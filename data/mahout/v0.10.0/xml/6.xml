<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:27:25 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-6/MAHOUT-6.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-6] Need a matrix implementation</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-6</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;We need matrices for Mahout.&lt;/p&gt;

&lt;p&gt;An initial set of basic requirements includes:&lt;/p&gt;

&lt;p&gt;a) sparse and dense support are required&lt;/p&gt;

&lt;p&gt;b) row and column labels are important&lt;/p&gt;

&lt;p&gt;c) serialization for hadoop use is required&lt;/p&gt;

&lt;p&gt;d) reasonable floating point performance is required, but awesome FP is not&lt;/p&gt;

&lt;p&gt;e) the API should be simple enough to understand&lt;/p&gt;

&lt;p&gt;f) it should be easy to carve out sub-matrices for sending to different reducers&lt;/p&gt;

&lt;p&gt;g) a reasonable set of matrix operations should be supported, these should eventually include:&lt;br/&gt;
    simple matrix-matrix and matrix-vector and matrix-scalar linear algebra operations, A B, A + B, A v, A + x, v + x, u + v, dot(u, v)&lt;br/&gt;
    row and column sums  &lt;br/&gt;
    generalized level 2 and 3 BLAS primitives, alpha A B + beta C and A u + beta v&lt;/p&gt;

&lt;p&gt;h) easy and efficient iteration constructs, especially for sparse matrices&lt;/p&gt;

&lt;p&gt;i) easy to extend with new implementations&lt;/p&gt;</description>
                <environment></environment>
        <key id="12389277">MAHOUT-6</key>
            <summary>Need a matrix implementation</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="gsingers">Grant Ingersoll</assignee>
                                    <reporter username="tdunning@veoh.com">Ted Dunning</reporter>
                        <labels>
                    </labels>
                <created>Fri, 22 Feb 2008 03:37:52 +0000</created>
                <updated>Sat, 21 May 2011 04:24:18 +0100</updated>
                            <resolved>Sat, 29 Mar 2008 21:10:37 +0000</resolved>
                                                    <fixVersion>0.1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12571273" author="tdunning@veoh.com" created="Fri, 22 Feb 2008 03:55:56 +0000"  >
&lt;p&gt;My own, non-portable, non-releasable matrix package uses a class structure something like Colt, but with a simpler extension structure:&lt;/p&gt;

&lt;p&gt;interface Matrix1D &amp;#8211; the basic interface including numerous convenience functions&lt;/p&gt;

&lt;p&gt;abstract class AbstractMatrix1D implements Matrix1D &amp;#8211; implementations of generic capabilities like sum of elements and dot products&lt;/p&gt;

&lt;p&gt;class DenseMatrix1D extends AbstractMatrix1D &amp;#8211; implements vector as an array of doubles with an offset and stride. used for vectors and views of sub-vectors and row or column views of dense matrices.&lt;/p&gt;

&lt;p&gt;class SparseBinaryVector extends AbstractMatrix1D &amp;#8211; implements vector that only &quot;stores&quot; 0 or 1, but only stores the 1&apos;s, but doesn&apos;t store them because it knows what their value is.  This is really a bit-vector implemented as a closed hash table that only holds integers.&lt;/p&gt;

&lt;p&gt;class SparseDoubleVector extends AbstractMatrix1D &amp;#8211; implements vector that only stores non-zero doubles&lt;/p&gt;



&lt;p&gt;interface Matrix2D &amp;#8211; the basic interface including convenience functions&lt;/p&gt;

&lt;p&gt;abstract class AbstractMatrix2D implements Matrix1D &amp;#8211; a few universal implementations of convenience functions mostly in terms of BLAS ops&lt;/p&gt;

&lt;p&gt;abstract class AbstractSparseMatrix2D extends AbstractMatrix2D &amp;#8211; efficient implementations of BLAS ops for generic sparse matrices&lt;/p&gt;

&lt;p&gt;abstract class AbstractDenseMatrix2D extends AbstractMatrix2D &amp;#8211; reasonably efficient implementations of BLAS ops for dense matrices&lt;/p&gt;

&lt;p&gt;class DenseMatrix2D extends ADM2D &amp;#8211; matrix of doubles implemented using a single 1D array with generic stride and offset.  Also used to hold transposed views and some kinds of sub-matrix views. &lt;/p&gt;

&lt;p&gt;class DoublyIndexedSparseBinary2D &amp;#8211; sparse matrix whose non-zero elements are all 1.  Fast row and column views are available through redundant storage.&lt;/p&gt;

&lt;p&gt;class SparseRowDouble2D &amp;#8211; sparse matrix with general element values whose rows are accessible quickly.  Implemented as an array of SparseDouble1D vectors.&lt;/p&gt;

&lt;p&gt;class SparseColumnDouble2D &amp;#8211; sparse matrix with general elements values whose columns are accessible quickly.&lt;/p&gt;


&lt;p&gt;Functions &amp;#8212; Matrices support updates using functional objects so that generic in-place updates can be done very efficiently.  I stole this idea from Colt.   In fact, my matrix package uses the Colt Functions object for my own matrix implementations which is one reason I can&apos;t distribute my own matrices very easily.&lt;/p&gt;

&lt;p&gt;Any comments on this general structure?  For machine learning, I have had very little call for complex numbers.  Some might take issue with my assumption that float&apos;s pretty much just don&apos;t exist, but for large problems, I find it imperative to retain precision more than save memory.&lt;/p&gt;</comment>
                            <comment id="12571279" author="jeastman" created="Fri, 22 Feb 2008 05:21:39 +0000"  >&lt;p&gt;+1, assuming you can come up with stories for all the leaves&amp;lt;grin&amp;gt;, the overall structure looks quite reasonable. I could probably start filling out a couple of the Matrix1D operations for clustering. Do you have any operations in mind for the interfaces?&lt;/p&gt;</comment>
                            <comment id="12571295" author="tdunning@veoh.com" created="Fri, 22 Feb 2008 07:55:48 +0000"  >
&lt;p&gt;Here is my set of methods for Matrix1D.  These are nearly identical to the functions used by Colt with the addition of some convenience methods.&lt;/p&gt;

&lt;p&gt;    double get(int index);&lt;br/&gt;
    void set(int index, double value);&lt;br/&gt;
    Matrix1D plus(double x);&lt;br/&gt;
    Matrix1D plus(Matrix1D x);&lt;br/&gt;
    Matrix1D minus(Matrix1D x);&lt;br/&gt;
    Matrix1D times(double x);&lt;br/&gt;
    // should this be element-wise or dot ... I think element-wise&lt;br/&gt;
    Matrix1D times(Matrix1D x);&lt;br/&gt;
    double dot(Matrix1D x);&lt;br/&gt;
    double zSum();&lt;/p&gt;

&lt;p&gt;    Matrix1D viewPart(int offset, int length);&lt;br/&gt;
    Matrix1D copy();&lt;/p&gt;

&lt;p&gt;    double getQuick(int index);&lt;br/&gt;
    void setQuick(int index, double value);&lt;/p&gt;

&lt;p&gt;    void getNonZeros(IntArrayList jx, DoubleArrayList values);&lt;br/&gt;
    void foreachNonZero(IntDoubleFunction f);&lt;/p&gt;

&lt;p&gt;    int size();&lt;br/&gt;
    int cardinality();&lt;/p&gt;

&lt;p&gt;    double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map);&lt;br/&gt;
    double aggregate(Matrix1D other, DoubleDoubleFunction aggregator, DoubleDoubleFunction map);&lt;/p&gt;

&lt;p&gt;    Matrix1D assign(double[] values);&lt;br/&gt;
    Matrix1D assign(double value);&lt;br/&gt;
    Matrix1D assign(DoubleFunction function);&lt;br/&gt;
    Matrix1D assign(Matrix1D other);&lt;br/&gt;
    Matrix1D assign(Matrix1D y, DoubleDoubleFunction function);&lt;br/&gt;
    NewMatrix1D assign(Matrix1D y,  DoubleDoubleFunction function, IntArrayList nonZeroIndexes);&lt;/p&gt;

&lt;p&gt;    boolean haveSharedCells(Matrix1D other);&lt;/p&gt;

&lt;p&gt;    Matrix1D like();&lt;br/&gt;
    Matrix1D like(int n);&lt;/p&gt;

&lt;p&gt;    double[] toArray();&lt;/p&gt;</comment>
                            <comment id="12571450" author="tdunning@veoh.com" created="Fri, 22 Feb 2008 16:11:23 +0000"  >
&lt;p&gt;The different matrix API&apos;s have differed on this.&lt;/p&gt;

&lt;p&gt;The goal to have easy extensibility implies that either these operations happen in one of the abstract classes or that they live in a different place.&lt;/p&gt;

&lt;p&gt;Many of these algorithms take the form of a matrix implementation.  For instance, all of the factorizations like eigenvector or singular vector or QR or LU decomposition are nominally a matrix that has internal parts which are useful sometimes in their own right (eigenvalues) or which facilitate some common operation (back-sub in LU, least squares for QR).  For all of them, however, you can do multiplications and additions and such (just not destructive mult and add).&lt;/p&gt;

&lt;p&gt;As such, the approach of having special matrix types that are actually decompositions is pretty attractive.  The destructive ops can throw unimplemented operation exceptions (which is the default at the highest abstract matrix level anyway) and they can add some additional API elements for their special capabilities.  Whether constructors or factor methods are better is an open question in my mind.&lt;/p&gt;


&lt;p&gt;On 2/22/08 6:38 AM, &quot;Grant Ingersoll&quot; &amp;lt;gsingers@apache.org&amp;gt; wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Any thoughts about where support belongs for things like calculating  &lt;br/&gt;
&amp;gt; eigenvalues/vectors and/or *Rank algorithms that rely on an iterative  &lt;br/&gt;
&amp;gt; operations on a matrix/graph, etc.?    Seems like they can be  &lt;br/&gt;
&amp;gt; generalized, but not sure if they are first class citizens on a Matrix  &lt;br/&gt;
&amp;gt; implementation or not.&lt;/p&gt;
</comment>
                            <comment id="12571799" author="jeastman" created="Sat, 23 Feb 2008 23:13:36 +0000"  >&lt;p&gt;Here&apos;s a minimal implementation of Matrix1D methods and tests that will be adequate to replace Point and Float[] in the clustering code. I did not implement all of Ted&apos;s suggestions as I did not understand them and/or there were missing classes. There are a couple of issues it raises:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I made all the methods side-effect free, returning new instances from all operations. This will exercise the garbage collector but eliminate difficult debugging problems. It also seems consistent with the functional programming roots of map/reduce.&lt;/li&gt;
	&lt;li&gt;I implemented no checking of cardinality sameness or division by zero so these are needed. The question in my mind is whether to use checked exceptions or runtime exceptions. There really is no valid use case I can think of for the former but I await comments before acting.&lt;/li&gt;
	&lt;li&gt;I added divide(), normalize(), asFormatString() and a decodeFormat static which are needed by clustering&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will wait until MAHOOT-5 gets committed before beginning the refactoring since it will be a major change from the latest working patch and it really needs this stuff in trunk too before beginning.&lt;/p&gt;</comment>
                            <comment id="12571883" author="paul.elschot@xs4all.nl" created="Sun, 24 Feb 2008 09:46:51 +0000"  >&lt;p&gt;I had a quick look at the latest patch, the 6b.diff. &lt;br/&gt;
It looks good, but I see one possible issue in there: the use of java interfaces.&lt;br/&gt;
The problem with interfaces is that once they are implemented somewhere outside of a code base, there is no way to change them inside that code base without breaking something outside. In other words, public interfaces are forever, and it may be a bit too soon for that.&lt;br/&gt;
So the question is whether it would be better to use public abstract classes instead of public interfaces. &lt;/p&gt;

&lt;p&gt;Also I&apos;d like to have a sparse 2D matrix implementation on top of a Lucene index with term vectors, but that appears to be no problem, and it&apos;s better handled as another issue.&lt;br/&gt;
It&apos;s related to labeling rows and columns though. Lucene docs could be labeled by a primary key value, and lucene features could be labeled by their term values, possibly combined with the term field. (Roughly, in Lucene, a document consists of several fields, each field having indexed terms. A term vector in Lucene consists of all the term values and frequencies for a field of a document.)&lt;/p&gt;</comment>
                            <comment id="12571923" author="tdunning@veoh.com" created="Sun, 24 Feb 2008 18:41:22 +0000"  >
&lt;p&gt;Paul,&lt;/p&gt;

&lt;p&gt;Can you amplify a bit on how you see the difference between interfaces and abstract classes?&lt;/p&gt;

&lt;p&gt;It is absolutely true that interfaces can only be changed delicately, but at this stage I think that everybody understands that.  But why is a public abstract class any different?&lt;/p&gt;

&lt;p&gt;I should also say that the interface is definitely incomplete as it says nothing about labeling of rows and columns, nor does it have any way to find out if a matrix is sparse, nor whether a sparse matrix has fast column or row viewing.  All are pretty important, but all are additions to this API, rather than changes.&lt;/p&gt;

&lt;p&gt;Finally, I have a little problem in viewing a lucene index itself as a single matrix.  I would propose an interface in which a lucene index is a factory which constructs matrices that  are linear combinations of fields of the lucene matrix.  There should also be some way to view the native retrieval operation of the lucene index as matrix multiplication.  &lt;/p&gt;

</comment>
                            <comment id="12571927" author="tdunning@veoh.com" created="Sun, 24 Feb 2008 18:58:56 +0000"  >&lt;p&gt;&lt;br/&gt;
See &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-7&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/MAHOUT-7&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12571965" author="paul.elschot@xs4all.nl" created="Sun, 24 Feb 2008 21:35:16 +0000"  >&lt;p&gt;Ted,&lt;/p&gt;

&lt;p&gt;An abstract class differs from an interface in that one can easily:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;add a public method with a default implementation, and&lt;/li&gt;
	&lt;li&gt;deprecate a method.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;See also (but not only):&lt;br/&gt;
&lt;a href=&quot;http://faq.javaranch.com/java/InterfaceVsAbstractClass&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://faq.javaranch.com/java/InterfaceVsAbstractClass&lt;/a&gt;&lt;br/&gt;
This mentions a.o.:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;use an interface if you&apos;re sure the API is stable for the long run&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And thanks for opening &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-7&quot; title=&quot;Lucene indexes should act as matrix factories&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-7&quot;&gt;&lt;del&gt;MAHOUT-7&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12571966" author="tdunning@veoh.com" created="Sun, 24 Feb 2008 21:35:46 +0000"  >
&lt;p&gt;Regarding the 6b diff, the intent of the view functions is to return a reference to the same underlying storage so that in place updates of parts of a matrix or vector can be done.  This is actually pretty important for performance in some cases and it pretty massively simplifies the API.&lt;/p&gt;

&lt;p&gt;This means that it is much simpler for the Dense1D implementation to have a reference to a double[], an offset and a stride.  That means that views are easy.  Likewise, the Dense2D implementation should have a reference to a double[], an offset and a column and row stride.  This allows many views such as transpose, diagonals, rows and columns to allow be really simple.  It also allows column or row major memory layout (if we ever get to the point we care that much).  You can even handle banded matrices pretty well with this layout, although you need a teensy bit of logic to make sure that out-of-band references return zeros.  &lt;/p&gt;

&lt;p&gt;The purpose, btw, of the get/set Quick methods is that if there is some sort of size checking (as there really has to be since array bounds checking won&apos;t necessary catch out of range references in views), then the quick alternatives can be used to avoid the checks.  This allows the range checks to be factored out of some inner loops with obvious benefit in any case where the compiler is less than genius level.&lt;/p&gt;</comment>
                            <comment id="12571972" author="tdunning@veoh.com" created="Sun, 24 Feb 2008 22:05:11 +0000"  >
&lt;p&gt;Regarding Paul&apos;s comments about interfaces versus abstract classes, I prefer to use interfaces here, but provide abstract classes that most people will inherit from.  &lt;/p&gt;

&lt;p&gt;In that case, updates to the interface come (mostly) in two flavors:&lt;/p&gt;

&lt;p&gt;a) convenience updates that can easily be implemented in the abstract classes.  Very few implementors will be hurt here because they won&apos;t even notice that their classes suddenly have new functionality.&lt;/p&gt;

&lt;p&gt;b) substantial and important functionality that was overlooked at first. Changing the interface has the desired effect of forcing implementors to support this functionality.  If the functionality isn&apos;t required of all implementations, then it can be declared in the abstract with gives the desired effect. &lt;/p&gt;</comment>
                            <comment id="12572112" author="jeastman" created="Mon, 25 Feb 2008 16:10:32 +0000"  >&lt;p&gt;On the point about interfaces, the current diff has both interfaces and abstract classes. I understand the brittleness that interfaces can introduce and have seen recent comments about challenges introduced by their evolution on the Hadoop list. I suggest we retain both artifacts for now while we are in a pre-release phase and continue this discussion. It would be a little work to remove the interfaces later but I do not see a reason to remove them now.&lt;/p&gt;

&lt;p&gt;On the view functions, I can see their value but not yet their explicit need in any submitted algorithms. Following agile practices, I would suggest tabling their implementation until such an explicit need does materialize. I do think the question of side-effects I raised earlier will be affected by any sharing of underlying data structures and invite further discussion thereof.&lt;/p&gt;

&lt;p&gt;On the fast methods that avoid the range checking that is currently missing, do we want to introduce checked exceptions or use runtime exceptions? I do not see any reasonable use case where recovery from such a condition would be a common practice. OTOH, introducing checked exceptions on the current methods and not having them on the fast methods would certainly make the difference between the methods more apparent.&lt;/p&gt;</comment>
                            <comment id="12572120" author="jeastman" created="Mon, 25 Feb 2008 16:31:34 +0000"  >&lt;p&gt;Well, here&apos;s a story that suggests using checked exceptions would be valuable:&lt;/p&gt;

&lt;p&gt;User is processing large volumes of vector data that contain some encoding errors causing some input vectors to be too small. User wishes to detect these conditions in order to be able to omit the records without aborting the computation.&lt;/p&gt;</comment>
                            <comment id="12572235" author="jeastman" created="Mon, 25 Feb 2008 21:05:10 +0000"  >&lt;p&gt;Based upon my above story I decided to add checked exceptions to the Matrix1D interface. Needing some more efficient operations to avoid the bounds checking in the inner loops, I implemented the Quick operations too, as well as zSum(). Comments on my name choices (and Ted&apos;s too) are always fair game.&lt;/p&gt;

&lt;p&gt;I&apos;m still being lazy about the view operations while we discuss side-effects.&lt;/p&gt;

&lt;p&gt;All unit tests run.&lt;/p&gt;</comment>
                            <comment id="12572248" author="tdunning@veoh.com" created="Mon, 25 Feb 2008 21:38:12 +0000"  >
&lt;p&gt;Btw, the easiest Mahout user story for views is parallel multiplication (= coocurrence counting).&lt;/p&gt;

&lt;p&gt;To multiply A&apos; * B, one way is to reduce on columns of A modulo some number that is about 2-5x the number of reducers which should about the number of cores to be used.  The map would emit copies of B, one for each reduce key.  Then it should emit columns of A keyed by the column number modulo the reduce key count.  &lt;/p&gt;

&lt;p&gt;It is highly desirable to:&lt;/p&gt;

&lt;p&gt;a) not write a special serializer for columns of a matrix ... the serializer for vectors should do.&lt;/p&gt;

&lt;p&gt;b) not copy columns of A before serializer.&lt;/p&gt;

&lt;p&gt;Column views give us what we need.  By symmetry, we should have row views, of course.  Also, if you have the machinery for row and column views, sub-matrix views are trivial additions.&lt;/p&gt;

&lt;p&gt;Views can be done many ways.  One way is with a view wrapper, and this can be used at the abstract matrix level to get views for free for new implementations.  For many kinds of matrix, it is desirable to have a special purpose view to avoid the wrapper overhead.  Dense matrices based on strided access to an array of values, for instance, can support views with no additional mechanism and without any appreciable overhead other than memory locality issues.  Most sparse representations can provide either row or column views very cheaply as well.&lt;/p&gt;</comment>
                            <comment id="12572339" author="jeastman" created="Tue, 26 Feb 2008 01:46:33 +0000"  >&lt;p&gt;This patch adds a Matrix1DView wrapper and tests thereof. In order to avoid side effects, calling the setQuick method throws an UnsupportedOperationException and copy materializes a new DenseMatrix1D, not another view. This is consistent with the read-onliness of most view abstractions and allows all of the abstract matrix operations to work. Views can be made of any MatrixID, and this includes views of views, which share the same underlying Matrix1D.&lt;/p&gt;

&lt;p&gt;Am I too hung-up on no side-effects?&lt;/p&gt;</comment>
                            <comment id="12572340" author="tdunning@veoh.com" created="Tue, 26 Feb 2008 02:07:06 +0000"  >&lt;p&gt;Yes, you are too hung up on no side-effects!&lt;/p&gt;

&lt;p&gt;Ability to do destructive operations via views is critical to almost any decomposition algorithm (QR, LU, Lanczos).&lt;/p&gt;

&lt;p&gt;The author of Colt made a persuasive case that mutation by views was critical for performance without a HUGE api.  Take for instance, the common operation of zero-ing out a column.  With a Colt style (mutable view) API, this is done as:&lt;/p&gt;

&lt;p&gt;    A.viewColumn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.assign(0)&lt;/p&gt;

&lt;p&gt;Zeroing out a row is done this way:&lt;/p&gt;

&lt;p&gt;    A.viewRow&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.assign(0)&lt;/p&gt;

&lt;p&gt;But what about adding a vector to a particular row?&lt;/p&gt;

&lt;p&gt;    A.viewRow&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.assign(v, Function.plus)&lt;/p&gt;

&lt;p&gt;Or zeroing out a sub-matrix:&lt;/p&gt;

&lt;p&gt;    A.viewBlock(tl, br, width, height).assign(0).&lt;/p&gt;

&lt;p&gt;IF you don&apos;t have these mutable views one of two things happens.&lt;/p&gt;

&lt;p&gt;Either:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the programmer calls set a LOT resulting in really, really slow code that the optimizer can&apos;t handle,&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Or&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the API becomes (literally) exponentially larger because every common mutation such as setting to zero, incrementing by a constant, adding a vector and so on gets multiplied by the number of kinds of pieces that you want to work on.  In fact, it is a good idea to factor out the kind of mutation as well, just as Colt does.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;On 2/25/08 5:47 PM, &quot;Jeff Eastman (JIRA)&quot; &amp;lt;jira@apache.org&amp;gt; wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Am I too hung-up on no side-effects?&lt;/p&gt;</comment>
                            <comment id="12572566" author="jeastman" created="Tue, 26 Feb 2008 17:26:43 +0000"  >&lt;p&gt;Ok, I get the case for side-effects. It is a line to be crossed with eyes open and this diff does just that. In addition to semantic changes in copy, setQuick and viewPart I&apos;ve implemented the assign operations (and unit tests too).&lt;/p&gt;
</comment>
                            <comment id="12572716" author="jeastman" created="Tue, 26 Feb 2008 23:34:17 +0000"  >&lt;p&gt;Here&apos;s another patch with like() and haveSharedCells() implemented and tested. I also implemented an initial SparseDoubleVector using a Map&amp;lt;Integer, Double&amp;gt; and tests for it. It uses a HashMap, is that ok with you?&lt;/p&gt;

&lt;p&gt;Could you provide some more insight into the remaining functions? The SparseBinaryVector seems pretty special purpose and I imagine you have a proposal for its implementation. Could you please discribe that?&lt;/p&gt;

&lt;p&gt;Both of these vector classes beg the question of why DenseMatrix1D is not called DenseVector instead. Comments?&lt;/p&gt;</comment>
                            <comment id="12572720" author="tdunning@veoh.com" created="Tue, 26 Feb 2008 23:46:54 +0000"  >
&lt;p&gt;A hash map is a great first implementation for a sparse vector.  Ultimately,&lt;br/&gt;
it will need to be replaced, but delaying that day is a good thing.  Also, a&lt;br/&gt;
really efficient structure is a pain in the ass to get exactly right.  The&lt;br/&gt;
hash map you have will work right off the bat.&lt;/p&gt;

&lt;p&gt;The primary use of SparseBinaryVector is as a row or column of a&lt;br/&gt;
SparseBinaryMatrix.  A binary matrix is useful in cases where reduction to&lt;br/&gt;
binary values makes sense (many behavioral analysis cases are good for that,&lt;br/&gt;
as are many text analysis cases).  It only makes sense, however, when there&lt;br/&gt;
is beginning to be serious memory pressure since its virtue is that you save&lt;br/&gt;
8 bytes per value.  That can be 2/3 of the storage of some matrices.  For&lt;br/&gt;
some of my key programs, I need fast row and column access to very lare&lt;br/&gt;
binary matrices and getting 3x larger matrices to fit in memory (and buying&lt;br/&gt;
more memory) really helped.&lt;/p&gt;

&lt;p&gt;I used Matrix1D out of inertia from Colt.  The only virtue to the notation&lt;br/&gt;
is that it makes sense to go eventually to Matrix3D and Matrix4D, but the&lt;br/&gt;
vector terminology is so well known that I wouldn&apos;t think it a problem.&lt;br/&gt;
Nobody is ever going to be confused.  Some purists might object that a&lt;br/&gt;
vector is an object from linear algebra whereas what we have is a&lt;br/&gt;
single-indexed array with a few linear algebra operations tacked on.  I am&lt;br/&gt;
not a purist.&lt;/p&gt;


</comment>
                            <comment id="12573467" author="jeastman" created="Thu, 28 Feb 2008 21:40:48 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Renamed Matrix1D to Vector and Matrix2D to Matrix, in all interfaces and classes where they occurred&lt;/li&gt;
	&lt;li&gt;Removed Double (typename) from all artifacts&lt;/li&gt;
	&lt;li&gt;Moved all Vector artifacts into a new utils.vector package.&lt;/li&gt;
	&lt;li&gt;Implemented UnaryFunction and BinaryFunction interfaces&lt;/li&gt;
	&lt;li&gt;Implemented Negate and Plus functions for unit tests&lt;/li&gt;
	&lt;li&gt;Moved all function artifacts into a new utils.function package&lt;/li&gt;
	&lt;li&gt;Moved the two exceptions to utils&lt;/li&gt;
	&lt;li&gt;Implemented assign operations on functions and unit tests for all concrete classes&lt;/li&gt;
	&lt;li&gt;Removed the DenseBinaryVector for now until we converge on generics or not&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All unit tests run.&lt;/p&gt;

&lt;p&gt;It looks pretty clean now, for Vector at least. Time to start thinking about Matrix.&lt;/p&gt;</comment>
                            <comment id="12574068" author="gsingers" created="Sat, 1 Mar 2008 04:14:04 +0000"  >&lt;p&gt;minor updates to Vector, mostly javadocs.  Also added in a start to a Vector test for sanity purposes.&lt;/p&gt;</comment>
                            <comment id="12574138" author="jeastman" created="Sat, 1 Mar 2008 18:51:48 +0000"  >&lt;p&gt;Initial implementation of Matrices and unit tests based upon the spirit of Vector. This needs to be merged with Grant&apos;s tweaks to Vector.&lt;/p&gt;</comment>
                            <comment id="12574737" author="jeastman" created="Mon, 3 Mar 2008 21:14:44 +0000"  >&lt;p&gt;Sorted out the two patches and added back my Vector unit tests that fell out due to an oversight. Couldn&apos;t resist adding a cross() operation on vectors but I&apos;m going to do something else for a while to let people review this and let the dust settle.  Once we get vectors into trunk I will update the clustering code to use them.&lt;/p&gt;</comment>
                            <comment id="12576034" author="jrennie" created="Fri, 7 Mar 2008 04:38:50 +0000"  >&lt;p&gt;Hmm... a HashMap SparseVector implementation is certainly flexible, but also quite inefficient both in terms of space and in terms of the basic vector/matrix operations (e.g. dot-product).  What about a (second?) representation as an int[] of indices and a double[] of value, where the indices are stored in sorted order?  This makes dot-products efficient and greatly reduces storage space.  &apos;course, this makes get/set (very) slow, but I think the tradeoff is valuable.  At least, when I tested a HashMap implementation (might have been the colt one), it was completely impractical for my work (waaaaay too slow, IIRC).  The int[], double[] representation is what I use now and it serves me well.&lt;/p&gt;

&lt;p&gt;Btw, since there likely to be multiple implementations of a SparseVector, can we rename SparseVector to SparseVectorHashMap or some such?&lt;/p&gt;</comment>
                            <comment id="12576037" author="jeastman" created="Fri, 7 Mar 2008 04:56:37 +0000"  >&lt;p&gt;Boy, I am sure not wedded to the HashMap implementation. From my Smalltalk experience, one hash lookup like that is equivalent to about 40 iterations down a fixed array. Unless the vector cardinality is very large and mostly not sparse (size ~ cardinality), your implementation will likely outperform mine. I was coding stream-of-consciousness and picked only the most obvious and simplest to code approach for everything. Please feel free to propose a patch with your alternative. If you could include a unit test that measures the tradeoff point between iterating and hashing in the current jdk, it would be quite informative and even more compelling.&lt;/p&gt;

&lt;p&gt;I&apos;m ok with either introducing another sparse implementation, or changing the current one. I do think we ought to make these sorts of changes based upon empirical data and agreed upon user stories.&lt;/p&gt;

&lt;p&gt;I do think we ought to get something into trunk soon so that the patch merging hassle is behind us.&lt;/p&gt;</comment>
                            <comment id="12576283" author="tdunning@veoh.com" created="Fri, 7 Mar 2008 17:25:48 +0000"  >
&lt;p&gt;Hashmaps in Java are surprisingly fast (very nearly 1 array access).&lt;/p&gt;

&lt;p&gt;Their real cost is memory size and locality of reference.  Rennies sorted&lt;br/&gt;
index suggest is very tight on memory and is good for sequential accesses.&lt;br/&gt;
Random access isn&apos;t all &lt;b&gt;that&lt;/b&gt; bad since binary search is available.  My&lt;br/&gt;
experience is similar to his... sequential scanning is vastly more important&lt;br/&gt;
than random access.&lt;/p&gt;

&lt;p&gt;One point I would suggest, however, is to allow the vector to be unsorted&lt;br/&gt;
until it needs to be in order.  That allows fast filling of the vector&lt;br/&gt;
followed by a single sort the first time sequential scanning or random&lt;br/&gt;
access is done.&lt;/p&gt;



</comment>
                            <comment id="12576371" author="jrennie" created="Fri, 7 Mar 2008 20:58:02 +0000"  >&lt;p&gt;Re: Jeff&lt;/p&gt;

&lt;p&gt;Sounds good.  It think I might actually have some time to do this.  One thing I didn&apos;t see when looking through the last patch was basic matrix/vector operations.  I&apos;ll go ahead and include a dot-product method to exhibit how it&apos;d work and do some speed comparisons vs. a HashMap impl.&lt;/p&gt;

&lt;p&gt;Yeah, would definitely be good to get this stuff in trunk, if only to make it easier to read/access! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Re: Ted&lt;/p&gt;

&lt;p&gt;Didn&apos;t realize HashMaps were so fast.  Will be good to revisit the testing I did earlier.  Agreed on the CRS benefits.&lt;/p&gt;

&lt;p&gt;One way I get around the sorted constraint while constructing a sparse vector is a SparseVectorBuilder class.  It basically has two methods: void add(int _idx, double _val), and SparseVector build().  Avoids having to keep state within the SparseVector.&lt;/p&gt;</comment>
                            <comment id="12576381" author="jrennie" created="Fri, 7 Mar 2008 21:32:19 +0000"  >&lt;p&gt;Btw, noticed the matrix stuff is currently under utils.matrix and utils.vector.  The matrix package is so important that I&apos;d think we&apos;d want it to have it&apos;s own package (org.apache.mahout.matrix).  Also, we should not separate vector/matrix classes into separate packages b/c matrix-vector products will likely need to access protected members of both classes for efficient operation.  Ted, Jeff, do you agree, or am I missing something here?&lt;/p&gt;</comment>
                            <comment id="12576402" author="jrennie" created="Fri, 7 Mar 2008 22:09:47 +0000"  >&lt;p&gt;Hmm... actually, the HashMap implementation doubles nicely as the builder for the CRS implementation.&lt;/p&gt;</comment>
                            <comment id="12576495" author="tdunning@veoh.com" created="Sat, 8 Mar 2008 06:13:48 +0000"  >
&lt;p&gt;I agree that they should be together.&lt;/p&gt;

&lt;p&gt;I don&apos;t know whether that is the correct rationale, but I am sure one will&lt;br/&gt;
come up.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;



</comment>
                            <comment id="12576508" author="jeastman" created="Sat, 8 Mar 2008 07:42:51 +0000"  >&lt;p&gt;Moved all Vector and Matrix artifacts into a new org.apache.mahout.matrix package so they are back together again.&lt;br/&gt;
Renamed asFormatString() to asWritableComparable() and adjusted initial implementation to return Text.&lt;br/&gt;
Updated unit tests to changes.&lt;br/&gt;
All tests still run.&lt;/p&gt;

&lt;p&gt;Let&apos;s continue the discussion on HashMap and/or array optimizations with some tests to generate empirical data.&lt;/p&gt;</comment>
                            <comment id="12576533" author="gsingers" created="Sat, 8 Mar 2008 12:41:07 +0000"  >&lt;p&gt;Adds ASL headers, fixes testWritableComparable test to pass.  Will commit in tomorrow so that we can start seeing how this works in real life.&lt;/p&gt;</comment>
                            <comment id="12576985" author="jrennie" created="Mon, 10 Mar 2008 13:42:22 +0000"  >&lt;p&gt;Ted, I am a bit surprised how speedy the HashMap impl. is! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  2-3x slower than the CRS impl, but much better than I thought.  Would be good to test a primitive HashMap (int, double).  Might be as fast as the CRS version and much more flexible.  I&apos;m gonna just drop the code in here.  Besides the two vector classes and test class, you&apos;ll also find StopWatch, the code I used to do the timing.  One thing I didn&apos;t do was to check much time was wasted by the StopWatch code...&lt;/p&gt;

&lt;p&gt;import java.util.Random;&lt;/p&gt;

&lt;p&gt;import junit.framework.TestCase;&lt;/p&gt;

&lt;p&gt;import org.apache.log4j.Logger;&lt;/p&gt;

&lt;p&gt;public class SparseVectorPerformanceTests extends TestCase {&lt;/p&gt;

&lt;p&gt;	private static final Logger log = Logger.getLogger(SparseVectorPerformanceTests.class);&lt;/p&gt;

&lt;p&gt;	Random rand = new Random();&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished HashMap dot product in 4.161 seconds.&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished CRS dot product in 2.340 seconds.&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=50 nnz2=200&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished HashMap dot product in 6.482 seconds.&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished CRS dot product in 2.663 seconds.&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=100 nnz2=100&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;br/&gt;
	 */&lt;br/&gt;
	public void testSparseVectorPerformance() throws Exception {&lt;br/&gt;
		StopWatch hmvSW = new StopWatch(&quot;HashMap dot product&quot;, log, false);&lt;br/&gt;
		StopWatch crsSW = new StopWatch(&quot;CRS dot product&quot;, log, false);&lt;br/&gt;
		final int numTrials = 1000000;&lt;br/&gt;
		final int vectorSize = 1000;&lt;br/&gt;
		final int nnz1 = 100;&lt;br/&gt;
		final int nnz2 = 100;&lt;br/&gt;
		for (int i = 0; i &amp;lt; numTrials; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {			SparseVectorHashMap hmv1 = new SparseVectorHashMap();			SparseVectorHashMap hmv2 = new SparseVectorHashMap();			for (int j = 0; j &amp;lt; nnz1; ++j) {
				hmv1.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
			}&lt;br/&gt;
			for (int j = 0; j &amp;lt; nnz2; ++j) {
				hmv2.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
			}&lt;br/&gt;
			SparseVectorCRS crsv1 = hmv1.buildSparseVector();&lt;br/&gt;
			SparseVectorCRS crsv2 = hmv2.buildSparseVector();&lt;br/&gt;
			hmvSW.start();&lt;br/&gt;
			hmv1.dot(hmv2);&lt;br/&gt;
			hmvSW.stop();&lt;br/&gt;
			crsSW.start();&lt;br/&gt;
			crsv1.dot(crsv2);&lt;br/&gt;
			crsSW.stop();&lt;br/&gt;
		}&lt;br/&gt;
		hmvSW.logEndMessage();&lt;br/&gt;
		crsSW.logEndMessage();&lt;br/&gt;
		log.debug(&quot;numTrials=&quot; + numTrials + &quot; vectorSize=&quot; + vectorSize + &quot; nnz1=&quot; + nnz1 + &quot; nnz2=&quot; + nnz2);&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
	public void testSparseVectorCorrectness() throws Exception {&lt;br/&gt;
		final int vectorSize = 100;&lt;br/&gt;
		final int nnz = 10;&lt;br/&gt;
		SparseVectorHashMap hmv1 = new SparseVectorHashMap();&lt;br/&gt;
		SparseVectorHashMap hmv2 = new SparseVectorHashMap();&lt;br/&gt;
		for (int j = 0; j &amp;lt; nnz; ++j) {
			hmv1.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
			hmv2.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
		}&lt;br/&gt;
		SparseVectorCRS crsv1 = hmv1.buildSparseVector();&lt;br/&gt;
		SparseVectorCRS crsv2 = hmv2.buildSparseVector();&lt;br/&gt;
		double hmvDot = hmv1.dot(hmv2);&lt;br/&gt;
		double vDot = crsv1.dot(crsv2);&lt;br/&gt;
		assertTrue(hmvDot == vDot);&lt;br/&gt;
		log.debug(hmvDot);&lt;br/&gt;
		log.debug(vDot);&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
import java.util.ArrayList;&lt;br/&gt;
import java.util.Collections;&lt;br/&gt;
import java.util.HashMap;&lt;br/&gt;
import java.util.List;&lt;br/&gt;
import java.util.Map;&lt;br/&gt;
&lt;br/&gt;
public class SparseVectorHashMap {&lt;br/&gt;
&lt;br/&gt;
	Map&amp;lt;Integer, Double&amp;gt; data;&lt;br/&gt;
&lt;br/&gt;
	public SparseVectorHashMap() {
		this.data = new HashMap&amp;lt;Integer, Double&amp;gt;();
	}&lt;br/&gt;
&lt;br/&gt;
	public SparseVectorCRS buildSparseVector() {&lt;br/&gt;
		int size = this.data.size();&lt;br/&gt;
		int[] index = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
		double[] value = new double&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
		List&amp;lt;Integer&amp;gt; keyList = new ArrayList&amp;lt;Integer&amp;gt;(this.data.keySet());&lt;br/&gt;
		Collections.sort(keyList);&lt;br/&gt;
		for (int i = 0; i &amp;lt; size; ++i) {
			Integer indexInteger = keyList.get(i);
			index[i] = indexInteger.intValue();
			value[i] = this.data.get(indexInteger).doubleValue();
		}&lt;br/&gt;
		return new SparseVectorCRS(index, value);&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
	public void set(Integer _index, Double _value) {
		this.data.put(_index, _value);
	}&lt;br/&gt;
&lt;br/&gt;
	/**&lt;br/&gt;
	 * Assumption: _smaller.size() &amp;lt; _larger.size()&lt;br/&gt;
	 * &lt;br/&gt;
	 * @param _smaller&lt;br/&gt;
	 *            data entry of SparseVectorHashMap&lt;br/&gt;
	 * @param _larger&lt;br/&gt;
	 *            data entry of SparseVectorHashMap&lt;br/&gt;
	 * @return dot-product of corresponding vectors&lt;br/&gt;
	 */&lt;br/&gt;
	static private double dot(Map&amp;lt;Integer, Double&amp;gt; _smaller, Map&amp;lt;Integer, Double&amp;gt; _larger) {&lt;br/&gt;
		double retval = 0.0;&lt;br/&gt;
		for (Map.Entry&amp;lt;Integer, Double&amp;gt; smallEntry : _smaller.entrySet()) {&lt;br/&gt;
			Double largeValue = _larger.get(smallEntry.getKey());&lt;br/&gt;
			if (largeValue != null) {
				retval += largeValue.doubleValue() * smallEntry.getValue().doubleValue();
			}&lt;br/&gt;
		}&lt;br/&gt;
		return retval;&lt;br/&gt;
	}&lt;br/&gt;
&lt;br/&gt;
	/**&lt;br/&gt;
	 * @param _v&lt;br/&gt;
	 * @return dot-product of this vector with _v&lt;br/&gt;
	 */&lt;br/&gt;
	public double dot(SparseVectorHashMap _v) {&lt;br/&gt;
		if (this.data.size() &amp;lt; _v.data.size()) {
			return dot(this.data, _v.data);
		}&lt;br/&gt;
		return dot(_v.data, this.data);&lt;br/&gt;
	}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
import java.util.Random;&lt;br/&gt;
&lt;br/&gt;
import junit.framework.TestCase;&lt;br/&gt;
&lt;br/&gt;
import org.apache.log4j.Logger;&lt;br/&gt;
&lt;br/&gt;
public class SparseVectorPerformanceTests extends TestCase {&lt;br/&gt;
&lt;br/&gt;
	private static final Logger log = Logger.getLogger(SparseVectorPerformanceTests.class);&lt;br/&gt;
&lt;br/&gt;
	Random rand = new Random();&lt;br/&gt;
&lt;br/&gt;
	/**&lt;br/&gt;
	 * &amp;lt;ul&amp;gt;&lt;br/&gt;
	 * &amp;lt;li&amp;gt; Finished HashMap dot product in 4.161 seconds.&lt;br/&gt;
	 * &amp;lt;li&amp;gt; Finished CRS dot product in 2.340 seconds.&lt;br/&gt;
	 * &amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=50 nnz2=200&lt;br/&gt;
	 * &amp;lt;/ul&amp;gt;&lt;br/&gt;
	 * &amp;lt;ul&amp;gt;&lt;br/&gt;
	 * &amp;lt;li&amp;gt; Finished HashMap dot product in 6.482 seconds.&lt;br/&gt;
	 * &amp;lt;li&amp;gt; Finished CRS dot product in 2.663 seconds.&lt;br/&gt;
	 * &amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=100 nnz2=100&lt;br/&gt;
	 * &amp;lt;/ul&amp;gt;&lt;br/&gt;
	 */&lt;br/&gt;
	public void testSparseVectorPerformance() throws Exception {&lt;br/&gt;
		StopWatch hmvSW = new StopWatch(&quot;HashMap dot product&quot;, log, false);&lt;br/&gt;
		StopWatch crsSW = new StopWatch(&quot;CRS dot product&quot;, log, false);&lt;br/&gt;
		final int numTrials = 1000000;&lt;br/&gt;
		final int vectorSize = 1000;&lt;br/&gt;
		final int nnz1 = 100;&lt;br/&gt;
		final int nnz2 = 100;&lt;br/&gt;
		for (int i = 0; i &amp;lt; numTrials; ++i) {&lt;br/&gt;
			SparseVectorHashMap hmv1 = new SparseVectorHashMap();&lt;br/&gt;
			SparseVectorHashMap hmv2 = new SparseVectorHashMap();&lt;br/&gt;
			for (int j = 0; j &amp;lt; nnz1; ++j) {
				hmv1.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
			}			for (int j = 0; j &amp;lt; nnz2; ++j) {
				hmv2.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
			}			SparseVectorCRS crsv1 = hmv1.buildSparseVector();			SparseVectorCRS crsv2 = hmv2.buildSparseVector();			hmvSW.start();			hmv1.dot(hmv2);			hmvSW.stop();			crsSW.start();			crsv1.dot(crsv2);			crsSW.stop();		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;		hmvSW.logEndMessage();&lt;br/&gt;
		crsSW.logEndMessage();&lt;br/&gt;
		log.debug(&quot;numTrials=&quot; + numTrials + &quot; vectorSize=&quot; + vectorSize + &quot; nnz1=&quot; + nnz1 + &quot; nnz2=&quot; + nnz2);&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public void testSparseVectorCorrectness() throws Exception {&lt;br/&gt;
		final int vectorSize = 100;&lt;br/&gt;
		final int nnz = 10;&lt;br/&gt;
		SparseVectorHashMap hmv1 = new SparseVectorHashMap();&lt;br/&gt;
		SparseVectorHashMap hmv2 = new SparseVectorHashMap();&lt;br/&gt;
		for (int j = 0; j &amp;lt; nnz; ++j) &lt;/p&gt;
{
			hmv1.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
			hmv2.set(this.rand.nextInt(vectorSize) + 1, this.rand.nextDouble());
		}
&lt;p&gt;		SparseVectorCRS crsv1 = hmv1.buildSparseVector();&lt;br/&gt;
		SparseVectorCRS crsv2 = hmv2.buildSparseVector();&lt;br/&gt;
		double hmvDot = hmv1.dot(hmv2);&lt;br/&gt;
		double vDot = crsv1.dot(crsv2);&lt;br/&gt;
		assertTrue(hmvDot == vDot);&lt;br/&gt;
		log.debug(hmvDot);&lt;br/&gt;
		log.debug(vDot);&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;import org.apache.log4j.Logger;&lt;/p&gt;

&lt;p&gt;public class StopWatch {&lt;/p&gt;

&lt;p&gt;	enum StopWatchState &lt;/p&gt;
{ RUNNING, STOPPED }

&lt;p&gt;	static final double meg = 1024.0 * 1024.0;&lt;/p&gt;

&lt;p&gt;	long t0;&lt;/p&gt;

&lt;p&gt;	String action;&lt;/p&gt;

&lt;p&gt;	Logger log;&lt;/p&gt;

&lt;p&gt;	StopWatchState state;&lt;/p&gt;

&lt;p&gt;	double elapsedSeconds = 0.0;&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Initializes and starts the clock.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@param _action&lt;/li&gt;
	&lt;li&gt;@param _log&lt;br/&gt;
	 */&lt;br/&gt;
	public StopWatch(final String _action, final Logger _log) 
{
		this(_action, _log, true);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public StopWatch(final String _action, final Logger _log, final boolean _startRunning) {&lt;br/&gt;
		this.action = _action;&lt;br/&gt;
		this.log = _log;&lt;br/&gt;
		this.log.info(startMessage());&lt;br/&gt;
		if (_startRunning) &lt;/p&gt;
{
			this.state = StopWatchState.RUNNING;
			this.t0 = System.currentTimeMillis();
		}
&lt;p&gt; else&lt;br/&gt;
			this.state = StopWatchState.STOPPED;&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	String startMessage() &lt;/p&gt;
{
		Runtime r = Runtime.getRuntime();
		double totMemMeg = r.totalMemory() / meg;
		double freeMemMeg = r.freeMemory() / meg;
		return String.format(&quot;mem=%.2fm  Started %s...&quot;, Double.valueOf(totMemMeg - freeMemMeg), this.action);
	}

&lt;p&gt;	public void start() {&lt;br/&gt;
		if (this.state.equals(StopWatchState.RUNNING)) &lt;/p&gt;
{
			this.log.warn(&quot;start(): StopWatch is already running.  Not doing anything.&quot;);
			return;
		}
&lt;p&gt;		this.state = StopWatchState.RUNNING;&lt;br/&gt;
		this.t0 = System.currentTimeMillis();&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public void stop() {&lt;br/&gt;
		double curElapsedSeconds = ((System.currentTimeMillis() - this.t0) / 1000.0);&lt;br/&gt;
		if (this.state.equals(StopWatchState.STOPPED)) &lt;/p&gt;
{
			this.log.warn(&quot;stop(): StopWatch is already stopped.  Not doing anything.&quot;);
			return;
		}
&lt;p&gt;		this.elapsedSeconds += curElapsedSeconds;&lt;br/&gt;
		this.state = StopWatchState.STOPPED;&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public void logEndMessage() &lt;/p&gt;
{
		this.log.info(endMessage());
	}

&lt;p&gt;	public void logEndMessage(final String _s) &lt;/p&gt;
{
		this.log.info(endMessage() + &quot; &quot; + _s);
	}

&lt;p&gt;	String endMessage() {&lt;br/&gt;
		double totalElapsedSeconds = this.elapsedSeconds;&lt;br/&gt;
		if (this.state.equals(StopWatchState.RUNNING)) &lt;/p&gt;
{
			totalElapsedSeconds += ((System.currentTimeMillis() - this.t0) / 1000.0);
		}
&lt;p&gt;		Runtime r = Runtime.getRuntime();&lt;br/&gt;
		double totMemMeg = r.totalMemory() / meg;&lt;br/&gt;
		double freeMemMeg = r.freeMemory() / meg;&lt;br/&gt;
		return String.format(&quot;mem=%.2fm  Finished %s in %.3f seconds.&quot;, Double.valueOf(totMemMeg - freeMemMeg), this.action, Double.valueOf(totalElapsedSeconds));&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;</comment>
                            <comment id="12577037" author="dweiss" created="Mon, 10 Mar 2008 15:32:10 +0000"  >&lt;p&gt;A quickie:&lt;/p&gt;

&lt;p&gt;1. Make many, many rounds through the same code and throw away initial observations. JVMs tend to optimize code after some time (and compile it to native code of course). A single run is definitely not enough.&lt;/p&gt;

&lt;p&gt;2. There is no HashMap on primitive types in the JDK. It&apos;s done on boxed types &amp;#8211; while these yield to low-level optimizations, I doubt you&apos;ll get much improvement.&lt;/p&gt;</comment>
                            <comment id="12577048" author="tdunning@veoh.com" created="Mon, 10 Mar 2008 15:49:47 +0000"  >
&lt;p&gt;I believe that Jason was referring to a purpose built primitive HashMap for&lt;br/&gt;
primitives (of which there are many implementations, including a reasonably&lt;br/&gt;
good one in Colt).&lt;/p&gt;



</comment>
                            <comment id="12577061" author="jrennie" created="Mon, 10 Mar 2008 16:33:56 +0000"  >&lt;p&gt;Re David:&lt;/p&gt;

&lt;p&gt;1. Good point.  Was doing the test as more of a gut-check than a formal test, but yeah, we should change the test so that the first 10% or so iterations are ignored.&lt;/p&gt;

&lt;p&gt;Re Ted:&lt;/p&gt;

&lt;p&gt;Exactly.  I&apos;d be surprised if we don&apos;t see at least a 25% speed improvement with a special purpose int/double HashMap.  Also, provides us with memory savings.  Can/should we just grab Colt&apos;s impl?&lt;/p&gt;</comment>
                            <comment id="12577071" author="gsingers" created="Mon, 10 Mar 2008 17:09:48 +0000"  >


&lt;p&gt;Not without looking at the license, etc.  I see some LGPL in there: &lt;a href=&quot;http://dsd.lbl.gov/~hoschek/colt/license.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dsd.lbl.gov/~hoschek/colt/license.html&lt;/a&gt; &lt;br/&gt;
   We can implement our own, or maybe there is a version somewhere  &lt;br/&gt;
under ASL? &lt;/p&gt;</comment>
                            <comment id="12577080" author="dweiss" created="Mon, 10 Mar 2008 17:27:49 +0000"  >&lt;p&gt;If you&apos;re looking at collection implementations based on primitives then there are a couple &amp;#8211; commons collections used to have one, we used pcj (primitive collections for java) in Carrot2.&lt;/p&gt;

&lt;p&gt;That said, on modern JVMs the speed improvement is still not that impressive (read: minimal). I bet JVMs have good optimizations for boxed types (since they are immutable). Feel free to check pcj, it&apos;s quite all right and the license is permissive.&lt;/p&gt;</comment>
                            <comment id="12577181" author="jrennie" created="Mon, 10 Mar 2008 20:56:23 +0000"  >&lt;p&gt;David&apos;s right, I&apos;m wrong---a primitive implementation didn&apos;t help (wrt speed).  I tested the pcj IntKeyDoubleOpenHashMap vs. java.util.HashMap&amp;lt;Integer,Double&amp;gt;.  Tried two load factors (I set initial capacity to 1/loadFactor): 25% and 50%.  The two maps were about comparable for 25%.  java.util.HashMap was faster for 50%.  The CRS impl. was 2.3-3.6x faster than java.util.HashMap (after subtracting the SW &quot;base&quot; times).&lt;/p&gt;

&lt;p&gt;The details:&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished HashMap dot product in 6.501 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished PrimitiveMap dot product in 6.589 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished CRS dot product in 2.632 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished SW base time in 1.162 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=100 nnz2=100 loadFactor=25%&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished HashMap dot product in 4.573 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished PrimitiveMap dot product in 4.033 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished CRS dot product in 2.290 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished SW base time in 1.103 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=200 nnz2=50 loadFactor=25%&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished HashMap dot product in 6.244 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished PrimitiveMap dot product in 7.417 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished CRS dot product in 2.575 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished SW base time in 1.054 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=100 nnz2=100 loadFactor=50%&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished HashMap dot product in 3.745 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished PrimitiveMap dot product in 4.249 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished CRS dot product in 2.270 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; Finished SW base time in 1.164 seconds&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt; numTrials=1000000 vectorSize=1000 nnz1=200 nnz2=50 loadFactor=50%&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;br/&gt;
	 */&lt;br/&gt;
	public void testSparseVectorPerformance() throws Exception {&lt;br/&gt;
		StopWatch hmvSW = new StopWatch(&quot;HashMap dot product&quot;, log, false);&lt;br/&gt;
		StopWatch pmvSW = new StopWatch(&quot;PrimitiveMap dot product&quot;, log, false);&lt;br/&gt;
		StopWatch crsSW = new StopWatch(&quot;CRS dot product&quot;, log, false);&lt;br/&gt;
		StopWatch baseSW = new StopWatch(&quot;SW base time&quot;, log, false);&lt;br/&gt;
		final int numTrials = 1000000;&lt;br/&gt;
		final int vectorSize = 1000;&lt;br/&gt;
		final int nnz1 = 100;&lt;br/&gt;
		final int nnz2 = 100;&lt;br/&gt;
		final int sizeMultiple = 2;&lt;br/&gt;
		for (int i = 0; i &amp;lt; numTrials; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {			// ignore first 10% of iterations			if (i == numTrials / 10) {
				hmvSW.reset();
				pmvSW.reset();
				crsSW.reset();
				baseSW.reset();
			}			SparseVectorPrimitiveMap pmv1 = new SparseVectorPrimitiveMap(nnz1 * sizeMultiple);			SparseVectorPrimitiveMap pmv2 = new SparseVectorPrimitiveMap(nnz2 * sizeMultiple);			SparseVectorHashMap hmv1 = new SparseVectorHashMap(nnz1 * sizeMultiple);			SparseVectorHashMap hmv2 = new SparseVectorHashMap(nnz2 * sizeMultiple);			for (int j = 0; j &amp;lt; nnz1; ++j) {
				int index = this.rand.nextInt(vectorSize) + 1;
				double value = this.rand.nextDouble();
				pmv1.set(index, value);
				hmv1.set(index, value);
			}			for (int j = 0; j &amp;lt; nnz2; ++j) {
				int index = this.rand.nextInt(vectorSize) + 1;
				double value = this.rand.nextDouble();
				pmv2.set(index, value);
				hmv2.set(index, value);
			}			SparseVector crsv1 = pmv1.buildSparseVector();			SparseVector crsv2 = pmv2.buildSparseVector();			hmvSW.start();			hmv1.dot(hmv2);			hmvSW.stop();			pmvSW.start();			pmv1.dot(pmv2);			pmvSW.stop();			crsSW.start();			crsv1.dot(crsv2);			crsSW.stop();			baseSW.start();			baseSW.stop();		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;		hmvSW.logEndMessage();&lt;br/&gt;
		pmvSW.logEndMessage();&lt;br/&gt;
		crsSW.logEndMessage();&lt;br/&gt;
		baseSW.logEndMessage();&lt;br/&gt;
		log.debug(&quot;numTrials=&quot; + numTrials + &quot; vectorSize=&quot; + vectorSize + &quot; nnz1=&quot; + nnz1 + &quot; nnz2=&quot; + nnz2 + &quot; loadFactor=&quot; + (100 / sizeMultiple) + &quot;%&quot;);&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12577182" author="jrennie" created="Mon, 10 Mar 2008 20:57:12 +0000"  >&lt;p&gt;Btw, I&apos;m running jdk-6u4-linux-x64.bin&lt;/p&gt;</comment>
                            <comment id="12577192" author="tdunning@veoh.com" created="Mon, 10 Mar 2008 21:09:46 +0000"  >
&lt;p&gt;Amazing.&lt;/p&gt;

&lt;p&gt;Were you able to measure garbage production?&lt;/p&gt;



</comment>
                            <comment id="12579261" author="gsingers" created="Sun, 16 Mar 2008 21:22:40 +0000"  >&lt;p&gt;Does it make sense to be able to assign labels to the rows and columns and maybe even have it accessible as a map?  For instance, I think I could use these for the bayesian classifier implementation I am working on and it would make sense to be able to label the features and the labels.  Naturally, I can store the information elsewhere as well, but didn&apos;t know whether it made sense to keep the info w/ the matrix.&lt;/p&gt;</comment>
                            <comment id="12579262" author="gsingers" created="Sun, 16 Mar 2008 21:24:06 +0000"  >&lt;p&gt;Committed revision 637664.  Thanks!&lt;/p&gt;</comment>
                            <comment id="12583366" author="gsingers" created="Sat, 29 Mar 2008 21:10:37 +0000"  >&lt;p&gt;This was committed.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12389433">MAHOUT-7</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12376200" name="MAHOUT-6a.diff" size="17931" author="jeastman" created="Fri, 22 Feb 2008 05:21:39 +0000"/>
                            <attachment id="12376321" name="MAHOUT-6b.diff" size="32378" author="jeastman" created="Sat, 23 Feb 2008 23:13:36 +0000"/>
                            <attachment id="12376440" name="MAHOUT-6c.diff" size="41712" author="jeastman" created="Mon, 25 Feb 2008 21:05:10 +0000"/>
                            <attachment id="12376465" name="MAHOUT-6d.diff" size="50854" author="jeastman" created="Tue, 26 Feb 2008 01:46:33 +0000"/>
                            <attachment id="12376528" name="MAHOUT-6e.diff" size="54947" author="jeastman" created="Tue, 26 Feb 2008 17:26:43 +0000"/>
                            <attachment id="12376567" name="MAHOUT-6f.diff" size="71082" author="jeastman" created="Tue, 26 Feb 2008 23:34:17 +0000"/>
                            <attachment id="12376768" name="MAHOUT-6g.diff" size="46513" author="jeastman" created="Thu, 28 Feb 2008 21:40:48 +0000"/>
                            <attachment id="12376893" name="MAHOUT-6h.patch" size="52501" author="gsingers" created="Sat, 1 Mar 2008 04:14:04 +0000"/>
                            <attachment id="12376908" name="MAHOUT-6i.diff" size="152444" author="jeastman" created="Sat, 1 Mar 2008 18:51:48 +0000"/>
                            <attachment id="12377011" name="MAHOUT-6j.diff" size="188567" author="jeastman" created="Mon, 3 Mar 2008 21:14:44 +0000"/>
                            <attachment id="12377426" name="MAHOUT-6k.diff" size="186809" author="jeastman" created="Sat, 8 Mar 2008 07:42:51 +0000"/>
                            <attachment id="12377437" name="MAHOUT-6l.patch" size="196118" author="gsingers" created="Sat, 8 Mar 2008 12:41:06 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 22 Feb 2008 05:21:39 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10060</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy7s7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23412</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>