<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:20:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-190/MAHOUT-190.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-190] Make all instance fields private</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-190</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;This one may be more controversial but is useful and interesting enough to discuss.&lt;/p&gt;

&lt;p&gt;I personally believe instance fields should always be private. I think the pro- and con- debate goes like this:&lt;/p&gt;

&lt;p&gt;Making all fields private increases encapsulation. Fields must be made explicitly accessible via getters and setters, which is good &amp;#8211; default to hiding, rather than exposing. Not-hiding a field amounts to committing it to be a part of the API, which is rarely intended. Using getters/setters allows read/write access to be independently controlled and even allowed &amp;#8211; allows for read-only &apos;fields&apos;. Getters/setters establish an API independent from the representation which is a Good Thing.&lt;/p&gt;

&lt;p&gt;But don&apos;t getters and setters slow things down?&lt;/p&gt;

&lt;p&gt;Trivially. JIT compilers will easily inline one-liners. Making fields private more readily allows fields to be marked final, and these two factors allow for optimizations by (Proguard or) JIT. It could actually speed things up.&lt;/p&gt;

&lt;p&gt;But isn&apos;t it messy to write all those dang getters/setters?&lt;/p&gt;

&lt;p&gt;Not really, and not at all if you use an IDE, which I think we all should be.&lt;/p&gt;

&lt;p&gt;But sometimes a class needs to share representation with its subclasses.&lt;/p&gt;

&lt;p&gt;Yes, and it remains possible with package-private / protected getters and setters. This is IMHO a rare situation anyway, and, the code is far easier to read when fields from a parent don&apos;t magically appear, or one doesn&apos;t wonder about where else a field may be accessed in subclasses. I also feel like sometimes making a field more visible is a shortcut enabler to some bad design. It usually is a bad smell.&lt;/p&gt;

&lt;p&gt;Thoughts on this narrative. Once again I volunteer to implement the consensus.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12439164">MAHOUT-190</key>
            <summary>Make all instance fields private</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srowen">Sean Owen</assignee>
                                    <reporter username="srowen">Sean Owen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 27 Oct 2009 12:25:44 +0000</created>
                <updated>Sat, 21 May 2011 04:24:03 +0100</updated>
                            <resolved>Mon, 9 Nov 2009 15:07:13 +0000</resolved>
                                    <version>0.2</version>
                                    <fixVersion>0.3</fixVersion>
                                        <due>Fri, 13 Nov 2009 00:00:00 +0000</due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12770517" author="tdunning" created="Tue, 27 Oct 2009 14:13:28 +0000"  >
&lt;p&gt;Totally agree.&lt;/p&gt;

&lt;p&gt;In fact, this may be one issue where I am even more extreme in my views than Sean.  Non-private instance variables are VERY rarely a good thing except in throw-away code.&lt;/p&gt;

&lt;p&gt;As such, when I see them, I tend to throw away the code!&lt;/p&gt;</comment>
                            <comment id="12770575" author="jake.mannix" created="Tue, 27 Oct 2009 17:08:22 +0000"  >&lt;p&gt;Oh lordy... the combinatinon of private and final is a scary one to me.  It means we end up leaning far too much in the direction of &quot;closed for modification&quot; as compared to &quot;open for extension&quot;.  &lt;/p&gt;

&lt;p&gt;I know you can make the getter protected, if necessary.  But in a library such as this one, in which every extension is of the &quot;expert&quot; level, assuming the end user isn&apos;t going to need to access &quot;private&quot; data in their operation is a bad one.  &lt;/p&gt;

&lt;p&gt;The number of times I&apos;ve needed to do something the implementer didn&apos;t expect is really high.  For example, imagine we&apos;re talking about the IntDoubleVector, a sparse impl which has int[] indices, and double[] values, and implements Vector.  Great, it has all the useful methods, like the iterators, and linear methods like dot and so forth.  Now as user, I end up needing to know, for my application, what the current maximum index (in this vector) is, and the minimum index.  Neither of these are exposed via a Vector API, and in fact, most likely nobody will put a getIndices() method on the class itself, because it&apos;s &quot;internal&quot;.  If they&apos;re private, then we&apos;re screwed - nobody can efficiently getMaxIndex() without modifying the class itself, because you can&apos;t subclass it to get access.  You then say, well the right answer is to give a read-only getIndices method, except in this case, you&apos;ve got an array, and if you&apos;ve actually lost any real immutability if you were trying to enforce any, because the contents of the array are modifiable even if the array is final.  Also, what are you going to do, write protected getters for every single private instance variable, to make sure that subclasses &lt;b&gt;can&lt;/b&gt; get access to them if they need to?  How is it less magic to see, in the middle of some subclass, &quot;int[] foo = getIndices();&quot; vs. &quot;int[] foo = this.indices;&quot; ?&lt;/p&gt;

&lt;p&gt;I like to think of myself as someone who doesn&apos;t write &quot;bad smelling&quot; code, and yet I find myself, &lt;b&gt;especially&lt;/b&gt; in apache projects, running into cases where the class designer assumes that nobody will need to do something with a class, when it&apos;s just that they haven&apos;t thought of it yet.  When the project in question is a full-fledged application (Solr, HBase, etc...), I&apos;m fine with this - it&apos;s supposed to be &lt;b&gt;easy&lt;/b&gt;, and users may be not supposed to dig into the internals that often.  When the project is a &lt;b&gt;library&lt;/b&gt; (Lucene, Mahout, Commons-*, etc...), for use by a very wide audience, it can get beyond annoying.  &lt;/p&gt;

&lt;p&gt;For project committers, you don&apos;t notice the pain of this as much: if you see a new use for a class, you can just add a method, or decide to make an exception and change the private instance to a protected one, but end users can&apos;t do this.  All they can do is petition to the dev list, submit a patch, and then try to beg and argue to get the patch committed, by which time they&apos;ve probably just forked the code and recompiled with their own patches locally, maybe just giving up on the system entirely.&lt;/p&gt;

&lt;p&gt;Sorry if I sound bitter, but this whole &quot;open/closed&quot; principle can really go wrong when you go the extreme route of assuming you know what people are going to do with the code, and assuming that because someone&apos;s design &quot;doesn&apos;t smell right&quot; to you means that you should be dictating how they code.  It&apos;s rather paternalistic.  So I don&apos;t give a rat&apos;s ass about the performance of getters, it&apos;s much more that the &lt;b&gt;design choice&lt;/b&gt; of hiding everything, even from subclasses (don&apos;t get me started on making classes final which don&apos;t need to be final!), that I feel pretty strongly about (and having protected getters for everything leads to a horribly cluttered api and doesn&apos;t make sense).&lt;/p&gt;</comment>
                            <comment id="12770588" author="srowen" created="Tue, 27 Oct 2009 17:32:44 +0000"  >&lt;p&gt;I agree there&apos;s a tension between closed-for-modification and open-for-extension. I believe there&apos;s more harm in allowing extension without designing for it than the opposite. And in the code so far, I really don&apos;t see evidence of explicit design for extension. I see overrideable methods in constructors, etc.&lt;/p&gt;

&lt;p&gt;When confronted with a class that could be either closed up to be safe, or designed for extension, I&apos;m all for designing for extension.&lt;/p&gt;

&lt;p&gt;But does that ever involve having non-private fields? That&apos;s the narrower question I&apos;m asking.&lt;/p&gt;

&lt;p&gt;I do think a getter is better than a raw field access, yes. I don&apos;t agree that every field should be accessible by default, no, which is why it makes any difference. Something should be accessible on purpose, not by accident, and I don&apos;t sense many of the non-public fields in the project now are on purpose.&lt;/p&gt;

&lt;p&gt;Replacing it with a getter does little, yes, but it&apos;s a step in the right direction? Do we have evidence there is a problem with people wanting to extend and not being able to?&lt;/p&gt;

&lt;p&gt;I&apos;d also advance the opposite problem: you have a protected field that the dev really doesn&apos;t think of as something used by anyone. He removes or changes it. Oops, just broke two subclassers. Either he reverts and realizes, actually, that&apos;s now part of the API, sorry, or finds some workaround (like migrating to getters). Is that a lesser problem?&lt;/p&gt;</comment>
                            <comment id="12770592" author="jake.mannix" created="Tue, 27 Oct 2009 17:49:33 +0000"  >&lt;p&gt;&amp;lt;em&amp;gt;Replacing it with a getter does little, yes, but it&apos;s a step in the right direction? &amp;lt;/em&amp;gt;&lt;/p&gt;

&lt;p&gt;I&apos;m a big fan of getters over &lt;b&gt;public&lt;/b&gt; instance variables, &lt;b&gt;always&lt;/b&gt;.  Over protected instance variables?  It&apos;s not so bad, much of the time that seems fine, yes, esp. when you&apos;re exposing it &quot;on purpose&quot; as you say.  It&apos;s the exposing it for the advanced user, who is going to subclass, that I&apos;m wondering about.  Like you say, you&apos;re not going to go and add protected getters for everything - only things you think people will need.  But then that comes back to the problem of reading the user&apos;s mind...&lt;/p&gt;

&lt;p&gt;&amp;lt;em&amp;gt;I&apos;d also advance the opposite problem...&amp;lt;/em&amp;gt;&lt;/p&gt;

&lt;p&gt;Yeah, this is the only argument I really agree with on this, and the only way to get around it is to yes, accept that anything that someone can get access to, via a protected method in a subclass, is in some sense part of the API.  And for the same reasons why you shouldn&apos;t have a millions methods on interfaces (well, some of the same reasons), making an API huge by having &lt;b&gt;everything&lt;/b&gt; not public be protected by default is a bad idea.&lt;/p&gt;

&lt;p&gt;But early on in a project, when it&apos;s evolving fast, and you don&apos;t know how people are going to use it?  That&apos;s not the time to err on the side of &quot;closed for modification&quot;, it&apos;s the time to assume that every user is moderately advanced (why else would they be using a 0.x product?), and let them try things out, and maybe you find things that really should be designed for extension that you didn&apos;t realize before.  Making it harder for people to monkey-with just hampers adoption.  If users do crazy shit in the internals of a core class which they&apos;re give protected access to, and then in 0.4 we remove those variables, breaking some implementers, well, they knew what they were getting into by monkeying with internals in a fast moving project, and they&apos;ll probably bring it up on the lists, we&apos;ll all have a big discussion about whether we need to revert or migrate to getters, and we&apos;ve all learned something.&lt;/p&gt;

&lt;p&gt;When the project is farther along (like Lucene), it&apos;s more acceptable to lock things down, but doing it too early just leads to pain for people who want to experiment, in my experience.&lt;/p&gt;

&lt;p&gt;Does it &lt;b&gt;hurt&lt;/b&gt; us to not make this kind of design choice, of enforcing this strict rule, until later on when apis have stabilized and we know who our users are and what they are doing?&lt;/p&gt;</comment>
                            <comment id="12770621" author="srowen" created="Tue, 27 Oct 2009 19:48:18 +0000"  >&lt;p&gt;How about this compromise: I think there are several instances that everyone where everyone will agree there&apos;s no real case for extension (e.g. test cases). There are some cases where there&apos;s a question &amp;#8211; there&apos;s some case for extension.&lt;/p&gt;

&lt;p&gt;I&apos;ll prepare a patch where the &apos;clear&apos; cases are made private, and otherwise, raw access is replaced with getters/setters. This should be a strict improvement. We retain API openness going forward, just in a slightly more organized way. And the non-controversial cases are &apos;fixed&apos;.&lt;/p&gt;</comment>
                            <comment id="12770712" author="tdunning" created="Wed, 28 Oct 2009 00:00:18 +0000"  >
&lt;blockquote&gt;&lt;p&gt;I know you can make the getter protected, if necessary.  But in a library such as this one, in which every extension is of the &quot;expert&quot; level, assuming the end user isn&apos;t going to need to access &quot;private&quot; data in their operation is a bad one.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Surely Sean is merely advocating at the core that we forbid access to instance variables except via getter and setter.  &lt;/p&gt;

&lt;p&gt;I agree that too much final annotation is (a) pointless and (b) an unnecessary PITA.  On the other hand, final can make code more comprehensible if used judiciously.&lt;/p&gt;</comment>
                            <comment id="12770720" author="jake.mannix" created="Wed, 28 Oct 2009 00:19:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;Surely Sean is merely advocating at the core that we forbid access to instance variables except via getter and setter. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, but for the sake of argument, when do we go and create those get/set methods?  We go through now and add them for everything, and by default make these methods protected?  If we don&apos;t, we&apos;ve hidden them completely and they&apos;re not available, but if we do, that&apos;s a crazy lot of methods added, most of the time when they&apos;re not necessary, because nobody should be using them (ie. they are the &quot;clear&quot; cases Sean talks about, of private inner stuff nobody should use - implementation details and so forth).  &lt;/p&gt;

&lt;p&gt;So we need to decide which are the &quot;clearly&quot; inner, make those private with no getters, let alone setters, and then go through the &quot;possibly extendable&quot; cases, make those private with protected getter (and setter, if it looks like this is somethign that doesn&apos;t need to be final/immutable), and then find the cases of basically public stuff, and make them private with public access methods.&lt;/p&gt;

&lt;p&gt;I guess what I&apos;m advocating is that this be taken in a case-by-case basis, instead of a blanket statement of &quot;lets hide everything now, and only add back accessors later as necessary&quot; - yes, I agree with both of you that the basic statement of making them private is fine, as long as you default to imagining the world where an advanced user might think of doing something different with things, and only don&apos;t provide at least protected access via accessors when you are really really sure that nobody should access these in any possible subclass.  I personally tend to think that subclasses, since they follow the &quot;is a&quot; qualifier w.r.t. their parent, deserve to be allowed to access a fair amount of their parent.  The problem with this kind of approach, as I keep saying, is that it leads to a proliferation of protected accessor methods.  This isn&apos;t doesn&apos;t rule out doing this, but it&apos;s a slight strike against it in my eyes.&lt;/p&gt;</comment>
                            <comment id="12770740" author="gsingers" created="Wed, 28 Oct 2009 01:12:58 +0000"  >&lt;p&gt;-1 on a blanket move to private nor final, especially at this stage of the game.  People need to be able to extend implementations.  We&apos;ve spent a lot of time in Lucene undoing private/final b/c there is no possible way to predict where the next innovation comes from.&lt;/p&gt;</comment>
                            <comment id="12770871" author="srowen" created="Wed, 28 Oct 2009 10:08:17 +0000"  >&lt;p&gt;Yes, I am suggesting we (= I) go through now and create potentially all the getters/setters. It will take me 10 minutes with my IDE.&lt;/p&gt;

&lt;p&gt;My personal preference is strongly to design for extension, but failing that, prevent extension if it&apos;s not designed for. and a lot of stuff is not yet designed for extension.&lt;/p&gt;

&lt;p&gt;I am surprised to hear we&apos;d welcome some dependencies to weave their way into the internal representation of these classes, in ways we aren&apos;t tracking. Tens of small subtle bugs come to mind. Oops, now I want to synchronize on some internal object. But I&apos;ve allowed callers to access it directly, and they are too. Maybe a deadlock occurs. Oops I didn&apos;t expect the field to be nulled at this point.&lt;/p&gt;

&lt;p&gt;Isn&apos;t just opening up the representation just punting on designing for extension? should it not be intentional?&lt;/p&gt;

&lt;p&gt;The strong argument for complete extensibility sounds like an argument for no encapsulation, which can&apos;t be the idea. There&apos;s a line, and I thought encapsulating representation was one of the things farthest from that line. I am sure that&apos;s the right thing given my own experience, but we all have different experience, and I&apos;m not pushing this point of view.&lt;/p&gt;

&lt;p&gt;One other thing, it&apos;s open-source right? this is the very case where the worst-case is just that someone copies/pastes a class. It&apos;s not a closed library.&lt;/p&gt;

&lt;p&gt;The least change would be to expose absolutely everything through getters/setters. I think you said it Jake &amp;#8211; it&apos;s a crazy lot of methods added, most of which are not necessary. But these &apos;methods&apos; already exist, they&apos;re part of the API, in the form of accessible fields. They&apos;re in the javadoc. This change is just a &apos;messenger&apos;.&lt;/p&gt;

&lt;p&gt;Why don&apos;t I make a patch that does in fact add all the getters/setters, for a look. I think in many cases it will just highlight that the fields aren&apos;t going to be useful to any extenders. And we chuck those. And we leave a lot of them. And in 3 versions, can even review them again.&lt;/p&gt;</comment>
                            <comment id="12771174" author="tdunning" created="Wed, 28 Oct 2009 22:46:05 +0000"  >
&lt;p&gt;I would prefer to make all instance variables private, and then add  getters and setters &lt;b&gt;only&lt;/b&gt; where used.&lt;/p&gt;

&lt;p&gt;Putting getters and setters on everything is not a good idea (in my opinion).&lt;/p&gt;</comment>
                            <comment id="12772477" author="srowen" created="Mon, 2 Nov 2009 09:42:40 +0000"  >&lt;p&gt;Partial patch. This addresses public fields. I simply replaced with getters/setters &amp;#8211; but them removed the setter in cases where it didn&apos;t appear to make sense (and of course, wasn&apos;t used). For instance a few classes accumulate a mean and standard deviation; doesn&apos;t really make sense to let a caller set these.&lt;/p&gt;

&lt;p&gt;I&apos;m using this to test the waters, see if this seems acceptable or if there concerns about extensibility. There seem to be two strong +1s for this, a +0, and a possible -1 for the patch and I can&apos;t proceed with a veto.&lt;/p&gt;</comment>
                            <comment id="12772608" author="tdunning" created="Mon, 2 Nov 2009 19:15:16 +0000"  >
&lt;p&gt;I think that this patch is a very nice conservative step very much in the right direction.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="12774289" author="srowen" created="Fri, 6 Nov 2009 13:41:20 +0000"  >&lt;p&gt;Patch, round 2 of 3&lt;/p&gt;</comment>
                            <comment id="12774595" author="srowen" created="Sat, 7 Nov 2009 13:09:51 +0000"  >&lt;p&gt;OK went ahead and made the rest of the changes I think are appropriate given discussion on the issue. Final part 2 patch attached, looking to submit Monday.&lt;/p&gt;</comment>
                            <comment id="12774638" author="tdunning" created="Sat, 7 Nov 2009 17:02:37 +0000"  >
&lt;p&gt;Is patch-2 reversed?  &lt;/p&gt;

&lt;p&gt;I like the reversed changes and can&apos;t imagine Sean making the forward changes.&lt;/p&gt;</comment>
                            <comment id="12774643" author="srowen" created="Sat, 7 Nov 2009 17:43:58 +0000"  >&lt;p&gt;Oops, yes had &quot;reverse patch&quot; checked from a previous action &amp;#8211; didn&apos;t realize it was sticky&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12423816" name="MAHOUT-190_1.patch" size="48827" author="srowen" created="Mon, 2 Nov 2009 09:42:40 +0000"/>
                            <attachment id="12424257" name="MAHOUT-190_2.patch" size="79267" author="srowen" created="Sat, 7 Nov 2009 13:09:51 +0000"/>
                            <attachment id="12424202" name="MAHOUT-190_2.patch" size="51997" author="srowen" created="Fri, 6 Nov 2009 13:41:20 +0000"/>
                            <attachment id="12424260" name="MAHOUT-190_21.patch" size="79267" author="srowen" created="Sat, 7 Nov 2009 17:43:58 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 27 Oct 2009 14:13:28 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9875</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy6nb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23228</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>