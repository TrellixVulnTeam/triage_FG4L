<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:19:01 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-823/MAHOUT-823.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-823] RandomAccessSparseVector.dot with another non-sequential vector can be extremely non-symmetric in its performance</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-823</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;&lt;a href=&quot;http://codesearch.google.com/#6LK_nEANBKE/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java&amp;amp;l=172&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://codesearch.google.com/#6LK_nEANBKE/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java&amp;amp;l=172&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The complexity of the algorithm is O(num nondefault elements in this), while it could clearly be O(min(num nondefault in this, num nondefault in x)).&lt;/p&gt;

&lt;p&gt;This can be fixed by adding this code before line 189.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(x.getNumNondefaultElements() &amp;lt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.getNumNondefaultElements()) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; x.dot(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;An easy case where this asymmetry is very apparent and makes a huge difference in performance is K-Means clustering.&lt;/p&gt;

&lt;p&gt;In K-Means for high-dimensional points (e.g. those that arise in text retrieval problems), the centroids often have a huge number of non-zero components, whereas points have a small number of them.&lt;/p&gt;

&lt;p&gt;So, if you make a mistake and use centroid.dot(point) in your code for computing the distance, instead of point.dot(centroid), you end up with orders of magnitude worse performance (which is what we actually observed - the clustering time was a couple of minutes with this fix and over an hour without it).&lt;/p&gt;

&lt;p&gt;So, perhaps, if you make this fix, quite a few people who had a similar case but didn&apos;t notice it will suddenly have a dramatic performance increase &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12525298">MAHOUT-823</key>
            <summary>RandomAccessSparseVector.dot with another non-sequential vector can be extremely non-symmetric in its performance</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srowen">Sean Owen</assignee>
                                    <reporter username="jkff">Eugene Kirpichov</reporter>
                        <labels>
                            <label>dot</label>
                            <label>dot-product</label>
                            <label>vector</label>
                    </labels>
                <created>Fri, 30 Sep 2011 12:21:30 +0100</created>
                <updated>Thu, 9 Feb 2012 14:00:55 +0000</updated>
                            <resolved>Sat, 1 Oct 2011 14:30:55 +0100</resolved>
                                    <version>0.5</version>
                                    <fixVersion>0.6</fixVersion>
                                    <component>Math</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="13118011" author="tdunning" created="Fri, 30 Sep 2011 13:16:15 +0100"  >&lt;p&gt;Great idea, do you have a patch?&lt;/p&gt;</comment>
                            <comment id="13118015" author="srowen" created="Fri, 30 Sep 2011 13:24:00 +0100"  >&lt;p&gt;I think it&apos;s a good idea, and can be expanded. Am I right that the goal is to compute the dot in the way that will avoid more lookups (in the other vector), and/or avoid looking up in the vector with the slower get() operation?&lt;/p&gt;

&lt;p&gt;I imagine that avoiding lookups is higher priority, so the rule you suggest is something we always want to do. So, for example, let&apos;s say you&apos;re dotting a SequentialAccessSparseVector with 100,000 non-default elements, with a RandomAccessSparseVector of 1,000 non-default elements. You&apos;d want random-dot-sequential, right? Even though it&apos;ll take longer to look up in the SequentialAccessSparseVector with binary search, it&apos;s saving 100x lookups.&lt;/p&gt;

&lt;p&gt;But we now have a rule in the code that prioritizes dotting sequential-dot-random. I think we&apos;d just remove that then right?&lt;/p&gt;

&lt;p&gt;And then in SequentialAccessSparseVector... I can imagine keeping the special-case of sequential-dot-sequential... but somehow it also seems overwhelmed by avoiding lookups. And, this special-case ignores DenseVectors, which should be similarly treated. So, can it go too?&lt;/p&gt;

&lt;p&gt;And then DenseVector&apos;s special case for DenseVector seems not that useful.&lt;/p&gt;

&lt;p&gt;And then we get to the point where all dot() implementations are the same, and include the helpful rule above. This seems happy and tidy &amp;#8211; see attached counter-proposal patch, just for discussion. Am I missing something?&lt;/p&gt;</comment>
                            <comment id="13118049" author="jkff" created="Fri, 30 Sep 2011 14:26:29 +0100"  >&lt;p&gt;Ted, since the code change required is so small, I simply included it into the task description. Is there any particular reason to convert that into a patch (e.g. the necessity to follow a formal procedure)?&lt;/p&gt;

&lt;p&gt;Sean, right, the goal is to avoid doing many lookups; I actually only had in mind the trivial case of dotting two RandomAccess vectors, but your comment got me thinking on what to do in the general case.&lt;/p&gt;

&lt;p&gt;Random-random: Smallest leads (what&apos;s proposed)&lt;br/&gt;
Seq-seq: Merge (what&apos;s implemented)&lt;br/&gt;
Random-seq:&lt;br/&gt;
If random leads, number of operations is O((num-nonzero-in-r)^2) because there&apos;s this many lookups into the sequential vector, each taking linear time.&lt;br/&gt;
If sequential leads (what&apos;s implemented), number of operations is O(num nonzero in sequential).&lt;/p&gt;

&lt;p&gt;It&apos;s difficult to decide which to use, given that we don&apos;t know the constant factors, but at least having the sequential lead will never have quadratic behavior, so I suggest to leave it as is.&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;br/&gt;
Bottom line:&lt;br/&gt;
I would suggest to implement just the proposed change.&lt;/p&gt;</comment>
                            <comment id="13118065" author="tdunning" created="Fri, 30 Sep 2011 14:49:45 +0100"  >&lt;p&gt;Eugene, &lt;/p&gt;

&lt;p&gt;I was just suggesting the patch to avoid errors.  I would normally have created the patch and had you review it to be sure it was what you meant, but I am packing for my flight tomorrow and am too lazy.&lt;/p&gt;

&lt;p&gt;Your suggested policies look fine.  Sequential-random could be handled as random leading, but I would sort the indexes from the random to avoid the quadratic behavior and just require a big ratio before considering the possibility.  Even then, it seems quite possible that the cost will be the same as the sequential leading since we have to skip through the list to the right spots anyway.  Thus, the cost is liable to be O(size of sequential up to last element of random) in any case.&lt;/p&gt;</comment>
                            <comment id="13118296" author="srowen" created="Fri, 30 Sep 2011 20:16:14 +0100"  >&lt;p&gt;What&apos;s the quadratic case? SequentialAccessSparseVector is O(log n) for lookups, not O&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. That&apos;s still worse than O(1), for a hash-based RandomAccessSparseVector or array-backed DenseVector, but the real-world difference, I assume, is a small-ish constant factor. Dunno, realistically looking at 20-ish comparisons in a big vector versus 4-5? It&apos;s still probably a &apos;win&apos; to lead with the smaller vector if it has, say, 5x fewer entries.&lt;/p&gt;

&lt;p&gt;I must say I&apos;m in love with simplifying this and getting rid of &apos;instanceof&apos; code here, which is already incomplete and not optimal in most cases. Why don&apos;t I run some benchmarks to get some concept of the appropriate constant factors, then build that in to my patch? Am I still missing something?&lt;/p&gt;</comment>
                            <comment id="13118474" author="jkff" created="Fri, 30 Sep 2011 22:33:31 +0100"  >&lt;p&gt;Sean, you&apos;re right - I was somehow blindly assuming that the sequential vector is O( n ). Indeed benchmarks need to be done. If there&apos;d be a way to make the code simpler, sometimes much faster than the current version, and always not much slower (probably getting &quot;always not slower&quot; would be harder, as the constant factors measured in benchmarks would differ across particular deployments) - that would be great.&lt;/p&gt;</comment>
                            <comment id="13118626" author="robinanil" created="Sat, 1 Oct 2011 02:49:23 +0100"  >&lt;p&gt;There is  a vector benchmarks class in utils or examples? Use that, it compares various combinations of operations of various types of vectors&lt;/p&gt;</comment>
                            <comment id="13118721" author="srowen" created="Sat, 1 Oct 2011 12:08:51 +0100"  >&lt;p&gt;I did the homework, and came up with the following result. The substance of the patch is now this (as well as removing other dot() implementations):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// Crude rule of thumb: when a sequential-access vector, with O(log n) lookups, has about
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// 2^n elements, its lookups take longer than a dense / random access vector (with O(1) lookups) by
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// about a factor of (0.71n - 12.3). This holds pretty well from n=19 up to at least n=23 according to my tests;
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// below that lookups are so fast that &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; difference is near zero.
&lt;/span&gt;
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; thisNumNonDefault = getNumNondefaultElements();
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; thatNumNonDefault = x.getNumNondefaultElements();
    &lt;span class=&quot;code-comment&quot;&gt;// Default: dot from smaller vector to larger vector
&lt;/span&gt;    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; reverseDot = thatNumNonDefault &amp;lt; thisNumNonDefault;

    &lt;span class=&quot;code-comment&quot;&gt;// But, see &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; we should override that -- is exactly one of them sequential access and so slower to lookup in?
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isSequentialAccess() != x.isSequentialAccess()) {
      &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; log2ThisSize = &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.log(thisNumNonDefault) / LOG2;
      &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; log2ThatSize = &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.log(thatNumNonDefault) / LOG2;
      &lt;span class=&quot;code-comment&quot;&gt;// Only override when the O(log n) factor seems big enough to care about:
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (log2ThisSize &amp;gt;= 19.0 &amp;amp;&amp;amp; log2ThatSize &amp;gt;= 19.0) {
        &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; dotCost = thisNumNonDefault;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (x.isSequentialAccess()) {
          dotCost *= 0.71 * log2ThatSize - 12.3;
        }
        &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; reverseDotCost = thatNumNonDefault;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isSequentialAccess()) {
          reverseDotCost *= 0.71 * log2ThisSize - 12.3;
        }
        reverseDot = reverseDotCost &amp;lt; dotCost;
      }
    }

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (reverseDot) {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; x.dot(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="13118805" author="srowen" created="Sat, 1 Oct 2011 14:30:55 +0100"  >&lt;p&gt;Hearing essential consensus on this approach, and as tests pass, and it simplifies and speeds things, I committed. We can tweak it later.&lt;/p&gt;</comment>
                            <comment id="13118857" author="hudson" created="Sat, 1 Oct 2011 18:49:36 +0100"  >&lt;p&gt;Integrated in Mahout-Quality #1076 (See &lt;a href=&quot;https://builds.apache.org/job/Mahout-Quality/1076/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/Mahout-Quality/1076/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-823&quot; title=&quot;RandomAccessSparseVector.dot with another non-sequential vector can be extremely non-symmetric in its performance&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-823&quot;&gt;&lt;del&gt;MAHOUT-823&lt;/del&gt;&lt;/a&gt; standardize, optimize vector dot product&lt;/p&gt;

&lt;p&gt;srowen : &lt;a href=&quot;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1177975&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1177975&lt;/a&gt;&lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorView.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13118984" author="jkff" created="Sun, 2 Oct 2011 09:33:03 +0100"  >&lt;p&gt;Yay, great! Thanks!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12497153" name="MAHOUT-823.patch" size="6127" author="srowen" created="Fri, 30 Sep 2011 13:24:43 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 30 Sep 2011 12:16:15 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>41006</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy2rb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22598</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>