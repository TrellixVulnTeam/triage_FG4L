<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:16:46 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-420/MAHOUT-420.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-420] Improving the distributed item-based recommender</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-420</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;A summary of the discussion on the mailing list:&lt;/p&gt;

&lt;p&gt;Extend the distributed item-based recommender from using only simple cooccurrence counts to using the standard computations of an item-based recommender as defined in Sarwar et al &quot;Item-Based Collaborative Filtering Recommendation Algorithms&quot; (&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.144.9927&amp;amp;rep=rep1&amp;amp;type=pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.144.9927&amp;amp;rep=rep1&amp;amp;type=pdf&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;What the distributed recommender generally does is that it computes the prediction values for all users towards all items those users have not rated yet. And the computation is done in the following way:&lt;/p&gt;

&lt;p&gt; u = a user&lt;br/&gt;
 i = an item not yet rated by u&lt;br/&gt;
 N = all items cooccurring with i&lt;/p&gt;

&lt;p&gt; Prediction(u,i) = sum(all n from N: cooccurrences(i,n) * rating(u,n))&lt;/p&gt;

&lt;p&gt;The formula used in the paper which is used by GenericItemBasedRecommender.doEstimatePreference(...) too, looks very similar to the one above:&lt;/p&gt;

&lt;p&gt; u = a user&lt;br/&gt;
 i = an item not yet rated by u&lt;br/&gt;
 N = all items similar to i (where similarity is usually computed by pairwisely comparing the item-vectors of the user-item matrix)&lt;/p&gt;

&lt;p&gt; Prediction(u,i) = sum(all n from N: similarity(i,n) * rating(u,n)) / sum(all n from N: abs(similarity(i,n)))&lt;/p&gt;

&lt;p&gt;There are only 2 differences:&lt;br/&gt;
 a) instead of the cooccurrence count, certain similarity measures like pearson or cosine can be used&lt;br/&gt;
 b) the resulting value is normalized by the sum of the similarities&lt;/p&gt;

&lt;p&gt;To overcome difference a) we would only need to replace the part that computes the cooccurrence matrix with the code from ItemSimilarityJob or the code introduced in &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-418&quot; title=&quot;Computing the pairwise similarities of the rows of a matrix&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-418&quot;&gt;&lt;del&gt;MAHOUT-418&lt;/del&gt;&lt;/a&gt;, then we could compute arbitrary similarity matrices and use them in the same way the cooccurrence matrix is currently used. We just need to separate steps up to creating the co-occurrence matrix from the rest, which is simple since they&apos;re already different MR jobs. &lt;/p&gt;

&lt;p&gt;Regarding difference b) from a first look at the implementation I think it should be possible to transfer the necessary similarity matrix entries from the PartialMultiplyMapper to the AggregateAndRecommendReducer to be able to compute the normalization value in the denominator of the formula. This will take a little work, yes, but is still straightforward. It canbe in the &quot;common&quot; part of the process, done after the similarity matrix is generated.&lt;/p&gt;

&lt;p&gt;I think work on this issue should wait until &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-418&quot; title=&quot;Computing the pairwise similarities of the rows of a matrix&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-418&quot;&gt;&lt;del&gt;MAHOUT-418&lt;/del&gt;&lt;/a&gt; is resolved as the implementation here depends on how the pairwise similarities will be computed in the future.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12467470">MAHOUT-420</key>
            <summary>Improving the distributed item-based recommender</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srowen">Sean Owen</assignee>
                                    <reporter username="ssc">Sebastian Schelter</reporter>
                        <labels>
                    </labels>
                <created>Mon, 21 Jun 2010 10:38:47 +0100</created>
                <updated>Sun, 31 Oct 2010 15:49:37 +0000</updated>
                            <resolved>Thu, 8 Jul 2010 20:20:24 +0100</resolved>
                                                    <fixVersion>0.4</fixVersion>
                                    <component>Collaborative Filtering</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12884270" author="ssc" created="Thu, 1 Jul 2010 14:40:23 +0100"  >&lt;p&gt;I managed to implement all requirements, added unit-tests for all mappers and reducers participating in the RecommenderJob and wrote a small integration test to check the correctness of the generated recommendations. I&apos;m not completely sure how the changes affect performance, would be great if someone could review the patch and check that.&lt;/p&gt;</comment>
                            <comment id="12884425" author="srowen" created="Thu, 1 Jul 2010 22:20:23 +0100"  >&lt;p&gt;It&apos;s all looking reasonably good. I think the patch may need an update to match head as I am getting errors applying it. i bet they are small issues.&lt;/p&gt;

&lt;p&gt;I skimmed through it and have a few questions:&lt;/p&gt;

&lt;p&gt;findDeclaredField() and setField() &amp;#8211; yeah I see what you&apos;re doing though it seems a little fragile to dig inside an object and change its fields. They are just tests, so maybe it&apos;s OK, but are there alternatives? Even for tests, if it&apos;s private, I think it&apos;s not testable myself.&lt;/p&gt;

&lt;p&gt;Are there any chances to reduce the number of unique writable objects we&apos;re creating? There is some need to specialize and create custom objects for performance though I do see there are starting to be lots of objects that hold one or two primitives and I&apos;m keen to reuse classes if reasonable&lt;/p&gt;

&lt;p&gt;Likewise I don&apos;t mind adding more utility classes per se but I prefer to avoid utils/helper classes if the methods can be reasonably attached to another implementation. I haven&apos;t looked hard at it, maybe these are necessary, just noting one concern.&lt;/p&gt;

&lt;p&gt;I&apos;ll have to look more at the patch when I can apply it and view it in the IDE.&lt;/p&gt;

&lt;p&gt;Does this change behavior of the recommender job or is it the same initial input and final output?&lt;/p&gt;</comment>
                            <comment id="12884574" author="ssc" created="Fri, 2 Jul 2010 08:17:10 +0100"  >&lt;p&gt;The latest patch should work with the head now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Are there any chances to reduce the number of unique writable objects we&apos;re creating? There is some need to specialize and create custom objects for performance though I do see there are starting to be lots of objects that hold one or two primitives and I&apos;m keen to reuse classes if reasonable&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is certainly desirable, yet is seems very difficult to me, especially when we use features like secondary sort which requires very specialized objects. If you see a good starting point on which objects to generalize I&apos;d be ready to put some work into that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;findDeclaredField() and setField() - yeah I see what you&apos;re doing though it seems a little fragile to dig inside an object and change its fields. They are just tests, so maybe it&apos;s OK, but are there alternatives? Even for tests, if it&apos;s private, I think it&apos;s not testable myself.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I can see your point here. In an ideal world you would want to write unit-tests that know nothing about the actual implementation of the class to test and treat it like a &quot;blackbox&quot;, giving it some input and then checking the output. However you have to get the class to test into a certain state before it can be tested in a lot of cases. From my experience the best way to achieve this is to make the class ready for dependency injection so it can be configured from outside, yet I don&apos;t think this really fits good for MapReduce code. So I thought the easiest way to get control over the classes state for testing was to directly set the private fields which is a very unobtrusive way because the code does not need to be changed just for testing purposes, yet this approach has the drawback of binding the tests directly to the implementation of the classes that are tested. If we want to avoid that we&apos;d have to refactor the code a bit to be more testable I think.&lt;/p&gt;

&lt;p&gt;A rather complex example for this would be the AggregateAndRecommendReducer which fills an OpenIntLongHashMap from a SequenceFile when it is setup. In the test for that class, I did not want to create a sequencefile on disk and have it read that, because that would make the test code unreadable and instead of only testing one method (the reduce() method) I would also implicitly have to test the setup method additionally. So I thought the easiest to write and most understandable way would be to create an OpentIntLongHashMap and directly assign that to the private field. Another solution might be to introduce a package-private setter method that could be called by the testcode. &lt;/p&gt;

&lt;p&gt;I can try to refactor the code to avoid the setField() calls, if you want. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Likewise I don&apos;t mind adding more utility classes per se but I prefer to avoid utils/helper classes if the methods can be reasonably attached to another implementation. I haven&apos;t looked hard at it, maybe these are necessary, just noting one concern.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not to fond of utility classes either, especially because they are usually called statically. Yet what I dislike more is code duplication and I tried to only move methods into utility classes that are called from at least two different classes. One example why this is crucial is the parsing of lines from preference text files. I saw that in some places only a comma is allowed as delimiter, while other classes also allow a tab. That&apos;s a typical example for what happens when code is duplicated and new functionality is introduced, so I thought it&apos;d be far better to move this functionality into a utility class to have exactly one place in the code where the delimiter is specified.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Does this change behavior of the recommender job or is it the same initial input and final output?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Everything stays the same, the only difference is that you have to tell the job which similarity measure to use.&lt;/p&gt;</comment>
                            <comment id="12884636" author="srowen" created="Fri, 2 Jul 2010 11:56:14 +0100"  >&lt;p&gt;Now that I&apos;m looking at the patch I have a number of question. It seems to be changing many key points of the job, and I wish to see that the functionality and optimizations are not being lost.&lt;/p&gt;

&lt;p&gt;I&apos;m not fully understanding is handling of NaN. You see what was done before &amp;#8211; NaN values in vectors were used to exclude items from recommendation. It&apos;s a reasonably nice way to do it. What&apos;s the equivalent here? I see other bits of code paying attention to NaN.&lt;/p&gt;

&lt;p&gt;Are we handling &quot;boolean&quot; preferences efficiently? Before it would avoid the vector-times-preference step when the pref was known to be 1.0, and I don&apos;t see that now.&lt;/p&gt;

&lt;p&gt;Finally there is a feature in vectors that will save space, causing it to write float values instead of doubles, since we don&apos;t need 64 bits of precision. I also don&apos;t see how that&apos;s preserved.&lt;/p&gt;

&lt;p&gt;Basically I am not yet sure how the new computation is structured from reading the code. I think some comments on the &quot;Aggregate&quot; jobs would be ideal. &lt;/p&gt;

&lt;p&gt;It&apos;s also a big task to test but my concern is how fast this runs now. I got to about 700 hours CPU for 5.7 million users / 130M ratings and I&apos;m afraid that it can easily go up by orders of magnitude if some of the optimizations aren&apos;t here.&lt;/p&gt;</comment>
                            <comment id="12884726" author="ssc" created="Fri, 2 Jul 2010 16:45:50 +0100"  >&lt;p&gt;Hi Sean,&lt;/p&gt;

&lt;p&gt;I think you&apos;re right, optimization is crucial here and there&apos;s still a lot of work to do. I will have a look at the things you pointed out. Meanwhile I will try to answer your questions and explain the way the job works best I can. I hope I can explain it good enough so you can join in on this.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;m not fully understanding is handling of NaN. You see what was done before - NaN values in vectors were used to exclude items from recommendation. It&apos;s a reasonably nice way to do it. What&apos;s the equivalent here? I see other bits of code paying attention to NaN.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;From the example output attached one can see that there&apos;s always a NaN summand mapped for the prediction computation towards items a user already knows, so those will be excluded too, as the predicted preference will be NaN too. Unfortunately this happens only in the last computation stage, I didn&apos;t find a way to do it earlier (maybe you see one?).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Are we handling &quot;boolean&quot; preferences efficiently? Before it would avoid the vector-times-preference step when the pref was known to be 1.0, and I don&apos;t see that now.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t think that the current patch works well for boolean preferences. I will need some time to investigate that (or maybe you could give me some hints).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Finally there is a feature in vectors that will save space, causing it to write float values instead of doubles, since we don&apos;t need 64 bits of precision. I also don&apos;t see how that&apos;s preserved.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think changing the doubles to floats in PredictionPartWritable will have the same effect as the float values in the vectors you mentioned, that will be on my todo list for an updated patch.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basically I am not yet sure how the new computation is structured from reading the code. I think some comments on the &quot;Aggregate&quot; jobs would be ideal.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I attached the computations of the unit-test example (with the combiner disabled for clarity), I hope the output can provide a clear picture of how the computation is done.  Please note that this is an unrealistic example as every item is similar to every other item.&lt;/p&gt;

&lt;p&gt;A short summary of the changes:&lt;/p&gt;

&lt;p&gt;The cooccurrence matrix has been replaced with the similarity matrix and the PartialMultiplyMapper and the AggregateAndRecommendReducer have changed partly.&lt;/p&gt;

&lt;p&gt;The PartialMultiplyMapper receives the preferences (userIDs and prefValues) as well as the column from the similarity matrix for an item. &lt;/p&gt;

&lt;p&gt;For each preference and similar item it now maps a summand of the numerator and a summand of the denominator (wrapped in a PredictionPartWritable) of the formula for the prediction of the preference of the user towards the similar item:&lt;/p&gt;

&lt;p&gt;i = the current item the PartialMultiplyMapper is looking at&lt;br/&gt;
u = a user preferring that item&lt;br/&gt;
j = an item similar to i (known from the similarity matrix column)&lt;/p&gt;

&lt;p&gt;Prediction(u,j) = ... + preference(u,i) * similarity(i,j) + ... / ... + |similarity(i,j)| + ...&lt;/p&gt;

&lt;p&gt;The AggregateAndRecommendReducer receives all PredictionPartWritables for a user (secondary sorted by item) and can thus compute all the predictions for the user.&lt;/p&gt;

&lt;p&gt;-----------------------------------------&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; 
user-item-matrix   
   
        burger  hotdog  berries  icecream
dog       5       5        2        -   
rabbit    2       -        3        5 
cow       -       5        -        3   
donkey    3       -        -        5


item-item-similarity-matrix (tanimoto-coefficient of the item-vectors of the user-item-matrix)

        burger  hotdog  berries icecream
burger    -      0.25    0.66    0.5
hotdog   0.25     -      0.33    0.25
berries  0.66    0.33     -      0.25
icecream 0.5     0.25    0.25     -



Prediction(dog, icecream)   = (0.5 * 5 + 0.25 * 5 + 0.25 * 2 ) / (0.5 + 0.25 + 0.25)  ~ 4.3
Prediction(rabbit, hotdog)  = (0.25 * 2 + 0.33 * 3 + 0.25 * 5) / (0.25 + 0.33 + 0.25) ~ 3,3
Prediction(cow, burger)     = (0.25 * 5 + 0.5 * 3) / (0.25 + 0.5)                     ~ 3,7 
Prediction(cow, berries)    = (0.33 * 5 + 0.25 * 3) / (0.33 + 0.25)                   ~ 4,1
Prediction(donkey, hotdog)  = (0.25 * 3 + 0.25 * 5) / (0.25 + 0.25)                   ~ 4
Prediction(donkey, berries) = (0.66 * 3 + 0.25 * 5) / (0.66 + 0.25)                   ~ 3,6

-----------------------------------------

PartialMultiplyMapper: looking at item [1]
	looking at user [1] with preference [5.0]
		similar item [1] with similarity [NaN]
		similar item [2] with similarity [0.25]
		similar item [3] with similarity [0.6666667]
		similar item [4] with similarity [0.5]
	looking at user [2] with preference [2.0]
		similar item [1] with similarity [NaN]
		similar item [2] with similarity [0.25]
		similar item [3] with similarity [0.6666667]
		similar item [4] with similarity [0.5]
	looking at user [4] with preference [3.0]
		similar item [1] with similarity [NaN]
		similar item [2] with similarity [0.25]
		similar item [3] with similarity [0.6666667]
		similar item [4] with similarity [0.5]

PartialMultiplyMapper: looking at item [2]
	looking at user [1] with preference [5.0]
		similar item [1] with similarity [0.25]
		similar item [2] with similarity [NaN]
		similar item [3] with similarity [0.33333334]
		similar item [4] with similarity [0.25]
	looking at user [3] with preference [5.0]
		similar item [1] with similarity [0.25]
		similar item [2] with similarity [NaN]
		similar item [3] with similarity [0.33333334]
		similar item [4] with similarity [0.25]

PartialMultiplyMapper: looking at item [3]
	looking at user [1] with preference [2.0]
		similar item [1] with similarity [0.6666667]
		similar item [2] with similarity [0.33333334]
		similar item [3] with similarity [NaN]
		similar item [4] with similarity [0.25]
	looking at user [2] with preference [3.0]
		similar item [1] with similarity [0.6666667]
		similar item [2] with similarity [0.33333334]
		similar item [3] with similarity [NaN]
		similar item [4] with similarity [0.25]

PartialMultiplyMapper: looking at item [4]
	looking at user [2] with preference [5.0]
		similar item [1] with similarity [0.5]
		similar item [2] with similarity [0.25]
		similar item [3] with similarity [0.25]
		similar item [4] with similarity [NaN]
	looking at user [3] with preference [3.0]
		similar item [1] with similarity [0.5]
		similar item [2] with similarity [0.25]
		similar item [3] with similarity [0.25]
		similar item [4] with similarity [NaN]
	looking at user [4] with preference [5.0]
		similar item [1] with similarity [0.5]
		similar item [2] with similarity [0.25]
		similar item [3] with similarity [0.25]
		similar item [4] with similarity [NaN]

AggregateAndRecommendReducer: Computing predictions for user [1]
	Predicting preference towards [1]
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [1.3333334] to numerator and similarity [0.6666667] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [2]
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [0.6666667] to numerator and similarity [0.33333334] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [3]
		adding preference*similarity [3.3333335] to numerator and similarity [0.6666667] to denominator
		adding preference*similarity [1.6666667] to numerator and similarity [0.33333334] to denominator
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [4]
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [2.5] to numerator and similarity [0.5] to denominator
		adding preference*similarity [0.5] to numerator and similarity [0.25] to denominator
		Predicted preference is [4.25]

AggregateAndRecommendReducer: Computing predictions for user [2]
	Predicting preference towards [1]
		adding preference*similarity [2.0] to numerator and similarity [0.6666667] to denominator
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		adding preference*similarity [2.5] to numerator and similarity [0.5] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [2]
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [0.5] to numerator and similarity [0.25] to denominator
		adding preference*similarity [1.0] to numerator and similarity [0.33333334] to denominator
		Predicted preference is [3.3]
	Predicting preference towards [3]
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		adding preference*similarity [1.3333334] to numerator and similarity [0.6666667] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [4]
		adding preference*similarity [1.0] to numerator and similarity [0.5] to denominator
		adding preference*similarity [0.75] to numerator and similarity [0.25] to denominator
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		Predicted preference is [NaN]

AggregateAndRecommendReducer: Computing predictions for user [3]
	Predicting preference towards [1]
		adding preference*similarity [1.5] to numerator and similarity [0.5] to denominator
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		Predicted preference is [3.6666667]
	Predicting preference towards [2]
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		adding preference*similarity [0.75] to numerator and similarity [0.25] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [3]
		adding preference*similarity [1.6666667] to numerator and similarity [0.33333334] to denominator
		adding preference*similarity [0.75] to numerator and similarity [0.25] to denominator
		Predicted preference is [4.142857]
	Predicting preference towards [4]
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		Predicted preference is [NaN]

AggregateAndRecommendReducer: Computing predictions for user [4]
	Predicting preference towards [1]
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		adding preference*similarity [2.5] to numerator and similarity [0.5] to denominator
		Predicted preference is [NaN]
	Predicting preference towards [2]
		adding preference*similarity [0.75] to numerator and similarity [0.25] to denominator
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		Predicted preference is [4.0]
	Predicting preference towards [3]
		adding preference*similarity [1.25] to numerator and similarity [0.25] to denominator
		adding preference*similarity [2.0] to numerator and similarity [0.6666667] to denominator
		Predicted preference is [3.5454545]
	Predicting preference towards [4]
		adding preference*similarity [1.5] to numerator and similarity [0.5] to denominator
		adding preference*similarity [NaN] to numerator and similarity [NaN] to denominator
		Predicted preference is [NaN]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; </comment>
                            <comment id="12885140" author="ssc" created="Mon, 5 Jul 2010 09:34:07 +0100"  >&lt;p&gt;I uploaded an alternative patch, that uses vectors instead of custom writables for the computation in the last step. It should be easier to understand and closer to the current implementation. Unfortunately I couldn&apos;t figure out how to write a Combiner for the Aggregate step when doing the computation this way and I also didn&apos;t find a way to filter out recommendations that were only based on one data point.&lt;/p&gt;

&lt;p&gt;Nevertheless I hope it helps us decide which path to go here.&lt;/p&gt;</comment>
                            <comment id="12885563" author="ssc" created="Tue, 6 Jul 2010 16:22:58 +0100"  >&lt;p&gt;I did some local tests using the 100K movielens dataset, generating 10 recommendations per user and having maxPrefsPerUserConsidered set to 25 and maxCooccurrencesPerItemConsidered/maxSimilaritiesPerItemConsidered set to 25. &lt;br/&gt;
I checked the overall running time and the amount of data that was read and written in the partialMultiply and aggregateAndRecommend jobs.&lt;/p&gt;

&lt;p&gt;The simple cooccurrence-based recommender finished in approximately one minute and read and wrote about 200MB in the partialMultiply and aggregateAndRecommend jobs. All of my patches needed&lt;br/&gt;
about 6 minutes and read and wrote 3-4 times as much data... I finally figured out that that huge difference was caused by me not pruning the vectors as it was done before in the UserVectorToCooccurrenceMapper.&lt;/p&gt;

&lt;p&gt;I added that step and evolved the latest patch (the one that uses vectors instead of custom writables).&lt;/p&gt;

&lt;p&gt;I got it to finish the job in one minute too and write about 400MB in the partialMultiply and 300MB in the aggregateAndRecommend step when the computation was done using pearson correlation as similarity . I tried to apply all optimizations you mentioned (like setWritesLaxPrecision(true) on the VectorWritables, no multiplication if the pref is 1 and a special computation method for boolean data). I also found a way to make the patch drop recommendations based on only one data point (the same thing GenericItemBasedRecommender.doEstimatePreference(...) is doing).&lt;/p&gt;

&lt;p&gt;Are we on the right path and do you see more optimization potential?&lt;/p&gt;</comment>
                            <comment id="12885568" author="srowen" created="Tue, 6 Jul 2010 16:51:45 +0100"  >&lt;p&gt;It certainly sounds like it&apos;s on the right path. I haven&apos;t yet had a chance to look at it.&lt;br/&gt;
My broad concerns are whether it performs about as well and doesn&apos;t work too differently, but it sounds like those are fine.&lt;br/&gt;
I will look at the patch within a few days.&lt;/p&gt;</comment>
                            <comment id="12886413" author="srowen" created="Thu, 8 Jul 2010 20:05:31 +0100"  >&lt;p&gt;I&apos;m going to commit this since I&apos;m convinced enough you&apos;ve tested it and streamlined it. I have looked over it again briefly and don&apos;t see anything that jumps out at me. I&apos;d like to commit even if later we find some additional changes that are required since that way we can continue to collaborate on these changes rather than pass back and forth patches.&lt;/p&gt;

&lt;p&gt;Later I&apos;ll need to rewrite some of the book chapter on this but that&apos;s fine.&lt;/p&gt;</comment>
                            <comment id="12886448" author="hudson" created="Thu, 8 Jul 2010 21:19:36 +0100"  >&lt;p&gt;Integrated in Mahout-Quality #128 (See &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Mahout-Quality/128/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Mahout-Quality/128/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-420&quot; title=&quot;Improving the distributed item-based recommender&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-420&quot;&gt;&lt;del&gt;MAHOUT-420&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12886641" author="ssc" created="Fri, 9 Jul 2010 08:35:33 +0100"  >&lt;p&gt;I&apos;m pretty content with the latest patch too and I think it fits the current coding style best. Let me know when there are changes to be made, I&apos;m willing to invest as much time as needed here.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12448548" name="MAHOUT-420-2.patch" size="93428" author="ssc" created="Fri, 2 Jul 2010 08:14:40 +0100"/>
                            <attachment id="12448673" name="MAHOUT-420-2a.patch" size="80087" author="ssc" created="Mon, 5 Jul 2010 09:30:11 +0100"/>
                            <attachment id="12448785" name="MAHOUT-420-3.patch" size="93256" author="ssc" created="Tue, 6 Jul 2010 16:20:18 +0100"/>
                            <attachment id="12448492" name="MAHOUT-420.patch" size="94159" author="ssc" created="Thu, 1 Jul 2010 14:34:31 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 1 Jul 2010 21:20:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9643</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy587:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22998</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>