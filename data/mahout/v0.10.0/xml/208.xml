<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:21:17 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-208/MAHOUT-208.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-208] Vector.getLengthSquared() is dangerously optimized</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-208</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;SparseVector and DenseVector both cache the value of lengthSquared, so that subsequent calls to it get the cached value.  Great, except the cache is never cleared - calls to set/setQuick or assign or anything, all leave the cached value unchanged.  &lt;/p&gt;

&lt;p&gt;Mutating method calls should set lengthNorm to -1 so that the cache is cleared.&lt;/p&gt;

&lt;p&gt;This could be a really nasty bug if hit.&lt;/p&gt;</description>
                <environment>&lt;p&gt;all&lt;/p&gt;</environment>
        <key id="12441595">MAHOUT-208</key>
            <summary>Vector.getLengthSquared() is dangerously optimized</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jake.mannix">Jake Mannix</assignee>
                                    <reporter username="jake.mannix">Jake Mannix</reporter>
                        <labels>
                    </labels>
                <created>Tue, 24 Nov 2009 19:06:05 +0000</created>
                <updated>Sat, 21 May 2011 04:24:16 +0100</updated>
                            <resolved>Thu, 28 Jan 2010 06:16:53 +0000</resolved>
                                    <version>0.1</version>
                                    <fixVersion>0.3</fixVersion>
                                    <component>Math</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12788848" author="srowen" created="Thu, 10 Dec 2009 19:14:14 +0000"  >&lt;p&gt;Agree, I already saw this and half-fixed it as regards readFields(). Yes, it is a bad one indeed. Seems like the caller should cache the value if it&apos;s so important.&lt;/p&gt;

&lt;p&gt;Any objection to removing this caching?&lt;/p&gt;</comment>
                            <comment id="12788854" author="tdunning" created="Thu, 10 Dec 2009 19:30:40 +0000"  >
&lt;p&gt;This caching can be a really major win so I would prefer to keep it.&lt;/p&gt;

&lt;p&gt;You are correct that many callers could cache it, but that can also be quite difficult because they would need to cache &lt;b&gt;lots&lt;/b&gt; of lengths.  Moreover, the caching is primarily to assist in computing distances between sparse vectors.  Thus if you compute the distance v1 and v2 in one part of the code, it isn&apos;t real obvious how some other part of the code would know to cache these lengths for when v2 is compared to v3.  Certainly it isn&apos;t easy to understand how the caller could inject the cached values into the euclideanDistance call that it is supposed to accelerate.&lt;/p&gt;

&lt;p&gt;Having the caching in vectors makes all of this happen with no overhead (other than stupid bugs) for users who don&apos;t use the capability and only minimal effort for users who do use the capability.&lt;/p&gt;</comment>
                            <comment id="12788857" author="jake.mannix" created="Thu, 10 Dec 2009 19:31:29 +0000"  >&lt;p&gt;We could remove it, but I actually did something like this in decomposer, and kept track of a single boolean (isCacheValid or whatever) which would get set to false whenever a mutating method was called (not worrying about the case where you were setting it to something which didn&apos;t change the lengthNorm - ie be as conservative as possible).  But with iterator methods which can mutate the vector entries as well, tracking down all the places where things can change could be tricky (and adding another isCacheValid = false in all the inner loops... is there a perf impact?).&lt;/p&gt;

&lt;p&gt;The other option is to just have a immutable subclasses which do keep track of things like this where we know it won&apos;t change, and as you say, the caller can keep track of it in the mutable case.&lt;/p&gt;

&lt;p&gt;There is a use-case for this though, if you&apos;re running over a huge set of vectors (say, a big matrix of them), and need to do dot products with them and then divide or multiply by norms or whatnot, keeping track of all of these norms externally is a lot of overhead, but recomputing them every time doubles your run time.  &lt;/p&gt;</comment>
                            <comment id="12788862" author="tdunning" created="Thu, 10 Dec 2009 19:39:43 +0000"  >&lt;p&gt;(ted speaking from far down the slippery slope)&lt;/p&gt;

&lt;p&gt;We could have mutable iterators that set the cache flag to false if you even ask for the iterator and immutable iterators that throw an exception if you try to mutate anything.&lt;/p&gt;
</comment>
                            <comment id="12788869" author="jake.mannix" created="Thu, 10 Dec 2009 19:47:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;We could have mutable iterators that set the cache flag to false if you even ask for the iterator and immutable iterators that throw an exception if you try to mutate anything.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So we go from having one iterator, to two, to four?  Talk about ew, right?  Or is this not what you&apos;re suggesting?&lt;/p&gt;</comment>
                            <comment id="12789171" author="kshashi" created="Fri, 11 Dec 2009 08:33:14 +0000"  >&lt;p&gt;It is important to have this caching  to keep the work done on &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-121&quot; title=&quot;Speed up distance calculations for sparse vectors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-121&quot;&gt;&lt;del&gt;MAHOUT-121&lt;/del&gt;&lt;/a&gt; intact. &lt;/p&gt;

&lt;p&gt;Alternative to maintaining caching flag is to use the hashcode of underlying constructs. For example, in case of SparseVector, we could use OpenIntDoubleHashMap.hashCode() to see if the cached value is still valid.  In case of DenseVectors, hashcode of arrays can be used.&lt;/p&gt;
</comment>
                            <comment id="12789201" author="jake.mannix" created="Fri, 11 Dec 2009 10:00:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;Alternative to maintaining caching flag is to use the hashcode of underlying constructs. For example, in case of SparseVector, we could use OpenIntDoubleHashMap.hashCode() to see if the cached value is still valid. In case of DenseVectors, hashcode of arrays can be used.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Does this really work?  hashCode() is nearly as expensive as lengthNorm() to compute itself, so unless I&apos;m blanking on some fancy thing the JVM does to cache hashcodes and invalidate them when data which would make them change... then you do a hashCode() check to see if you need to recompute the lengthNorm(), taking nearly twice the time in the case where there was mutation, and taking O(numNonZeroEntries) time instead of O(1) when there wasn&apos;t.&lt;/p&gt;</comment>
                            <comment id="12789207" author="srowen" created="Fri, 11 Dec 2009 10:11:18 +0000"  >&lt;p&gt;Agree with Jake, there isn&apos;t any special handling of hashcode. This also introduces the possibility of errors, which seems unacceptable for this API.&lt;/p&gt;

&lt;p&gt;I&apos;ll go the other way and just fix handling of the caching, because yes it&apos;s going to be quite wrong if the vector is changed.&lt;/p&gt;</comment>
                            <comment id="12789217" author="jake.mannix" created="Fri, 11 Dec 2009 10:30:25 +0000"  >&lt;p&gt;So the strategy is just &quot;be careful&quot; (what I did in decomposer), not &quot;separate out the mutating iterators from the immutable ones&quot;, right?  Personally I&apos;d be fine if we decided to go the slightly easier route for now, and only did caching on immutable vectors (make a new subclass, and move the caching down into that), because this actually covers most of both Shashi and my main use cases.  Of course, there are probably many more, so &quot;doing it right&quot; and keeping a properly invalidated cache even for mutable vectors is desirable in the long run.&lt;/p&gt;</comment>
                            <comment id="12789262" author="srowen" created="Fri, 11 Dec 2009 12:10:21 +0000"  >&lt;p&gt;Actually I think you are right that this is the ultimate solution. Many uses of Vector don&apos;t mutate them, and therefore that should be something one can optimize for by selecting an immutable implementation.&lt;/p&gt;

&lt;p&gt;Actually there are a number of issues I&apos;d like to discuss about the Vector implementation, perhaps sooner than later. Who should I understand to be the &quot;owner&quot; of Vector? I also ask because we need to understand how the migration to Colt is going, and who&apos;s heading that up.&lt;/p&gt;

&lt;p&gt;But for purposes here: fixing this right now means recomputing the length on each set() operation. That&apos;s better than broken code, but is it better than not caching? If I just took out caching actually would that be good motivation to refactor Vector?&lt;/p&gt;</comment>
                            <comment id="12789274" author="jake.mannix" created="Fri, 11 Dec 2009 12:26:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;Actually there are a number of issues I&apos;d like to discuss about the Vector implementation, perhaps sooner than later. Who should I understand to be the &quot;owner&quot; of Vector? I also ask because we need to understand how the migration to Colt is going, and who&apos;s heading that up.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll own Matrix and Vector if nobody else really has serious plans for it.  &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-205&quot; title=&quot;Pull Writable (and anything else hadoop dependent) out of the matrix module&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-205&quot;&gt;&lt;del&gt;MAHOUT-205&lt;/del&gt;&lt;/a&gt; is something which needs to come soon, so we can make a hadoop-independent linar package, with a separate interface to Hadoop, and then a (couple of) fully parallel Matrix implementation(s), as well as the whole incorporation of Colt primitives.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But for purposes here: fixing this right now means recomputing the length on each set() operation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No!  Far too costly.  Just invalidate the cache (set lengthNorm to -1, or set a boolean), because maybe nobody will ever call lengthNorm() on this Vector again, so why recompute it?  Just leave it lazily for the lengthNorm() call.&lt;/p&gt;</comment>
                            <comment id="12789284" author="srowen" created="Fri, 11 Dec 2009 12:49:10 +0000"  >&lt;p&gt;Fixed by adding &apos;  lengthSquared = -1.0; &apos; to every place the values are mutated.&lt;/p&gt;</comment>
                            <comment id="12790118" author="kshashi" created="Mon, 14 Dec 2009 12:16:04 +0000"  >&lt;p&gt;Apologies. I &lt;b&gt;assumed&lt;/b&gt; underlying library already does some caching for hash value. String does cache, but it is immutable, so it is &quot;obvious.&quot; Caching hashcode for mutable object will face the same problems as us. &lt;/p&gt;
</comment>
                            <comment id="12805408" author="jakemannix" created="Wed, 27 Jan 2010 08:19:09 +0000"  >&lt;p&gt;Hmm... I&apos;m getting bitten by this again: setQuick() mutates, but only calls &quot;lengthSquared = -1.0&quot; in DenseVector.  The sparse vectors don&apos;t do this, and nasty things happen. Will check in fix.&lt;/p&gt;</comment>
                            <comment id="12805560" author="jake.mannix" created="Wed, 27 Jan 2010 16:23:23 +0000"  >&lt;p&gt;reopening until I check in the sparse fixes.&lt;/p&gt;</comment>
                            <comment id="12805806" author="jake.mannix" created="Thu, 28 Jan 2010 06:16:53 +0000"  >&lt;p&gt;fixed in r903965&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 10 Dec 2009 19:14:14 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9857</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy6jj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23211</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>