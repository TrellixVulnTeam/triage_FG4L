<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:20:52 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-881/MAHOUT-881.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-881] Refactor TopItems to use Lucene&apos;s PriorityQueue and remove excessive sorting</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-881</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;TopItems.getTop*() all do a fair number of excessive operations that can be replaced by switching to using Lucene&apos;s PriorityQueue implementation, which is more efficient and faster than Java&apos;s built in PQ implementation.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12531219">MAHOUT-881</key>
            <summary>Refactor TopItems to use Lucene&apos;s PriorityQueue and remove excessive sorting</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="7">Later</resolution>
                                        <assignee username="gsingers">Grant Ingersoll</assignee>
                                    <reporter username="gsingers">Grant Ingersoll</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 Nov 2011 08:10:20 +0000</created>
                <updated>Thu, 9 Feb 2012 14:02:54 +0000</updated>
                            <resolved>Sun, 20 Nov 2011 13:25:17 +0000</resolved>
                                    <version>0.6</version>
                                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="13149012" author="gsingers" created="Sat, 12 Nov 2011 08:50:33 +0000"  >&lt;p&gt;This patch converts TopItems to use Lucene PQ and removes unnecessary sorts, etc.  It fails on one test due to the fact that the old code does not provide a total ordering on the SimilarUser object (it does not honor the x.compare&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; == 0 implies x.equals&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; suggestion of Comparable) which means that in the GenericUserBasedRecommenderTest.testMostSimilar() asserts that the returned item is #4, but my version returns #3, which has the same score as #4.  This is because I break ties using the id.&lt;/p&gt;</comment>
                            <comment id="13149034" author="srowen" created="Sat, 12 Nov 2011 10:06:22 +0000"  >&lt;p&gt;-1 Grant I thought we discussed this on the mailing list? I don&apos;t see that this achieves anything. You are still doing an implicit n log n heap sort to attain an ordered result. You still allocate a container object for the result. This seems like swapping some code for more complex (but equally working) code, and adding a Lucene dependency.&lt;/p&gt;

&lt;p&gt;Do you have a load test that shows it would be notably faster? the patch does have such a thing.&lt;/p&gt;

&lt;p&gt;The comment about SimilarUser is right though. It would just affect tie breaking, which doesn&apos;t really matter, but should be fixed.&lt;/p&gt;</comment>
                            <comment id="13149048" author="hudson" created="Sat, 12 Nov 2011 11:32:50 +0000"  >&lt;p&gt;Integrated in Mahout-Quality #1170 (See &lt;a href=&quot;https://builds.apache.org/job/Mahout-Quality/1170/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/Mahout-Quality/1170/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-881&quot; title=&quot;Refactor TopItems to use Lucene&amp;#39;s PriorityQueue and remove excessive sorting&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-881&quot;&gt;&lt;del&gt;MAHOUT-881&lt;/del&gt;&lt;/a&gt;: add a unit test for TopItems also fix minor code formatting issue&lt;/p&gt;

&lt;p&gt;gsingers : &lt;a href=&quot;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1201222&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1201222&lt;/a&gt;&lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/mahout/trunk/core/src/main/java/org/apache/mahout/cf/taste/impl/recommender/TopItems.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/core/src/test/java/org/apache/mahout/cf/taste/impl/recommender/TopItemsTest.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13149081" author="hudson" created="Sat, 12 Nov 2011 14:46:50 +0000"  >&lt;p&gt;Integrated in Mahout-Quality #1171 (See &lt;a href=&quot;https://builds.apache.org/job/Mahout-Quality/1171/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/Mahout-Quality/1171/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-882&quot; title=&quot;TopItems.getTopUsers ignores rescoring&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-882&quot;&gt;&lt;del&gt;MAHOUT-882&lt;/del&gt;&lt;/a&gt; Actually used rescored value in one TopItems method. Also, fix SimilarUser issue along the way from &lt;a href=&quot;https://issues.apache.org/jira/browse/MAHOUT-881&quot; title=&quot;Refactor TopItems to use Lucene&amp;#39;s PriorityQueue and remove excessive sorting&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MAHOUT-881&quot;&gt;&lt;del&gt;MAHOUT-881&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;srowen : &lt;a href=&quot;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1201248&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&amp;amp;view=rev&amp;amp;rev=1201248&lt;/a&gt;&lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/mahout/trunk/core/src/main/java/org/apache/mahout/cf/taste/impl/recommender/SimilarUser.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/core/src/main/java/org/apache/mahout/cf/taste/impl/recommender/TopItems.java&lt;/li&gt;
	&lt;li&gt;/mahout/trunk/core/src/test/java/org/apache/mahout/cf/taste/impl/recommender/GenericUserBasedRecommenderTest.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13149106" author="yseeley@gmail.com" created="Sat, 12 Nov 2011 16:37:12 +0000"  >&lt;p&gt;Grant&apos;s patch seems to half the number of PQ operations while collecting the top N.  I don&apos;t know enough about possible Mahout usage patterns, or the relative cost to this against everything else to know if it matters, but it does for Lucene.  One lucene example is sorting by date descending when they have been added in roughly ascending order - the number of PQ operations is very high, so cutting it down by half is a nice win.&lt;/p&gt;

&lt;p&gt;As far as the sort, the patch essentially implements a heap sort, taking advantage of the fact that we have already done the first half of that (building the heap).  Not sure how to compare that to other sort algorithms...&lt;/p&gt;

&lt;p&gt;Memory usage also seems improved.  This existing code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    List&amp;lt;RecommendedItem&amp;gt; result = Lists.newArrayListWithCapacity(size);
    result.addAll(topItems);
    Collections.sort(result, ByValueRecommendedItemComparator.getInstance());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Object&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt; allocated for the ArrayList&lt;/li&gt;
	&lt;li&gt;result.addAll calls toArray which creates another Object&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt; and then copies it to the first&lt;/li&gt;
	&lt;li&gt;Collections.sort creates another Object&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt; while doing the mergesort, then iterates the original collection, setting every item&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think Grant&apos;s might be improved by using Arrays.asList which would avoid an extra Object&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt; allocation + copy.&lt;/p&gt;

&lt;p&gt;So the patch also improves on the memory use - but again, I don&apos;t know enough about Mahout to know if it matters in this context.&lt;/p&gt;</comment>
                            <comment id="13149109" author="srowen" created="Sat, 12 Nov 2011 17:02:03 +0000"  >&lt;p&gt;(See my comments on dev@ too)&lt;/p&gt;

&lt;p&gt;Why are there fewer operations? Both seem to do an insert if the new item is known to be among the new top-N, and not otherwise.&lt;/p&gt;

&lt;p&gt;Both versions allocate the ArrayList. I think you&apos;re quite right about the addAll() and sort() though. Even if that&apos;s an implementation detail, it&apos;s real. Those are a few extra arrays of size 10-ish on average, so I would imagine it&apos;s not significant. But I also don&apos;t like the idea.&lt;/p&gt;

&lt;p&gt;On the other hand, I have an unfounded suspicion that the implicit heap sort here is slower in practice here than a simple quicksort, since that is generally the case.&lt;/p&gt;

&lt;p&gt;I would be surprised if this was not all but identical in performance. We could also make some micro-wins here in other ways to avoid these couple extra allocations. or we can use the Lucene-based queue and avoid heap sort. I have a very slight aversion to changing to something equal but different, replacing very standard java.util.PriorityQueue with merely &quot;standard&quot; Lucene PriorityQueue.&lt;/p&gt;

&lt;p&gt;If I&apos;m wrong that this isn&apos;t equal &amp;#8211; I support it. If we all concludes it&apos;s equal, or barely slower, I&apos;m -0 on the change and really not fussed about it.&lt;/p&gt;</comment>
                            <comment id="13149111" author="yseeley@gmail.com" created="Sat, 12 Nov 2011 17:28:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;Why are there fewer operations? Both seem to do an insert if the new item is known to be among the new top-N, and not otherwise.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Assuming a full priority queue, you have an add() and a poll() per competitive entry (I don&apos;t think there&apos;s a way to get around that using Java&apos;s PQ).  Lucene&apos;s PQ can rebalance the heap once per competitive entry.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I have an unfounded suspicion that the implicit heap sort here is slower in practice here than a simple quicksort, since that is generally the case.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Heapsort is generally slower than quicksort... but since we already have a built heap, we&apos;re only doing half-a-heapsort?&lt;/p&gt;</comment>
                            <comment id="13149112" author="yseeley@gmail.com" created="Sat, 12 Nov 2011 17:38:03 +0000"  >&lt;p&gt;Grant&apos;s patch should probably also continue to track lowestTopValue to avoid creating unnecessary GenericRecommendedItem objects.&lt;/p&gt;
</comment>
                            <comment id="13149113" author="srowen" created="Sat, 12 Nov 2011 17:40:31 +0000"  >&lt;p&gt;Both good points, I get you now. For me, these last few are valid, and tally up to enough of a theoretical win that I support the patch. I&apos;m guessing that it&apos;s still virtually identically fast in practice &amp;#8211; for example the expected number of add/poll operations when finding the top 10 is just about 20 anyway. I know from profiling that virtually no time is spent here. Even if it adds some code, I think it&apos;s nice.&lt;/p&gt;</comment>
                            <comment id="13149127" author="gsingers" created="Sat, 12 Nov 2011 19:28:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;Grant&apos;s patch should probably also continue to track lowestTopValue to avoid creating unnecessary GenericRecommendedItem objects&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll add that.&lt;/p&gt;</comment>
                            <comment id="13149128" author="gsingers" created="Sat, 12 Nov 2011 19:31:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;replacing very standard java.util.PriorityQueue with merely &quot;standard&quot; Lucene PriorityQueue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that you will find many of Java&apos;s implementations are subpar for high performance, specialized cases, which is what we have here.  So, yeah, they have standard APIs that everyone knows, but the downside is they are usually slower.&lt;/p&gt;</comment>
                            <comment id="13149130" author="yseeley@gmail.com" created="Sat, 12 Nov 2011 19:33:55 +0000"  >&lt;p&gt;One last note: &lt;b&gt;if&lt;/b&gt; the number of competitive entries is ever expected to be high (as is the case with the lucene example I gave above) then you can still cap the number of GenericRecommendedItem objects created by making them mutable.  Then on a competitive entry and a full PQ, you modify the bottom entry and call adjustTop() instead of creating a new entry.&lt;/p&gt;</comment>
                            <comment id="13149136" author="gsingers" created="Sat, 12 Nov 2011 20:18:31 +0000"  >&lt;p&gt;Adds back in the checks for fullness and lowest value.&lt;/p&gt;

&lt;p&gt;Still working on benchmarking.  I think it would be nice if we could do both macro and micro benchmark.  For macro, Lucene has a nice benchmark toolkit that is pretty flexible/pluggable that we maybe could leverage.&lt;/p&gt;</comment>
                            <comment id="13149138" author="ssc" created="Sat, 12 Nov 2011 20:22:13 +0000"  >&lt;p&gt;You should also include org.apache.mahout.cf.taste.common.FixedSizePriorityQueue in your optimizations if possible, as its implementing the same functionality.&lt;/p&gt;</comment>
                            <comment id="13149219" author="gsingers" created="Sun, 13 Nov 2011 05:21:26 +0000"  >&lt;p&gt;Here&apos;s an updated patch which has some basic benchmarking.  Still need to validate on real machine and double check some more things.  &lt;/p&gt;</comment>
                            <comment id="13149270" author="srowen" created="Sun, 13 Nov 2011 10:18:18 +0000"  >&lt;p&gt;Since it&apos;s easy, I just used jprofiler to observe the exact difference. See attached excerpt from the call graph, before and after. Out of about 23 minutes of CPU time spent in the getTopItems() method, the cost of queue operations did in fact drop, from 90 microseconds to 47 microseconds. That&apos;s 0.0065% of runtime before, or about 1 part in 15,000, so I don&apos;t think you are observing any actual difference in runtime.&lt;/p&gt;

&lt;p&gt;I&apos;m not against this; I suppose that if it&apos;s not adding what we thought and is introducing very slightly more complexity and change, I&apos;d be very slightly predisposed to not make such a change. Or what about addressing some of those allocations directly that Yonik mentioned, if anything? Those are 1-liners.&lt;/p&gt;

&lt;p&gt;In any event, I would rather not also change AbstractAverageDifferenceEvaluator &amp;#8211; was that just a temp change? Or I could work in reporting those figures differently for you. To answer your TODO: returning an array would change the API, and cause some other difficult breakage (IIRC). It&apos;s a List on purpose. I think you&apos;ll find however that Arrays.asList() is the better method call there, probably avoids overhead.&lt;/p&gt;</comment>
                            <comment id="13149380" author="gsingers" created="Sun, 13 Nov 2011 22:11:11 +0000"  >&lt;p&gt;Yeah, I did some profiling too and came to the same conclusion.  I&apos;m going to shelve this.  We can come back to it after improving some of the other things.&lt;/p&gt;</comment>
                            <comment id="13149381" author="srowen" created="Sun, 13 Nov 2011 22:17:57 +0000"  >&lt;p&gt;I think the tests should at least be committed. I&apos;d also like to make some 1-liner improvements here that are obvious, if tiny, wins.&lt;/p&gt;</comment>
                            <comment id="13149382" author="gsingers" created="Sun, 13 Nov 2011 22:24:07 +0000"  >&lt;p&gt;Yeah, tests are good and the evaluator.&lt;/p&gt;</comment>
                            <comment id="13149385" author="tdunning" created="Sun, 13 Nov 2011 22:52:08 +0000"  >&lt;blockquote&gt;
&lt;p&gt;from 90 microseconds to 47 microseconds&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is consistent with my experience in other efforts.  The priority queue is rarely the problem if you avoid inserting most elements and even if you do insert most elements due to pathological ordering of the original data, it isn&apos;t a big deal since the cost is n log k where n is the number of documents and k is the size of the queue.&lt;/p&gt;

&lt;p&gt;One big difference that we can probably make, however, is to multi-thread some of these sequential programs.  This isn&apos;t very hard with the Executors in Java.  This doesn&apos;t make things more efficient, but it does make them 10x faster on commonly available servers.  That is an effort for a different JIRA in any case.&lt;/p&gt;</comment>
                            <comment id="13149387" author="gsingers" created="Sun, 13 Nov 2011 23:09:08 +0000"  >&lt;p&gt;I see some other things we can do, too.  For instance, I&apos;m benchmarking whether we can avoid what allocating the arrays for storing the similarity results so often.  &lt;/p&gt;</comment>
                            <comment id="13149391" author="tdunning" created="Sun, 13 Nov 2011 23:37:46 +0000"  >&lt;blockquote&gt;
&lt;p&gt;avoid what allocating the arrays&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There is a somewhat pathological interest in the Lucene community about avoiding allocation.  The standard approach to doing this is to re-use data structures.&lt;/p&gt;

&lt;p&gt;In fact, this often has a perverse effect on the GC that makes programs slower overall and definitely makes the code far more error prone.&lt;/p&gt;

&lt;p&gt;The problem with performance is rarely allocation and is far more commonly the cost of copying.  If the idiom that you are using to avoid allocation still involves as much copying, then you are unlikely to save anything at all by avoiding an allocation and it may cost you quite a bit since you are making an array live longer than its natural life which can, in the worst situations, even trigger a full GC if the array survives too long.&lt;/p&gt;

&lt;p&gt;For most uses of arrays such as score accumulators, the copying is inherent in the algorithm being used and is not something to be avoided because having the array be collected as a short-lived object is usually the most efficient way to go.&lt;/p&gt;

&lt;p&gt;Mutation and re-use also introduces complexities of storage management that are roughly equivalent to the cognitive load of malloc/free which, particularly if not associated with any level of optimization should be avoided like the plague.&lt;/p&gt;

&lt;p&gt;One common idiom that used to cause performance issues had to do with gratuitous boxing and unboxing of data in order to package it for passing between different parts of code.  This is much less of a problem than it used to be because lots of these uses are inlined and the structure creation is optimized away.  You still have to watch for it with collections because of the memory pressure that it creates.&lt;/p&gt;
</comment>
                            <comment id="13153784" author="gsingers" created="Sun, 20 Nov 2011 12:50:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think the tests should at least be committed. I&apos;d also like to make some 1-liner improvements here that are obvious, if tiny, wins.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Were you referring to the tests already committed?  Also, I&apos;d like to see something like the LoadEvaluationRunner in, but an earlier comment suggested not changing the AbstractDiffRecommenderEvaluator.  Sean, do you have other suggestions for getting those stats out?&lt;/p&gt;</comment>
                            <comment id="13153791" author="srowen" created="Sun, 20 Nov 2011 12:58:35 +0000"  >&lt;p&gt;I&apos;m referring to TopItemsTest and anything already committed. All of that is of course useful.&lt;br/&gt;
Sketch out what kind of stats you&apos;d like out of this (in another JIRA if you like) and I&apos;ll implement it. More data is OK, just thought I might be able to set up the API in a way that accommodates it all more easiliy.&lt;/p&gt;</comment>
                            <comment id="13153799" author="gsingers" created="Sun, 20 Nov 2011 13:25:17 +0000"  >&lt;p&gt;Once PQ operations become a bottleneck (b/c everything else is fast) we can revisit.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12503527" name="Call_Tree.html" size="7222" author="srowen" created="Sun, 13 Nov 2011 10:18:44 +0000"/>
                            <attachment id="12503528" name="Call_Tree_2.html" size="8124" author="srowen" created="Sun, 13 Nov 2011 10:18:44 +0000"/>
                            <attachment id="12503512" name="MAHOUT-881.patch" size="20570" author="gsingers" created="Sun, 13 Nov 2011 05:21:25 +0000"/>
                            <attachment id="12503500" name="MAHOUT-881.patch" size="19770" author="gsingers" created="Sat, 12 Nov 2011 20:18:31 +0000"/>
                            <attachment id="12503480" name="MAHOUT-881.patch" size="15034" author="gsingers" created="Sat, 12 Nov 2011 08:50:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 12 Nov 2011 10:06:22 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>216956</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy2ef:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22540</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>