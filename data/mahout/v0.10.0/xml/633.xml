<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:23:46 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MAHOUT-633/MAHOUT-633.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MAHOUT-633] Add SequenceFileIterable; put Iterable stuff in one place</title>
                <link>https://issues.apache.org/jira/browse/MAHOUT-633</link>
                <project id="12310751" key="MAHOUT">Mahout</project>
                    <description>&lt;p&gt;In another project I have a useful little class, SequenceFileIterable, which simplifies iterating over a sequence file. It&apos;s like FileLineIterable. I&apos;d like to add it, then use it throughout the code. See patch, which for now merely has the proposed new classes. &lt;/p&gt;

&lt;p&gt;Well it also moves some other iterator-related classes that seemed to be outside their rightful home in common.iterator.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12502214">MAHOUT-633</key>
            <summary>Add SequenceFileIterable; put Iterable stuff in one place</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srowen">Sean Owen</assignee>
                                    <reporter username="srowen">Sean Owen</reporter>
                        <labels>
                            <label>iterable</label>
                            <label>iterator</label>
                            <label>sequence-file</label>
                    </labels>
                <created>Wed, 23 Mar 2011 18:44:52 +0000</created>
                <updated>Sat, 21 May 2011 04:19:00 +0100</updated>
                            <resolved>Thu, 31 Mar 2011 10:25:28 +0100</resolved>
                                    <version>0.4</version>
                                    <fixVersion>0.5</fixVersion>
                                    <component>Classification</component>
                    <component>Clustering</component>
                    <component>Collaborative Filtering</component>
                        <due>Thu, 31 Mar 2011 00:00:00 +0000</due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="13010310" author="ssc" created="Wed, 23 Mar 2011 19:28:24 +0000"  >&lt;p&gt;looks very useful to me!&lt;/p&gt;

&lt;p&gt;It would be great if we also had an iterator that runs over all the parts* files in a directory, that would allow us to simplify a lot of code.&lt;/p&gt;</comment>
                            <comment id="13010497" author="dlyubimov" created="Wed, 23 Mar 2011 22:39:01 +0000"  >&lt;p&gt;if you want to be true to the Hadoop contract, you need to refactor the following to use hadoop&apos;s ReflectionUtils and pass in the configuration. There are tons of writables around that are also Configurable. Including one of my Mahout&apos;s branches that equips VectorWritable with additional capabilties and controls them by making it Configurable.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void instantiateKeyValue() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
+    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
+      key = keyClass.newInstance();
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (noValue) {
+        value = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
+      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
+        value = valueClass.newInstance();
+      }
+    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InstantiationException ie) {
+      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IOException(ie);
+    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (IllegalAccessException iae) {
+      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IOException(iae);
+    }
+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13010506" author="dlyubimov" created="Wed, 23 Mar 2011 22:55:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;It would be great if we also had an iterator that runs over all the parts* files in a directory, that would allow us to simplify a lot of code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Even better: Hadoop globs... &lt;/p&gt;</comment>
                            <comment id="13010649" author="srowen" created="Thu, 24 Mar 2011 12:48:17 +0000"  >&lt;p&gt;Both good points!&lt;/p&gt;</comment>
                            <comment id="13011865" author="srowen" created="Sun, 27 Mar 2011 23:18:12 +0100"  >&lt;p&gt;I&apos;m through core now, but no tests or other modules. It&apos;s already an epic patch, but I think it&apos;s quite good. It actually deletes 100 lines more of code than it adds, and reduces some duplication, and even does a bit better job at cleanup.&lt;/p&gt;

&lt;p&gt;I&apos;m still working on this patch.&lt;/p&gt;

&lt;p&gt;The one possible downside is that this implementation creates a new Writable for each read. This is mildly positive in that it avoids some common bugs in reading from sequence files wherein the caller doesn&apos;t realize it&apos;s storing a copy to a Writable that&apos;s changing. (The Mahout code is cloning/instantiating new ones in most cases anyways as it has to) It does mean more objects allocated though. While I think the overhead of that is minor, probably, compared to the I/O of the read itself, it&apos;s not obviously trivial.&lt;/p&gt;

&lt;p&gt;I think this can be designed around in the wrapper &amp;#8211; for instance often the key is not used so that can be embedded in the logic of the iterator to avoid allocations.&lt;/p&gt;

&lt;p&gt;The only gotchas to watch out for in this patch are, first, that change / fix? to VectorCache. And second Dmitriy when I ran into some of your latest commits I left several uses of SequenceFile.Reader as-is since it needs to be done that way, but ended up accumulating a load of small style changes. That bit of the patch is noisy. (There was also a section where I think I elided use of a &quot;closeables&quot; object in the case where it seemed to be a no-op?)&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="13011873" author="tdunning" created="Mon, 28 Mar 2011 01:13:29 +0100"  >&lt;blockquote&gt;
&lt;p&gt;The one possible downside is that this implementation creates a new Writable for each read. This is mildly positive in that it avoids some common bugs in reading from sequence files wherein the caller doesn&apos;t realize it&apos;s storing a copy to a Writable that&apos;s changing. (The Mahout code is cloning/instantiating new ones in most cases anyways as it has to) It does mean more objects allocated though. While I think the overhead of that is minor, probably, compared to the I/O of the read itself, it&apos;s not obviously trivial.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that creating a new Writable each time is probably a good thing on the whole.  I doubt seriously that it will be any slower as long as it avoids unnecessary copying of a large structure.  If you avoid large copies then new allocation can actually be better than re-use since new allocation keeps the garbage reclamation work in the newspace collector which is considerably better than letting stuff get copied several times and possibly even tenured.&lt;/p&gt;</comment>
                            <comment id="13011879" author="dlyubimov" created="Mon, 28 Mar 2011 01:40:48 +0100"  >&lt;p&gt;seems good to me. &lt;br/&gt;
I am not stuck on certain style issues, i just used eclipse&apos;s ctrl-shift-f autoformat. So it&apos;s fine it&apos;s just hard for me to tell &apos;good&apos; from &apos;bad&apos; sometimes. Such as i don&apos;t use compound block &lt;/p&gt;
{ .. }
&lt;p&gt; if there&apos;s only one statement in there. it&apos;s just something i do. I thought it was also Sun&apos;s convention but I don&apos;t have a strong opinion. &lt;/p&gt;

&lt;p&gt;I see that you don&apos;t support glob expressions for multiple files yet? Did you decide not to support multiple files or it&apos;s TBD or i am missing some extra helper functionality here?&lt;/p&gt;

&lt;p&gt;I see that you applied that to loading the (R_1, R_2...R_z). That seems technically correct to me the way it is done here. But irony is that couldn&apos;t use a glob expression parameterized cause order of side R files is relevant. So if you ever switch to multiple files by Hadoop glob, that piece would not be covered. Perhaps there&apos;s a space for a contract to supply both glob and comparator for files selecting so they are opened in a predefined order (like there in BtJob).&lt;/p&gt;

&lt;p&gt;perhaps a constructor version &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; 
SequenceFileIterator ( &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;(or path) glob, Comparator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; or Path&amp;gt; openSequenceComparator)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; would solve that in one bite. &lt;/p&gt;

&lt;p&gt;There&apos;s a helper method in SSVDSolver that does the same (load matrices in memory). That probably has an extensive use &amp;#8211; i think in tests mostly but it might be used something else. So that might be refactored to use this as well. but i can attend to it myself later. &lt;/p&gt;

&lt;p&gt;I am kind of inclined to frown on not reusing Writables. That&apos;s what hadoop does and there&apos;s a rather good reason for that. GC thrashing. Effects on massive datasets are felt especially if the job is CPU-bound (which is how the SSVD is). I actually see up to 20% improvements in running times when i equip VectorWritable with preprocessing ability so that it doesn&apos;t create a vector for every iteration &amp;#8211; just because of GC thrashing. SSVD solver relies on that to load side R sequences &amp;#8211; currently, all at once into RAM that&apos;s currently a bottleneck for RAM scalability. It can be thus somewhat sizeable, so that better be done as efficiently as possible. GC thrashing probably going to be especially bad in this case since we are trying to load a lot of stuff into memory which has the same (tenured) lifespan and GC will have especially bad overhead in Young gen space especially as we approach to RAM limits for the R data. &lt;/p&gt;

&lt;p&gt;Problem usually is that it is o.k. to approach RAM limits when you don&apos;t need to relinquish objects. But if you do a lot of (small dead) GC material floating around, full GCs including memory defrags will occur more often and take more time to a degree that you&apos;d eventually be more busy doing GCs than anything else on 64bit systems with large heaps (&amp;gt;2G xmx). This may last for quite a long time before you are bound to converge on OOM. But if your RAM use prediction is tuned accurately, you&apos;d never hit OOM but it&apos;d be just painfully slow in java (i have a lot of experience with seeing that). The only remedy that i know is to preallocate near-limit RAM that you need in advance and in big chunks and  not to create any (if possible, at all) &apos;dead small&apos; GC stuff per iteration. (IMO). That said, that purely comes from observing the effects, I am not actually very strong on inner workings of GC.&lt;/p&gt;

</comment>
                            <comment id="13011904" author="dlyubimov" created="Mon, 28 Mar 2011 04:35:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;&lt;br/&gt;
I think that creating a new Writable each time is probably a good thing on the whole. I doubt seriously that it will be any slower as long as it avoids unnecessary copying of a large structure. If you avoid large copies then new allocation can actually be better than re-use since new allocation keeps the garbage reclamation work in the newspace collector which is considerably better than letting stuff get copied several times and possibly even tenured.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;so we are clear, we are talking &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;A&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Writable w = ReflectionUtil.newIntance(...)
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ( i = 0 ; i&amp;lt; 100000000; i++ ) { 
  ... &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; something with w ... 
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;vs.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;B&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ( i = 0 ; i&amp;lt; 100000000; i++ ) { 
  Writable w = ReflectionUtil.newIntance(...)
  ... &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; something with w ... 
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;... and you essentually saying that B is faster than A. I am not a GC expert so i reserve right to be wrong. but i am dubious about it because of my benchmarks and simulations i ran on java.&lt;/p&gt;

&lt;p&gt;1) It&apos;s one writable (a handful references at most) vs. young reference in every iteration. Sure, YGC and allocation are fast, but I am kind of dubious it is faster than not doing anything at all. In fact, we want it to tenure and even go to permanent pool so YGC &apos;forgets&apos; about it and not check it any more, but even if it doesn&apos;t happen we don&apos;t care much since it&apos;s only one iteration for GC. Overhead, as far as i understand, in this case only happens during full gcs which would be rarer than YGC.&lt;/p&gt;

&lt;p&gt;2) what i witness usually is that dynamics changes quite a bit when you approach the memory limit. Full GCs are happenning in that situation more frequently (perhaps you can fight that by decreasing young GC space but i couldn&apos;t and it&apos;s still a hassle to tune). Full GCs are also quite long running. In fact, this problem is so bad that HBase folks told me they had cases when Full GC even with 12G caused pauses long enough to break 40 second zookeeper session to a region node (causing node die-offs). So they in fact recommend longer zk sessions for higher RAMs just because of GC! &lt;/p&gt;

&lt;p&gt;So either you don&apos;t approach the limit (i.e. not use all RAM you paid for) or preallocate stuff and let it tenure without adding much new in the mix. &lt;/p&gt;

&lt;p&gt;In practice what i found that allocation of new objects that don&apos;t leave YGC is indeed better in my benchmarks than yanking them from either pessimistic or even optimistic object pool (with optimistic pools, i.e. those running on Compare-And-Swap operations those using  surprisingly being only marginally better) but things are starting to change quite dramatically as soon as you try to fill in say 5G out of 6 and factor in all tenured and full gc overhead. &lt;/p&gt;

&lt;p&gt;Actually in practice for real time applications the best practice i found is to run java processes at ~300M with the rest of the system dedicated to I/O cache which keeps my memory mapped structures (btrees and such). java heaps are only used to allocate a handful of long lived and reused object trees to walk the memory-mapped structures. That combination seems to be unbeatable so far. Kernel manages &apos;bulk&apos; memory and you manage TWAs. And even if the rest of the processing is causing full GCs, they are unlikely to be catastrophic on that size of heap. but that&apos;s of course is not applicable to batches. &lt;/p&gt;

&lt;p&gt;In general, i would be very greatful if somebody could give me hint how to fight GC thrashing in near-full RAM situations, but in any event i think i doubt that it would be preferring code B over A.&lt;/p&gt;
</comment>
                            <comment id="13011908" author="dlyubimov" created="Mon, 28 Mar 2011 04:45:29 +0100"  >&lt;p&gt;P.S. my stochastic projection jobs with modified VectorWritable which doesn&apos;t form actual vector at all but rather passes elements on stack memory also seem to run significantly faster just because of that. which is basically equivalent to case A vs. case B. I don&apos;t have exact benchmark comparison on hand since I never really wanted to compared it but it&apos;s quite apparent even with -Xmx200M map tasks. So perhaps if we could have actual real-life simulation benchmarks, we could actually see how &quot;bad&quot; or &quot;good&quot; it is. But my evidence so far has been pretty &quot;bad&quot;, although i did not care collecting it for some time now so it related to less modern jvms.&lt;/p&gt;</comment>
                            <comment id="13011910" author="dlyubimov" created="Mon, 28 Mar 2011 05:15:37 +0100"  >&lt;p&gt;Here is how hbase is fighting this: &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3455&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-3455&lt;/a&gt;. Not quite the same as batch iteration but basically, the same thing i was talking about : cloning stuff into one &quot;old&quot; reference and reusing it is more &quot;benign&quot; than tons of short-lived references. Not clear if they got any significant performance boost, but they clearly experience dramatically less full GCs in 0.90.1. I think performance would be more affected more in CPU-bound batch though than in an hbase type serivce.&lt;/p&gt;
</comment>
                            <comment id="13012480" author="srowen" created="Tue, 29 Mar 2011 14:43:39 +0100"  >&lt;p&gt;Here comes a new version of the patch. Yes I have in here glob and list support, ReflectionUtils, and avoiding creation of extra key instances where not needed.&lt;/p&gt;

&lt;p&gt;This actually should be called the &quot;Great Iterator Patch&quot;. I kept finding little things around Iterators, Iterables, PathFilters as well that could be refactored and threw it into the mix. I really like the result, but, it&apos;s a doozy of a patch. It does delete a net 500 lines of code, tests pass, it&apos;s definitely standardized about 80% of the interaction with reading sequence files, and fixed a few small bugs along the way (see what I did to StableFixedSizeSamplingIterator for instance &amp;#8211; it wasn&apos;t stable).&lt;/p&gt;

&lt;p&gt;Sebastian I think there are appropriate calls to makeQualified().&lt;/p&gt;

&lt;p&gt;Dmitriy let me now go read your comments, I had not actually seen them yet!&lt;/p&gt;</comment>
                            <comment id="13012482" author="srowen" created="Tue, 29 Mar 2011 14:50:56 +0100"  >&lt;p&gt;On new Writables: I agree, I don&apos;t think it can be faster to allocate many Writables. This is really the big possible problem with what this patch does. &lt;/p&gt;

&lt;p&gt;I found that in maybe 60% of cases the key is discarded, so, wrote special support for that which would not make a new key object on each iteration.&lt;/p&gt;

&lt;p&gt;And, in about half the cases, the caller is cloning the key and/or value because it wants to save a copy. So in some cases it&apos;s already making new objects.&lt;/p&gt;

&lt;p&gt;I had in mind that this factor is probably dwarfed by I/O and the actual deserialization... right? I had the impression these Hadoop jobs were most certainly I/O bound, not memory/GC/CPU bound.&lt;/p&gt;

&lt;p&gt;There&apos;s a subtle argument for correctness too... it&apos;s a bit all-to-easy to forget to clone a key or value and get bitten with a subtle bug. But this is more of a minor practical argument.&lt;/p&gt;

&lt;p&gt;And of course the whole point of the exercise is to standardize the code, since from touring the code it was clear there were many approaches (e.g. makeQualified() or not) and occasional correctness issues (e.g. no call to close()).&lt;/p&gt;

&lt;p&gt;That&apos;s my reasoning. Thoughts on this thinking? I suppose my gut is that this isn&apos;t a big deal, but I don&apos;t have evidence.&lt;/p&gt;</comment>
                            <comment id="13012486" author="srowen" created="Tue, 29 Mar 2011 14:55:22 +0100"  >&lt;p&gt;On sorting the order of input &amp;#8211; Dmitriy I think I kept my hands off the cases where it looked like it was not a simple matter of iterating through the results from globStatus() and listStatus(). The patch is, well, a mess to read. What in particular are you referring to so I can double-check? anything involving SSVDSolver.partitionComparator for instance? I didn&apos;t touch those.&lt;/p&gt;

&lt;p&gt;We can definitely add sorting support.&lt;/p&gt;</comment>
                            <comment id="13012621" author="dlyubimov" created="Tue, 29 Mar 2011 19:59:16 +0100"  >&lt;p&gt;yes &amp;#8211; it is often the case &amp;#8211; esp. in lin algebra side info files &amp;#8211; that you need to load those blocks in a specific order. In this case order is determined by the task id. That&apos;s what my code is doing here.&lt;/p&gt;

&lt;p&gt;It&apos;s just if you don&apos;t have support for some strategy determining file order then i can&apos;t use your multifile glob support. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;anything involving SSVDSolver.partitionComparator for instance? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;&amp;#8211;&lt;br/&gt;
Thought No 2: I also had a thought that maybe it&apos;s worth to factor the problem out into two : 1 &amp;#8211; sequence file iterator and 2-- multifile glob iterator (supporting ordering as well) that delegates iterating to single file iterator. (that&apos;s usually how i did that sort of stuff). &lt;/p&gt;</comment>
                            <comment id="13012626" author="srowen" created="Tue, 29 Mar 2011 20:08:18 +0100"  >&lt;p&gt;Oh yes, it&apos;s already split up that way and one delegates to the other. Ordering is easy to add. How about I add it to the patch and let you take a look at using it? I say that as I think it may be better if you have a look at what I changed directly to make sure it makes sense, and that&apos;s a small way of accomplishing this.&lt;/p&gt;</comment>
                            <comment id="13012629" author="dlyubimov" created="Tue, 29 Mar 2011 20:11:43 +0100"  >&lt;p&gt;I haven&apos;t looked thru the patch yet. I will try to do it in the evening.&lt;/p&gt;

&lt;p&gt;But i think we are in agreement except for missing ordering support &amp;#8211; i could add it later if you want. &lt;/p&gt;</comment>
                            <comment id="13012634" author="dlyubimov" created="Tue, 29 Mar 2011 20:20:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;And, in about half the cases, the caller is cloning the key and/or value because it wants to save a copy. So in some cases it&apos;s already making new objects.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that&apos;s true. We can&apos;t prevent ppl from screwing it over. We only can given them a chance not to. And I want that chance for myself.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I had in mind that this factor is probably dwarfed by I/O and the actual deserialization... right? I had the impression these Hadoop jobs were most certainly I/O bound, not memory/GC/CPU bound.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not in SSVD, it packs parts of massive scale QR and and stochastic projection in one map step and i had it 98.8% avg CPU saturation. Which basically told me i wasn&apos;t wasteful on I/O &amp;#8211; which I tried pretty hard not to be. QR algorithms are quadratic &amp;#8211; even that we reduce the scale of the problem. I am still a little bit wasteful on flops here but it&apos;s not dramatic and it got to be enough for open source. So this near-limit memory use GC stuff will affect me very very much (i build a series of jobs with similar dynamics before in java 1.5, it was pretty bad (up to 50 times slower) until i employed the strategies i told about above).&lt;/p&gt;</comment>
                            <comment id="13012637" author="dlyubimov" created="Tue, 29 Mar 2011 20:27:55 +0100"  >&lt;blockquote&gt;&lt;p&gt;Oh yes, it&apos;s already split up that way and one delegates to the other. Ordering is easy to add. How about I add it to the patch and let you take a look at using it? I say that as I think it may be better if you have a look at what I changed directly to make sure it makes sense, and that&apos;s a small way of accomplishing this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes sir, i will try to do it in the evening. (My daughter going to sleep routine permitting).&lt;/p&gt;</comment>
                            <comment id="13012639" author="srowen" created="Tue, 29 Mar 2011 20:31:26 +0100"  >&lt;p&gt;Sounds like we just need a new flag or something to select reuse of the key/value objects. Then I can go back and enable it where the code seemed to have been reusing them already. I can get on that along with ordering support.&lt;/p&gt;

&lt;p&gt;While it&apos;s sounding complex... I think it&apos;s really not much, compared to the amount of clean-up and code removal this is enabling. I quite like all this.&lt;/p&gt;

&lt;p&gt;Good luck reading the patch. Really, you want to look at new code in .common.iterator.sequencefile, and how it&apos;s used in your bits of code. The rest is probably not relevant.&lt;/p&gt;</comment>
                            <comment id="13012658" author="tdunning" created="Tue, 29 Mar 2011 20:59:59 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Not in SSVD, it packs parts of massive scale QR and and stochastic projection in one map step and i had it 98.8% avg CPU saturation. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Dmitriy,&lt;/p&gt;

&lt;p&gt;How much of that time was due to GC?&lt;/p&gt;

&lt;p&gt;Do you have any evidence that simpler techniques that cause ephemeral garbage are increasing your memory pressure?&lt;/p&gt;</comment>
                            <comment id="13012724" author="dlyubimov" created="Tue, 29 Mar 2011 22:43:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;How much of that time was due to GC?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the tests I ran, not significant. But i was using preprocessing handler on VectorWritable (the patch you guys were reluctant to accept) which did not create intermediate vector storage at all. All matrix elements were passed in on stack. Mahout&apos;s patch doesn&apos;t have this code but i will be happy to put it in jira for discussion. Also, i did not run close to memory limits on the tasks i ran with SSVD. I just don&apos;t have datasets that big. &lt;/p&gt;

&lt;p&gt;But i ran other code that did &amp;#8211; and like i said, running time losses were significant, up to order of magnitude (in jvm 1.5).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do you have any evidence that simpler techniques that cause ephemeral garbage are increasing your memory pressure?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am not sure I understand this. If you are asking whether memory use per se is increased because of you are using tons of short lived references instead of one &apos;old&apos; gen reference, no, i don&apos;t beleive that effect would be very significant so as we can construe it as being detrimental. It&apos;s just in near-limits memory use you&apos;d vent out significantly more cpu on this, actually, surpirsingly a lot of cpu on 64bit systems with big heaps and a lot of references in them (&amp;gt;40 second global pauses, i.e. 4 times that on per-cpu basis, per full GC run on 12Gb), that&apos;s all. It&apos;s only apparent in jobs that need a lot of side info to run.&lt;/p&gt;</comment>
                            <comment id="13012728" author="dlyubimov" created="Tue, 29 Mar 2011 22:51:08 +0100"  >&lt;p&gt;I guess i need to clarify that i am not talking about situation that something is bad when you have -Xmx6G and start using a lot of small references. &lt;/p&gt;

&lt;p&gt;I am talking about situation when before you start iterating, you have already preloaded 5G out of 6G with &quot;stuff&quot;. or something along those lines. Low-mem situation.&lt;/p&gt;</comment>
                            <comment id="13012735" author="dlyubimov" created="Tue, 29 Mar 2011 23:00:43 +0100"  >&lt;blockquote&gt;&lt;p&gt;In the tests I ran, not significant. But i was using preprocessing handler on VectorWritable (the patch you guys were reluctant to accept) which did not create intermediate vector storage at all. All matrix elements were passed in on stack. Mahout&apos;s patch doesn&apos;t have this code but i will be happy to put it in jira for discussion. Also, i did not run close to memory limits on the tasks i ran with SSVD. I just don&apos;t have datasets that big. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually correction: i do think i saw difference in running time between code running with existing VectorWriable that creates interim vector instances for each iteration and the code that just passes matrix elements on stack. But like i said i did not measure the difference it as it was not my goal. And it&apos;s not the evidence i&apos;d like to appeal anyway since there wasn&apos;t much side info. But i have other situations (outside Mahout realm but also iterative batches with big side info) that i&apos;d like to appeal to. &lt;/p&gt;</comment>
                            <comment id="13012741" author="gsingers" created="Tue, 29 Mar 2011 23:08:04 +0100"  >&lt;p&gt;You probably should take over the SequenceFileVectorIterable class I added in Utils.&lt;/p&gt;</comment>
                            <comment id="13012846" author="dlyubimov" created="Wed, 30 Mar 2011 05:58:02 +0100"  >&lt;p&gt;Ok.. i see just two functional changes: &lt;/p&gt;

&lt;p&gt;&amp;#8211; replacing deep copy iterator for upper-triangular matrices with copy-constructor iterator, which seems to be fine (although it uses reflection to invoke copy-constructor whereas ad-hoc stuff uses direct invocation, which is technically slower but who cares). &lt;/p&gt;

&lt;p&gt;&amp;#8211; using sequenceFileIterator for reading side info R sequences in BtJob. Also seems fine by looking at it. This actually could use multifile glob iterator provided there&apos;s a way to enforce order like i described. &lt;/p&gt;

&lt;p&gt;I think qtInput also might be replaced with the same iterator (second side feed)&lt;/p&gt;

&lt;p&gt;Am i missing any other functional changes? thanks.&lt;/p&gt;</comment>
                            <comment id="13012847" author="dlyubimov" created="Wed, 30 Mar 2011 06:04:00 +0100"  >&lt;p&gt;Actually deep copy iterator was using copy-constructor just because it was hasty solution . Acutally it could&apos;ve reused the same double[] (as in same &apos;writable&apos; pattern). well this side R matrices info doesn&apos;t use mass iterations so it probably won&apos;t be much of an overhead (only ~1000 instances in all job max).&lt;/p&gt;</comment>
                            <comment id="13013684" author="srowen" created="Wed, 30 Mar 2011 22:44:41 +0100"  >&lt;p&gt;One last patch. This has everything we&apos;ve talked about. It won&apos;t create new instances unless it&apos;s necessary. Should be a win-win change now.&lt;/p&gt;</comment>
                            <comment id="13013709" author="dlyubimov" created="Wed, 30 Mar 2011 23:24:43 +0100"  >&lt;p&gt;Looks fine. Terrific effort. &lt;br/&gt;
I guess i can wire up SequenceFileDirIterable as appropriate, later.&lt;/p&gt;
</comment>
                            <comment id="13014280" author="hudson" created="Fri, 1 Apr 2011 00:30:44 +0100"  >&lt;p&gt;Integrated in Mahout-Quality #708 (See &lt;a href=&quot;https://hudson.apache.org/hudson/job/Mahout-Quality/708/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://hudson.apache.org/hudson/job/Mahout-Quality/708/&lt;/a&gt;)&lt;/p&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12475018" name="MAHOUT-633.patch" size="542170" author="srowen" created="Wed, 30 Mar 2011 22:44:41 +0100"/>
                            <attachment id="12474879" name="MAHOUT-633.patch" size="461060" author="srowen" created="Tue, 29 Mar 2011 14:43:39 +0100"/>
                            <attachment id="12474742" name="MAHOUT-633.patch" size="219406" author="srowen" created="Sun, 27 Mar 2011 23:18:12 +0100"/>
                            <attachment id="12474426" name="MAHOUT-633.patch" size="30096" author="srowen" created="Wed, 23 Mar 2011 18:59:09 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 23 Mar 2011 19:28:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9428</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxy3x3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22786</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>