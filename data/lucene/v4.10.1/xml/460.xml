<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:14:24 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-460/LUCENE-460.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[LUCENE-460] hashCode improvements</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-460</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                    <description>&lt;p&gt;It would be nice for all Query classes to implement hashCode and equals to enable them to be used as keys when caching.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12325152">LUCENE-460</key>
            <summary>hashCode improvements</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                    <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Sun, 30 Oct 2005 23:36:01 +0000</created>
                <updated>Thu, 18 Jul 2013 21:54:07 +0100</updated>
                            <resolved>Thu, 6 Apr 2006 11:10:47 +0100</resolved>
                                                                    <component>core/search</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12356325" author="yseeley@gmail.com" created="Mon, 31 Oct 2005 00:04:04 +0000"  >&lt;p&gt;A couple of guidelines off the top of my head...&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;hash codes should strive to be unique across the Query hierarchy, not just unique within one specific subclass.  For example, TermQuery(t) and SpanTermQuery(t) will generate the exact same hash codes.&lt;/li&gt;
	&lt;li&gt;mix bits between different components that have any hashCode parts in common...&lt;br/&gt;
   for example RangeQuery will produce the same hashCode whenever lowerTerm==upperTerm.&lt;br/&gt;
   Also, field&lt;span class=&quot;error&quot;&gt;&amp;#91;x TO y&amp;#93;&lt;/span&gt; will produce the same hashCode for &lt;b&gt;any&lt;/b&gt; field since the fieldname parts of the&lt;br/&gt;
  terms will always cancel eachother out.  This will also cause the hashCode of field
{x TO x}
&lt;p&gt; to equal field:x&lt;br/&gt;
  The hashCode of FilteredQuery will also cause many collisions because the bits aren&apos;t mixed inbetween&lt;br/&gt;
   the query and the filter.&lt;br/&gt;
  Remember that every query as a boost component... never just xor two query hashCodes together.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;make things position dependent.&lt;br/&gt;
  Currently, field&lt;span class=&quot;error&quot;&gt;&amp;#91;x TO y&amp;#93;&lt;/span&gt; will produce the same hasCode as field&lt;span class=&quot;error&quot;&gt;&amp;#91;y TO x&amp;#93;&lt;/span&gt;... not particularly important for RangeQuery, but&lt;br/&gt;
   you get the idea. &lt;/li&gt;
	&lt;li&gt;don&apos;t be afraid of using &quot;&lt;ins&gt;&quot; instead of &quot;^&quot;.  They both take a single CPU cycle, but &quot;&lt;/ins&gt;&quot; is not quite so easily (accidentally) reversed.&lt;/li&gt;
	&lt;li&gt;flipping more than a single bit when hashing a boolean might be a good idea - it will make collisions harder.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;http://www.concentric.net/~Ttwang/tech/inthash.htm&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.concentric.net/~Ttwang/tech/inthash.htm&lt;/a&gt; is an interesting link on integer hash codes (what we are in effect doing when we combine multiple hash codes).  Esp interesting is the section &quot;Parallel Operations&quot;&lt;/p&gt;</comment>
                            <comment id="12356326" author="yseeley@gmail.com" created="Mon, 31 Oct 2005 00:07:52 +0000"  >&lt;p&gt;Oh, and preserve entropy by using reversible integer hash functions (see the previous link).&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;key ^= (key &amp;lt;&amp;lt; a) | (key &amp;gt;&amp;gt;&amp;gt; b); for a,b in (17,16) (16,17) (14,19) (19,14) (13,20) (20,13) (10,23) (23,10) (8,25) (25,8)&lt;/li&gt;
	&lt;li&gt;multiply by an odd&lt;/li&gt;
	&lt;li&gt;addition&lt;/li&gt;
	&lt;li&gt;xor&lt;/li&gt;
	&lt;li&gt;rotates&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12356327" author="lucenebugs@danielnaber.de" created="Mon, 31 Oct 2005 00:14:08 +0000"  >&lt;p&gt;&quot;Currently, field&lt;span class=&quot;error&quot;&gt;&amp;#91;x TO y&amp;#93;&lt;/span&gt; will produce the same hasCode as field&lt;span class=&quot;error&quot;&gt;&amp;#91;y TO x&amp;#93;&lt;/span&gt;... not particularly important for RangeQuery, but  you get the idea. &quot;&lt;/p&gt;

&lt;p&gt;Actually it is kind of important, because while &lt;span class=&quot;error&quot;&gt;&amp;#91;a TO z&amp;#93;&lt;/span&gt; will give hits &lt;span class=&quot;error&quot;&gt;&amp;#91;z TO a&amp;#93;&lt;/span&gt; won&apos;t.&lt;/p&gt;</comment>
                            <comment id="12356384" author="paul.elschot@xs4all.nl" created="Mon, 31 Oct 2005 16:51:42 +0000"  >&lt;p&gt;&amp;gt; &#160;- hash codes should strive to be unique across the Query hierarchy, not just unique within one specific&lt;br/&gt;
&amp;gt; subclass. For example, TermQuery(t) and SpanTermQuery(t) will generate the exact same hash codes. &lt;/p&gt;

&lt;p&gt;This has the disadvantage that the structure information added by the query parser is lost in the hash.&lt;br/&gt;
In case a hash is needed over the query text before parsing, one can use precisely that.&lt;br/&gt;
What&apos;s the point of hash code uniqueness over subclasses?&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                            <comment id="12356414" author="yseeley@gmail.com" created="Mon, 31 Oct 2005 23:01:04 +0000"  >&lt;p&gt;Paul, I&apos;m not sure I understand your point about &quot;structure information added by the query parser is lost in the hash&quot;.&lt;br/&gt;
Let me rephrase my statement in case you misunderstood me:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;hash codes should strive to avoid collisions across Query hierarchy, not just within one specific&lt;br/&gt;
     subclass. An example of hashCode implementations that don&apos;t do this are TermQuery(t) and SpanTermQuery(t) which will generate the exact same hash codes. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; What&apos;s the point of hash code uniqueness over subclasses? &lt;/p&gt;

&lt;p&gt;The same point as hash code uniqueness (avoiding collisions) within a particular class - the more collisions you have, the more it will slow down hash based lookups.  Things should still work if all hashCodes mapped to the same number, but it would be dog slow.&lt;/p&gt;</comment>
                            <comment id="12356432" author="paul.elschot@xs4all.nl" created="Tue, 1 Nov 2005 04:22:19 +0000"  >&lt;p&gt;&amp;gt;  For example, TermQuery(t) and SpanTermQuery(t) will generate the exact same hash codes. &lt;/p&gt;

&lt;p&gt;I&apos;m sorry, I misread this as an example of what a hash code should be. You meant this&lt;br/&gt;
to be an example of what is wrong with current hashcodes...&lt;/p&gt;
</comment>
                            <comment id="12361200" author="yseeley@gmail.com" created="Sat, 24 Dec 2005 01:29:21 +0000"  >&lt;p&gt;Some people have asked where some of the magic constants come from in the hashCodes:&lt;/p&gt;

&lt;p&gt;&amp;gt; python -c &quot;import random;print hex(random.getrandbits(32))&lt;span class=&quot;error&quot;&gt;&amp;#91;:-1&amp;#93;&lt;/span&gt;&quot;&lt;br/&gt;
&amp;gt; Just a way of making some things unique.... let me know if you have a&lt;br/&gt;
&amp;gt; better idea on that.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; So those constants are just random numbers.  I thought about trying to pick magic numbers to maximize hamming distances, etc,&lt;br/&gt;
&amp;gt; but it&apos;s more work and more likely to mess things up if you get it wrong.  getClass().hashCode() would also work, but it would be &lt;br/&gt;
&amp;gt; slower.&lt;/p&gt;</comment>
                            <comment id="12373451" author="yseeley@gmail.com" created="Thu, 6 Apr 2006 11:10:47 +0100"  >&lt;p&gt;closing... I think I got most of these.&lt;/p&gt;</comment>
                            <comment id="13712434" author="dsmiley" created="Thu, 18 Jul 2013 17:00:18 +0100"  >&lt;p&gt;I am not an expert on hashCode generation, yet as any java developer I have to generate hash codes.  I typically leave this to my IDE, IntelliJ.  As I find the need to update a hashCode, &lt;b&gt;do you think it&apos;s bad form for me to outright replace an existing hashCode implementation you wrote that looks complicated to me with what IntelliJ generates?&lt;/b&gt;:  Here&apos;s a specific example:&lt;/p&gt;

&lt;p&gt;SpanNotQuery formerly:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; h = include.hashCode();
    h = (h&amp;lt;&amp;lt;1) | (h &amp;gt;&amp;gt;&amp;gt; 31);  &lt;span class=&quot;code-comment&quot;&gt;// rotate left
&lt;/span&gt;    h ^= exclude.hashCode();
    h = (h&amp;lt;&amp;lt;1) | (h &amp;gt;&amp;gt;&amp;gt; 31);  &lt;span class=&quot;code-comment&quot;&gt;// rotate left
&lt;/span&gt;    h ^= &lt;span class=&quot;code-object&quot;&gt;Float&lt;/span&gt;.floatToRawIntBits(getBoost());
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; h;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IntelliJ will generate a hashCode for this + a new pre &amp;amp; post pair of integer fields I&apos;m adding via &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-5091&quot; title=&quot;Modify SpanNotQuery to act as SpanNotNearQuery too&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-5091&quot;&gt;&lt;del&gt;LUCENE-5091&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.hashCode();
    result = 31 * result + include.hashCode();
    result = 31 * result + exclude.hashCode();
    result = 31 * result + pre;
    result = 31 * result + post;
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; result;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now that&apos;s a hashCode implementation I can understand, and I don&apos;t question it&apos;s validity because IntelliJ always generates them in a consistent fashion that I am used to seeing.  Your hashCode might be better, but I simply don&apos;t understand and thus can&apos;t maintain it.  Do you want me to consult you (or an applicable author of a confusing hashCode in general) every time?  Granted this doesn&apos;t happen often.&lt;/p&gt;</comment>
                            <comment id="13712635" author="dweiss" created="Thu, 18 Jul 2013 19:41:33 +0100"  >&lt;p&gt;There isn&apos;t really much to understand, it&apos;s pretty simple. &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
h = (h&amp;lt;&amp;lt;1) | (h &amp;gt;&amp;gt;&amp;gt; 31);  &lt;span class=&quot;code-comment&quot;&gt;// rotate left&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These are rotation bitshifts &amp;#8211; there is no operator for it in Java. There&apos;s actually an intrinsic for this (Integer.rotateLeft and rotateRight).&lt;/p&gt;

&lt;p&gt;Now which sequence of operations &amp;#8211; the one above or IntelliJ generated one &amp;#8211; is &quot;better&quot; is a difficult question to answer &amp;#8211; depends how many collisions you actually get for real life include/exclude pairs. I doubt there&apos;ll be many. Multiplications used to be much smaller than bitshifts and logical operations so the first version is probably historically motivated (as being faster).&lt;/p&gt;</comment>
                            <comment id="13712709" author="dsmiley" created="Thu, 18 Jul 2013 20:37:00 +0100"  >&lt;p&gt;With some time (and thanks to your help) I&apos;m learning &lt;b&gt;what&lt;/b&gt; it is doing but it takes more to know &lt;b&gt;why&lt;/b&gt;, making it hard to judge how to add in a couple more integers into the existing hashCode.  Well... as I&apos;ve been spending more time investigating, I&apos;m feeling a more comfortable.  I would certainly prefer to see Integer.rotateLeft(31).&lt;/p&gt;

&lt;p&gt;I argue for the more maintainable code &amp;#8211; and that&apos;s IntelliJ&apos;s version.  I also like that it uses super.hashCode(), which leaves the responsibility of including the hashcode of boost, which is where that responsibility should lie.  Of course the approaches are complementary.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;More generally&lt;/em&gt;, I&apos;m looking to see if it would be bad form of me to outright replace a hashCode (or equals) method if it suited me, without feeling obliged to consult who coded it in the first place.&lt;/p&gt;</comment>
                            <comment id="13712829" author="dweiss" created="Thu, 18 Jul 2013 21:54:07 +0100"  >&lt;p&gt;I didn&apos;t argue for the first version or the second one &amp;#8211; I was just saying both are pretty straightforward. They&apos;re apples and oranges, hard to tell which one is better. IntelliJ&apos;s version is based on a common pattern found throughout the JDK &amp;#8211; I am pretty sure it has a common underlying academic source somewhere &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In general implementing equals and hashCode properly (so that the contract of these methods is not violated and the hash code distribution is sensibly random) is not trivial at all so anything that helps you get to the point is probably sensible.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.rotateLeft(31)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That example is actually a rotateLeft(1) &amp;#8211; you shift one bit to the left (h&amp;lt;&amp;lt;1), then you OR (&quot;insert&quot;) the leftmost bit shifted to the first bit&apos;s position (h&amp;gt;&amp;gt;&amp;gt;31).&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 31 Oct 2005 00:14:08 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>13289</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxyxkf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27589</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>