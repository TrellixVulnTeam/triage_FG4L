<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:05:31 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2271/LUCENE-2271.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[LUCENE-2271] Function queries producing scores of -inf or NaN (e.g. 1/x) return incorrect results with TopScoreDocCollector</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2271</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                    <description>&lt;p&gt;This is a foolowup to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2270&quot; title=&quot;queries with zero boosts don&amp;#39;t work&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-2270&quot;&gt;&lt;del&gt;LUCENE-2270&lt;/del&gt;&lt;/a&gt;, where a part of this problem was fixed (boost = 0 leading to NaN scores, which is also un-intuitive), but in general, function queries in Solr can create these invalid scores easily. In previous version of Lucene these scores ordered correct (except NaN, which mixes up results), but never invalid document ids are returned (like Integer.MAX_VALUE).&lt;/p&gt;

&lt;p&gt;The problem is: TopScoreDocCollector pre-fills the HitQueue with sentinel ScoreDocs with a score of -inf and a doc id of Integer.MAX_VALUE. For the HQ to work, this sentinel must be smaller than all posible values, which is not the case:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;-inf is equal and the document is not inserted into the HQ, as not competitive, but the HQ is not yet full, so the sentinel values keep in the HQ and result is the Integer.MAX_VALUE docs. This problem is solveable (and only affects the Ordered collector) by chaning the exit condition to:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (score &amp;lt;= pqTop.score &amp;amp;&amp;amp; pqTop.doc != &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE) {
    &lt;span class=&quot;code-comment&quot;&gt;// Since docs are returned in-order (i.e., increasing doc Id), a document
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// with equal score to pqTop.score cannot compete since HitQueue favors
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// documents with lower doc Ids. Therefore reject those docs too.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The NaN case can be fixed in the same way, but then has another problem: all comparisons with NaN result in false (none of these is true): x &amp;lt; NaN, x &amp;gt; NaN, NaN == NaN. This leads to the fact that HQ&apos;s lessThan always returns false, leading to unexspected ordering in the PQ and sometimes the sentinel values do not stay at the top of the queue. A later hit then overrides the top of the queue but leaves the incorrect sentinels  unchanged -&amp;gt; invalid results. This can be fixed in two ways in HQ:&lt;br/&gt;
Force all sentinels to the top:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; lessThan(ScoreDoc hitA, ScoreDoc hitB) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (hitA.doc == &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE)
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (hitB.doc == &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE)
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (hitA.score == hitB.score)
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; hitA.doc &amp;gt; hitB.doc; 
    &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; hitA.score &amp;lt; hitB.score;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;or alternatively have a defined order for NaN (Float.compare sorts them after +inf):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; lessThan(ScoreDoc hitA, ScoreDoc hitB) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (hitA.score == hitB.score)
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; hitA.doc &amp;gt; hitB.doc; 
    &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Float&lt;/span&gt;.compare(hitA.score, hitB.score) &amp;lt; 0;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The problem with both solutions is, that we have now more comparisons per hit and the use of sentinels is questionable. I would like to remove the sentinels and use the old pre 2.9 code for comparing and using PQ.add() when a competitive hit arrives. The order of NaN would be unspecified.&lt;/p&gt;

&lt;p&gt;To fix the order of NaN, it would be better to replace all score comparisons by Float.compare() &lt;span class=&quot;error&quot;&gt;&amp;#91;also in FieldComparator&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;I would like to delay 2.9.2 and 3.0.1 until this problem is discussed and solved.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12456755">LUCENE-2271</key>
            <summary>Function queries producing scores of -inf or NaN (e.g. 1/x) return incorrect results with TopScoreDocCollector</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="thetaphi">Uwe Schindler</reporter>
                        <labels>
                    </labels>
                <created>Fri, 19 Feb 2010 08:05:22 +0000</created>
                <updated>Wed, 16 Apr 2014 13:54:38 +0100</updated>
                                            <version>2.9</version>
                                    <fixVersion>4.9</fixVersion>
                    <fixVersion>Trunk</fixVersion>
                                    <component>core/search</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12835678" author="rcmuir" created="Fri, 19 Feb 2010 10:15:54 +0000"  >&lt;p&gt;its not a bug, as its doc&apos;ed to work this way.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NOTE&amp;lt;/b&amp;gt;: The values &lt;span class=&quot;code-object&quot;&gt;Float&lt;/span&gt;.Nan,
 * &lt;span class=&quot;code-object&quot;&gt;Float&lt;/span&gt;.NEGATIVE_INFINITY and &lt;span class=&quot;code-object&quot;&gt;Float&lt;/span&gt;.POSITIVE_INFINITY are
 * not valid scores.  This collector will not properly
 * collect hits with such scores.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12835683" author="rcmuir" created="Fri, 19 Feb 2010 10:23:45 +0000"  >&lt;p&gt;I don&apos;t think we should do anything to fix NaN, such as using more expensive comparisons (Float.compareTo) and stuff. as it is not a number, its an invalid score. &lt;/p&gt;

&lt;p&gt;i think function queries shoudl throw and exception instead of producing NaN, this problem is only limited to function queries.&lt;/p&gt;

&lt;p&gt;I think fixing scores of negative infinity make more sense, as these are unpreventable (again only a problem with function queries!) and at least negative infinity is actually a number.&lt;/p&gt;

&lt;p&gt;i think &quot;fixing&quot; a top-N collector, or &quot;fixing&quot; anything that sorts NaN is wrong. NaN doesnt have a properly defined sort order. NaN has an order hacked into Float.compareTo, but this is different. sorting the primitive type makes no sense, and the documentation should stay that it doesnt work with TSDC.&lt;/p&gt;</comment>
                            <comment id="12835699" author="thetaphi" created="Fri, 19 Feb 2010 11:11:35 +0000"  >&lt;p&gt;This is patch that supports NaN and -inf.&lt;/p&gt;

&lt;p&gt;The cost of the additional checks in HitQueue.lessThan are neglectible, as they only occur when a competitive hit is really inserted into the queue. The check enforces all sentinels to the top of the queue, regardless what their score is (because always NaN != NaN).&lt;/p&gt;</comment>
                            <comment id="12835700" author="rcmuir" created="Fri, 19 Feb 2010 11:14:23 +0000"  >&lt;p&gt;attached is a patch, written by Uwe. as far as a &quot;bugfix&quot; i prefer this patch, as the more complicated, performance-intrusive NaN fixes I think should be something we do in 3.1&lt;/p&gt;

&lt;p&gt;e.g., &quot;fixing&quot; NaN to work will likely slow down people getting large numbers of results, and i don&apos;t think we should do that in bugfix releases. &lt;/p&gt;

&lt;p&gt;but in 3.1, we could change it, include some large results-oriented collectors for these people, and the whole thing would make sense.&lt;/p&gt;</comment>
                            <comment id="12835701" author="thetaphi" created="Fri, 19 Feb 2010 11:14:25 +0000"  >&lt;p&gt;Sorry reverted a comment remove.&lt;/p&gt;</comment>
                            <comment id="12835717" author="rcmuir" created="Fri, 19 Feb 2010 12:02:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;The cost of the additional checks in HitQueue.lessThan are neglectible, as they only occur when a competitive hit is really inserted into the queue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This should be benchmarked for MultiSearcher and ParallelMultiSearcher, too, as they also use HitQueue.&lt;/p&gt;</comment>
                            <comment id="12835743" author="thetaphi" created="Fri, 19 Feb 2010 13:35:12 +0000"  >&lt;p&gt;Patch with testcases for trunk, but should work on branches, too (after removing @Override). Without the fixes in HitQueue or TSDC the tests fail.&lt;/p&gt;</comment>
                            <comment id="12835750" author="yseeley@gmail.com" created="Fri, 19 Feb 2010 13:56:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;its not a bug, as its doc&apos;ed to work this way. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, so it was a design bug too.&lt;/p&gt;</comment>
                            <comment id="12835758" author="rcmuir" created="Fri, 19 Feb 2010 14:21:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;OK, so it was a design bug too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A design bug that function queries score docs with an invalid score (NaN) instead of throwing an exception?&lt;/p&gt;</comment>
                            <comment id="12835762" author="yseeley@gmail.com" created="Fri, 19 Feb 2010 14:40:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;A design bug that function queries score docs with an invalid score (NaN) instead of throwing an exception?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, a design bug that -Inf scores were disallowed, esp since they were handled just fine in the past.&lt;/p&gt;

&lt;p&gt;NaN is different - it&apos;s more of a judgement call depending on the cost to handle it.&lt;/p&gt;</comment>
                            <comment id="12835763" author="thetaphi" created="Fri, 19 Feb 2010 14:49:00 +0000"  >&lt;p&gt;The cost to handle NaN is the modified lessThan() in HitQueue.&lt;/p&gt;</comment>
                            <comment id="12835780" author="thetaphi" created="Fri, 19 Feb 2010 15:37:03 +0000"  >&lt;p&gt;Improved test, that also checks for increasing doc ids when score identical&lt;/p&gt;</comment>
                            <comment id="12836178" author="yseeley@gmail.com" created="Sat, 20 Feb 2010 14:38:14 +0000"  >&lt;p&gt;I&apos;m starting to think that handling NaN is as important as handling the infinities.&lt;br/&gt;
This is because once you allow infinities, it&apos;s easy to get a NaN with a simple multiplication by 0.&lt;/p&gt;</comment>
                            <comment id="12836179" author="rcmuir" created="Sat, 20 Feb 2010 14:47:51 +0000"  >&lt;blockquote&gt;&lt;p&gt;This is because once you allow infinities, it&apos;s easy to get a NaN with a simple multiplication by 0. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;maybe we should keep it as is then, and only allow finite results&lt;/p&gt;</comment>
                            <comment id="12836180" author="yseeley@gmail.com" created="Sat, 20 Feb 2010 14:51:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;maybe we should keep it as is then, and only allow finite results&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But how?  Finite results can combine and overflow into infinite results with things like boolean query, so we can&apos;t give a definite range of values that a query can safely produce.&lt;/p&gt;</comment>
                            <comment id="12836181" author="rcmuir" created="Sat, 20 Feb 2010 14:57:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;But how? Finite results can combine and overflow into infinite results with things like boolean query, so we can&apos;t give a definite range of values that a query can safely produce.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;right, but this really only happens with function queries. this is my problem, with normal queries how can this happen?&lt;br/&gt;
its a very very very very special case, and it seems overkill to add all these checks to performance-sensitive top-docs collection just for function queries, to handle NaN and infinites&lt;/p&gt;</comment>
                            <comment id="12836182" author="thetaphi" created="Sat, 20 Feb 2010 14:57:56 +0000"  >&lt;p&gt;In my opinion we should fix it using the attached patch and in the future 3.1 do some refactoring:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;no sentinels&lt;/li&gt;
	&lt;li&gt;define a order for NaN, as NaN breaks the complete order of results (because PQ cannot handle the case that lessThan(a,b) returns false and also lessThan(b,a) when NaN is involved)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12836183" author="rcmuir" created="Sat, 20 Feb 2010 15:01:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;In my opinion we should fix it using the attached patch and in the future 3.1 do some refactoring: &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;in general agree, on one condition that it doesnt slow down normal queries, MultiSearcher, or ParallelMultiSearcher significantly (benchmarks)&lt;/p&gt;

&lt;p&gt;in my opinion the thing is documented not to work for these values, so its not a bug at all. if we want to support these values we should redesign the collector (in 3.1)&lt;/p&gt;</comment>
                            <comment id="12836191" author="thetaphi" created="Sat, 20 Feb 2010 15:55:21 +0000"  >&lt;p&gt;Here a simplier patch with sentinels removed. You can maybe think about a better if-check in the out of order collector&lt;/p&gt;</comment>
                            <comment id="12836194" author="thetaphi" created="Sat, 20 Feb 2010 16:11:57 +0000"  >&lt;p&gt;Sorry, insertWithOverflow is correct!&lt;/p&gt;</comment>
                            <comment id="12836197" author="creamyg" created="Sat, 20 Feb 2010 16:24:21 +0000"  >&lt;p&gt;An awful lot of thought went into optimizing those collection algorithms.  I&lt;br/&gt;
disagree with many of the design decisions that were made, but it seems rushed&lt;br/&gt;
to blithely revert those optimizations.&lt;/p&gt;

&lt;p&gt;FWIW, the SortCollector in KS (designed on the Lucy list last spring, would be&lt;br/&gt;
in Lucy but some prereqs haven&apos;t gone in yet) doesn&apos;t have the problem with&lt;br/&gt;
-Inf sentinels.  It uses an array of &quot;actions&quot; representing sort rules to&lt;br/&gt;
determine whether a hit is &quot;competitive&quot; and should be inserted into the&lt;br/&gt;
queue; the first action is set to AUTO_ACCEPT (meaning try inserting the hit&lt;br/&gt;
into the queue) until the queue fills up, and then again to AUTO_ACCEPT at the&lt;br/&gt;
start of each segment.  It&apos;s not necessary to fill up the queue with dummy&lt;br/&gt;
hits beforehand.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;
static INLINE bool_t
SI_competitive(SortCollector *self, i32_t doc_id)
{
    u8_t *const actions = self-&amp;gt;actions;
    u32_t i = 0;

    /* Iterate through our array of actions, returning as quickly as
     * possible. */
    do {
        switch (actions[i] &amp;amp; ACTIONS_MASK) {
            case AUTO_ACCEPT:
                return true;
            case AUTO_REJECT:
                return false;
            case AUTO_TIE:
                break;
            case COMPARE_BY_SCORE: {
                    float score = Matcher_Score(self-&amp;gt;matcher);
                    if  (score &amp;gt; self-&amp;gt;bubble_score) {
                        self-&amp;gt;bumped-&amp;gt;score = score;
                        return true;
                    }
                    else if (score &amp;lt; self-&amp;gt;bubble_score) {
                        return false;
                    }
                }
                break;
            case COMPARE_BY_SCORE_REV: {
                // ...
            case COMPARE_BY_DOC_ID:
                // ...
            case COMPARE_BY_ORD1: {
                // ...
        }
    } while (++i &amp;lt; self-&amp;gt;num_actions);

    /* If we&apos;ve made it this far and we&apos;re still tied, reject the doc so that
     * we prefer items already in the queue.  This has the effect of
     * implicitly breaking ties by doc num, since docs are collected in order.
     */
    return false;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12836203" author="thetaphi" created="Sat, 20 Feb 2010 16:50:50 +0000"  >&lt;p&gt;Attached is the patch with the testcase from the previous one (with sentinels). All tests pass.&lt;/p&gt;</comment>
                            <comment id="12836214" author="mikemccand" created="Sat, 20 Feb 2010 18:03:44 +0000"  >&lt;p&gt;I would rather not change the core default collector here, when&lt;br/&gt;
sorting by score.&lt;/p&gt;

&lt;p&gt;All of the patches being considered would add an extra comparison/and&lt;br/&gt;
(or maybe if) per collect call, which while presumably small, is still&lt;br/&gt;
an added cost.&lt;/p&gt;

&lt;p&gt;Likely this added cost is in the noise of a benchmark so we wouldn&apos;t&lt;br/&gt;
be able to conclude much by benching... but enough of these added&lt;br/&gt;
costs will eventually add up.  At the end of the day you are adding&lt;br/&gt;
non-zero work for the CPU to do, for every collect.&lt;/p&gt;

&lt;p&gt;This is Lucene&apos;s searching hotspot, so we should only be adding extra&lt;br/&gt;
code on this critical path when it&apos;s really needed.&lt;/p&gt;

&lt;p&gt;It&apos;s ashame to make everyone pay that price when in practice very few&lt;br/&gt;
users need to collect -Inf/NaN scoring docs.  This hasn&apos;t been hit in&lt;br/&gt;
a &quot;real&quot; use case yet.&lt;/p&gt;

&lt;p&gt;In fact, before 2.9 (ie up to and including 2.4), we by default&lt;br/&gt;
filtered out all docs scoring &amp;lt;= 0.0, so -Inf and NaN were always&lt;br/&gt;
filtered out, anyway.&lt;/p&gt;

&lt;p&gt;Users who somehow do hit this in a real use case have a good&lt;br/&gt;
workaround: use TopFieldCollector, sorting by Relevance.  This will&lt;br/&gt;
properly handle -Inf, and will at least collect NaN scoring docs (but&lt;br/&gt;
their sort order will be random, as it always has).  Or, use&lt;br/&gt;
PositiveScoresOnlyCollector (to get back to Lucene 2.4 behavior).  Or,&lt;br/&gt;
create a custom collector.&lt;/p&gt;</comment>
                            <comment id="12836217" author="thetaphi" created="Sat, 20 Feb 2010 18:12:48 +0000"  >&lt;p&gt;Here is a new impl that only has exactly one additional check in the initial collection (when th pq is not yet full). After the PQ is full, the collector is replaced by the short-cutting one.&lt;/p&gt;

&lt;p&gt;This impl should even be faster than before, if the additional method call does not count and is removed by the JVM (which it should, because its clearly predictable)&lt;/p&gt;</comment>
                            <comment id="12836220" author="thetaphi" created="Sat, 20 Feb 2010 18:16:21 +0000"  >&lt;p&gt;more improved&lt;/p&gt;</comment>
                            <comment id="12836228" author="thetaphi" created="Sat, 20 Feb 2010 18:38:18 +0000"  >&lt;p&gt;More optimized version with more local variables. This is the version for the benchmark-try.&lt;/p&gt;</comment>
                            <comment id="12836232" author="thetaphi" created="Sat, 20 Feb 2010 19:16:10 +0000"  >&lt;p&gt;Here a benchmark task made by grant. Run collector.alg and wait long enough.&lt;/p&gt;</comment>
                            <comment id="12836252" author="thetaphi" created="Sat, 20 Feb 2010 20:16:10 +0000"  >&lt;p&gt;More improved version, now equal to prefilled queue case, as the collector reuses overflowed ScoreDoc instances.&lt;/p&gt;</comment>
                            <comment id="12836265" author="thetaphi" created="Sat, 20 Feb 2010 21:39:33 +0000"  >&lt;p&gt;I did some benchmarks (Java 1.5.0_22, 64bit, Win7, Core2Duo P8700) will do more tomorrow when i set up a large testing environment with 3 separate checkouts containing the three collector versions):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The latest approach (&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12436458/LUCENE-2271.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/secure/attachment/12436458/LUCENE-2271.patch&lt;/a&gt;) with no sentinels using the delegation and exchanging the inner collector was as fast as the original unpatched version&lt;/li&gt;
	&lt;li&gt;The approach with sentinels but fixed HitQueue ordering and extra checks (&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12436329/LUCENE-2271.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/secure/attachment/12436329/LUCENE-2271.patch&lt;/a&gt;), showed (as exspected) a little overhead: The ordered collector was as fast as the unpatched unordered collector (because one check more) - so i would not use this patch&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12836273" author="thetaphi" created="Sat, 20 Feb 2010 22:22:28 +0000"  >&lt;p&gt;Fix an issue when numDocs==0.&lt;/p&gt;</comment>
                            <comment id="12836384" author="mikemccand" created="Sun, 21 Feb 2010 15:36:56 +0000"  >&lt;p&gt;This is a delightfully clever solution, delegating to a contained&lt;br/&gt;
collector and then swapping in one collector for the startup (when the&lt;br/&gt;
queue is not yet full) and then a new collector once the queue is&lt;br/&gt;
full.&lt;/p&gt;

&lt;p&gt;It&apos;s the closest equivalent we in javaland can reach, to using&lt;br/&gt;
function pointers in C.&lt;/p&gt;

&lt;p&gt;But, I don&apos;t think we should commit this &amp;#8211; this makes the code more&lt;br/&gt;
complex, and doesn&apos;t really gain enough (performance is the same) in&lt;br/&gt;
return.  It also relies more heavily on the JVM being able to optimize away&lt;br/&gt;
the method call.&lt;/p&gt;

&lt;p&gt;Yes it handles -inf/nan, but I don&apos;t think Lucene&apos;s default&lt;br/&gt;
sort-by-relevance collector needs to (prior to 2.9 we silently&lt;br/&gt;
filtered out such hits, as well as all hits with score &amp;lt;= 0.0).&lt;/p&gt;</comment>
                            <comment id="12836400" author="mikemccand" created="Sun, 21 Feb 2010 17:01:11 +0000"  >&lt;p&gt;I think we should fix a few doc issues, and add asserts (attached patch for trunk).&lt;/p&gt;</comment>
                            <comment id="12836451" author="thetaphi" created="Sun, 21 Feb 2010 21:41:44 +0000"  >&lt;p&gt;After applying Mike&apos;s patch (with modified asserts to correctly detect NaN), updated my patch of the delegating and -inf/NaN aware TopScoreDocCollector.&lt;/p&gt;

&lt;p&gt;Maybe we should add it as a separate collector for function queries in 3.1. Maybe with correct NaN ordering?&lt;/p&gt;</comment>
                            <comment id="13716980" author="steve_rowe" created="Tue, 23 Jul 2013 19:44:32 +0100"  >&lt;p&gt;Bulk move 4.4 issues to 4.5 and 5.0&lt;/p&gt;</comment>
                            <comment id="13970825" author="thetaphi" created="Wed, 16 Apr 2014 13:54:38 +0100"  >&lt;p&gt;Move issue to Lucene 4.9.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12456940">SOLR-1785</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12436452" name="LUCENE-2271-bench.patch" size="27424" author="thetaphi" created="Sat, 20 Feb 2010 19:16:10 +0000"/>
                            <attachment id="12436540" name="LUCENE-2271-maybe-as-separate-collector.patch" size="12301" author="thetaphi" created="Sun, 21 Feb 2010 21:41:44 +0000"/>
                            <attachment id="12436503" name="LUCENE-2271.patch" size="2996" author="mikemccand" created="Sun, 21 Feb 2010 17:01:11 +0000"/>
                            <attachment id="12436463" name="LUCENE-2271.patch" size="11369" author="thetaphi" created="Sat, 20 Feb 2010 22:22:28 +0000"/>
                            <attachment id="12436458" name="LUCENE-2271.patch" size="10053" author="thetaphi" created="Sat, 20 Feb 2010 20:18:30 +0000"/>
                            <attachment id="12436443" name="LUCENE-2271.patch" size="6551" author="thetaphi" created="Sat, 20 Feb 2010 16:50:50 +0000"/>
                            <attachment id="12436329" name="LUCENE-2271.patch" size="5855" author="thetaphi" created="Fri, 19 Feb 2010 15:37:03 +0000"/>
                            <attachment id="12436308" name="TSDC.patch" size="1306" author="rcmuir" created="Fri, 19 Feb 2010 11:14:23 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 19 Feb 2010 10:15:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11518</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Lucene Fields</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxymcn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>25772</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>