<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:08:47 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1726/LUCENE-1726.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[LUCENE-1726] IndexWriter.readerPool create new segmentReader outside of sync block</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1726</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                    <description>&lt;p&gt;I think we will want to do something like what field cache does&lt;br/&gt;
with CreationPlaceholder for IndexWriter.readerPool. Otherwise&lt;br/&gt;
we have the (I think somewhat problematic) issue of all other&lt;br/&gt;
readerPool.get* methods waiting for an SR to warm.&lt;/p&gt;

&lt;p&gt;It would be good to implement this for 2.9.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12429239">LUCENE-1726</key>
            <summary>IndexWriter.readerPool create new segmentReader outside of sync block</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.png">Trivial</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="mikemccand">Michael McCandless</assignee>
                                    <reporter username="jasonrutherglen">Jason Rutherglen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 30 Jun 2009 23:23:47 +0100</created>
                <updated>Fri, 10 May 2013 11:43:10 +0100</updated>
                            <resolved>Mon, 24 Jan 2011 21:35:28 +0000</resolved>
                                    <version>2.4.1</version>
                                    <fixVersion>4.0-ALPHA</fixVersion>
                                    <component>core/index</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                    <timeoriginalestimate seconds="172800">48h</timeoriginalestimate>
                            <timeestimate seconds="172800">48h</timeestimate>
                                        <comments>
                            <comment id="12726700" author="jasonrutherglen" created="Thu, 2 Jul 2009 22:54:06 +0100"  >&lt;p&gt;We don&apos;t block accessing readers in the IW.readerPool when a new&lt;br/&gt;
segmentReader is being warmed/instantiated. This is important&lt;br/&gt;
when new segmentReaders on large new segments are being accessed&lt;br/&gt;
for the first time. Otherwise today IW.getReader may wait while&lt;br/&gt;
the new SR is being created.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;IW.readerPool map values are now of type MapValue&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We synchronize on the MapValue in methods that access the SR&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;synchronize for the entire readerPool.get method is removed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;All tests pass&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12727567" author="mikemccand" created="Mon, 6 Jul 2009 16:04:01 +0100"  >&lt;p&gt;Can we make the MapValue strongly typed?  Eg name it SegmentReaderValue, and it has a single member &quot;SegmentReader reader&quot;.&lt;/p&gt;

&lt;p&gt;getIfExists has duplicate checks for null (mv != null is checked twice and mv.value != null too).&lt;/p&gt;

&lt;p&gt;I think there is a thread hazard here, in particular a risk that one thread decrefs a reader just as another thread is trying to get it, and the reader in fact gets closed while the other thread has an mv.reader != null and illegally increfs that.  I think you&apos;ll have to do the sr.incRef inside the synchronized(this), but I don&apos;t think that entirely resolves it.&lt;/p&gt;

&lt;p&gt;I&apos;m going to move this out out 2.9; I don&apos;t think it should block it.&lt;/p&gt;</comment>
                            <comment id="12727696" author="jasonrutherglen" created="Mon, 6 Jul 2009 19:54:28 +0100"  >&lt;ul&gt;
	&lt;li&gt;New SRMapValue is strongly typed&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;All tests pass&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;I think there is a thread hazard here, in particular a&lt;br/&gt;
risk that one thread decrefs a reader just as another thread is&lt;br/&gt;
trying to get it, and the reader in fact gets closed while the&lt;br/&gt;
other thread has an mv.reader != null and illegally increfs&lt;br/&gt;
that. I think you&apos;ll have to do the sr.incRef inside the&lt;br/&gt;
synchronized(this), but I don&apos;t think that entirely resolves&lt;br/&gt;
it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Are you referring to a decref on a reader outside of IW? The&lt;br/&gt;
asserts we have did help in catching synchronization errors.&lt;br/&gt;
It&apos;s unclear to me how to recreate the use case described such&lt;br/&gt;
that it breaks things. We need a test case that fails with the&lt;br/&gt;
current patch?&lt;/p&gt;</comment>
                            <comment id="12727813" author="mikemccand" created="Mon, 6 Jul 2009 23:18:52 +0100"  >&lt;p&gt;The hazard is something like this, for a non-NRT IndexWriter (ie, no&lt;br/&gt;
pooling):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Thread #1 is a merge; it checks out a reader &amp;amp; starts running&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Thread #2 is applyDeletes (or opening an NRT reader); it calls&lt;br/&gt;
    readerPool.get, enters the first sync block to pull out the&lt;br/&gt;
    SRMapValue which has non-null reader, then leaves the sync block&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Thread #1 calls release, which decRefs the reader &amp;amp; closes it&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Thread #2 resumes, sees it has a non-null mv.reader and incRefs&lt;br/&gt;
    it, which is illegal (reader was already closed).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12727823" author="jasonrutherglen" created="Mon, 6 Jul 2009 23:43:19 +0100"  >&lt;p&gt;Shouldn&apos;t we be seeing an exception in TestStressIndexing2 (or&lt;br/&gt;
another test class) when the mv.reader.incRef occurs and the&lt;br/&gt;
reader is already closed?&lt;/p&gt;</comment>
                            <comment id="12727843" author="mikemccand" created="Tue, 7 Jul 2009 01:08:15 +0100"  >&lt;p&gt;Yes, we should eventually see a failure; I think it&apos;s just rare.  Maybe try making a new test that constantly indexes docs, w/ low merge factor &amp;amp; maxBufferedDocs (so lots of flushing/merging happens) in one thread and constantly opens an NRT reader in another thread, to tease it out?&lt;/p&gt;</comment>
                            <comment id="12727882" author="jasonrutherglen" created="Tue, 7 Jul 2009 03:28:38 +0100"  >&lt;p&gt;When I moved the sync block around in readerPool.get, tests&lt;br/&gt;
would fail and/or hang. I&apos;m not sure yet where we&apos;d add the&lt;br/&gt;
sync(this) block. &lt;/p&gt;

&lt;p&gt;I&apos;ll work on reproducing the above mentioned issue, thanks for&lt;br/&gt;
the advice.&lt;/p&gt;</comment>
                            <comment id="12728435" author="jasonrutherglen" created="Wed, 8 Jul 2009 01:04:46 +0100"  >&lt;p&gt;Added a test case (for now a separate test class) that runs for&lt;br/&gt;
5 minutes, mergeFactor 2, maxBufferedDocs 10, 4 threads&lt;br/&gt;
alternately adding and deleting docs. I haven&apos;t seen the error&lt;br/&gt;
we&apos;re looking for yet. CPU isn&apos;t maxing out (probably should,&lt;br/&gt;
indicating possible blocking?) and may need to allow it run&lt;br/&gt;
longer?&lt;/p&gt;</comment>
                            <comment id="12728441" author="jasonrutherglen" created="Wed, 8 Jul 2009 01:30:44 +0100"  >&lt;p&gt;Each thread in the test only performs adds or deletes (rather than both) and now we get a &quot;MockRAMDirectory: cannot close: there are still open files&quot; exception.  &lt;/p&gt;</comment>
                            <comment id="12728787" author="jasonrutherglen" created="Wed, 8 Jul 2009 17:46:34 +0100"  >&lt;p&gt;I tried the test on trunk and get the same error. They&apos;re all&lt;br/&gt;
docstore related files so maybe extra doc stores are being&lt;br/&gt;
opened?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; 
   [junit] MockRAMDirectory: cannot close: there are still open
files: {_s4.fdt=2, _g2.fdx=2, _s4.fdx=2, _g2.tvf=2, _dw.fdx=2,
_g2.tvd=2, _g2.tvx=2, _ks.tvf=2, _n9.tvx=2, _ks.tvx=2,
_n9.fdx=2, _ks.fdx=2, _dw.cfx=1, _n9.tvf=2, _cp.cfx=1,
_s4.tvf=2, _dw.tvx=2, _87.fdx=2, _fr.tvx=2, _87.tvf=2,
_fr.tvd=2, _87.fdt=2, _ks.tvd=2, _s4.tvd=2, _dw.tvd=2,
_n9.fdt=2, _g2.fdt=2, _87.tvd=2, _fr.fdt=2, _dw.fdt=2,
_dj.cfx=1, _s4.tvx=2, _ks.fdt=2, _n9.tvd=2, _fr.tvf=2,
_fr.fdx=2, _dw.tvf=2, _87.tvx=2} [junit]
java.lang.RuntimeException: MockRAMDirectory: cannot close:
there are still open files: {_s4.fdt=2, _g2.fdx=2, _s4.fdx=2,
_g2.tvf=2, _dw.fdx=2, _g2.tvd=2, _g2.tvx=2, _ks.tvf=2,
_n9.tvx=2, _ks.tvx=2, _n9.fdx=2, _ks.fdx=2, _dw.cfx=1,
_n9.tvf=2, _cp.cfx=1, _s4.tvf=2, _dw.tvx=2, _87.fdx=2,
_fr.tvx=2, _87.tvf=2, _fr.tvd=2, _87.fdt=2, _ks.tvd=2,
_s4.tvd=2, _dw.tvd=2, _n9.fdt=2, _g2.fdt=2, _87.tvd=2,
_fr.fdt=2, _dw.fdt=2, _dj.cfx=1, _s4.tvx=2, _ks.fdt=2,
_n9.tvd=2, _fr.tvf=2, _fr.fdx=2, _dw.tvf=2, _87.tvx=2} [junit]
	at
org.apache.lucene.store.MockRAMDirectory.close(MockRAMDirectory.j
ava:278) [junit] 	at
org.apache.lucene.index.Test1726.testIndexing(Test1726.java:48)
[junit] 	at
org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java
:88)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12728824" author="mikemccand" created="Wed, 8 Jul 2009 18:58:40 +0100"  >&lt;p&gt;Hmm... I&apos;ll dig into this test case.&lt;/p&gt;</comment>
                            <comment id="12728833" author="jasonrutherglen" created="Wed, 8 Jul 2009 19:12:18 +0100"  >&lt;p&gt;Mike,&lt;/p&gt;

&lt;p&gt;I was wondering if you can recommend techniques or tools for&lt;br/&gt;
debugging this type of multithreading issue? (i.e. how do you go&lt;br/&gt;
about figuring this type of issue out?) &lt;/p&gt;</comment>
                            <comment id="12728853" author="mikemccand" created="Wed, 8 Jul 2009 20:07:14 +0100"  >&lt;p&gt;I don&apos;t have any particular tools...&lt;/p&gt;

&lt;p&gt;First I simplify the test as much as possible while still hitting the&lt;br/&gt;
failure (eg this failure happens w/ only 2 threads), then see if the&lt;br/&gt;
error will happen if I turn on IndexWriter&apos;s infoStream (it doesn&apos;t&lt;br/&gt;
for this, so far).  If so, I scrutinize the series of events to find&lt;br/&gt;
the hazard; else, I turn off infoStream and add back in a small number&lt;br/&gt;
of prints, as long as failure still happens.&lt;/p&gt;

&lt;p&gt;Often I use a simple Python script that runs the test over &amp;amp; over&lt;br/&gt;
until a failure happens, saving the log, and then scrutinize that.&lt;/p&gt;

&lt;p&gt;It&apos;s good to start with a rough guess, eg this failure is w/ only doc&lt;br/&gt;
stores so it seems likely the merging logic that opens doc stores just&lt;br/&gt;
before kicking off the merge may be to blame.&lt;/p&gt;</comment>
                            <comment id="12728889" author="mikemccand" created="Wed, 8 Jul 2009 21:37:03 +0100"  >&lt;p&gt;OK the problem happens when a segment is first opened by a merge that&lt;br/&gt;
doesn&apos;t need to merge the doc stores; later, an NRT reader is opened&lt;br/&gt;
that separately opens the doc stores of the same &lt;span class=&quot;error&quot;&gt;&amp;#91;pooled&amp;#93;&lt;/span&gt;&lt;br/&gt;
SegmentReader, but then it&apos;s the merge that closes the read-only clone&lt;br/&gt;
of the reader.&lt;/p&gt;

&lt;p&gt;In this case the separately opened (by the NRT reader) doc stores are&lt;br/&gt;
not closed by the merge thread.  It&apos;s the mirror image of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1639&quot; title=&quot;intermittent failure in TestIndexWriter. testRandomIWReader&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1639&quot;&gt;&lt;del&gt;LUCENE-1639&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&apos;ve fixed it by pulling all shared readers in a SegmentReader into a&lt;br/&gt;
separate static class (CoreReaders).  Cloned SegmentReaders share the&lt;br/&gt;
same instance of this class so that if a clone later opens the doc&lt;br/&gt;
stores, any prior ancestor (that the clone was created from) would&lt;br/&gt;
also close those readers if it&apos;s the reader to decRef to 0.&lt;/p&gt;

&lt;p&gt;I did something similar for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1609&quot; title=&quot;Eliminate synchronization contention on initial index reading in TermInfosReader ensureIndexIsRead &quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1609&quot;&gt;&lt;del&gt;LUCENE-1609&lt;/del&gt;&lt;/a&gt; (which I&apos;ll now hit conflicts&lt;br/&gt;
on after committing this... sigh).&lt;/p&gt;

&lt;p&gt;I plan to commit in a day or so.&lt;/p&gt;</comment>
                            <comment id="12728909" author="jasonrutherglen" created="Wed, 8 Jul 2009 22:23:54 +0100"  >&lt;p&gt;The test now passes, needs to go in the patch, perhaps in&lt;br/&gt;
TestIndexWriterReader? Great work on this, it&apos;s easier to&lt;br/&gt;
understand SegmentReader now that all the shared objects are in&lt;br/&gt;
one object (CoreReaders). It should make debugging go more&lt;br/&gt;
smoothly. &lt;/p&gt;

&lt;p&gt;Is there a reason we&apos;re not synchronizing on SR.core in&lt;br/&gt;
openDocStores? Couldn&apos;t we synchronize on core for the cloning&lt;br/&gt;
methods? &lt;/p&gt;</comment>
                            <comment id="12728938" author="mikemccand" created="Wed, 8 Jul 2009 23:25:05 +0100"  >&lt;blockquote&gt;&lt;p&gt;Is there a reason we&apos;re not synchronizing on SR.core in openDocStores?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was going to say &quot;because IW sychronizes&quot; but in fact it doesn&apos;t,&lt;br/&gt;
properly, because when merging we go and open doc stores in&lt;br/&gt;
unsynchronized context.  So I&apos;ll synchronize(core) in&lt;br/&gt;
SR.openDocStores.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Couldn&apos;t we synchronize on core for the cloning methods?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think that&apos;s needed?  The core is simply carried over to the&lt;br/&gt;
newly cloned reader.&lt;/p&gt;
</comment>
                            <comment id="12729024" author="jasonrutherglen" created="Thu, 9 Jul 2009 04:04:48 +0100"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t think that&apos;s needed? The core is simply carried&lt;br/&gt;
over to the newly cloned reader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right however wouldn&apos;t it be somewhat cleaner to sync on core&lt;br/&gt;
for all clone operations given we don&apos;t want those to occur&lt;br/&gt;
(external to IW) at the same time? Ultimately we want core to be&lt;br/&gt;
the controller of it&apos;s resources rather than the SR being cloned?&lt;/p&gt;

&lt;p&gt;I ran the test with the SRMapValue sync code, (4 threads) with&lt;br/&gt;
the sync on SR.core in openDocStore for 10 minutes, 2 core&lt;br/&gt;
Windows XML laptop Java 6.14 and no errors. Then same with 2&lt;br/&gt;
threads for 5 minutes and no errors. I&apos;ll keep on running it to&lt;br/&gt;
see if we can get an error.&lt;/p&gt;

&lt;p&gt;I&apos;m still a little confused as to why we&apos;re going to see the bug&lt;br/&gt;
if readerPool.get is syncing on the SRMapValue. I guess there&apos;s&lt;br/&gt;
a slight possibility of the error, and perhaps a more randomized&lt;br/&gt;
test would produce it.&lt;/p&gt;</comment>
                            <comment id="12729199" author="mikemccand" created="Thu, 9 Jul 2009 12:23:15 +0100"  >&lt;p&gt;Attached new patch (the patch is worse than it looks, because many&lt;br/&gt;
things moved into the CoreReaders class):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Moved more stuff into CoreReaders (fieldInfos, dir, segment, etc.)&lt;br/&gt;
    and moved methods down as well (ctor, openDocStores, decRef).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Made members final when possible, else synchronized access to&lt;br/&gt;
    getting them (to avoid running amok of JMM).&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;
&lt;p&gt;Right however wouldn&apos;t it be somewhat cleaner to sync on core&lt;br/&gt;
for all clone operations given we don&apos;t want those to occur&lt;br/&gt;
(external to IW) at the same time? Ultimately we want core to be&lt;br/&gt;
the controller of it&apos;s resources rather than the SR being cloned?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In fact, I&apos;m not sure why cloning/reopening a segment needs to be&lt;br/&gt;
synchronized at all.&lt;/p&gt;

&lt;p&gt;Sure it&apos;d be weird for an app to send multiple threads down,&lt;br/&gt;
attempting to reopen/clone the same SR or core at once, but from&lt;br/&gt;
Lucene&apos;s standpoint there&apos;s nothing &quot;wrong&quot; with doing so, I think?&lt;/p&gt;

&lt;p&gt;(Though, DirectoryReader does need its sync when its transferring the&lt;br/&gt;
write lock due to reopen on a reader w/ pending changes).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I ran the test with the SRMapValue sync code, (4 threads) with&lt;br/&gt;
the sync on SR.core in openDocStore for 10 minutes, 2 core&lt;br/&gt;
Windows XML laptop Java 6.14 and no errors. Then same with 2&lt;br/&gt;
threads for 5 minutes and no errors. I&apos;ll keep on running it to&lt;br/&gt;
see if we can get an error.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You could try inserting a testPoint (see the other testPoints in&lt;br/&gt;
IndexWriter) after the SRMapValue is pulled from the hash but before&lt;br/&gt;
we check if its reader is null, and then modify the threads in your&lt;br/&gt;
test to randomly yield on that testPoint (by subclassing IW)?  Ie&lt;br/&gt;
&quot;exacerbate&quot; the path that exposes the hazard.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;m still a little confused as to why we&apos;re going to see the bug&lt;br/&gt;
if readerPool.get is syncing on the SRMapValue. I guess there&apos;s&lt;br/&gt;
a slight possibility of the error, and perhaps a more randomized&lt;br/&gt;
test would produce it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The hazard exists because there&apos;s a time when no synchronization is&lt;br/&gt;
held.  Ie, you retrieve SRMapValue from the hash while sync&apos;d on&lt;br/&gt;
ReaderPool.  You then leave that sync entirely (this is where hazard&lt;br/&gt;
comes in), and next you sync on the SRMapValue.  Another thread can&lt;br/&gt;
sneak in and close the SRMapValue.reader during the time that no sync&lt;br/&gt;
is held.&lt;/p&gt;</comment>
                            <comment id="12730009" author="jasonrutherglen" created="Sat, 11 Jul 2009 18:27:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;try inserting a testPoint (see the other testPoints in&lt;br/&gt;
IndexWriter) after the SRMapValue is pulled from the hash but before&lt;br/&gt;
we check if its reader is null&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I added the test point, but tested without the yield, the method&lt;br/&gt;
itself was enough of a delay to expose the exception.  &lt;/p&gt;</comment>
                            <comment id="12730010" author="jasonrutherglen" created="Sat, 11 Jul 2009 19:19:19 +0100"  >&lt;p&gt;I haven&apos;t really figured out a clean way to move the reader&lt;br/&gt;
creation out of the reader pool synchronization. It turns out to&lt;br/&gt;
be somewhat tricky, unless we redesign our synchronization. &lt;/p&gt;

&lt;p&gt;One thing that came to mind is passing a lock object to SR&apos;s&lt;br/&gt;
core (which would be the same lock on SRMapValue), which the&lt;br/&gt;
incref/decref could sync on as well. Otherwise we&apos;ve got&lt;br/&gt;
synchronization in many places, IW, IW.readerPool, SR, SR.core.&lt;br/&gt;
It would seem to make things brittle? Perhaps listing out the&lt;br/&gt;
various reasons we&apos;re synchronizing, to see if we can&lt;br/&gt;
consolidate some of them will help?&lt;/p&gt;</comment>
                            <comment id="12730030" author="jasonrutherglen" created="Sun, 12 Jul 2009 01:18:43 +0100"  >&lt;p&gt;Another idea is instantiate the SR.core.ref outside of the&lt;br/&gt;
IW.readerPool, and pass it into the newly created reader. Then&lt;br/&gt;
when we obtain SRMapValue, incref so we&apos;re keeping track of it&apos;s&lt;br/&gt;
usage, which (I believe) should be inline with the normal usage&lt;br/&gt;
of SR.ref (meaning don&apos;t close the reader if SRMV is checked&lt;br/&gt;
out). This way we know when the SRMV is in use and different&lt;br/&gt;
threads don&apos;t clobber each other creating and closing SRs using&lt;br/&gt;
readerPool.&lt;/p&gt;</comment>
                            <comment id="12730272" author="mikemccand" created="Mon, 13 Jul 2009 10:57:21 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I haven&apos;t really figured out a clean way to move the reader&lt;br/&gt;
creation out of the reader pool synchronization. It turns out to&lt;br/&gt;
be somewhat tricky, unless we redesign our synchronization.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe we should simply hold off for now?&lt;/p&gt;

&lt;p&gt;I don&apos;t think this sync is costing much in practice, now.&lt;br/&gt;
Ie, IndexReader.open is not concurrent when opening its segments; nor&lt;br/&gt;
would we expect multiple threads to be calling IndexWriter.getReader&lt;br/&gt;
concurrently.&lt;/p&gt;

&lt;p&gt;There is a wee bit of concurrency we are preventing, ie for a merge or&lt;br/&gt;
applyDeletes to get a reader just as an NRT reader is being opened,&lt;br/&gt;
but realistically 1) that&apos;s not very costly, and 2) we can&apos;t gain that&lt;br/&gt;
concurrency back anyway because we synchronize on IW when opening the&lt;br/&gt;
reader.&lt;/p&gt;</comment>
                            <comment id="12730424" author="jasonrutherglen" created="Mon, 13 Jul 2009 18:48:55 +0100"  >&lt;p&gt;I was thinking the sync on all of readerPool could delay someone&lt;br/&gt;
trying to call IW.getReader who would wait for a potentially&lt;br/&gt;
large new segment to be warmed. However because IW.mergeMiddle&lt;br/&gt;
isn&apos;t loading the term index, IW.getReader will pay the cost of&lt;br/&gt;
loading the term index. So yeah, it doesn&apos;t seem necessary.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12413000" name="LUCENE-1726.patch" size="39965" author="mikemccand" created="Thu, 9 Jul 2009 12:23:15 +0100"/>
                            <attachment id="12412908" name="LUCENE-1726.patch" size="18922" author="mikemccand" created="Wed, 8 Jul 2009 21:37:03 +0100"/>
                            <attachment id="12412809" name="LUCENE-1726.patch" size="13393" author="jasonrutherglen" created="Wed, 8 Jul 2009 01:30:43 +0100"/>
                            <attachment id="12412804" name="LUCENE-1726.patch" size="13282" author="jasonrutherglen" created="Wed, 8 Jul 2009 01:04:46 +0100"/>
                            <attachment id="12412643" name="LUCENE-1726.patch" size="9453" author="jasonrutherglen" created="Mon, 6 Jul 2009 19:54:28 +0100"/>
                            <attachment id="12412424" name="LUCENE-1726.patch" size="9588" author="jasonrutherglen" created="Thu, 2 Jul 2009 22:54:06 +0100"/>
                            <attachment id="12412884" name="LUCENE-1726.trunk.test.patch" size="3922" author="jasonrutherglen" created="Wed, 8 Jul 2009 17:46:33 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 6 Jul 2009 15:04:01 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12033</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Lucene Fields</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxyppz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>26318</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>