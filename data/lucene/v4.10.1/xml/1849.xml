<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:09:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1849/LUCENE-1849.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[LUCENE-1849] Add OutOfOrderCollector and InOrderCollector subclasses of Collector</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1849</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                    <description>&lt;p&gt;I find myself always having to implement these methods, and i always return a constant (depending on if the collector can handle out of order hits)&lt;/p&gt;

&lt;p&gt;would be nice for these two convenience abstract classes to exist that implemented acceptsDocsOutOfOrder() as final and returned the appropriate value&lt;/p&gt;</description>
                <environment></environment>
        <key id="12433849">LUCENE-1849</key>
            <summary>Add OutOfOrderCollector and InOrderCollector subclasses of Collector</summary>
                <type id="5" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Wish</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="tsmith">Tim Smith</reporter>
                        <labels>
                    </labels>
                <created>Mon, 24 Aug 2009 15:35:03 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:36 +0100</updated>
                            <resolved>Tue, 25 Aug 2009 10:15:38 +0100</resolved>
                                    <version>2.9</version>
                                    <fixVersion>2.9</fixVersion>
                                    <component>core/search</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12746904" author="shaie" created="Mon, 24 Aug 2009 15:56:59 +0100"  >&lt;p&gt;But then what will classes like TopFieldCollector and TopScoreDocCollector will do? They won&apos;t be able to extend from any of them because a Collector may support both, one impl more efficient than the other.&lt;/p&gt;

&lt;p&gt;Of course it doesn&apos;t mean that every Collector needs to extend either of these, but I wonder if it&apos;s such a big deal to decide on your own, once you&apos;ve decided to write a Collector, if you support it or not.&lt;/p&gt;

&lt;p&gt;Those two do not do any harm, but we&apos;ll just need to maintain them going forward, and I wonder if they are really that useful ...&lt;/p&gt;</comment>
                            <comment id="12746907" author="tsmith" created="Mon, 24 Aug 2009 16:01:40 +0100"  >&lt;p&gt;They would be convenience classes for people implementing their own Collectors (as i am)&lt;/p&gt;

&lt;p&gt;just kinda a pain (and bloats amount of required code by about 5 lines) to have to always implement this method (when it could be inherited easily from a parent class)&lt;/p&gt;

&lt;p&gt;Just throwing this out as an idea to see if anyone else likes it (thats why i marked it as a &lt;em&gt;Wish&lt;/em&gt;)&lt;/p&gt;</comment>
                            <comment id="12746912" author="shaie" created="Mon, 24 Aug 2009 16:21:04 +0100"  >&lt;blockquote&gt;&lt;p&gt;(and bloats amount of required code by about 5 lines)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You can do it in 2 (or even 1) &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; acceptsDocsOutOfOrder() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;/&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;; }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t mind if those two will be added. I still don&apos;t think they&apos;re that useful, but they don&apos;t do any harm either.&lt;/p&gt;</comment>
                            <comment id="12746920" author="tsmith" created="Mon, 24 Aug 2009 16:29:10 +0100"  >&lt;p&gt;People tend to always reformat single line functions like that to use at lest 2 more lines (i think checkstyle/eclipse formatting will often screw up my compact code if someone else ever touches it))&lt;br/&gt;
also, you need the extra line for javadoc, so thats always 5 lines &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I can always add these to classes to my class hierarchy (and i probably will if it doesn&apos;t get added to lucene&apos;s search package)&lt;br/&gt;
but i think these are in general useful to anyone implementing collectors&lt;/p&gt;

&lt;p&gt;a typical person porting to 2.9 can switch their HitCollector to subclass InOrderCollector instead (in order to keep getting docs in order like lucene 2.4)&lt;br/&gt;
This then means they don&apos;t need to even think about acceptDocsOutOfOrder() semantics unless they really want to&lt;br/&gt;
Also one less method to implement incorrectly for us application developers &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12746926" author="thetaphi" created="Mon, 24 Aug 2009 16:43:33 +0100"  >&lt;p&gt;How about making acceptsDocsOutOfOrder()  no abstract and provide a default implementation that just returns a field that can only be set by a protected method? E.g. protected setAcceptsDocsOutOfOrder()  can be initialized by a ctor? Or make the field private and initialize it by a ctor in the abstract calss? By that cou can create a subclass of Collector like the following:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Collector c = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Collector(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;/&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;) {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void collect(...)...
  ...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I would like this, as it is much simplier to use instead of always implementing this silly one-liner.&lt;/p&gt;</comment>
                            <comment id="12746928" author="tsmith" created="Mon, 24 Aug 2009 16:53:11 +0100"  >&lt;p&gt;I like the idea of this flag being private final and initialized via a Collector constructor&lt;/p&gt;

&lt;p&gt;Collector.acceptDocsOutOfOrder() should then be made final though? (otherwise each collector has a boolean flag that may never be used if a subclass implements acceptDocsOutOfOrder() its own way)&lt;/p&gt;</comment>
                            <comment id="12746971" author="mikemccand" created="Mon, 24 Aug 2009 18:42:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;I like the idea of this flag being private final and initialized via a Collector constructor&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems OK to me.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Collector.acceptDocsOutOfOrder() should then be made final though?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or just make it package private?  This flag is only used by oal.search.* to mate the right scorer to the collector.&lt;/p&gt;</comment>
                            <comment id="12747021" author="tsmith" created="Mon, 24 Aug 2009 20:03:30 +0100"  >&lt;blockquote&gt;&lt;p&gt;Or just make it package private? This flag is only used by oal.search.* to mate the right scorer to the collector.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;protected instead please, &lt;br/&gt;
Collector subclasses should be able to inspect this value if they want/need to&lt;/p&gt;
</comment>
                            <comment id="12747026" author="mikemccand" created="Mon, 24 Aug 2009 20:17:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;protected instead please, &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.  Can you cons up a patch here?&lt;/p&gt;</comment>
                            <comment id="12747028" author="tsmith" created="Mon, 24 Aug 2009 20:19:43 +0100"  >&lt;p&gt;will do&lt;/p&gt;</comment>
                            <comment id="12747029" author="shaie" created="Mon, 24 Aug 2009 20:21:22 +0100"  >&lt;p&gt;How would this flag reduce any &quot;code bloat&quot; in subclasses? They now have to call super() in their ctors.&lt;/p&gt;

&lt;p&gt;And TSDC and TFC will need to add a parameter to their private ctors, so that they can pass this parameter on to TopDocsCollector, which will need to pass it on to Collector ...&lt;/p&gt;

&lt;p&gt;I think this will get pretty messy and complicated.&lt;/p&gt;

&lt;p&gt;What exactly are we trying to solve here? 5 lines of code that every Collector developer (how many are out there anyway?) need to invest 3 minutes thinking about them before he codes that method?&lt;/p&gt;</comment>
                            <comment id="12747039" author="tsmith" created="Mon, 24 Aug 2009 20:44:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think this will get pretty messy and complicated.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah, this is a bit messy with the chain of inheritance in these classes (as each variant is &quot;slightly&quot; optimized depending on in order/out of order collection)&lt;/p&gt;

&lt;p&gt;makes me go back to favoring InOrderCollector/OutOfOrderCollector abstract classes&lt;br/&gt;
or maybe just one &quot;AbstractCollector&quot; method which implements all methods except collect()&lt;/p&gt;

&lt;p&gt;like so:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class AbstractCollector &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Collector {
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; allowDocsOutOfOrder;
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; IndexReader reader;
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; Scorer scorer;
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; docBase;  

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; AbstractCollector() {
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; AbstractCollector(&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; allowDocsOutOfOrder) {
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.allowDocsOutOfOrder = allowDocsOutOfOrder;
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void setNextReader(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; docBase) {
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.reader = reader;
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.docBase = docBase;
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void setScorer(Scorer scorer) {
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.scorer = scorer;
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; acceptsDocsOutOfOrder() {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; allowDocsOutOfOrder;
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;&lt;p&gt;What exactly are we trying to solve here?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;the Collector methodology has grown more complicated (because it does more to handle per segment searches)&lt;br/&gt;
the HitCollector api was nice and simple&lt;/p&gt;

&lt;p&gt;this AbstractCollector (insert better name here) gets things back to being more simple&lt;br/&gt;
could even hide the &quot;Scorer&quot; as private and provide a &quot;score()&quot; method that returns the score for the current document, and otherwise simplify this even more&lt;/p&gt;

&lt;p&gt;subclassing AbstractCollector instead of Collector makes it so most of the &quot;required common things&quot; are done for you&lt;br/&gt;
otherwise, every single Collector will do virtually the same thing is done in AbstractCollector here (as far as setup/etc)&lt;/p&gt;

&lt;p&gt;Again, this is just a &lt;em&gt;Wish&lt;/em&gt; which i&apos;ve thought of as i&apos;ve been working through the new collector API (and found myself doing the exact same thing for every implementation of Collector)&lt;/p&gt;</comment>
                            <comment id="12747042" author="shaie" created="Mon, 24 Aug 2009 21:02:41 +0100"  >&lt;p&gt;But if we encourage people to extend AbstractCollector, they&apos;ll incur some overhead we&apos;ve tried to eliminate. Why have a setScorer impl which does something, even if just member assignment, if I don&apos;t need the score?&lt;/p&gt;

&lt;p&gt;Keeping Scorer private is not good either, because that&apos;ll add a method call for me (score() vs. scorer.score()). This is also something we&apos;ve tried to avoid in all these &quot;specialized&quot; impls in TSDC/TFC.&lt;/p&gt;

&lt;p&gt;Part of the new Collector API is to help Collector developers impl the best Collector for their needs. By having those methods abstract, we force them to think a little bit and then do what&apos;s best for them. If I don&apos;t need a score, I don&apos;t even want to have a Scorer member in my Collector (which consumes memory, even if just a pointer).&lt;/p&gt;

&lt;p&gt;I&apos;m afraid that by introducing this AbstractCollector, we won&apos;t encourage people to impl the best Collector for their needs. They&apos;ll just impl collect() and use whatever is available if they need to. And really, IMO, this AbstractCollector saves me nothing - I don&apos;t mind writing this.scorer = scorer if I need Scorer. And I don&apos;t think the current Collector API makes it any more harder to write a Collector ... but perhaps I&apos;m wrong.&lt;/p&gt;</comment>
                            <comment id="12747046" author="tsmith" created="Mon, 24 Aug 2009 21:12:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;we force them to think a little bit and then do what&apos;s best for them&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;the more you force people to think, the more likely they will come to the wrong solution (in my experience)&lt;/p&gt;

&lt;p&gt;i love the power of the new Collector API, and i know how to take advantage of it to eek out the utmost performance where it matters or is possible.  But with some cases, i just want that AbstractCollector because it reduces my code complexity for subclasses and does everything i need without me introducing duplicated code&lt;/p&gt;

&lt;p&gt;Also, the AbstractCollector makes it much easier to create anonymous subclasses of Collector (just one method to override) (i hate anonymous subclasses myself, but i see them used a lot inside lucene). I know in 2.4 there were tons of anonymous HitCollectors &lt;/p&gt;</comment>
                            <comment id="12747050" author="shaie" created="Mon, 24 Aug 2009 21:20:14 +0100"  >&lt;p&gt;If we want to help people impl Collector, then let&apos;s at least make a useful subclass, like ScoringCollector which impls setScorer and setNextReader by keeping Scorer and docBase. It will leave you to impl collect() however you want.&lt;/p&gt;

&lt;p&gt;But just have an AbstractCollector which stores everything that the setter methods passed does not look a good idea to me. What do you think?&lt;/p&gt;</comment>
                            <comment id="12747051" author="tsmith" created="Mon, 24 Aug 2009 21:25:39 +0100"  >&lt;p&gt;i was just proposing AbstractCollector to consolidate the &quot;variations&quot; of abstract subclasses of Collector&lt;/p&gt;

&lt;p&gt;I like ScoringCollector&lt;br/&gt;
i would also like a NonScoringCollector&lt;/p&gt;

&lt;p&gt;in this case, i would recommend both should take the &quot;allowDocsOutOfOrder&quot; flag in their constructors (and store in a private final returned by acceptingOutOfOrderDocs())&lt;br/&gt;
otherwise, i would still want to see 2 variations on each of ScoringCollector and NonScoringCollector to handle the OutOfOrder vs InOrder variations&lt;/p&gt;

</comment>
                            <comment id="12747054" author="thetaphi" created="Mon, 24 Aug 2009 21:32:37 +0100"  >&lt;p&gt;There should also be not only the variation that simply stores docBase in a field. I normally never used that, I always store the reader in a field and then directly operate on the subreader (e.g. for retriving values from the field cache). For me global docIds are unimportant (at least in my collectors). Because of this problem, I had created exactly such a abstract helper class handling this.&lt;/p&gt;

&lt;p&gt;For the special case FieldCache, the proposed abstract class simply storing all set values into protected fields does not make sense. This FieldCache-using collectors normally override setNextReader(), where they retrieve the needed arrays from the field cache (whenever a new reader occurs, you can switch your value arrays to the next reader instantly). Collector then only operates on the field cache array, the reader is unimportant. And even the docBase is unimportant. I have such an collector, that uses numerical document ids from the relational database out of the field cache.&lt;/p&gt;

&lt;p&gt;Lot&apos;s of use-cases... Maybe we should put these helper classes into contrib/queries?&lt;/p&gt;</comment>
                            <comment id="12747059" author="tsmith" created="Mon, 24 Aug 2009 21:38:30 +0100"  >&lt;p&gt;I guess the question is: what variations do we provide helper Collector implementations for?&lt;/p&gt;

&lt;p&gt;seems like there&apos;s a bunch of possibilities (depending on how far you go)&lt;/p&gt;

&lt;p&gt;thats why i initially proposed AbstractCollector (storing everything that was set (IndexReader, Scorer, docBase))&lt;br/&gt;
the amount of memory and time used to set 2 pointers and an int per segment almost seems irrelevant for this Collector implementation aid (and if you really care about those few bytes and cpu cycles, you can directly implement Collector)&lt;/p&gt;</comment>
                            <comment id="12747067" author="mikemccand" created="Mon, 24 Aug 2009 21:59:27 +0100"  >&lt;p&gt;I think we should simply do nothing.  This is an expert API.  There are a many ways it&apos;s going to be used.  Each app can make helper classes if it wants, but I think Lucene should simply offer Collector.&lt;/p&gt;</comment>
                            <comment id="12747075" author="tsmith" created="Mon, 24 Aug 2009 22:03:54 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think we should simply do nothing. This is an expert API.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;i&apos;m ok with that&lt;/p&gt;

&lt;p&gt;just thought this idea would potentially be of general use for other developers, but it probably gets more complex adding all the variations for subclasses of Collector and maybe even more confusing that just the raw Collector API&lt;/p&gt;</comment>
                            <comment id="12747206" author="shaie" created="Tue, 25 Aug 2009 04:26:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think we should simply do nothing&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1. So many use cases brought up in this issue, and so many &quot;helper&quot; classes. I just can&apos;t help imagining the future of this &quot;I want a non scoring collector, which accepts docs out of order, and keeps its next reader ...&quot; and we&apos;ll try very hard to create a helper class which does that because now we cannot inherit from two &apos;abstract&apos; Collectors, each achieving part of it.&lt;/p&gt;

&lt;p&gt;I also feel that when I&apos;ll upgrade all of HitCollectors to Collector, the decision on what to do where will not be that difficult - it&apos;s pretty straightforward I think. At least it&apos;s the same decision as &quot;which collector should I subclass&quot; ...&lt;/p&gt;</comment>
                            <comment id="12747427" author="yseeley@gmail.com" created="Tue, 25 Aug 2009 15:13:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think we should simply do nothing. This is an expert API.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;The reality is that order will matter for some custom collectors, and the abstract method makes that clear.&lt;br/&gt;
The API is fine as it is, but if we wanted to provide a default in Collector, that would be fine too.&lt;br/&gt;
&lt;b&gt;If&lt;/b&gt; we were to provide a default in Collector, it should be a simple constant, not a variable.  Subclasses changing would simply override the method as normal.  We should strive to treat our abstract base classes as interfaces, and adding fields and final methods should be avoided.&lt;/p&gt;</comment>
                            <comment id="12747441" author="tsmith" created="Tue, 25 Aug 2009 15:34:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we were to provide a default in Collector, it should be a simple constant, not a variable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;in that case, it may be useful to have this method return &quot;false&quot; by default (expecting docs in order, as this is the &quot;default&quot; in 2.4)&lt;/p&gt;</comment>
                            <comment id="12747584" author="mikemccand" created="Tue, 25 Aug 2009 20:12:20 +0100"  >&lt;p&gt;I would prefer not to make a default here, ie, force an explicit&lt;br/&gt;
choice, because it is an expert API.&lt;/p&gt;

&lt;p&gt;BooleanQuery gets sizable gains in performance if you let it return&lt;br/&gt;
docs out of order.  If we default it (to false), most users won&apos;t&lt;br/&gt;
realize how much performance they&apos;re accidentally losing.&lt;/p&gt;</comment>
                            <comment id="12747587" author="tsmith" created="Tue, 25 Aug 2009 20:20:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;I would prefer not to make a default here, ie, force an explicit choice, because it is an expert API. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;very reasonable&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BooleanQuery gets sizable gains in performance if you let it return docs out of order.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Any stats on the performance gains here available?&lt;br/&gt;
didn&apos;t see any on a cursory glance through javadoc&lt;/p&gt;

&lt;p&gt;Also, are the implications of out of order docids coming back from nextDoc() well documented (javadoc?, wiki?)?&lt;br/&gt;
I guess out of order docids really screw up advance(int), so you should never call advance(int) if you allowed out of order collection for a Scorer?&lt;/p&gt;</comment>
                            <comment id="12747637" author="mikemccand" created="Tue, 25 Aug 2009 22:00:05 +0100"  >&lt;blockquote&gt;&lt;p&gt;Any stats on the performance gains here available?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think somewhere in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1483&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt; is the answer to this question, but I can&apos;t find it now.  (We need a whole new search index just for that issue alone!).  But the optimization currently only applies if the query contains just SHOULD terms plus up to 32 MUST_NOT terms.  More testing here would be great... the specialized search in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1594&quot; title=&quot;Use source code specialization to maximize search performance&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1594&quot;&gt;&lt;del&gt;LUCENE-1594&lt;/del&gt;&lt;/a&gt; also uses out-of-order collection for certain AND queries but I haven&apos;t confirmed if/when that&apos;s a win.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Also, are the implications of out of order docids coming back from nextDoc() well documented (javadoc?, wiki?)?&lt;br/&gt;
I guess out of order docids really screw up advance(int), so you should never call advance(int) if you allowed out of order collection for a Scorer?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Out-of-order scoring is only used for top-scorers today in Lucene, so nextDoc/advance are not used.  (Though: BooleanScorer, which provides docs out-of-order, is I think able to nextDoc() through the out-of-order docs, but I don&apos;t think we take advantage of that anywhere, though we could do so to improve performance of BooleanQuery as a sub-clause of BooleanQuery).&lt;/p&gt;</comment>
                            <comment id="12747645" author="tsmith" created="Tue, 25 Aug 2009 22:10:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;Out-of-order scoring is only used for top-scorers today in Lucene&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I see that FilteredQuery passes &quot;scoreDocsInOrder&quot; down to its sub query&lt;br/&gt;
Is this incorrect?&lt;br/&gt;
seems like this could cause problems as FilteredQuery does call nextDoc/advance on its sub query (which could be out of order because of this)&lt;/p&gt;</comment>
                            <comment id="12747678" author="mikemccand" created="Tue, 25 Aug 2009 22:55:01 +0100"  >&lt;p&gt;Good catch!  It should not be doing that.  It should be passing &quot;true&quot; down since it will use advance.&lt;/p&gt;

&lt;p&gt;But it doesn&apos;t result in a bug, because 1) its Weight.scoresDocsOutOfOrder returns false, which causes IndexSearcher&apos;s sort by relevance or field methods to pick an in-order collector which then causes IndexSearcher to pass &quot;true&quot; for scoreDocsInOrder, and 2) it&apos;s passing down &quot;false&quot; for topScorer, which causes BooleanQuery to not return an out-of-order scorer.&lt;/p&gt;

&lt;p&gt;I&apos;ll commit a fix plus a test shortly.&lt;/p&gt;</comment>
                            <comment id="12747805" author="shaie" created="Wed, 26 Aug 2009 08:07:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think somewhere in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1483&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt; is the answer to this question&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I tracked it down to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1575&quot; title=&quot;Refactoring Lucene collectors (HitCollector and extensions)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1575&quot;&gt;&lt;del&gt;LUCENE-1575&lt;/del&gt;&lt;/a&gt; which was the huge refactoring to HitCollector issue: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1575?focusedCommentId=12695784&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12695784&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-1575?focusedCommentId=12695784&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12695784&lt;/a&gt;&lt;br/&gt;
(perhaps we should index my memory cells? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ).&lt;/p&gt;</comment>
                            <comment id="12747851" author="mikemccand" created="Wed, 26 Aug 2009 10:23:41 +0100"  >&lt;p&gt;We do need to index your memory cells!&lt;/p&gt;

&lt;p&gt;Except: that entry is showing the &lt;span class=&quot;error&quot;&gt;&amp;#91;sizable&amp;#93;&lt;/span&gt; perf gains of disabling scoring when sorting by field (I think?). We were instead looking for the comparison of BooleanScorer vs BoolenScorer2.&lt;/p&gt;</comment>
                            <comment id="12747874" author="shaie" created="Wed, 26 Aug 2009 10:58:16 +0100"  >&lt;p&gt;Yes I know that - I remember that you once ran w/ BS vs. BS2 and thought the results were reported in that issue. But I&apos;ve scanned it and I don&apos;t find it. Perhaps it was in an email, but I seem to remember you reported ~20-30% improvement in favor of BS. I&apos;ll try to digg it up from the bottom of my memory pit.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 24 Aug 2009 14:56:59 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11914</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Lucene Fields</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxyoyv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>26196</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>