<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:06:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-887/LUCENE-887.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[LUCENE-887] Interruptible segment merges</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-887</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                    <description>&lt;p&gt;Adds the ability to IndexWriter to interrupt an ongoing merge. This might be necessary when Lucene is e. g. running as a service and has to stop indexing within a certain period of time due to a shutdown request.&lt;/p&gt;

&lt;p&gt;A solution would be to add a new method shutdown() to IndexWriter which satisfies the following two requirements:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if a merge is happening, abort it&lt;/li&gt;
	&lt;li&gt;flush the buffered docs but do not trigger a merge&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;See also discussions about this feature on java-dev:&lt;br/&gt;
&lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/49008&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/49008&lt;/a&gt;&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12370016">LUCENE-887</key>
            <summary>Interruptible segment merges</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="michaelbusch">Michael Busch</assignee>
                                    <reporter username="michaelbusch">Michael Busch</reporter>
                        <labels>
                    </labels>
                <created>Wed, 23 May 2007 05:36:16 +0100</created>
                <updated>Fri, 21 Dec 2007 10:33:41 +0000</updated>
                            <resolved>Fri, 21 Dec 2007 10:33:41 +0000</resolved>
                                                                    <component>core/index</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12500301" author="michaelbusch" created="Thu, 31 May 2007 08:14:09 +0100"  >&lt;p&gt;Here is the code I originally wrote to add a shutdown function to IndexWriter.&lt;/p&gt;

&lt;p&gt;This patch contains a class called ExtendedIndexWriter that (as you might &lt;br/&gt;
guess &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ) extends IndexWriter and adds a shutdown() method. This method&lt;br/&gt;
may always be called by some thread, no matter if other threads are &lt;br/&gt;
currently adding documents.&lt;/p&gt;

&lt;p&gt;Three scenarios might happen:&lt;br/&gt;
1) Shutdown() is called while there is no ongoing merge or addDocument:&lt;br/&gt;
   In this case the buffered documents are flushed to disk without &lt;br/&gt;
   triggering cascading merges. (I will commit a protected method&lt;br/&gt;
   flushRamSegments(boolean triggerMerge) to IndexWriter to support this.&lt;/p&gt;

&lt;p&gt;2) Shutdown() is called while there is an ongoing merge:&lt;br/&gt;
   In this case an IOException is thrown by the extended FSOutputStream&lt;br/&gt;
   which makes the IndexWriter rollback the transaction. Thereafter&lt;br/&gt;
   flushRamSegments(false) is called to flush buffered docs if there are&lt;br/&gt;
   any.&lt;/p&gt;

&lt;p&gt;3) Shutdown() is called while other threads are in addDocument:&lt;br/&gt;
   This is the tricky one. We don&apos;t want to throw the IOException before&lt;br/&gt;
   the addDocument has finished analyzing and indexing the document,&lt;br/&gt;
   because otherwise this document would be lost. Since buildDocument()&lt;br/&gt;
   is not synchronized we can not rely on IndexWriters mutex to wait for&lt;br/&gt;
   those threads to finish addDocument. Therefore I add a variable that&lt;br/&gt;
   counts how many threads are in addDocument(). A different mutex is&lt;br/&gt;
   used to increment, decrement and check this variable. Shutdown wait&lt;br/&gt;
   until indexing of those docs is done and continues like in case 1) or 2).&lt;/p&gt;


&lt;p&gt;I suggest whoever is interested should just look at the code. I&apos;m sure&lt;br/&gt;
there will be a lot of questions. There&apos;s still a lot of work that has&lt;br/&gt;
to be done here, like writing testcases and examining how this works in&lt;br/&gt;
the new autoCommit=false mode (I wrote this code before that new feature&lt;br/&gt;
was committed). And we still have to decide whether this shutdown&lt;br/&gt;
functionality should go into the Lucene core.&lt;/p&gt;</comment>
                            <comment id="12500457" author="mikemccand" created="Thu, 31 May 2007 20:20:39 +0100"  >
&lt;p&gt;This looks great to me!&lt;/p&gt;

&lt;p&gt;I think we should keep it out of core (ie, as subclasses as you&apos;ve done&lt;br/&gt;
here) for now?&lt;/p&gt;

&lt;p&gt;So, if a shutdown request comes in then currently running addDocument&lt;br/&gt;
calls are allowed to complete but if a new addDocument call tries to&lt;br/&gt;
run it will hit an &quot;IndexWriter already closed&quot; IOException.  Once the&lt;br/&gt;
in-flight addDocument calls finish you then flush the ram segments&lt;br/&gt;
without allowing cascading merge.&lt;/p&gt;

&lt;p&gt;This actually means you can potentially have too many &quot;level 0&quot; (just&lt;br/&gt;
flushed) segments in the index but that should not be a big deal since&lt;br/&gt;
the next merge would clean it up.  And it should be rare.&lt;/p&gt;

&lt;p&gt;In shutdown(), after you call waitForAddDocument(), why not call&lt;br/&gt;
clearInterrupt before calling flushRamSegments?  Isn&apos;t the&lt;br/&gt;
flushRamSegments() call guaranteed to hit the&lt;br/&gt;
IndexWriterInterruptException if it&apos;s using an ExtendedFSDirectory and&lt;br/&gt;
there are &amp;gt; 0 buffered docs?&lt;/p&gt;

&lt;p&gt;Also I think it&apos;s possible that the addDocument() call from another&lt;br/&gt;
thread will hit the IndexWriterInterruptException, right?  So those&lt;br/&gt;
other threads should catch this and ignore it (since their doc was in&lt;br/&gt;
fact succesfully added and only the followon merge was interrupted)?&lt;/p&gt;</comment>
                            <comment id="12500550" author="michaelbusch" created="Fri, 1 Jun 2007 02:50:06 +0100"  >&lt;p&gt;&amp;gt; This looks great to me!&lt;/p&gt;

&lt;p&gt;Thanks for reviewing!&lt;/p&gt;

&lt;p&gt;&amp;gt; So, if a shutdown request comes in then currently running addDocument&lt;br/&gt;
&amp;gt; calls are allowed to complete but if a new addDocument call tries to&lt;br/&gt;
&amp;gt; run it will hit an &quot;IndexWriter already closed&quot; IOException.  Once the&lt;br/&gt;
&amp;gt; in-flight addDocument calls finish you then flush the ram segments&lt;br/&gt;
&amp;gt; without allowing cascading merge.&lt;/p&gt;

&lt;p&gt;Exactly.&lt;/p&gt;

&lt;p&gt;&amp;gt; This actually means you can potentially have too many &quot;level 0&quot; (just&lt;br/&gt;
&amp;gt; flushed) segments in the index but that should not be a big deal since&lt;br/&gt;
&amp;gt; the next merge would clean it up.  And it should be rare.&lt;/p&gt;

&lt;p&gt;Yes, unless another shutdown request comes while the first merge after&lt;br/&gt;
restarting the system is happening (which should be very unlikely), this&lt;br/&gt;
will be cleaned up. Also, once the system is up again the IndexWriter &lt;br/&gt;
will delete left over file fragments from an aborted merge.&lt;/p&gt;

&lt;p&gt;&amp;gt; In shutdown(), after you call waitForAddDocument(), why not call&lt;br/&gt;
&amp;gt; clearInterrupt before calling flushRamSegments?  Isn&apos;t the&lt;br/&gt;
&amp;gt; flushRamSegments() call guaranteed to hit the&lt;br/&gt;
&amp;gt; IndexWriterInterruptException if it&apos;s using an ExtendedFSDirectory and&lt;br/&gt;
&amp;gt; there are &amp;gt; 0 buffered docs?&lt;/p&gt;

&lt;p&gt;Hmm I think I did it this way in case we aren&apos;t using an &lt;br/&gt;
ExtendedFSDirectory, because then the flush would just succeed without &lt;br/&gt;
an IndexWriterInterruptException and we safe an instanceof check here. &lt;br/&gt;
But you are right, we can just call clearInterrupt, but only if &lt;br/&gt;
(d instanceof ExtendedFSDirectory) == true. That&apos;s probably simpler. &lt;br/&gt;
Thereafter it is safe to call close() because the buffer is empty, so &lt;br/&gt;
the call of flushRamSegments in close() won&apos;t do anything.&lt;/p&gt;

&lt;p&gt;&amp;gt; Also I think it&apos;s possible that the addDocument() call from another&lt;br/&gt;
&amp;gt; thread will hit the IndexWriterInterruptException, right?  So those&lt;br/&gt;
&amp;gt; other threads should catch this and ignore it (since their doc was in&lt;br/&gt;
&amp;gt; fact succesfully added and only the followon merge was interrupted)?&lt;/p&gt;

&lt;p&gt;Hmm I&apos;m not sure if I understand this. I catch the &lt;br/&gt;
IndexWriterInterruptException in addDocument() and in the catch block&lt;br/&gt;
flushAfterInterrupt() is called which clears the interrupt flag. So&lt;br/&gt;
IndexWriterInterruptException shouldn&apos;t be thrown again and addDocument()&lt;br/&gt;
should just return normally? Or am I missing something. Could you give &lt;br/&gt;
an example?&lt;/p&gt;</comment>
                            <comment id="12500634" author="mikemccand" created="Fri, 1 Jun 2007 10:13:07 +0100"  >&lt;p&gt;&amp;gt; &amp;gt; This actually means you can potentially have too many &quot;level 0&quot; (just&lt;br/&gt;
&amp;gt; &amp;gt; flushed) segments in the index but that should not be a big deal since&lt;br/&gt;
&amp;gt; &amp;gt; the next merge would clean it up. And it should be rare.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Yes, unless another shutdown request comes while the first merge&lt;br/&gt;
&amp;gt; after restarting the system is happening (which should be very&lt;br/&gt;
&amp;gt; unlikely), this will be cleaned up. Also, once the system is up&lt;br/&gt;
&amp;gt; again the IndexWriter will delete left over file fragments from an&lt;br/&gt;
&amp;gt; aborted merge.&lt;/p&gt;

&lt;p&gt;Actually the leftover files from the aborted merge &lt;b&gt;should&lt;/b&gt; be deleted&lt;br/&gt;
in the finally clause in mergeSegments, on hitting the original&lt;br/&gt;
IndexWriterInterruptedException.  Ie once shutdown is complete, your&lt;br/&gt;
index should have none of the partially written files left, I think?&lt;/p&gt;


&lt;p&gt;&amp;gt; &amp;gt; Also I think it&apos;s possible that the addDocument() call from another&lt;br/&gt;
&amp;gt; &amp;gt; thread will hit the IndexWriterInterruptException, right? So those&lt;br/&gt;
&amp;gt; &amp;gt; other threads should catch this and ignore it (since their doc was in&lt;br/&gt;
&amp;gt; &amp;gt; fact succesfully added and only the followon merge was interrupted)?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Hmm I&apos;m not sure if I understand this. I catch the&lt;br/&gt;
&amp;gt; IndexWriterInterruptException in addDocument() and in the catch&lt;br/&gt;
&amp;gt; block flushAfterInterrupt() is called which clears the interrupt&lt;br/&gt;
&amp;gt; flag. So IndexWriterInterruptException shouldn&apos;t be thrown again and&lt;br/&gt;
&amp;gt; addDocument() should just return normally? Or am I missing&lt;br/&gt;
&amp;gt; something. Could you give an example?&lt;/p&gt;

&lt;p&gt;Woops &amp;#8211; sorry, I missed that you indeed catch the&lt;br/&gt;
IndexWriterInterruptException coming out of all addDocument calls, so&lt;br/&gt;
I think that will work correctly and the caller will never see the&lt;br/&gt;
exception.  Good!&lt;/p&gt;

&lt;p&gt;Hmm, here&apos;s another possible issue .. thread safety sure is difficult.&lt;/p&gt;

&lt;p&gt;Say there are 2 addDocument calls in-flight, and the first one tries&lt;br/&gt;
to flush buffered docs but hits the IndexWRiterInterruptException.&lt;br/&gt;
You catch this, clear the interrupt flag but before you then call&lt;br/&gt;
flushRAMSegments(false) the other addDocument thread get scheduled and&lt;br/&gt;
enters the synchronized block in addDocument and then kicks off a&lt;br/&gt;
flush with a merge.  I think at this point the merge would happily run&lt;br/&gt;
to completion because the interrupt flag got cleared?&lt;/p&gt;</comment>
                            <comment id="12500766" author="michaelbusch" created="Fri, 1 Jun 2007 18:15:35 +0100"  >&lt;p&gt;&amp;gt; Actually the leftover files from the aborted merge &lt;b&gt;should&lt;/b&gt; be deleted&lt;br/&gt;
&amp;gt; in the finally clause in mergeSegments, on hitting the original&lt;br/&gt;
&amp;gt; IndexWriterInterruptedException.  Ie once shutdown is complete, your&lt;br/&gt;
&amp;gt; index should have none of the partially written files left, I think?&lt;/p&gt;

&lt;p&gt;Oh yes, you&apos;re right.&lt;/p&gt;

&lt;p&gt;&amp;gt; Hmm, here&apos;s another possible issue .. thread safety sure is difficult.&lt;/p&gt;

&lt;p&gt;It is!&lt;/p&gt;

&lt;p&gt;&amp;gt; Say there are 2 addDocument calls in-flight, and the first one tries&lt;br/&gt;
&amp;gt; to flush buffered docs but hits the IndexWRiterInterruptException.&lt;br/&gt;
&amp;gt; You catch this, clear the interrupt flag but before you then call&lt;br/&gt;
&amp;gt; flushRAMSegments(false) the other addDocument thread get scheduled and&lt;br/&gt;
&amp;gt; enters the synchronized block in addDocument and then kicks off a&lt;br/&gt;
&amp;gt; flush with a merge.  I think at this point the merge would happily run&lt;br/&gt;
&amp;gt; to completion because the interrupt flag got cleared?&lt;/p&gt;

&lt;p&gt;Hmm... yes I understand. Actually do we even have to call&lt;br/&gt;
flushAfterInterrupt() in the catch clause of addDocument()? The &lt;br/&gt;
IndexWriterInterruptException is only thrown in case shutdown() has&lt;br/&gt;
been called, and in that case shutdown() waits anyways for all &lt;br/&gt;
in-flight addDocument() calls to complete and flushes the buffered docs&lt;br/&gt;
then. Right? Or maybe I&apos;m completely confused now... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12500780" author="mikemccand" created="Fri, 1 Jun 2007 18:47:36 +0100"  >&lt;p&gt;&amp;gt; &amp;gt; Say there are 2 addDocument calls in-flight, and the first one tries&lt;br/&gt;
&amp;gt; &amp;gt; to flush buffered docs but hits the IndexWRiterInterruptException.&lt;br/&gt;
&amp;gt; &amp;gt; You catch this, clear the interrupt flag but before you then call&lt;br/&gt;
&amp;gt; &amp;gt; flushRAMSegments(false) the other addDocument thread get scheduled and&lt;br/&gt;
&amp;gt; &amp;gt; enters the synchronized block in addDocument and then kicks off a&lt;br/&gt;
&amp;gt; &amp;gt; flush with a merge. I think at this point the merge would happily run&lt;br/&gt;
&amp;gt; &amp;gt; to completion because the interrupt flag got cleared?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Hmm... yes I understand. Actually do we even have to call&lt;br/&gt;
&amp;gt; flushAfterInterrupt() in the catch clause of addDocument()? The&lt;br/&gt;
&amp;gt; IndexWriterInterruptException is only thrown in case shutdown() has&lt;br/&gt;
&amp;gt; been called, and in that case shutdown() waits anyways for all&lt;br/&gt;
&amp;gt; in-flight addDocument() calls to complete and flushes the buffered&lt;br/&gt;
&amp;gt; docs then. Right? Or maybe I&apos;m completely confused now... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I think you are right: just removing the call to flushAfterInterrupt()&lt;br/&gt;
in the catch clause of addDocument() should correct this.  That way&lt;br/&gt;
there is only one place&amp;amp;time (inside shutdown()) where the&lt;br/&gt;
flushAfterInterrupt() is called and this should properly prevent any&lt;br/&gt;
merging from taking place.  Phew!&lt;/p&gt;

&lt;p&gt;Best to make a super stressful thread test case and run in on an N&amp;gt;1&lt;br/&gt;
CPU/core machine to be really sure the different concurrency paths are&lt;br/&gt;
well explored &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12500794" author="michaelbusch" created="Fri, 1 Jun 2007 19:19:38 +0100"  >&lt;p&gt;&amp;gt; I think you are right: just removing the call to flushAfterInterrupt()&lt;br/&gt;
&amp;gt; in the catch clause of addDocument() should correct this.  That way&lt;br/&gt;
&amp;gt; there is only one place&amp;amp;time (inside shutdown()) where the&lt;br/&gt;
&amp;gt; flushAfterInterrupt() is called and this should properly prevent any&lt;br/&gt;
&amp;gt; merging from taking place.  Phew!&lt;/p&gt;

&lt;p&gt;Cool. I will update the patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; Best to make a super stressful thread test case and run in on an N&amp;gt;1&lt;br/&gt;
&amp;gt; CPU/core machine to be really sure the different concurrency paths are&lt;br/&gt;
&amp;gt; well explored  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;Agree. I will work on a test case as well. I can use a 4 core Xeon&lt;br/&gt;
machine to run the tests on.&lt;/p&gt;</comment>
                            <comment id="12500802" author="michaelbusch" created="Fri, 1 Jun 2007 19:28:46 +0100"  >&lt;p&gt;&amp;gt; I think we should keep it out of core (ie, as subclasses as you&apos;ve done&lt;br/&gt;
&amp;gt; here) for now? &lt;/p&gt;

&lt;p&gt;We could also add new methods (not abstract) to Directory:&lt;br/&gt;
  boolean isInterruptable();&lt;br/&gt;
  void interrupt();&lt;br/&gt;
  void clearInterrupt();&lt;/p&gt;

&lt;p&gt;By default isInterruptable() would return false and the other two wouldn&apos;t&lt;br/&gt;
do anything. Only some Directory implementations should then overwrite these&lt;br/&gt;
methods, like FSDirectory.&lt;/p&gt;

&lt;p&gt;What I don&apos;t like about this is that we would have to make those methods&lt;br/&gt;
public, because IndexWriter has to call them. &lt;/p&gt;</comment>
                            <comment id="12500933" author="mikemccand" created="Sat, 2 Jun 2007 09:24:09 +0100"  >&lt;p&gt;I too am nervous about making this as a public API change to&lt;br/&gt;
Directory.&lt;/p&gt;

&lt;p&gt;I&apos;m also nervous that such a broad change expands the API of Directory&lt;br/&gt;
to achieve a fairly specific functionality in IndexWriter (stop a&lt;br/&gt;
merge).&lt;/p&gt;

&lt;p&gt;Also, looking forward to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-843&quot; title=&quot;improve how IndexWriter uses RAM to buffer added documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-843&quot;&gt;&lt;del&gt;LUCENE-843&lt;/del&gt;&lt;/a&gt;, I &lt;b&gt;think&lt;/b&gt; we will need a&lt;br/&gt;
different approach anyways (I think one that specifically targets the&lt;br/&gt;
merging, at a higher level).  Because with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-843&quot; title=&quot;improve how IndexWriter uses RAM to buffer added documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-843&quot;&gt;&lt;del&gt;LUCENE-843&lt;/del&gt;&lt;/a&gt;, IndexWriter&lt;br/&gt;
directly streams stored fields &amp;amp; vectors to disk and so you&apos;d have to&lt;br/&gt;
be extremely careful not to interrupt that IO (vs the IO being done&lt;br/&gt;
for merging).&lt;/p&gt;</comment>
                            <comment id="12500971" author="michaelbusch" created="Sat, 2 Jun 2007 23:31:50 +0100"  >&lt;p&gt;&amp;gt; I&apos;m also nervous that such a broad change expands the API of Directory&lt;br/&gt;
&amp;gt; to achieve a fairly specific functionality in IndexWriter (stop a&lt;br/&gt;
&amp;gt; merge).&lt;/p&gt;

&lt;p&gt;I agree. Adding public methods to Directory with javadocs saying&lt;br/&gt;
&quot;Please don&apos;t call me!&quot; is probably not very desirable.&lt;/p&gt;

&lt;p&gt;&amp;gt; Also, looking forward to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-843&quot; title=&quot;improve how IndexWriter uses RAM to buffer added documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-843&quot;&gt;&lt;del&gt;LUCENE-843&lt;/del&gt;&lt;/a&gt;, I &lt;b&gt;think&lt;/b&gt; we will need a&lt;br/&gt;
&amp;gt; different approach anyways (I think one that specifically targets the&lt;br/&gt;
&amp;gt; merging, at a higher level). Because with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-843&quot; title=&quot;improve how IndexWriter uses RAM to buffer added documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-843&quot;&gt;&lt;del&gt;LUCENE-843&lt;/del&gt;&lt;/a&gt;, IndexWriter&lt;br/&gt;
&amp;gt; directly streams stored fields &amp;amp; vectors to disk and so you&apos;d have to&lt;br/&gt;
&amp;gt; be extremely careful not to interrupt that IO (vs the IO being done&lt;br/&gt;
&amp;gt; for merging).&lt;/p&gt;

&lt;p&gt;OK I understand. Right, this approach would interrupt those streams as &lt;br/&gt;
well. I&apos;m not very familiar with your 843 patch yet, hopefully after 2.2&lt;br/&gt;
is out I&apos;ll have some time...&lt;/p&gt;</comment>
                            <comment id="12535357" author="michaelbusch" created="Tue, 16 Oct 2007 22:47:43 +0100"  >&lt;p&gt;I think we can close this issue because we have a concurrent MergeScheduler now and a close() method that can abort running merges:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /**
   * Closes the index with or without waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; currently
   * running merges to finish.  This is only meaningful when
   * using a MergeScheduler that runs merges in background
   * threads.
   * @param waitForMerges &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; call will block
   * until all merges complete; &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;, it will abort all
   * running merges and &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; right away
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void close(&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; waitForMerges) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The only restriction is that an application that wants to be able to stop merges immediately has to use a concurrent MergeScheduler, but I think this is acceptable?&lt;/p&gt;</comment>
                            <comment id="12535366" author="michaelbusch" created="Wed, 17 Oct 2007 00:03:13 +0100"  >&lt;p&gt;Just to confirm: close(false) only aborts running merges, but waits for in-flight addDocument() calls and flush, right? That would mean that we can never loose data with close(false), just some merge work?&lt;/p&gt;</comment>
                            <comment id="12535369" author="mikemccand" created="Wed, 17 Oct 2007 00:17:42 +0100"  >&lt;p&gt;That&apos;s right.&lt;/p&gt;

&lt;p&gt;Close calls flush() and flush() waits for any in-flight addDocument() calls to finish.&lt;/p&gt;</comment>
                            <comment id="12544724" author="michaelbusch" created="Thu, 22 Nov 2007 08:03:19 +0000"  >&lt;p&gt;close(false) does not &quot;kill&quot; a merge thread right? So actually&lt;br/&gt;
there is no guarantee that close(false) will return within x minutes?&lt;/p&gt;

&lt;p&gt;E. g. if a cascading merge is running, then close(false) will wait&lt;br/&gt;
for the current merge job to finish, and then abort, meaning not&lt;br/&gt;
perform other planned merge jobs of the cascading merge?&lt;br/&gt;
But if the current merge job is very big, with huge segments&lt;br/&gt;
involved, then it can still take a long time for close(false) to&lt;br/&gt;
return?&lt;/p&gt;</comment>
                            <comment id="12544769" author="mikemccand" created="Thu, 22 Nov 2007 11:03:16 +0000"  >
&lt;p&gt;I believe close(false) marks all still-running merges as aborted&lt;br/&gt;
(calls OneMerge.abort()) and then returns immediately without waiting&lt;br/&gt;
for them to finish?&lt;/p&gt;

&lt;p&gt;However, you&apos;re right, those merge threads are not &quot;killed&quot; in that&lt;br/&gt;
they keep running until they &quot;notice&quot; they were aborted (typically&lt;br/&gt;
when the merge tries to commit its results).  Right now we don&apos;t make&lt;br/&gt;
any effort to have the merging process notice sooner that it was&lt;br/&gt;
aborted and abort the thread.&lt;/p&gt;

&lt;p&gt;If we could somehow reach in &amp;amp; find all FSIndexOutputs that are&lt;br/&gt;
presently opened by SegmentMerger, and forcefully close them (forcing&lt;br/&gt;
an IOException which ConcurrentMergeScheduler catches &amp;amp; ignores if the&lt;br/&gt;
merge was aborted) that&apos;d give us a fast way to have the threads stop&lt;br/&gt;
working.&lt;/p&gt;

&lt;p&gt;Oh, one issue is we are failing to setDaemon(true) on these threads,&lt;br/&gt;
which means the JVM will not exit until they complete.  I&apos;ll fix&lt;br/&gt;
that.&lt;/p&gt;</comment>
                            <comment id="12544854" author="michaelbusch" created="Thu, 22 Nov 2007 17:46:25 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I believe close(false) marks all still-running merges as aborted&lt;br/&gt;
(calls OneMerge.abort()) and then returns immediately without waiting&lt;br/&gt;
for them to finish?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;OK I got it. So if Lucene runs as a service and a shutdown request is&lt;br/&gt;
received, then a call to close(false) will cause the IndexWriter to mark&lt;br/&gt;
the running merges as aborted, flush the buffer and return once &lt;br/&gt;
flush+commit is done. Then the caller knows that it is safe now to&lt;br/&gt;
shutdown the JVM, which will also stop the running merge thread&lt;br/&gt;
(because it&apos;s a daemon thread now). &lt;br/&gt;
We should probably add a testcase that tests such a shutdown &lt;br/&gt;
scenario.&lt;/p&gt;

 &lt;blockquote&gt;
&lt;p&gt;If we could somehow reach in &amp;amp; find all FSIndexOutputs that are&lt;br/&gt;
presently opened by SegmentMerger, and forcefully close them (forcing&lt;br/&gt;
an IOException which ConcurrentMergeScheduler catches &amp;amp; ignores if the&lt;br/&gt;
merge was aborted) that&apos;d give us a fast way to have the threads stop&lt;br/&gt;
working.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The fact that the background merge thread keeps running doesn&apos;t hurt&lt;br/&gt;
us, but the advantage would be to reduce system load and thus to&lt;br/&gt;
possibly speedup the flush+commit that the other thread is doing.&lt;br/&gt;
Maybe for now we could also set the priority of the background thread&lt;br/&gt;
to a minimum value, as soon as close(false) is called?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Oh, one issue is we are failing to setDaemon(true) on these threads,&lt;br/&gt;
which means the JVM will not exit until they complete. I&apos;ll fix&lt;br/&gt;
that.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Cool, thanks! W/o this the above explained shutdown scenario wouldn&apos;t&lt;br/&gt;
work.&lt;/p&gt;</comment>
                            <comment id="12553921" author="michaelbusch" created="Fri, 21 Dec 2007 10:33:41 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1097&quot; title=&quot;IndexWriter.close(false) does not actually stop background merge threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1097&quot;&gt;&lt;del&gt;LUCENE-1097&lt;/del&gt;&lt;/a&gt; solves this nicely!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12358593" name="ExtendedIndexWriter.java" size="7904" author="michaelbusch" created="Thu, 31 May 2007 08:14:09 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 31 May 2007 19:20:39 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12855</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Lucene Fields</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxyux3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27160</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>