<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:11:33 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/PIG-1295/PIG-1295.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[PIG-1295] Binary comparator for secondary sort</title>
                <link>https://issues.apache.org/jira/browse/PIG-1295</link>
                <project id="12310730" key="PIG">Pig</project>
                    <description>&lt;p&gt;When hadoop framework doing the sorting, it will try to use binary version of comparator if available. The benefit of binary comparator is we do not need to instantiate the object before we compare. We see a ~30% speedup after we switch to binary comparator. Currently, Pig use binary comparator in following case:&lt;/p&gt;

&lt;p&gt;1. When semantics of order doesn&apos;t matter. For example, in distinct, we need to do a sort in order to filter out duplicate values; however, we do not care how comparator sort keys. Groupby also share this character. In this case, we rely on hadoop&apos;s default binary comparator&lt;br/&gt;
2. Semantics of order matter, but the key is of simple type. In this case, we have implementation for simple types, such as integer, long, float, chararray, databytearray, string&lt;/p&gt;

&lt;p&gt;However, if the key is a tuple and the sort semantics matters, we do not have a binary comparator implementation. This especially matters when we switch to use secondary sort. In secondary sort, we convert the inner sort of nested foreach into the secondary key and rely on hadoop to sorting on both main key and secondary key. The sorting key will become a two items tuple. Since the secondary key the sorting key of the nested foreach, so the sorting semantics matters. It turns out we do not have binary comparator once we use secondary sort, and we see a significant slow down.&lt;/p&gt;

&lt;p&gt;Binary comparator for tuple should be doable once we understand the binary structure of the serialized tuple. We can focus on most common use cases first, which is &quot;group by&quot; followed by a nested sort. In this case, we will use secondary sort. Semantics of the first key does not matter but semantics of secondary key matters. We need to identify the boundary of main key and secondary key in the binary tuple buffer without instantiate tuple itself. Then if the first key equals, we use a binary comparator to compare secondary key. Secondary key can also be a complex data type, but for the first step, we focus on simple secondary key, which is the most common use case.&lt;/p&gt;

&lt;p&gt;We mark this issue to be a candidate project for &quot;Google summer of code 2010&quot; program. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12458995">PIG-1295</key>
            <summary>Binary comparator for secondary sort</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="azaroth">Gianmarco De Francisci Morales</assignee>
                                    <reporter username="daijy">Daniel Dai</reporter>
                        <labels>
                            <label>gsoc</label>
                            <label>mentor</label>
                    </labels>
                <created>Sat, 13 Mar 2010 00:47:27 +0000</created>
                <updated>Fri, 17 Dec 2010 22:43:20 +0000</updated>
                            <resolved>Mon, 16 Aug 2010 09:01:42 +0100</resolved>
                                    <version>0.7.0</version>
                                    <fixVersion>0.8.0</fixVersion>
                                    <component>impl</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="12848809" author="azaroth" created="Tue, 23 Mar 2010 17:14:37 +0000"  >&lt;p&gt;Avro provides efficient binary comparison for tuples with generic schemas.&lt;br/&gt;
A simple way to implement this would be to adapt Pig to use Avro for intermediate files.&lt;br/&gt;
This would allow to use generic schemas for keys and solve the genral problem in an efficient and elegant way.&lt;/p&gt;

&lt;p&gt;I would be glad to give it a try.&lt;/p&gt;</comment>
                            <comment id="12849315" author="daijy" created="Wed, 24 Mar 2010 17:55:38 +0000"  >&lt;p&gt;Hi, Gianmarco,&lt;br/&gt;
Thank you for your interest. Avro is one thing we definitely want to try. We have some previous work on Avro (&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-794&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;PIG-794&lt;/a&gt;), but we haven&apos;t actively working on it for a while. The previous implementation might not be very right, and it is based on an very old version of Avro, and finally we did not include it into Pig codebase. We will be very happy if you want to try it again, and we would recommend you to build it from scratch. We are very interested to see the performance and additional gains provided by Avro. &lt;/p&gt;</comment>
                            <comment id="12849645" author="azaroth" created="Thu, 25 Mar 2010 10:08:51 +0000"  >&lt;p&gt;I will start to look at the documentation and source code of both Pig and Avro to get a rough idea of the work to do.&lt;br/&gt;
Maybe having a look at the old patch would be good to identify the points in the source code where changes are needed?&lt;/p&gt;

&lt;p&gt;Where can I discuss this issue and ideas to solve it? mailing list? irc?&lt;br/&gt;
Do you have any other suggestion?&lt;/p&gt;</comment>
                            <comment id="12849730" author="dvryaboy" created="Thu, 25 Mar 2010 15:42:43 +0000"  >&lt;p&gt;Gianmarco, the ticket for Avro loader (&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-794&quot; title=&quot;Use Avro serialization in Pig&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-794&quot;&gt;PIG-794&lt;/a&gt;) is where you would discuss this.  The old patch can be more or less discarded &amp;#8211; the whole loader interface changed recently to make this sort of thing much easier and more powerful &amp;#8211; but it&apos;s the issue folks who are interested in this are tracking.&lt;/p&gt;</comment>
                            <comment id="12849817" author="daijy" created="Thu, 25 Mar 2010 18:23:24 +0000"  >&lt;p&gt;Hi, Gianmarco,&lt;br/&gt;
Mailing list and Jira should be a good place to discuss your ideas. Dmitriy is right, we should discuss Avro issues in &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-794&quot; title=&quot;Use Avro serialization in Pig&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-794&quot;&gt;PIG-794&lt;/a&gt;. If you are talking about &quot;Google Summer of Code&quot;, Avro is definitely a candidate project for you to work. &lt;/p&gt;</comment>
                            <comment id="12851453" author="azaroth" created="Tue, 30 Mar 2010 17:22:54 +0100"  >&lt;p&gt;Hi, &lt;br/&gt;
I have been reading the source code and the referenced &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1038&quot; title=&quot;Optimize nested distinct/sort to use secondary key&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1038&quot;&gt;&lt;del&gt;PIG-1038&lt;/del&gt;&lt;/a&gt; issue. &lt;/p&gt;

&lt;p&gt;Probably Avro integration is too big of a project for GSoC, but implementing the tuple binary comparator seems doable. &lt;br/&gt;
I will write a proposal, any advices for it? &lt;/p&gt;

&lt;p&gt;My idea of the project&apos;s breakdown would be like this: &lt;/p&gt;

&lt;p&gt;Identify the cases that can be optimized and the appropriate visitor for those. &lt;br/&gt;
Write a test unit for this optimization. &lt;br/&gt;
Implement the comparator knowing the data types of the tuple. &lt;br/&gt;
Write a second test unit with different types. &lt;br/&gt;
Write the logic to extract tuple boundary from schema information (I suppose this optimization is possible only if the schema is known) &lt;br/&gt;
Try to extend it to the general case of complex data type as secondary key. &lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="12851736" author="daijy" created="Wed, 31 Mar 2010 07:08:24 +0100"  >&lt;p&gt;Thanks Gianmarco,&lt;br/&gt;
My suggestion is to divide it into two step:&lt;br/&gt;
1. make binary comparator works&lt;br/&gt;
2. integrate it into the current Pig code&lt;/p&gt;

&lt;p&gt;It is better to make sure we have quality deliverable for step 1 before we move to step 2.&lt;/p&gt;</comment>
                            <comment id="12854607" author="azaroth" created="Wed, 7 Apr 2010 18:21:06 +0100"  >&lt;p&gt;I have drafted my proposal at &lt;br/&gt;
&lt;a href=&quot;http://socghop.appspot.com/gsoc/student_proposal/show/google/gsoc2010/azaroth/t127030843242&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://socghop.appspot.com/gsoc/student_proposal/show/google/gsoc2010/azaroth/t127030843242&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Any feedback is more than welcome.&lt;/p&gt;</comment>
                            <comment id="12854649" author="daijy" created="Wed, 7 Apr 2010 20:07:48 +0100"  >&lt;p&gt;Thanks Gianmarco, &lt;br/&gt;
Proposal looks good. Besides unit test, we need to add some performance test in both phase 1 and phase 2.&lt;/p&gt;</comment>
                            <comment id="12876030" author="azaroth" created="Sun, 6 Jun 2010 10:52:51 +0100"  >&lt;p&gt;Here is my frist dratf for the binary comparator, together with some simple tests.&lt;/p&gt;

&lt;p&gt;This comparator should replace PigTupleRawComparator.&lt;/p&gt;

&lt;p&gt;I assume that the tuple we are comparing is a NullableTuple that wraps a DefaultTuple.&lt;br/&gt;
There is a comment in the old comparator that says:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Users are allowed to implement their own versions of tuples, which means we have no
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// idea what the underlying representation is.&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This will need to be addressed. If I can know that the tuple is not a DefaultTuple looking at its data type byte, I can switch back to object deserialization. This means that the user must not use the same DataType.TUPLE as the default tuple.&lt;/p&gt;

&lt;p&gt;The comparator iterates over the serialized tuples and compares them following the same logic as the old comparator (first check if Null, then their sizes, then compare field by field, if the fields are of different types compare the datatypes, else compare the values).&lt;br/&gt;
For now I implemented the logic only for simple types, I plan to add bytearrays and chararrays. I do not plan to add support for complex datatypes. In this case I will fall back to object deserialization.&lt;/p&gt;

&lt;p&gt;The implementation uses a ByteBuffer to easily iterate over the values. I don&apos;t know if it is acceptable or its performance impact but it is very handy. The alternative is manual bookkeeping of a cursor inside the byte arrays.&lt;br/&gt;
To do this I would probably use a map that tells me how many bytes each data type uses. This map should probably go somewhere else though (DataType? DataReaderWriter?). I commented out an initial attempt for this at the end of the class.&lt;br/&gt;
An alternative implementation could be to follow the strategy of the others PigRawComparators, that wrap a comparator from Hadoop. This would require keeping a number of comparators in memory, though. I commented out this approach at the beginning of the class.&lt;/p&gt;

&lt;p&gt;TODO:&lt;br/&gt;
Implement fallback behaviour.&lt;br/&gt;
Implement support for bytearrays and chararrays.&lt;br/&gt;
Graceful handling of tuples different from DefaultTuple.&lt;br/&gt;
Add performance tests.&lt;/p&gt;

&lt;p&gt;Any comment is more than welcome.&lt;/p&gt;</comment>
                            <comment id="12876354" author="daijy" created="Mon, 7 Jun 2010 19:30:31 +0100"  >&lt;p&gt;I briefly review the patch, looks good. This is the approach we expected. Can we do some initial performance test first? &lt;/p&gt;</comment>
                            <comment id="12876444" author="azaroth" created="Mon, 7 Jun 2010 23:10:51 +0100"  >&lt;p&gt;I added some simple performance tests.&lt;br/&gt;
The tests generate 1 million tuples modifying a prototypical tuple and compare them to the prototype.&lt;br/&gt;
One test uses the new comparator and the other uses the old one. I generate exactly the same tuples using a fixed seed. I also check the correctness of the comparisons using the normal compareTo() method of the tuples.&lt;/p&gt;

&lt;p&gt;The logic to generate the tuples is a bit involved: I tried to exercise all the datatype comparisons in a uniform manner, so I mutate less the first elements of the tuple, in order to have more probability of getting the comparison further down the tuple. The probabilities are totally made up and do not make much sense.&lt;/p&gt;

&lt;p&gt;As a first approximation, I see a slight overall speedup in the test.&lt;br/&gt;
I will do some profiling to see which margins of improvement we have.&lt;/p&gt;</comment>
                            <comment id="12878120" author="azaroth" created="Fri, 11 Jun 2010 23:49:52 +0100"  >&lt;p&gt;I did some more detailed profiling and testing. I ran a slightly modified version of the performance tests in the patch.&lt;br/&gt;
On my machine, the new comparator takes between 8 and 10 seconds. The old one between 11 and 14.&lt;br/&gt;
The performance advantage is not so big, but I found also that most of the time of the test is not spent comparting.&lt;br/&gt;
The profiler shows that most of the time is spent in cloning (probably JUnit internals?):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [junit]  84.0%     0  +  1769    java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.clone
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For what concerns user code instead, most of the time is spent writing data. Randomization of the input also takes some time.&lt;br/&gt;
The old comparator takes (0.9% + 0.3% | compareTuple + compare) more than 1% of the time. The new one takes only 0.2% of the time.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   [junit]   2.9%    62  +     0    org.apache.pig.data.DataReaderWriter.writeDatum
    [junit]   1.1%    23  +     0    java.io.DataOutputStream.writeInt
    [junit]   0.9%    19  +     0    java.util.Random.next
    [junit]   0.9%    18  +     0    java.io.DataOutputStream.writeLong
    [junit]   0.9%    18  +     0    org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigTupleRawComparator.compareTuple
    [junit]   0.6%    11  +     1    org.apache.pig.data.DataReaderWriter.readDatum
    [junit]   0.5%    11  +     0    java.io.DataInputStream.readInt
    [junit]   0.5%    11  +     0    org.apache.pig.data.DefaultTuple.readFields
    [junit]   0.3%     7  +     0    org.apache.pig.impl.io.PigNullableWritable.write
    [junit]   0.3%     7  +     0    org.apache.pig.data.DefaultTuple.&amp;lt;init&amp;gt;
    [junit]   0.3%     3  +     3    org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigTupleRawComparator.compare
    [junit]   0.2%     5  +     0    java.util.ArrayList.get
    [junit]   0.2%     5  +     0    org.apache.pig.data.DefaultTuple.write
    [junit]   0.2%     3  +     2    org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigTupleRawComparatorNew.compare
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All in all, these tests are probably not much representative, but I also feel that the speedup we may get with a raw comparator is somewhat limited.&lt;br/&gt;
I am open to suggestion on how to modify the performance tests to make them more representative.&lt;/p&gt;</comment>
                            <comment id="12878127" author="daijy" created="Sat, 12 Jun 2010 00:06:55 +0100"  >&lt;p&gt;&quot;the new comparator takes between 8 and 10 seconds. The old one between 11 and 14&quot;, that is a 137% or 140% speedup. That&apos;s significant enough for us to go forward. &lt;/p&gt;</comment>
                            <comment id="12878130" author="daijy" created="Sat, 12 Jun 2010 00:12:04 +0100"  >&lt;p&gt;Can you also attach performance test code? I want to take a look. Thanks.&lt;/p&gt;</comment>
                            <comment id="12878247" author="azaroth" created="Sat, 12 Jun 2010 11:41:56 +0100"  >&lt;p&gt;Sure,&lt;br/&gt;
here it is the revised file.&lt;br/&gt;
I left the random testing for unit testing purposes, and I moved the performance testing to a separate main method.&lt;br/&gt;
This makes profiling &lt;b&gt;much&lt;/b&gt; easier.&lt;/p&gt;

&lt;p&gt;FYI, for profiling I am using a mixture of hprof (the java internal profiler) and jrat (&lt;a href=&quot;http://jrat.sourceforge.net&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jrat.sourceforge.net&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;I can prepare a more detailed report of where most of the time is consumed, if needed.&lt;br/&gt;
Roughly, 80% of the test time is spent in the org.apache.pig.data package to write tuples (DefaultTuple.write() , DataReaderWriter.writeDatum() , DataType.findType() are the most expensive methods).&lt;br/&gt;
From targeted profiling I have seen that the raw version of the compare method is around 3x faster than the old one.&lt;/p&gt;</comment>
                            <comment id="12879576" author="daijy" created="Thu, 17 Jun 2010 00:12:13 +0100"  >&lt;p&gt;I run your main problem. It also counts the tuple bytes generation time, which dominate the cpu profile. I run it in another way, generate the bytes first and don&apos;t include in the timing, and then compare the bytes using different comparator, Here is my code snippet:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[][] toCompare1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[TIMES][];
&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[][] toCompare2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[TIMES][];
NullableTuple t;
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=0;i&amp;lt;TIMES;i++) {
    t = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NullableTuple(test.getRandomTuple(rand));
    t.write(test.dos1);
    toCompare1[i] = test.baos1.toByteArray();
}
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=0;i&amp;lt;TIMES;i++) {
    t = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NullableTuple(test.getRandomTuple(rand));
    t.write(test.dos2);
    toCompare2[i] = test.baos2.toByteArray();
}

before = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; loop = 0; loop &amp;lt; 10000; loop++) {
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; TIMES; i++) {
        test.comparator.compare(toCompare1[i], 0, toCompare1[i].length, toCompare2[i], 0, toCompare2[i].length);
    }
}
after = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();

before = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; loop = 0; loop &amp;lt; 10000; loop++) {
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; TIMES; i++) {
        test.oldComparator.compare(toCompare1[i], 0, toCompare1[i].length, toCompare2[i], 0, toCompare2[i].length);
    }
}
after = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this comparison, I see 6.5 times speedup.&lt;/p&gt;

&lt;p&gt;Also notice the code style for Apache is always use space instead of tab, make sure you take care of this.&lt;/p&gt;</comment>
                            <comment id="12879920" author="azaroth" created="Thu, 17 Jun 2010 21:35:42 +0100"  >&lt;p&gt;I modified the main in order to include your code snippet. Thanks very much for the suggestion!&lt;/p&gt;

&lt;p&gt;I reduced the number of tuples in order to avoid OutOfMemory exceptions on my machine (only 1 GiB of RAM). I see the same numbers you reported: 6.5 times improve in speed only for the compare() method.&lt;/p&gt;

&lt;p&gt;I took care of the tabs issue.&lt;/p&gt;

&lt;p&gt;I will add support for ByteArrays and CharArrays next, together with fallback behaviour for complex datatypes.&lt;/p&gt;</comment>
                            <comment id="12882956" author="azaroth" created="Sun, 27 Jun 2010 14:59:14 +0100"  >&lt;p&gt;Added support for BYTEARRAY and CHARARRAY data types.&lt;br/&gt;
Added fallback behaviour for unknown data types.&lt;br/&gt;
Added support for non-raw comparison.&lt;/p&gt;

&lt;p&gt;I changed to public the visibility of a the charset field in DataType, because I need to know which encoding is being used for strings.&lt;/p&gt;

&lt;p&gt;I am testing the patch locally before submitting it.&lt;/p&gt;

&lt;p&gt;Given that performance tests look good, I think the next step would be to handle tuples different from DefaultTuple. This requires some changes to the infrastructure.&lt;/p&gt;</comment>
                            <comment id="12883031" author="daijy" created="Mon, 28 Jun 2010 06:22:44 +0100"  >&lt;p&gt;Hi, Gianmarco,&lt;br/&gt;
I think we can stick on DefaultTuple which is the major use case. I doubt there is a way to do a binary compare for an unknown tuple implementation. If user do not use DefaultTuple then we fall back to the deserialize version.&lt;/p&gt;</comment>
                            <comment id="12883339" author="azaroth" created="Mon, 28 Jun 2010 23:51:37 +0100"  >&lt;p&gt;Ok, if the user does not use DefaultTuple we fall back to the default deserialization case.&lt;/p&gt;

&lt;p&gt;I added handling of nested tuples via recursion and appropriate unit tests.&lt;/p&gt;</comment>
                            <comment id="12883361" author="daijy" created="Tue, 29 Jun 2010 01:07:23 +0100"  >&lt;p&gt;Thanks, is the patch ready for review?&lt;/p&gt;</comment>
                            <comment id="12883367" author="azaroth" created="Tue, 29 Jun 2010 01:30:56 +0100"  >&lt;p&gt;I think it is&lt;/p&gt;</comment>
                            <comment id="12883486" author="hadoopqa" created="Tue, 29 Jun 2010 10:37:21 +0100"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12448251/PIG-1295_0.6.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12448251/PIG-1295_0.6.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision 958666.&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 6 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    -1 javac.  The applied patch generated 150 javac compiler warnings (more than the trunk&apos;s current 145 warnings).&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs warnings.&lt;/p&gt;

&lt;p&gt;    -1 release audit.  The applied patch generated 402 release audit warnings (more than the trunk&apos;s current 399 warnings).&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    -1 contrib tests.  The patch failed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/testReport/&lt;/a&gt;&lt;br/&gt;
Release audit warnings: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/artifact/trunk/patchprocess/releaseAuditDiffWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/artifact/trunk/patchprocess/releaseAuditDiffWarnings.txt&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/355/console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="12884259" author="azaroth" created="Thu, 1 Jul 2010 13:22:57 +0100"  >&lt;p&gt;Addressed a small bug and added ASF license to source files&lt;/p&gt;</comment>
                            <comment id="12885626" author="daijy" created="Tue, 6 Jul 2010 19:20:46 +0100"  >&lt;p&gt;Patch looks good, one comment: Where is the code &quot;if the user does not use DefaultTuple we fall back to the default deserialization case&quot;?&lt;/p&gt;</comment>
                            <comment id="12885831" author="thejas" created="Wed, 7 Jul 2010 06:25:21 +0100"  >&lt;p&gt;1.  If utf8 encoded ordering is same as java string compareTo ordering (i could not find a quick answer), it will possible to compare the strings by just comparing the bytes , instead of  creating additional string objects.&lt;br/&gt;
2. The comparison does not handle chararrays &amp;gt; 65k in length, ie when BIGCHARARRAY is used as the type in encoding. This is a problem even in existing pig code.&lt;br/&gt;
3. The comparison function is based on the DefaultTuple serialization format, we need to make sure that it gets used only when DefaultTuple is the default tuple. I am making changes to use a new tuple with different serialization format in &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; title=&quot;Optimize serialization/deserialization between Map and Reduce and between MR jobs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1472&quot;&gt;&lt;del&gt;PIG-1472&lt;/del&gt;&lt;/a&gt; . I think we should have this comparison logic defined in the class/interface where the serialization format is defined. I think it should be part of the InterSedes interface in the patch in  &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; title=&quot;Optimize serialization/deserialization between Map and Reduce and between MR jobs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1472&quot;&gt;&lt;del&gt;PIG-1472&lt;/del&gt;&lt;/a&gt; . &lt;/p&gt;</comment>
                            <comment id="12887190" author="azaroth" created="Sun, 11 Jul 2010 13:37:54 +0100"  >&lt;p&gt;I added the code for &quot;if the user does not use DefaultTuple we fall back to the default deserialization case&quot;. I assume the user defined tuple will have a different DataType byte from DataType.TUPLE. If this is not the case, I see no way of discerning DefaultTuple from any other Tuple implementation.&lt;br/&gt;
Anyway, I think this issue needs to be properly addressed in the context of &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;PIG-1472&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I added support for BIGCHARARRAY.&lt;/p&gt;

&lt;p&gt;UTF-8 decoding is quite convoluted. It is a variable length encoding, so we cannot avoid using a String. &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;UTF-8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Before tackling the integration with &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;PIG-1472&lt;/a&gt; I need to familiarize with the code in the patch. I will write a proposal for the integration in the next days.&lt;/p&gt;

&lt;p&gt;I also made some changes to DataByteArray in order to encapsulate the logic for comparison in a publicly accessible method. This way the raw comparison is consistent with the behavior of the class, in a way similar to the other cases where I delegate comparison to the class.&lt;/p&gt;</comment>
                            <comment id="12887270" author="daijy" created="Mon, 12 Jul 2010 05:59:02 +0100"  >&lt;p&gt;With the change of &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; title=&quot;Optimize serialization/deserialization between Map and Reduce and between MR jobs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1472&quot;&gt;&lt;del&gt;PIG-1472&lt;/del&gt;&lt;/a&gt;, we need to change raw comparator accordingly:&lt;br/&gt;
1. Bag comparison should be changed to compare TINYBAG/SMALLBAG/BAG&lt;br/&gt;
2. Tuple comparison should be changed to compare TINYTUPLE/SMALLTUPLE/TUPLE&lt;br/&gt;
3. Map comparison should be changed to compare TINYMAP/SMALLMAP/MAP&lt;br/&gt;
4. Integer comparison should be changed to compare INTEGER_0/INTEGER_1/INTEGER_INBYTE/INTEGER_INSHORT/INTEGER&lt;br/&gt;
5. ByteArray comparison should be changed to compare TINYBYTEARRAY/SMALLBYTEARRAY/BYTEARRAY&lt;br/&gt;
6. Chararray comparison should be changed to compare SMALLCHARARRAY/CHARARRAY&lt;br/&gt;
7. Raw comparator is now depend on the serialization format. Now we have two serialization format, DefaultTuple and BinSedesTuple. It&apos;s better to move PigTupleRawComparatorNew inside BinSedesTuple. But in this project, we only focus on BinSedesTuple, which addres most use cases&lt;/p&gt;

&lt;p&gt;In the integration code, we shall check if TupleFactory is actually BinSedesTupleFactory, if it is, use this raw comparator; otherwise, use the original comparator. &lt;/p&gt;

&lt;p&gt;I was wrong for the customized tuple. we do not need a fall back scheme for customized tuple. In the serialized format, all Tuples including customized Tuple will be serialized into the same format. &lt;/p&gt;

&lt;p&gt;Looks like UTF-8 encoding is convoluted, we can leave it for now.&lt;/p&gt;</comment>
                            <comment id="12887420" author="daijy" created="Mon, 12 Jul 2010 18:05:31 +0100"  >&lt;p&gt;More clarification for custom Tuple. There two cases for custom tuple:&lt;br/&gt;
1. User create custom tuple inside UDF. In this case, we do not have a special serialized format for custom tuple. After serialization, we cannot tell if it is a custom tuple. That is say, we lose track of tuple implementation after se/des. Since serialized format is the same, we can still use the same raw comparator.&lt;br/&gt;
2. If user use a custom tuple factory (by overriding &quot;pig.data.tuple.factory.name&quot;), then serialized format may be changed. If we detect that tuple factory is not BinSedesTupleFactory, we shall not use this raw comparator.&lt;/p&gt;</comment>
                            <comment id="12888495" author="azaroth" created="Wed, 14 Jul 2010 20:10:38 +0100"  >&lt;p&gt;I have studied &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; title=&quot;Optimize serialization/deserialization between Map and Reduce and between MR jobs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1472&quot;&gt;&lt;del&gt;PIG-1472&lt;/del&gt;&lt;/a&gt; a bit.&lt;br/&gt;
My idea is as follows:&lt;br/&gt;
1) write a new method &quot;CompareBinSedesTuple&quot; that uses the new serialization format. The method will look like the one for default tuples that already exists.&lt;/p&gt;

&lt;p&gt;2) in the entry point compare(), assess which TupleFactory we are actually using (using instanceof or checking the &quot;pig.data.tuple.factory.name&quot; property). If it is the DefaultTupleFactory, or the BinSedesTupleFactory, use the appropriate raw comparison method, otherwise resort to deserialization&lt;/p&gt;

&lt;p&gt;3) actually, I would think the best place for the comparators is inside each TupleFactory. We can later split the comparator in two classes and put them in the appropriate TupleFactory implementation. We will have to add a getRawComparatorClass to the TupleFactory abstract class and modify the code that instantiates the comparator to take the class name from the TupleFactory.&lt;br/&gt;
(I am not sure of this design, I am guessing on many details).&lt;/p&gt;</comment>
                            <comment id="12888517" author="thejas" created="Wed, 14 Jul 2010 21:15:55 +0100"  >&lt;p&gt;This sounds fine. In case of BinSedesTupleFactory/BinSedesTuple the serialization code is in the subclass (BinInterSedes) of InterSedes class. Since the comparator function is closely tied to serlialization logic, i think that would be the appropriate place  to have the comparator implementation code. The BinSedesTupleFactory can return the class obtained from InterSedesFactory.getInterSedesInstance().&lt;/p&gt;
</comment>
                            <comment id="12888529" author="daijy" created="Wed, 14 Jul 2010 21:49:55 +0100"  >&lt;p&gt;If &quot;pig.data.tuple.factory.name&quot; is BinSedesTupleFactory, we should use your raw comparator. DefaultTupleFactory is a minor case, we can use deserialization.&lt;/p&gt;</comment>
                            <comment id="12889231" author="azaroth" created="Fri, 16 Jul 2010 18:18:15 +0100"  >&lt;p&gt;In DataType the type bytes are sorted in such a way that the comparison between different data types yields a standard order. This is achieved by carefully assigning the byte values to the types.&lt;br/&gt;
In BinInterSedes this does not happen. So, to reproduce the same order, I need to sort the bytes somehow. The easiest way is to reassign the values in a way that is coherent with DataType. The hard way would be to implement a comparison method with all the possible combinations taken into account, but this is crazy to maintain.&lt;br/&gt;
I have also the same problem for costants: because for INTEGER_0/1 and BOOLEAN_TRUE/FALSE there is no value to read, and the two data type bytes are different, with the current design I need to ensure that BOOLEAN_TRUE &amp;gt; BOOLEAN_FALSE and INTEGER_1 &amp;gt; INTEGER_0.&lt;br/&gt;
Furthermore, It would be good to sort the byte types so that INTEGER &amp;gt; INTEGER_INSHORT &amp;gt; INTEGER_INBYTE etc...&lt;/p&gt;</comment>
                            <comment id="12889236" author="daijy" created="Fri, 16 Jul 2010 18:28:43 +0100"  >&lt;p&gt;Hi, Gianmarco,&lt;br/&gt;
I think it&apos;s better not to assume INTEGER &amp;gt; INTEGER_INSHORT. What type tells you is how to read the next data correctly. So if you see a INTEGER_INSHORT, read INTEGER_INSHORT into an integer, so you can compare with other integer type correctly.&lt;/p&gt;</comment>
                            <comment id="12889334" author="azaroth" created="Fri, 16 Jul 2010 22:22:36 +0100"  >&lt;p&gt;To follow a backwards compatible behaviour I should group all the integers (for example) into the same case statement and then implement all the logic there (if it is INTEGER_0/1 do not read anything, if it is INTEGER_INBYTE read a byte, etc...).&lt;br/&gt;
So in each case statement I would need to compare each data type with its siblings, implement the logic to tell which one sorts first, then if the other data type is not a sibling, impose the global sorting.&lt;br/&gt;
This will result in some quite convoluted code compared to the actual patch, because I will not be able to compare data types directly.&lt;br/&gt;
Is this the desired behaviour?&lt;/p&gt;</comment>
                            <comment id="12889368" author="daijy" created="Fri, 16 Jul 2010 23:24:09 +0100"  >&lt;p&gt;We need to compare a category of data type, not data type itself. For example:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (bt1==INTEGER_0||bt1==INTEGER_1||bt1==INTEGER_INBYTE||bt1==INTEGER_INSHORT||bt1==INTEGER) {
    type1 = INTEGER;
    value1 = readInteger(bt1);
}
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (bt2==INTEGER_0||bt2==INTEGER_1||bt2==INTEGER_INBYTE||bt2==INTEGER_INSHORT||bt2==INTEGER) {
    type2 = INTEGER;
    value2 = readInteger(bt1);
}
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (type1==type2)
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (value1 &amp;lt; value2 ? -1 : (value1 == value2 ? 0 : 1));
&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; dt1-dt2;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12889485" author="azaroth" created="Sat, 17 Jul 2010 11:16:30 +0100"  >&lt;p&gt;Implemented a new compareBinInterSedesTuple() method.&lt;br/&gt;
This new method works with data serialized with &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1472&quot; title=&quot;Optimize serialization/deserialization between Map and Reduce and between MR jobs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1472&quot;&gt;&lt;del&gt;PIG-1472&lt;/del&gt;&lt;/a&gt; format.&lt;br/&gt;
It relies on DataType for data type comparison by translating the data types.&lt;br/&gt;
I implemented some logic to read unsinged ints from bytes and shorts because I am using ByteBuffer that does not implement the DataInput interface. We might want to change that later.&lt;br/&gt;
For now complex data types cause the whole tuple to be deserialized, but I have put some placeholders for methods to deserialize single complex objects and continue the normal execution flow.&lt;br/&gt;
I plan to fill them in when I move the code inside BinInterSedes so that I can use the methods to read complex data types (readBag, readMap, etc..). This will involve some juggling around between DataInputBuffer and ByteBuffer (this is why we might consider to switch out ByteBuffer) to get the cursors consistent among them.&lt;/p&gt;

&lt;p&gt;I think the next step would be splitting the comparator and putting it into the serialization class (BinInterSedes). I don&apos;t know yet how to modify the class interface to make the comparator class available outside (but I think this relates to phase 2).&lt;/p&gt;

&lt;p&gt;I see no good place to put the class that implements the comparator for DefaultTuple, and Daniel said it is a minor case, so should I just throw away the code for DefaultTuple?&lt;/p&gt;</comment>
                            <comment id="12889510" author="azaroth" created="Sat, 17 Jul 2010 15:57:43 +0100"  >&lt;p&gt;I modified the comparator to be fully recursive for arbitrarily nested data.&lt;br/&gt;
There is a bit of code duplication for the fallback behaviour, I plan to clean that up later.&lt;/p&gt;

&lt;p&gt;I use InterSedes.readDatum() to read complex types.&lt;br/&gt;
I had to modify the readWritable() method in order to return a WritableComparable. I think it should have been this way from the beginning looking at DataType.compare and given that is is dealing with a GENERIC_WRITABLECOMPARABLE as the constant says.&lt;/p&gt;

&lt;p&gt;I found there is no implementation of a compareTo() method for InternalMaps, nor in the class nor in DataType, so I commented that out.&lt;/p&gt;

&lt;p&gt;I added some tests for complex data types.&lt;/p&gt;

&lt;p&gt;I think this could be the final revision for phase 1, before I move the code into BinInterSedes.&lt;/p&gt;</comment>
                            <comment id="12890384" author="daijy" created="Tue, 20 Jul 2010 19:51:37 +0100"  >&lt;p&gt;Patch looks pretty good. Thanks Gianmarco! Couple of comments:&lt;br/&gt;
1. PigTupleRawComparatorNew:324,332,343,357,367,377,387,399,416,474,483,501,512,etc, if GeneralizedDataType is not equal, we should throw exception to contain the error&lt;br/&gt;
2. PigTupleRawComparatorNew:455-464, if the comparison of two items is not equal, we shall return the result without comparing additional items, that&apos;s how we get performance gain&lt;br/&gt;
3. I am unable to run TestPigTupleRawComparator.main due to OOM, what is the speed up after the change?&lt;br/&gt;
4. PigTupleRawComparatorNew:132, we shall move the logic of choosing the right comparator to Pig code, and move comparator into BinSedesTuple and DefaultTuple. This is part of integration work and let&apos;s mark it as the first thing for phase 2.&lt;/p&gt;</comment>
                            <comment id="12892417" author="azaroth" created="Mon, 26 Jul 2010 20:10:00 +0100"  >&lt;p&gt;Thanks, here my observations:&lt;/p&gt;

&lt;p&gt;1. If you look at the old comparator, it uses DataType.compare(). In DataType:454-458 if the two data types are not equal, the value returned is the difference between the datatypes. I retained the same behavior in the patch.&lt;br/&gt;
2. I think we already do that. There is an additional guard in the for loop, that goes on only if rc == 0 on line 452&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; tsz1 &amp;amp;&amp;amp; rc == 0; i++) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;3. Yes, I somehow changed the number of tuples without noticing. I got back to 10e3 and I see a 10x improvement in time now&lt;br/&gt;
4. Sure!&lt;/p&gt;</comment>
                            <comment id="12892454" author="daijy" created="Mon, 26 Jul 2010 21:42:46 +0100"  >&lt;p&gt;Good. I will commit the patch. Let&apos;s start with integration&lt;/p&gt;</comment>
                            <comment id="12894302" author="azaroth" created="Sat, 31 Jul 2010 17:52:58 +0100"  >&lt;p&gt;Here my first stab at integration.&lt;br/&gt;
I split the class in two classes and put them into DefaultTuple and BinInterSedes.&lt;br/&gt;
This asymmetry is not nice but the serialization code is in different places for different tuples, and I wanted to keep the comparison code as close as possible to the serialization code.&lt;/p&gt;

&lt;p&gt;I modified the TupleFactory interface adding a method to get the tuple comparator class.&lt;br/&gt;
This method is implemented in BinSedesTupleFactory and overridden in DefaultTupleFactory.&lt;/p&gt;

&lt;p&gt;BinSedesTupleFactory delegates it to a package method in BinInterSedes (where the actual code is).&lt;br/&gt;
DefaultTupleFactoru delegates it to DefaultTuple (where the actual code is).&lt;/p&gt;

&lt;p&gt;The actual code for both comparators is just a cut/paste of the methods in PigTupleRawComparatorNew, I just adjusted a bit the entry points.&lt;/p&gt;

&lt;p&gt;I left the new comparator and tests untouched for now.&lt;/p&gt;

&lt;p&gt;Please let me have any comments you may have.&lt;/p&gt;</comment>
                            <comment id="12894382" author="azaroth" created="Sun, 1 Aug 2010 14:29:28 +0100"  >&lt;p&gt;I have some problems understanding the SecondaryKeyOptimizer.&lt;/p&gt;

&lt;p&gt;For example, given this query:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

A = LOAD &apos;input1&apos; AS (a0,a1,a2);
B = LOAD &apos;input2&apos; AS (b0,b1,b2);
C = cogroup A by (a0,a1), B by (b0,b1) parallel 2;
D = foreach C { E = limit A 10; F = E.a2; G = DISTINCT F; generate group, COUNT(G);};

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The key type is correctly recognized to be a tuple, the so.getNumMRUseSecondaryKey() is 1, but when I get to JobControlCompiler mro.getUseSecondaryKey() is false.&lt;/p&gt;

&lt;p&gt;Then, when it chooses the comparator in selectComparator(), hasOrderBy , which is (mro.isGlobalSort() || mro.isLimitAfterSort() || mro.usingTypedComparator()) , is false.&lt;/p&gt;

&lt;p&gt;So I get into the second switch statement and I get these comparators&lt;/p&gt;

&lt;p&gt;        case DataType.TUPLE:&lt;br/&gt;
            job.setSortComparatorClass(PigTupleWritableComparator.class);&lt;br/&gt;
            job.setGroupingComparatorClass(PigGroupingTupleWritableComparator.class);&lt;/p&gt;

&lt;p&gt;that, to me, look like they are already comparing tuples in raw format (they use WritableComparator.compareBytes).&lt;/p&gt;

&lt;p&gt;Is this because the query is one in which order semantics do not matter, so it is already optimized?&lt;br/&gt;
Should it change if I add an ORDER BY somewhere before the LIMIT?&lt;br/&gt;
Is this the relevant case we want to optimize?&lt;/p&gt;</comment>
                            <comment id="12894841" author="daijy" created="Tue, 3 Aug 2010 09:02:30 +0100"  >&lt;p&gt;Hi, Gianmarco,&lt;br/&gt;
When you do an explain, you will see &quot;Secondary sort: true&quot; if the MR plan will use secondary sort. I am not yet sure why your script not using secondary sort, I will check it tomorrow. However, the following script will use secondary sort:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
A = LOAD &apos;1.txt&apos; AS (a0, a1, a2);
B = group A by $0 parallel 2;
C = foreach B { D = limit A 10; E = order D by $1; generate group, E;};
explain C;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When secondary sort is used, Pig will use PigSecondaryKeyComparator, which is not actually raw. We need to replace it with your raw comparator. &lt;/p&gt;</comment>
                            <comment id="12894961" author="azaroth" created="Tue, 3 Aug 2010 19:00:41 +0100"  >&lt;p&gt;Thanks for the suggestion Daniel.&lt;/p&gt;

&lt;p&gt;My idea to integrate the RawTupleComparator is to modify PigSecondaryKeyComparator to delegate the comparison to it. I cannot mimic the current behavior of making 2 calls (one for the main and one for the secondary key) because I do not know the boundaries between the keys. So I need to make a single call to compare the compound key. There are some issues though.&lt;/p&gt;

&lt;p&gt;1) There are some inconsistencies between the behavior of PigTupleRawComparator (the original one) and PigSecondaryKeyComparator.&lt;br/&gt;
Specifically, when tuples are null the first one returns 0 while the second one compares the indexes.&lt;br/&gt;
Furthermore, indexes are compared also when one of the fields in the tuples is null, in order not to join them (if I understood correctly &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-927&quot; title=&quot;null should be handled consistently in Join&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-927&quot;&gt;&lt;del&gt;PIG-927&lt;/del&gt;&lt;/a&gt;). This is done in PigSecondaryKeyComparator but not in PigTupleRawComparator.&lt;br/&gt;
Is it designed to be like this or is it a bug?&lt;br/&gt;
I suppose the behaviors of the two comparators should be more or less the same.&lt;/p&gt;

&lt;p&gt;2) In PigSecondaryKeyComparator the key is assumed to be a 2-field tuple where the 0th field is the main key and the 1st field is the secondary key.&lt;br/&gt;
We can directly feed the binary representation of this tuple inside our new raw comparator, but we need to consolidate the sort orders. Right now there are 2 different and independent sort orders serialized in the jobConf (pig.sortOrder and pig.secondarySortOrder). In the simple case, when sort orders for all the columns are specified, we can just concatenate them together (sort of). There are some problems when we have WholeTuple sort orders as they might differ. &lt;br/&gt;
I would like to keep all of this out of the tuple comparator and define some clean interface to pass the sort orders.  One problem I see is that I probably need the tuple sizes (recursively) to do this, and this is not known at configuration time. I also need to fix this in the current comparator, in order to take into account the recursion inside nested tuples.&lt;/p&gt;

&lt;p&gt;3) Should I keep all the mIndex/mNull handling outside the RawTupleComparator and write wrappers that deal with them?&lt;br/&gt;
That is, should the RawTupleComparator know how to deal with a NullableTuple or should it just know its kind of Tuple (BinInterSedes or Default)&lt;/p&gt;</comment>
                            <comment id="12895093" author="daijy" created="Wed, 4 Aug 2010 01:03:17 +0100"  >&lt;p&gt;Hi, Gianmarco,&lt;br/&gt;
1. Notice currently PigTupleRawComparator is only used in &quot;order-by&quot; job, PigSecondaryKeyComparator only used by &quot;non-order-by&quot; job, there is a semantic difference in null handling. In order-by, different null key are treated equal; In group-by, however, null from different relation cannot merge (this is to conform with SQL standard). In your case, RawTupleComparator can be used in both &quot;order-by tuple&quot; case and &quot;non-order-by&quot; with secondary key case. So there will be semantic gap between this two. We need to deal with it separately. For simplicity, we can focus on secondary key case first (which means, different null keys from different relations are not equal)&lt;/p&gt;

&lt;p&gt;2. We need to deal with sort order. When we use PigTupleRawComparator for secondary sort, it&apos;s quite clear the structure will be (main_key, secondary_key, value). I think we can limit PigTupleRawComparator specific to this structure currently (don&apos;t think about order-by tuple case), so you can pass the sort order and deal with it in PigTupleRawComparator&lt;/p&gt;

&lt;p&gt;3. Yes, I think it might be better to keep mIndex/mNull handling outside RawTupleComparator&lt;/p&gt;</comment>
                            <comment id="12895346" author="azaroth" created="Wed, 4 Aug 2010 19:10:15 +0100"  >&lt;p&gt;Ok, first working integration.&lt;br/&gt;
Modified PigTupleRawComparatorNew to use the raw comparators via TupleFactory.&lt;br/&gt;
Created a new class PigSecondaryKeyComparatorNew that should substitute the old one. This one uses the raw comparators.&lt;br/&gt;
Modified JobControlCompiler to use the new comparators.&lt;/p&gt;

&lt;p&gt;Moved the null/index semantic outside the raw comparators and inside the wrappers.&lt;/p&gt;

&lt;p&gt;Modified BinSedesTupleComparator to correctly handle sort order. The sort order is applied to the first call to compare tuples. In case we are doing a secondary sort, the sort orders are propagated 1 level more (because we have a nested tuple with the keys, and we need to apply the sort orders to the content of the outermost tuple).&lt;br/&gt;
The code is not the cleanest possible but TestPigTupleRawComparator and TestSecondarySort pass.&lt;/p&gt;

&lt;p&gt;TODO:&lt;br/&gt;
Implement the logic for &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-927&quot; title=&quot;null should be handled consistently in Join&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-927&quot;&gt;&lt;del&gt;PIG-927&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
I plan to create a new interface (TupleRawComparator) and add a method to check if during the comparison a field of type NULL was encountered. This interface will be used instead of the simple RawComparator to hold the reference to our raw comparators.&lt;/p&gt;

&lt;p&gt;Write speed test.&lt;br/&gt;
Is there something already made that can be used to test the speed improvement? The inputs for the unit test are of course too small.&lt;/p&gt;</comment>
                            <comment id="12896173" author="azaroth" created="Fri, 6 Aug 2010 23:18:40 +0100"  >&lt;p&gt;Fixed issues for &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-927&quot; title=&quot;null should be handled consistently in Join&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-927&quot;&gt;&lt;del&gt;PIG-927&lt;/del&gt;&lt;/a&gt; as planned.&lt;br/&gt;
Fixed a couple of bugs that came up with testing.&lt;br/&gt;
Aligned the code path for the deserialization version.&lt;br/&gt;
Ran full test suite, all tests pass.&lt;/p&gt;

&lt;p&gt;TODO:&lt;br/&gt;
Align code for DefaultTuple (low priority).&lt;br/&gt;
Speed tests.&lt;/p&gt;</comment>
                            <comment id="12896339" author="azaroth" created="Sun, 8 Aug 2010 11:27:13 +0100"  >&lt;p&gt;I performed a some speed tests using PigMix2.&lt;br/&gt;
I used query L16 and generated 2 datasets: one with 1M rows (1.6GiB) and the other with 10M rows (16GiB).&lt;br/&gt;
I took the times end to end using the &quot;time&quot; utility.&lt;br/&gt;
I do not have a cluster so I ran pig locally.&lt;br/&gt;
Here the results.&lt;/p&gt;

&lt;p&gt;Trunk		1M		0m53.469s&lt;br/&gt;
Patched		1M		0m39.076s&lt;br/&gt;
Trunk		10M	9m49.507s&lt;br/&gt;
Patched		10M	8m0.048s&lt;/p&gt;

&lt;p&gt;We have a 20~30% improvement end-to-end for this query.&lt;br/&gt;
I think this is consistent with the expectations.&lt;/p&gt;</comment>
                            <comment id="12896390" author="daijy" created="Sun, 8 Aug 2010 19:07:42 +0100"  >&lt;p&gt;That is terrific! I will review your patch shortly. &lt;/p&gt;</comment>
                            <comment id="12897850" author="daijy" created="Thu, 12 Aug 2010 18:26:31 +0100"  >&lt;p&gt;I reviewed and regenerate the patch. Couple of notes:&lt;br/&gt;
1. All unit test and end-to-end test pass, hudson warning are addressed&lt;br/&gt;
2. See consistent performance improvement (around 20%) in pigmix query L16 (using 10 reducers, on a cluster of 10 nodes)&lt;br/&gt;
3. Did some refactory, change some class names and move some code around, move getRawComparatorClass to Tuple instead of TupleFactory&lt;/p&gt;

&lt;p&gt;Gianmarco, can you take a look if my changes are good?&lt;/p&gt;</comment>
                            <comment id="12897922" author="thejas" created="Thu, 12 Aug 2010 20:48:53 +0100"  >&lt;p&gt;Comments about &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1295&quot; title=&quot;Binary comparator for secondary sort&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1295&quot;&gt;&lt;del&gt;PIG-1295&lt;/del&gt;&lt;/a&gt;_0.14.patch -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The comparison logic for BinInterSedes relies on the serliazation format, so it think its better to have it closer to where the serialization format is implemented. Ie add a function to InterSedes interface (getComparator() ?) , and move the implementation logic to BinInterSedes class.&lt;/li&gt;
	&lt;li&gt;I think TupleFactory is a better place for getRawComparatorClass() for the following reasons-
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;TupleFactory is a singleton class, Tuple is not. Having it in Tuple implies that you can have different values returned by different instances.&lt;/li&gt;
		&lt;li&gt;Adding it to Tuple interface breaks backward compatibility, all Tuple implementations will need to add this function. Also, does not make sense for load functions that return a custom tuple to implement this method, because it is not related to that tuple implementation.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12897949" author="daijy" created="Thu, 12 Aug 2010 22:08:23 +0100"  >&lt;p&gt;Response to Thejas:&lt;br/&gt;
1. Yes, you are right. I will put another layer of abstraction for InterSedes.getRawComparatorClass&lt;br/&gt;
2. Conceptually comparator is in the logic of Tuple. Ideally it should be a static method of Tuple, however Tuple interface do not allow me do that. But even this I still feel it&apos;s better to put it in Tuple. For backward compatibility, first, we will break either Tuple or TupleFactory, the impact is equivalent; second, in both PigSecondaryKeyComparator and PigTupleSortComparator, we will check if Tuple does not implement the new method, we fall back to the default serialize version. Thoughts?&lt;/p&gt;</comment>
                            <comment id="12897958" author="thejas" created="Thu, 12 Aug 2010 22:48:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;Conceptually comparator is in the logic of Tuple. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This comparator is part of only the &lt;b&gt;default&lt;/b&gt; tuple implementation used internally within pig. So the class that is the source of truth for the default internal tuple implementation seems a good place to have this function. A tuple returned by a loadfunction has nothing to do with the comparator logic. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Ideally it should be a static method of Tuple, however Tuple interface do not allow me do that.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, a static method can&apos;t be overridden. Since this is supposed to return only one value per pig query, the singleton TupleFactory is a better place.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For backward compatibility, first, we will break either Tuple or TupleFactory, the impact is equivalent;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No. TupleFactory is an abstract class, while Tuple is an interface. Users will not be forced to change their implementation if we add a function to TupleFactory. Also, users are more likely to have custom Tuple than custom TupleFactory - because they might implement different tuples as part of their load function implementation, and are unlikely to change the default Tuple implementation used in internally in pig.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;second, in both PigSecondaryKeyComparator and PigTupleSortComparator, we will check if Tuple does not implement the new method, we fall back to the default serialize version. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If Tuple interface is going to have this function, i think we should add in the javadoc that it makes sense to implement the function only if it is going to be used as the default internal tuple implementation. And that&lt;br/&gt;
null value can be returned if user chooses to not implement it.&lt;/p&gt;
</comment>
                            <comment id="12898014" author="daijy" created="Fri, 13 Aug 2010 01:10:48 +0100"  >&lt;p&gt;Attach another patch to address Thejas&apos;s first point. &lt;/p&gt;</comment>
                            <comment id="12898167" author="azaroth" created="Fri, 13 Aug 2010 11:02:21 +0100"  >&lt;p&gt;My 2 cents on the issue.&lt;/p&gt;

&lt;p&gt;1) I agree with Thejas that comparator logic is strictly tied to serialization, so they should be as close as possible.&lt;/p&gt;

&lt;p&gt;2) I agree that comparator is something related to Tuple, but Tuple is an interface and this complicates things. Putting the method to access the comparator in TupleFactory seems more natural to me, as the Factory and the Tuple implementation are anyway strongly tied.&lt;br/&gt;
I don&apos;t like to have to create a (useless) Tuple in order to get to the comparator class.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;? &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; TupleRawComparator&amp;gt; mComparatorClass = TupleFactory.getInstance().newTuple().getRawComparatorClass();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Other minor things:&lt;/p&gt;

&lt;p&gt;In PigSecondaryKeyComparator@54&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (mComparator==&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                mComparator = PigTupleDefaultRawComparator.class.newInstance();
            } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InstantiationException e) {
                &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(e);
            } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (IllegalAccessException e) {
                &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(e);
            }
        }
        ((Configurable)mComparator).setConf(jconf);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We can directly instantiate the class instead of using reflection here. Furthermore, there is no need to cast mComparator to Configurable.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
       &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (mComparator==&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) 
                mComparator = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; PigTupleDefaultRawComparator();
        mComparator.setConf(jconf);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

</comment>
                            <comment id="12898449" author="daijy" created="Fri, 13 Aug 2010 23:37:59 +0100"  >&lt;p&gt;Discuss with Alan, we agree to put getRawComparator into TupleFactory. Attach &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1295&quot; title=&quot;Binary comparator for secondary sort&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1295&quot;&gt;&lt;del&gt;PIG-1295&lt;/del&gt;&lt;/a&gt;_0.16.patch. &lt;/p&gt;</comment>
                            <comment id="12898818" author="daijy" created="Mon, 16 Aug 2010 09:01:41 +0100"  >&lt;p&gt;All unit test pass. &lt;/p&gt;

&lt;p&gt;test-patch:&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; -1 overall.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 @author.  The patch does not contain any @author tags.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 tests included.  The patch appears to include 8 new or modified tests.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     -1 javac.  The applied patch generated 156 javac compiler warnings (more than the trunk&apos;s current 145 warnings).&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 findbugs.  The patch does not introduce any new Findbugs warnings.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     -1 release audit.  The applied patch generated 414 release audit warnings (more than the trunk&apos;s current 410 warnings).&lt;/p&gt;

&lt;p&gt;javac warnings is all about deprecate. For release audit warnings, I checked every new file have license header.&lt;/p&gt;

&lt;p&gt;Patch committed. Thanks Gianmarco!&lt;/p&gt;</comment>
                            <comment id="12898845" author="azaroth" created="Mon, 16 Aug 2010 11:01:27 +0100"  >&lt;p&gt;Thanks for your support Daniel.&lt;br/&gt;
It was a great experience.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12438759">PIG-1038</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12446437" name="PIG-1295_0.1.patch" size="10004" author="azaroth" created="Sun, 6 Jun 2010 10:52:51 +0100"/>
                            <attachment id="12449758" name="PIG-1295_0.10.patch" size="60723" author="azaroth" created="Sat, 17 Jul 2010 15:57:43 +0100"/>
                            <attachment id="12450964" name="PIG-1295_0.11.patch" size="88455" author="azaroth" created="Sat, 31 Jul 2010 17:52:58 +0100"/>
                            <attachment id="12451243" name="PIG-1295_0.12.patch" size="133713" author="azaroth" created="Wed, 4 Aug 2010 19:10:15 +0100"/>
                            <attachment id="12451470" name="PIG-1295_0.13.patch" size="155419" author="azaroth" created="Fri, 6 Aug 2010 23:18:40 +0100"/>
                            <attachment id="12451928" name="PIG-1295_0.14.patch" size="170914" author="daijy" created="Thu, 12 Aug 2010 18:26:30 +0100"/>
                            <attachment id="12451973" name="PIG-1295_0.15.patch" size="171890" author="daijy" created="Fri, 13 Aug 2010 01:10:48 +0100"/>
                            <attachment id="12452066" name="PIG-1295_0.16.patch" size="170829" author="daijy" created="Fri, 13 Aug 2010 23:37:58 +0100"/>
                            <attachment id="12446534" name="PIG-1295_0.2.patch" size="11849" author="azaroth" created="Mon, 7 Jun 2010 23:10:51 +0100"/>
                            <attachment id="12446952" name="PIG-1295_0.3.patch" size="12876" author="azaroth" created="Sat, 12 Jun 2010 11:41:56 +0100"/>
                            <attachment id="12447382" name="PIG-1295_0.4.patch" size="13868" author="azaroth" created="Thu, 17 Jun 2010 21:35:42 +0100"/>
                            <attachment id="12448158" name="PIG-1295_0.5.patch" size="21519" author="azaroth" created="Sun, 27 Jun 2010 14:59:14 +0100"/>
                            <attachment id="12448251" name="PIG-1295_0.6.patch" size="31759" author="azaroth" created="Mon, 28 Jun 2010 23:51:37 +0100"/>
                            <attachment id="12448491" name="PIG-1295_0.7.patch" size="33430" author="azaroth" created="Thu, 1 Jul 2010 13:22:57 +0100"/>
                            <attachment id="12449186" name="PIG-1295_0.8.patch" size="36717" author="azaroth" created="Sun, 11 Jul 2010 13:37:54 +0100"/>
                            <attachment id="12449751" name="PIG-1295_0.9.patch" size="56539" author="azaroth" created="Sat, 17 Jul 2010 11:16:30 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 23 Mar 2010 17:14:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>164798</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyaot3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>96330</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>