<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:02:49 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/PIG-2293/PIG-2293.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[PIG-2293] Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.</title>
                <link>https://issues.apache.org/jira/browse/PIG-2293</link>
                <project id="12310730" key="PIG">Pig</project>
                    <description>&lt;p&gt;The existing PIG merge join has the following limitations:&lt;br/&gt;
   1. It assumes the right side of the table must be accessed sequentially - record by record.&lt;br/&gt;
   2. It does not perform well against large, sparse tables.&lt;/p&gt;

&lt;p&gt;The current implementation of the merge join introduced the interface IndexableLoadFunc.  This &apos;LoadFunc&apos;&lt;br/&gt;
supports the ability to &apos;seekNear&apos; a given key (before reading the next record).  &lt;br/&gt;
The merge join physical operator only calls &apos;seekNear&apos; for the first key in each split (effectively eliminating splits&lt;br/&gt;
where the first and subsequent keys will not be found).  Subsequent joins are found by reading sequentially through&lt;br/&gt;
the records on the right table looking for matches from the left table.&lt;/p&gt;

&lt;p&gt;While this method works well for dense join tables - it performs poorly against large sparse tables or data sources that support &lt;br/&gt;
point lookups natively (HBase for example).&lt;/p&gt;

&lt;p&gt;The proposed enhancement is to add a new join type - &apos;merge-sparse&apos; to PIG latin.  When specified in the PIG script, this join type&lt;br/&gt;
will cause the merge join operator to call seekNear on each and every key (rather than just the first in each split).&lt;/p&gt;





</description>
                <environment></environment>
        <key id="12523613">PIG-2293</key>
            <summary>Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="aklish">Aaron Klish</assignee>
                                    <reporter username="aklish">Aaron Klish</reporter>
                        <labels>
                    </labels>
                <created>Mon, 19 Sep 2011 21:17:21 +0100</created>
                <updated>Thu, 26 Apr 2012 21:33:10 +0100</updated>
                            <resolved>Mon, 10 Oct 2011 03:58:17 +0100</resolved>
                                    <version>0.9.0</version>
                                    <fixVersion>0.10.0</fixVersion>
                                    <component>impl</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                    <timeoriginalestimate seconds="1209600">336h</timeoriginalestimate>
                            <timeestimate seconds="1209600">336h</timeestimate>
                                        <comments>
                            <comment id="13108113" author="dvryaboy" created="Mon, 19 Sep 2011 21:24:54 +0100"  >&lt;p&gt;At that point it stops being a merge join, doesn&apos;t it?&lt;/p&gt;</comment>
                            <comment id="13108132" author="aklish" created="Mon, 19 Sep 2011 21:49:38 +0100"  >&lt;p&gt;I guess that would depend on the manner in which it was used.&lt;/p&gt;

&lt;p&gt;The primary use case I am concerned about is the large, sparse table stored in HDFS.&lt;br/&gt;
In this scenario, the right side is still sorted, and access is still sequential.&lt;/p&gt;

&lt;p&gt;However, the access is sequential point lookups - rather than sequential block reads - which will perform better.&lt;/p&gt;


</comment>
                            <comment id="13108142" author="daijy" created="Mon, 19 Sep 2011 22:03:13 +0100"  >&lt;p&gt;I discussed with Aaron about this. This is a variation of merge join, it optimize merge join query in the case right side table is sparse. Implementation wise, it puts a flag in POMergeJoin to indicate that, so POMergeJoin can optimize this case accordingly. &lt;/p&gt;</comment>
                            <comment id="13108194" author="dvryaboy" created="Mon, 19 Sep 2011 23:33:52 +0100"  >&lt;p&gt;I&apos;ve observed very large performance differences between doing HBase point lookups on a large chunk of the table, and doing scans (even when the scan throws out most of the data). It&apos;d be great to have some hard numbers on % of skipped data for which this makes sense to do for both HDFS and HBase.&lt;/p&gt;</comment>
                            <comment id="13108199" author="aklish" created="Mon, 19 Sep 2011 23:45:40 +0100"  >&lt;p&gt;Submitted on behalf of third-party: Yahoo! Inc. (Author: Paresh Goswami)&lt;/p&gt;

&lt;p&gt;I will be providing an additional patch which will bring the changes more inline with the suggested approach in the JIRA (perhaps in a different JIRA)&lt;/p&gt;</comment>
                            <comment id="13108213" author="dvryaboy" created="Tue, 20 Sep 2011 00:08:03 +0100"  >&lt;p&gt;IndexedStorage.java does not have apache header.. we need a way to (officially) ensure Y! and Paresh are ok with the license.&lt;/p&gt;</comment>
                            <comment id="13108225" author="daijy" created="Tue, 20 Sep 2011 00:19:17 +0100"  >&lt;p&gt;Aaron, please post patch on this Jira. You will need to make the following changes in your new patch:&lt;br/&gt;
1. Use a new join type &quot;merge-sparse&quot; instead of the IndexedStorage&lt;br/&gt;
2. The LoadFunc not seems to be very general, better move to piggybank&lt;br/&gt;
3. As Dmitriy said, need to add license header in every source code file&lt;/p&gt;</comment>
                            <comment id="13108860" author="sms" created="Tue, 20 Sep 2011 18:52:31 +0100"  >&lt;p&gt;Daniel, for point 1, I am assuming that a new join type merge-spare (changes to parser, etc.) is favored over a specific implementation (IndexedStorage) ?&lt;/p&gt;</comment>
                            <comment id="13109304" author="daijy" created="Wed, 21 Sep 2011 07:49:33 +0100"  >&lt;p&gt;Yes, this is essentially a new join type to the user, though implementation wise, it only does minor change to the regular merge join.&lt;/p&gt;</comment>
                            <comment id="13115087" author="aklish" created="Tue, 27 Sep 2011 01:54:52 +0100"  >&lt;p&gt;Here is the latest version with the comments (hopefully) addressed.&lt;/p&gt;</comment>
                            <comment id="13115130" author="aklish" created="Tue, 27 Sep 2011 03:06:56 +0100"  >&lt;p&gt;E2E framework test cases to be submitted by Daniel.&lt;/p&gt;</comment>
                            <comment id="13115685" author="aklish" created="Tue, 27 Sep 2011 17:27:37 +0100"  >&lt;p&gt;Test cases to integrate into e2e framework.&lt;/p&gt;</comment>
                            <comment id="13116895" author="daijy" created="Thu, 29 Sep 2011 00:23:39 +0100"  >&lt;p&gt;Patch in general looks good. There is one test failure MergeSparseJoin_5 and I fixed in the patch. Also I removed the document change, and will put that in release notes (this is how we usually do it)&lt;/p&gt;</comment>
                            <comment id="13116908" author="olgan" created="Thu, 29 Sep 2011 01:08:14 +0100"  >&lt;p&gt;Daniel, thanks for your help! Is anything else needed from Aaron or the patch is ready to go in?&lt;/p&gt;</comment>
                            <comment id="13117048" author="daijy" created="Thu, 29 Sep 2011 07:35:15 +0100"  >&lt;p&gt;I am running the test and will commit it once tests pass. &lt;/p&gt;</comment>
                            <comment id="13117681" author="daijy" created="Thu, 29 Sep 2011 23:34:44 +0100"  >&lt;p&gt;A second look of the patch, I would like to fix these issues:&lt;br/&gt;
1. POMergeJoin.getNextRightInp(): joinType == LOJoin.JOINTYPE.MERGESPARSE &amp;amp;&amp;amp; !(rightLoader instanceof DefaultIndexableLoader)&lt;br/&gt;
   Why should we care about DefaultIndexableLoader or not? Better to remove this check&lt;br/&gt;
2. Need to distinguish sparse merge join in explain&lt;br/&gt;
3. Better to collect sparse merge join as a separate feature&lt;/p&gt;

&lt;p&gt;I will submit another patch.&lt;/p&gt;</comment>
                            <comment id="13117773" author="daijy" created="Fri, 30 Sep 2011 01:22:42 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-2293&quot; title=&quot;Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-2293&quot;&gt;&lt;del&gt;PIG-2293&lt;/del&gt;&lt;/a&gt;-2.patch fixed the above mentioned issues.&lt;/p&gt;</comment>
                            <comment id="13117793" author="aklish" created="Fri, 30 Sep 2011 01:52:46 +0100"  >&lt;p&gt;If the right table does not implement IndexableLoadFunc, then PIG will create an Index of the table and set the loader to DefaultIndexableLoader.  This is fine for merge but not for merge-sparse (DefaultIndexableLoader cannot handle repeated calls to seekNear).  If the check below is too specific, then maybe an exception should be thrown elsewhere (perhaps where the logical plan is mapped to a physical).&lt;/p&gt;

&lt;p&gt;POMergeJoin.getNextRightInp(): joinType == LOJoin.JOINTYPE.MERGESPARSE &amp;amp;&amp;amp; !(rightLoader instanceof DefaultIndexableLoader)&lt;/p&gt;</comment>
                            <comment id="13118249" author="thejas" created="Fri, 30 Sep 2011 19:12:18 +0100"  >&lt;p&gt;Aaron,&lt;br/&gt;
Can you provide some any performance numbers of using merge-join and merge-join-sparse on sparse data ?&lt;br/&gt;
That will help people understand the value of this feature.&lt;/p&gt;

</comment>
                            <comment id="13118256" author="daijy" created="Fri, 30 Sep 2011 19:23:00 +0100"  >&lt;p&gt;I discussed with Ashutosh (the author of regular MergeJoin) and tried DefaultIndexableLoader. It works fine in merge-sparse join. We do need to remove the DefaultIndexableLoader restriction. It is very confusing if one loader supports merge-sparse and the other don&apos;t, even when both loader implemented the same interface.&lt;/p&gt;</comment>
                            <comment id="13118270" author="daijy" created="Fri, 30 Sep 2011 19:42:00 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-2293&quot; title=&quot;Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-2293&quot;&gt;&lt;del&gt;PIG-2293&lt;/del&gt;&lt;/a&gt;-3.patch fix unit tests.&lt;/p&gt;</comment>
                            <comment id="13118508" author="aklish" created="Fri, 30 Sep 2011 23:18:04 +0100"  >&lt;p&gt;Hmm,  I had tried DefaultIndexableLoader - and saw an infinite loop.&lt;/p&gt;

&lt;p&gt;I don&apos;t think it works.&lt;/p&gt;
</comment>
                            <comment id="13118531" author="daijy" created="Fri, 30 Sep 2011 23:36:39 +0100"  >&lt;p&gt;Can you post your script, and which infinite loop you saw?&lt;/p&gt;</comment>
                            <comment id="13118549" author="aklish" created="Sat, 1 Oct 2011 00:00:24 +0100"  >&lt;p&gt;Try this in local mode (This is not an infinite loop - I must have been mistaken about that).&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;klish@gwgd4008 pig_patch&amp;#93;&lt;/span&gt;$ cat a.txt&lt;br/&gt;
1       2       3&lt;br/&gt;
4       2       1&lt;br/&gt;
4       3       3&lt;br/&gt;
7       2       5&lt;br/&gt;
8       4       3&lt;br/&gt;
8       3       4&lt;br/&gt;
12      3       4&lt;br/&gt;
20      1       2&lt;br/&gt;
28      4       1&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;klish@gwgd4008 pig_patch&amp;#93;&lt;/span&gt;$ cat b.txt&lt;br/&gt;
1       3&lt;br/&gt;
2       7&lt;br/&gt;
2       9&lt;br/&gt;
2       4&lt;br/&gt;
4       6&lt;br/&gt;
4       9&lt;br/&gt;
8       9&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;klish@gwgd4008 pig_patch&amp;#93;&lt;/span&gt;$ cat index_join.pig&lt;br/&gt;
A = LOAD &apos;./a.txt&apos;  AS (a1:int, a2:int, a3:int);&lt;br/&gt;
B = LOAD &apos;./b.txt&apos;  AS (b1:int, b2:int);&lt;/p&gt;

&lt;p&gt;C = join A by a1, B by b1 USING &apos;merge-sparse&apos;;&lt;/p&gt;

&lt;p&gt;DUMP C;&lt;/p&gt;

&lt;p&gt;I get the following exception:&lt;/p&gt;

&lt;p&gt;org.apache.pig.backend.executionengine.ExecException: ERROR 1102: Data is not sorted on right side. Last two keys encountered were:&lt;br/&gt;
2&lt;br/&gt;
1&lt;br/&gt;
        at org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POMergeJoin.getNext(POMergeJoin.java:359)&lt;br/&gt;
        at org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigGenericMapBase.runPipeline(PigGenericMapBase.java:267)&lt;br/&gt;
        at org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigGenericMapBase.map(PigGenericMapBase.java:262)&lt;br/&gt;
        at org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigGenericMapBase.map(PigGenericMapBase.java:64)&lt;br/&gt;
        at org.apache.hadoop.mapreduce.Mapper.run(Mapper.java:144)&lt;br/&gt;
        at org.apache.hadoop.mapred.MapTask.runNewMapper(MapTask.java:764)&lt;br/&gt;
        at org.apache.hadoop.mapred.MapTask.run(MapTask.java:370)&lt;br/&gt;
        at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:212)&lt;/p&gt;</comment>
                            <comment id="13118550" author="aklish" created="Sat, 1 Oct 2011 00:03:18 +0100"  >&lt;p&gt;Hi Thejas,&lt;/p&gt;

&lt;p&gt;I will ask one of our engineers if he still has performance results from some tests we ran a few months back.&lt;/p&gt;

&lt;p&gt;We have a use case with very sparse data on the right side (about 20TB).&lt;/p&gt;

&lt;p&gt;The performance gain was significant (maybe 20X?).  If he doesn&apos;t have the numbers archived somewhere, we will probably run some similar tests in the coming weeks.&lt;/p&gt;</comment>
                            <comment id="13118558" author="thejas" created="Sat, 1 Oct 2011 00:07:00 +0100"  >&lt;p&gt;Aaron,&lt;br/&gt;
I think we need to give some guidance to users to when this feature should be used, ie how sparse should be the data ? &lt;br/&gt;
Should it be used when the smaller relation has less than 1% of keys in larger one ? or should it be less than 0.1% .. ?&lt;/p&gt;</comment>
                            <comment id="13118589" author="daijy" created="Sat, 1 Oct 2011 01:13:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;I get the following exception:&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, this is something I miss, thanks. I traced into the code, the cause is the way we detect unsorted data. After seekNear, we could reverse the read head to a previous location (This is &quot;Near&quot; means). In this case, merge join complain that right side is unsorted. But this is not a fundamental problem, we shall change unsorted data detection logic. I will attach a new patch.&lt;/p&gt;</comment>
                            <comment id="13118591" author="daijy" created="Sat, 1 Oct 2011 01:15:35 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-2293&quot; title=&quot;Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-2293&quot;&gt;&lt;del&gt;PIG-2293&lt;/del&gt;&lt;/a&gt;-4.patch fix above mentioned exception.&lt;/p&gt;</comment>
                            <comment id="13119496" author="aklish" created="Mon, 3 Oct 2011 19:53:40 +0100"  >&lt;p&gt;Hi Thejas,&lt;/p&gt;

&lt;p&gt;If you look at the release notes, I commented a bit on the guidance.  Basically though, I don&apos;t think any meaningful % can be given - because the performance depends on too many other factors.&lt;/p&gt;

&lt;p&gt;Users will have to try both methods.&lt;/p&gt;

&lt;p&gt;Aaron&lt;/p&gt;</comment>
                            <comment id="13119505" author="thejas" created="Mon, 3 Oct 2011 20:05:19 +0100"  >&lt;p&gt;Some ballpark numbers will be still be useful for users to understand if they should spend time on comparing with the two merge join options.&lt;br/&gt;
I think we can assume the use of the new load function introduced in this jira, and one string join key that looks like a user name key (average length around 10 chars ?). So the only remaining variable (of the 3 in release notes) would be the density of join keys in the right table. If can have few numbers by varying that, I think it will be very useful.&lt;/p&gt;</comment>
                            <comment id="13120268" author="aklish" created="Tue, 4 Oct 2011 17:43:20 +0100"  >&lt;p&gt;Hi Daniel,&lt;/p&gt;

&lt;p&gt;Unfortunately, there are still problems with this patch.  Here is an infinite loop scenario:&lt;/p&gt;

&lt;p&gt;Make a simple file called x:&lt;br/&gt;
for ((i=0;i&amp;lt;1000;i++)); do echo $i; done &amp;gt; x&lt;/p&gt;

&lt;p&gt;Make another file like z:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;klish@gwgd4007 pig_patch&amp;#93;&lt;/span&gt;$ cat z&lt;br/&gt;
1&lt;br/&gt;
999&lt;/p&gt;

&lt;p&gt;And a simple script like:&lt;br/&gt;
A = LOAD &apos;./z&apos;  AS (a1:int);&lt;br/&gt;
B = LOAD &apos;./x&apos;  AS (b1:int);&lt;/p&gt;

&lt;p&gt;C = join A by a1, B by b1 USING &apos;merge-sparse&apos;;&lt;/p&gt;

&lt;p&gt;DUMP C;&lt;/p&gt;

&lt;p&gt;If you look at the way DefaultIndexableLoader is written, it creates a new ReadToEndLoader for every call to seekNear.&lt;br/&gt;
It was never designed for multiple calls to seekNear.  Short of a some refactoring of this class, I don&apos;t see how allowing this &lt;br/&gt;
is a good idea.&lt;/p&gt;

&lt;p&gt;        loader = new ReadToEndLoader((LoadFunc)PigContext.instantiateFuncFromSpec(rightLoaderFuncSpec),&lt;br/&gt;
                conf, inpLocation, splitsToBeRead);&lt;/p&gt;</comment>
                            <comment id="13120304" author="daijy" created="Tue, 4 Oct 2011 18:32:20 +0100"  >&lt;p&gt;Hi, Aaron,&lt;br/&gt;
I don&apos;t particularly want to make DefaultIndexableLoader work. But I&apos;m trying to get rid of a separate LoadFunc Interface specific to merge-sparse join. I will take a look of your test case.&lt;/p&gt;</comment>
                            <comment id="13120365" author="daijy" created="Tue, 4 Oct 2011 19:31:52 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-2293&quot; title=&quot;Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-2293&quot;&gt;&lt;del&gt;PIG-2293&lt;/del&gt;&lt;/a&gt;-5.patch fix infinite loop.&lt;/p&gt;</comment>
                            <comment id="13120577" author="aklish" created="Wed, 5 Oct 2011 00:23:51 +0100"  >&lt;p&gt;Here is some performance data:&lt;/p&gt;

&lt;p&gt;merge-sparse (Using IndexedStorage)&lt;br/&gt;
------------&lt;br/&gt;
SLOTS_MILLIS_MAPS 1,711,722&lt;br/&gt;
HDFS_BYTES_READ 13,305,558,069&lt;br/&gt;
HDFS_BYTES_WRITTEN 485,765,545&lt;br/&gt;
Execution Time: (2mins, 46sec)&lt;/p&gt;

&lt;p&gt;merge (Using standard PigStorage)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;SLOTS_MILLIS_MAPS 3,633,465&lt;br/&gt;
HDFS_BYTES_READ 91,896,826,321&lt;br/&gt;
HDFS_BYTES_WRITTEN 485,765,545&lt;br/&gt;
Execution Time: (6mins, 53sec) This does not include the index phase.&lt;/p&gt;

&lt;p&gt;Left Table&lt;br/&gt;
131,540 Records&lt;/p&gt;

&lt;p&gt;Right Table&lt;br/&gt;
28,476,640 Records&lt;br/&gt;
90,549,549,781 bytes&lt;/p&gt;

&lt;p&gt;Join&lt;br/&gt;
96,174 Records&lt;/p&gt;

&lt;p&gt;The join key was 37 bytes.&lt;/p&gt;

&lt;p&gt;Sparseness by records: 0.34%&lt;br/&gt;
Sparseness by bytes:   0.0039%&lt;/p&gt;

&lt;p&gt;Other runs have similar data.&lt;/p&gt;</comment>
                            <comment id="13120578" author="aklish" created="Wed, 5 Oct 2011 00:24:46 +0100"  >&lt;p&gt;The runs were with 20 mappers with speculative execution enabled (8 additional mappers)&lt;/p&gt;</comment>
                            <comment id="13121389" author="aklish" created="Wed, 5 Oct 2011 20:31:46 +0100"  >&lt;p&gt;Hi Daniel,&lt;/p&gt;

&lt;p&gt;The performance of &apos;merge-sparse&apos; if the right table is indexed by PIG is awful (running for hours instead of minutes).&lt;/p&gt;

&lt;p&gt;I believe this is because of the implementation of DefaultIndexableLoader (each call to seekNear rereads the entire index).&lt;/p&gt;

&lt;p&gt;I don&apos;t think we should allow PIG to create an index if the right tables is not already indexable for merge-sparse joins.  Here is a patch to throw an exception in this case.&lt;/p&gt;</comment>
                            <comment id="13121536" author="olgan" created="Wed, 5 Oct 2011 23:14:18 +0100"  >&lt;p&gt;I don&apos;t think the code has been committed. Until that happens, please, do not close the JIRA&lt;/p&gt;</comment>
                            <comment id="13121541" author="aklish" created="Wed, 5 Oct 2011 23:19:48 +0100"  >&lt;p&gt;sorry - was an accident.&lt;/p&gt;</comment>
                            <comment id="13121587" author="daijy" created="Thu, 6 Oct 2011 00:24:14 +0100"  >&lt;p&gt;Aaron&apos;s patch &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-2293&quot; title=&quot;Pig should support a more efficient merge join against data sources that natively support point lookups or where the join is against large, sparse tables.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-2293&quot;&gt;&lt;del&gt;PIG-2293&lt;/del&gt;&lt;/a&gt;-6.patch.txt disable &quot;merge-sparse&quot; join if the right loader does not implement IndexableLoader. Though &quot;merge-sparse&quot; is totally doable in that case, but anyway it is not the focus of this Jira. Please put a comment explaining why this is disabled and what&apos;s the issue you saw, in case we explore this route in the future. &lt;/p&gt;</comment>
                            <comment id="13122006" author="aklish" created="Thu, 6 Oct 2011 16:29:53 +0100"  >&lt;p&gt;Latest patch with comment as requested.&lt;/p&gt;</comment>
                            <comment id="13123852" author="daijy" created="Mon, 10 Oct 2011 03:58:01 +0100"  >&lt;p&gt;All tests pass. Test-patch result:&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; -1 overall.  &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 @author.  The patch does not contain any @author tags.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 tests included.  The patch appears to include 12 new or modified tests.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     +1 findbugs.  The patch does not introduce any new Findbugs warnings.&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt; &lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;exec&amp;#93;&lt;/span&gt;     -1 release audit.  The applied patch generated 464 release audit warnings (more than the trunk&apos;s current 450 warnings).&lt;/p&gt;

&lt;p&gt;All new files have Apache header.&lt;/p&gt;

&lt;p&gt;Patch committed to trunk. Credit to Aaron, Paresh and Jakub!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12496946" name="PIG-2293-1.patch" size="63684" author="daijy" created="Thu, 29 Sep 2011 00:23:38 +0100"/>
                            <attachment id="12497095" name="PIG-2293-2.patch" size="67133" author="daijy" created="Fri, 30 Sep 2011 01:22:42 +0100"/>
                            <attachment id="12497198" name="PIG-2293-3.patch" size="67913" author="daijy" created="Fri, 30 Sep 2011 19:42:00 +0100"/>
                            <attachment id="12497248" name="PIG-2293-4.patch" size="67942" author="daijy" created="Sat, 1 Oct 2011 01:15:35 +0100"/>
                            <attachment id="12497678" name="PIG-2293-5.patch" size="68666" author="daijy" created="Tue, 4 Oct 2011 19:31:52 +0100"/>
                            <attachment id="12497874" name="PIG-2293-6.patch.txt" size="70145" author="aklish" created="Wed, 5 Oct 2011 20:31:46 +0100"/>
                            <attachment id="12498011" name="PIG-2293-7.patch" size="70597" author="aklish" created="Thu, 6 Oct 2011 16:29:52 +0100"/>
                            <attachment id="12496760" name="e2e_test.txt" size="10036" author="aklish" created="Tue, 27 Sep 2011 17:27:37 +0100"/>
                            <attachment id="12496602" name="patch.txt" size="55826" author="aklish" created="Tue, 27 Sep 2011 01:54:52 +0100"/>
                            <attachment id="12495157" name="patch.txt" size="31061" author="aklish" created="Mon, 19 Sep 2011 23:45:40 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 19 Sep 2011 20:24:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8900</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12310041" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Patch Info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10042"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyawiv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>97580</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Overview&lt;br/&gt;
--------&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;* This patch adds a new join type, &amp;#39;merge-sparse&amp;#39; to PIG.&lt;br/&gt;
&amp;nbsp;* This patch adds a new &amp;#39;IndexedStorage&amp;#39; UDF to piggybank. &lt;br/&gt;
&lt;br/&gt;
&amp;#39;merge-sparse&amp;#39; join operator&lt;br/&gt;
-----------------------------&lt;br/&gt;
&lt;br/&gt;
The new functionality is similar to the existing &amp;#39;merge&amp;#39; join in the following ways:&lt;br/&gt;
&amp;nbsp;* It expects the input to be sorted in both the left and right tables.&lt;br/&gt;
&amp;nbsp;* The join can be accomplished as a map-only merge of the left and right tables.&lt;br/&gt;
&lt;br/&gt;
The new functionality is different from the existing &amp;#39;merge&amp;#39; join in the following ways:&lt;br/&gt;
&amp;nbsp;* The performance characteristics of the join operations are different.&lt;br/&gt;
&amp;nbsp;* For every key in the left table, the join operator will seek to the corresponding key in the right table. &lt;br/&gt;
&amp;nbsp;* Unlike a &amp;#39;merge&amp;#39; join, PIG will not create an index of the right table if it is not already indexed.  The right table loader &amp;gt;must&amp;lt; implement IndexableLoadFunc.  The feature is disabled for &amp;#39;merge-sparse&amp;#39; joins because the implementation of the DefaultIndexableLoader was not designed for multiple seeks.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
The existing &amp;#39;merge&amp;#39; join implementation only seeks to the first key from each input split of the left table.&lt;br/&gt;
It performs similar to a table scan with the optimization to skip records that belong to other input splits.&lt;br/&gt;
This implementation performs best when the join is dense.  In this case, scanning block by block will be &lt;br/&gt;
efficient because of the likelihood of finding matches in many of the scanned blocks.&lt;br/&gt;
&lt;br/&gt;
The new &amp;#39;merge-sparse&amp;#39; join implementation performs best when the join is sparse and the right table&lt;br/&gt;
implements an efficient seek operation (typically, the right table should be indexed by the join keys).&lt;br/&gt;
In this case, the additional overhead of per record seeks is less than the IO &amp;amp; processing &lt;br/&gt;
overhead of a partial table scan.&lt;br/&gt;
&lt;br/&gt;
The performance tradeoff between the two methods depends on a number of factors:&lt;br/&gt;
&amp;nbsp;* The density of matching join keys in the right table.&lt;br/&gt;
&amp;nbsp;* The overhead/efficiency of the seek operator implementation of the right loader.  &lt;br/&gt;
&amp;nbsp;* The size and number of keys in the index.&lt;br/&gt;
&lt;br/&gt;
Finding the exact performance inflection point will require trial and error for each data set and implementation of the right loader.&lt;br/&gt;
&lt;br/&gt;
See the performance data below for guidance on when to use this operator.&lt;br/&gt;
&lt;br/&gt;
IndexedStorage UDF&lt;br/&gt;
------------------&lt;br/&gt;
&lt;br/&gt;
IndexedStorage is a form of PigStorage that supports a per record seek.  &lt;br/&gt;
IndexedStorage creates a separate (hidden) index file for&lt;br/&gt;
every data file that is written.  The format of the index file is:&lt;br/&gt;
| Header     |&lt;br/&gt;
| Index Body |&lt;br/&gt;
| Footer     |&lt;br/&gt;
The Header contains the list of record indices (field numbers) that represent index keys.&lt;br/&gt;
The Index Body contains a PIG Tuple for each record in the data.  &lt;br/&gt;
The fields of the Tuple are:&lt;br/&gt;
&amp;nbsp;* The index key(s) as a PIG Tuple &lt;br/&gt;
&amp;nbsp;* The number of records that share this index key. &lt;br/&gt;
&amp;nbsp;* Offset into the data file to read the first matching record. &lt;br/&gt;
The Footer contains sequentially:&lt;br/&gt;
&amp;nbsp;* The smallest key(s) Tuple in the index. &lt;br/&gt;
&amp;nbsp;* The largest key(s) Tuple in the index. &lt;br/&gt;
&amp;nbsp;* The offset in bytes to the start of the footer. &lt;br/&gt;
&lt;br/&gt;
IndexedStorage implements IndexableLoadFunc and&lt;br/&gt;
can be used as the &amp;#39;right table&amp;#39; in a PIG &amp;#39;merge&amp;#39; or &amp;#39;merge-sparse&amp;#39; join.&lt;br/&gt;
&lt;br/&gt;
IndexedStorage does not require the data to be partitioned by index key(s).  &lt;br/&gt;
However, each partition (separate index) must be &amp;gt;locally&amp;lt; sorted by the index key(s) &lt;br/&gt;
(partitions can contain overlapping ranges of keys).&lt;br/&gt;
&lt;br/&gt;
Performance&lt;br/&gt;
------------------&lt;br/&gt;
Here is some performance data:&lt;br/&gt;
&lt;br/&gt;
merge-sparse (Using IndexedStorage)&lt;br/&gt;
------------&lt;br/&gt;
SLOTS_MILLIS_MAPS 1,711,722&lt;br/&gt;
HDFS_BYTES_READ 13,305,558,069&lt;br/&gt;
HDFS_BYTES_WRITTEN 485,765,545&lt;br/&gt;
Execution Time: (2mins, 46sec)&lt;br/&gt;
&lt;br/&gt;
merge (Using standard PigStorage)&lt;br/&gt;
&lt;br/&gt;
SLOTS_MILLIS_MAPS 3,633,465&lt;br/&gt;
HDFS_BYTES_READ 91,896,826,321&lt;br/&gt;
HDFS_BYTES_WRITTEN 485,765,545&lt;br/&gt;
Execution Time: (6mins, 53sec) This does not include the index phase.&lt;br/&gt;
&lt;br/&gt;
Left Table&lt;br/&gt;
131,540 Records&lt;br/&gt;
&lt;br/&gt;
Right Table&lt;br/&gt;
28,476,640 Records&lt;br/&gt;
90,549,549,781 bytes&lt;br/&gt;
&lt;br/&gt;
Join&lt;br/&gt;
96,174 Records&lt;br/&gt;
&lt;br/&gt;
The join key was 37 bytes.&lt;br/&gt;
&lt;br/&gt;
Sparseness by records: 0.34%&lt;br/&gt;
Sparseness by bytes: 0.0039%&lt;br/&gt;
&lt;br/&gt;
Number of Mappers: 20&lt;br/&gt;
&lt;br/&gt;
Other runs have similar data.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>