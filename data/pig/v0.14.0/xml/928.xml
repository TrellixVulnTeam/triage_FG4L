<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:54:36 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/PIG-928/PIG-928.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[PIG-928] UDFs in scripting languages</title>
                <link>https://issues.apache.org/jira/browse/PIG-928</link>
                <project id="12310730" key="PIG">Pig</project>
                    <description>&lt;p&gt;It should be possible to write UDFs in scripting languages such as python, ruby, etc.  This frees users from needing to compile Java, generate a jar, etc.  It also opens Pig to programmers who prefer scripting languages over Java.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12433483">PIG-928</key>
            <summary>UDFs in scripting languages</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="aniket486">Aniket Mokashi</assignee>
                                    <reporter username="alangates">Alan Gates</reporter>
                        <labels>
                    </labels>
                <created>Wed, 19 Aug 2009 17:52:01 +0100</created>
                <updated>Sun, 9 Oct 2011 21:59:58 +0100</updated>
                            <resolved>Mon, 26 Jul 2010 17:55:46 +0100</resolved>
                                                    <fixVersion>0.8.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>14</watches>
                                                                <comments>
                            <comment id="12745138" author="alangates" created="Wed, 19 Aug 2009 18:22:52 +0100"  >&lt;p&gt;Attaching some preliminary work by Kishore Gopalakrishna on this.  This code is a good start, but not ready for inclusion.  It needs to be cleaned up, put in our class structure, etc.  &lt;/p&gt;

&lt;p&gt;Comments from Kishore:&lt;/p&gt;

&lt;p&gt;It contains all the libraries required and also the GenericEval UDF and&lt;br/&gt;
GenericFilter UDF&lt;/p&gt;

&lt;p&gt;I dint get a chance to get the Algebraic function working.&lt;/p&gt;

&lt;p&gt;To test it, just unzip the package and run&lt;/p&gt;

&lt;p&gt;rm -rf wordcount/output;&lt;br/&gt;
pig -x local wordcount.pig ---&amp;gt; to test eval&lt;br/&gt;
pig -x local wordcount_filter.pig ---&amp;gt; to test filter [sorry it should&lt;br/&gt;
be named filter.pig]&lt;br/&gt;
cat wordcount/output&lt;/p&gt;</comment>
                            <comment id="12765860" author="alangates" created="Thu, 15 Oct 2009 02:58:48 +0100"  >&lt;p&gt;Questions that we need to answer to get this patch ready for commit:&lt;/p&gt;

&lt;p&gt;1) How do we do type conversion?  The current patch assumes a single string input and output.  We&apos;ll want to be able to do conversions from scripting languages to pig types that make sense.  How this can be done is tied up with #2 below.&lt;/p&gt;

&lt;p&gt;2) Do we do this using the Bean Scripting Framework or with specific bindings for each language?  This patch shows how to do the specific bindings for Groovy.  It can be done for Jython, and I&apos;m reasonably sure it can be done for JRuby.  The obvious advantage of using the BSF is we get all the languages they support for free.  We need to understand the performance costs of each choice.  We should be able to use the existing patch to test the difference between using the BSF and direct Groovy bindings.  Also, it seems like type conversions will be much easier to do if we use specific bindings, as we can do explicit type mappings for each language.  Perhaps this is possible with BSF, but I&apos;m not sure how.&lt;/p&gt;

&lt;p&gt;3) Grammer for how to declare these.  I propose that we allow two options:  inlined in define and file referenced in define.  So these would roughly look like:&lt;/p&gt;

&lt;p&gt;define myudf ScriptUDF(&apos;groovy&apos;, &apos;return input.get(0).split();&apos;);&lt;br/&gt;
define myudf ScriptUDF(&apos;python&apos;, myudf.py);&lt;/p&gt;

&lt;p&gt;We could also support inlining in the Pig Latin itself, something like:&lt;/p&gt;

&lt;p&gt;B = foreach A generate &lt;/p&gt;
{&apos;groovy&apos;, &apos;return input.get(0).split();&apos;);}
&lt;p&gt;;&lt;/p&gt;

&lt;p&gt;I&apos;m not a fan of this type of inlining, as I think it makes the code hard to read.&lt;/p&gt;</comment>
                            <comment id="12766746" author="alangates" created="Fri, 16 Oct 2009 23:28:48 +0100"  >&lt;p&gt;I ran some quick and sloppy performance tests on this.  I ran it using both BSF and direct bindings to groovy.  I also ran it using the builtin TOKENIZE function in Pig.  I had it read 5000 lines of text.  The groovy (or TOKENIZE) functions handle splitting the line, then we do a standard group/count to count the words.  I got the following results:&lt;/p&gt;

&lt;p&gt;Groovy using BSF:  55.070 seconds&lt;br/&gt;
Groovy direct bindings:  58.560 seconds&lt;br/&gt;
TOKENIZE:  2.554 seconds&lt;/p&gt;

&lt;p&gt;So a 30x slow down using this.  That&apos;s pretty painful.  I know string translation between languages can be bad.  I don&apos;t know how much of this is inter-language bindings and how much is groovy.  When i get  chance I&apos;ll try this in Python and see if I get similar numbers.&lt;/p&gt;</comment>
                            <comment id="12766750" author="ashutoshc" created="Fri, 16 Oct 2009 23:35:47 +0100"  >&lt;p&gt;30x is indeed too slow. But, between BSF and direct bindings, I imagine direct bindings should have been more performant, since BSF adds an extra layer of translation. Isn&apos;t it ? &lt;/p&gt;</comment>
                            <comment id="12766757" author="alangates" created="Fri, 16 Oct 2009 23:48:53 +0100"  >&lt;p&gt;I expected to see the direct bindings to be faster as well, but the tests didn&apos;t show that.  In the code contributed by Kishore the type translation was done the same regardless of the bindings used.  Perhaps there would be a more efficient way to do the type translation for direct bindings.  &lt;/p&gt;</comment>
                            <comment id="12766763" author="ashutoshc" created="Sat, 17 Oct 2009 00:04:13 +0100"  >&lt;p&gt;Though good learning from this test is BSF is not slower then direct bindings (need additional verifications though..) So, this feature could be implemented in lot less code and complexity using BSF as oppose to using different direct bindings for different languages.  On the other hand, only useful language BSF supports currently is Ruby. Not sure how many people using Pig will also be interested in groovy, javascript etc.( other languages supported by BSF ).&lt;/p&gt;</comment>
                            <comment id="12766769" author="alangates" created="Sat, 17 Oct 2009 00:13:29 +0100"  >&lt;p&gt;jython was the one I was assuming people would want.&lt;/p&gt;</comment>
                            <comment id="12766774" author="ashutoshc" created="Sat, 17 Oct 2009 00:39:22 +0100"  >&lt;p&gt;Right, I overlooked it. I think Ruby and Python are two most widely used scripting languages and both are supported by BSF. So, comparing BSF with direct bindings:&lt;br/&gt;
1) Performance : Initial test shows almost equal.&lt;br/&gt;
2) Support of multiple languages.&lt;br/&gt;
3) Ease of implementation &lt;br/&gt;
To me, BSF seems to be the way to go for this, atleast the first-cut. Implementing this feature using BSF will allow us to expose this to users quickly and if many people are using it and finding one particular language to be slow then we can explore language bindings for that particular language. Thoughts?&lt;/p&gt;</comment>
                            <comment id="12766806" author="alangates" created="Sat, 17 Oct 2009 01:55:06 +0100"  >&lt;p&gt;A couple thoughts:&lt;/p&gt;

&lt;p&gt;1) I still have to figure out how to do type translation in BSF.  The current patch just assumes one string argument and then does reflection on the fly on return to figure out what it is returning.  We may or may not be able to expose schemas to scripted UDFs (ala outputSchema and argToFuncMapping) but we at least need to handle multiple and non-string arguments.  I need to do more digging in order to understand how to do this type translation in BSF.&lt;/p&gt;

&lt;p&gt;2) For at least some either jython or jruby we&apos;ve got to show better than a 30x differential.  There are some products you&apos;re just too embarrassed to sell.  We may be able to speed this up some by having the framework figure out the return type for this UDF and always convert the returning object based on that return type rather than trying to do reflection.&lt;/p&gt;

&lt;p&gt;I don&apos;t know ruby or python, and I don&apos;t have time at the moment to go learn either.  If someone is willing to give me snippets of python and/or ruby that mimic the split functionality given in the patch, I&apos;m happy to test against those two in BSF and see what happens.&lt;/p&gt;</comment>
                            <comment id="12766867" author="ashutoshc" created="Sat, 17 Oct 2009 10:25:24 +0100"  >&lt;p&gt;I did little research on the topic and it turned there is a third option for doing it. JSR-223&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; for &quot;Scripting for Java&quot; has been approved through JCP and now is a part of java platform in form of javax.script&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; as of java 6. It seems that it aims to provide a consistent api through java language itself. No bindings needed, no BSF all one needs is a &quot;scripting engine&quot;. And they claim to have a very long list of languages supported including awk, python, ruby, groovy, javascript, scheme, php, smalltalk etc. &lt;br/&gt;
It will be interesting to explore this since:&lt;br/&gt;
1) Support from java platform implies no dependencies on BSF and language bindings jars.&lt;br/&gt;
2) Possibly more performant.&lt;br/&gt;
3) One consistent api for all scripting languages&lt;br/&gt;
4) Longer list of supported languages&lt;/p&gt;

&lt;p&gt;I am currently reading the apis and if I get something to work, will post back here.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=223&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.jcp.org/en/jsr/detail?id=223&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://java.sun.com/javase/6/docs/api/javax/script/package-summary.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/javase/6/docs/api/javax/script/package-summary.html&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://scripting.dev.java.net/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://scripting.dev.java.net/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12766984" author="ashutoshc" created="Sun, 18 Oct 2009 00:45:00 +0100"  >&lt;p&gt;I did some quick benchmarking using BSF approach for UDFs written in Ruby, Python, Groovy and native builtin in Pig. It&apos;s a standard wordcount example where udf tokenizes an input string into number of words. I used pig sources(src/org/apache/pig) as input which has more then 210K lines. Since, I haven&apos;t yet figured out type translation so to be consistent in experiment, I passed data as String argument and return type as Object[] in all languages. Following are the numbers I got averaged over 3 runs:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Language&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Time(seconds)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Pig&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;17&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Ruby&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;155&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;9.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Python&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;178&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Groovy&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1460&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;85&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;This shows Groovy-BSF combo is super-slow and Ruby and Python is much better. These numbers must be seen as an absolute worst case. I believe type translations, compiling script in constructor and using the compiled version instead of evaluating script in every exec() call will give much better performance. Also, there might exist other optimizations.&lt;/p&gt;

&lt;p&gt;Sometime next week, I will try to repeat the same experiment with javax.script&lt;/p&gt;</comment>
                            <comment id="12829427" author="woody.anderson@gmail.com" created="Thu, 4 Feb 2010 04:00:19 +0000"  >&lt;p&gt;unpack the file into a directory:&lt;br/&gt;
cd foo;&lt;br/&gt;
tar xvfz scripting.tgz&lt;br/&gt;
mkdata.sh&lt;/p&gt;

&lt;p&gt;time pig -x local tokenize.pig&lt;br/&gt;
time pig -x local js_wc.pig&lt;br/&gt;
time pig -x local pjy_wc.pig&lt;/p&gt;


&lt;p&gt;to do the last one, you&apos;ll have to build the Code.jar, do this (after installing jython.jar in /tmp)&lt;br/&gt;
mkdir tmp&lt;br/&gt;
scripter --jars &apos;/tmp/jython.jar:spig.jar:pjy.jar:pjs.jar&apos; -c ./Code.jar -w ./tmp/ --javac javac -o pjy_wc.pig pjy_wc.pjy&lt;/p&gt;</comment>
                            <comment id="12829432" author="woody.anderson@gmail.com" created="Thu, 4 Feb 2010 04:24:50 +0000"  >&lt;p&gt;slight error in the js_wc.js script:&lt;br/&gt;
change line 9 to:&lt;br/&gt;
X = foreach a GENERATE spig_split($0);&lt;br/&gt;
and, if you want schema info in the JS impl, change &apos;bag&apos; to &apos;b:&lt;/p&gt;
{tt:(t:chararray)}
&lt;p&gt;&apos; on line 4.&lt;/p&gt;

&lt;p&gt;setenv PIG_HEAPSIZE 2048&lt;br/&gt;
time pig -x local tokenize.pig&lt;br/&gt;
  41.724u 2.046s 0:30.52 143.3%	0+0k 0+16io 8pf+0w&lt;br/&gt;
time pig -x local js_wc.pig&lt;br/&gt;
  72.079u 2.905s 0:54.50 137.5%	0+0k 0+46io 14pf+0w&lt;br/&gt;
time pig -x local pjy_wc.pig&lt;br/&gt;
  41.588u 2.155s 0:33.58 130.2%	0+0k 0+6io 8pf+0w&lt;/p&gt;

&lt;p&gt;so the testing indicates that with this implementation the jython is fairly on par with the java TOKENIZE impl, and js is just shy of twice as slow.&lt;/p&gt;

&lt;p&gt;there are a lot of reasons that the performance of this implementation is startlingly better than the previous numbers, mostly to do with caching the functions, and jython.2.5.1 perhaps being better than whatever python variant was tried above.&lt;br/&gt;
this impl also aheres to the schema system for output data, which does cost some cpu, but is generally not too bad.&lt;/p&gt;

&lt;p&gt;the scripter converter does not have a js handler, but it does convert inlined jython code (anything between @@ jython @@ and subsequent @@)&lt;br/&gt;
for example (taken from pjy_wc.pjy):&lt;br/&gt;
@@ jython @@&lt;br/&gt;
def split(a):&lt;br/&gt;
    &quot;&quot;&quot; @return b:&lt;/p&gt;
{tt:(t:chararray)}
&lt;p&gt; &quot;&quot;&quot;&lt;br/&gt;
    return a.split()&lt;/p&gt;


&lt;p&gt;anyway, i&apos;d like to discuss these approaches moving into pig with more out-of-the-box support.&lt;br/&gt;
package: org/apache/pig/scripting is meant to be the harness that i&apos;d like to see as part of pig (or something very like that package)&lt;br/&gt;
packages: org/apache/pig/scripting/js, org/apache/pig/scripting/jython are implementations that i think are pretty useful, but could be improved. distributing these with pig is certainly debatable. eps jython requires jython.jar to function, and the js implementation is really just a proof of concept for a second language impl (i didn&apos;t even make a FilterFunc yet)&lt;/p&gt;

&lt;p&gt;the scripter functionality is something i&apos;d like to see supported by the pig parser as much as possible, but i don&apos;t have a great idea of how to do that yet. perhaps a new statement to allow a user to register a language pack jar would include hooking it into the parser to handle file references etc. as manually handling the dependency graph is a major pita. The creation of a Code jar and the invocation of javac (in particular, this may not be needed) are pretty arduous, so it&apos;d be nice for a general system to make this work.&lt;br/&gt;
I tried to write the script so that you could add new language handlers to it and it would process functions of the form &lt;/p&gt;
{lang}
&lt;p&gt;.&lt;/p&gt;
{function}
&lt;p&gt;(args) and convert appropriately. but i only implemented jython, so the language separation may not be entirely complete, e.g. a language with very different structure may require some other modifications to the script.&lt;/p&gt;

&lt;p&gt;i want to close by saying that the initial inspiration for this work and the idea of the pre-process script came from a blog post about a project called baconsnake &lt;a href=&quot;http://arnab.org/blog/baconsnake&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://arnab.org/blog/baconsnake&lt;/a&gt;, by Arnab Nandi. That post put me on the track of using jython from java code for the first time, and the idea of making the actual script injecting language tolerable. many thanks.&lt;/p&gt;</comment>
                            <comment id="12835393" author="woody.anderson@gmail.com" created="Thu, 18 Feb 2010 20:52:51 +0000"  >&lt;p&gt;did a bit more classloader work and i removed the need for the rather ugly javac hack.&lt;br/&gt;
so, now the command line is:&lt;br/&gt;
scripter --jars &apos;/tmp/jython.jar:spig.jar:pjy.jar:pjs.jar&apos; -c ./Code.jar -w ./tmp/ -o pjy_wc.pig pjy_wc.pjy&lt;/p&gt;

&lt;p&gt;if &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1242&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/PIG-1242&lt;/a&gt; were accomplished, the code.jar could be omitted in favor of register jython_code.py;, which would be even nicer.&lt;/p&gt;</comment>
                            <comment id="12836108" author="ashutoshc" created="Sat, 20 Feb 2010 02:53:33 +0000"  >&lt;p&gt;Hey Woody,&lt;/p&gt;

&lt;p&gt;Great work !! This will definitely be useful for lot of Pig users. I just hastily looked at your work. One question which stuck to me is you are doing lot of heavy lifting to provide for multi-language support by figuring out which language user is asking for and then doing reflection to load appropriate interpreter and stuff. I think it might be easier to use one of the frameworks here (BSF or javax.script) which hides this and allows handling of multiple language transparently. (atleast, thats what they claim to do) Have you taken a look at them? These frameworks  will arguably help us to provide support for more languages without maintaining lot of code on our part. Though, I am sure they will come at the performance cost (certainly CPU and possibly memory too). &lt;/p&gt;</comment>
                            <comment id="12837984" author="woody.anderson@gmail.com" created="Wed, 24 Feb 2010 19:56:54 +0000"  >&lt;p&gt;yes, i&apos;ve looked at both javax.script and BSF, both of which are not well designed for this scenario (in my opinion).&lt;br/&gt;
This comes mostly from their extreme generality and that they do not seem to provide a way to access and subsequently stash a consistent reference to a particular function. aka a pointer.&lt;/p&gt;

&lt;p&gt;This is partly what allows direct use of the jython interpreter to be so fast. Each invocation utilizes a function object directly, it does not have to give a name to an &apos;engine&apos; which looks up the function and decided appropriate call context, object context etc.&lt;br/&gt;
Those things are great, but not if you don&apos;t need them.&lt;br/&gt;
Perhaps someone can show me how those systems work much better than i have been able to utilize them, but this approach allows the impl to be agnostic to these frameworks in a way that can boost performance.&lt;br/&gt;
as you may have noticed, the js example uses javax.script, which BSF3 now conforms to, this impl must populate an engine, and then use the function name over and over. this involves more function name lookups and is less condusive to lamda functions etc.&lt;/p&gt;

&lt;p&gt;bsf is also extremely easy to integrate under the hood in the same way, it has the same perf costs as javax.script due to the hoop jumping. I tried this out while trying to make perl work, but the perlengine is 6 years old and i was unable to get it to work, the bsf binding part worked well enough though.&lt;/p&gt;

&lt;p&gt;the reflection overhead is pretty minimal, and not really needed if the user writes the code directly (they can simply use the appropriate package directly).&lt;br/&gt;
eg.&lt;br/&gt;
define spig_println_Tchararray_P1 org.apache.pig.scripting.Eval(&apos;js&apos;,&apos;println_Tchararray_P1&apos;,&apos;chararray&apos;,&apos;var println_Tchararray_P1 = function(a0) &lt;/p&gt;
{ println(a0); };&apos;);&lt;br/&gt;
v.s&lt;br/&gt;
define spig_println_Tchararray_P1 org.apache.pig.scripting.js.Eval(&apos;println_Tchararray_P1&apos;,&apos;chararray&apos;,&apos;var println_Tchararray_P1 = function(a0) { println(a0); }
&lt;p&gt;;&apos;);&lt;/p&gt;

&lt;p&gt;the top level Eval is there simply to allow factory based performance improvements that can be created by knowledgeable implementers.&lt;/p&gt;

&lt;p&gt;if the scriptengine frameworks provided nicer access to functions, and nicer call patterns it would have been nicer to use them.&lt;/p&gt;</comment>
                            <comment id="12838690" author="prasen" created="Fri, 26 Feb 2010 03:30:17 +0000"  >&lt;p&gt;Just curious to know,  can we not implement it along the lines of DEFINE commands. In that case we will let the shell take care of scripting issues, and no need to include scripting-specific jars ( jython etc. ). That might require code changes in core-pig and cant be implemented as a separate UDF-package though. &lt;/p&gt;</comment>
                            <comment id="12841033" author="ashutoshc" created="Thu, 4 Mar 2010 03:04:01 +0000"  >&lt;p&gt;@Prasen&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;can we not implement it along the lines of DEFINE commands. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ya, this functionality could be partially simulated using DEFINE / Streaming combination. But that may not be most efficient way to achieve it. First of all, streaming script  would be run in a separate process (as oppose to same JVM in approaches discussed above)  so there will be CPU cost involved in getting data in and out of from java process to stream script process.  Then, there is a cost of serialization and deserialization of parameters. You loose all the type information of the parameters.  Once you are in same runtime you can start doing interesting things. Also, having scripts in define statements will get kludgy soon as one you start to do complicated things there.  &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;no need to include scripting-specific jars (jython etc.)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Do you mean Include in pig distribution or in pig&apos;s  classpath at runtime ? In either case that may not necessarily a problem. For first part, we can use ivy to pull the jars for us instead of including in distribution and for second part we can ship all the jars required by Pig to compute nodes.&lt;/p&gt;</comment>
                            <comment id="12841039" author="ashutoshc" created="Thu, 4 Mar 2010 03:16:54 +0000"  >&lt;p&gt;@Woody&lt;/p&gt;

&lt;p&gt;I agree frameworks will not be performant. I think there usefulness depends on what we want to achieve? If we want to support many different languages, then they might prove useful, if we are only interested in supporting a language or two (seems Python and Ruby are most popular ones) then it won&apos;t make sense to pay the overhead associated with them.&lt;/p&gt;</comment>
                            <comment id="12841381" author="dvryaboy" created="Thu, 4 Mar 2010 16:50:38 +0000"  >&lt;p&gt;FWIW &amp;#8211; I would rather few languages were supported, and were fast, than support a lot of languages that are all unusably slow.  Ten times slower than Pig is in the unusable range, imo.&lt;/p&gt;</comment>
                            <comment id="12841387" author="alangates" created="Thu, 4 Mar 2010 17:06:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;FWIW - I would rather few languages were supported, and were fast, than support a lot of languages that are all unusably slow. Ten times slower than Pig is in the unusable range, imo.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 &lt;br/&gt;
I think if we can get Python going and make it easy to add Ruby, we&apos;ll have satisfied 90% of the potential users.  I&apos;ve had a number of people ask me directly if they could program in either of those languages.  I&apos;ve never had anyone say they wish they could write UDFs in groovy or java script.  I think people will pay a 2x cost for Python or Ruby.  I don&apos;t think they&apos;ll pay 10x.&lt;/p&gt;</comment>
                            <comment id="12841599" author="woody.anderson@gmail.com" created="Thu, 4 Mar 2010 23:12:16 +0000"  >&lt;p&gt;@Ashutosh&lt;br/&gt;
I don&apos;t think there is &lt;em&gt;any&lt;/em&gt; measurable overhead to the reflection mechanism in the example I provided. The objects are allocated &quot;a few&quot; times due to the schema interrogation logic of pig (something that might deserve an entire other bug thread of discussion, as i have no idea why X copies of a UDF have to be allocated for this).&lt;br/&gt;
When it comes time to run (i.e. where it really counts), there is a single invocation of the factory pattern followed by &quot;huge&quot; (data set derived) number of calls to that function. The UDF that is called is fully built an fully initialized with final variables etc, facilitating maximal streamlined execution.&lt;br/&gt;
There are certainly things about the approach i took, but language selection overhead is not one of them. If you have profiling numbers that suggest otherwise I&apos;d be suitably surprised.&lt;/p&gt;

&lt;p&gt;A secondary point to the whole idea of needing some script language code other than, say BSF or javax.script is the idea of type coercion. BSF/javax is not usable in a drop in manner. Each engine unfortunately consumes and produces objects in its own object model. If either of these frameworks had bothered to mandate converting input/output to java.util things would at least be easier, b/c we could convert from that to DataBag/Tuple in a unified manner, but this isn&apos;t the case. Thus conversion must be implemented per Engine, at which point, a conversion from PyArray to Tuple is more appropriate than PyArray -&amp;gt; List -&amp;gt; Tuple for performance concerns.&lt;br/&gt;
But, even for rudimentary correctness, type conversion must be implemented for each, at which point, a wrapping pattern that selects an appropriate function factory is a necessary pattern anyway.&lt;/p&gt;

&lt;p&gt;@Alan/@Dmitriy&lt;br/&gt;
Orthogonal to the above point: The idea of trying to support multiple script languages vs. a few. I am personally not of the same mind as you guys i guess.&lt;br/&gt;
I think there is near zero &apos;overhead&apos; perf cost for supporting some unspecified language. Languages continually evolve and new languages emerge that utilize the JVM better and better. I certainly agree that, at this time, jython and jruby seem the best. However, to say that clojure or javascript, or whatever are not going to move forward and potentially become more effectively integrated with the JVM is a bit premature.&lt;/p&gt;

&lt;p&gt;I would make the sacrifice if the ability to support multiple languages was actually that hard, or had an actual serious performance cost.&lt;br/&gt;
I just don&apos;t think those two issues are real.&lt;/p&gt;

&lt;p&gt;The performance costs come from the individual scripting engine features with respect to byte-code compliation, function referencing, string manipulation, execution caching etc.,  and their type coercion complexities.&lt;br/&gt;
That is completely different than the cost of PIG supporting multiple languages.&lt;br/&gt;
Also, supporting multiple languages is also not that hard. Arnab has thought about this, as have I. I think his ideas, while not perfect, offer a good avenue of exploration and moving forward that offers integration of PIG with any script language. It (importantly) offers to put those languages in PIG instead of the other way around, and it allows for multiple interpreter contexts and even multiple languages.&lt;/p&gt;

&lt;p&gt;I&apos;ll quote Arnab&apos;s quick description here:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;DEFINE CMD `SCRIPTBLOCK`&#160;script(&apos;javascript&apos;)&lt;br/&gt;
This is identical to the commandline streaming syntax, and follows gracefully in the style of the &quot;ship&quot; and &quot;cache&quot; keywords.&#160;&lt;/p&gt;

&lt;p&gt;Thus your javascript example becomes&lt;br/&gt;
DEFINE JSBlock `&lt;br/&gt;
function split(a) &lt;/p&gt;
{
&#160;&#160;return a.split(&quot; &quot;);
}
&lt;p&gt;`&#160;script(&apos;JAVASCRIPT&apos;);&lt;br/&gt;
Note the use of backticks is consistent with the current syntax, and is unlikely to occur in common scripts, so it saves us the escaping. Also it&#160;allows newlines in the code.&#160;&lt;br/&gt;
The goal is to create namespaces &amp;#8211; you can now call your function as &quot;JSBlock.split(a)&quot;. This allows us to have multiple functions in one block. &lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;This idea, coupled with the ability to register files and directories directly (e.g. register foo.py&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; provides the ability to load code into an arbitrary namespace/interpreter-scope, load it for an arbitrary language etc.&lt;br/&gt;
and the invocation syntax is nice and clean Block.foo() calls a method named foo in the interpreter.&lt;br/&gt;
To allow for the easy invocation syntax to perform well, we would need to cause it to execute in the same was as:&lt;br/&gt;
  define spig_split org.apache.pig.scripting.Eval(&apos;jython&apos;,&apos;split&apos;,&apos;b:&lt;/p&gt;
{tt:(t:chararray)}
&lt;p&gt;&apos;);&lt;/p&gt;

&lt;p&gt;i don&apos;t see that as particularly difficult modification of the function rationalization logic of pig. Actually, i think it&apos;s a general improvement as it cuts down on object allocations.&lt;/p&gt;

&lt;p&gt;In the event that this methodology is adopted, you are then still free to write projects that stuff PIG inside python or ruby etc. But PIG itself remains an environment that plays well with multiple script engines.&lt;/p&gt;

&lt;p&gt;conclusion:&lt;br/&gt;
I see it as quite achievable to support any given language with near zero overhead above the lang&apos;s scriptengine,&lt;br/&gt;
I thing it&apos;s quite doable to do this in a flexible model that allows them to be mixed together, even within the same script&lt;br/&gt;
I think that, overall this is highly preferable to a single or otherwise finite language situation (though i advocate possibly auto-supporting jython/jruby)&lt;/p&gt;</comment>
                            <comment id="12841619" author="dvryaboy" created="Thu, 4 Mar 2010 23:56:33 +0000"  >&lt;p&gt;Woody, what I meant by my remark was that I disagree with Ashutosh and agree with you, not that I only want to support Python. If using a framework meant we could support 100 jvm-based languages and your approach meant we could support 2, I&apos;d still go with what actually works.&lt;/p&gt;

&lt;p&gt;By the way, we should adapt this to create a reflection UDF to call out to Java libraries, so we don&apos;t have to wrap things like String.split anymore.&lt;/p&gt;</comment>
                            <comment id="12842062" author="woody.anderson@gmail.com" created="Fri, 5 Mar 2010 22:17:28 +0000"  >&lt;p&gt;Java reflection is very doable, it&apos;s kind of a pain i guess, but you could definitely do it. I think using BeanShell might be a way to use java syntax if you want to, but jython and jruby also are quite good at allowing you to call java code very easily and naturally.&lt;br/&gt;
What kind of reflection system are you thinking? passing a string as input to some function? or finding someway to assume you can make certain method calls on the objects that represent various data object in pig. e.g.  $0.split(&quot;.&quot;), assuming $0 is a chararray/string.&lt;br/&gt;
or are you thinking something that equates to:&lt;br/&gt;
def splitter java.util.regex.Pattern(&quot;\.&quot;);&lt;br/&gt;
A = foreach B generate splitter.split($0);&lt;/p&gt;

&lt;p&gt;to have it perform at &apos;peak&apos;, you&apos;d need to wrap the reflection into the constructor and cache the java.lang.reflect.Method object.&lt;br/&gt;
it wouldn&apos;t be too hard to write (the assumed impl uses constructor args to determine the correct Method via reflection):&lt;br/&gt;
def split org.apache.pig.scripting.Eval(&apos;reflect&apos;, &apos;java.util.regex.Pattern&apos;, &apos;split&apos;, &quot;\.&quot;, &apos;String&apos;, &apos;b:&lt;/p&gt;
{tt:(t:chararray)}
&lt;p&gt;&apos;);&lt;br/&gt;
A = foreach B generate split($0);&lt;/p&gt;

&lt;p&gt;to be more &apos;generic&apos; but less performant, you could do it more like this (the assumed impl uses less info to simply reflect a particular object):&lt;br/&gt;
def split org.apache.pig.scripting.Eval(&apos;reflect&apos;, &apos;java.util.regex.Pattern&apos;, &apos;split&apos;, &quot;\.&quot;);&lt;br/&gt;
A = foreach B generate split(&apos;split&apos;, $0);&lt;/p&gt;

&lt;p&gt;the issue here is that each invocation has to determine the correct Method object (after the first it&apos;s probably highly cacheable), also since the method might change as a result of a different name or different args, the lookup might also produce a different output schema. At any rate, i think you could write reasonably peformant caching code for this solution, but it&apos;d be more complicated and a tag slower than the former approach.&lt;br/&gt;
Mainly i&apos;ve tried in all of my impls to do as little as possible in the exec() method, and try to make most objects in use final and immutable (e.g. build them all in the constructor).&lt;/p&gt;

&lt;p&gt;you could of course go so far as to delay the creation of the actual Pattern object (i.e. where you first present the split pattern &quot;\.&quot;). Again, it lends itself to performance degrading coding patterns, but if you&apos;re careful with your actions, i think you could get most of it back with appropriately cached objects. Doing this in a completely generic fashion.. i&apos;ll think about it i guess, i think there&apos;s more overhead here than in the other approaches, but if your lib function is more than &apos;split&apos;, the overhead might not be noticeable. Of course, you could implement each of these abstractions levels and use them judiciously.&lt;/p&gt;

&lt;p&gt;anyway, there are a lot of options here, are these in line with what you were thinking?&lt;/p&gt;</comment>
                            <comment id="12844976" author="julienledem" created="Sat, 13 Mar 2010 22:33:34 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I&apos;m attaching something I implemented last year. I cleaned it up and updated the dependency to Pig 0.6.0 for the occasion.&lt;br/&gt;
There&apos;s probably some overlap with previous posts, sorry about the late submission.&lt;br/&gt;
Here is my approach.&lt;br/&gt;
I wanted to make easier a couple of things:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;writing programs that require multiple calls to pig&lt;/li&gt;
	&lt;li&gt;UDFs&lt;/li&gt;
	&lt;li&gt;parameter passing to Pig&lt;br/&gt;
So I integrated Pig with Jython so that the whole program (main program, UDFs, Pig scripts) could be in one python script.&lt;br/&gt;
example: python/tc.py in the attachment&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The script defines Python functions that are available as UDFs to pig automatically. The decorator @outputSchema is an easy way to specify what the output schema of the UDF is.&lt;br/&gt;
example (see script): @outputSchema(&quot;relationships:&lt;/p&gt;
{t:(target:chararray, candidate:chararray)}
&lt;p&gt;&quot;&lt;br/&gt;
Also notice that the UDFs use the standard python constructs: tuple, dictionary and list. they are converted to Pig constructs on the fly. This makes the definition of UDFs in Python very easy. Notice that the udf takes a list of arguments, not a tuple. The input tuple gets automatically mapped to the arguments.&lt;/p&gt;

&lt;p&gt;Then the script defines a main() function that will be the main program executed on the client.&lt;br/&gt;
In the main the Python program has access to a global pig variable that provides two methods (for now) and is designed to be an equivalent to PigServer.&lt;br/&gt;
List&amp;lt;ExecJob&amp;gt; executeScript(String script)&lt;br/&gt;
to execute a pig script in-lined in Python&lt;br/&gt;
deleteFile(String filename)&lt;br/&gt;
to delete a file&lt;br/&gt;
This looks a little bit like the JDBC approach where you &quot;query&quot; Pig and then can process the data.&lt;/p&gt;

&lt;p&gt;also you can embed python expressions in the pig statements using $&lt;/p&gt;
{ ... }
&lt;p&gt;example: $&lt;/p&gt;
{n - 1}
&lt;p&gt;They get executed in the current scope and replaced in the script. &lt;/p&gt;

&lt;p&gt;To run the example (assuming javac, jar and java are in your PATH):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;tar xzvf pyg.tgz&lt;/li&gt;
	&lt;li&gt;add pig-0.6.0-core.jar to the lib folder&lt;/li&gt;
	&lt;li&gt;./makejar.sh&lt;/li&gt;
	&lt;li&gt;./runme.sh&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It runs the following:&lt;br/&gt;
org.apache.pig.pyg.Pyg local tc.py&lt;/p&gt;

&lt;p&gt;tc.py is a python script that performs a transitive closure on a list of relation using an iterative algorithm. It defines python functions&lt;/p&gt;

&lt;p&gt;Limitations:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;you can not include other python scripts but this should be doable.&lt;/li&gt;
	&lt;li&gt;I haven&apos;t spent much time testing performance. I suspect the Pig&amp;lt;-&amp;gt;Python type conversion to be a little slow as it creates many new objects. It could possibly be improved by making the Pig objects implement the Python interfaces.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(the attachment contains jython.jar 2.5.0 for simplicity)&lt;/p&gt;

&lt;p&gt;Best regards, Julien&lt;/p&gt;</comment>
                            <comment id="12845017" author="julienledem" created="Sun, 14 Mar 2010 03:17:53 +0000"  >&lt;p&gt;Hi Woody,&lt;br/&gt;
Some comments:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Schema parsing:&lt;br/&gt;
I notice that you wrote a Schema parser in EvalBase.&lt;br/&gt;
It took me a while to figure out but you can do that with the following Pig class&lt;br/&gt;
org.apache.pig.impl.logicalLayer.parser.QueryParser&lt;br/&gt;
using the following code:&lt;br/&gt;
QueryParser parser = new QueryParser(new StringReader(schema));&lt;br/&gt;
result = parser.TupleSchema();&lt;br/&gt;
for example:&lt;br/&gt;
String schema = &quot;relationships:
{t:(target:chararray, candidate:chararray)}
&lt;p&gt;&quot;&lt;br/&gt;
and you get a Schema instance back.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Different options for passing the Python code to the hadoop nodes:&lt;br/&gt;
I notice you pass the Python functions by creating a .py file included in the jar which is then loaded through the class loader.&lt;br/&gt;
I pass the python code to the nodes by adding it as a parameter of my UDF constructor (encoded in a string). The drawback is that it is verbose as it gets included for every function. &lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12845420" author="woody.anderson@gmail.com" created="Mon, 15 Mar 2010 17:34:07 +0000"  >&lt;p&gt;@julien&lt;br/&gt;
have read over your code.&lt;/p&gt;

&lt;p&gt;1. schema parsing: yup, i much prefer re-using the parser, i wasn&apos;t able to find that impl, but should have been more diligent in looking for it.&lt;br/&gt;
2. i love the outputSchema decorator pattern that you use.&lt;br/&gt;
3. code via a .py file vs. string literal in the constructor. The .py file is a definite win when dealing with encoding issues (quotes, newlines etc). It&apos;s also a cleaner way to import larger blocks of code, and works for jython files etc. that are used indirectly etc. The constructor pattern is still supported in my approach, i just use it exclusively for lambda functions.&lt;br/&gt;
4. the pyObjToObj code is simpler in your approach, but limits the integration flexibility. i.e. you explicitly tie tuple:tuple, list:bag. Also, it&apos;s not clear how well this would handle sequences and iterators etc. I personally prefer using the schema to disambiguate the conversion, so that existing python code can be used to generate bags/tuples etc. via the schema rather than having to convert python objects using wrapper code.&lt;br/&gt;
5. the outputSchema logic is nice (as i said in #2, i love the decorator thing), but the schema should be cached if it is not a function. If it&apos;s a function, then the ref should be cached. This is particularly important if you&apos;re using the schema to inform the python -&amp;gt; pig data coercion.&lt;br/&gt;
6. as i said in prev comments, the scope of the interpreter is important. If you have two different UDFs that you want to share any state (such as counters), then a shared interpreter is a good idea. There are also memory gains from sharing etc. In general, i think you rarely want a distinct interpreter, and as such it should be possible, but not the default.&lt;/p&gt;

&lt;p&gt;Anyway, thanks for attaching the submission, i think there are lots of great ideas in your project. It makes me wish i&apos;d known about it sooner, parsing the pig schema system was not a fun day, though i guess i did learn a bit from it. The decorator thing is lovely. I&apos;ll probably borrow those and produce a tighter jython and scripting harness at some point.&lt;/p&gt;

&lt;p&gt;Overall, i&apos;m still firmly in the multi-language camp, but i think this provides nice improvements for a jython impl, and can clearly still swallow whatever language support pig introduces for anyone who wants to drive pig from python. So i think it should still be useful as a standalone project/harness.&lt;/p&gt;</comment>
                            <comment id="12847986" author="julienledem" created="Sun, 21 Mar 2010 21:49:14 +0000"  >&lt;p&gt;@Woody&lt;/p&gt;

&lt;p&gt;The main advantage of embedding pig calls in the scripting language is that it enables iterative algorithms, which Pig is no very good at currently. Why would we limit users to UDFs when they can have their whole program in their scripting language of choice?&lt;/p&gt;

&lt;p&gt;4. Python is a very interesting language to integrate with Pig because it has all the same native data structures (tuple:tuple, list:bag, dictionary:map) which makes the UDFs compact and easy to code. That said, in scripting languages that don&apos;t match as well as Python to the Pig types, using the schema to disambiguate will be a must have.&lt;br/&gt;
When do we need to convert sequences and iterators ? Pig has only tuple, bag and map as complex types AFAIK.&lt;br/&gt;
5. agreed, It should be cached or initialised at the begining.&lt;br/&gt;
3. and 6. I&apos;ll investigate passing the main script through the classpath when I have time. One interpreter would be nice to save memory and initialization time. I&apos;m not sure the shared state is such an advantage as UDFs should not rely on being run in the same process. Maybe I&apos;m just missing something.&lt;/p&gt;

&lt;p&gt;About the multi language: I&apos;m not against it, but there&apos;s not that much code to share.&lt;br/&gt;
The scripting&amp;lt;-&amp;gt;pig type conversion is specific to each language as you mentioned. also calling functions, getting a list of functions, defining output schemas will be specific.&lt;/p&gt;

&lt;p&gt;How I see the multilanguage:&lt;/p&gt;

&lt;p&gt;pig local|mapred -script &lt;/p&gt;
{language}
&lt;p&gt; &lt;/p&gt;
{scriptfile}

&lt;p&gt;main program:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;generic: loads the sript file&lt;/li&gt;
	&lt;li&gt;generic: makes the script available in the classpath of the tasks (through a jar generated on the fly?)&lt;/li&gt;
	&lt;li&gt;specific: initializes the interpreter for the scripting language&lt;/li&gt;
	&lt;li&gt;specific: adds the global variables defined by pig for the main (in my case: decorators, pig server instance)&lt;/li&gt;
	&lt;li&gt;generic: loads the script in the interpreter&lt;/li&gt;
	&lt;li&gt;specific: figures out the list of functions and registers them automatically as UDFs in PIG using a dedicated UDF wrapper class&lt;/li&gt;
	&lt;li&gt;specific: run the main&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Pig execute call from the script:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;generic: parse the Pig string to replace $
{expression}
&lt;p&gt; by the value of the expression as evaluated by the interpreter in the local scope.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;UDF init:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;generic: loads the script from the classpath&lt;/li&gt;
	&lt;li&gt;specific: initializes the interpreter for the scripting language&lt;/li&gt;
	&lt;li&gt;specific: add the global variables defined by pig for the UDFs (in my case: decorators)&lt;/li&gt;
	&lt;li&gt;generic: loads the script in the interpreter&lt;/li&gt;
	&lt;li&gt;specific: figures out the runtime for the outputSchema: function call or static schema (parsing of schema generic)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;UDF call:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;specific: convert a pig tuple to a parameter list in the scripting language types&lt;/li&gt;
	&lt;li&gt;specific: call the function with the parameters&lt;/li&gt;
	&lt;li&gt;specific: convert the result to Pig types&lt;/li&gt;
	&lt;li&gt;generic: return the result&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12853439" author="dvryaboy" created="Mon, 5 Apr 2010 17:56:00 +0100"  >&lt;p&gt;Woody,&lt;br/&gt;
I submitted my attempt at generic Java invocation in &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1354&quot; title=&quot;UDFs for dynamic invocation of simple Java methods&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1354&quot;&gt;&lt;del&gt;PIG-1354&lt;/del&gt;&lt;/a&gt;. Would appreciate feedback. It&apos;s fairly limited (only works for methods that return one of classes that has a Pig equivalent, and takes parameters of the same), but I&apos;ve already found it quite useful, even in the limited state. Had to break out a separate class for each return type, Pig was giving me trouble otherwise.&lt;/p&gt;</comment>
                            <comment id="12862040" author="julienledem" created="Thu, 29 Apr 2010 02:03:13 +0100"  >&lt;p&gt;I implemented the modifications mentioned in my previous comment:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-928?focusedCommentId=12847986&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12847986&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/PIG-928?focusedCommentId=12847986&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12847986&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To run the example (assuming javac, jar and java are in your PATH):&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;tar xzvf pyg.tgz&lt;/li&gt;
	&lt;li&gt;add pig-0.6.0-core.jar to the lib folder&lt;/li&gt;
	&lt;li&gt;./makejar.sh&lt;/li&gt;
	&lt;li&gt;./runme.sh&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The python implementation is now decoupled form the generic code.&lt;br/&gt;
the script code is passed through the classpath.&lt;br/&gt;
To implement other scripting languages, extend org.apache.pig.greek.ScriptEngine&lt;/p&gt;

&lt;p&gt;I renamed this thing Pig-Greek &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12864402" author="julienledem" created="Wed, 5 May 2010 18:00:47 +0100"  >&lt;p&gt;The attentive reader will have noticed that it should be &quot;tar xzvf pig-greek.tgz&quot; in my previous comment.&lt;/p&gt;</comment>
                            <comment id="12864443" author="nicolastorzec" created="Wed, 5 May 2010 19:50:42 +0100"  >&lt;p&gt;On the benchmarking side,&lt;br/&gt;
I had a look at the benchmark comparing native Pig built-in functions with UDFs written in Ruby, Python and Groovy using the BSF approach.&lt;/p&gt;

&lt;p&gt;For the sake of comprehensiveness, couldn&apos;t we also compare it with Pig streaming through Ruby, Python and Groovy?&lt;/p&gt;</comment>
                            <comment id="12870562" author="arnabdotorg" created="Mon, 24 May 2010 11:40:58 +0100"  >&lt;p&gt;Building on Julien&apos;s and Woody&apos;s code, this patch provides pluggable scripting support in native Pig.&lt;/p&gt;

&lt;p&gt;##Syntax:##&lt;/p&gt;

&lt;p&gt;register &apos;test.py&apos; USING org.apache.pig.scripting.jython.JythonScriptEngine;&lt;/p&gt;

&lt;p&gt;This makes all functions inside test.py available as Pig functions.&lt;/p&gt;

&lt;p&gt;##Things in this patch: ##&lt;/p&gt;

&lt;p&gt;1. Modifications to parser .jjt file&lt;/p&gt;

&lt;p&gt;2. ScriptEngine abstract class and Jython instantiation. &lt;/p&gt;

&lt;p&gt;3. Ability to ship .py files similar to .jars, loaded on demand.&lt;/p&gt;

&lt;p&gt;4. Input checking and Schema support.&lt;/p&gt;


&lt;p&gt;##Things NOT in this patch: ##&lt;/p&gt;

&lt;p&gt;1. Inline code support: (Replace &apos;test.py&apos; with `multiline inline code`, prefer to submit as separate bug)&lt;/p&gt;

&lt;p&gt;2. Scripting engines and examples other than Jython(e.g. beanshell and rhino)&lt;/p&gt;

&lt;p&gt;3. Junit-based test harness (provided as test.zip)&lt;/p&gt;

&lt;p&gt;4. Python&amp;lt;-&amp;gt;Pig Object transforms are not very efficient (see calltrace.zip). Preferred the cleaner implementation first. (non-obvious optimizations such as object reuse can be introduced as separate bug)&lt;/p&gt;


&lt;p&gt;##Notes: ##&lt;/p&gt;

&lt;p&gt;1. I went with &quot;register&quot; instead of &quot;define&quot; since files can contain multiple functions, similar to .jars. imho this makes more sense, using define would introduce the concept of &quot;codeblock aliases&quot; and function names would look like &quot;alias.functionName()&quot;, which is possible but inconsistent since we cannot have &quot;alias2.functionName()&quot; (which would require separate interpreter instances, etc etc).&lt;/p&gt;

&lt;p&gt;2. This has been tested both locally and in mapred mode.&lt;/p&gt;

&lt;p&gt;3. We assume .py files are simply a list of functions. Since the entire file is loaded, you can have dependent functions. No effort is made to resolve imports, though.&lt;/p&gt;

&lt;p&gt;4. You&apos;ll need to add jython.jar into classpath, or compile it into pig.jar.&lt;/p&gt;


&lt;p&gt;Would love comments and code-followups!&lt;/p&gt;</comment>
                            <comment id="12870739" author="dvryaboy" created="Mon, 24 May 2010 18:51:07 +0100"  >&lt;p&gt;I&apos;ve found that using lazy conversion from objects to tuples can save significant amounts of time when records get later filtered out, only parts of the output used, etc. Perhaps this is something to try if you say pythonToPig is slow?&lt;/p&gt;

&lt;p&gt;Here&apos;s what I did with Protocol Buffers: &lt;a href=&quot;http://github.com/dvryaboy/elephant-bird/blob/master/src/java/com/twitter/elephantbird/pig/util/ProtobufTuple.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://github.com/dvryaboy/elephant-bird/blob/master/src/java/com/twitter/elephantbird/pig/util/ProtobufTuple.java&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12871025" author="arnabdotorg" created="Tue, 25 May 2010 07:48:25 +0100"  >&lt;p&gt;Thanks Dmitriy! Lazy objects are a great idea. Note that I&apos;m not saying that pythontoPig is slow per se &amp;#8211; it&apos;s just the biggest part of the profiler trace, and would be a great place for optimization. I ran some numbers on the patch, and it looks like outside of the runtime instantiation, there is a fairly small performance penalty with the current code (1.2x slower).&lt;/p&gt;

&lt;p&gt;WordCount example from Alan&apos;s package.zip: &lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Data size&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Native&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Jython&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Factor&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10K&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;9s&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;18s&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;50K&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;14s&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;19s&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;500K&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;54s&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;64s&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.19&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;(Full Data: 8x&quot;War &amp;amp; Peace&quot; from Proj. Gutenberg, 500K lines, 24MB)&lt;br/&gt;
(TOKENIZE was modified to spaces-only, both implementations have identical output)&lt;/p&gt;

&lt;p&gt;Python code:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;@outputSchema(&quot;s:{d:(word:chararray)}&quot;)
def tokenize(word):
  if word is not None:
    return word.split(&apos; &apos;)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12871448" author="ashutoshc" created="Wed, 26 May 2010 01:15:12 +0100"  >&lt;p&gt;Arnab,&lt;/p&gt;

&lt;p&gt;Thanks for putting together a patch for this. One question I have is about register Vs define. Currently you are auto-registering all the functions in the script file and then they are available for later use in script. But I am not sure how we will handle the case for inlined functions. For inline functions &lt;tt&gt;define&lt;/tt&gt; seems to be a natural choice as noted in previous comments of the jira. And if so, then we need to modify define to support that use case. Wondering to remain consistent, we always use &lt;tt&gt;define&lt;/tt&gt; to define &amp;lt;non-native&amp;gt; functions instead of auto registering them. I also didn&apos;t get why there will be need for separate interpreter instances in that case.&lt;/p&gt;</comment>
                            <comment id="12872007" author="arnabdotorg" created="Thu, 27 May 2010 00:22:06 +0100"  >&lt;p&gt;Thanks for looking into the patch Ashutosh! Very good question, short answer: I couldn&apos;t come up with an elegant solution using &lt;tt&gt;define&lt;/tt&gt;  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I spent a bunch of time thinking about the &quot;right thing to do&quot; before going this way. As Woody mentioned, my initial instinct was to do this in in &lt;tt&gt;define&lt;/tt&gt;, but kept hitting roadblocks when working with &lt;tt&gt;define&lt;/tt&gt;:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;I came up with the analogy that &quot;register&quot; is like &quot;import&quot; in java, and &quot;define&quot; is like &quot;alias&quot; in bash. In this interpretation, whenever you want to introduce new code, you &lt;tt&gt;register&lt;/tt&gt; it with Pig. Whenever you want to alias anything for convenience or to add meta-information, you &lt;tt&gt;define&lt;/tt&gt; it.&lt;/li&gt;
	&lt;li&gt;Define is not amenable to multiple functions in the same script.
	&lt;ul&gt;
		&lt;li&gt;For example, to follow the &lt;tt&gt;stream&lt;/tt&gt; convention, &lt;blockquote&gt;&lt;p&gt; {define X &apos;x.py&apos; &lt;span class=&quot;error&quot;&gt;&amp;#91;inputoutputspec&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;schemaspec&amp;#93;&lt;/span&gt;;}. &lt;/p&gt;&lt;/blockquote&gt; Which function is the input/output spec for? A solution like &lt;blockquote&gt;&lt;p&gt; {&lt;span class=&quot;error&quot;&gt;&amp;#91;func1():schemaspec1,func2:schemaspec2&amp;#93;&lt;/span&gt;} &lt;/p&gt;&lt;/blockquote&gt; is... ugly.&lt;/li&gt;
		&lt;li&gt;Further, how do we access these functions? One solution is to have the namespace as a codeblock, e.g. X.func1(), which is doable by registering functions as &quot;X.func1&quot;, but we&apos;re (mis)leading the user to believe there is some sort of real namespacing going on. I foresee multi-function files as a very common use case; people could have a &quot;util.py&quot; with their commonly used suite of functions instead of forcing 1 file per 2-3 line function.&lt;/li&gt;
		&lt;li&gt;Note that Julien&apos;s @decorator idea cleanly solves this problem and I think it&apos;ll work for all languages.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;With inline &lt;tt&gt;define&lt;/tt&gt;, most languages have the convention of mentioning function definitions with the function name, input references &amp;amp; return schema spec, it seems redundant to force the user to break this convention and have something like &lt;blockquote&gt;&lt;p&gt; {define x as script(&apos;def X(a,b): return a + b;&apos;);}, &lt;/p&gt;&lt;/blockquote&gt; and have x.X(). Lambdas can solve this problem halfway, you&apos;ll need to then worry about the schema spec and we&apos;re back at a kludgy solution!&lt;/li&gt;
	&lt;li&gt;My plan for inline functions is to write all to a temp file (1 per script engine) and then deal with them as registering a file.&lt;/li&gt;
	&lt;li&gt;Jython code runs in its own interpreter because I couldn&apos;t figure out how to load Jython bytecode into Java, this has something to do with the lack of a jythonc afaik(I may be wrong). There will be one interpreter per non-compilable scriptengine, for others(Janino, Groovy), we load the class directly into the runtime.&lt;/li&gt;
	&lt;li&gt;From a code-writing perspective, overloading &lt;tt&gt;define&lt;/tt&gt; to tack on a third use-case despite would involve an overhaul to the POStream physical operator and felt very inelegant; register on the other hand is well contained to a single purpose &amp;#8211; including files for UDFs.&lt;/li&gt;
	&lt;li&gt;Consider the use of Janino as a ScriptEngine. Unlike the Jython scriptengine, this loads java UDFs into the native runtime and doesn&apos;t translate objects; so we&apos;re looking at potentially &lt;em&gt;zero&lt;/em&gt; loss of performance for inline UDFs (or register &apos;UDF.java&apos;; ). The difference between native and script code gets blurry here...&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;tl;dr&amp;#93;&lt;/span&gt; ...and then I thought fair enough, let&apos;s just go with &lt;tt&gt;register&lt;/tt&gt;! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12875341" author="julienledem" created="Thu, 3 Jun 2010 23:58:41 +0100"  >&lt;p&gt;I like Register better as well.&lt;/p&gt;

&lt;p&gt;With java UDFs, you REGISTER a jar.&lt;br/&gt;
Then you can use the classes in the jar using their fully qualified class name.&lt;br/&gt;
Optionally you can use DEFINE to alias the functions or pass extra initialization parameters.&lt;/p&gt;

&lt;p&gt;with scripting as implemented by Arnab, you REGISTER a script file (adding the script language information as it is not only java anymore) and you can use all the functions in it (just like you do in java).&lt;br/&gt;
Then I would say you should be able to alias them using DEFINE and define a closure by passing extra parameters, DEFINE log2 logn(2, $0); (maybe I am asking to much here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )&lt;/p&gt;</comment>
                            <comment id="12877160" author="aniket486" created="Wed, 9 Jun 2010 19:24:09 +0100"  >&lt;p&gt;Proposed syntax for the Script UDF registration-&lt;/p&gt;

&lt;p&gt;1. Registration of entire script-&lt;br/&gt;
test.py has helloworld, complex etc.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
register &apos;test.py&apos; lang python;
b = foreach a generate helloworld(a.$0), complex(a.$1);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This registers all functions in test.py as pig UDFs.&lt;/p&gt;

&lt;p&gt;Issues- (as per current implementation)&lt;br/&gt;
1. flat namespace- this consumes the UDF namespace. Do we need to have test.py.helloworld?&lt;br/&gt;
2. no way to find signature- We do not verify signature of helloworld in front end, user has no feedback about UDF signatures.&lt;br/&gt;
3. Dependencies- no ship clause.&lt;/p&gt;

&lt;p&gt;Optional command-&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
describe &apos;test.py&apos;;
helloworld{x:chararray};
complex{i:&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;};
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Changes needed- ScriptEngine needs to have a function that for a given script and funcspec dumps the function signature if funcspec if the function is present in the script (given path).&lt;br/&gt;
abstract void dumpFunction(String path, FuncSpec funcSpec, PigContext pigContext);&lt;/p&gt;

&lt;p&gt;2. Registration of single UDF from a script-&lt;br/&gt;
test.py has helloworld which has dependencies in &apos;1.py&apos; and &apos;2.py&apos;.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
define helloworld lang python source &apos;test.py&apos; ship (&apos;1.py&apos;, &apos;2.py&apos;);
OR
define hello lang python source &apos;test.py&apos;#helloworld ship (&apos;1.py&apos;, &apos;2.py&apos;);
b = foreach a generate helloworld(a.$0);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This registers helloworld (/hello) as pig UDF.&lt;/p&gt;

&lt;p&gt;Also,&lt;br/&gt;
ScriptEngine -&amp;gt; getStandardScriptJarPath() returns path for standard location of jython.jar (user can override this with register jython5.jar etc). We ship this jar if user does not explicitly specify one.&lt;br/&gt;
ScriptEngine.getInstance maps keyword &quot;python&quot; to appropriate ScriptEngine class.&lt;/p&gt;

&lt;p&gt;Attached is initial implementation for register script clause and parse patch has parsing related initial changes for define clause.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;RegisterPythonUDF2.patch, RegisterScriptUDFDefineParse.patch &amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="12877197" author="arnabdotorg" created="Wed, 9 Jun 2010 21:45:13 +0100"  >&lt;p&gt;&amp;gt; register &apos;test.py&apos; lang python;&lt;/p&gt;

&lt;p&gt;How does one define an arbitrary &quot;lang&quot;? e.g. I would like to introduce Scala as a UDF engine, preferably as a jar itself. i.e. something like:&lt;/p&gt;

&lt;p&gt;register scalascript.jar;&lt;br/&gt;
register &apos;test.py&apos; USING scala.Engine();&lt;/p&gt;


</comment>
                            <comment id="12877667" author="aniket486" created="Fri, 11 Jun 2010 01:43:08 +0100"  >&lt;p&gt;I support above comment.&lt;br/&gt;
Also, in favor of not breaking old code. I think, we should avoid introducing new keywords.&lt;/p&gt;

&lt;p&gt;In the above proposal, by adding python as a lang-keyword I meant to hide extensibility of ScriptEngine interface by natively supporting python. If we have to allow users add support for other languages. we need to allow &quot;using org.apache.pig.scripting.jython.JythonScriptEngine&quot;. But this will need us to document the scriptengine interface.&lt;/p&gt;

&lt;p&gt;Following seems to be more suitable choice. Comments?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-- register all UDFs inside test.py using custom (or builtin) ScriptEngine
register &apos;test.py&apos; using org.apache.pig.scripting.jython.JythonScriptEngine ship (&apos;1.py&apos;, &apos;2.py&apos;);
-- namespace? test.helloworld?
b = foreach a generate helloworld(a.$0), complex(a.$1);

-- register helloworld UDF as hello using JythonScriptEngine
define hello using org.apache.pig.scripting.jython.JythonScriptEngine from &apos;test.py&apos;#helloworld ship (&apos;1.py&apos;, &apos;2.py&apos;);
b = foreach a generate helloworld(a.$0); 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also, register scalascript.jar would not be necessary if getStandardScriptJarPath() returns the path of the jar.&lt;/p&gt;</comment>
                            <comment id="12879181" author="alangates" created="Wed, 16 Jun 2010 00:33:19 +0100"  >&lt;p&gt;I propose the following syntax for register:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
REGISTER _filename_ [USING _class_ [AS _namespace_]]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is backwards compatible with the current version of register.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;class&lt;/em&gt; in the USING clause would need to implement a new interface ScriptEngine (or something) which would be used to interpret the file.  If no USING clause is&lt;br/&gt;
given, then it is assumed that &lt;em&gt;filename&lt;/em&gt; is a jar.  I like this better than the &apos;lang python&apos; option we had earlier because it allows users to add new engines&lt;br/&gt;
without modifying the parser.  We should however provide a pre-defined set of scripting engines and names, so that for example python translates to&lt;br/&gt;
org.apache.pig.script.jython.JythonScriptingEngine&lt;/p&gt;

&lt;p&gt;If the AS clause is not given, then the basename of &lt;em&gt;filename&lt;/em&gt; defines the namespace name for all functions defined in that file.  This allows us to avoid&lt;br/&gt;
function name clashes.  If the AS clause is given, this defines an alternate namespace.  This allows us to avoid name clashes for filenames.  Functions would&lt;br/&gt;
have to be referenced by full namespace names, though aliases can be given via DEFINE.&lt;/p&gt;

&lt;p&gt;Note that the AS clause is a sub-clause of the USING clause, and cannot be used alone, so there is no ability to give namespaces to jars.&lt;/p&gt;

&lt;p&gt;As far as I can tell there is no need for a SHIP clause in the register.  Additional python modules that are needed can be registered.  As long as Pig lazily&lt;br/&gt;
searches for functions and does not automatically find every function in every file we register, this will work fine.&lt;/p&gt;

&lt;p&gt;So taken altogether, this would look like the following.  Assume we have two python files &lt;tt&gt;/home/alan/myfuncs.py&lt;/tt&gt;&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; mymod

def a():
    ...

def b():
    ...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and &lt;tt&gt;/home/bob/myfuncs.py&lt;/tt&gt;:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
def a():
    ...

def c():
    ...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and the following Pig Latin&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
REGISTER /home/alan/myfuncs.py USING python;
REGISTER /home/alan/mymod.py; -- no need &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; USING since I won&apos;t be looking in here &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; files, it just has to be moved over
REGISTER /home/bob/myfuncs.py  USING python AS hisfuncs;

DEFINE b myfuncs.b();

A = LOAD &apos;mydata&apos; as (x, y, z);
B = FOREACH A GENERATE myfuncs.a(x), b(y), hisfuncs.a(z);
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="12879201" author="julienledem" created="Wed, 16 Jun 2010 01:24:10 +0100"  >&lt;p&gt;I like the suggestion. However I would prefer not to use namespaces by default.&lt;br/&gt;
Most likely users will register a few functions and use namespaces only when conflicts happen.&lt;br/&gt;
The shortest syntax should be used for the most common use case.&lt;/p&gt;

&lt;p&gt;most of the time:&lt;br/&gt;
REGISTER /home/alan/myfuncs.py USING python;&lt;br/&gt;
B = FOREACH A GENERATE a&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/p&gt;

&lt;p&gt;when it is needed:&lt;br/&gt;
REGISTER /home/alan/myfuncs.py USING python AS myfuncs;&lt;br/&gt;
B = FOREACH A GENERATE myfuncs.a&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/p&gt;

&lt;p&gt;Also register jar does not prefix classes by the jar name so that would be inconsistent.&lt;br/&gt;
REGISTER /home/alan/myfuncs.jar;&lt;/p&gt;</comment>
                            <comment id="12879621" author="aniket486" created="Thu, 17 Jun 2010 02:37:58 +0100"  >&lt;p&gt;I have attached the patch for proposed changes.&lt;/p&gt;

&lt;p&gt;Few points to note-&lt;br/&gt;
1. As jar is treated in a different way (searched in system resources, classloader used etc) than other files, we differentiate a jar with its extension.&lt;br/&gt;
2. namespace is kept as default = &quot;&quot; as per above comment, this is implemented as part of registerFunctions interface of ScriptEngine, so that different engines can have different behavior as necessary.&lt;br/&gt;
3. keyword python is supported along with custom scriptengine name.&lt;/p&gt;</comment>
                            <comment id="12879625" author="aniket486" created="Thu, 17 Jun 2010 02:45:48 +0100"  >&lt;p&gt;Adding missing scripting files&lt;/p&gt;</comment>
                            <comment id="12884378" author="aniket486" created="Thu, 1 Jul 2010 19:47:49 +0100"  >&lt;p&gt;Extension of this jira to track progress for inline script udfs with define clause has been added at &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1471&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/PIG-1471&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12884406" author="julienledem" created="Thu, 1 Jul 2010 21:30:51 +0100"  >&lt;p&gt;I created another extension to discuss the embedding part: &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1479&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/PIG-1479&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12884763" author="dvryaboy" created="Fri, 2 Jul 2010 19:16:56 +0100"  >&lt;p&gt;Aniket, the patch does not apply cleanly to trunk, can you rebase it? &lt;/p&gt;</comment>
                            <comment id="12884784" author="dvryaboy" created="Fri, 2 Jul 2010 20:06:14 +0100"  >&lt;p&gt;I rebased the patch and made it pull jython down via maven. 2.5.1 doesn&apos;t appear to be available right now, so this pulls down 2.5.0. Hope that&apos;s ok.&lt;/p&gt;

&lt;p&gt;Looks like the tabulation is wrong in most of this patch.. someone please hit ctrl-a, ctrl-i next time &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;Needless to say, this thing needs tests, desperately.&lt;/p&gt;

&lt;p&gt;Also imho in order for it to make it into trunk, it should be a compile-time option to support (and pull down) jython or jruby or whatnot, not a default option. Otherwise we are well on our way to making people pull down the internet in order to compile pig.&lt;/p&gt;</comment>
                            <comment id="12884841" author="aniket486" created="Fri, 2 Jul 2010 23:50:24 +0100"  >&lt;p&gt;The fix needed some changes in queryparser to support namespace, I found this in test cases I added. &lt;br/&gt;
Current EvalFuncSpec logic is convoluted, I replaced it with a cleaner one.&lt;br/&gt;
I have attached the updated patch with changes mentioned above.&lt;/p&gt;

&lt;p&gt;I am not sure what needs to be done for jython.jar, my guess was to check-in that in /lib. Thoughts?&lt;/p&gt;</comment>
                            <comment id="12884843" author="aniket486" created="Fri, 2 Jul 2010 23:51:44 +0100"  >&lt;p&gt;Changes needed for script UDF.&lt;br/&gt;
TODO- jython.jar related changes&lt;/p&gt;</comment>
                            <comment id="12884845" author="dvryaboy" created="Fri, 2 Jul 2010 23:56:13 +0100"  >&lt;p&gt;Aniket, I already made the changes you need to pull down jython &amp;#8211; take a look at the patch I attached.&lt;/p&gt;

&lt;p&gt;One more general note &amp;#8211; let&apos;s say jython instead of python (in the grammar, the keywords, everywhere), as there may be slight incompatibilities between the two and we want to be clear on what we are using.&lt;/p&gt;</comment>
                            <comment id="12884856" author="aniket486" created="Sat, 3 Jul 2010 00:28:37 +0100"  >&lt;p&gt;I had added an interface: getStandardScriptJarPath to find the path of jython jar to be shipped as part of job.jar only when user uses this feature. How do I incorporate this into new changes? &lt;br/&gt;
Do we want to go for compile time support option? &lt;/p&gt;</comment>
                            <comment id="12884863" author="julienledem" created="Sat, 3 Jul 2010 00:49:25 +0100"  >&lt;p&gt;Aniket, this is assuming the  ScriptEngine requires only one jar.&lt;br/&gt;
I would suggest instead having a method ScriptEngine.init(PigContext) that would be called after the ScriptEngine instance has been retrieved from the factory.&lt;br/&gt;
That would let the script engine add whatever is needed to the job.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(scriptingLang != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
            ScriptEngine se = ScriptEngine.getInstance(scriptingLang);

            &lt;span class=&quot;code-comment&quot;&gt;//pigContext.scriptJars.add(se.getStandardScriptJarPath());
&lt;/span&gt;            se.init(pigContext);
            se.registerFunctions(path, namespace, pigContext);
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Have a good week end, Julien&lt;/p&gt;</comment>
                            <comment id="12885633" author="julienledem" created="Tue, 6 Jul 2010 19:48:42 +0100"  >&lt;p&gt;actually, I retract the init() method as it seems this could all happen in registerFunctions()&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;public void registerFunctions(String path, String namespace, PigContext pigContext)&lt;br/&gt;
    throws IOException { &lt;/p&gt;

&lt;p&gt;    pigContext.addJar(JAR_PATH);&lt;br/&gt;
    ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;also I was suggesting this way of automatically figuring out the jar path for a class:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;	/** &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;figure out the jar location from the class&lt;/li&gt;
	&lt;li&gt;@param clazz&lt;/li&gt;
	&lt;li&gt;@return the jar file location, null if the class was not loaded from a jar&lt;br/&gt;
	 */&lt;br/&gt;
	protected static String getJar(Class&amp;lt;?&amp;gt; clazz) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {		URL resource = clazz.getClassLoader().getResource(clazz.getCanonicalName().replace(&amp;quot;.&amp;quot;,&amp;quot;/&amp;quot;)+&amp;quot;.class&amp;quot;);		if (resource.getProtocol().equals(&amp;quot;jar&amp;quot;)) &lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {
			return resource.getPath().substring(resource.getPath().indexOf(&amp;#39;}&lt;/span&gt; &lt;/div&gt;		return null;	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;otherwise the code depends on the path it is run from.&lt;/p&gt;</comment>
                            <comment id="12885635" author="julienledem" created="Tue, 6 Jul 2010 19:51:35 +0100"  >&lt;p&gt;Argh... Sorry about that&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
	/** 
	 * figure out the jar location from the class 
	 * @param clazz
	 * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; the jar file location, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the class was not loaded from a jar
	 */
	&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; getJar(&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz) {
		URL resource = clazz.getClassLoader().getResource(clazz.getCanonicalName().replace(&lt;span class=&quot;code-quote&quot;&gt;&quot;.&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;/&quot;&lt;/span&gt;)+&lt;span class=&quot;code-quote&quot;&gt;&quot;.class&quot;&lt;/span&gt;);
		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (resource.getProtocol().equals(&lt;span class=&quot;code-quote&quot;&gt;&quot;jar&quot;&lt;/span&gt;)) {
			&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; resource.getPath().substring(resource.getPath().indexOf(&apos;:&apos;)+1,resource.getPath().indexOf(&apos;!&apos;));
		}
		&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12885717" author="aniket486" created="Tue, 6 Jul 2010 23:27:28 +0100"  >&lt;p&gt;Thanks Dmitriy and Julien for your help.&lt;br/&gt;
Attached is the patch with test cases. Test manually passed.&lt;/p&gt;</comment>
                            <comment id="12885737" author="julienledem" created="Wed, 7 Jul 2010 00:35:33 +0100"  >&lt;p&gt;ScriptEvalFunc does not do much anymore, I would suggest to remove it.&lt;br/&gt;
If we want to keep it to add shared code in the future then remove its constructor as it forces the schema to be fixed.&lt;br/&gt;
The output schema may depend on the input schema in some cases.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class ScriptEvalFunc &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; EvalFunc&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; {
    /**
     * Stub constructor to guide derived classes 
     * Avoids extra reference on exec()
     * @param fileName
     * @param functionName
     * @param numArgs
     * @param schema
     */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ScriptEvalFunc(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; fileName, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; functionName, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; numArgs, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; schema) {
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; exec(Tuple tuple) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; Schema outputSchema(Schema input);

}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As a side note, my original posting (see pig-greek.tgz) had a second decorator to handle that. You would provide the name of the function to compute the output schema from the input schema:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@outputSchemaFunction(&lt;span class=&quot;code-quote&quot;&gt;&quot;fooOutputSchema&quot;&lt;/span&gt;)
def foo(someParameter):
   ...

def fooOutputSchema(inputSchema):
   ...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12885822" author="hadoopqa" created="Wed, 7 Jul 2010 05:26:07 +0100"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12448831/RegisterPythonUDFFinale3.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12448831/RegisterPythonUDFFinale3.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision 960062.&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    -1 javadoc.  The javadoc tool appears to have generated 1 warning messages.&lt;/p&gt;

&lt;p&gt;    -1 javac.  The applied patch generated 146 javac compiler warnings (more than the trunk&apos;s current 145 warnings).&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 4 new Findbugs warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    -1 contrib tests.  The patch failed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/340/testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/340/testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/340/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/340/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/340/console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/340/console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="12886163" author="aniket486" created="Thu, 8 Jul 2010 01:19:09 +0100"  >&lt;p&gt;I got what you mean, if user needs a generic square function he can write:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
#!/usr/bin/python
@outputSchemaFunction(\&lt;span class=&quot;code-quote&quot;&gt;&quot;squareSchema\&quot;&lt;/span&gt;)
def square(number):
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (number * number)
def squareSchema(input):
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; input
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I will make changes so that I can use similar approach as pig-greek. Since outputschema needs to know both input and name of outputSchemaFunction current code would need further changes.&lt;/p&gt;</comment>
                            <comment id="12886515" author="aniket486" created="Thu, 8 Jul 2010 22:57:41 +0100"  >&lt;p&gt;Added support for decorator outputSchemaFunction that points to a function which defines the schema for the function.&lt;br/&gt;
Also, in case of function with no decorator schema is assumed to be databytearray.&lt;/p&gt;</comment>
                            <comment id="12886530" author="aniket486" created="Thu, 8 Jul 2010 23:35:59 +0100"  >&lt;p&gt;I have uploaded a wiki page to mention the usage and syntax-- &lt;a href=&quot;http://wiki.apache.org/pig/UDFsUsingScriptingLanguages&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/pig/UDFsUsingScriptingLanguages&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12886610" author="hadoopqa" created="Fri, 9 Jul 2010 05:26:19 +0100"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12449018/RegisterPythonUDF_Final.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12449018/RegisterPythonUDF_Final.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision 960062.&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    -1 javac.  The applied patch generated 146 javac compiler warnings (more than the trunk&apos;s current 145 warnings).&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 1 new Findbugs warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    -1 contrib tests.  The patch failed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/364/testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/364/testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/364/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/364/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/364/console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/364/console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="12886826" author="aniket486" created="Fri, 9 Jul 2010 19:52:11 +0100"  >&lt;p&gt;Fixed @@@ related stuff...&lt;br/&gt;
Parsing of schema from decorators is postponed until the constructor.&lt;br/&gt;
Fixed some test related changes. &lt;/p&gt;</comment>
                            <comment id="12886888" author="hadoopqa" created="Fri, 9 Jul 2010 22:17:01 +0100"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12449105/RegisterPythonUDFFinale4.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12449105/RegisterPythonUDFFinale4.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision 962628.&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    -1 patch.  The patch command could not apply the patch.&lt;/p&gt;

&lt;p&gt;Console output: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/365/console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h7.grid.sp2.yahoo.net/365/console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="12886941" author="aniket486" created="Sat, 10 Jul 2010 00:14:19 +0100"  >&lt;p&gt;Rebased version of Finale4&lt;/p&gt;</comment>
                            <comment id="12888062" author="alangates" created="Tue, 13 Jul 2010 23:37:25 +0100"  >&lt;p&gt;ScriptEngine is a new public interface for Pig once we commit this patch.  We need to declare this as public and it&apos;s stability level (evolving I&apos;m guessing since&lt;br/&gt;
its new, but I&apos;m open to arguments for other levels).  See &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1311&quot; title=&quot;Pig interfaces should be clearly classified in terms of scope and stability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1311&quot;&gt;&lt;del&gt;PIG-1311&lt;/del&gt;&lt;/a&gt; for info on how to do this.&lt;/p&gt;</comment>
                            <comment id="12888068" author="hadoopqa" created="Tue, 13 Jul 2010 23:41:57 +0100"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12449134/RegisterPythonUDFFinale5.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12449134/RegisterPythonUDFFinale5.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision 963504.&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    -1 javac.  The applied patch generated 145 javac compiler warnings (more than the trunk&apos;s current 144 warnings).&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 1 new Findbugs warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    -1 contrib tests.  The patch failed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/344/testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/344/testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/344/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/344/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/344/console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hudson.zones.apache.org/hudson/job/Pig-Patch-h8.grid.sp2.yahoo.net/344/console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="12888100" author="ashutoshc" created="Wed, 14 Jul 2010 00:21:42 +0100"  >&lt;ul&gt;
	&lt;li&gt;Do you want to allow: &lt;tt&gt;register myJavaUDFs.jar using &apos;java&apos; as &apos;javaNameSpace&apos;&lt;/tt&gt; ? Use-case could be that if we are allowing namespaces for non-java, why not allow for Java udfs as well. But then &lt;tt&gt;define&lt;/tt&gt; is exactly for this purpose. So, it may make sense to throw exception for such a case.&lt;/li&gt;
	&lt;li&gt;In ScriptEngine.getJarPath() shouldn&apos;t you throw a FileNotFoundException instead of returning null.&lt;/li&gt;
	&lt;li&gt;Don&apos;t gobble up Checked Exceptions and then rethrow RuntimeExceptions. Throw checked exceptions, if you need to.&lt;/li&gt;
	&lt;li&gt;ScriptEngine.getInstance() should be a singleton, no?&lt;/li&gt;
	&lt;li&gt;In JythonScriptEngine.getFunction() I think you should check if interpreter.get(functionName) != null and then return it and call Interpreter.init(path) only if its null.&lt;/li&gt;
	&lt;li&gt;In JythonUtils, for doing type conversion you should make use of both input and output schemas (whenever they are available) and avoid doing reflection for every element. You can get hold of input schema through outputSchema() of EvalFunc and then do UDFCOntext magic to use it. If schema == null || schema == bytearray, you need to resort to reflections. Similarily if outputSchema is available via decorators, use it to do type conversions.&lt;/li&gt;
	&lt;li&gt;In jythonUtils.pythonToPig() in case of Tuple, you first create Object[] then do Arrays.asList(), you can directly create List&amp;lt;Object&amp;gt; and avoid unnecessary casting. In the same method, you are only checking for long, dont you need to check for int, String  etc. and then do casting appropriately. Also, in default case I think we cant let object pass as it is using Object.class, it could be object of any type and may cause cryptic errors in Pipeline, if let through. We should throw an exception if we dont know what type of object it is. Similar argument for default case of pigToPython()&lt;/li&gt;
	&lt;li&gt;I didn&apos;t get why the changes are required in POUserFunc. Can you explain and also add it as comments in the code.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Testing:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;This is a big enough feature to warrant its own test file. So, consider adding a new test file (may be TestNonJavaUDF). Additionally, we see frequent timeouts on TestEvalPipeline, we dont want it to run any longer.&lt;/li&gt;
	&lt;li&gt;Instead of adding query through pigServer.registerCode() api, add it through pigServer.registerQuery(register myscript.py using &quot;jython&quot;). This will make sure we are testing changes in QueryParser.jjt as well.&lt;/li&gt;
	&lt;li&gt;Add more tests. Specifically, for complex types passed to the udfs (like bag) and returning a bag. You can get bags after doing a group-by. You can also take a look at original Julien&apos;s patch which contained a python script. Those I guess were at right level of complexity to be added as test-cases in our junit tests.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Nit-picks:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Unnecessary import in JythonFunction.java&lt;/li&gt;
	&lt;li&gt;In PigContext.java, you are using Vector and LinkedList, instead of usual ArrayList. Any particular reason for it, just curious?&lt;/li&gt;
	&lt;li&gt;More documentation (in QuerParser.jjt, ScriptEngine, JythonScriptEngine (specifically for outputSchema, outputSchemaFunction, schemafunction))&lt;/li&gt;
	&lt;li&gt;Also keep an eye of recent &quot;mavenization&quot; efforts of Pig, depending on when it gets checked-in you may (or may not) need to make changes to ivy&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12888232" author="aniket486" created="Wed, 14 Jul 2010 08:21:17 +0100"  >&lt;p&gt;Thanks for your comments. I will make the required changes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do you want to allow: register myJavaUDFs.jar using &apos;java&apos; as &apos;javaNameSpace&apos; ? Use-case could be that if we are allowing namespaces for non-java, why not allow for Java udfs as well. But then define is exactly for this purpose. So, it may make sense to throw exception for such a case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;myJavaUDFs.jar can itself have package structure that can define its own namespace, for example- maths.jar has function math.sin etc, I will throw parseexception for such a case&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;ScriptEngine.getInstance() should be a singleton, no?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;getInstance is a factory method that returns an instance of scriptEngine based on its type. We create a newInstance of the scriptEngine so that if registerCode is called simultaneously, we can create a different interpreter for both the invocations to register these scripts to pig.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In JythonScriptEngine.getFunction() I think you should check if interpreter.get(functionName) != null and then return it and call Interpreter.init(path) only if its null.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This behavior is consistent with interpreter.get method that returns null if some resource is not found inside the script. Callers of this function handle runtimeexceptions. Also, we will fail much earlier if we try to access functions that are not already present/registered so it should be safe.&lt;br/&gt;
Also, interpreter is never null because its a static member of the JythonScriptEngine, instantiated statically.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I didn&apos;t get why the changes are required in POUserFunc. Can you explain and also add it as comments in the code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;POUserFunc has possible bug to check res.result != null when it is always null at this point. If the returntype expected is bytearray, we cast return object to byte[] with toString().getBytes() (which was never hit due to the bug mentioned above), but when return type is byte[] we need special handling (this is not case for other evalfuncs as they generally return pigtypes).&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of adding query through pigServer.registerCode() api, add it through pigServer.registerQuery(register myscript.py using &quot;jython&quot;). This will make sure we are testing changes in QueryParser.jjt as well.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;register is Grunt command parsed by gruntparser hence doesnt go through queryparser. We directly call registerCode from GruntParser. Also, parsing logic is trivial.&lt;/p&gt;
</comment>
                            <comment id="12888979" author="aniket486" created="Fri, 16 Jul 2010 02:14:50 +0100"  >&lt;p&gt;Commenting on behavior of EvalFunc&amp;lt;Object&amp;gt;, we consider following UDF-&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class UDF1 &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; EvalFunc&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; {
    class Student{
        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; age;
        &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; name;
        Student(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; nm) {
            age = a;
            name = nm;
        }
    }
    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; exec(Tuple input) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Student(12, (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)input.get(0));
    }
    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Schema outputSchema(Schema input) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Schema(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Schema.FieldSchema(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, DataType.BYTEARRAY));
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Although, this one define its output schema as ByteArray we fail this one as we do not know how to deserialize Student. Clearly, this is due to the bug in POUserFunc which fails to convert to ByteArray. Hence, res.result != null should be changed to result.result !=null.&lt;/p&gt;</comment>
                            <comment id="12889242" author="aniket486" created="Fri, 16 Jul 2010 18:51:38 +0100"  >&lt;p&gt;Added new test cases to test tuple and bag scenarios- moved to a new test file.&lt;br/&gt;
Fixed the exception handling.&lt;br/&gt;
Added detailed comments.&lt;/p&gt;</comment>
                            <comment id="12890840" author="ashutoshc" created="Wed, 21 Jul 2010 20:27:02 +0100"  >&lt;p&gt;Thanks, Aniket for making those changes. Its getting closer.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I am still not convinced about the changes required in POUserFunc. That logic should really be a part of pythonToPig(pyObject). If python UDF is returning byte[], it should be turned into DataByteArray before it gets back into Pig&apos;s pipeline. And if we do that conversion in pythonToPig() (which is a right place to do it) we will need no changes in POUserFunc.&lt;/li&gt;
	&lt;li&gt;As I suggested in previous comment in the same method you should avoid first creating Array and then turning that Array in list, you can rather create a list upfront and use it.&lt;/li&gt;
	&lt;li&gt;Instead of instanceof, doing class equality test will be a wee-bit faster. Like instead of (pyObject instanceof PyDictionary) do pyobject.getClass() == PyDictionary.class. Obviously, it will work when you know exact target class and not for the derived ones.&lt;/li&gt;
	&lt;li&gt;parseSchema(String schema) already exist in  org.apache.pig.impl.util.Utils class. So, no need for that in ScriptEngine&lt;/li&gt;
	&lt;li&gt;For register command, we need to test not only for functionality but for regressions as well. Look at TestGrunt.java in test package to get an idea how to write test for it.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12890845" author="ashutoshc" created="Wed, 21 Jul 2010 20:30:38 +0100"  >&lt;p&gt;Addendum:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Also what will happen if user returned a nil python object  (null equivalent of Java) from UDF. It looks to me that will result in NPE. Can you add a test for that and similar test case from pigToPython()&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12891357" author="aniket486" created="Thu, 22 Jul 2010 22:52:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;I am still not convinced about the changes required in POUserFunc. That logic should really be a part of pythonToPig(pyObject). If python UDF is returning byte[], it should be turned into DataByteArray before it gets back into Pig&apos;s pipeline. And if we do that conversion in pythonToPig() (which is a right place to do it) we will need no changes in POUserFunc.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I agree that it is better to move computation on JythonFunction side (JythonUtils) for type checking and should provide more type safety to avoid user defined types complexity. But I would still go for changes in POUserFunc for result.result for the case defined in above example (removing byte[] scenario).&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of instanceof, doing class equality test will be a wee-bit faster. Like instead of (pyObject instanceof PyDictionary) do pyobject.getClass() == PyDictionary.class. Obviously, it will work when you know exact target class and not for the derived ones.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Jython code has derived classes for each of the basic Jython types, though they aren&apos;t used for most of the types as of now, they may start returning these derived objects (PyTupleDerived) in their future implementation, in which case we might break our code. Also, PyLongDerived are already used inside the code. _&lt;em&gt;tojava&lt;/em&gt;_ function just returns the proxy java object until we ask for a specific type of object. I think its better to use instanceof instead of class equality here.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For register command, we need to test not only for functionality but for regressions as well. Look at TestGrunt.java in test package to get an idea how to write test for it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Code path for .jar registration is identical to old code, except that it doesnt &quot;use&quot; any engine or namespace.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Also what will happen if user returned a nil python object (null equivalent of Java) from UDF. It looks to me that will result in NPE. Can you add a test for that and similar test case from pigToPython()&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A java null object will be turned into PyNone object but _&lt;em&gt;tojava&lt;/em&gt;_ function will always returns the special object Py.NoConversion  if this PyObject can not be converted to the desired Java class.&lt;/p&gt;</comment>
                            <comment id="12891437" author="aniket486" created="Fri, 23 Jul 2010 01:56:27 +0100"  >&lt;p&gt;Added test for map-udf, null-inputoutput and grunt&lt;br/&gt;
Made required changes as per suggestions.&lt;/p&gt;</comment>
                            <comment id="12892368" author="daijy" created="Mon, 26 Jul 2010 17:55:45 +0100"  >&lt;p&gt;Patch committed. Thanks Aniket!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12495087">PIG-1794</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12526391">PIG-2317</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12448591" name="PIG-928.patch" size="9477" author="dvryaboy" created="Fri, 2 Jul 2010 20:06:14 +0100"/>
                            <attachment id="12447301" name="RegisterPythonUDF3.patch" size="9930" author="aniket486" created="Thu, 17 Jun 2010 02:38:25 +0100"/>
                            <attachment id="12447302" name="RegisterPythonUDF4.patch" size="26696" author="aniket486" created="Thu, 17 Jun 2010 02:45:48 +0100"/>
                            <attachment id="12448605" name="RegisterPythonUDFFinale.patch" size="32369" author="aniket486" created="Fri, 2 Jul 2010 23:51:43 +0100"/>
                            <attachment id="12448831" name="RegisterPythonUDFFinale3.patch" size="35353" author="aniket486" created="Tue, 6 Jul 2010 23:27:28 +0100"/>
                            <attachment id="12449105" name="RegisterPythonUDFFinale4.patch" size="41089" author="aniket486" created="Fri, 9 Jul 2010 19:52:11 +0100"/>
                            <attachment id="12449134" name="RegisterPythonUDFFinale5.patch" size="41122" author="aniket486" created="Sat, 10 Jul 2010 00:45:02 +0100"/>
                            <attachment id="12449686" name="RegisterPythonUDFLatest.patch" size="45705" author="aniket486" created="Fri, 16 Jul 2010 18:51:38 +0100"/>
                            <attachment id="12450251" name="RegisterPythonUDFLatest2.patch" size="52682" author="aniket486" created="Fri, 23 Jul 2010 01:56:27 +0100"/>
                            <attachment id="12449018" name="RegisterPythonUDF_Final.patch" size="40648" author="aniket486" created="Thu, 8 Jul 2010 22:57:40 +0100"/>
                            <attachment id="12446717" name="RegisterScriptUDFDefineParse.patch" size="2390" author="aniket486" created="Wed, 9 Jun 2010 19:25:20 +0100"/>
                            <attachment id="12445309" name="calltrace.png" size="720624" author="arnabdotorg" created="Mon, 24 May 2010 11:40:58 +0100"/>
                            <attachment id="12417038" name="package.zip" size="5425208" author="alangates" created="Wed, 19 Aug 2009 18:22:52 +0100"/>
                            <attachment id="12443152" name="pig-greek.tgz" size="5898041" author="julienledem" created="Thu, 29 Apr 2010 02:03:11 +0100"/>
                            <attachment id="12445307" name="pig.scripting.patch.arnab" size="17765" author="arnabdotorg" created="Mon, 24 May 2010 11:40:58 +0100"/>
                            <attachment id="12438720" name="pyg.tgz" size="5896880" author="julienledem" created="Sat, 13 Mar 2010 22:33:34 +0000"/>
                            <attachment id="12436245" name="scripting.tgz" size="45059" author="woody.anderson@gmail.com" created="Thu, 18 Feb 2010 20:52:51 +0000"/>
                            <attachment id="12434783" name="scripting.tgz" size="44354" author="woody.anderson@gmail.com" created="Thu, 4 Feb 2010 04:00:19 +0000"/>
                            <attachment id="12445308" name="test.zip" size="1766" author="arnabdotorg" created="Mon, 24 May 2010 11:40:58 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>19.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 16 Oct 2009 22:35:47 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>51023</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyakjz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>95641</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>