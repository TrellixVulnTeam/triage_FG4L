<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:04:54 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/PIG-2359/PIG-2359.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[PIG-2359] Support more efficient Tuples when schemas are known</title>
                <link>https://issues.apache.org/jira/browse/PIG-2359</link>
                <project id="12310730" key="PIG">Pig</project>
                    <description>&lt;p&gt;Pig Tuples have significant overhead due to the fact that all the fields are Objects.&lt;br/&gt;
When a Tuple only contains primitive fields (ints, longs, etc), it&apos;s possible to avoid this overhead, which would result in significant memory savings.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12531275">PIG-2359</key>
            <summary>Support more efficient Tuples when schemas are known</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dvryaboy">Dmitriy V. Ryaboy</assignee>
                                    <reporter username="dvryaboy">Dmitriy V. Ryaboy</reporter>
                        <labels>
                    </labels>
                <created>Sun, 13 Nov 2011 23:05:05 +0000</created>
                <updated>Fri, 22 Feb 2013 04:53:29 +0000</updated>
                            <resolved>Tue, 17 Jan 2012 01:40:49 +0000</resolved>
                                                    <fixVersion>0.11</fixVersion>
                                        <due></due>
                            <votes>1</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="13149388" author="dvryaboy" created="Sun, 13 Nov 2011 23:13:48 +0000"  >&lt;p&gt;The attached patch is a first cut at adding this support.&lt;/p&gt;

&lt;p&gt;Note that it changes the TupleFactory interface by adding a couple new methods for creating optimized tuples.&lt;/p&gt;

&lt;p&gt;Two flavors of optimized tuples are provided:&lt;/p&gt;

&lt;p&gt;1) For single-field tuple, we provide a PrimitiveFieldTuple, which simply wraps a primitive value (or a string). &lt;/p&gt;

&lt;p&gt;2) For multi-field tuples, we provide an implementation that uses a single bytebuffer to hold the data in memory, and deserializes the appropriate field on read. This incurs a bit of a read-time penalty, but I believe it&apos;s a good trade-off, since (a) most of the time we only read once, and the allocation costs are much lower than for regular tuples, and (b) the memory overhead is several times lower than for regular tuples, so we&apos;ll save on GC.&lt;/p&gt;

&lt;p&gt;Microbenchmark results can be found in the javadoc for PrimitiveTuple.&lt;/p&gt;

&lt;p&gt;Note that so far I haven&apos;t changed any behavior in existing Pig code, other than changing one interface. The next step would be to start using these Tuples when possible.&lt;/p&gt;

&lt;p&gt;One complication is that since we don&apos;t push much metadata around with tuples, we can only deserialize them into standard tuples; so all savings are lost once we hit an MR boundary. Changing this would require a pretty significant refactor, I&apos;d love to hear ideas from folks who worked on BinInterSedes on how to do this.&lt;/p&gt;

&lt;p&gt;So far, I&apos;ve played with using these in some UDFs that generate large bags of tuples, and the difference in both speed and memory use if fairly dramatic.&lt;/p&gt;</comment>
                            <comment id="13149398" author="azaroth" created="Sun, 13 Nov 2011 23:55:38 +0000"  >&lt;p&gt;Neat!&lt;br/&gt;
The patch is quite long, I will have a look at it later.&lt;br/&gt;
For the BinInterSedes, I think that adding a new byte type for each specific tuple and modifying readTuple() should do the trick.&lt;br/&gt;
I am a bit concerned about the access to PrimitiveTuple.&lt;br/&gt;
Specifically, do we always have the schema available when we need to read a field?&lt;/p&gt;</comment>
                            <comment id="13149409" author="dvryaboy" created="Mon, 14 Nov 2011 01:17:37 +0000"  >&lt;p&gt;Nope, it&apos;s more efficient to call type-specific getInteger, getLong, etc, but get() works.&lt;/p&gt;</comment>
                            <comment id="13149421" author="daijy" created="Mon, 14 Nov 2011 03:01:44 +0000"  >&lt;p&gt;Great first step! Some initial observations:&lt;br/&gt;
1. We can pass the schema into JobConf and read it back in BinInterSedes.setConf()&lt;br/&gt;
2. Support string in PrimitiveTuple is super helpful, is that in the plan?&lt;br/&gt;
3. BinInterSedes should take advantage of it to serialize/deserialize the PrimitiveTuple in a more efficient way&lt;/p&gt;

&lt;p&gt;Worth to mention we need to put fastutil_small.jar(&lt;a href=&quot;http://www.java2s.com/Code/Jar/f/Downloadfastutilsmalljar.htm&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.java2s.com/Code/Jar/f/Downloadfastutilsmalljar.htm&lt;/a&gt;) into lib in order to compile.&lt;/p&gt;</comment>
                            <comment id="13149422" author="dvryaboy" created="Mon, 14 Nov 2011 03:21:24 +0000"  >&lt;p&gt;Oops, fastutil wasn&apos;t supposed to make it into this patch, that&apos;s an experiment for later. I&apos;ll get rid of the PrimitiveBags in the next version of the patch.&lt;/p&gt;

&lt;p&gt;Putting the schemas into the JobConf is possible.. I am a little worried about having binary data that&apos;s not readable without an ephemeral job conf, though. Also, it&apos;ll be hard to figure out which tuple the schema is supposed to apply to &amp;#8211; we&apos;ll need to prefix the tuple with something, anyway. Maybe a header?&lt;/p&gt;

&lt;p&gt;The header would look like:&lt;br/&gt;
&lt;b&gt;magic_header_start&lt;/b&gt;; &lt;br/&gt;
byte tuple_schema_id; &lt;b&gt;magic_schema_start&lt;/b&gt;; byte type; byte type; ... &lt;b&gt;magic_schema_end&lt;/b&gt;;&lt;br/&gt;
byte tuple_schema_id; &lt;b&gt;magic_schema_start&lt;/b&gt;; byte type; byte type; ... &lt;b&gt;magic_schema_end&lt;/b&gt;;&lt;br/&gt;
byte tuple_schema_id; &lt;b&gt;magic_schema_start&lt;/b&gt;; byte type; byte type; ... &lt;b&gt;magic_schema_end&lt;/b&gt;;&lt;br/&gt;
&lt;b&gt;magic_header_end&lt;/b&gt;;&lt;/p&gt;

&lt;p&gt;Then, we introduce a SCHEMATUPLE value, like we did with TINY_TUPLE et al, and the serialized tuple would look like:&lt;br/&gt;
&lt;b&gt;SCHEMATUPLE&lt;/b&gt; &lt;b&gt;tuple_schema_id&lt;/b&gt; bytes.....&lt;br/&gt;
&lt;b&gt;SCHEMATUPLE&lt;/b&gt; &lt;b&gt;tuple_schema_id&lt;/b&gt; bytes.....&lt;/p&gt;

&lt;p&gt;I suppose we could also write the header in a separate tuple with high rep, to avoid a hotspot.&lt;/p&gt;</comment>
                            <comment id="13149539" author="azaroth" created="Mon, 14 Nov 2011 10:30:06 +0000"  >&lt;p&gt;For sure we need to represent the tuple like this:&lt;/p&gt;

&lt;p&gt;SCHEMATUPLE tuple_schema_id bytes...&lt;/p&gt;

&lt;p&gt;Because we do not want to put the schema in every tuple, we need a single place where there is a Map: tuple_schema_id -&amp;gt; tuple_schema&lt;br/&gt;
This map is anyway job specific, because tuple_schema_ids will be generated on the fly for the specific schema of the tuple used in the job.&lt;br/&gt;
JobConf looks like a good place to put this piece of information exactly because it is job specific.&lt;br/&gt;
I do not personally like much the idea of having metadata in a tuple with high replication, it looks a bit hacky to me.&lt;br/&gt;
I don&apos;t understand your concern, could you detail it a bit more? In any case the BinInterSedes tuple is ephemeral as the JobConf, and is not used for persisting data. So I assume your concern is not for users, but for developers and debugging, right?&lt;br/&gt;
It is true that the tuple will not be anymore self-describing, but this is the price to pay to have more efficient serialization format. What kind of problems do you think could arise?&lt;/p&gt;

&lt;p&gt;We can then discuss on the best way to represent this Map.&lt;/p&gt;</comment>
                            <comment id="13149802" author="dvryaboy" created="Mon, 14 Nov 2011 18:26:43 +0000"  >&lt;p&gt;It occurs to me that in effect, we &lt;b&gt;already&lt;/b&gt; have the schema next to every tuple in BinSedes, since we precede each field with a byte that describes the type. If for primitive tuples we simply put the type bytes first, and then write the bytes as they are stored in the byte buffer, we will have a super efficient read, and won&apos;t take up any more space than we do now.&lt;/p&gt;</comment>
                            <comment id="13150351" author="azaroth" created="Tue, 15 Nov 2011 10:26:47 +0000"  >&lt;p&gt;Yes, we already do that.&lt;br/&gt;
But that&apos;s because a byte is negligible when compared to the size of the rest of the tuple.&lt;br/&gt;
I think that if we want really a more efficient tuple implementation when schemas are known, we need to strip the schema from the data. What&apos;s the point of repeating the schema in each tuple apart from ease of implementation?&lt;br/&gt;
This modification might be done in a different Jira, while we can keep this one for the bytearray implementation.&lt;/p&gt;

&lt;p&gt;For the PrimitiveFieldTuple implementation, should we create a different byte for each tuple?&lt;br/&gt;
This way we can save on the size and schema byte and make it really compact.&lt;br/&gt;
Otherwise we could use a byte to indicate PRIMITIVE_FIELD_TUPLE and then a second one to indicate the schema (Double, Float, etc..)&lt;/p&gt;

&lt;p&gt;For the PrimitiveTuple, we would use PRIMITIVE_TUPLE, then the size as a byte (I assume we don&apos;t really use schemas with more than 255 primitives?), the schema (1 byte per type) and finally the data in the bytearray.&lt;br/&gt;
Actually, given that we are changing the serialization format, we don&apos;t need the schema to be 1 byte per type, but we could multiplex several fields in the same byte. We have 8 primitive types in Pig (by the way, should we also implement PByteTuple, PBooleanTuple?), so 3 bits will suffice. We can use 4 for alignment and expandability. This cuts by 50% the overhead due to schema.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="13150510" author="ashutoshc" created="Tue, 15 Nov 2011 14:17:16 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think that if we want really a more efficient tuple implementation when schemas are known, we need to strip the schema from the data. What&apos;s the point of repeating the schema in each tuple apart from ease of implementation?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Be careful with the assumption that schema is going to be same for all the rows in a data. Currently, Pig doesn&apos;t make this assumption and is thus able to work with tuples of varying schema in data. See, &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1131&quot; title=&quot;Pig simple join does not work when it contains empty lines&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1131&quot;&gt;&lt;del&gt;PIG-1131&lt;/del&gt;&lt;/a&gt; where a related optimization was attempted (and also &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1188&quot; title=&quot;Padding nulls to the input tuple according to input schema&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1188&quot;&gt;&lt;del&gt;PIG-1188&lt;/del&gt;&lt;/a&gt;). &lt;/p&gt;</comment>
                            <comment id="13150557" author="azaroth" created="Tue, 15 Nov 2011 15:34:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;Be careful with the assumption that schema is going to be same for all the rows in a data. Currently, Pig doesn&apos;t make this assumption and is thus able to work with tuples of varying schema in data. See, &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1131&quot; title=&quot;Pig simple join does not work when it contains empty lines&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1131&quot;&gt;&lt;del&gt;PIG-1131&lt;/del&gt;&lt;/a&gt; where a related optimization was attempted (and also &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-1188&quot; title=&quot;Padding nulls to the input tuple according to input schema&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-1188&quot;&gt;&lt;del&gt;PIG-1188&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes Ashutosh, you are right.&lt;br/&gt;
But when a user specifies a schema Pig enforces it on the data, so all the tuples have the same schema anyway.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
grunt&amp;gt; sh cat file.txt
1	2
1	2	3
1
	2

grunt&amp;gt; a = load &apos;file.txt&apos; AS (x1:&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, x2:&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
grunt&amp;gt; dump a
(1,2)
(1,2)
(1,)
(,2)

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we don&apos;t have a schema then we don&apos;t use this new kind of tuples.&lt;br/&gt;
Instead, I see a more general problem of how to handle the serialization of null fields with these new Tuple implementations.&lt;br/&gt;
The schema I proposed needs to be augmented with either a NULL_TYPE which makes us lose track of the original type in the tuple, or modify the schema to use 1 bit of each type byte.&lt;/p&gt;</comment>
                            <comment id="13150608" author="dvryaboy" created="Tue, 15 Nov 2011 16:59:37 +0000"  >&lt;p&gt;Ashutosh, your comment is correct in the general case, but in this case, we only use these special tuples when we know the schema from the get-go.&lt;/p&gt;

&lt;p&gt;I think 1 new byte for each of possible primitive single-field tuples (serialization: tuple_type, null_bit, serialized value), and 1 new primitive tuple (serialization: tuple_type, size, types, n_null_bits, bytearray) should work.&lt;/p&gt;

&lt;p&gt;To get around the limitation of 1 byte for expressing the # of fields in a tuple (just in case) we can limit ourselves to 127 per byte, and save the high bit to indicate that the next byte should be interpreted to contain the rest of the number (so, it would take 3 bits to express 256.. but we could. And most of the time, this won&apos;t matter, as the vast majority of the tuples is going to be well under 128 fields).&lt;/p&gt;

&lt;p&gt;There&apos;s some nastiness in Tuples where they all have internal &quot;isNull&quot; field that might be true to indicate the whole tuple is null. I am not sure what the deal is there. Do we need to write an extra bit per tuple to differentiate &quot;all fields are null&quot; from &quot;the tuple is null&quot;? Or should we just write the NULL byte (currently used to express null tuples) and let it be deserialize into a normal, not-primitive, tuple?&lt;/p&gt;</comment>
                            <comment id="13150698" author="daijy" created="Tue, 15 Nov 2011 19:27:08 +0000"  >&lt;p&gt;We don&apos;t even deal with isNull in BinInterSedes.&lt;/p&gt;</comment>
                            <comment id="13150727" author="azaroth" created="Tue, 15 Nov 2011 20:01:02 +0000"  >&lt;p&gt;I do not know about the semantics of isNull() in Tuple.&lt;br/&gt;
Is a Tuple null when all its fields are null?&lt;br/&gt;
In this case we are missing a piece in BinInterSedes.&lt;br/&gt;
I don&apos;t even know whether isNull() is used at all.&lt;br/&gt;
I would vote for the &quot;just write NULL byte and get over&quot; solution.&lt;/p&gt;

&lt;p&gt;Finally, I don&apos;t see where you reconstruct the &quot;nulls&quot; field from the serialized PrimitiveTuple, I am probably missing a piece.&lt;/p&gt;</comment>
                            <comment id="13156415" author="dvryaboy" created="Wed, 23 Nov 2011 23:48:49 +0000"  >&lt;p&gt;fwiw - I ripped all of the isNull stuff out of the tuple interface and implementations and things compile (so I guess it&apos;s never, ever called?). Extricating this change from my primitive tuples branch is a bit painful.. you guys cool with that change?&lt;/p&gt;</comment>
                            <comment id="13156642" author="azaroth" created="Thu, 24 Nov 2011 11:11:29 +0000"  >&lt;p&gt;Totally cool!&lt;br/&gt;
Do tests pass?&lt;/p&gt;</comment>
                            <comment id="13158158" author="daijy" created="Mon, 28 Nov 2011 03:16:20 +0000"  >&lt;p&gt;Seems Pig core is not using isNull, so not dealing with it in schema tuple implementation is totally fine. But I would like to keep the interface since it is marked public stable. &lt;/p&gt;</comment>
                            <comment id="13158301" author="azaroth" created="Mon, 28 Nov 2011 09:04:16 +0000"  >&lt;p&gt;Should we at least mark the method as deprecated and remove it in a future release?&lt;br/&gt;
This should also avoid someone starts using it and is also a form of documentation.&lt;/p&gt;</comment>
                            <comment id="13158616" author="scott_carey" created="Mon, 28 Nov 2011 18:34:13 +0000"  >
&lt;p&gt;One approach is to create a class on the fly, extending a base abstract tuple class and adding the fields for the schema.  &lt;/p&gt;

&lt;p&gt;Then a read is reading a field.  Nulls can be handled with a BitSet for objects with more than 32 fields, otherwise a bitmask on an int.  That can be baked into an abstract class so that code-gen needs to only add fields and map those to indexes.&lt;/p&gt;</comment>
                            <comment id="13159042" author="dvryaboy" created="Tue, 29 Nov 2011 02:12:35 +0000"  >&lt;p&gt;Scott, you are suggesting code-gen and compile on the fly during runtime?&lt;/p&gt;</comment>
                            <comment id="13159696" author="scott_carey" created="Wed, 30 Nov 2011 00:29:04 +0000"  >&lt;p&gt;Yes, using something like ASM (&lt;a href=&quot;http://asm.ow2.org/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://asm.ow2.org/&lt;/a&gt;) to fill out the fields and get() methods by extending an abstract class that is written in Java and has most of the work already done.&lt;/p&gt;

&lt;p&gt;A custom TupleFactory could have a static ThreadLocal&amp;lt;WeakHashMap&amp;lt;Schema, TupleBuilder&amp;gt;&amp;gt; or something similar, where the TupleBuilder and the Tuple it creates is created by dynamic class generation.&lt;/p&gt;

&lt;p&gt;The resulting objects would be memory compact and very fast.   I am tempted to try and implement it if I have some spare time.  I have been thinking about something similar for Avro, but the use case for Pig is significantly simpler.&lt;/p&gt;

&lt;p&gt;It would re-use the other changes above to the Tuple contract &amp;#8211; getLong() getInteger() etc.  I really like the idea of moving Tuple to have intrinsic getters.  There are some questions I have about the contract however &amp;#8211; what should be done if getLong is called for a field index containg an Integer?  promote?  Should it follow the rules in the Pig specification for type casts or throw an exception?&lt;/p&gt;
</comment>
                            <comment id="13159707" author="dvryaboy" created="Wed, 30 Nov 2011 00:36:22 +0000"  >&lt;p&gt;That&apos;s a sexy idea, I like it &amp;#8211; especially since it will let us handle strings in addition to numbers.&lt;br/&gt;
We&apos;ll have to implement the same codegen on the deseralization side, or somehow serialize generated class names.. that could get somewhat ugly. Doable, though. Could also try to serialize the codegenned classes using kryo.&lt;/p&gt;

&lt;p&gt;I&apos;ll finish up this patch and run some timing tests; unless you are ready to work on this right now, let&apos;s open a separate ticket for the codegen approach. &lt;/p&gt;</comment>
                            <comment id="13159739" author="scott_carey" created="Wed, 30 Nov 2011 01:51:48 +0000"  >&lt;p&gt;Yes, codegen should probably be a different ticket.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I understand why there is much to do on the serialization/deserialization side, but I have not looked into it in detaul.&lt;/p&gt;

&lt;p&gt;Conceptually, one can build an API for building pig tuples of this sort that is independent of the serialization used.  Given a Schema, get a TupleBuilder.  Fill it with data as you deserialize and create the Tuple.  The tuple implementation details (e.g. code gen vs old Object[] style Tuple) can both be supported.  Am I missing something?&lt;br/&gt;
If the schema is not known or varies per record, then a completely different code path must be taken.&lt;/p&gt;
</comment>
                            <comment id="13162526" author="dvryaboy" created="Mon, 5 Dec 2011 00:02:20 +0000"  >&lt;p&gt;Attaching patch with better serialization, deprecation of isNull, boolean support, and slightly better tests.&lt;/p&gt;</comment>
                            <comment id="13162547" author="dvryaboy" created="Mon, 5 Dec 2011 01:14:27 +0000"  >&lt;p&gt;Very rough (read: invalid, probably) speed test: modified SUM / LongSum to use a PLongTuple, and ran this code on excite.log from the tutorial:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
l = load &apos;tutorial/data/excite-big.log&apos; as (id:chararray, val:&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;, query:chararray);
x = foreach (group l all) generate SUM(l.val);

store x into &apos;/tmp/foo&apos;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Before optimization:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

real	0m14.785s
user	0m22.516s
sys	0m1.203s

real	0m15.323s
user	0m22.605s
sys	0m1.182s

real	0m14.841s
user	0m22.600s
sys	0m1.176s
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;after:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
real	0m14.347s
user	0m20.442s
sys	0m1.095s

real	0m14.344s
user	0m20.241s
sys	0m1.064s

real	0m14.577s
user	0m20.671s
sys	0m1.087s
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13165022" author="dvryaboy" created="Thu, 8 Dec 2011 06:22:08 +0000"  >&lt;p&gt;Found a place where this breaks. InternalCachedBag (and presumably other cached bags) use &amp;lt;code&amp;gt;t.write(out)&amp;lt;code&amp;gt; to spill to disk, and &amp;lt;code&amp;gt;t = factory.newTuple(); t.readFields(in)&amp;lt;code&amp;gt; to read. This is a problem as it assumes t will write itself in a format the default tuple returned by factory.newTuple() will read. Seems like a straightforward fix would be to use InterSedes to read, right? Any reason that wouldn&apos;t work?&lt;/p&gt;</comment>
                            <comment id="13165063" author="dvryaboy" created="Thu, 8 Dec 2011 07:31:54 +0000"  >&lt;p&gt;Fixed the bags. Added a test.&lt;/p&gt;</comment>
                            <comment id="13165680" author="dvryaboy" created="Thu, 8 Dec 2011 23:33:19 +0000"  >&lt;p&gt;Ok I think this is ready for review.&lt;/p&gt;</comment>
                            <comment id="13170363" author="azaroth" created="Thu, 15 Dec 2011 17:43:30 +0000"  >&lt;p&gt;I will try to have a look at it during the weekend if nobody else volunteers.&lt;/p&gt;</comment>
                            <comment id="13170640" author="alangates" created="Fri, 16 Dec 2011 00:50:25 +0000"  >&lt;p&gt;Comments:&lt;/p&gt;

&lt;p&gt;In PrimitiveTuple.get(), I wonder if you&apos;d get faster access if you removed the array bounds check.  Java is going to do that for you anyway.  You can catch the IndexOutOfBoundsException and rethrow it with a nicer error message.&lt;/p&gt;

&lt;p&gt;The same comment applies to checking whether the buffer capacity will be exceeded by reading the requested field.&lt;/p&gt;

&lt;p&gt;Also applies to set()&lt;/p&gt;

&lt;p&gt;Does append ever make sense for these types of tuples?  Should it just throw NotSupportedException?&lt;/p&gt;

&lt;p&gt;In the P*Tuple classes, when a user calls set(int pos, Object o), you are forcing o into the type of the tuple (e.g., for PIntTuple you are forcing it into an int).  This is a change of semantics from the general tuple contract where whatever you pass to set is taken to be the value for that field.  I would like to understand more about the use case when you would expect to see this used.  Is it that you want to force this to int because the data may or may not be all ints (like there may be some floats?).  I think it would be better to just take an int, and return a null and issue a warning if what you get isn&apos;t an int.  This still violates the semantic, but at least it doesn&apos;t silently produce a different result.  If the use case is only for the internal use of passing data between map and reducer or between MR jobs, then I definitely think we should forget all the checks and just assume the data is correct.&lt;/p&gt;

&lt;p&gt;You added new methods to the TupleFactory class, which is marked as Stable.  You&apos;ll need to provide default implementations of those to avoid breaking backward compatibility.&lt;/p&gt;

&lt;p&gt;Why is this patch changing http libraries?  (See the changes to ivy/library.properties.)&lt;/p&gt;</comment>
                            <comment id="13170754" author="dvryaboy" created="Fri, 16 Dec 2011 04:13:01 +0000"  >&lt;p&gt;Thanks for the close read, Alan!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In PrimitiveTuple.get(), I wonder if you&apos;d get faster access if you removed the array bounds check. Java is going to do that for you anyway. You can catch the IndexOutOfBoundsException and rethrow it with a nicer error message.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will do.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The same comment applies to checking whether the buffer capacity will be exceeded by reading the requested field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will do.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also applies to set()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will do&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Does append ever make sense for these types of tuples? Should it just throw NotSupportedException?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it makes sense, painful as it is &amp;#8211; users can get a PTuple handed to their UDF and unwittingly call append on it. I don&apos;t want existing scripts to crash, so trying to make things degrade nicely.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In the P*Tuple classes, when a user calls set(int pos, Object o), you are forcing o into the type of the tuple (e.g., for PIntTuple you are forcing it into an int). This is a change of semantics from the general tuple contract where whatever you pass to set is taken to be the value for that field. I would like to understand more about the use case when you would expect to see this used. Is it that you want to force this to int because the data may or may not be all ints (like there may be some floats?). I think it would be better to just take an int, and return a null and issue a warning if what you get isn&apos;t an int. This still violates the semantic, but at least it doesn&apos;t silently produce a different result. If the use case is only for the internal use of passing data between map and reducer or between MR jobs, then I definitely think we should forget all the checks and just assume the data is correct.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The use case isn&apos;t just internal, I started this in the first case because I needed to construct large tuple bags in a UDF. My reasoning for taking int value was that this is what we do when people &quot;cast&quot; a float to an int in pig. If you declare the schema to be an int, and put in a float... seems to me like having an int come out is ok. Could also die abruptly. I think null would be most surprising of the available choices.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You added new methods to the TupleFactory class, which is marked as Stable. You&apos;ll need to provide default implementations of those to avoid breaking backward compatibility.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good call, will do.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why is this patch changing http libraries? (See the changes to ivy/library.properties.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I did that when I was going to use ByteArrayBuffer, offered by httpcore. The nice thing about it is that it&apos;s resizable, but then again it doesn&apos;t have the r/wLong, r/wInt, etc methods, so I reverted to regular nio.ByteBuffer. There is no strict reason to change the libs, but it&apos;s a safe bump &amp;#8211; and the libs we are currently using are deprecated and replaced by the ones I bumped to (it&apos;s the same project, which got moved inside Apache). See &lt;a href=&quot;http://hc.apache.org/httpclient-3.x/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hc.apache.org/httpclient-3.x/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13171315" author="alangates" created="Fri, 16 Dec 2011 23:47:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;The use case isn&apos;t just internal, I started this in the first case because I needed to construct large tuple bags in a UDF. My reasoning for taking int value was that this is what we do when people &quot;cast&quot; a float to an int in pig. If you declare the schema to be an int, and put in a float... seems to me like having an int come out is ok. Could also die abruptly. I think null would be most surprising of the available choices.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When will these specialized tuple types get used?  Pig will use them internally when we expect a bag (or whatever) to contain that type.  Users can use them in UDFs they construct.  Are there are other cases where we envision them being used?  I agree my &quot;push it to null&quot; is just as arbitrary as your &quot;push to the type I expected&quot;.  I shy away from failing jobs on these kinds of errors because you hate for one row in a billion to fail an entire job.  I guess I&apos;m ok with your approach, though I think it should issue a warning (since it seems clear the user expected to find only one type in the data), and I think the Javadoc comments on the set() functions should clearly declare that this instance of the function bends the semantics of the interface.&lt;/p&gt;

&lt;p&gt;Performance wise, this looks very exciting.&lt;/p&gt;</comment>
                            <comment id="13171345" author="dvryaboy" created="Sat, 17 Dec 2011 00:16:01 +0000"  >&lt;p&gt;I have another branch-in-progress that pushes this into a bunch of Pig UDFs including max/min/avg. Just doing that shaved about 10 out of 84 seconds off each mapper in tpc-h Q1 in my (non-conclusive) experiments.&lt;/p&gt;

&lt;p&gt;I&apos;ll add the javadoc in the next version of the patch, thanks. Issuing a warning would potentially lead to log spam.. is there a handy counter?&lt;/p&gt;</comment>
                            <comment id="13171358" author="alangates" created="Sat, 17 Dec 2011 00:25:24 +0000"  >&lt;p&gt;Use the aggregated warnings, PigLogger.warn rather than log4j warn, to avoid the log spam.&lt;/p&gt;</comment>
                            <comment id="13173271" author="dvryaboy" created="Tue, 20 Dec 2011 16:02:42 +0000"  >&lt;p&gt;New patch addresses Alan&apos;s comments.&lt;/p&gt;</comment>
                            <comment id="13181781" author="dvryaboy" created="Sat, 7 Jan 2012 02:27:47 +0000"  >&lt;p&gt;Bump &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13183609" author="thejas" created="Tue, 10 Jan 2012 21:45:01 +0000"  >&lt;p&gt;I will review the patch by this weekend.&lt;/p&gt;</comment>
                            <comment id="13183639" author="scott_carey" created="Tue, 10 Jan 2012 22:23:52 +0000"  >&lt;p&gt;Performance comments:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In PrimitiveTuple.get(), I wonder if you&apos;d get faster access if you removed the array bounds check. Java is going to do that for you anyway. You can catch the IndexOutOfBoundsException and rethrow it with a nicer error message.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is generally slower.  &lt;br/&gt;
1. The JVM will detect your checks and not do its own bounds checks if yours are sufficient. (&lt;br/&gt;
2. The JVM will profile the method, and compile the checks with the right CPU branch hints and instruction layout based on the odds that the branch is taken.&lt;br/&gt;
3. If it is out of bounds, it is a hundred times faster to find out via an if statement than a try/catch.&lt;/p&gt;

&lt;p&gt;All of the above are much more noticeable if in a loop than a single access, so it may not help here much.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I did that when I was going to use ByteArrayBuffer, offered by httpcore. The nice thing about it is that it&apos;s resizable, but then again it doesn&apos;t have the r/wLong, r/wInt, etc methods, so I reverted to regular nio.ByteBuffer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Note, nio.ByteBuffer is &apos;slow&apos; (but very handy).  Unfortunately, all calls to it are virtual method calls and not inlined.  This is because of its dual heap / direct nature.  If serializnig data to a byte[], writing your own private method to swizzle the int/long into the bytes can have significant performance gains if it is a hot-spot in time spent since it will be inlined at critical call sites while ByteBuffer&apos;s methods will not.&lt;/p&gt;</comment>
                            <comment id="13183689" author="dvryaboy" created="Tue, 10 Jan 2012 23:17:01 +0000"  >&lt;p&gt;Sigh. I originally had my own swizzling code and ripped it out because nio.ByteBuffer made the code look nicer. I&apos;ll put it back in...&lt;/p&gt;

&lt;p&gt;Out of bounds crashes the job, so I don&apos;t think the speed of try/catch matters. &lt;/p&gt;</comment>
                            <comment id="13183690" author="scott_carey" created="Tue, 10 Jan 2012 23:17:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;The JVM will detect your checks and not do its own bounds checks if yours are sufficient&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;More info:&lt;br/&gt;
The JVM tries to eliminate array bounds checks.  It can do this in a few ways.  &lt;br/&gt;
There is the loop predication work that is in JRE 6_u22 or so and later that will move bound checks from inside a loop to the outside of the loop when it can.  Older JVMs can do similar, but in fewer situations.  This is both the intrinsic Java check and any you write yourself.  In fact, it tries to hoist all sorts of code outside the loop if it can, not just array bounds checks.&lt;br/&gt;
If it can prove that the value passed in is within range it may eliminate the bounds check.  This can be due to the index variable having a known range (0 to arr.length, for example) or a few other conditions.&lt;/p&gt;

&lt;p&gt;For a public virtual method like Tuple.get() it will almost never be able to inline the call at the call site, and so it may not ever be able to prove that it can remove the bounds checks.  In this sort of situation, there are two fast ways:  don&apos;t check yourself and let the exception bubble up, or check yourself and handle the out of bound condition yourself.  In general, catching an index out of bounds exception is slower than checking yourself since the JVM can prove that its own checks are useless with yours guarding them and exceptoin handling is much slower than a code branch.&lt;br/&gt;
In the condition that the method may be inlined aggressively (small private or effectively final methods especially) leaving manual checks out can be very fast since the JVM may be able to prove that none are necessary at all at a given call site.&lt;/p&gt;

&lt;p&gt;Variants can be performance tested and refined over time.  It doesn&apos;t have to be perfect now.&lt;/p&gt;</comment>
                            <comment id="13186028" author="alangates" created="Sat, 14 Jan 2012 00:41:28 +0000"  >&lt;p&gt;+1, latest patch looks good.  Looking forward to Pig flying a little faster.&lt;/p&gt;</comment>
                            <comment id="13187371" author="dvryaboy" created="Tue, 17 Jan 2012 01:40:49 +0000"  >&lt;p&gt;Committed to trunk.&lt;/p&gt;</comment>
                            <comment id="13187372" author="dvryaboy" created="Tue, 17 Jan 2012 01:41:14 +0000"  >&lt;p&gt;I now turn your attention to &lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-2454&quot; title=&quot;Make use of primitive tuples in builtin UDFs and operators&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-2454&quot;&gt;&lt;del&gt;PIG-2454&lt;/del&gt;&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13187560" author="azaroth" created="Tue, 17 Jan 2012 09:46:42 +0000"  >&lt;p&gt;Great job Dmitry!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12536776">PIG-2454</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12543829">PIG-2550</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12503556" name="PIG-2359.1.patch" size="65468" author="dvryaboy" created="Sun, 13 Nov 2011 23:13:48 +0000"/>
                            <attachment id="12506070" name="PIG-2359.2.patch" size="79959" author="dvryaboy" created="Mon, 5 Dec 2011 00:02:20 +0000"/>
                            <attachment id="12506582" name="PIG-2359.3.patch" size="100581" author="dvryaboy" created="Thu, 8 Dec 2011 07:31:54 +0000"/>
                            <attachment id="12508094" name="PIG-2359.4.patch" size="102226" author="dvryaboy" created="Tue, 20 Dec 2011 16:02:42 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 13 Nov 2011 23:55:38 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>217011</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyawtr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>97629</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>newTupleForSchema(Schema s) and newTupleForSchema(byte... types) methods are introduced to TupleFactory, allowing Pig to choose optimized Tuple implementations for specific schemas, when those are available.&lt;br/&gt;
&lt;br/&gt;
Two optimized implementations are introduced:&lt;br/&gt;
- single-value Tuples (tuples which only hold a single int, double, String, etc&lt;br/&gt;
- primitive-value Tuples (tuples which only hold values that can be represented by a fixed-width datatype in Java: int, long, double, boolean, float).&lt;br/&gt;
&lt;br/&gt;
Using such tuples can result in significant memory utilization improvements.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>