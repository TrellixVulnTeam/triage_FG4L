<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:15:57 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-106/SOLR-106.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-106] new facet params: facet.sort, facet.mincount, facet.offset</title>
                <link>https://issues.apache.org/jira/browse/SOLR-106</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;a couple of new facet params:&lt;br/&gt;
facet lists become pageable with facet.offset, facet.limit  (idea from Erik)&lt;br/&gt;
facet.sort explicitly specifies sort order (true for count descending, false for natural index order)&lt;br/&gt;
facet.mincount: minimum count for facets included in response (idea from JJ, deprecate zeros)&lt;/p&gt;</description>
                <environment></environment>
        <key id="12360491">SOLR-106</key>
            <summary>new facet params: facet.sort, facet.mincount, facet.offset</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Sun, 14 Jan 2007 06:09:22 +0000</created>
                <updated>Fri, 10 May 2013 11:40:28 +0100</updated>
                            <resolved>Tue, 16 Jan 2007 18:31:43 +0000</resolved>
                                                    <fixVersion>1.2</fixVersion>
                                    <component>search</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12464561" author="yseeley@gmail.com" created="Sun, 14 Jan 2007 06:14:33 +0000"  >&lt;p&gt;Attached untested code... I don&apos;t want to bother testing + adding test code w/o feedback on direction.&lt;/p&gt;

&lt;p&gt;Changes included in this code:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;facet.offset, facet.sort, facet.mincount support (detailed above)&lt;/li&gt;
	&lt;li&gt;avoid temporary HashMap when sort=false, add directly to response&lt;/li&gt;
	&lt;li&gt;for sorted case, keep track of min element in the queue to avoid needlessly adding pairs&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12464596" author="highstick" created="Sun, 14 Jan 2007 15:59:28 +0000"  >&lt;p&gt;What about a facet filter query to only return facets which match a certain query?&lt;/p&gt;

&lt;p&gt;In our case we use categories which are organized hierarchically via a path syntax.&lt;br/&gt;
Documets have different categories attached which is indexed by a solr field.&lt;/p&gt;

&lt;p&gt;Now certain apps (which deal with these documets) are interested in a specific category subpath.&lt;br/&gt;
If you use faceted searching you get all categories back - not only those in which the application is interested in.&lt;/p&gt;

&lt;p&gt;Currently we use a workaround which uses an additional solr search field that just contains the categories for the application, but this doesn&apos;t scale very well.&lt;br/&gt;
Would it be possible to add an additional filter query for facets to limit the facets which are actually returned in the faceted search?&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="12464652" author="hossman" created="Mon, 15 Jan 2007 04:34:36 +0000"  >&lt;p&gt;Yonik: i think all of these params make sense.  i only skimmed the code cahnges breifly but they look sound to me.&lt;/p&gt;

&lt;p&gt;Andreas: there was some discussion on the list about being able to specify a &quot;prefix&quot; that facet field values must match to be listed (which would trivial and efficient for TermEnum based facets, and doable for FieldCache facets) ... that makes a lot of sense to me in a &quot;type ahead&quot; word completion type of application (like google suggest) but the situation you describe doesn&apos;t relaly make sense to me &amp;#8211; if your client is only interested in documents in certain categories, then don&apos;t you want to filter the &lt;b&gt;documents&lt;/b&gt; by do just those categories (at which point the facets will also be filtered) ... can you start a thread on solr-user describing your situation/scaling issue?&lt;/p&gt;


</comment>
                            <comment id="12464658" author="skeptikos" created="Mon, 15 Jan 2007 05:54:21 +0000"  >&lt;p&gt;+1 on direction, and based on a quick scan of the patch.&lt;/p&gt;

&lt;p&gt;It could be sort=asc|desc|none rather than true|false, but I&apos;m not sure whether anyone would ever have a use for asc so it&apos;s probably not worth implementing.&lt;/p&gt;

&lt;p&gt;Of course extending to caching the facet tallies would dramatically speed paging.  Perhaps both getFieldCacheCounts and getFacetTermEnumCounts should return a Collection, which could be a BoundedTreeSet when sorting or a List implementation when not, holding all the counts &amp;gt;= facet.mincount; then getTermCounts could centralize the paging and response creation and provide an object to (someday) cache.  It would lose the mincount=0 optimization for getFieldCacheCounts, but how many users are really going to want mincounts=0 unless the list is small and non-sparse in which case the optimization isn&apos;t a big win anyway.&lt;/p&gt;</comment>
                            <comment id="12464661" author="yseeley@gmail.com" created="Mon, 15 Jan 2007 06:17:19 +0000"  >&lt;p&gt;I did have a reservation about always guaranteeing a sort order... I wasn&apos;t sure if it would always be easy to maintain term-sort order in future implementations.  If that were the case, &lt;b&gt;maybe&lt;/b&gt; it should be sort=count|term|none... might be more future-flexible, but harder to remember than a boolean.&lt;/p&gt;

&lt;p&gt;Just curious, what are your usecases for facet paging, and what percent of facet queries would have an offset other than 0?&lt;/p&gt;</comment>
                            <comment id="12464698" author="skeptikos" created="Mon, 15 Jan 2007 08:56:51 +0000"  >&lt;p&gt;Case for Facet Count Caching: Paging through the hitlist (as well as paging through the facet list).  In some cases it appears that generating the facet counts takes much longer than generating the hitlist.  And that&apos;s certainly the case when the hitlist is retrieved from cache.&lt;/p&gt;

&lt;p&gt;Case or Facet Paging:  The UI design I&apos;m doing back-end for has a list of facets with 5 top values each, and a &quot;More...&quot; link when there are indeed more than 5 facet values.  Traversing that link is supposed to show a page with all facet values which fit, and Prev and Next paging buttons to access those which don&apos;t.  This browser shows counts and can be sorted by count but by default is sorted alphabetically by term.  Next to each term is a checkbox; after browsing and checking, a button returns to the hitlist but adds a big OR of the checked terms as an fq. So for example if a user searches and gets 437 hits with rutabaga in the title, having 264 unique author names, they might want to browse the list looking for friends.  Then after browsing and checking they can see a hitlist of all articles written by friends with rutabage in the title.&lt;/p&gt;

&lt;p&gt;I don&apos;t have any idea what the proportion of facet queries would have offset &amp;gt; 0 e.g. where the user has moved to the next page, but I assume it&apos;s non-rare.&lt;/p&gt;

&lt;p&gt;It occurs to me that facet.limit should NOT do double-duty for paging: In a world where facet counts are cached, facet.limit should continue to play its current role, and limit the number of ranked values that make it into the BoundedTreeSet and thus the cache.  Then facet.offset and facet.count could be used to return a subset.  facet.limit==0 --&amp;gt; no limit, but can still be paged.&lt;/p&gt;

&lt;p&gt;Case for pulling response generation out of getFieldCacheCounts and getFacetTermEnumCounts:  I (truly) have a 37 million document index which I need to facet on Author, of which there are millions.  The TermEnum algorithm is clearly unsuited, and the FieldCache algorithm requires an inordinate amount of memory; I had to disable it.  So rather than tell management &quot;can&apos;t be done&quot;, I think I need to plug in at least one more algorithm, e.g. using TermFreqVectors, to SimpleFacets.  Would love not to have to replicate the response generation code.&lt;/p&gt;

&lt;p&gt;Or the sorting code.  Just had an idea:  It would be even nicer if the counting logic could be passed some object, say an implementation of TermCountRecorder, which has an add(String term, int count) method.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;That object would encapsulate and isolate the generation of CountPair objects, the filtering for mincount, and whatever varieties of sorting are supported.&lt;/li&gt;
	&lt;li&gt;Rather than have one object with multiple pathways e.g. for term vs. count vs. no sorting, a static factory method could take the field, sort, and mincount arguments and return an anonymous implementation based on a List or a TreeSet or whatever.&lt;/li&gt;
	&lt;li&gt;The factory could also be told whether the counting logic guarantees adding terms in term (index) order, and if not but if term order were requested it could return an implementation which sorts by term text, otherwise a simple List.&lt;/li&gt;
	&lt;li&gt;It could be the object that gets cached for that query for that field.&lt;/li&gt;
	&lt;li&gt;It could have a generateResponse(offset, count) method which generates the &amp;lt;list name=&quot;&amp;lt;facetfield&amp;gt;&quot;&amp;gt;&lt;/li&gt;
	&lt;li&gt;It could optimize memory when multiple TermCountRecorders corresponding to different queries are cached for a field, by maintaining a single WeakHashMap of term strings for the field, so each TermCountRecorder with the same term has a pointer to the same String object &amp;#8211; essentially like String.intern() but the scope is the field and the master value would disappear once all cached TermCountRecorders referencing it disappear.&lt;/li&gt;
	&lt;li&gt;It would make life much easier for a faceting approache where rather than iterating field-&amp;gt;document it might be more efficient to iterate document-&amp;gt;field (e.g. TermFreqVectors?): A TermCountRecorder could be allocated for each faceting field using that algorithm and have add(...) called in a round-robin fashion as documents are iterated. At the end all could be added to the cache and, whether added or retrieved, would have generateResponse called.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12465248" author="yseeley@gmail.com" created="Tue, 16 Jan 2007 18:31:43 +0000"  >&lt;p&gt;committed, with tests and other changes.&lt;br/&gt;
I&apos;ll work on updating docs shortly.&lt;/p&gt;</comment>
                            <comment id="12465254" author="yseeley@gmail.com" created="Tue, 16 Jan 2007 19:10:23 +0000"  >&lt;p&gt;Thanks for the info JJ... didn&apos;t see your update untill after I committed this (I&apos;m running a bit behind all the solr traffic &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; Case for Facet Count Caching: Paging through the hitlist &lt;/p&gt;

&lt;p&gt;Hmmm, yes that would be good for a more stateless client.  Even more efficient would be to recognize in the client that since you are only changing a page in the hitlist, the facets won&apos;t change (and hence don&apos;t re-query).&lt;/p&gt;

&lt;p&gt;&amp;gt; It occurs to me that facet.limit should NOT do double-duty for paging:&lt;/p&gt;

&lt;p&gt;Or, it should &lt;b&gt;only&lt;/b&gt; be used for paging, specifying the number to be returned.  The BoundedTreeSet size and caching are an implementation detail and shouldn&apos;t be in the API unless really necessary.  If it matters in the future, we could add a hint specifying how much &quot;extra&quot; should be computed.&lt;/p&gt;

&lt;p&gt;&amp;gt; Case for pulling response generation out of getFieldCacheCounts and getFacetTermEnumCounts&lt;/p&gt;

&lt;p&gt;Sure, makes sense.  Don&apos;t view the current facet code as &quot;done&quot;... I have a &lt;b&gt;lot&lt;/b&gt; of little ideas on how to make it better, esp for cases like faceting on author.&lt;/p&gt;

&lt;p&gt;&amp;gt; TermFreqVectors&lt;br/&gt;
Regarding this, do you have any performance data on it... my assumption was that it would be too slow for a large number of hits.  Perhaps still a good option to have if the number of hits are small and the fieldcache isn&apos;t an option though.&lt;/p&gt;

&lt;p&gt;&amp;gt; Just had an idea: It would be even nicer if the counting logic could be passed some object,&lt;br/&gt;
Yup, separating those things was on my todo list.&lt;/p&gt;

</comment>
                            <comment id="12589322" author="hossman" created="Wed, 16 Apr 2008 00:44:45 +0100"  >&lt;p&gt;This bug was modified as part of a bulk update using the criteria...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Marked (&quot;Resolved&quot; or &quot;Closed&quot;) and &quot;Fixed&quot;&lt;/li&gt;
	&lt;li&gt;Had no &quot;Fix Version&quot; versions&lt;/li&gt;
	&lt;li&gt;Was listed in the CHANGES.txt for 1.2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The Fix Version for all 39 issues found was set to 1.2, email notification&lt;br/&gt;
was suppressed to prevent excessive email.&lt;/p&gt;

&lt;p&gt;For a list of all the issues modified, search jira comments for this&lt;br/&gt;
(hopefully) unique string: 20080415hossman2&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12348916" name="facet_params.patch" size="10800" author="yseeley@gmail.com" created="Sun, 14 Jan 2007 06:11:06 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 14 Jan 2007 15:59:28 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7476</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxtd3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21076</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>