<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:19:34 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-182/SOLR-182.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-182] register SolrRequestHandlers at runtime / lazy loading</title>
                <link>https://issues.apache.org/jira/browse/SOLR-182</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;It would be useful to be able to register handlers after SolrCore has been initialized initialized.  It is also useful to be able to ask what handlers are registered and to where.  This patch adds the following functions to SolrCore:&lt;/p&gt;

&lt;p&gt;SolrRequestHandler registerRequestHandler(String handlerName, SolrRequestHandler handler);&lt;br/&gt;
Collection&amp;lt;SolrRequestHandler&amp;gt; getRequestHandlers(Class&amp;lt;? extends SolrRequestHandler&amp;gt; clazz);&lt;/p&gt;

&lt;p&gt;It also guarantees that request handlers will be initialized with an argument saying what path it is registered to.  RequestHandlerBase gets a bean for the registered path.&lt;/p&gt;

&lt;p&gt;While discussing this, Yonik suggested making it possible to defer initialization of some handlers that will be infrequently used.  I added the &apos;LazyRequestHandlerWrapper&apos;  (if taking this out makes the patch any easier to commit - it can get its own issue)&lt;/p&gt;

&lt;p&gt;check:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/Dynamic-RequestHandler-loading-tf3351707.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Dynamic-RequestHandler-loading-tf3351707.html&lt;/a&gt;&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12364186">SOLR-182</key>
            <summary>register SolrRequestHandlers at runtime / lazy loading</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ryantxu">Ryan McKinley</reporter>
                        <labels>
                    </labels>
                <created>Tue, 6 Mar 2007 00:46:50 +0000</created>
                <updated>Fri, 10 May 2013 11:39:28 +0100</updated>
                            <resolved>Mon, 26 Mar 2007 19:24:04 +0100</resolved>
                                                    <fixVersion>1.2</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12478229" author="ryantxu" created="Tue, 6 Mar 2007 00:57:31 +0000"  >&lt;p&gt;If you all are more comfortable with&lt;/p&gt;

&lt;p&gt; Collection&amp;lt;SolrRequestHandler&amp;gt; getRequestHandlers()&lt;/p&gt;

&lt;p&gt;then:&lt;/p&gt;

&lt;p&gt; Collection&amp;lt;SolrRequestHandler&amp;gt; getRequestHandlers(Class&amp;lt;? extends SolrRequestHandler&amp;gt; clazz)&lt;/p&gt;

&lt;p&gt;that is an easy change.  Likewise we can postpone the Lazy bit if it makes anything easier.&lt;/p&gt;

&lt;p&gt;I included tests for everything i think is testable about these changes, and added nice javadocs.&lt;/p&gt;
</comment>
                            <comment id="12478240" author="ryantxu" created="Tue, 6 Mar 2007 01:49:09 +0000"  >&lt;p&gt;changed this so that LazyRequestHandlerWrapper is not a public class.  That seems cleaner as it is not something that should be used directly&lt;/p&gt;</comment>
                            <comment id="12478529" author="ryantxu" created="Tue, 6 Mar 2007 19:31:12 +0000"  >&lt;p&gt;Updated in response to Hoss&apos; comments:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/Re%3A-Dynamic-RequestHandler-loading-p9337978.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Re%3A-Dynamic-RequestHandler-loading-p9337978.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1. gets rid of the get by class thing&lt;br/&gt;
2. adds Map&amp;lt;&amp;gt; getRequestHandlers() &lt;br/&gt;
3. gets rid of the extra param to init()&lt;/p&gt;
</comment>
                            <comment id="12478561" author="hossman" created="Tue, 6 Mar 2007 20:22:39 +0000"  >&lt;p&gt;two outstanding questions from the email discussion...&lt;/p&gt;

&lt;p&gt;1) yonik seemed to be concerned about synchronization issues involved with geting a request handler by name now that they can be registered dynamicly on the fly ... flarify that.&lt;/p&gt;

&lt;p&gt;2) if we want request handlers to be able to find out what nam(es) they are registered with (now that anyone can call core.registerRequestHandler I might give the exact same identicle instance multiple names) they should be able to do that from the init method ... since we aren&apos;t changing the API of the init method, we should probably make sure that registering a handler causes...&lt;br/&gt;
      handler = clazz.newInstance();&lt;br/&gt;
      this.register( name, handler );&lt;br/&gt;
      handler.init( args );&lt;br/&gt;
...to happen in that order.&lt;/p&gt;

&lt;p&gt;i would even argue that when registering multiple handlers (ie: from the config) we may want the psuedocode to be...&lt;/p&gt;

&lt;p&gt;    foreach (handlerconfig) &lt;/p&gt;
{
         handler = clazz.newInstance();
         this.register( name, handler );
    }
&lt;p&gt;    foreach (key in registry) &lt;/p&gt;
{
         lookup(key).init( args );
    }

&lt;p&gt;...so that all handlernames are defined before any init methods are called.&lt;/p&gt;

</comment>
                            <comment id="12478571" author="ryantxu" created="Tue, 6 Mar 2007 20:53:16 +0000"  >&lt;p&gt;#2, smart!  yes&lt;/p&gt;</comment>
                            <comment id="12478672" author="ryantxu" created="Wed, 7 Mar 2007 02:29:54 +0000"  >&lt;p&gt;This update loads handlers in the style suggested by Hoss.&lt;/p&gt;

&lt;p&gt;It makes sure everything is instanciated and registered before calling init() on any handlres registered in solrconfig.xml&lt;/p&gt;

&lt;p&gt;It calls init() on handlers in the order they were defined.&lt;/p&gt;

&lt;p&gt;The only open issue is if SolrCore.getRequestHandler() should be synchronized.  I can&apos;t think of any potential problems if it isn&apos;t but i could be missing something.&lt;/p&gt;

&lt;p&gt;I&apos;ll let whoever commits this decide if it should be synchronized or not.&lt;/p&gt;</comment>
                            <comment id="12479435" author="yseeley@gmail.com" created="Thu, 8 Mar 2007 21:37:07 +0000"  >&lt;p&gt;w.r.t. synchronization of getRequestHandler(), I was just thinking ahead to when registerRequestHandler() may be called after the constructor for SolrCore.&lt;/p&gt;

&lt;p&gt;Registration before initialization is interesting, but again, this only works easily if registerRequestHandler() is restricted to the SolrCore constructor.  If this were to change in the future, it would expose un-initialized handlers to requests.&lt;/p&gt;</comment>
                            <comment id="12479452" author="ryantxu" created="Thu, 8 Mar 2007 22:43:13 +0000"  >&lt;p&gt;The API in this patch lets you call SolrCofe.registerRequestHandler( path, handler ) at any point.  If you use this api, you are responsible to make sure the handler is initalized &amp;#8211; this may or may not require calling init( NamedList ) depending on the handler implementation.  &lt;/p&gt;

&lt;p&gt;The &quot;Registration before initialization&quot; is only save for SolrCore to use within its constructor.  RequestHandlers.registerHandlers( NodeList nodes ) - is package private and only called from the SolrCore constructor.&lt;/p&gt;

&lt;p&gt;I still don&apos;t see how synchronization becomes an issue - unless someone is trying a bizarro use case where someone registers a handler within SolrRequestHandler.handleRequest() and expects that &lt;b&gt;exactly&lt;/b&gt; the next request use the newly registered handler.  &lt;/p&gt;

&lt;p&gt;In my use case, I have a custom filter that extends SolrRequestDispatcher.  This filter initializes solr normally, then inspects what was registered and automatically sets up the rest of the environment.  &lt;/p&gt;</comment>
                            <comment id="12479488" author="yseeley@gmail.com" created="Fri, 9 Mar 2007 03:01:31 +0000"  >&lt;p&gt;If you modify the map in one thread and read from it in another thread, that requires synchronization to work correctly (even if it&apos;s a different entry being accessed).&lt;/p&gt;</comment>
                            <comment id="12479491" author="ryantxu" created="Fri, 9 Mar 2007 03:18:45 +0000"  >&lt;p&gt;But what is the failure mode?  &lt;/p&gt;

&lt;p&gt;Suppose, in thread A, I call:&lt;br/&gt;
  SolrCore.getSolrCore().registerRequestHandler( &quot;/path/to/handler&quot;, handler );&lt;/p&gt;

&lt;p&gt;then 5 seconds later in thread D, I call:&lt;br/&gt;
  SolrCore.getSolrCore().getRequestHandler( &quot;/path/to/handler&quot; )&lt;/p&gt;

&lt;p&gt;Can we be sure the new handler will be returned?  Is there any chance of anything exploding?  Is it only in the microseconds around touching the map that things are undefined?  &lt;/p&gt;

&lt;p&gt;If it is a graceful error (null or whatever was there before), i don&apos;t think this case needs to be synchronized.  If it is something else could happen, it should be.&lt;/p&gt;</comment>
                            <comment id="12479494" author="yseeley@gmail.com" created="Fri, 9 Mar 2007 03:45:06 +0000"  >&lt;p&gt;&amp;gt; But what is the failure mode? &lt;/p&gt;

&lt;p&gt;Any number of modes of failure.... it&apos;s very tough to predict them (I think you&apos;d have to be Doug Lea &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1)&lt;br/&gt;
   thread #1 does map.put(&quot;/path/to/handler&quot;, handler)&lt;br/&gt;
   thread #2 iterates over the map and gets a ConcurrentModificationException&lt;/p&gt;

&lt;p&gt;2)&lt;br/&gt;
  thread #1 does map.put(&quot;/path/to/handler&quot;, handler)&lt;br/&gt;
  thread #2 does map.put(&quot;/path/to/handler2&quot;, handler2)&lt;br/&gt;
  a) If they hash to the same bucket, one could overwrite the other&lt;br/&gt;
  b) one or both could cause resize() to be invoked... ouch!  many different modes of failure there&lt;/p&gt;

&lt;p&gt;3)&lt;br/&gt;
    thread #1 does map.put(&quot;/path/to/handler&quot;, handler) causing resize to be called()&lt;br/&gt;
    thread #2 does a map.get(&quot;/myexistinghandler&quot;) and it gets back null&lt;/p&gt;

&lt;p&gt;I&apos;d agree with you if the only mode of failure was to get back null for the current object being put in the map (since it&apos;s a race between threads anyway, null is a valid view - one should synchronize externally in that case anyway).  But, any insert can mess up all other reads.&lt;/p&gt;</comment>
                            <comment id="12479506" author="ryantxu" created="Fri, 9 Mar 2007 04:52:23 +0000"  >&lt;p&gt;synchronized it is!&lt;/p&gt;

&lt;p&gt;Rather then synchronizing each function call, I&apos;m using a synchonized map:&lt;/p&gt;

&lt;p&gt;  private final Map&amp;lt;String, SolrRequestHandler&amp;gt; handlers = Collections.synchronizedMap(&lt;br/&gt;
      new HashMap&amp;lt;String,SolrRequestHandler&amp;gt;() );&lt;/p&gt;</comment>
                            <comment id="12483794" author="hossman" created="Fri, 23 Mar 2007 23:40:34 +0000"  >&lt;p&gt;related note i&apos;m typing before i forget...&lt;/p&gt;

&lt;p&gt;in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-81&quot; title=&quot;Add Query Spellchecker functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-81&quot;&gt;&lt;del&gt;SOLR-81&lt;/del&gt;&lt;/a&gt; i tried to call SolrCore.getSolrCore.getDataDir() in the init method of a requestHandler and got an infinite loop.  I can&apos;t remember if this type of situation would be prevented by this patch or not ... if it isn&apos;t that doesn&apos;t mean this patch shouldn&apos;t be committed, it just means we should probably open a separate bug to try and detect/prevent/error in that situation.&lt;/p&gt;
</comment>
                            <comment id="12483796" author="ryantxu" created="Fri, 23 Mar 2007 23:46:31 +0000"  >&lt;p&gt;yes, that situation is handled by this patch.  This was one of my primary reasons for writing it!&lt;/p&gt;

&lt;p&gt;This patch lets you do call SolrCore.getCore() and inspect the schema/index/whatever.  Without it, you need to do some sort of lazy loading after the first request.&lt;/p&gt;</comment>
                            <comment id="12483871" author="yseeley@gmail.com" created="Sat, 24 Mar 2007 20:11:34 +0000"  >&lt;p&gt;A couple of comments...&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;For lazy loading, you don&apos;t even want to load the class if it&apos;s not used (loaded classes take up resources, and there may be optional jars that will cause errors).&lt;/li&gt;
	&lt;li&gt;it really seems like init() must be called before any calls to handleRequest.  To ensure this, I don&apos;t think we can do the registration inbetween.  This isn&apos;t just a hypothetical problem... think about when a new web page is published that causes a new type of request to start hitting an existing Solr server... 10s to 100s of requests per second for a new hander all of a sudden.  The likelihood becomes very high that another request will cause handleRequest() to be called before or concurrently with init().&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12483879" author="ryantxu" created="Sat, 24 Mar 2007 20:46:25 +0000"  >&lt;p&gt;&amp;gt; - For lazy loading, you don&apos;t even want to load the class if it&apos;s not used (loaded classes take up &lt;br/&gt;
&amp;gt; resources, and there may be optional jars that will cause errors).&lt;/p&gt;

&lt;p&gt;Ok - I&apos;m a little nervous about that because I like things to fail loudly at startup rather then wait to tell you they were configured incorrectly.  (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-179&quot; title=&quot;Save me from myself!  Abort on configuration errors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-179&quot;&gt;&lt;del&gt;SOLR-179&lt;/del&gt;&lt;/a&gt;)  But if you are using lazy loading, that is probably the behavior you would expect.&lt;/p&gt;

&lt;p&gt;I&apos;ll change it so that the LazyRequestHandlerWrapper stores the string value for the class name rather then the Class itself.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt; - it really seems like init() must be called before any calls to handleRequest.  &lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;yes, init() must be called before any call to handleRequest() - absolutely&lt;/p&gt;

&lt;p&gt;Correct me if I have the lifecycle wrong, but I think it is ok:&lt;/p&gt;

&lt;p&gt;1. SolrDispatchFilter.init() calls SolrCore.getSolrCore() &lt;br/&gt;
2. SolrCore.getSolrCore() calls SolrCore constructor&lt;br/&gt;
3. SolrCore constructor initalizes schema, listeners, index and writers&lt;br/&gt;
4. then calls reqHandlers.initHandlersFromConfig( SolrConfig.config )&lt;/p&gt;

&lt;p&gt;this function:&lt;br/&gt;
 a. creates each handler for solrconfig.xml and registers it&lt;br/&gt;
 b. calls init() on each handler - (since register was called first, each handler knows what else exists, but it may or may not be initialized)&lt;/p&gt;

&lt;p&gt;5. initialize searcher / updateHandler&lt;br/&gt;
6. SolrDispatchFilter.init() finishes and solr starts accepting requests.&lt;/p&gt;

&lt;p&gt;All handlers call init() before they could possibly receive any requests.  No requests can hit solr during the limbo period (a-b), It is only in the &quot;unstable&quot; state in the SolrCore constructor - I think the benefits of handlers knowing what else is registered during their init() method is worth the slightly awkward construction.&lt;/p&gt;

&lt;p&gt;The public interface:&lt;br/&gt;
 SolrCore.register( String handlerName, SolrRequestHandler handler )&lt;br/&gt;
assumes that the handler is properly initialized.  As soon as this is called it can immediately start accepting requests.  I will make the javadoc more clear on this point.  &lt;/p&gt;

&lt;p&gt;The only potentially dangerous function is (4) initHandlersFromConfig.  This is a package private function that defiantly should not be called anywhere else.  Calling this function twice is not normal, if someone does it, they are asking for trouble.&lt;/p&gt;</comment>
                            <comment id="12484055" author="ryantxu" created="Mon, 26 Mar 2007 08:50:02 +0100"  >&lt;p&gt;1. Changed the LazyRequestHandlerWrapper to hang on to a string rather then a class and does not access the class until it is needed.  (saves memory, but delays errors)&lt;/p&gt;

&lt;p&gt;2. Added more explicit documentation&lt;/p&gt;

&lt;p&gt;initHandlersFromConfig still registers all handlers before initializing them - i am confident this is ok unless it is called outside of the solr core constructor.&lt;/p&gt;</comment>
                            <comment id="12484140" author="yseeley@gmail.com" created="Mon, 26 Mar 2007 16:41:59 +0100"  >&lt;p&gt;&amp;gt; (saves memory, but delays errors) &lt;br/&gt;
Delays errors can also be a feature (if things need to be configured first, or jars need to be dropped in the right spot, etc).&lt;/p&gt;

&lt;p&gt;I think getWrappedHandler() needs to by synchronized or else&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;multiple instances could be instantiated&lt;/li&gt;
	&lt;li&gt;an instantiated instance could be handed back to a different thread before or during the handler&apos;s init()&lt;/li&gt;
	&lt;li&gt;general spookiness even after init() finishes due to lack of synchronization (initialized data won&apos;t necessarily be seen correctly in a different thread)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12484168" author="ryantxu" created="Mon, 26 Mar 2007 18:34:45 +0100"  >&lt;p&gt;One line change adding synchronized to:&lt;br/&gt;
  public synchronized SolrRequestHandler getWrappedHandler()&lt;/p&gt;

&lt;p&gt;thanks yonik&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt;&amp;gt; (saves memory, but delays errors) &lt;br/&gt;
&amp;gt; Delays errors can also be a feature (if things need to be configured first, or jars need to be dropped in the right spot, etc).&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;I&apos;m convinced.  With &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-179&quot; title=&quot;Save me from myself!  Abort on configuration errors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-179&quot;&gt;&lt;del&gt;SOLR-179&lt;/del&gt;&lt;/a&gt; you can configure things to stop after errors - if you want some things to stop while otheres continue, you can make them lazy loaded.&lt;/p&gt;

</comment>
                            <comment id="12484179" author="yseeley@gmail.com" created="Mon, 26 Mar 2007 19:24:04 +0100"  >&lt;p&gt;Committed.  Thanks Ryan!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12362978">SOLR-162</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12362978">SOLR-162</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12354234" name="SOLR-182-RuntimeRequestHandlers.patch" size="23814" author="ryantxu" created="Mon, 26 Mar 2007 18:34:45 +0100"/>
                            <attachment id="12354188" name="SOLR-182-RuntimeRequestHandlers.patch" size="23801" author="ryantxu" created="Mon, 26 Mar 2007 08:50:02 +0100"/>
                            <attachment id="12352957" name="SOLR-182-RuntimeRequestHandlers.patch" size="23679" author="ryantxu" created="Fri, 9 Mar 2007 04:52:23 +0000"/>
                            <attachment id="12352806" name="SOLR-182-RuntimeRequestHandlers.patch" size="22360" author="ryantxu" created="Wed, 7 Mar 2007 02:29:54 +0000"/>
                            <attachment id="12352778" name="SOLR-182-RuntimeRequestHandlers.patch" size="18640" author="ryantxu" created="Tue, 6 Mar 2007 19:31:12 +0000"/>
                            <attachment id="12352693" name="SOLR-182-RuntimeRequestHandlers.patch" size="22570" author="ryantxu" created="Tue, 6 Mar 2007 01:49:09 +0000"/>
                            <attachment id="12352690" name="SOLR-182-RuntimeRequestHandlers.patch" size="60693" author="ryantxu" created="Tue, 6 Mar 2007 00:57:30 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 6 Mar 2007 20:22:39 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7404</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxsw7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21000</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>