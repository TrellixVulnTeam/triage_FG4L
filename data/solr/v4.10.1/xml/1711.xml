<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:18:31 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-1711/SOLR-1711.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-1711] Race condition in org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.java</title>
                <link>https://issues.apache.org/jira/browse/SOLR-1711</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;While inserting a large pile of documents using StreamingUpdateSolrServer there is a race condition as all Runner instances stop processing while the blocking queue is full. With a high performance client this could happen quite often, there is no way to recover from it at the client side.&lt;/p&gt;

&lt;p&gt;In StreamingUpdateSolrServer there is a BlockingQueue called queue to store UpdateRequests, there are up to threadCount number of workers threads from StreamingUpdateSolrServer.Runner to read that queue and push requests to a Solr instance. If at one point the BlockingQueue is empty all workers stop processing it and pushing the collected content to Solr which could be a time consuming process, sometimes all worker threads are waiting for Solr. If at this time the client fills the BlockingQueue to full all worker threads will quit without processing any further and the main thread will block forever.&lt;/p&gt;

&lt;p&gt;There is a simple, well tested patch attached to handle this situation.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12445033">SOLR-1711</key>
            <summary>Race condition in org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.java</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                    <reporter username="a_babo">Attila Babo</reporter>
                        <labels>
                    </labels>
                <created>Fri, 8 Jan 2010 13:18:52 +0000</created>
                <updated>Wed, 18 Jan 2012 18:15:59 +0000</updated>
                            <resolved>Tue, 15 Feb 2011 21:39:54 +0000</resolved>
                                    <version>1.4</version>
                    <version>1.5</version>
                                    <fixVersion>3.1</fixVersion>
                    <fixVersion>4.0-ALPHA</fixVersion>
                                    <component>clients - java</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>3</watches>
                                    <timeoriginalestimate seconds="3600">1h</timeoriginalestimate>
                            <timeestimate seconds="3600">1h</timeestimate>
                                        <comments>
                            <comment id="12798007" author="a_babo" created="Fri, 8 Jan 2010 13:21:24 +0000"  >&lt;p&gt;Patch 1, 2:&lt;br/&gt;
Inside the Runner.run method I&apos;ve added a do while loop to prevent the Runner to quit while there are new requests, this handles the problem of new requests added while Runner is sending the previous batch.&lt;/p&gt;

&lt;p&gt;Patch 3&lt;br/&gt;
Validity check of method variable is not strictly necessary, just a code clean up.&lt;/p&gt;

&lt;p&gt;Patch 4&lt;br/&gt;
The last part of the patch is to move synchronized outside of conditional to avoid a situation where runners change while evaluating it.&lt;/p&gt;

&lt;p&gt;To minify the patch all indentation has been removed.&lt;/p&gt;</comment>
                            <comment id="12805109" author="yseeley@gmail.com" created="Tue, 26 Jan 2010 17:34:29 +0000"  >&lt;p&gt;Thanks Attila!  I just committed this.&lt;/p&gt;</comment>
                            <comment id="12849865" author="lukeforehand" created="Thu, 25 Mar 2010 19:29:33 +0000"  >&lt;p&gt;This is a very serious problem for us.  We have multiple threads adding to the StreamingUpdateSolrServer&apos;s BlockingQueue, and if I bump the thread count high enough (around 10 for my process) I can reproduce this problem every time.  I&apos;d say this bug is critical enough to warrant a SOLR bug-fix release.&lt;/p&gt;</comment>
                            <comment id="12872790" author="hossman" created="Fri, 28 May 2010 04:02:39 +0100"  >
&lt;p&gt;Correcting Fix Version based on CHANGES.txt, see this thread for more details...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-dev/201005.mbox/%3Calpine.DEB.1.10.1005251052040.24672@radix.cryptio.net%3E&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-dev/201005.mbox/%3Calpine.DEB.1.10.1005251052040.24672@radix.cryptio.net%3E&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12873376" author="hossman" created="Sun, 30 May 2010 05:43:24 +0100"  >&lt;p&gt;Committed revision 949473.&lt;/p&gt;

&lt;p&gt;merged to branch-1.4 for 1.4.1&lt;/p&gt;</comment>
                            <comment id="12978559" author="jtuchscherer" created="Thu, 6 Jan 2011 23:05:28 +0000"  >&lt;p&gt;We are still seeing the same issue with Solr1.4.1&lt;/p&gt;

&lt;p&gt;We get into this situation when all the runner threads die due to a broken pipe, while the BlockingQueue is still full. All of the producer threads are all blocked on the BlockingQueue.put() method. Since the runners are spawned by the producers, which are all blocked, runner threads never get created to drain the queue.&lt;/p&gt;

&lt;p&gt;Here&apos;s a potential fix. In the runner code, replace these lines:&lt;/p&gt;

&lt;p&gt;        // remove it from the list of running things...&lt;br/&gt;
        synchronized (runners) &lt;/p&gt;
{
          runners.remove( this );
        }

&lt;p&gt;with these lines:&lt;/p&gt;

&lt;p&gt;        // remove it from the list of running things unless we are the last runner and the queue is full...&lt;br/&gt;
        synchronized (runners) {&lt;br/&gt;
          if (runners.size() == 1 &amp;amp;&amp;amp; queue.remainingCapacity() == 0) &lt;/p&gt;
{
            // keep this runner alive
            scheduler.execute(this);
          }
&lt;p&gt; else &lt;/p&gt;
{
            runners.remove( this );
          }
&lt;p&gt;        }&lt;/p&gt;</comment>
                            <comment id="12987223" author="yseeley@gmail.com" created="Wed, 26 Jan 2011 21:18:21 +0000"  >&lt;p&gt;Thanks Johannes, the fix does look correct, and I&apos;ve committed to 3x and trunk.&lt;br/&gt;
If we have another release of 1.4, we should backport this.&lt;/p&gt;</comment>
                            <comment id="12992224" author="aakarsh" created="Tue, 8 Feb 2011 23:10:55 +0000"  >&lt;p&gt;We are still seeing this issue even after using Johannes fix. All runners are exiting  and the main producer thread hangs on line 196 queue.put . I am thinking it may be because queue is getting drained and filled fast (queue size 50 , number of threads 20) . So there might be a race condition on the queue capacity check.Queue appears to be below capacity to the last runner  &lt;br/&gt;
then  fills up by simultaneous calls to put . I still see the issue after backporting  what is in 3.x branch for testing it with solr 1.4.1. I guess a solution may be to use larger queue capacities for now but the race conditions still seem to be present.&lt;/p&gt;</comment>
                            <comment id="12994562" author="yseeley@gmail.com" created="Mon, 14 Feb 2011 23:36:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;So there might be a race condition on the queue capacity check.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah.  What about moving the queue.put() inside the synchronized(runners) block to fix this?&lt;/p&gt;</comment>
                            <comment id="12994903" author="yseeley@gmail.com" created="Tue, 15 Feb 2011 17:58:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;What about moving the queue.put() inside the synchronized(runners) block to fix this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;On second thought, that looks like a pretty bad idea &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Looks like a recipe for deadlock since the runners lock will be held if put then blocks. &lt;/p&gt;</comment>
                            <comment id="12994934" author="yseeley@gmail.com" created="Tue, 15 Feb 2011 19:08:20 +0000"  >&lt;p&gt;Here&apos;s a patch that uses offer instead of put in a retry loop.&lt;/p&gt;</comment>
                            <comment id="12995018" author="yseeley@gmail.com" created="Tue, 15 Feb 2011 21:39:54 +0000"  >&lt;p&gt;Committed the latest patch - hopefully that finally fixes this issue!&lt;/p&gt;</comment>
                            <comment id="13006352" author="goeller" created="Mon, 14 Mar 2011 08:51:32 +0000"  >&lt;p&gt;I tried out the comitted patch with SOLR 1.4.1 (built SOLR on my own). Unfortunately I still have an issue when having the following scenario:&lt;/p&gt;

&lt;p&gt;Server: Runs SOLR servlet&lt;br/&gt;
Client: Adds documents to the index using the StreamingUpdateSolrServer in several threads.&lt;/p&gt;

&lt;p&gt;If the server crashes or becomes unreachable for the client, the StreamingUpdateSolrServer on the client will end up in an infinite loop, trying to send requests to the server.&lt;br/&gt;
It should be possible to stop/shutdown/dispose the StreamingUpdateSolrServer somehow from another thread. &lt;/p&gt;

&lt;p&gt;Clearing the queue and stopping the executor service from outside stopps the infinite loop.&lt;/p&gt;</comment>
                            <comment id="13013174" author="gsingers" created="Wed, 30 Mar 2011 16:45:46 +0100"  >&lt;p&gt;Bulk close for 3.1.0 release&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12494894">SOLR-2308</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12471097" name="SOLR-1711.patch" size="2747" author="yseeley@gmail.com" created="Tue, 15 Feb 2011 19:08:20 +0000"/>
                            <attachment id="12429747" name="StreamingUpdateSolrServer.patch" size="1449" author="a_babo" created="Fri, 8 Jan 2010 13:21:24 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 26 Jan 2010 17:34:29 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5952</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxurqv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3314</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>