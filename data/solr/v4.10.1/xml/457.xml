<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:19:19 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-457/SOLR-457.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-457] A multi threaded implementation for solrJ</title>
                <link>https://issues.apache.org/jira/browse/SOLR-457</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;Provide a multi threaded implementation of CommonsHttpSolrServer&lt;br/&gt;
For usage with distributed searching in solr-303&lt;/p&gt;</description>
                <environment></environment>
        <key id="12386318">SOLR-457</key>
            <summary>A multi threaded implementation for solrJ</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="pjaol">patrick o&apos;leary</reporter>
                        <labels>
                    </labels>
                <created>Tue, 15 Jan 2008 22:46:01 +0000</created>
                <updated>Fri, 10 May 2013 11:41:14 +0100</updated>
                            <resolved>Fri, 25 Jan 2008 05:29:11 +0000</resolved>
                                    <version>1.3</version>
                                    <fixVersion>1.3</fixVersion>
                                    <component>clients - java</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12559266" author="pjaol" created="Tue, 15 Jan 2008 22:49:21 +0000"  >&lt;p&gt;Provides a multi-threaded implementation of CommonsHttpSolrServer&lt;br/&gt;
for use with distributed searching.&lt;br/&gt;
Example Usage :&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
          
          MultiThreadedHttpSolrServer mtserver = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiThreadedHttpSolrServer(&lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//&quot;&lt;/span&gt;+shards[0]);
&lt;/span&gt;          &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; first = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;

          ModifiableSolrParams params = sreq.params;
          params.remove(&lt;span class=&quot;code-quote&quot;&gt;&quot;wt&quot;&lt;/span&gt;); &lt;span class=&quot;code-comment&quot;&gt;// use &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; response format (or let SolrJ select)
&lt;/span&gt;          params.remove(&lt;span class=&quot;code-quote&quot;&gt;&quot;version&quot;&lt;/span&gt;);
          params.remove(&lt;span class=&quot;code-quote&quot;&gt;&quot;shards&quot;&lt;/span&gt;);      &lt;span class=&quot;code-comment&quot;&gt;// not a top-level request
&lt;/span&gt;          params.remove(&lt;span class=&quot;code-quote&quot;&gt;&quot;indent&quot;&lt;/span&gt;);
          params.remove(&lt;span class=&quot;code-quote&quot;&gt;&quot;echoParams&quot;&lt;/span&gt;);
          params.set(&lt;span class=&quot;code-quote&quot;&gt;&quot;isShard&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);  &lt;span class=&quot;code-comment&quot;&gt;// a sub (shard) request
&lt;/span&gt;
          &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; shard : shards) {
            &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; url = &lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//&quot;&lt;/span&gt; + shard;
&lt;/span&gt;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (! first){
            	mtserver.addSolrServer(&lt;span class=&quot;code-quote&quot;&gt;&quot;http:&lt;span class=&quot;code-comment&quot;&gt;//&quot;&lt;/span&gt;+shard);
&lt;/span&gt;            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
            	first = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
            }

          }
          
          &lt;span class=&quot;code-comment&quot;&gt;// process all the shards
&lt;/span&gt;          &lt;span class=&quot;code-comment&quot;&gt;// and retrive the responses
&lt;/span&gt;          
          QueryResponse[] responses = mtserver.process(params);
          &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; sz = responses.length;
          
          &lt;span class=&quot;code-comment&quot;&gt;// Responses are maintained in an array matching 
&lt;/span&gt;          &lt;span class=&quot;code-comment&quot;&gt;// the order they were added to the MultiThreadedSolrServer
&lt;/span&gt;          
          &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; sz; i++){
              ShardResponse srsp = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ShardResponse();
              srsp.req = sreq;
              srsp.shard = shards[i];
              
              srsp.rsp = responses[i];
              sreq.responses.add(srsp);
          }
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12559282" author="ryantxu" created="Tue, 15 Jan 2008 23:31:19 +0000"  >&lt;p&gt;Is this something that is only used in the distributed search context?  If so, it might make sense to put it in a package (or private class) that is limited to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-303&quot; title=&quot;Distributed Search over HTTP&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-303&quot;&gt;&lt;del&gt;SOLR-303&lt;/del&gt;&lt;/a&gt; related functions.&lt;/p&gt;

&lt;p&gt;I get a little scared that people would think they need to use &quot;MultiThreadedHttpSolrServer&quot; for multi threaded access &amp;#8211; the CommonsHttpSolrServer is mult threaded.&lt;/p&gt;</comment>
                            <comment id="12559308" author="pjaol" created="Wed, 16 Jan 2008 00:46:05 +0000"  >&lt;p&gt;Not too concerned about which package it&apos;s in.&lt;/p&gt;

&lt;p&gt;There is a need to clarify the multi threaded statement. CommonsHttpSolrServer is thread-safe using MultiThreadedHttpConnectionManager which provides pooling.&lt;/p&gt;

&lt;p&gt;However you still have to implement a thread or runnable class to use it in a threaded manor, otherwise the connections are serial. That&apos;s what this implementation does.&lt;/p&gt;

&lt;p&gt;Could be used in anything that requires a request to multiple solr instances, not just distributed search.&lt;br/&gt;
e.g.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;add / update / delete documents to multiple solr severs&lt;br/&gt;
      e.g real time indexing and not using a master - slave implementation&lt;/li&gt;
	&lt;li&gt;If federate search ever gets kicked off, it has possible uses there.&lt;/li&gt;
	&lt;li&gt;large scale monitoring, if you have 100 boxes, it will save you considerable time doing them in a threaded&lt;br/&gt;
   fashion than serially.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12559340" author="timmsc" created="Wed, 16 Jan 2008 03:14:46 +0000"  >&lt;p&gt;Currently with Solrj, if you want to take advantage of the connection pooling, I think you need to create a single instance of CommonsHttpSolrServer in your application (and if you aren&apos;t, you are better off using SimpleHttpConnectionManager).  So, it seems to make sense to make it easier to use in this fashion.  This could be made more general purpose though if process just took a single request and returned a single response and you called it once for each server.  This would abstract out the threading and connection pooling while not constraining the class to something designed primarily for &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-303&quot; title=&quot;Distributed Search over HTTP&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-303&quot;&gt;&lt;del&gt;SOLR-303&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A couple of other comments:&lt;/p&gt;

&lt;p&gt;The threads should probably be pooled rather than creating and destroying on each request.  While creating and destroying threads has gotten faster, pooling is usually beneficial.&lt;/p&gt;

&lt;p&gt;Unless I&apos;m mistaken, it appears that your connectionManager is different from the _connectionManager in CommonsHttpSolrServer, so the methods that you didn&apos;t override will not work correctly, e.g., setConnectionTimeout().&lt;/p&gt;

&lt;p&gt;Neither the CommonsHttpSolrServer currently in Solrj nor this patch appear to allow setting of the read timeout: setSoTimeout(int timeout) or the connection manager timeout: setConnectionManagerTimeout(long timeout).  Other HttpClient options such as disabling Nagle&apos;s algorithm are probably not as important.  This should probably be opened as a separate JIRA issue (edit: see &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-462&quot; title=&quot;Performance related enhancements to Solrj&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-462&quot;&gt;&lt;del&gt;SOLR-462&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="12559349" author="pjaol" created="Wed, 16 Jan 2008 04:36:40 +0000"  >&lt;p&gt;In terms of reusing threads I used Executors.newCachedThreadPool which should maintain a static pool of threads. Or so it says in the documentation. I&apos;ll try profiling it when I get a chance.&lt;/p&gt;

&lt;p&gt;The _connectionManger yep that&apos;s a good spot, need to overwrite &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; HttpClient getHttpConnection() {
	&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HttpClient(getConnectionManager());
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Makes sense to change the CommonsHttpSolrServer setConnectionTimeout, setDefaultMaxConnectionsPerHost, setMaxTotalConnections to call getConnectionManager() instead of using _connectionManager&lt;br/&gt;
unless having a setConnectionManager makes more sense.&lt;/p&gt;

&lt;p&gt;At the moment I&apos;ve just added a setConnectionManager in the MultiThreadedHttpSolrServer, but that leaves me wondering do I need to abstract the connection manger in the client implementation or is that over kill.&lt;br/&gt;
Because there will always be something new to set in your connection manager.&lt;/p&gt;</comment>
                            <comment id="12561868" author="yseeley@gmail.com" created="Wed, 23 Jan 2008 23:31:41 +0000"  >&lt;p&gt;OK, I&apos;m just getting back to distributed search stuff...&lt;/p&gt;

&lt;p&gt;My first inclination on how to handle this (the SolrJ part) was to&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;add a constructor to CommonsHttpSolrServer that takes an HttpClient&lt;/li&gt;
	&lt;li&gt;add a getHttpClient()&lt;/li&gt;
	&lt;li&gt;perhaps remove methods that deal with setting connection timeouts, etc... don&apos;t duplicate the interface of HttpClient&lt;/li&gt;
	&lt;li&gt;add a constructor with common settings (timeout, retry, etc) for when the user doesn&apos;t supply the HttpClient&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Then, in distributed search land, we could either create SolrServers on the fly (having them all share a single HttpClient), or if SolrServers are expensive to create, we could cache them per shard.&lt;/p&gt;

&lt;p&gt;Looking at this particular patch, I&apos;m not sure it&apos;s the right direction.  It maintains a list of solr servers and sends the same request to each.  There are a number of places in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-303&quot; title=&quot;Distributed Search over HTTP&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-303&quot;&gt;&lt;del&gt;SOLR-303&lt;/del&gt;&lt;/a&gt; where we need to send different requests to different shards (so we would be unable to re-use a single MultiThreadedHttpSolrServer.&lt;/p&gt;

&lt;p&gt;I think we also need to be clear in SolrJ (i.e. in the javadoc) what is thread-safe and what is not.&lt;/p&gt;</comment>
                            <comment id="12561924" author="pjaol" created="Thu, 24 Jan 2008 02:43:38 +0000"  >&lt;p&gt;An idea I&apos;ve been thinking about is to change the addSolrServer to also include solr params&lt;br/&gt;
for each shard. &lt;br/&gt;
Definitely to get docs by id, it would be cleaner.&lt;/p&gt;

&lt;p&gt;The real purpose of the patch is to execute the individual shard requests as concurrent threads. &lt;br/&gt;
To give you an idea, an implementation I&apos;ve tested this on, the patch took a 200ms request down&lt;br/&gt;
to 42ms.&lt;/p&gt;

&lt;p&gt;This may seem overkill to most folks, but is critical for my needs.&lt;/p&gt;

&lt;p&gt;From load testing, I haven&apos;t noticed any significant over head in creating new MultiThreadedHttpSolrServers&lt;br/&gt;
SolrServers creation seem light as well, it&apos;s only processing the request that appears to be the main&lt;br/&gt;
work horse.&lt;/p&gt;

&lt;p&gt;I&apos;ll make some changes now that &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-462&quot; title=&quot;Performance related enhancements to Solrj&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-462&quot;&gt;&lt;del&gt;SOLR-462&lt;/del&gt;&lt;/a&gt; is added, as I don&apos;t need the overrides. &lt;/p&gt;</comment>
                            <comment id="12561926" author="yseeley@gmail.com" created="Thu, 24 Jan 2008 02:55:16 +0000"  >&lt;p&gt;&amp;gt; This may seem overkill to most folks, but is critical for my needs.&lt;/p&gt;

&lt;p&gt;Oh, no question that parallel requests is a requirement... distributed search would be a joke without it.&lt;/p&gt;

&lt;p&gt;I think for now though, we should put the bare minimum in SolrJ that we think is correct.  Some method of sharing a common connection pool (and perhaps the HttpClient too) is the critical part.  Spinning up threads, or using a thread pool, can be accomplished in the distributed search code for now.&lt;/p&gt;

&lt;p&gt;Allowing a user to specify the HttpClient to use for communication seems to be the most powerful option as it doesn&apos;t cover up any of the HttpClient API.&lt;/p&gt;</comment>
                            <comment id="12562202" author="yseeley@gmail.com" created="Thu, 24 Jan 2008 20:29:44 +0000"  >&lt;p&gt;I&apos;m taking a crack at cleaning up some SolrJ stuff... can someone tell me why the concept of a core is in SolrJ?&lt;br/&gt;
A core is a solr instance... surely one can just create another SolrServer to talk to it?&lt;/p&gt;</comment>
                            <comment id="12562215" author="ryantxu" created="Thu, 24 Jan 2008 20:54:42 +0000"  >&lt;p&gt;It is there so that multicore reload/swap/etc are all accessible with the same interface for embedded and remote.  If we only had the remote case, it would not be necessary, but the embedded version can get stale references.&lt;/p&gt;

&lt;p&gt;As I try to justify it now, I can think of some other ways to do that &amp;#8211; now that the core is required to be selected in the path.  I&apos;ll open a new issue for that and tackle it before 1.3 release.&lt;/p&gt;

&lt;p&gt;ryan&lt;/p&gt;</comment>
                            <comment id="12562268" author="yseeley@gmail.com" created="Thu, 24 Jan 2008 22:52:37 +0000"  >&lt;p&gt;Here are some proposed updates (see solrj.patch) to SolrJ:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;change some interfaces to abstract classes (good to do it now since SolrServer was just changed.... people have to recompile anyway)&lt;/li&gt;
	&lt;li&gt;allow specification of HttpClient when constructing the SolrServer... this allows the user to choose how to share things... a single HttpClient for all SolrServers, a new HttpClient for each SolrServer all sharing a single connection manager, etc.&lt;/li&gt;
	&lt;li&gt;added a method on ResponseParser that takes an InputStream.  Two reasons: often other parsers can do better / faster encoding than InputStreamReader, and there could be binary formats in the future.  XMLResponseParser was changed to use an InputStream if supplied.&lt;/li&gt;
	&lt;li&gt;The factory in XMLResponseParser was changed to be static... each parser shouldn&apos;t have their own factory.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12562314" author="ryantxu" created="Fri, 25 Jan 2008 00:34:18 +0000"  >&lt;p&gt;these changes look good to me..  &lt;/p&gt;

&lt;p&gt;If we change SolrRequest to an abstract super class, there is probably no good reason to also have RequestBase.&lt;/p&gt;

&lt;p&gt;While we are at it, should SolrResponse change to an abstract class?  I can&apos;t think of any reason it would need to be an interface.  (I think we should keep SolrResponseBase as is)&lt;/p&gt;</comment>
                            <comment id="12562366" author="yseeley@gmail.com" created="Fri, 25 Jan 2008 05:29:11 +0000"  >&lt;p&gt;committed (with recommended changes).&lt;br/&gt;
I&apos;m resolving this bug, as I think the rest of the mult-threadedness that is needed for distributed search belongs there.&lt;/p&gt;

&lt;p&gt;There &lt;b&gt;is&lt;/b&gt; more MT support needed in SolrJ, but in the form of performance enhancements when indexing to a single SolrServer I think.  Something that will enable multiple indexing threads without requiring the user write a multi-threaded client.  It should be relatively easy with the Java5 concurrency stuff.&lt;/p&gt;</comment>
                            <comment id="12589283" author="hossman" created="Wed, 16 Apr 2008 00:28:41 +0100"  >&lt;p&gt;This bug was modified as part of a bulk update using the criteria...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Currently marked (&quot;Resolved&quot; or &quot;Closed&quot;) and &quot;Fixed&quot;&lt;/li&gt;
	&lt;li&gt;Had no &quot;Fix Version&quot; versions&lt;/li&gt;
	&lt;li&gt;&quot;Affects Versions&quot; included 1.3&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The Fix Version for all 8 issues found was set to 1.3 (1.3 has not yet been released, if an issue is already fixed, and it affected 1.3 then the fix will be in 1.3)&lt;/p&gt;

&lt;p&gt;Email notification was suppressed to prevent excessive email.&lt;/p&gt;

&lt;p&gt;For a list of all the issues modified, search jira comments for this&lt;br/&gt;
(hopefully) unique string:  20080415hossman1&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12373210" name="multithreaded-solrj.patch" size="4636" author="pjaol" created="Tue, 15 Jan 2008 22:49:21 +0000"/>
                            <attachment id="12373984" name="solrj.patch" size="12827" author="yseeley@gmail.com" created="Thu, 24 Jan 2008 22:52:36 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 15 Jan 2008 23:31:19 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7147</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxr7z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20729</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>