<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:17:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-683/SOLR-683.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-683] Distributed Search / Shards Deadlock</title>
                <link>https://issues.apache.org/jira/browse/SOLR-683</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;Per this discussion:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/Distributed-Search-Strategy---Shards-td18882112.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Distributed-Search-Strategy---Shards-td18882112.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Solr seems to lock up when running distributed search on three servers, with all three using shards of each other.  Thread dump attached.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Linux&lt;br/&gt;
jre1.6.0_05&lt;br/&gt;
8GB RAM&lt;br/&gt;
2 x 2 core AMD 2.4 Ghz&lt;br/&gt;
2 x 140GB disk&lt;/p&gt;</environment>
        <key id="12401948">SOLR-683</key>
            <summary>Distributed Search / Shards Deadlock</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                    <reporter username="cameronl">Cameron</reporter>
                        <labels>
                    </labels>
                <created>Fri, 8 Aug 2008 02:07:06 +0100</created>
                <updated>Fri, 10 May 2013 11:41:04 +0100</updated>
                            <resolved>Tue, 12 Aug 2008 15:46:01 +0100</resolved>
                                    <version>1.3</version>
                                    <fixVersion>1.3</fixVersion>
                                    <component>search</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12621584" author="yseeley@gmail.com" created="Mon, 11 Aug 2008 21:41:06 +0100"  >&lt;p&gt;Here&apos;s the problem: deadlock is possible when the max number of concurrent HTTP requests is less than the number of possible HTTP requests (from both top-level clients, and by other shards).&lt;/p&gt;

&lt;p&gt;Consider the simplest case of two shards, each with just a single thread dedicated to handling incoming HTTP requests.  A top-level request comes into each shard, and each shard queries the other.  The second request to each shard blocks because the first thread has not yet completed.  Deadlock.&lt;/p&gt;</comment>
                            <comment id="12621594" author="cameronl" created="Mon, 11 Aug 2008 21:54:27 +0100"  >&lt;p&gt;So this seems to be a container level issue, not a Solr issue?&lt;/p&gt;</comment>
                            <comment id="12621612" author="yseeley@gmail.com" created="Mon, 11 Aug 2008 22:34:19 +0100"  >&lt;p&gt;I duplicated a deadlock with two shards with 1000 client threads making requests.&lt;br/&gt;
When I changed the maxThreads parameter from 250 to 10000 (in jetty.xml), the deadlocks went away... I was able to run through 1M requests.&lt;/p&gt;</comment>
                            <comment id="12621616" author="yseeley@gmail.com" created="Mon, 11 Aug 2008 22:41:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;So this seems to be a container level issue, not a Solr issue?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes and no... it&apos;s not a low-level solr bug, and it can be solved by upping the number of concurrent threads or http requests in the container.&lt;/p&gt;

&lt;p&gt;But if we could set a read timeout on shard requests, we could also prevent a hard deadlock and return an error instead.  In any case, we should increase the number of threads in the example jetty config and document this issue.&lt;/p&gt;</comment>
                            <comment id="12621642" author="cameronl" created="Tue, 12 Aug 2008 00:00:25 +0100"  >&lt;p&gt;We could up the number of threads in our container, but this does not completely resolve the issue, as any sort of denial of service attack would potentially cause this to happen with no possible way of recovery.  I would agree that some sort of timeout would be needed to actually solve the issue.&lt;/p&gt;</comment>
                            <comment id="12621666" author="larsko" created="Tue, 12 Aug 2008 02:17:10 +0100"  >&lt;p&gt;Another way to handle this would be to configure the servlet container to reject incoming connections when all available threads are in use &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;. This will cause failed requests which could have been served after a short wait, but eliminates the deadlock problem.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://docs.codehaus.org/display/JETTY/Configuring+Connectors&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.codehaus.org/display/JETTY/Configuring+Connectors&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://tomcat.apache.org/tomcat-6.0-doc/config/http.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://tomcat.apache.org/tomcat-6.0-doc/config/http.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12621836" author="yseeley@gmail.com" created="Tue, 12 Aug 2008 15:46:01 +0100"  >&lt;p&gt;The problem with a read timeout is it would cause otherwise perfectly acceptable requests to fail, even if the system is not under load (since we can&apos;t put an upper bound on how long a request can take).&lt;/p&gt;

&lt;p&gt;I&apos;m resolving this for now since I upped the max threads in the example jetty.xml to 10K and documented the issue on the distributed search wiki page.&lt;/p&gt;

&lt;p&gt;If the servlet container can be configured to reject requests rather than blocking, that would probably be the ideal scenario.  If anyone knows if Jetty can be configured to do that, we can add it to the solr example.&lt;/p&gt;</comment>
                            <comment id="12622058" author="larsko" created="Wed, 13 Aug 2008 02:08:08 +0100"  >&lt;p&gt;Attaching patch which adds the configuration parameter to have an accept queue size of 0 to jetty.xml, along with a reference to this issue and a boilerplate warning.&lt;/p&gt;</comment>
                            <comment id="12622700" author="yseeley@gmail.com" created="Thu, 14 Aug 2008 22:06:28 +0100"  >&lt;p&gt;Hmmm I see this was just committed, but are we sure it works?&lt;br/&gt;
Isn&apos;t acceptQueueSize just the network level connection queue size for the socket (as normally set by the listen sys call)?&lt;br/&gt;
When jetty runs out of handler threads, does it not accept new connections, or does it accept the connection and wait for a thread to become free to handle it?&lt;br/&gt;
If the former, then this patch should work.  If the latter, it won&apos;t.&lt;/p&gt;</comment>
                            <comment id="12622705" author="markrmiller@gmail.com" created="Thu, 14 Aug 2008 22:18:08 +0100"  >
&lt;p&gt;&amp;gt;&amp;gt; When jetty runs out of handler threads, does it not accept new connections, or does it accept the connection and wait for a thread to become free to handle it?&lt;/p&gt;

&lt;p&gt;Not sure if this is still the case, but I believe Jetty did just use the standard socket backlog queue and set it by default to the number of service threads - so you can have that many threadless requests queued up. Dunno if they changed that recently or not.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12622706" author="otis" created="Thu, 14 Aug 2008 22:19:15 +0100"  >&lt;p&gt;Hm, hard to tell from sparse Jetty javadocs.&lt;br/&gt;
&lt;a href=&quot;http://docs.codehaus.org/display/JETTY/Configuring+Connectors&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.codehaus.org/display/JETTY/Configuring+Connectors&lt;/a&gt; states:&lt;/p&gt;

&lt;p&gt;acceptQueueSize 	 Number of connection requests that can be queued up before the operating system starts to send rejections.&lt;/p&gt;

&lt;p&gt;Sounds more like the latter than the former.  That is, it sounds like Jetty itself might accept connections until the OS starts complaining.  Hm, either way this doesn&apos;t help if one has an actual deadlock, like the one you described in the 1-thread-example, does it?&lt;/p&gt;</comment>
                            <comment id="12622764" author="larsko" created="Fri, 15 Aug 2008 02:16:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;Not sure if this is still the case, but I believe Jetty did just use the standard socket backlog queue&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A quick look at the code suggests that this is still the case (at least for version 6.1.3 bundled with Solr).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When jetty runs out of handler threads, does it not accept new connections, or does it accept the connection and wait for a thread to become free to handle it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When it runs out of handler threads it can&apos;t accept the connection because there&apos;s no thread to handle it. The code where this is implemented looks like this.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;AbstractConnector.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt; current = &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.currentThread();
&lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;(AbstractConnector.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;)
            {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (_acceptorThread==&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
                
                _acceptorThread[_acceptor]=current;
            }
...
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (isRunning())
                {
                    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt;
                    {
                        accept(_acceptor); 
                    }
                }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The connection is only accepted if there&apos;s a thread to handle it.&lt;/p&gt;

&lt;p&gt;It&apos;s clearer in the Tomcat documentation for equivalent parameter (acceptCount in &lt;a href=&quot;http://tomcat.apache.org/tomcat-6.0-doc/config/http.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://tomcat.apache.org/tomcat-6.0-doc/config/http.html&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="12622906" author="yseeley@gmail.com" created="Fri, 15 Aug 2008 17:13:12 +0100"  >&lt;blockquote&gt;&lt;p&gt;The connection is only accepted if there&apos;s a thread to handle it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, but not from the normal pool... it looks like there are acceptor threads that do nothing but accept socket connections.&lt;/p&gt;

&lt;p&gt;I just confirmed that setting the acceptQueueSize does not work to reject connections.&lt;br/&gt;
I put in a configurable sleep in the search handler and made requests until they started blocking.  Requests were still accepted and just hung... netstat showed them to be &quot;ESTABLISHED&quot;.&lt;/p&gt;

&lt;p&gt;Further, setting a really low acceptQueueSize runs the risk of having connections rejected even in a low-load situation because jetty doesn&apos;t accept them fast enough.&lt;/p&gt;</comment>
                            <comment id="12622910" author="yseeley@gmail.com" created="Fri, 15 Aug 2008 17:18:26 +0100"  >&lt;p&gt;I just rolled back the second commit... I think just upping the thread count should be fine for now.&lt;/p&gt;</comment>
                            <comment id="12623247" author="larsko" created="Mon, 18 Aug 2008 03:39:02 +0100"  >&lt;p&gt;Yonik, you&apos;re right &amp;#8211; there&apos;re separate acceptor threads, setting acceptQueueSize just affects how connections are handled when they come in too quickly to be accepted by the available acceptor threads. There&apos;s no option to influence handling connections when no executor threads are available. I&apos;ve verified that Tomcat behaves in the same way.&lt;/p&gt;

&lt;p&gt;So the only thing we can do is up the thread count. Even setting timeouts won&apos;t help as this only affects the actual network transfers, not the execution time of the executor threads.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12388097" name="SOLR-683.patch" size="775" author="larsko" created="Wed, 13 Aug 2008 02:08:08 +0100"/>
                            <attachment id="12387835" name="locked.log" size="184037" author="cameronl" created="Fri, 8 Aug 2008 18:01:54 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 11 Aug 2008 20:41:06 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6932</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxpun:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20507</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>