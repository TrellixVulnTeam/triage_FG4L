<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:21:39 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-139/SOLR-139.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-139] Support updateable/modifiable documents</title>
                <link>https://issues.apache.org/jira/browse/SOLR-139</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;It would be nice to be able to update some fields on a document without having to insert the entire document.&lt;/p&gt;

&lt;p&gt;Given the way lucene is structured, (for now) one can only modify stored fields.&lt;/p&gt;

&lt;p&gt;While we are at it, we can support incrementing an existing value - I think this only makes sense for numbers.&lt;/p&gt;

&lt;p&gt;for background, see:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/loading-many-documents-by-ID-tf3145666.html#a8722293&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/loading-many-documents-by-ID-tf3145666.html#a8722293&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12361944">SOLR-139</key>
            <summary>Support updateable/modifiable documents</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ryantxu">Ryan McKinley</reporter>
                        <labels>
                    </labels>
                <created>Sun, 4 Feb 2007 08:01:35 +0000</created>
                <updated>Fri, 10 May 2013 11:33:35 +0100</updated>
                            <resolved>Fri, 23 Nov 2012 02:42:06 +0000</resolved>
                                                    <fixVersion>4.0</fixVersion>
                                    <component>update</component>
                        <due></due>
                            <votes>57</votes>
                                    <watches>81</watches>
                                                                <comments>
                            <comment id="12470035" author="ryantxu" created="Sun, 4 Feb 2007 08:59:41 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt;-IndexDocumentCommand.patch adds a new command to UpdateHandler and deprecates &apos;AddUpdateCommand&apos;&lt;/p&gt;

&lt;p&gt;This patch is only concerned with adding updateability to the UpdateHandler, it does not deal with how request handlers specify what should happen with each field.&lt;/p&gt;

&lt;p&gt;I added:&lt;/p&gt;

&lt;p&gt;public class IndexDocumentCommand &lt;br/&gt;
{&lt;br/&gt;
  public enum MODE &lt;/p&gt;
{
    OVERWRITE, // overwrite existing values with the new one. (the default behavior)
    APPEND,    // add the new value to existing value
    DISTINCT,  // same as APPEND, but make sure each value is distinct
    INCREMENT, // increment existing value.  Must be a number!
    REMOVE     // remove the previous value.
  }
&lt;p&gt;;&lt;/p&gt;

&lt;p&gt;  public boolean overwrite = true;&lt;br/&gt;
  public SolrDocument doc;&lt;br/&gt;
  public Map&amp;lt;SchemaField,MODE&amp;gt; mode; // What to do for each field.  null is the default&lt;br/&gt;
  public int commitMaxTime = -1; // make sure the document is commited within this much time&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;RequestHandlers will need to fill up the &apos;mode&apos; map if they want to support updateability.  Setting the mode.put( null, APPEND ) sets the default mode.&lt;/p&gt;

</comment>
                            <comment id="12470043" author="ryantxu" created="Sun, 4 Feb 2007 11:42:19 +0000"  >&lt;p&gt;I just attached a modified XmlUpdateRequestHandler that uses the new IndexDocumentCommand .  I left this out originally because I think the discussion around syntax and functionality should be separated...  BUT without some example, it is tough to get a sense how this would work, so i added this example.&lt;/p&gt;

&lt;p&gt;Check the new file:&lt;br/&gt;
monitor-modifier.xml&lt;/p&gt;

&lt;p&gt;It starts with:&lt;br/&gt;
&amp;lt;add mode=&quot;cat=DISTINCT,features=APPEND,price=INCREMENT,sku=REMOVE,OVERWRITE&quot;&amp;gt;&lt;br/&gt;
&amp;lt;doc&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;id&quot;&amp;gt;3007WFP&amp;lt;/field&amp;gt;&lt;br/&gt;
  ...&lt;/p&gt;

&lt;p&gt;If you run  ./post.sh  monitor-modifier.xml multiple times and check: &lt;a href=&quot;http://localhost:8983/solr/select?q=id:3007WFP&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/select?q=id:3007WFP&lt;/a&gt; you should notice&lt;br/&gt;
1) the price increments by 5 each time&lt;br/&gt;
2) there is an additional &apos;feature&apos; line each time&lt;br/&gt;
3) the categories are distinct even if the input is not&lt;/p&gt;

&lt;p&gt;sku=REMOVE is required because sku is a stored field that is written to with copyField.  &lt;/p&gt;

&lt;p&gt;Although I think this syntax is reasonable, this is just an example intended to spark discussion.  Other things to consider:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;rather then &apos;field=mode,&apos; we could do &apos;field:mode,&apos; this may look less like HTTP request parameter syntax&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The update handler could skip any stored field that is the target of a &apos;copyField&apos; automatically.  This is the most normal case, so it may be the most reasonable thing to do.&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12470061" author="yseeley@gmail.com" created="Sun, 4 Feb 2007 15:35:40 +0000"  >&lt;p&gt;Haven&apos;t had a chance to check out any code, but a few quick comments:&lt;/p&gt;

&lt;p&gt;If the field modes were parameters, they could be reused for other update handlers like SQL or CSV&lt;br/&gt;
Perhaps something like:&lt;br/&gt;
/update/xml?modify=true&amp;amp;f.price.mode=increment,f.features.mode=append&lt;/p&gt;

&lt;p&gt;&amp;gt; sku=REMOVE is required because sku is a stored field that is written to with copyField.&lt;br/&gt;
I&apos;m not sure I quite grok what REMOVE means yet, and how it fixes the copyField problem.&lt;/p&gt;

&lt;p&gt;Another way to work around copyField is to only collect stored fields that aren&apos;t copyField targets.  Then you run the copyField logic while indexing the document again (as you should anyway).&lt;/p&gt;

&lt;p&gt;I think I&apos;ll have a tagging usecase that requires removing a specific field value from a multivalued field.  Removing based on a regex might be nice too. though.&lt;/p&gt;

&lt;p&gt;f.tag.mode=remove&lt;br/&gt;
f.tag.mode=removeMatching or removeRegex&lt;/p&gt;
</comment>
                            <comment id="12470064" author="yseeley@gmail.com" created="Sun, 4 Feb 2007 16:11:54 +0000"  >&lt;p&gt;I browsed the code really quick, looking for the tricky part... It&apos;s here:&lt;br/&gt;
+      openSearcher();&lt;br/&gt;
+      Term t = new Term( uniqueKey.getName(), uniqueKey.getType().toInternal( id.toString() ) );&lt;br/&gt;
+      int docID = searcher.getFirstMatch( t );&lt;/p&gt;

&lt;p&gt;When you overwrite a document, it is really just adds another instance... so the index contains multiple copies.  When we &quot;commit&quot;, deletes of the older versions are performed.  So you really want the &lt;b&gt;last&lt;/b&gt; doc matching a term, not the first.&lt;/p&gt;

&lt;p&gt;Also, to need to make sure that the searcher you are using can actually &quot;see&quot; the last document (once a searcher is opened, it sees documents that were added since the last IndexWriter close().&lt;/p&gt;

&lt;p&gt;So a quick fix would be to do a commit() first that would close the writer, and then delete any old copies of docments.&lt;br/&gt;
Opening and closing readers and writers is &lt;b&gt;very&lt;/b&gt; expensive though.&lt;br/&gt;
You can get slightly more sophisticated by checking the pset (set of pending documents), and skip the commit() if the doc you are updating isn&apos;t in there (so you know an older searcher will still have the freshest doc for that id).&lt;/p&gt;

&lt;p&gt;We might be able to get more efficient yet in the future by leveraging NewIndexModifier: &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-124&quot; title=&quot;use NewIndexModifier, LUCENE-565&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-124&quot;&gt;&lt;del&gt;SOLR-124&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12470065" author="yseeley@gmail.com" created="Sun, 4 Feb 2007 16:13:49 +0000"  >&lt;p&gt;Oh, so we obviously need some tests that modify the same document multiple times w/o a commit in between.&lt;/p&gt;</comment>
                            <comment id="12470076" author="ryantxu" created="Sun, 4 Feb 2007 19:21:29 +0000"  >&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; If the field modes were parameters, they could be reused for other update handlers like SQL or CSV&lt;br/&gt;
&amp;gt; Perhaps something like:&lt;br/&gt;
&amp;gt; /update/xml?modify=true&amp;amp;f.price.mode=increment,f.features.mode=append&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Yes.  I think we should decide a standard &apos;modify modes&apos; syntax that can be used across handlers.  In this example, I am using the string:&lt;/p&gt;

&lt;p&gt;mode=cat=DISTINCT,features=APPEND,price=INCREMENT,sku=REMOVE,OVERWRITE&lt;/p&gt;

&lt;p&gt;and passing it to &apos;parseFieldModes&apos; in XmlUpdateRequestHandler.&lt;/p&gt;

&lt;p&gt;Personally, I think all the modes should be specified in a single param rather then a list of them.  I vote for a syntax like:&lt;/p&gt;

&lt;p&gt;&amp;lt;lst name=&quot;params&quot;&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;mode&quot;&amp;gt;cat=DISTINCT,features=APPEND,price=INCREMENT,sku=REMOVE,OVERWRITE&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;/lst&amp;gt;&lt;br/&gt;
 or:&lt;br/&gt;
&amp;lt;lst name=&quot;params&quot;&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;mode&quot;&amp;gt;cat:DISTINCT,features:APPEND,price:INCREMENT,sku:REMOVE,OVERWRITE&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;/lst&amp;gt;&lt;/p&gt;

&lt;p&gt;rather then:&lt;/p&gt;

&lt;p&gt;&amp;lt;lst name=&quot;params&quot;&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;f.cat.mode&quot;&amp;gt;DISTINCT&amp;lt;/str&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;f.features.mode&quot;&amp;gt;APPEND&amp;lt;/str&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;f.price.mode&quot;&amp;gt;INCREMENT&amp;lt;/str&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;f.sku.mode&quot;&amp;gt;REMOVE&amp;lt;/str&amp;gt;&lt;br/&gt;
 &amp;lt;str name=&quot;modify.default.mode&quot;&amp;gt;OVERWRITE&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;/lst&amp;gt;&lt;/p&gt;



&lt;p&gt;&amp;gt;&amp;gt; sku=REMOVE is required because sku is a stored field that is written to with copyField.&lt;br/&gt;
&amp;gt; I&apos;m not sure I quite grok what REMOVE means yet, and how it fixes the copyField problem.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;I&apos;m using &apos;REMOVE&apos; to say &quot;remove the previous value of this field before doing anything.&quot;  Essentially, this makes sure you new document does not start with a value for &apos;sku&apos;.&lt;/p&gt;


&lt;p&gt;&amp;gt; Another way to work around copyField is to only collect stored fields that aren&apos;t copyField targets.  &lt;/p&gt;

&lt;p&gt;I just implemented this.  It is the most normal case, so it should be the default.  It can be overridden by setting the mode for a copyField explicitly.&lt;/p&gt;

</comment>
                            <comment id="12470080" author="yseeley@gmail.com" created="Sun, 4 Feb 2007 19:44:47 +0000"  >&lt;p&gt;If modes are in a single param, a &quot;:&quot; syntax might be nicer because you could cut-n-paste it into a URL w/o escaping.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m using &apos;REMOVE&apos; to say &quot;remove the previous value of this field before doing anything.&quot; Essentially, this makes sure you new &lt;br/&gt;
&amp;gt; document does not start with a value for &apos;sku&apos;.&lt;/p&gt;

&lt;p&gt;That wouldn&apos;t work for multi-valued fields though, right?&lt;br/&gt;
If we keep this option, perhaps we should find a better name... to me &quot;remove&quot; suggests that the given value should be removed.  Think adding / removing tag values from a document.&lt;/p&gt;</comment>
                            <comment id="12470081" author="ryantxu" created="Sun, 4 Feb 2007 19:49:59 +0000"  >&lt;p&gt;Is this what you are suggesting?&lt;/p&gt;

&lt;p&gt;I added a second searcher to DirectUpdatehandler2 that is only closed when you call commit();  &lt;/p&gt;


&lt;p&gt;  // Check if the document has not been commited yet&lt;br/&gt;
  Integer cnt = pset.get( id.toString() );&lt;br/&gt;
  if( cnt != null &amp;amp;&amp;amp; cnt &amp;gt; 0 ) &lt;/p&gt;
{
    commit( new CommitUpdateCommand(false) );
  }
&lt;p&gt;  if( committedSearcher == null ) &lt;/p&gt;
{
    committedSearcher = core.newSearcher(&quot;DirectUpdateHandler2.committed&quot;);
  }
&lt;p&gt;  Term t = new Term( uniqueKey.getName(), uniqueKey.getType().toInternal( id.toString() ) );&lt;br/&gt;
  int docID = committedSearcher.getFirstMatch( t );&lt;br/&gt;
  if( docID &amp;gt;= 0 ) &lt;/p&gt;
{
    Document luceneDoc = committedSearcher.doc( docID );
    // set the new doc as the existingDoc + our changes
    DocumentBuilder builder = new DocumentBuilder( schema );
    add.doc = builder.bulid( 
       this.modifyDocument( luceneDoc, cmd.doc, cmd.mode ) );
  }


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This passes a new test that adds the same doc multiple times.  BUT it does commit each time.&lt;/p&gt;

&lt;p&gt;Another alternative would be to keep a Map&amp;lt;String,Document&amp;gt; of the pending documents in memory.  Then we would not have to commit each time something has changed.&lt;/p&gt;




</comment>
                            <comment id="12470082" author="ryantxu" created="Sun, 4 Feb 2007 19:57:15 +0000"  >
&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; That wouldn&apos;t work for multi-valued fields though, right?&lt;/p&gt;

&lt;p&gt;&apos;REMOVE&apos; on a mult-valued field would clear the old fields before adding the new ones.  It is essentially the same as OVERWRITE, but you may or may not pass in a new value on top of the old one.&lt;/p&gt;

&lt;p&gt;&amp;gt; If we keep this option, perhaps we should find a better name... &lt;/p&gt;

&lt;p&gt;how about &apos;IGNORE&apos; or &apos;CLEAR&apos;  It is awkward because it refers to what was in in the document before, not what you are passing in.&lt;/p&gt;

&lt;p&gt;The more i think about it, I think we should drop the &apos;REMOVE&apos; option.  You can get the same effect using &apos;OVERWRITE&apos; and passing in a null value.&lt;/p&gt;</comment>
                            <comment id="12470084" author="yseeley@gmail.com" created="Sun, 4 Feb 2007 20:07:27 +0000"  >&lt;p&gt;&amp;gt; I added a second searcher to DirectUpdatehandler2 that is only closed when you call commit();&lt;/p&gt;

&lt;p&gt;That&apos;s OK for right now, but longer term we should re-use the other searcher.&lt;br/&gt;
Previously, the searcher was only used for deletions, hence we always had to close it before we opened a writer.&lt;br/&gt;
If it&apos;s going to be used for doc retrieval now, we should change closeSearcher() to flushDeletes() and only really close the searcher if there had been deletes pending (from our current deleteByQuery  implementation).&lt;/p&gt;</comment>
                            <comment id="12470109" author="ryantxu" created="Mon, 5 Feb 2007 01:51:44 +0000"  >&lt;p&gt;I added a new version of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt;-IndexDocumentCommand.patch that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;gets rid of &apos;REMOVE&apos; option&lt;/li&gt;
	&lt;li&gt;uses a separate searcher to search for existing docs&lt;/li&gt;
	&lt;li&gt;includes the XmlUpdateRequestHandler&lt;/li&gt;
	&lt;li&gt;moves general code from XmlUpdateRequestHandler to SolrPluginUtils&lt;/li&gt;
	&lt;li&gt;adds a few more tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Can someone with a better lucene understanding look into re-useint the existing searcher as Yonik suggests above - I don&apos;t quite understand the other DUH2 implications.&lt;/p&gt;

&lt;p&gt;I moved the part that parses (and validates) field mode parsing into SolrPluginUtils.  This could be used by other RequestHandlers to parse the mode map.&lt;/p&gt;

&lt;p&gt;The XmlUpdateRequestHandler in this patch should support all legacy calls &lt;b&gt;except&lt;/b&gt; cases where overwritePending != overwriteCommitted.  There are no existing tests with this case, so it is not a problem from the testing standpoint.  I don&apos;t know if anyone is using this (mis?) feature.&lt;/p&gt;
</comment>
                            <comment id="12471497" author="ryantxu" created="Thu, 8 Feb 2007 21:51:45 +0000"  >&lt;p&gt;This is a minor change that keeps the OVERWRITE property if it is specified.  The previous version ignored the update mode if everthing was OVERWRITE.&lt;/p&gt;</comment>
                            <comment id="12473863" author="ryantxu" created="Sat, 17 Feb 2007 01:39:58 +0000"  >&lt;p&gt;added missing files.  this should is ready to check over if anyone has some time&lt;/p&gt;</comment>
                            <comment id="12478307" author="ryantxu" created="Tue, 6 Mar 2007 08:16:54 +0000"  >&lt;p&gt;An updated and cleaned up versoin.  The big change is to the SolrDocument interface - rather then expose Maps directly, it hides them in an interface:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://solrstuff.org/svn/solrj/src/org/apache/solr/util/SolrDocument.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://solrstuff.org/svn/solrj/src/org/apache/solr/util/SolrDocument.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Still needs some test cases&lt;/p&gt;</comment>
                            <comment id="12482361" author="ryantxu" created="Tue, 20 Mar 2007 10:43:06 +0000"  >&lt;p&gt;depending on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-193&quot; title=&quot;General SolrDocument interface to manage field values.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-193&quot;&gt;&lt;del&gt;SOLR-193&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12492613" author="ryantxu" created="Mon, 30 Apr 2007 01:31:33 +0100"  >&lt;p&gt;applies (almost cleanly) with trunk + &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-193&quot; title=&quot;General SolrDocument interface to manage field values.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-193&quot;&gt;&lt;del&gt;SOLR-193&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12505316" author="ryantxu" created="Fri, 15 Jun 2007 18:14:53 +0100"  >&lt;p&gt;updated with trunk&lt;/p&gt;</comment>
                            <comment id="12505611" author="ryantxu" created="Sun, 17 Jun 2007 20:36:54 +0100"  >&lt;ul&gt;
	&lt;li&gt;Updated to work with trunk.&lt;/li&gt;
	&lt;li&gt;moved MODE enum to common&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This could be added without affecting any call to the XmlUpdateHandler &amp;#8211; (for now) this only works with the StaxUpdateHandler.  Adding it will help clarify some of the DocumentBuilder needs/issues...&lt;/p&gt;</comment>
                            <comment id="12509498" author="ryantxu" created="Mon, 2 Jul 2007 07:59:55 +0100"  >&lt;ul&gt;
	&lt;li&gt;Updated for new SolrDocument implementation.&lt;/li&gt;
	&lt;li&gt;Testing via solrj.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think this should be committed soon.  It should only affect performance if you specify a &apos;mode&apos; in the add command.&lt;/p&gt;</comment>
                            <comment id="12509608" author="yseeley@gmail.com" created="Mon, 2 Jul 2007 17:25:23 +0100"  >&lt;p&gt;Another use case to keep in mind... someone might use an UpdateRequestProcessor&lt;br/&gt;
to add new fields to a document (something like copyField, but more complex).  Some of this logic might be based on the value of other fields themselves.&lt;/p&gt;

&lt;p&gt;example1:  a userTag field that represents tags on objects of the form user#tagstring.&lt;br/&gt;
If user==member, then add tagstring to the indexed-only ownerTags field, else&lt;br/&gt;
add the tagstring to the socialTags field.&lt;/p&gt;

&lt;p&gt;example2: an UpdateRequestProcessor is used to encode the value of a field with rot13... this should obviously only be done for new field values, and not values that are just being re-stored, so the UpdateRequestProcessor needs to be able to distinguish between the two.&lt;/p&gt;

&lt;p&gt;example3: some field values are pulled from a database when missing rather than being stored values.&lt;/p&gt;

&lt;p&gt;I think we need to try to find the right UpdateRequestProcessor interface to support all these with UpdateableDocuments.&lt;/p&gt;</comment>
                            <comment id="12509615" author="ryantxu" created="Mon, 2 Jul 2007 17:51:01 +0100"  >
&lt;p&gt;So you are suggesting pulling this out of the UpdateHandler and managing the document merging in the UpdateRequestProcessor?  (this might makes sense - It was not an option when the patch started in feb)  &lt;/p&gt;

&lt;p&gt;How can the UpdateHandler get access to pending documents?  should it just use req.getSearcher()? &lt;/p&gt;


&lt;p&gt;&amp;gt; example1:  a userTag field that represents tags on objects of the form user#tagstring.&lt;br/&gt;
&amp;gt; If user==member, then add tagstring to the indexed-only ownerTags field, else&lt;br/&gt;
&amp;gt; add the tagstring to the socialTags field.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; example2: an UpdateRequestProcessor is used to encode the value of a field with rot13... this should obviously only be done for new field values, and not values that are just being re-stored, so the UpdateRequestProcessor needs to be able to distinguish between the two.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;1 &amp;amp; 2 seem pretty straightforwad&lt;/p&gt;

&lt;p&gt;&amp;gt; example3: some field values are pulled from a database when missing rather than being stored values.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Do you mean as input or output?  The UpdateRequestProcessor could not affect if a field is stored or not, it could augment a document with more fields &lt;b&gt;before&lt;/b&gt; it is indexed.  To add fields from a database rather then storing them, we would need a hook at the end.&lt;/p&gt;</comment>
                            <comment id="12509622" author="yseeley@gmail.com" created="Mon, 2 Jul 2007 18:28:46 +0100"  >&lt;p&gt;&amp;gt; So you are suggesting &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I don&apos;t have a concrete implementation idea, I&apos;m just going over all the things I know people will want to do (and many of these I have an immediate use for).&lt;/p&gt;

&lt;p&gt;&amp;gt; Do you mean as input or output?&lt;/p&gt;

&lt;p&gt;Input, for index-only fields.  Normally field values need to be stored for an &quot;update&quot; to work, but we could also allow the user to get these field values from an external source.&lt;/p&gt;

&lt;p&gt;&amp;gt; we would need a hook at the end.&lt;/p&gt;

&lt;p&gt;Yes, it might make sense to have more than one callback method per UpdateRequestProcessor&lt;/p&gt;

&lt;p&gt;Of course now that I finally look at the code, UpdateRequestProcessor isn&apos;t quite what I expected.&lt;br/&gt;
I was originally thinking more along the lines of DocumentMutator(s) that manipulate a document, not that actually initiate the add/delete/udpate calls.  But there is a certain greater power to what you are exposing/allowing too (as long as you don&apos;t need multiple of them).&lt;/p&gt;

&lt;p&gt;In UpdateRequestProcessor , instead of &lt;br/&gt;
  protected final NamedList&amp;lt;Object&amp;gt; response;&lt;br/&gt;
Why not just expose SolrQueryRequest, SolrQueryResponse?&lt;/p&gt;

</comment>
                            <comment id="12509631" author="yseeley@gmail.com" created="Mon, 2 Jul 2007 18:43:21 +0100"  >&lt;p&gt;&amp;gt; How can the UpdateHandler get access to pending documents? should it just use req.getSearcher()? &lt;/p&gt;

&lt;p&gt;I don&apos;t think so... the document may have been added more recently than the last searcher was opened.&lt;br/&gt;
We need to use the IndexReader from the UpdateHandler.  The reader and writer can both remain open as long as the reader is not used for deletions (which is a write operation and hence exclusive with IndexWriter).&lt;/p&gt;
</comment>
                            <comment id="12509635" author="yseeley@gmail.com" created="Mon, 2 Jul 2007 19:18:07 +0100"  >&lt;p&gt;&amp;gt; (as long as you don&apos;t need multiple of them). &lt;/p&gt;

&lt;p&gt;If you had a bunch of independent things you wanted to do, having a single processor forces you to squish them together (say you even added another document type to your index and then wanted to add another mutation operation).&lt;/p&gt;

&lt;p&gt;What if we had some sort of hybrid between the two approaches. Had a list of processors, and the last would have primary responsibility for getting the documents in the index?&lt;/p&gt;</comment>
                            <comment id="12510040" author="ryantxu" created="Wed, 4 Jul 2007 02:41:43 +0100"  >&lt;p&gt;implementing modifiable documents in UpdateRequestProcessor.&lt;/p&gt;

&lt;p&gt;This adds two example docs:&lt;br/&gt;
modify1.xml and modify2.xml&lt;/p&gt;

&lt;p&gt;&amp;lt;add mode=&quot;OVERWRITE,price:INCREMENT,cat:DISTINCT&quot;&amp;gt;&lt;br/&gt;
 &amp;lt;doc&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;id&quot;&amp;gt;CSC&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;name&quot;&amp;gt;Campbell&apos;s Soup Can&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;manu&quot;&amp;gt;Andy Warhol&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;price&quot;&amp;gt;23.00&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;popularity&quot;&amp;gt;100&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;cat&quot;&amp;gt;category1&amp;lt;/field&amp;gt;&lt;br/&gt;
 &amp;lt;/doc&amp;gt;&lt;br/&gt;
&amp;lt;/add&amp;gt;&lt;/p&gt;

&lt;p&gt;will increment the price by 23 each time it is run.&lt;/p&gt;</comment>
                            <comment id="12512388" author="ryantxu" created="Fri, 13 Jul 2007 08:44:52 +0100"  >&lt;p&gt;implements modifiable documents in the &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-269&quot; title=&quot;UpdateRequestProcessorFactory - process requests before submitting them&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-269&quot;&gt;&lt;del&gt;SOLR-269&lt;/del&gt;&lt;/a&gt; update processor chain.&lt;/p&gt;

&lt;p&gt;If the request does not have a &apos;mode&apos; string, the ModifyDocumentProcessorFactory does not add a processor to the chain.&lt;/p&gt;
</comment>
                            <comment id="12512553" author="yseeley@gmail.com" created="Fri, 13 Jul 2007 18:57:08 +0100"  >&lt;p&gt;Some general issues w/ update processors and modifiable documents, and keeping this stuff out of the update handler is that the udpate handler knows much more about the index than we do outside, and it constrains implementation (and performance optimizations).&lt;/p&gt;

&lt;p&gt;For example, if modifiable documents were implemented in the update handler, and the old version of the document hasn&apos;t been committed yet, the update handler could buffer the complete modify command to be done at a later time (the &lt;b&gt;much&lt;/b&gt; slower alternative is closing the writer and opening the reader to get the latest stored fields), then closing the reader and re-opening the writer.&lt;/p&gt;</comment>
                            <comment id="12512555" author="ryantxu" created="Fri, 13 Jul 2007 18:58:45 +0100"  >&lt;p&gt;Updated patch to work with &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-269&quot; title=&quot;UpdateRequestProcessorFactory - process requests before submitting them&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-269&quot;&gt;&lt;del&gt;SOLR-269&lt;/del&gt;&lt;/a&gt; UpdateRequestProcessors.&lt;/p&gt;

&lt;p&gt;One thing I think is weird about this is that it uses parameters to say the mode rather then the add command.  That is, to modify a documetn you have to send:&lt;/p&gt;

&lt;p&gt;/update?mode=OVERWRITE,count:INCREMENT&lt;br/&gt;
&amp;lt;add&amp;gt;&lt;br/&gt;
 &amp;lt;doc&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;id&quot;&amp;gt;1&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;count&quot;&amp;gt;5&amp;lt;/field&amp;gt;&lt;br/&gt;
 &amp;lt;/doc&amp;gt;&lt;br/&gt;
&amp;lt;/add&amp;gt;&lt;/p&gt;

&lt;p&gt;rather then:&lt;br/&gt;
&amp;lt;add mode=&quot;OVERWRITE,count:INCREMENT&quot;&amp;gt;&lt;br/&gt;
 &amp;lt;doc&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;id&quot;&amp;gt;1&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;field name=&quot;count&quot;&amp;gt;5&amp;lt;/field&amp;gt;&lt;br/&gt;
 &amp;lt;/doc&amp;gt;&lt;br/&gt;
&amp;lt;/add&amp;gt;&lt;/p&gt;

&lt;p&gt;This is fine, but it makes it hard to have an example &apos;modify&apos; xml document.&lt;/p&gt;</comment>
                            <comment id="12512558" author="ryantxu" created="Fri, 13 Jul 2007 19:09:58 +0100"  >&lt;p&gt;&amp;gt; the udpate handler knows much more about the index than we do outside&lt;/p&gt;

&lt;p&gt;Yes.  The patch i just attached only deals with documents that are already commited.  It uses req.getSearcher() to find existing documents.  &lt;/p&gt;

&lt;p&gt;Beyond finding commited or non-commited Documents, is there anything else that it can do better?  &lt;/p&gt;

&lt;p&gt;Is it enought to add something to UpdateHandler to ask for a pending or commited document by uniqueId?&lt;/p&gt;

&lt;p&gt;I like having the the actual document manipulation happening in the Processor because it is an easy place to put in other things like grabbing stuff from a SQL database.  &lt;/p&gt;</comment>
                            <comment id="12512602" author="yseeley@gmail.com" created="Fri, 13 Jul 2007 21:08:19 +0100"  >&lt;p&gt;&amp;gt; I like having the the actual document manipulation happening in the Processor because it is an easy &lt;br/&gt;
&amp;gt; place to put in other things like grabbing stuff from a SQL database.&lt;/p&gt;

&lt;p&gt;The update handler could call the processor when it was time to do the manipulation too.&lt;/p&gt;

&lt;p&gt;Consider the case of future support for ParallelReader, where some fields are in one sub-index and some fields are in another sub-index.  I&apos;m not sure if our current processor interfaces will be able to handle that scenario well (but I&apos;m not sure if we should worry about it too much right now either).&lt;/p&gt;

&lt;p&gt;There is another way to perhaps mitigate the problem of a few frequently modified documents causing thrashing: a document cache in the update handler.&lt;/p&gt;</comment>
                            <comment id="12512613" author="ryantxu" created="Fri, 13 Jul 2007 21:43:17 +0100"  >&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; The update handler could call the processor when it was time to do the manipulation too.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;What are you thinking?  Adding the processor as a parameter to AddUpdateCommand?&lt;/p&gt;

&lt;p&gt;&amp;gt; ... ParallelReader, where some fields are in one sub-index  ...&lt;/p&gt;

&lt;p&gt;the processor would ask the updateHandler for the existing document - the updateHandler deals with getting it to/from the right place.&lt;/p&gt;

&lt;p&gt;we could add something like:&lt;br/&gt;
  Document getDocumentFromPendingOrCommited( String indexId )&lt;br/&gt;
to UpdateHandler and then that is taken care of.&lt;/p&gt;

&lt;p&gt;Other then extracting the old document, what needs to be done that cant be done in the processor?  &lt;/p&gt;</comment>
                            <comment id="12512617" author="yseeley@gmail.com" created="Fri, 13 Jul 2007 21:52:42 +0100"  >&lt;p&gt;&amp;gt;&amp;gt; ... ParallelReader, where some fields are in one sub-index ...&lt;br/&gt;
&amp;gt; the processor would ask the updateHandler for the existing document - the updateHandler deals with&lt;br/&gt;
&amp;gt; getting it to/from the right place.&lt;/p&gt;

&lt;p&gt;The big reason you would use ParallelReader is to avoid touching the less-modified/bigger fields in one index when changing some of the other fields in the other index.&lt;/p&gt;

&lt;p&gt;&amp;gt; What are you thinking? Adding the processor as a parameter to AddUpdateCommand?&lt;/p&gt;

&lt;p&gt;I didn&apos;t have a clear alternative... I was just pointing out the future pitfalls of assuming too much implementation knowledge.&lt;/p&gt;
</comment>
                            <comment id="12512628" author="ryantxu" created="Fri, 13 Jul 2007 22:25:59 +0100"  >&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; ... avoid touching the less-modified/bigger fields ...&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;aaah, perhaps a future updateHandler getDocument() function could take a list of fields it should extract.  Still problems with what to do when you add it.. maybe it checks if anything has changed in the less-modified index?  I see your point.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; What are you thinking? Adding the processor as a parameter to AddUpdateCommand?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I didn&apos;t have a clear alternative... I was just pointing out the future pitfalls of assuming too much implementation knowledge.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;I am fine either way &amp;#8211; in the UpdateHandler or the Processors.  &lt;/p&gt;

&lt;p&gt;Request plumbing-wise, it feels the most natural in a processor.  But if we rework the AddUpdateCommand it could fit there too.  I don&apos;t know if it is an advantage or disadvantage to have the &apos;modify&apos; parameters tied to the command or the parameters.  either way has its +-, with no real winner (or loser) IMO&lt;/p&gt;

&lt;p&gt;In the end, I want to make sure that I never need a custom UpdateHandler (80% is greek to me), but can easily change the &apos;modify&apos; logic.&lt;/p&gt;</comment>
                            <comment id="12513355" author="yseeley@gmail.com" created="Tue, 17 Jul 2007 21:59:02 +0100"  >&lt;p&gt;FYI, I&apos;m working on a loadStoredFields() for UpdateHandler now.&lt;/p&gt;</comment>
                            <comment id="12513654" author="yseeley@gmail.com" created="Wed, 18 Jul 2007 18:55:35 +0100"  >&lt;p&gt;Here&apos;s a patch that adds getStoredFields to updateHandler.&lt;br/&gt;
Changes include leaving the searcher open as long as possible (and in conjunction with the writer, if the reader has no unflushed deletions).  This would allow reuse of a single index searcher when modifying multiple documents that are not in the pending set.&lt;/p&gt;

&lt;p&gt;No tests for getStoredFields() yet... I plan on a comprehensive update handler test that uses multiple threads to try and flush out any possible concurrency bugs. &lt;/p&gt;</comment>
                            <comment id="12513681" author="yseeley@gmail.com" created="Wed, 18 Jul 2007 19:45:37 +0100"  >&lt;p&gt;updated getStoredFields.patch to use synchronization instead of the write lock since you can&apos;t upgrade a read lock to a write lock.  I could have started out with the write lock and downgraded it to a read lock, but that would probably lead to much worse concurrency since it couldn&apos;t proceed in parallel with other operations such as adds.&lt;/p&gt;

&lt;p&gt;It would be good if someone could review this for threading issues.&lt;/p&gt;</comment>
                            <comment id="12513685" author="yseeley@gmail.com" created="Wed, 18 Jul 2007 20:00:50 +0100"  >&lt;p&gt;Found another bug just by looking at it a little longer... pset needs to be synchronized if all we have is the read lock, since addDoc() actually changes the pset while only holding the readLock (but it also synchronizes).  I expanded the sync block to encompass the pset access and merged the two sync blocks.  Hopefully this one should be correct.&lt;/p&gt;</comment>
                            <comment id="12514099" author="klaasm" created="Fri, 20 Jul 2007 06:24:28 +0100"  >&lt;p&gt;It is my fault that the DUH2 locking is so hairy to begin with, so I should at least review changes to it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;With your last change, the locking looks sound.  However, I noticed a few things:&lt;/p&gt;

&lt;p&gt;This comment is now inaccurate:&lt;br/&gt;
+    // need to start off with the write lock because we can&apos;t aquire&lt;br/&gt;
+    // the write lock if we need to.&lt;/p&gt;

&lt;p&gt;Should openSearcher() call closeSearcher() instead of doing it manually?  It looks like searcherHasChanges is not being reset to false.&lt;/p&gt;
</comment>
                            <comment id="12514234" author="yseeley@gmail.com" created="Fri, 20 Jul 2007 17:20:43 +0100"  >&lt;p&gt;Thanks Mike, I&apos;ve made those changes to my local copy.&lt;/p&gt;</comment>
                            <comment id="12514772" author="yseeley@gmail.com" created="Mon, 23 Jul 2007 21:24:47 +0100"  >&lt;p&gt;Here&apos;s the latest patch, with the beginnings of a test, but I&apos;ve run into some issues.&lt;/p&gt;

&lt;p&gt;1) I&apos;m getting occasional errors about the index writer already being closed (with lucene trunk), or null pointer exception with the lucene version we have bundled.  It&apos;s the same issue I believe... somehow the writer gets closed when someone else is trying to use it.  If I comment out verifyLatest() in the test (that calls getStoredFields), it no longer happens.&lt;/p&gt;

&lt;p&gt;2) When I comment out getStoredFields, things seem to run correctly, but memory grows without bound and i eventually run out.  100 threads each limiting themselves to manipulating 16 possible documents each should not be able to cause this.&lt;/p&gt;

&lt;p&gt;At this point, I think #2 is the most important to investigate.  It may be unrelated to this latest patch, and could be related to other peoples reports of running out of memory while indexing.&lt;/p&gt;</comment>
                            <comment id="12515154" author="yseeley@gmail.com" created="Wed, 25 Jul 2007 05:23:46 +0100"  >&lt;p&gt;Weird... I put a profiler on it to try and figure out the OOM issue, and I never saw heap usage growing over time (stayed between 20M and 30M), right up until I got an OOM (it never registered on the profiler).&lt;/p&gt;</comment>
                            <comment id="12515306" author="yseeley@gmail.com" created="Wed, 25 Jul 2007 15:27:36 +0100"  >&lt;p&gt;OOM still happens from the command line also after lucene updates to 2.2.&lt;br/&gt;
Looks like it&apos;s time for old-school instrumentation (printfs, etc).&lt;/p&gt;</comment>
                            <comment id="12515366" author="yseeley@gmail.com" created="Wed, 25 Jul 2007 18:58:53 +0100"  >&lt;p&gt;I disabled logging on all of &quot;org.apache.solr&quot; via a filter, and voila, OOM problems are gone.&lt;br/&gt;
Perhaps the logger could not keep up with the number of records and they piled up over time time (does any component of the logging framework use another thread that might be getting starved?)&lt;/p&gt;

&lt;p&gt;Anyway, it doesn&apos;t look like Solr has a memory leak.&lt;br/&gt;
On to the next issue.&lt;/p&gt;</comment>
                            <comment id="12515406" author="yseeley@gmail.com" created="Wed, 25 Jul 2007 21:14:17 +0100"  >&lt;p&gt;The locking logic for getStoredFields() is indeed flawed.&lt;br/&gt;
closing the writer inside the sync block of getStoredFields() doesn&apos;t project callers of addDoc() from concurrently using that writer.  The commit lock aquire will be needed after all... no getting around it I think.&lt;/p&gt;</comment>
                            <comment id="12515424" author="klaasm" created="Wed, 25 Jul 2007 22:17:54 +0100"  >&lt;p&gt;Darn, you&apos;re right: writer.addDocument() is outside of the synchronized block.&lt;/p&gt;

&lt;p&gt;We could do as you suggested, downgrading to a read lock from commit.  It should only reduce concurrently when the document is in pending state.&lt;/p&gt;</comment>
                            <comment id="12516470" author="yseeley@gmail.com" created="Mon, 30 Jul 2007 19:36:31 +0100"  >&lt;p&gt;Attaching a patch for getStoredFields that appears to work.&lt;/p&gt;</comment>
                            <comment id="12516473" author="yseeley@gmail.com" created="Mon, 30 Jul 2007 19:42:35 +0100"  >&lt;p&gt;So the big issue now is that I don&apos;t think we can use getStoredFields() and do document modification outside the update handler.  The biggest reason is that I think we need to be able to update documents atomically (in the sense that updates should not be lost).&lt;/p&gt;

&lt;p&gt;Consider the usecase of adding a new tag to a multi-valued field:  if two different clients tag a document at the same time, it doesn&apos;t seem acceptable that one of the tags could be lost.  So I think that we need a modifyDocument() call on updateHandler, and perhaps a ModifyUpdateCommand to go along with it.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure yet what this means for request processors.  Perhaps another method that handles the reloaded storedFields?&lt;/p&gt;</comment>
                            <comment id="12516598" author="ryantxu" created="Tue, 31 Jul 2007 03:25:56 +0100"  >
&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; So I think that we need a modifyDocument() call on updateHandler, and perhaps a ModifyUpdateCommand to go along with it.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;m not sure yet what this means for request processors.  Perhaps another method that handles the reloaded storedFields?&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;Another option might be some sort of transaction or locking model.  Could it block other requests while there is an open transaction/lock?&lt;/p&gt;

&lt;p&gt;Consider the case where we need the same atomic protection for fields loaded from non-stored fields loaded from a SQL database.  In this case, it may be nice to have locking/blocking happen at the processor level.&lt;/p&gt;

&lt;p&gt;I don&apos;t know synchronized well enough to know if this works or is a bad idea, but what about something like:&lt;/p&gt;

&lt;p&gt;class ModifyExistingDocumentProcessor {&lt;br/&gt;
  void processAdd(AddUpdateCommand cmd) {&lt;br/&gt;
    String id = cmd.getIndexedId(schema);&lt;br/&gt;
    synchronized( updateHandler ) &lt;/p&gt;
{
       SolrDocument existing = updateHandler.loadStoredFields( id );
       myCustomHelper.loadTagsFromDB( existing );
       cmd.solrDoc = ModifyDocumentUtils.modifyDocument( ... );
       
       // This eventually calls: updateHandler.addDoc(cmd);
       super.processAdd(cmd);
    }
&lt;p&gt;  }&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;This type of approach would need to make sure everyone modifying fields was locking on the same updateHandler.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m not against adding a ModifyUpdateCommand, I just like having the modify logic sit outside the UpdateHandler.&lt;/p&gt;</comment>
                            <comment id="12517746" author="ryantxu" created="Sun, 5 Aug 2007 07:16:51 +0100"  >&lt;p&gt;Updated to use Yonik&apos;s &apos;getStoredFields&apos;.  The one change to that is to have UpdateHandler addFields() load fields as the Object (not external string) and to skip copy fields:&lt;/p&gt;

&lt;p&gt;void addFields(Document luceneDoc, SolrDocument solrDoc) {&lt;br/&gt;
    for (Fieldable f : (List&amp;lt;Fieldable&amp;gt;)luceneDoc.getFields()) {&lt;br/&gt;
      SchemaField sf = schema.getField( f.name() );&lt;br/&gt;
      if( !schema.isCopyFieldTarget( sf ) ) &lt;/p&gt;
{
        Object externalVal = sf.getType().toObject(f);
        solrDoc.addField(f.name(), externalVal);  
      }
&lt;p&gt;    }&lt;br/&gt;
  }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This still implements modifiable documents as a RequestProcessor.&lt;/p&gt;</comment>
                            <comment id="12519741" author="ryantxu" created="Tue, 14 Aug 2007 19:14:16 +0100"  >&lt;p&gt;applies with trunk&lt;/p&gt;</comment>
                            <comment id="12520554" author="ehatcher" created="Fri, 17 Aug 2007 14:24:24 +0100"  >&lt;p&gt;I&apos;m experimenting with this patch with tagging.   I&apos;m modeling the fields in this way, beyond general document metadata fields:&lt;/p&gt;

&lt;p&gt;   &amp;lt;username&amp;gt;_tags&lt;br/&gt;
  usernames&lt;/p&gt;

&lt;p&gt;And copyFielding *_tags into &quot;tags&quot;. &lt;/p&gt;

&lt;p&gt;usernames field allows seeing all users who have tagged documents.&lt;/p&gt;

&lt;p&gt;Users are allowed to &quot;uncollect&quot; an object, which would remove the &amp;lt;username&amp;gt;_tags field and remove their name from the usernames field.   Removing the &amp;lt;username&amp;gt;_tags field use case is covered with the &amp;lt;username&amp;gt;_tags:OVERWRITE mode.  But removing a username from the multiValued and non-duplicating usernames field is not.&lt;/p&gt;

&lt;p&gt;An example (from some conversations with Ryan): &lt;/p&gt;

&lt;p&gt; id: 10&lt;br/&gt;
 usernames: ryan, erik&lt;/p&gt;

&lt;p&gt;You want to be able to remove &apos;ryan&apos; but keep &apos;erik&apos;.&lt;/p&gt;

&lt;p&gt;Perhaps we need to add a &apos;REMOVE&apos; mode to remove the first (all?)&lt;br/&gt;
matching values&lt;br/&gt;
 /update?mode=OVERWRITE,username=REMOVE&lt;br/&gt;
 &amp;lt;doc&amp;gt;&lt;br/&gt;
  id=10,&lt;br/&gt;
  usernames=ryan&lt;br/&gt;
 &amp;lt;/doc&amp;gt;&lt;/p&gt;

&lt;p&gt;and make the output:&lt;/p&gt;

&lt;p&gt; id: 10&lt;br/&gt;
 usernames: erik&lt;/p&gt;

&lt;p&gt;But what about duplicate values?  &lt;/p&gt;</comment>
                            <comment id="12521900" author="ehatcher" created="Wed, 22 Aug 2007 20:23:15 +0100"  >&lt;p&gt;One thing to note about overwrite and copyFields is that to keep a purely copyFielded field in sync you must basically remove it (overwrite without providing a value).   &lt;/p&gt;

&lt;p&gt;For example, my schema:&lt;/p&gt;

&lt;p&gt;    &amp;lt;dynamicField name=&quot;*_tag&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&amp;gt;&lt;br/&gt;
    &amp;lt;field name=&quot;tag&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;and then this:&lt;br/&gt;
  &amp;lt;copyField source=&quot;*_tag&quot; dest=&quot;tag&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;The client never provides a value for &quot;tag&quot; only ever &amp;lt;username&amp;gt;_tag values.   I was seeing old values in the tag field after doing overwrites of &amp;lt;username&amp;gt;_tag expecting &quot;tag&quot; to get rewritten entirely.   Saying mode=tag:OVERWRITE does the trick.    This is understandable, but confusing, as the client then needs to know about purely copyFielded fields that it never sends directly. &lt;/p&gt;</comment>
                            <comment id="12521903" author="yseeley@gmail.com" created="Wed, 22 Aug 2007 20:32:51 +0100"  >&lt;p&gt;IMO, copyField targets should always be re-generated... so no, it doesn&apos;t seem like you should have to say anything about tag if you update erik_tag.&lt;/p&gt;

&lt;p&gt;On a side note, I&apos;m not sure how scalable the field-per-user strategy is.  There are some places in Lucene (segment merging for one) that go over each field, merging the properties.  Low thousands would be OK, but millions would not be OK.&lt;/p&gt;</comment>
                            <comment id="12521906" author="ehatcher" created="Wed, 22 Aug 2007 20:44:19 +0100"  >&lt;p&gt;I agree in the gut feel to how copyFields and overwrite should work, but what about the situation where the client is sending in values for that field also?   If it got completely regenerated during a modify operation, data would be lost.  No?&lt;/p&gt;

&lt;p&gt;Thanks for the note about field-per-user strategy.  In our case, even thousands of users is on down the road.   The simplicity of having fields per user is mighty alluring and is working nicely in the prototype for now. &lt;/p&gt;</comment>
                            <comment id="12521913" author="yseeley@gmail.com" created="Wed, 22 Aug 2007 20:56:21 +0100"  >&lt;p&gt;I think there are a number of restrictions for using this feature:&lt;br/&gt;
1) all source fields (not copyField targets) need to be stored, or included in modify commands&lt;br/&gt;
2) copyField targets should either be unstored, or if stored, should never be explicitly set by the user&lt;/p&gt;

&lt;p&gt;What tags would you send in that aren&apos;t user tags?  If they are some sort of global tags, then you could do global_tag=foo (reusing your dynamic user_tag field), or create a new globalTags field and an additional copyField to the tag field.&lt;/p&gt;</comment>
                            <comment id="12521928" author="ehatcher" created="Wed, 22 Aug 2007 21:59:16 +0100"  >&lt;p&gt;A mistake I had was my copyField target (&quot;tag&quot;) was stored.  Setting it to be unstored alleviated the need to overwrite it - thanks!&lt;/p&gt;

&lt;p&gt;One thing I noticed is that all fields sent in the update must be stored, but that doesn&apos;t really need to be the case with fields being overwritten -  perhaps that restriction should be lifted and only applies when the stored data is needed.&lt;/p&gt;

&lt;p&gt;As for sending in a field that was the target of a copyField - I&apos;m not doing this nor can I really envision this case, but it seemed like it might be a case to consider here.  Perhaps a &quot;text&quot; field that could be optionally set by the client, and is also the destination of copyField&apos;s of title, author, etc. &lt;/p&gt;</comment>
                            <comment id="12521932" author="yseeley@gmail.com" created="Wed, 22 Aug 2007 22:19:48 +0100"  >&lt;p&gt;&amp;gt; One thing I noticed is that all fields sent in the update must be stored, but that doesn&apos;t really need to be the case with fields being overwritten - perhaps that restriction should be lifted and only applies when the stored data is needed.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; Perhaps a &quot;text&quot; field that could be optionally set by the client, and is also the destination of copyField&apos;s of title, author, etc.&lt;/p&gt;

&lt;p&gt;Seems like things of this form can always be refactored by adding a field &quot;settableText&quot; and adding another copyField from that to &quot;text&quot;&lt;/p&gt;</comment>
                            <comment id="12522310" author="ehatcher" created="Fri, 24 Aug 2007 00:10:47 +0100"  >&lt;p&gt;There is a bug in the last patch that allows an update to a non-existent document to create a new document. &lt;/p&gt;

&lt;p&gt;I&apos;ve corrected this by adding this else clause in ModifyExistingDocumentProcessor:&lt;/p&gt;

&lt;p&gt;      if( existing != null ) &lt;/p&gt;
{
        cmd.solrDoc = ModifyDocumentUtils.modifyDocument(existing, cmd.solrDoc, modes, schema );
      }
&lt;p&gt; else &lt;/p&gt;
{
        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
            &quot;Cannot update non-existent document: &quot; + id);
      }

&lt;p&gt;I can&apos;t generate a patch, yet, that is clean addition of just that bit of code along with the other changes.&lt;/p&gt;</comment>
                            <comment id="12522320" author="ehatcher" created="Fri, 24 Aug 2007 01:02:31 +0100"  >&lt;p&gt;Some thoughts on the update request, how about using &amp;lt;update&amp;gt; instead of &amp;lt;add&amp;gt;?   And put the modes as attributes to &amp;lt;update&amp;gt;...&lt;/p&gt;

&lt;p&gt;   &amp;lt;update overwrite=&quot;title&quot; distinct=&quot;cat&quot;&amp;gt;&lt;br/&gt;
      &amp;lt;field name=&quot;id&quot;&amp;gt;ID&amp;lt;/field&amp;gt;&lt;br/&gt;
      &amp;lt;field name=&quot;title&quot;&amp;gt;new title&amp;lt;/field&amp;gt;&lt;br/&gt;
      &amp;lt;field name=&quot;cat&quot;&amp;gt;NewCategory&amp;lt;/field&amp;gt;&lt;br/&gt;
    &amp;lt;/update&amp;gt;&lt;/p&gt;

&lt;p&gt;Using &amp;lt;add&amp;gt; has the wrong implication for this operation.   Thoughts?&lt;/p&gt;</comment>
                            <comment id="12522333" author="yseeley@gmail.com" created="Fri, 24 Aug 2007 01:41:29 +0100"  >&lt;p&gt;&amp;gt; how about using &amp;lt;update&amp;gt; instead of &amp;lt;add&amp;gt;&lt;/p&gt;

&lt;p&gt;We had previously talked about making this distinction (and configuration for each field) in the URL:&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/update?mode=title:overwrite,cat:distinct&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/update?mode=title:overwrite,cat:distinct&lt;/a&gt;&lt;br/&gt;
This makes it usable and consistent for different update handlers and formats (CSV, future SQL, future JSON, etc)&lt;/p&gt;

&lt;p&gt;but perhaps if we allowed the &amp;lt;add&amp;gt; tag to optionally be called something more neutral like &amp;lt;docs&amp;gt;?&lt;/p&gt;

&lt;p&gt;wrt patches, I think the functionality needs refactoring so that modify document logic is in the update handler.  It seems like it&apos;s the only clean way from a locking perspective, and it also leaves open future optimizations (like using different indices depending on the fieldname and using a parallel reader across them).&lt;/p&gt;</comment>
                            <comment id="12522920" author="ehatcher" created="Mon, 27 Aug 2007 02:32:12 +0100"  >&lt;p&gt;Added DELETE support in ModifyDocumentUtils like this:&lt;/p&gt;

&lt;p&gt;      case DELETE:&lt;br/&gt;
        if( field != null ) {&lt;br/&gt;
          Collection&amp;lt;Object&amp;gt; collection = existing.getFieldValues(name);&lt;br/&gt;
          if (collection != null) {&lt;br/&gt;
            collection.remove(field.getValue());&lt;br/&gt;
            if (collection.isEmpty()) &lt;/p&gt;
{
              existing.removeField(name);
            }
&lt;p&gt; else &lt;/p&gt;
{
              existing.setField(name, collection, field.getBoost());
            }
&lt;p&gt;          }&lt;br/&gt;
        }&lt;br/&gt;
        // TODO: if field is null, should the field be deleted?&lt;br/&gt;
        break;&lt;/p&gt;</comment>
                            <comment id="12524089" author="ehatcher" created="Fri, 31 Aug 2007 15:24:58 +0100"  >&lt;p&gt;For posterity, here&apos;s the patch I&apos;m running in Collex production right now, and its working fine thus far.&lt;/p&gt;

&lt;p&gt;Sorry, I know this issue has a convoluted set of patches to follow at the moment.  I trust that when Ryan is back in action we&apos;ll get this tidied up and somehow get Yonik-satisfying refactorings &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12525951" author="ryantxu" created="Sat, 8 Sep 2007 21:30:09 +0100"  >&lt;p&gt;Updated Erik&apos;s patch to /trunk and added back the solrj modifiable document tests.&lt;/p&gt;</comment>
                            <comment id="12525955" author="ryantxu" created="Sat, 8 Sep 2007 21:52:11 +0100"  >&lt;p&gt;I&apos;m back and have some time to focus on this...  Internally, I need to move the document modification to the update handler, but before I get going it would be nice to agree what we want the external interface to look like.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Should we deprecate the AddUpdateCommand and replace it with something else? Do we want one command to do Add/Update/Modify?  Two?&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;what should happen if you &quot;modify&quot; a non-existent document?&lt;br/&gt;
a. error &amp;#8211; makes sense in a &apos;tagging&apos; context&lt;br/&gt;
b. treat it as an add &amp;#8211; makes sense in a &quot;keep these fields up to date&quot; context (i don&apos;t want to check if the document already exists or not)&lt;/p&gt;

&lt;p&gt;I happen to be working with context b, but I suspect &apos;a&apos; makes more sense.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Should we have different xml syntax for document modification vs add?  Erik suggested:&lt;/p&gt;

&lt;p&gt;&amp;lt;update overwrite=&quot;title&quot; distinct=&quot;cat&quot;&amp;gt;&lt;br/&gt;
 ...&lt;br/&gt;
&amp;lt;/update&amp;gt;&lt;/p&gt;

&lt;p&gt;since &apos;update&apos; is already used in a few ways, maybe &amp;lt;modify&amp;gt;?&lt;/p&gt;

&lt;p&gt;Should we put the id as an xml attribute?  this would make it possible to change the unique key.&lt;br/&gt;
  &amp;lt;modify id=&quot;ID&quot;&amp;gt;&lt;br/&gt;
   &amp;lt;field name=&quot;id&quot;&amp;gt;new id&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;/modify&amp;gt;&lt;br/&gt;
That may look weird if the uniqueKeyField is not called &quot;id&quot;&lt;/p&gt;

&lt;p&gt;Assuming we put the modes as attributes, I guess multiple fields would be comma delimited?&lt;br/&gt;
 &amp;lt;modify distinct=&quot;cat,keyword&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;Do you like the default mode called &quot;default&quot; or &quot;mode&quot;?&lt;br/&gt;
&amp;lt;modify id=&quot;ID&quot; default=&quot;overwrite&quot;&amp;gt;?&lt;br/&gt;
&amp;lt;modify id=&quot;ID&quot; mode=&quot;overwrite&quot;&amp;gt;?&lt;/p&gt;








</comment>
                            <comment id="12526272" author="ryantxu" created="Mon, 10 Sep 2007 22:25:38 +0100"  >&lt;p&gt;applies to /trunk&lt;/p&gt;</comment>
                            <comment id="12529710" author="ryantxu" created="Sat, 22 Sep 2007 23:43:35 +0100"  >&lt;p&gt;applies with trunk...&lt;/p&gt;</comment>
                            <comment id="12544856" author="joergkie" created="Thu, 22 Nov 2007 17:53:59 +0000"  >&lt;p&gt;A useful feature would be &quot;update based on query&quot;, so that documents matching the query condition will all be modified in the same way on the given update fields. &lt;br/&gt;
This feature would correspond to SQL&apos;s UPDATE command, so that Solr would now cover all the basic commands SQL provides.  (While this is a theoretic motivation, I just missed this feature for my Solr projects..)&lt;/p&gt;</comment>
                            <comment id="12564884" author="ryantxu" created="Fri, 1 Feb 2008 19:09:48 +0000"  >&lt;p&gt;updated to work with trunk.  no real changes.&lt;/p&gt;

&lt;p&gt;The final version of this will need to move updating logic out of the processor into the UpdateHandler&lt;/p&gt;</comment>
                            <comment id="12564896" author="yseeley@gmail.com" created="Fri, 1 Feb 2008 19:25:24 +0000"  >&lt;p&gt;I&apos;m having second thoughts if this is a good enough approach to really put in core Solr.&lt;br/&gt;
Requiring that all fields be stored is a really large drawback, esp for large indicies with really large documents.&lt;/p&gt;</comment>
                            <comment id="12564910" author="ryantxu" created="Fri, 1 Feb 2008 19:52:30 +0000"  >&lt;p&gt;that is part of why i thought having it in an update request processor makes sense &amp;#8211; it can easily be subclassed to pull the existing fields from whereever it needs.  Even if it is directly in the UpdateHandler, there could be some interface to &lt;em&gt;loadExistingFields( id )&lt;/em&gt; or something similar.&lt;/p&gt;</comment>
                            <comment id="12573906" author="otis" created="Fri, 29 Feb 2008 19:10:18 +0000"  >&lt;p&gt;I&apos;m looking at this issue now.  I used to think &quot;sure, this will work fine&quot;, but I&apos;m looking at a 1B doc index (split over N servers) and am suddenly very scared of having to store more than necessary in the index.  In other words, writing custom field value loaders from external storage sounds like the right thing to do.  Perhaps one such loader could simply load from the index itself. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12582401" author="goksron" created="Wed, 26 Mar 2008 19:08:38 +0000"  >&lt;p&gt;If I may comment?  &lt;/p&gt;

&lt;p&gt;Is it ok if a first implementation requires all fields to stored, and then a later iteration supports non-stored fields?  This seems to be a complex problem, and you might decide later that the first design is completely bogus.&lt;/p&gt;

</comment>
                            <comment id="12586372" author="ryantxu" created="Mon, 7 Apr 2008 14:03:32 +0100"  >&lt;p&gt;updated patch to work with trunk&lt;/p&gt;</comment>
                            <comment id="12591317" author="dsmiley" created="Tue, 22 Apr 2008 15:49:36 +0100"  >&lt;p&gt;I agree Lance.  I don&apos;t know what the &quot;first design&quot; is that might be bogus you&apos;re talking about... but we definitely &lt;b&gt;eventually&lt;/b&gt; want to handle non-stored fields.  I have an index that isn&apos;t huge and I&apos;m salivating at the prospects of doing an update.  For non-stored fields... it seems that if an update always over-writes such fields with new data then we should be able to support that now easily because we don&apos;t care what the old data was.&lt;/p&gt;

&lt;p&gt;For non-stored fields that need to be retained (Otis &amp;amp; Yoniks concern)... I wonder what Lucene exposes about the indexed data for a non-stored field.  We&apos;d just want to copy this low-level data over to a new document, basically.&lt;/p&gt;</comment>
                            <comment id="12591323" author="yseeley@gmail.com" created="Tue, 22 Apr 2008 16:07:06 +0100"  >&lt;blockquote&gt;
&lt;p&gt;For non-stored fields that need to be retained (Otis &amp;amp; Yoniks concern)... I wonder what Lucene exposes about the indexed data for a non-stored field. We&apos;d just want to copy this low-level data over to a new document, basically.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Lucene maintains an inverted index, so the &quot;indexed&quot; part is spread over the entire index (terms point to documents).  Copying an indexed field would require looping over every indexed term (all documents with that field).  It would be &lt;b&gt;very&lt;/b&gt; slow once an index got large.&lt;/p&gt;</comment>
                            <comment id="12601408" author="billa" created="Sat, 31 May 2008 20:36:37 +0100"  >&lt;p&gt;I noticed that this bug is no longer included in the 1.3 release.  Are there any outstanding issues if all the fields are stored?  Requiring that all fields are stored for a document to be update-able seems like reasonable to me.  This feature will simplify things for Solr users who are doing a query to get all the fields following by an add when they only want to update a very small number of fields.&lt;/p&gt;</comment>
                            <comment id="12601614" author="ryantxu" created="Mon, 2 Jun 2008 13:27:22 +0100"  >&lt;p&gt;the biggest reason this patch won&apos;t work is that with &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-559&quot; title=&quot;use Lucene updateDocument, deleteDocuments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-559&quot;&gt;&lt;del&gt;SOLR-559&lt;/del&gt;&lt;/a&gt;, the DirectUpdateHandler2 does not keep track of pending updates &amp;#8211; to get this to work again, it will need to maintain a list somewhere.&lt;/p&gt;

&lt;p&gt;Also, we need to make sure the API lets you grab stored fields from somewhere else &amp;#8211; as is, it forces you to store all fields for all documents.&lt;/p&gt;</comment>
                            <comment id="12616399" author="noble.paul" created="Thu, 24 Jul 2008 10:05:26 +0100"  >&lt;p&gt;How about maintaining a separate index at store.index and write all the documents to that index also. &lt;/p&gt;

&lt;p&gt;In the store.index , all the fields must be stored and none will be indexed. This index will not have any copy fields . It will blindly dump the data as it is.&lt;/p&gt;

&lt;p&gt;Updating can be done by reading data from this.  Deletion must also be done on both the indices&lt;/p&gt;

&lt;p&gt;This way the original index will be small and the users do not have to make all fields stored&lt;/p&gt;</comment>
                            <comment id="12616467" author="dsmiley" created="Thu, 24 Jul 2008 13:38:48 +0100"  >&lt;p&gt;It&apos;s unclear to me how your suggestion, Paul, is better.  If at the end of the day, all the fields must be stored on disk somewhere (and that is the case), then why complicate matters and split out the storage of the fields into a separate index?  In my case, nearly all of my fields are stored so this would be redundant.  AFAIK, having your &quot;main&quot; index &quot;small&quot; only matters as far as index storage, not stored-field storage.  So I don&apos;t get the point in this.&lt;/p&gt;</comment>
                            <comment id="12616564" author="ryantxu" created="Thu, 24 Jul 2008 19:20:22 +0100"  >&lt;p&gt;There are many approaches to make this work &amp;#8211; i don&apos;t think there will be a one-size-fits all approach though.  Storing all fields in the lucene index may be fine.  Perhaps we want to write the xml to disk when it is indexed, then reload it when the file is &apos;updated&apos;, perhaps the content should be stored in a SQL db.&lt;/p&gt;

&lt;p&gt;David - storing all data in the search index can be a problem because it can get BIG.  Imagine if nutch stored the raw content in the lucene index?  (I may be wrong on this) even with Lazy loading, there is a query time cost to having stored fields.&lt;/p&gt;

&lt;p&gt;In general, I think we just need an API that will allow for a variety of storage mechanisms.&lt;/p&gt;</comment>
                            <comment id="12616570" author="dsmiley" created="Thu, 24 Jul 2008 19:35:57 +0100"  >&lt;p&gt;Ryan, I know of course the index can get big because one needs to store all the data for re-indexing; but due to Lucene&apos;s fundamental limitations, we can&apos;t get around that fact.  Moving the data off to another place (a DB of some sort or whatever) doesn&apos;t change the fundamental problem.  If one is unwilling to store a copy somewhere convenient due to data scalability issues then we simply cannot support the feature because Lucene doesn&apos;t have an underlying update capability.&lt;/p&gt;

&lt;p&gt;If the schema&apos;s field isn&apos;t stored, then it may be useful to provide an API that can fetch un-stored fields for a given document.  I don&apos;t think it&apos;d be common to use the API and definitely wouldn&apos;t be worth providing a default implementation.&lt;/p&gt;</comment>
                            <comment id="12616725" author="ab" created="Fri, 25 Jul 2008 01:38:22 +0100"  >&lt;p&gt;It&apos;s possible to recover unstored fields, if the purpose of such recovery is to make a copy of the document and update other fields. The process is time-consuming, because you need to traverse all postings for all terms, so it might be impractical for larger indexes. Furthermore, such recovered content may be incomplete - tokens may have been changed or skipped/added by analyzers, positionIncrement gaps may have been introduced, etc, etc.&lt;/p&gt;

&lt;p&gt;Most of this functionality is implemented in Luke &quot;Restore &amp;amp; Edit&quot; function. Perhaps it&apos;s possible to implement a new low-level Lucene API to do it more efficiently.&lt;/p&gt;</comment>
                            <comment id="12616729" author="klaasm" created="Fri, 25 Jul 2008 02:01:57 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;quote&amp;#93;&lt;/span&gt;David - storing all data in the search index can be a problem because it can get BIG. Imagine if nutch stored the raw content in the lucene index? (I may be wrong on this) even with Lazy loading, there is a query time cost to having stored fields.&lt;span class=&quot;error&quot;&gt;&amp;#91;/quote&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Splitting it out into another store is much better at scale.  A distinct lucene index works relatively well.&lt;/p&gt;
</comment>
                            <comment id="12616762" author="noble.paul" created="Fri, 25 Jul 2008 05:33:58 +0100"  >&lt;ul&gt;
	&lt;li&gt;If your index is really big most likely you may have a master/slave deployment. In that case only master needs to store the data copy. The slaves do not have to pay the &apos;update tax&apos;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;Perhaps we want to write the xml to disk when it is indexed, then reload it when the file is &apos;updated&apos;, perhaps the content should be stored in a SQL db. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Writing the xml may not be an option if I use DIH for indexing (there is no xml). And what if I use CSV. That means multiple storage formats. RDDBMS storage is a problem because of incompatibility of Lecene/RDBMS data structures. Creating a schema will be extremely hard because of dynamic fields&lt;/p&gt;

&lt;p&gt;I guess we can have multiple solutions. I can provide a simple DuplicateIndexUpdateProcessor (for lack of a better name) which can store all the data in a duplicate index. Let the user decide what he wants&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s possible to recover unstored fields, if the purpose of such recovery is to make a copy of the document and update other fields.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It is not wise to invest our time to do &apos;very clever&apos; things because it is error prone. Unless Lucene gives us a clean API to do so&lt;/p&gt;</comment>
                            <comment id="12623383" author="noble.paul" created="Mon, 18 Aug 2008 16:42:58 +0100"  >&lt;p&gt;Shall I open another issue on my idea keeping another index for just stored fields (in an UpdateRequestProcessor). &lt;/p&gt;

&lt;p&gt;Is it a good idea to have multiple approaches for the same feature? &lt;br/&gt;
Or should I post the patch in this issue only?&lt;/p&gt;</comment>
                            <comment id="12623385" author="ryantxu" created="Mon, 18 Aug 2008 16:50:37 +0100"  >&lt;p&gt;to me the key is getting an interface that would allow for the existing fields to be stored a number of ways:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;within the index itself&lt;/li&gt;
	&lt;li&gt;within an independent index (as you suggest)&lt;/li&gt;
	&lt;li&gt;within SQL&lt;/li&gt;
	&lt;li&gt;on the file system&lt;/li&gt;
	&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12623416" author="noble.paul" created="Mon, 18 Aug 2008 18:44:28 +0100"  >&lt;p&gt;there are pros and cons w/ each approaches (am I discovering a universal truth here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )&lt;/p&gt;

&lt;p&gt;Many approaches can to confuse users . I can propose something like &lt;/p&gt;

&lt;p&gt;&amp;lt;modifiable&amp;gt;true&amp;lt;/modifiable&amp;gt; in the manIndex .&lt;br/&gt;
And say &lt;br/&gt;
&amp;lt;modificationStrategy&amp;gt;solr.SepareteIndexStrategy&amp;lt;/modificationStrategy&amp;gt;&lt;br/&gt;
or&lt;br/&gt;
&amp;lt;modificationStrategy&amp;gt;solr.SameIndexStrategy&amp;lt;/modificationStrategy&amp;gt;&lt;/p&gt;

&lt;p&gt;(I did not mention  the other two because of personal preferences &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  )&lt;/p&gt;</comment>
                            <comment id="12670783" author="shalinmangar" created="Thu, 5 Feb 2009 15:10:11 +0000"  >&lt;p&gt;Marking for 1.5&lt;/p&gt;</comment>
                            <comment id="12702778" author="marcusherou" created="Sat, 25 Apr 2009 21:49:12 +0100"  >&lt;p&gt;It would make sense of adding ParallelReader functionality so a core can read from several index-dirs. &lt;br/&gt;
Guess it complicates things a little since you would need to have support for adding data as well to more than one index.&lt;/p&gt;

&lt;p&gt;Suggestion:&lt;br/&gt;
/update/coreX/index1 - Uses schema1.xml&lt;br/&gt;
/update/coreX/index2 - Uses schema2.xml&lt;br/&gt;
/select/coreX - Uses all schemas e.g. A ParallelReader.&lt;/p&gt;

&lt;p&gt;Seing quite a lot questions on the mailinglist about users that want to be able to update a single field while maintaining the rest of the index intact (not reindex).&lt;/p&gt;
</comment>
                            <comment id="12702883" author="yseeley@gmail.com" created="Sun, 26 Apr 2009 14:23:42 +0100"  >&lt;p&gt;ParallelReader assumes you have two indexes that &quot;line up&quot; so the internal docids match.  Maintaining something like that would currently be pretty hard or impractical.&lt;/p&gt;</comment>
                            <comment id="12787072" author="mdiggory" created="Mon, 7 Dec 2009 19:40:53 +0000"  >&lt;p&gt;I notice this is a very long lived issue and that it is marked for 1.5.  Are there outstanding issues or problems with its usage if I apply it to my 1.4 source?&lt;/p&gt;</comment>
                            <comment id="12872416" author="hossman" created="Thu, 27 May 2010 23:04:49 +0100"  >&lt;p&gt;Bulk updating 240 Solr issues to set the Fix Version to &quot;next&quot; per the process outlined in this email...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-dev/201005.mbox/%3Calpine.DEB.1.10.1005251052040.24672@radix.cryptio.net%3E&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-dev/201005.mbox/%3Calpine.DEB.1.10.1005251052040.24672@radix.cryptio.net%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Selection criteria was &quot;Unresolved&quot; with a Fix Version of 1.5, 1.6, 3.1, or 4.0.  email notifications were suppressed.&lt;/p&gt;

&lt;p&gt;A unique token for finding these 240 issues in the future: hossversioncleanup20100527&lt;/p&gt;</comment>
                            <comment id="12987837" author="ravish" created="Thu, 27 Jan 2011 23:55:49 +0000"  >&lt;p&gt;This seems like a very old issue as someone suggested.  Is there any update on whether it will ever be resolved?  It is quite important feature and causes big problems when you have a huge index and only need to update one column.&lt;/p&gt;</comment>
                            <comment id="13021007" author="gbremer" created="Mon, 18 Apr 2011 13:43:23 +0100"  >&lt;p&gt;I need this feature. How much do I have to pay in order to get this issue fixed? Can I pass around a piggy bank?&lt;/p&gt;</comment>
                            <comment id="13269007" author="yseeley@gmail.com" created="Sat, 5 May 2012 17:45:09 +0100"  >&lt;p&gt;Here&apos;s a patch for updateable docs that reuses the infrastructure we put in place around versioning and realtime-get.&lt;/p&gt;

&lt;p&gt;Only the JSON parser is currently implemented.&lt;/p&gt;

&lt;p&gt;Recall that a normal field value in JSON is of the form:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-quote&quot;&gt;&quot;myfield&quot;&lt;/span&gt;:10
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This patch extends the JSON parser to support extended values as a Map.  For example, to add an additional value to a multi-valued field, you would use&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-quote&quot;&gt;&quot;myfield&quot;&lt;/span&gt;:{&lt;span class=&quot;code-quote&quot;&gt;&quot;add&quot;&lt;/span&gt;:10}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using an existing data structure (a Map) should allow us to pass this through javabin format w/o any additional changes.&lt;/p&gt;

&lt;p&gt;This patch depends on optimistic locking (it&apos;s currently included in this patch) and updating documents fully supports optimistic locking (i.e. you can conditionally update a document based on it&apos;s version)&lt;/p&gt;

&lt;p&gt;Right now only &quot;add&quot; and &quot;set&quot; are supported as mutators (and setting a null value is like &quot;remove&quot;), but I figured it would be best to do a slice first from start to finish.&lt;/p&gt;

&lt;p&gt;Comments?&lt;/p&gt;</comment>
                            <comment id="13269042" author="yseeley@gmail.com" created="Sat, 5 May 2012 20:38:10 +0100"  >&lt;p&gt;I&apos;m working in getting an XML syntax going.  The easiest/least disruptive seems to be an attribute:&lt;/p&gt;

&lt;p&gt;Current:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;foo&quot;&lt;/span&gt; boost=&lt;span class=&quot;code-quote&quot;&gt;&quot;2.5&quot;&lt;/span&gt;&amp;gt;100&amp;lt;/foo&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Proposed:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;foo&quot;&lt;/span&gt; boost=&lt;span class=&quot;code-quote&quot;&gt;&quot;2.5&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;add&quot;&lt;/span&gt;&amp;gt;100&amp;lt;/foo&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13269078" author="janhoy" created="Sat, 5 May 2012 23:55:57 +0100"  >&lt;p&gt;Cool. Any plans for supporting modification of existing value? Most useful would be add, subtract (for numeric) and append text for textual. (In FAST ESP we had this as part of the partial update APIs)&lt;/p&gt;</comment>
                            <comment id="13269081" author="yseeley@gmail.com" created="Sun, 6 May 2012 00:07:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;Cool. Any plans for supporting modification of existing value?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Definitely!&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;increment or inc (add is taken for adding additional field values).  decrement not needed (just use a negative increment)&lt;/li&gt;
	&lt;li&gt;append/prepend (and maybe allow &quot;add&quot; to mean &quot;append&quot; if a text/string field is multi-valued)&lt;/li&gt;
	&lt;li&gt;set operations for multi-valued fields (union, intersection, remove, etc)&lt;/li&gt;
	&lt;li&gt;we could get into conditionals, but at some point we should just punt that to a script-updator (i.e. update this document using the given script)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13269101" author="dsmiley" created="Sun, 6 May 2012 02:41:23 +0100"  >&lt;p&gt;Yonik; I don&apos;t see your patch.  Will this support the ability to replace a text field that is indexed?  If so, what is the essence of the implementation?  The most common use-case I need for my employer involves essentially a complete re-indexing of all docs but only for a few particular fields. I tend to think, at least for my use-case, that it is within reach if I had enough time to work on it.  The implementation concept I have involves building parallel segments with aligned docids.  Segment merging would clean out older versions of a field.&lt;/p&gt;</comment>
                            <comment id="13269104" author="yseeley@gmail.com" created="Sun, 6 May 2012 02:59:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;Yonik; I don&apos;t see your patch. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Try sorting by date, or click on the &quot;All&quot; tab and you can see where I added it.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12525736/SOLR-139.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/secure/attachment/12525736/SOLR-139.patch&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;what is the essence of the implementation?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is the simplest form.  Original fields need to be stored.  The document is retrieved and then re-indexed after modification.&lt;/p&gt;</comment>
                            <comment id="13269191" author="ab" created="Sun, 6 May 2012 12:41:51 +0100"  >&lt;p&gt;David, please see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3837&quot; title=&quot;A modest proposal for updateable fields&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-3837&quot;&gt;LUCENE-3837&lt;/a&gt; for a low-level partial update of inverted fields without re-indexing other fields. That is very much work in progress, and it&apos;s more complex. This issue provides a shortcut to a &quot;retrieve stored fields, modify, delete original doc, add modified doc&quot; sequence that users would have to execute manually.&lt;/p&gt;</comment>
                            <comment id="13269683" author="yseeley@gmail.com" created="Mon, 7 May 2012 16:14:22 +0100"  >&lt;p&gt;Here&apos;s an updated patch with XML support and cloud tests.&lt;/p&gt;

&lt;p&gt;The underlying mechanism for updating a field always change in the future (and depending on the field type), so the really important part of this is the API.&lt;/p&gt;

&lt;p&gt;I plan on committing soon unless someone comes does come up with some API improvements.&lt;/p&gt;</comment>
                            <comment id="13270612" author="yseeley@gmail.com" created="Tue, 8 May 2012 18:03:13 +0100"  >&lt;p&gt;Committed (5 years after the issue was opened!)&lt;/p&gt;

&lt;p&gt;I&apos;ll keep this issue open and we can add follow-on patches to implement increment and other set operations.&lt;/p&gt;</comment>
                            <comment id="13282202" author="seshun" created="Thu, 24 May 2012 06:29:31 +0100"  >&lt;p&gt;yonik,  I see a small issue with this.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I have added one of the example document from exampledocs folder.  The schema has &quot;price&quot; and &quot;price_c&quot; (copy field from price)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;1.When i add the document, it looks as follows:&lt;/p&gt;

&lt;p&gt;&amp;lt;str name=&quot;id&quot;&amp;gt;TWINX2048-3200PRO&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;str name=&quot;name&quot;&amp;gt;CORSAIR  XMS 2GB (2 x 1GB) 184-Pin DDR SDRAM Unbuffered DDR&lt;br/&gt;
                    400 (PC 3200) Dual Channel Kit System Memory - Retail&lt;br/&gt;
&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;str name=&quot;manu&quot;&amp;gt;Corsair Microsystems Inc.&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;float name=&quot;price&quot;&amp;gt;185.0&amp;lt;/float&amp;gt;&lt;br/&gt;
&amp;lt;arr name=&quot;price_c&quot;&amp;gt;&lt;br/&gt;
   &amp;lt;str&amp;gt;185,USD&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;/arr&amp;gt;&lt;/p&gt;

&lt;p&gt;2. Now I want to set price field with 100 , so I sent a json for it.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;{&amp;quot;id&amp;quot;:&amp;quot;TWINX2048-3200PRO&amp;quot;,&amp;quot;price&amp;quot;:{&amp;quot;set&amp;quot;:100}}&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Now the document looks as follows:&lt;br/&gt;
&amp;lt;str name=&quot;id&quot;&amp;gt;TWINX2048-3200PRO&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;str name=&quot;name&quot;&amp;gt;CORSAIR  XMS 2GB (2 x 1GB) 184-Pin DDR SDRAM Unbuffered DDR&lt;br/&gt;
                    400 (PC 3200) Dual Channel Kit System Memory - Retail&lt;br/&gt;
&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;str name=&quot;manu&quot;&amp;gt;Corsair Microsystems Inc.&amp;lt;/str&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;float name=&quot;price&quot;&amp;gt;100.0&amp;lt;/float&amp;gt;&lt;br/&gt;
&amp;lt;arr name=&quot;price_c&quot;&amp;gt;&lt;br/&gt;
      &amp;lt;str&amp;gt;100,USD&amp;lt;/str&amp;gt;&lt;br/&gt;
      &amp;lt;str&amp;gt;185,USD&amp;lt;/str&amp;gt;&lt;br/&gt;
&amp;lt;/arr&amp;gt;&lt;/p&gt;


&lt;p&gt;as you can see, the old price value still there in the &quot;price_c&quot;. Is there a workaround/patch we can do for this?&lt;/p&gt;</comment>
                            <comment id="13282532" author="yseeley@gmail.com" created="Thu, 24 May 2012 15:43:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;The schema has &quot;price&quot; and &quot;price_c&quot; (copy field from price)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For this feature to work correctly, source fields (the ones you normally send in) should be stored, and copyField targets (like price_c) should be un-stored.&lt;/p&gt;</comment>
                            <comment id="13397739" author="mkhludnev" created="Wed, 20 Jun 2012 19:30:45 +0100"  >&lt;p&gt;Yonik,&lt;/p&gt;

&lt;p&gt;it&apos;s hard to follow for me. Can&apos;t you clarify what&apos;s actually can be updated stored/indexed field, field cache? Where update will be searchable? &lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;</comment>
                            <comment id="13413687" author="yseeley@gmail.com" created="Fri, 13 Jul 2012 13:29:46 +0100"  >&lt;p&gt;Per the discussion on the mailing list, here&apos;s a patch that creates the document being updated if it doesn&apos;t exist already.  The standard optimistic concurrency mechanism can be used to specify that a document must exist if desired.&lt;/p&gt;</comment>
                            <comment id="13414324" author="yseeley@gmail.com" created="Sat, 14 Jul 2012 10:06:35 +0100"  >&lt;p&gt;The create-if-not-exist patch was committed to both trunk and 4x branch.&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?rev=1361301&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=1361301&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13442472" author="christopherball" created="Mon, 27 Aug 2012 16:34:31 +0100"  >&lt;p&gt;Yonik,&lt;/p&gt;

&lt;p&gt;Do you have an example with the XML syntax? I have been trying to test this in 4.0-Beta, but am obviously not grokking the right syntax =(&lt;br/&gt;
Also, have you tried to use this with a join query? I can think of some interesting use cases =)&lt;/p&gt;

&lt;p&gt;Regards&lt;/p&gt;</comment>
                            <comment id="13443446" author="dmaddi123" created="Tue, 28 Aug 2012 20:40:26 +0100"  >&lt;p&gt;Christopher, &lt;br/&gt;
Here is how I am able to update a document by posting an XML&lt;br/&gt;
&amp;lt;add&amp;gt;&lt;br/&gt;
  &amp;lt;doc&amp;gt;&lt;br/&gt;
    &amp;lt;field name=&quot;id&quot;&amp;gt;VA902B&amp;lt;/field&amp;gt;&lt;br/&gt;
    &amp;lt;field name=&quot;price&quot; update=&quot;set&quot;&amp;gt;300&amp;lt;/field&amp;gt;&lt;br/&gt;
  &amp;lt;/doc&amp;gt;&lt;br/&gt;
&amp;lt;/add&amp;gt;&lt;/p&gt;</comment>
                            <comment id="13456391" author="rcmuir" created="Sat, 15 Sep 2012 13:49:26 +0100"  >&lt;p&gt;Unassigned issues -&amp;gt; 4.1&lt;/p&gt;</comment>
                            <comment id="13457326" author="timmsc" created="Mon, 17 Sep 2012 22:07:36 +0100"  >&lt;p&gt;It appears that SolrJ does not yet (as of 4.0 Alpha) support updating fields in a document.  Is there a separate Jira ticket for this?&lt;/p&gt;</comment>
                            <comment id="13483495" author="mlissner" created="Wed, 24 Oct 2012 20:20:07 +0100"  >&lt;p&gt;Can we get this on the Wiki somewhere? I&apos;ve been looking around, haven&apos;t been able to find it. Not sure where to put it...&lt;/p&gt;</comment>
                            <comment id="13483496" author="mattaltermatt" created="Wed, 24 Oct 2012 20:22:11 +0100"  >&lt;p&gt;&#65279;&lt;br/&gt;
I will be out of the office until the 29th of October.&lt;/p&gt;

&lt;p&gt;If you need immediate assistance, please contact IT Integration (itintegration@paml.com) or my manager Jon Tolley (jtolley@paml.com).&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;

&lt;p&gt;PAML EMAIL DISCLAIMER:&lt;br/&gt;
Information contained in this message may be privileged and confidential. &lt;br/&gt;
If the reader of this message is not the intended recipient, be notified &lt;br/&gt;
that any dissemination, distribution or copying of this communication is &lt;br/&gt;
strictly prohibited. If this communication is received in error, please &lt;br/&gt;
notify the sender immediately by replying to the message and deleting &lt;br/&gt;
from your computer. Thank you&lt;/p&gt;</comment>
                            <comment id="13485544" author="jnothman" created="Sun, 28 Oct 2012 01:36:53 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I&apos;m a fan of the feature, but not really a fan of the syntax, for the following reasons:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;It is extremely verbose for batch update operations, e.g. setting a new field on all documents in the index. Surely the update modes should be specified outside of each individual record (either as URL query parameters, or in some content header/wrapper). The current approach is entirely inappropriate for extending to CSV, which might otherwise be an obvious choice of format when  adding a single field to each of a set of objects.&lt;/li&gt;
	&lt;li&gt;The distinction between an &quot;insert&quot; and an &quot;update&quot; operation (in SQL terms) is implicit, only indicated by the presence of an object in a JSON value, or by the presence of update in any one of the specified fields. Since insert and update operations are quite distinct on the server, it should select between these on a per-request basis, not per-record.&lt;/li&gt;
	&lt;li&gt;The JSON syntax would appear as if one could extend 
{&quot;set&quot;:100}
&lt;p&gt; to &lt;/p&gt;
{&quot;set&quot;:100,&quot;inc&quot;:2}
&lt;p&gt; on the same field, which is nonsense. It uses JSON a object for inappropriate semantics, where what one actually means is &lt;/p&gt;
{&quot;op&quot;:&quot;set&quot;,&quot;val&quot;:100}
&lt;p&gt;, or even &lt;/p&gt;
{&quot;name&quot;:&quot;price&quot;,&quot;op&quot;:&quot;set&quot;,&quot;val&quot;:100}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;It may be worth reserving JSON-object-as-value for something more literal in the future.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13503003" author="jkrupan" created="Fri, 23 Nov 2012 03:44:22 +0000"  >&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="13504540" author="lukasgraf" created="Tue, 27 Nov 2012 11:10:25 +0000"  >&lt;p&gt;This feature doesn&apos;t work as advertised in Solr 4.0.0 (final).&lt;/p&gt;

&lt;p&gt;Since it&apos;s not documented, I used the information in these blog posts (&lt;a href=&quot;http://yonik.com/solr/atomic-updates/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;yonik.com&lt;/a&gt;, &lt;a href=&quot;http://solr.pl/en/2012/07/09/solr-4-0-partial-documents-update/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;solr.pl&lt;/a&gt;) and this ticket to try to get it working, and asked in the #solr IRC channel, to no avail.&lt;/p&gt;

&lt;p&gt;Whenever I use the &apos;set&apos; command in an update message, it mangles the value to something like &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;str name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Title&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;{set=My new title}&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/str&amp;gt;&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; , and drops all other fields.&lt;/p&gt;

&lt;p&gt;I tried the JSON as well as the XML Syntax for the update message, and I tried it with both a manually defined &apos;&lt;em&gt;version&lt;/em&gt;&apos; field and without.&lt;/p&gt;

&lt;p&gt;Relevant parts from my schema.xml:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;schema name=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr-instance&quot;&lt;/span&gt; version=&lt;span class=&quot;code-quote&quot;&gt;&quot;1.4&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;fields&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Creator&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;string&quot;&lt;/span&gt; indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; required=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; multiValued=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Title&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;text&quot;&lt;/span&gt; indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; required=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; multiValued=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;UID&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;string&quot;&lt;/span&gt; indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; required=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; multiValued=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;_version_&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;long&quot;&lt;/span&gt; indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; required=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; multiValued=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/fields&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;&lt;/span&gt;

    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;uniqueKey&amp;gt;&lt;/span&gt;UID&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/uniqueKey&amp;gt;&lt;/span&gt;

&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/schema&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I initially created some content like this:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;$ curl &apos;localhost:8983/solr/update?commit=true&apos; -H &apos;Content-type:application/json&apos; -d &apos;[{&quot;UID&quot;:&quot;7cb8a43c&quot;,&quot;Title&quot;:&quot;My original Title&quot;, &quot;Creator&quot;: &quot;John Doe&quot;}]&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which resulted in this document:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;doc&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;str name=&lt;span class=&quot;code-quote&quot;&gt;&quot;UID&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;7cb8a43c&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/str&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;str name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Title&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;My original Title&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/str&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;str name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Creator&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;John Doe&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/str&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/doc&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then I tried to update that document with this statement:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;$ curl &apos;localhost:8983/solr/update?commit=true&apos; -H &apos;Content-type:application/json&apos; -d &apos;[{&quot;UID&quot;:&quot;7cb8a43c&quot;,&quot;Title&quot;:{&quot;set&quot;:&quot;My new title&quot;}}]&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which resulted in this mangled document:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;doc&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;str name=&lt;span class=&quot;code-quote&quot;&gt;&quot;UID&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;7cb8a43c&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/str&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;str name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Title&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;{set=My new title}&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/str&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/doc&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(I would have expected the document to still have the value &apos;John Doe&apos; for the &apos;Creator&apos; field,&lt;br/&gt;
and have the value of its &apos;Title&apos; field update to &apos;My new title&apos;)&lt;/p&gt;

&lt;p&gt;I tried using the XML format for the update message as well:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;add&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;doc&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;UID&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;7cb8a43c&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;Title&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;My new title&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/doc&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/add&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Same result as above.&lt;/p&gt;</comment>
                            <comment id="13504724" author="jkrupan" created="Tue, 27 Nov 2012 16:20:04 +0000"  >&lt;p&gt;I just tried it and the feature does work as advertised. If there is a bug, that should be filed as a separate issue. If there is a question or difficulty using the feature, that should be pursued on the Solr user list.&lt;/p&gt;

&lt;p&gt;For reference, I took a fresh, stock copy of the Solr 4.0 example, no changes to schema or config, and added one document:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
curl &apos;localhost:8983/solr/update?commit=&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&apos; -H &apos;Content-type:application/json&apos; -d &apos;
[{&lt;span class=&quot;code-quote&quot;&gt;&quot;id&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;id-123&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;title&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;My original Title&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;: &lt;span class=&quot;code-quote&quot;&gt;&quot;Initial content&quot;&lt;/span&gt;}]&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I queried it and it looked fine.&lt;/p&gt;

&lt;p&gt;I then modified only the title field:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
curl &apos;localhost:8983/solr/update?commit=&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&apos; -H &apos;Content-type:application/json&apos; -d &apos;
[{&lt;span class=&quot;code-quote&quot;&gt;&quot;id&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;id-123&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;title&quot;&lt;/span&gt;:{&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;My &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; title&quot;&lt;/span&gt;}}]&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I tried the XML equivalents and that worked fine as well, with the original content field preserved.&lt;/p&gt;</comment>
                            <comment id="13505035" author="lukasgraf" created="Tue, 27 Nov 2012 22:39:20 +0000"  >&lt;p&gt;Thanks for your response. I thought I had the issue reduced to a simple enough test case, but apparently not. I will try again with a clean stock Solr 4.0, and file a seperate issue if necessary, or look for support on the mailing list. My choice of words (&apos;doesn&apos;t work as advertised&apos;) might have been influenced by frustration about the lack of documentation, sorry for the noise.&lt;/p&gt;</comment>
                            <comment id="13505040" author="jkrupan" created="Tue, 27 Nov 2012 22:50:09 +0000"  >&lt;p&gt;No apology necessary for the noise. I mean, none of us was able to offer a prompt response to earlier inquiries and this got me focused on actually trying the feature for the first time.&lt;/p&gt;</comment>
                            <comment id="13505054" author="markrmiller@gmail.com" created="Tue, 27 Nov 2012 23:21:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;about the lack of documentation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since you are eating some of this pain, perhaps you could give a hand when you have it figured out and contribute to our wiki? &lt;a href=&quot;http://wiki.apache.org/solr/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/solr/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13506298" author="lukasgraf" created="Thu, 29 Nov 2012 07:47:28 +0000"  >&lt;p&gt;Certainly, to the extent that I can.&lt;/p&gt;</comment>
                            <comment id="13506392" author="lukasgraf" created="Thu, 29 Nov 2012 10:58:14 +0000"  >&lt;p&gt;Ok, I finally figured it out by diffing every single difference from my test case to the stock Solr 4.0 example using &lt;em&gt;git bisect&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The culprit was a missing &lt;b&gt;&amp;lt;updateLog /&amp;gt;&lt;/b&gt; directive in &lt;em&gt;solrconfig.xml&lt;/em&gt;. As soon as I configured a transaction log, atomic updates worked as expected. I added a note about this at &lt;a href=&quot;http://wiki.apache.org/solr/UpdateXmlMessages#Optional_attributes_for_.22field.22&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/solr/UpdateXmlMessages#Optional_attributes_for_.22field.22&lt;/a&gt; .&lt;/p&gt;</comment>
                            <comment id="13506520" author="jkrupan" created="Thu, 29 Nov 2012 15:06:38 +0000"  >&lt;p&gt;Oh, yeah, that. I actually was going to mention it, but I wanted to focus on running with the stock Solr example first. Actually, we need to look a little closer as to why/whether the &amp;lt;updateLog&amp;gt; directive is really always needed for partial document update. That should probably be a separate Jira issue.&lt;/p&gt;</comment>
                            <comment id="13506533" author="markrmiller@gmail.com" created="Thu, 29 Nov 2012 15:28:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;we need to look a little closer as to why/whether the &amp;lt;updateLog&amp;gt; directive is really always needed for partial document update.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I believe yonik chose to implement it by using updateLog features.&lt;/p&gt;</comment>
                            <comment id="13506735" author="hossman" created="Thu, 29 Nov 2012 19:56:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;I believe yonik chose to implement it by using updateLog features.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;i think it has to be - the &quot;real time get&quot; support provided by the updateLog is the only way to garuntee that the document will be available to atomicly update it.&lt;/p&gt;

&lt;p&gt;Lukas: if the atomic update code path isn&apos;t throwing a big fat error if you try to use it w/o updateLog configured then that sounds to me like a bug &amp;#8211; can you please file a Jira for that&lt;/p&gt;</comment>
                            <comment id="13506942" author="lukasgraf" created="Thu, 29 Nov 2012 23:35:08 +0000"  >&lt;p&gt;Filed &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-4127&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;SOLR-4127&lt;/a&gt;: Atomic updates used w/o updateLog should throw an error&lt;/p&gt;</comment>
                            <comment id="13547021" author="abhinav.shah@gmail.com" created="Tue, 8 Jan 2013 17:11:58 +0000"  >&lt;p&gt;I am using apache-solr 4.0.&lt;br/&gt;
I am trying to post the following document - &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
curl http:&lt;span class=&quot;code-comment&quot;&gt;//irvis016:8983/solr/collection1/update?commit=&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; -H &lt;span class=&quot;code-quote&quot;&gt;&quot;Content-Type: text/xml&quot;&lt;/span&gt; --data-binary &apos;&amp;lt;add commitWithin=&lt;span class=&quot;code-quote&quot;&gt;&quot;5000&quot;&lt;/span&gt;&amp;gt;&amp;lt;doc boost=&lt;span class=&quot;code-quote&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;accessionNumber&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;3165297&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;status&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;ORDERED&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;account.accountName&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;US LABS DEMO ACCOUNT&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;account.addresses.address1&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;2601 Campus Drive&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;account.addresses.city&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;Irvine&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;account.addresses.state&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;CA&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;account.addresses.zip&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;92622&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;account.externalIds.sourceSystem&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;10442&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;orderingPhysician.lcProviderNumber&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;60086&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;patient.lpid&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;5571351625769103&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;patient.patientName.lastName&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;test&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;patient.patientName.firstName&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;test123&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;patient.patientSSN&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;643522342&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;patient.patientDOB&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;1979-11-11T08:00:00.000Z&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;patient.mrNs.mrn&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;5423&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;specimens.specimenType&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;Bone Marrow&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;specimens.specimenType&quot;&lt;/span&gt; update=&lt;span class=&quot;code-quote&quot;&gt;&quot;set&quot;&lt;/span&gt;&amp;gt;Nerve tissue&amp;lt;/field&amp;gt;&amp;lt;field name=&lt;span class=&quot;code-quote&quot;&gt;&quot;UID&quot;&lt;/span&gt;&amp;gt;3165297USLABS2012&amp;lt;/field&amp;gt;&amp;lt;/doc&amp;gt;&amp;lt;/add&amp;gt;&apos;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This document gets successfully posted. However, the multi-valued field &apos;specimens.specimenType&apos;, gets stored as following in SOLR -&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&amp;lt;arr name=&lt;span class=&quot;code-quote&quot;&gt;&quot;specimens.specimenType&quot;&lt;/span&gt;&amp;gt;
&amp;lt;str&amp;gt;{set=Bone Marrow}&amp;lt;/str&amp;gt;
&amp;lt;str&amp;gt;{set=Nerve tissue}&amp;lt;/str&amp;gt;
&amp;lt;/arr&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I did not expect &quot;{set=&quot; to be stored along with the text &quot;Bone Marror&quot;.&lt;/p&gt;

&lt;p&gt;My Solr schema xml definition for the field specimens.SpecimenType is - &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&amp;lt;field indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; multiValued=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; name=&lt;span class=&quot;code-quote&quot;&gt;&quot;specimens.specimenType&quot;&lt;/span&gt; omitNorms=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;&quot;&lt;/span&gt; omitPositions=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; omitTermFreqAndPositions=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; termVectors=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;text_en&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Can someone help?&lt;/p&gt;</comment>
                            <comment id="13653969" author="thetaphi" created="Fri, 10 May 2013 11:33:35 +0100"  >&lt;p&gt;Closed after release.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12407389">SOLR-828</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12364056">SOLR-181</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12434404">LUCENE-1879</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12372155">SOLR-269</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12354478">SOLR-60</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12365339">SOLR-193</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12360482">SOLR-103</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12379550" name="Eriks-ModifiableDocument.patch" size="66914" author="ryantxu" created="Mon, 7 Apr 2008 14:03:32 +0100"/>
                            <attachment id="12374574" name="Eriks-ModifiableDocument.patch" size="66398" author="ryantxu" created="Fri, 1 Feb 2008 19:09:48 +0000"/>
                            <attachment id="12366413" name="Eriks-ModifiableDocument.patch" size="51053" author="ryantxu" created="Sat, 22 Sep 2007 23:43:35 +0100"/>
                            <attachment id="12365509" name="Eriks-ModifiableDocument.patch" size="53388" author="ryantxu" created="Mon, 10 Sep 2007 22:25:38 +0100"/>
                            <attachment id="12365412" name="Eriks-ModifiableDocument.patch" size="53845" author="ryantxu" created="Sat, 8 Sep 2007 21:30:09 +0100"/>
                            <attachment id="12364891" name="Eriks-ModifiableDocument.patch" size="45555" author="ehatcher" created="Fri, 31 Aug 2007 15:24:57 +0100"/>
                            <attachment id="12360905" name="SOLR-139-IndexDocumentCommand.patch" size="48504" author="ryantxu" created="Mon, 2 Jul 2007 07:59:55 +0100"/>
                            <attachment id="12359956" name="SOLR-139-IndexDocumentCommand.patch" size="37149" author="ryantxu" created="Sun, 17 Jun 2007 20:36:53 +0100"/>
                            <attachment id="12359899" name="SOLR-139-IndexDocumentCommand.patch" size="26443" author="ryantxu" created="Fri, 15 Jun 2007 18:14:53 +0100"/>
                            <attachment id="12356495" name="SOLR-139-IndexDocumentCommand.patch" size="29439" author="ryantxu" created="Mon, 30 Apr 2007 01:31:33 +0100"/>
                            <attachment id="12353726" name="SOLR-139-IndexDocumentCommand.patch" size="36654" author="ryantxu" created="Tue, 20 Mar 2007 10:43:06 +0000"/>
                            <attachment id="12352723" name="SOLR-139-IndexDocumentCommand.patch" size="46842" author="ryantxu" created="Tue, 6 Mar 2007 08:16:53 +0000"/>
                            <attachment id="12351410" name="SOLR-139-IndexDocumentCommand.patch" size="43601" author="ryantxu" created="Sat, 17 Feb 2007 01:39:58 +0000"/>
                            <attachment id="12350705" name="SOLR-139-IndexDocumentCommand.patch" size="33598" author="ryantxu" created="Thu, 8 Feb 2007 21:51:45 +0000"/>
                            <attachment id="12350314" name="SOLR-139-IndexDocumentCommand.patch" size="58086" author="ryantxu" created="Mon, 5 Feb 2007 01:34:36 +0000"/>
                            <attachment id="12350298" name="SOLR-139-IndexDocumentCommand.patch" size="31839" author="ryantxu" created="Sun, 4 Feb 2007 11:28:04 +0000"/>
                            <attachment id="12350297" name="SOLR-139-IndexDocumentCommand.patch" size="31849" author="ryantxu" created="Sun, 4 Feb 2007 08:58:11 +0000"/>
                            <attachment id="12363792" name="SOLR-139-ModifyInputDocuments.patch" size="52433" author="ryantxu" created="Tue, 14 Aug 2007 19:14:15 +0100"/>
                            <attachment id="12363188" name="SOLR-139-ModifyInputDocuments.patch" size="58017" author="ryantxu" created="Sun, 5 Aug 2007 07:16:51 +0100"/>
                            <attachment id="12361798" name="SOLR-139-ModifyInputDocuments.patch" size="40077" author="ryantxu" created="Fri, 13 Jul 2007 18:58:45 +0100"/>
                            <attachment id="12361094" name="SOLR-139-ModifyInputDocuments.patch" size="43833" author="ryantxu" created="Wed, 4 Jul 2007 02:41:43 +0100"/>
                            <attachment id="12350299" name="SOLR-139-XmlUpdater.patch" size="10407" author="ryantxu" created="Sun, 4 Feb 2007 11:29:19 +0000"/>
                            <attachment id="12525858" name="SOLR-139.patch" size="56804" author="yseeley@gmail.com" created="Mon, 7 May 2012 16:14:21 +0100"/>
                            <attachment id="12525736" name="SOLR-139.patch" size="49390" author="yseeley@gmail.com" created="Sat, 5 May 2012 17:45:08 +0100"/>
                            <attachment id="12536373" name="SOLR-139_createIfNotExist.patch" size="3652" author="yseeley@gmail.com" created="Fri, 13 Jul 2012 13:29:46 +0100"/>
                            <attachment id="12361755" name="SOLR-269+139-ModifiableDocumentUpdateProcessor.patch" size="92789" author="ryantxu" created="Fri, 13 Jul 2007 08:44:52 +0100"/>
                            <attachment id="12362787" name="getStoredFields.patch" size="25385" author="yseeley@gmail.com" created="Mon, 30 Jul 2007 19:36:30 +0100"/>
                            <attachment id="12362369" name="getStoredFields.patch" size="19150" author="yseeley@gmail.com" created="Mon, 23 Jul 2007 21:24:47 +0100"/>
                            <attachment id="12362086" name="getStoredFields.patch" size="11317" author="yseeley@gmail.com" created="Wed, 18 Jul 2007 20:00:44 +0100"/>
                            <attachment id="12362083" name="getStoredFields.patch" size="10812" author="yseeley@gmail.com" created="Wed, 18 Jul 2007 19:45:37 +0100"/>
                            <attachment id="12362079" name="getStoredFields.patch" size="10543" author="yseeley@gmail.com" created="Wed, 18 Jul 2007 18:55:35 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 4 Feb 2007 15:35:40 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7446</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxt5r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21043</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>