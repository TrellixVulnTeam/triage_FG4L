<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:17:26 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-940/SOLR-940.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-940] TrieRange support</title>
                <link>https://issues.apache.org/jira/browse/SOLR-940</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;We need support in Solr for the new TrieRange Lucene functionality.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12411367">SOLR-940</key>
            <summary>TrieRange support</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="shalinmangar">Shalin Shekhar Mangar</assignee>
                                    <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Sat, 27 Dec 2008 21:10:21 +0000</created>
                <updated>Tue, 10 Nov 2009 15:51:54 +0000</updated>
                            <resolved>Wed, 15 Jul 2009 18:26:59 +0100</resolved>
                                                    <fixVersion>1.4</fixVersion>
                                        <due></due>
                            <votes>4</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="12676323" author="shalinmangar" created="Tue, 24 Feb 2009 16:13:29 +0000"  >&lt;p&gt;Yonik, are you working on this? If not, I can start.&lt;/p&gt;</comment>
                            <comment id="12676324" author="yseeley@gmail.com" created="Tue, 24 Feb 2009 16:21:20 +0000"  >&lt;p&gt;I haven&apos;t started to work on it - go for it!&lt;/p&gt;</comment>
                            <comment id="12676341" author="shalinmangar" created="Tue, 24 Feb 2009 17:27:06 +0000"  >&lt;p&gt;Great! I need to upgrade the Lucene jars to get the new updated Trie API.&lt;/p&gt;</comment>
                            <comment id="12676551" author="thetaphi" created="Wed, 25 Feb 2009 07:55:24 +0000"  >&lt;p&gt;Cool, I am open for queries and requests about the API and can help where applicable. What do the Solr people think about &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1541&quot; title=&quot;Trie range - make trie range indexing more flexible&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1541&quot;&gt;&lt;del&gt;LUCENE-1541&lt;/del&gt;&lt;/a&gt;? I keep it open, but I think it makes things to complicated.&lt;/p&gt;</comment>
                            <comment id="12676570" author="shalinmangar" created="Wed, 25 Feb 2009 09:13:39 +0000"  >&lt;p&gt;Thanks Uwe! I have just started to look at the API, the discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1470&quot; title=&quot;Add TrieRangeFilter to contrib&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1470&quot;&gt;&lt;del&gt;LUCENE-1470&lt;/del&gt;&lt;/a&gt; and on the mailing list. So, I&apos;ll definitely need some help. My first priority is to get it working in a simple way, then add more configuration/tuning options depending on feedback.&lt;/p&gt;

&lt;p&gt;As for, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1541&quot; title=&quot;Trie range - make trie range indexing more flexible&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1541&quot;&gt;&lt;del&gt;LUCENE-1541&lt;/del&gt;&lt;/a&gt;, I&apos;m yet to get to that. Probably others may have more thoughts on that.&lt;/p&gt;</comment>
                            <comment id="12676577" author="thetaphi" created="Wed, 25 Feb 2009 09:25:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, I&apos;ll definitely need some help. My first priority is to get it working in a simple way, then add more configuration/tuning options depending on feedback&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Just a question: Do you need help implementing (working power), or is the documentation not yet understandable for a beginner? I added some indexing and query examples in the package overview, but maybe it is not so easy for others to understand. Maybe we can improve the documentation.&lt;/p&gt;

&lt;p&gt;I am not so familar with Solr internals, but as I understand you have datatypes and field configurations in your XML documents. Maybe you should add new types &quot;trie-long&quot;,... and index them using TrieUtils. I will check out svn trunk of Solr and look into it. In the first step, I would only use the APIs taking &lt;b&gt;one&lt;/b&gt; field name (which creates the internal helper field ending in &quot;#trie&quot;, that would automatically be created but &quot;invisible&quot; to the user). This ensures simplicity and the possibility to sort efficient using the SortField factory from TrieUtils (without custom sort comparators and so on).&lt;/p&gt;</comment>
                            <comment id="12676630" author="shalinmangar" created="Wed, 25 Feb 2009 12:40:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;Just a question: Do you need help implementing (working power), or is the documentation not yet understandable for a beginner? I added some indexing and query examples in the package overview, but maybe it is not so easy for others to understand. Maybe we can improve the documentation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I meant that I have only started looking at this so I may have questions later &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe you should add new types &quot;trie-long&quot;,... and index them using TrieUtils.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that seems to be the right way. I&apos;ll create TrieIntField and TrieLongField. We can use the implicit helper field or have it as a configuration option in schema.xml. We&apos;d also need changes to the SolrQueryParser so that range queries on such fields are handled correctly.&lt;/p&gt;

&lt;p&gt;I&apos;ll try to have a patch by tomorrow.&lt;/p&gt;</comment>
                            <comment id="12676635" author="thetaphi" created="Wed, 25 Feb 2009 12:54:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yes, that seems to be the right way. I&apos;ll create TrieIntField and TrieLongField. We can use the implicit helper field or have it as a configuration option in schema.xml. We&apos;d also need changes to the SolrQueryParser so that range queries on such fields are handled correctly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And how about using this for floats, doubles, and dates (which also have corresponding Solr field types)? You could create field descriptions for that too (subclasses of TrieIntField and TrieLongField), to be able to index these types using trie.&lt;/p&gt;</comment>
                            <comment id="12676643" author="thetaphi" created="Wed, 25 Feb 2009 13:18:01 +0000"  >&lt;p&gt;By the way, when looking through the schema code, I found out, that with Lucene trunk, it is now also possible to sort the &quot;SortableLongField&quot; &amp;amp; others using the new SortField ctors that &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1478&quot; title=&quot;Missing possibility to supply custom FieldParser when sorting search results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1478&quot;&gt;&lt;del&gt;LUCENE-1478&lt;/del&gt;&lt;/a&gt; introduced. Currently these fields are sorted by SortField.STRING, whcih is inefficient. Just as a side-note.&lt;/p&gt;</comment>
                            <comment id="12676698" author="thetaphi" created="Wed, 25 Feb 2009 16:41:46 +0000"  >&lt;p&gt;Just an idea (that came to me...): How about creating a TokenStream that returns the results of TrieUtils.trieCode&lt;span class=&quot;error&quot;&gt;&amp;#91;Long|Int&amp;#93;&lt;/span&gt;() with TokenIncrement 0. You should be able to search this with TrieRangeFilter (using the same field name for the highest and lower precision trie fields).&lt;/p&gt;</comment>
                            <comment id="12676710" author="shalinmangar" created="Wed, 25 Feb 2009 17:15:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;Just an idea (that came to me...): How about creating a TokenStream that returns the results of TrieUtils.trieCode&lt;span class=&quot;error&quot;&gt;&amp;#91;Long|Int&amp;#93;&lt;/span&gt;() with TokenIncrement 0. You should be able to search this with TrieRangeFilter (using the same field name for the highest and lower precision trie fields).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The difficulty is in identifying what type of tokenizer was used (TrieInt, TrieLong etc.) to index the field. The user will need to use the localparam syntax explicitly for us to use IntTrieRangeFilter e.g fq=&lt;/p&gt;
{trieint}
&lt;p&gt;tint:&lt;span class=&quot;error&quot;&gt;&amp;#91;10 TO 100&amp;#93;&lt;/span&gt;. I would like to avoid the use of such syntax as far as possible. Creating the field type may be more work than this option, but it can help us use the correct Filter and SortField automatically.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And how about using this for floats, doubles, and dates (which also have corresponding Solr field types)? You could create field descriptions for that too (subclasses of TrieIntField and TrieLongField), to be able to index these types using trie.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, we should support those too.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;By the way, when looking through the schema code, I found out, that with Lucene trunk, it is now also possible to sort the &quot;SortableLongField&quot; &amp;amp; others using the new SortField ctors that &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1478&quot; title=&quot;Missing possibility to supply custom FieldParser when sorting search results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1478&quot;&gt;&lt;del&gt;LUCENE-1478&lt;/del&gt;&lt;/a&gt; introduced. Currently these fields are sorted by SortField.STRING, whcih is inefficient. Just as a side-note. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks for the pointing this out. I&apos;ll take a look at this too.&lt;/p&gt;</comment>
                            <comment id="12676717" author="thetaphi" created="Wed, 25 Feb 2009 17:44:18 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Just an idea (that came to me...): How about creating a TokenStream that returns the results of TrieUtils.trieCode&lt;span class=&quot;error&quot;&gt;&amp;#91;Long|Int&amp;#93;&lt;/span&gt;() with TokenIncrement 0. You should be able to search this with TrieRangeFilter (using the same field name for the highest and lower precision trie fields).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The difficulty is in identifying what type of tokenizer was used (TrieInt, TrieLong etc.) to index the field. The user will need to use the localparam syntax explicitly for us to use IntTrieRangeFilter e.g fq=&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {trieint}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;tint:&lt;span class=&quot;error&quot;&gt;&amp;#91;10 TO 100&amp;#93;&lt;/span&gt;. I would like to avoid the use of such syntax as far as possible. Creating the field type may be more work than this option, but it can help us use the correct Filter and SortField automatically.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Now I understand the problem, Yonik had with the original TrieRange implementation and wanted to change the API. Your problem is, that you must be able to not just map the numerical value to &lt;b&gt;one&lt;/b&gt; field and token. You have to index &lt;b&gt;one&lt;/b&gt; numeric value to more than one token before indexing them.&lt;/p&gt;

&lt;p&gt;My idea was, to just use create a FieldType subclass for indexing TrieRangeFilter and overwrite the getAnalyzer() and getQueryAnalyzer() methods. The analyzer would get the numerical value and create tokens from it. Normally, it would be only &lt;b&gt;one&lt;/b&gt; token for numerical values that is converted using the toXXXX methods in FieldType. But now you have to create more than one token (one for each precision). This could be done by the analyzer that is returned by FieldType. This analyzer does really nothing, only returns a Tokenizer that does not really tokenize, it just returns Tokens containing the prefix encoded values of the given String converted to the numeric value in different precisions (using TrieUtils.trieCodeLong()).&lt;/p&gt;</comment>
                            <comment id="12676721" author="thetaphi" created="Wed, 25 Feb 2009 18:05:19 +0000"  >&lt;p&gt;I would program this tokenizer in this way (using the old Lucene Token API):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class TrieTokenStream &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; TokenStream/Tokenizer {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; TrieTokenStream(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; value,...) {
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.trieVals=Arrays.asList(TrieUtils.trieCodeLong(value,...)).iterator();
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Token next(Token token) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!s.hasNext()) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
    token.reinit(trieVals.next(),0,0);
    token.setPositionIncrement(0);
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; token;
  }

  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Iterator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; trieVals;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using this, you could index the field (without an additional helper field and so not sortable) using the standard Lucene Fieldable mechanism. No further changes to solar on the indexing side might be needed.&lt;/p&gt;</comment>
                            <comment id="12676723" author="shalinmangar" created="Wed, 25 Feb 2009 18:06:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;Now I understand the problem, Yonik had with the original TrieRange implementation and wanted to change the API. Your problem is, that you must be able to not just map the numerical value to one field and token. You have to index one numeric value to more than one token before indexing them.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was just reading Yonik&apos;s comment on java-dev to figure out what Yonik had in mind. Normally, the toInternal/toExternal methods take care of encoding/decoding. But we cannot use them because the trie encoding produces multiple tokens. That can be done through a tokenizer as you said. But, a tokenizer cannot add tokens in another field which is requred for the filter to work correctly.&lt;/p&gt;</comment>
                            <comment id="12676726" author="thetaphi" created="Wed, 25 Feb 2009 18:10:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;But, a tokenizer cannot add tokens in another field which is requred for the filter to work correctly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You can tokenize it into one field and use TrieRangeFilter with the same field name for the field and the lower precision field (second constructor). After that, search works, but you cannot sort anymore, because more than one token per document in this field.&lt;/p&gt;</comment>
                            <comment id="12676727" author="shalinmangar" created="Wed, 25 Feb 2009 18:10:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;Using this, you could index the field (without an additional helper field and so not sortable) using the standard Lucene Fieldable mechanism. No further changes to solar on the indexing side might be needed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, no sort should be OK for a start. Users can be instructed to use a copyField for sorting (just like we have integer and sint in the schema). Thanks for the tip Uwe! I&apos;ll try this out and let you know if this works out well.&lt;/p&gt;</comment>
                            <comment id="12676806" author="ryantxu" created="Wed, 25 Feb 2009 22:56:53 +0000"  >&lt;p&gt;I have not followed this closely, so correct me if I am way off base...&lt;/p&gt;

&lt;p&gt;Assuming TrieRange does all the number mojo needed in lucene, should it eventually replace the existing number implementaions?&lt;/p&gt;

&lt;p&gt;In solr 2.0, would it make sense that int,sint,float,sfloat, etc are all implemented with TrieRange?  Obviously we need to keep the existing field types for 1.X&lt;/p&gt;

&lt;p&gt;If this is true, should we deprecate the existing Number implementations for 1.4?  perhaps just NumberUtils?&lt;/p&gt;

&lt;p&gt;Should changing the schema version to 1.2 trigger using the TrieRange classes rather then the NumberUtils classes?  Becides supporting existing indexes, is there any reason to keep the solr number formats rather then the Trie version?&lt;/p&gt;</comment>
                            <comment id="12677713" author="shalinmangar" created="Sat, 28 Feb 2009 20:06:27 +0000"  >&lt;p&gt;Attaching first cut with the following changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;BaseTrieField - Base class for trie fields, hardcodes the field to be multi-valued and tokenized&lt;/li&gt;
	&lt;li&gt;TrieIntField - Support for ints&lt;/li&gt;
	&lt;li&gt;TrieIntTokenizer/Factory - Uses TrieUtils to create sequence of trie coded numbers for a given integer, decreasing in precision&lt;/li&gt;
	&lt;li&gt;Changes to SolrQueryParser to use IntTrieRangeFilter is field is instance of TrieIntField&lt;/li&gt;
	&lt;li&gt;TestTrie - Simple test for int range search&lt;/li&gt;
	&lt;li&gt;src/test/test-files/conf/schema-trie.xml uses the trie int&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The precisionStep is not configurable at the moment. This is because the same precisionStep must be used for indexing (by the Tokenizer) and to create the range filter (in SolrQueryParser) and I could not find a way to share this information between the two classes.&lt;/p&gt;

&lt;p&gt;TODO:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Support for float, long, doubles&lt;/li&gt;
	&lt;li&gt;Javadocs&lt;/li&gt;
	&lt;li&gt;Changes to example schema, clearly highlighting that trie fields cannot be used for sorting (one should use copyFields into a integer for sorting)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Thanks Uwe for suggesting the tokenizer approach, works great!&lt;/p&gt;

&lt;p&gt;Edit - Forgot to mention that needs updated Lucene jars (trunk).&lt;/p&gt;</comment>
                            <comment id="12677714" author="shalinmangar" created="Sat, 28 Feb 2009 20:12:46 +0000"  >&lt;blockquote&gt;&lt;p&gt;Assuming TrieRange does all the number mojo needed in lucene, should it eventually replace the existing number implementaions?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not until we can support sorting. Also, trie indexes many tokens per value, increasing the index size. Users who do not need range searches should not pay this penalty.&lt;/p&gt;</comment>
                            <comment id="12677726" author="thetaphi" created="Sat, 28 Feb 2009 21:11:51 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Assuming TrieRange does all the number mojo needed in lucene, should it eventually replace the existing number implementaions?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not until we can support sorting. Also, trie indexes many tokens per value, increasing the index size. Users who do not need range searches should not pay this penalty.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If the precisionStep is configureable, you can simply use 32 (for ints) or 64 (for longs) to not create additional precisions.&lt;/p&gt;</comment>
                            <comment id="12677740" author="thetaphi" created="Sat, 28 Feb 2009 22:21:11 +0000"  >&lt;p&gt;Just one question:&lt;br/&gt;
In queryParser you use: FieldType ft = schema.getFieldType(field); So if you have the FieldType, why are you not able to extract the precisionStep from the schema? The user would only have a problem, if he changes the precision step in the schema, but with a fixed schema, that contains the precisionStep as a parameter, you should be able to search indexed data. If you change the schema, you have to reindex (or use a precisionStep that is a multiple of the original one, see trie Javadoc: if you have indexed with step 2, you can search without problems using step 4)&lt;/p&gt;

&lt;p&gt;By the way: For future usage, you could use TrieUtils.get&lt;span class=&quot;error&quot;&gt;&amp;#91;Int|Long&amp;#93;&lt;/span&gt;SortField for FieldType.getSortField instead of using SortField.String. If the problem with more than one field name is solved, sorting works using the Trie-SortField using the correct parser.&lt;/p&gt;</comment>
                            <comment id="12677772" author="shalinmangar" created="Sun, 1 Mar 2009 05:28:35 +0000"  >&lt;p&gt;New patch with the following changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Supports int, float, long, double&lt;/li&gt;
	&lt;li&gt;There are no separate classes for each type (too much boilerplate code), instead they are folded into one &amp;#8211; TrieField&lt;/li&gt;
	&lt;li&gt;Same as above for Tokenizer - TrieTokenizerFactory&lt;/li&gt;
	&lt;li&gt;In the schema, one needs to specify an additional attribute &apos;type&apos; when declaring the field type, example:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&amp;lt;fieldType name=&lt;span class=&quot;code-quote&quot;&gt;&quot;tdouble&quot;&lt;/span&gt; class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.TrieField&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;double&quot;&lt;/span&gt; omitNorms=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt;
positionIncrementGap=&lt;span class=&quot;code-quote&quot;&gt;&quot;0&quot;&lt;/span&gt; indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;Precision step is now configurable and can be specified in field type declaration, example:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&amp;lt;fieldType name=&lt;span class=&quot;code-quote&quot;&gt;&quot;tdouble16&quot;&lt;/span&gt; class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.TrieField&quot;&lt;/span&gt; type=&lt;span class=&quot;code-quote&quot;&gt;&quot;double&quot;&lt;/span&gt; precisionStep=&lt;span class=&quot;code-quote&quot;&gt;&quot;16&quot;&lt;/span&gt;
 omitNorms=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; positionIncrementGap=&lt;span class=&quot;code-quote&quot;&gt;&quot;0&quot;&lt;/span&gt; indexed=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; stored=&lt;span class=&quot;code-quote&quot;&gt;&quot;false&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;Test expanded for float, long, double types&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;TODO:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Date type&lt;/li&gt;
	&lt;li&gt;More javadocs?&lt;/li&gt;
	&lt;li&gt;Update wiki&lt;/li&gt;
	&lt;li&gt;Changes to example schema&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="12677773" author="shalinmangar" created="Sun, 1 Mar 2009 05:32:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;If the precisionStep is configureable, you can simply use 32 (for ints) or 64 (for longs) to not create additional precisions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s great, I&apos;ll document this on the wiki.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In queryParser you use: FieldType ft = schema.getFieldType(field); So if you have the FieldType, why are you not able to extract the precisionStep from the schema?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, done, must have been the late night effect &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For future usage, you could use TrieUtils.get&lt;span class=&quot;error&quot;&gt;&amp;#91;Int|Long&amp;#93;&lt;/span&gt;SortField for FieldType.getSortField instead of using SortField.String. If the problem with more than one field name is solved, sorting works using the Trie-SortField using the correct parser.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Done too&lt;/p&gt;</comment>
                            <comment id="12677799" author="thetaphi" created="Sun, 1 Mar 2009 09:35:43 +0000"  >&lt;p&gt;Looks cool, great!&lt;br/&gt;
I have no Solr installed here to test in large scale, but from what I see, It seems sophisticated. I have only seen these points:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Missing support for half-open ranges with &quot;&amp;#42;&quot; (just add the test for &quot;&amp;#42;&quot; and pass null to TrieRangeFilter)&lt;/li&gt;
	&lt;li&gt;The example with a different configured precisionStep should use a precisionStep &amp;lt; 8 &lt;span class=&quot;error&quot;&gt;&amp;#91;16 is a possible value, but useless,because of number of terms. The possible number of terms increses dramatically with higher precision steps (factor 2^precisionStep). Javadocs should note, that 32/64 should be used for no additional trie fields&amp;#93;&lt;/span&gt;&lt;/li&gt;
	&lt;li&gt;Date support should be trivial, too.&lt;/li&gt;
	&lt;li&gt;Does it work with the tokenizer for standard term queries? e.g. somebody asks for all documents containing the long value x, but not using a TrieRange for that (this works, but can solr handle this?), is the value correctly tokenized? The problem here maybe that during parsing the query, the analyzer is used and generates a &quot;OR&quot; BolleanQuery of all terms incl lower precisions. Or is for the query another tokenizer used (but then this tokenizer should just generate one term using XxxxToPrefixCoded (without shift).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12677801" author="thetaphi" created="Sun, 1 Mar 2009 10:25:46 +0000"  >&lt;p&gt;About the sorting problem:&lt;/p&gt;

&lt;p&gt;As already discussed in the original TrieRange issue, the sorting is a problem for trie encoded fields. The problem is, that the current FieldCache has two problems:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it stores the &lt;b&gt;last&lt;/b&gt; term (the last term in the TermEnum!) in the cache&lt;/li&gt;
	&lt;li&gt;it throws an exception, when the number of term in one field &amp;gt; the number of docs (I think this was the case)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For trie fields it would be good, to have something like &quot;sorting on the first term of the document&quot;. This would be conformant with TrieRange, as the first term in trieCodeXxx() is always the highest precision one (and also in your tokenizer). I think, we should discuss more in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1372&quot; title=&quot;Proposal: introduce more sensible sorting when a doc has multiple values for a term&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1372&quot;&gt;&lt;del&gt;LUCENE-1372&lt;/del&gt;&lt;/a&gt;, where this sorting problem is discussed. If it would be fixed before 2.9, I could remove the whole multi-field parts out of TrieRange API and only support one field name (with what I would be really happy). Then you can index all trie terms in one field and sort on it (if the order of generated trie terms is preserved through the whole indexing and TermDocs array (which is not really simple for the field cache to handle).&lt;/p&gt;</comment>
                            <comment id="12677929" author="shalinmangar" created="Mon, 2 Mar 2009 08:57:05 +0000"  >&lt;p&gt;Changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Adding support for open ranges&lt;/li&gt;
	&lt;li&gt;Changed precision step in test schema.xml to 4&lt;/li&gt;
	&lt;li&gt;Renamed TrieTokenizerFactory to TrieIndexTokenizerFactory&lt;/li&gt;
	&lt;li&gt;Added a TrieQueryTokenizerFactory which converts query token to xxxToPrefixCoded form. Now term queries (in q or fq) are supported&lt;/li&gt;
	&lt;li&gt;Updated tests for open ranges and term queries&lt;/li&gt;
	&lt;li&gt;Minor javadoc updates&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;TODO:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Date support&lt;/li&gt;
	&lt;li&gt;Wiki updates&lt;/li&gt;
	&lt;li&gt;Example schema updates&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="12677936" author="shalinmangar" created="Mon, 2 Mar 2009 09:21:29 +0000"  >&lt;p&gt;Thanks Uwe for spotting those problems. The latest patch should take care of these issues.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For trie fields it would be good, to have something like &quot;sorting on the first term of the document&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, yeah. This looks like the easiest solution.&lt;/p&gt;</comment>
                            <comment id="12678286" author="shalinmangar" created="Tue, 3 Mar 2009 11:03:17 +0000"  >&lt;p&gt;Changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Support for date types&lt;/li&gt;
	&lt;li&gt;TrieField and TrieIndexTokenizer keep a static instance of DateField class whose parseMath and toObject methods are used. This makes sure that all date format related semantics as well as the DateMath syntax works as usual with trie dates.&lt;/li&gt;
	&lt;li&gt;Updated test for date type&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;TODO:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Update example schema&lt;/li&gt;
	&lt;li&gt;Update wiki&lt;/li&gt;
	&lt;li&gt;Commit?&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="12678291" author="shalinmangar" created="Tue, 3 Mar 2009 11:36:32 +0000"  >&lt;p&gt;Hmm, I think the TriField.toObject is not correct. We need to use TrieUtils to convert the prefix coded form back to int/float/long etc. Also, we need to add the TrieField as a known type for the binary response format.&lt;/p&gt;</comment>
                            <comment id="12678344" author="shalinmangar" created="Tue, 3 Mar 2009 15:16:39 +0000"  >&lt;p&gt;Please ignore my comment about toObject I made earlier. It is not necessary.&lt;/p&gt;

&lt;p&gt;Changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Added TrieField as a known type in BinaryResponseWriter so that TrieField.toObject is serialized&lt;/li&gt;
	&lt;li&gt;Changes to example schema with documentation&lt;/li&gt;
	&lt;li&gt;Updated javadocs&lt;/li&gt;
	&lt;li&gt;Use TrieUtils.getLongSortField for dates too&lt;/li&gt;
	&lt;li&gt;Remove hardcoded isMultivalued in TrieField&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This is a good time for folks to take this out for a spin &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12678367" author="thetaphi" created="Tue, 3 Mar 2009 17:12:34 +0000"  >&lt;p&gt;Cool!&lt;br/&gt;
When looking through the code, I found out that TrieQueryTokenizer is missing Date support, nothing else! And I would always throw an IllegalArgumentException in the default case of all switch(type) statements. This helps finding such errors faster.&lt;/p&gt;</comment>
                            <comment id="12678381" author="shalinmangar" created="Tue, 3 Mar 2009 18:18:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;When looking through the code, I found out that TrieQueryTokenizer is missing Date support, nothing else!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah right, I forgot that term queries won&apos;t work without it. I&apos;ll add it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And I would always throw an IllegalArgumentException in the default case of all switch(type) statements. This helps finding such errors faster.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point. Will do that too.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="12678423" author="shalinmangar" created="Tue, 3 Mar 2009 19:33:31 +0000"  >&lt;p&gt;Changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Support term queries for trie dates&lt;/li&gt;
	&lt;li&gt;Update test for term queries on dates&lt;/li&gt;
	&lt;li&gt;Throw SolrException for unknown trie type in switch (actually this can not happen because the enum has a fixed number of types and we are using all of them).&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="12678485" author="thetaphi" created="Tue, 3 Mar 2009 22:21:53 +0000"  >&lt;p&gt;The patch is the same as before, maybe you uploaded the wrong one.&lt;/p&gt;</comment>
                            <comment id="12678579" author="shalinmangar" created="Wed, 4 Mar 2009 04:27:32 +0000"  >&lt;p&gt;The last patch was incorrect. Uploading the correct patch.&lt;/p&gt;</comment>
                            <comment id="12679961" author="shalinmangar" created="Sun, 8 Mar 2009 07:23:55 +0000"  >&lt;p&gt;Updating javadocs to note that trie fields cannot be used in function queries. No other changes.&lt;/p&gt;

&lt;p&gt;What do people feel about committing this patch?&lt;/p&gt;

&lt;p&gt;Another thought - If we can write a ValueSource for trie fields whose DocValues return only the first indexed term, we should be able to use function queries. Will this be too expensive if Lucene does not support building such field caches for us?&lt;/p&gt;

&lt;p&gt;If this can be done then basic sorting would be possible through function queries (though they would be part of the score). However one still would not be able to use trie fields in the sort parameter (or mix their sorting with non-numeric fields).&lt;/p&gt;</comment>
                            <comment id="12680977" author="shalinmangar" created="Wed, 11 Mar 2009 18:44:46 +0000"  >&lt;p&gt;Committed revision 752562.&lt;/p&gt;

&lt;p&gt;Thanks Uwe for the ideas and the reviews!&lt;/p&gt;</comment>
                            <comment id="12680989" author="yseeley@gmail.com" created="Wed, 11 Mar 2009 19:03:24 +0000"  >&lt;p&gt;Instead of explicitly testing for TrieField in the QueryParser, how about adding a&lt;br/&gt;
FieldType.getRangeQuery()?  We&apos;ll need that anyway in the future to support value source range query, etc.&lt;/p&gt;</comment>
                            <comment id="12680996" author="shalinmangar" created="Wed, 11 Mar 2009 19:09:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;Instead of explicitly testing for TrieField in the QueryParser, how about adding a FieldType.getRangeQuery()?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sounds good. I&apos;ll give a patch.&lt;/p&gt;</comment>
                            <comment id="12681003" author="shalinmangar" created="Wed, 11 Mar 2009 19:43:32 +0000"  >&lt;ol&gt;
	&lt;li&gt;Adding FieldType.getRangeQuery method which uses the ConstantScore version of RangeQuery.&lt;/li&gt;
	&lt;li&gt;TrieField overrides it to provide its own implementation.&lt;/li&gt;
	&lt;li&gt;SolrQueryParser uses fieldType.getRangeQuery&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I&apos;ll commit this shortly.&lt;/p&gt;</comment>
                            <comment id="12681007" author="shalinmangar" created="Wed, 11 Mar 2009 19:50:39 +0000"  >&lt;p&gt;Committed revision 752596.&lt;/p&gt;</comment>
                            <comment id="12681171" author="shalinmangar" created="Thu, 12 Mar 2009 06:04:06 +0000"  >&lt;p&gt;From Hoss on solr-dev about the last patch:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I don&apos;t think treating &quot;*&quot; as special is something FieldType (or&lt;br/&gt;
TrieField) should do &amp;#8211; that&apos;s specific to the syntax of the QueryParser.&lt;br/&gt;
The FieldType classes should treat the string as a string. (otherwise if i&lt;br/&gt;
write a new QueryParser where * isn&apos;t a special character and use some&lt;br/&gt;
syntax like &quot;phoneNumber &amp;lt; *69&quot; i&apos;m screwed.&lt;br/&gt;
&quot;*69&quot; as the&lt;/p&gt;

&lt;p&gt;I also think having a single &quot;inclusive&quot; boolean is a bad idea.&lt;/p&gt;

&lt;p&gt;I would javadoc that the lower/upper bounds can be null, and have&lt;br/&gt;
SolrQueryParser pass null when it sees &quot;*&quot; in the syntax.  we should also&lt;br/&gt;
be explicit in the javadocs about what combinations of inclusion booleans&lt;br/&gt;
and null values are allowed so that subclasses know what to expect&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In this patch:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;FieldType no longer treats &apos;*&apos; specially&lt;/li&gt;
	&lt;li&gt;SolrQueryParser passes null for &apos;*&apos;&lt;/li&gt;
	&lt;li&gt;Single inclusive parameter replaced by two parameters &amp;#8211; minInclusive and maxInclusive&lt;/li&gt;
	&lt;li&gt;Javadoc updated to mention that nulls are allowed for part1 and part2, SolrQueryParser passes null for &apos;*&apos; character and same (true) values for minInclusive and maxInclusive. However other QueryParsers may have different semantics.&lt;/li&gt;
	&lt;li&gt;Corresponding changes to TrieField&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I&apos;ll commit shortly.&lt;/p&gt;</comment>
                            <comment id="12681183" author="shalinmangar" created="Thu, 12 Mar 2009 06:37:16 +0000"  >&lt;p&gt;Committed revision 752785.&lt;/p&gt;

&lt;p&gt;Fixed a single char bug in the previous patch at FieldType.getRangeQuery.&lt;/p&gt;</comment>
                            <comment id="12681244" author="shalinmangar" created="Thu, 12 Mar 2009 09:59:46 +0000"  >&lt;p&gt;Changing test to index and search for NOW/DAY TO NOW/DAY+10DAYS otherwise the millisecond precision fails the test intermittently.&lt;/p&gt;

&lt;p&gt;I&apos;ll commit this shortly.&lt;/p&gt;</comment>
                            <comment id="12681245" author="shalinmangar" created="Thu, 12 Mar 2009 10:04:12 +0000"  >&lt;p&gt;Committed revision 752823.&lt;/p&gt;</comment>
                            <comment id="12694975" author="thetaphi" created="Thu, 2 Apr 2009 13:12:35 +0100"  >&lt;p&gt;I created a new issue &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1582&quot; title=&quot;Make TrieRange completely independent from Document/Field with TokenStream of prefix encoded values&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1582&quot;&gt;&lt;del&gt;LUCENE-1582&lt;/del&gt;&lt;/a&gt; to fix the sorting problem and also support a TokenStream directly by trieCodeLong/Int(). The API will change, but this would be simplification for the Solr implementation (as the TokenStream can be directly used) and is more memory efficient.&lt;/p&gt;</comment>
                            <comment id="12695581" author="thetaphi" created="Fri, 3 Apr 2009 22:11:19 +0100"  >&lt;p&gt;This patch modifies Solr support for trie fields to the new Trie API (not committed until now).&lt;br/&gt;
This class simplifies the TokenizerFactories (no Solr-internal indexing Tokenizer needed anymore as trie API supplies TokenStream). The TrieQueryTokenizerFactory was simplified to use KeywordTokenizer instead of implementing an own one (this change can be left of, if you like your solution more).&lt;br/&gt;
For this to compile and work, the latest trunk builds of Lucene must be placed in lib and another small change because of a change in Fieldable interface must be added (not included in patch).&lt;/p&gt;</comment>
                            <comment id="12695761" author="thetaphi" created="Sat, 4 Apr 2009 16:54:52 +0100"  >&lt;p&gt;I forget to mention: with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1582&quot; title=&quot;Make TrieRange completely independent from Document/Field with TokenStream of prefix encoded values&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1582&quot;&gt;&lt;del&gt;LUCENE-1582&lt;/del&gt;&lt;/a&gt; and this patch, sorting now works for trie fields. I changed the schema.xml in the patch to note this.&lt;/p&gt;

&lt;p&gt;About function queries: If they use the &quot;normal&quot; field cache (long, int, double, float) with the supplied trie parser (as the trie SortField factory does), it would work. The parser for the nurmeric values is also separately available in TrieUtils. But I do not know, how to enable this in Solr (SortField support is available through the schema), maybe you can do this, or change the comments.&lt;/p&gt;

&lt;p&gt;By the way, the change needed for compilation with the new Lucene JARs is the omitTf thing (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1079&quot; title=&quot;Rename omitTf to omitTermFreqAndPositions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1079&quot;&gt;&lt;del&gt;SOLR-1079&lt;/del&gt;&lt;/a&gt;), I have done this in my local checkout to be able to create this patch.&lt;/p&gt;</comment>
                            <comment id="12695765" author="shalinmangar" created="Sat, 4 Apr 2009 18:01:43 +0100"  >&lt;p&gt;Thanks Uwe!&lt;/p&gt;

&lt;p&gt;I&apos;m having trouble applying the patch:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
shalinsmangar@shalinsmangar-laptop:~/work/oss/solr-trunk$ patch --dry-run -p0 &amp;lt; /home/shalinsmangar/Desktop/SOLR-940-newTrieAPI.patch 
(Stripping trailing CRs from patch.)
patching file example/solr/conf/schema.xml
(Stripping trailing CRs from patch.)
patching file src/java/org/apache/solr/analysis/TrieIndexTokenizerFactory.java
Hunk #3 FAILED at 51.
1 out of 3 hunks FAILED -- saving rejects to file src/java/org/apache/solr/analysis/TrieIndexTokenizerFactory.java.rej
(Stripping trailing CRs from patch.)
patching file src/java/org/apache/solr/analysis/TrieQueryTokenizerFactory.java
(Stripping trailing CRs from patch.)
patching file src/java/org/apache/solr/schema/TrieField.java
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;No biggie, I&apos;ll take care of it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I forget to mention: with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1582&quot; title=&quot;Make TrieRange completely independent from Document/Field with TokenStream of prefix encoded values&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1582&quot;&gt;&lt;del&gt;LUCENE-1582&lt;/del&gt;&lt;/a&gt; and this patch, sorting now works for trie fields.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That is great news!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;About function queries: If they use the &quot;normal&quot; field cache (long, int, double, float) with the supplied trie parser&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The function query stuff does use FieldCache but through the ValueSource abstraction. It should be possible by creating a TrieValueSource which uses the trie field cache parsers when creating the value source.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;By the way, the change needed for compilation with the new Lucene JARs is the omitTf thing (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1079&quot; title=&quot;Rename omitTf to omitTermFreqAndPositions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1079&quot;&gt;&lt;del&gt;SOLR-1079&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ok, I think we can commit that first as soon as there is consensus on the name.&lt;/p&gt;</comment>
                            <comment id="12695766" author="thetaphi" created="Sat, 4 Apr 2009 18:08:35 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m having trouble applying the patch:&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I created the patch from the SVN trunk checkout yesterday. Maybe it is in windows-format with CR-LF. For me it applies cleanly using TortoiseSVN merge function.&lt;/p&gt;

&lt;p&gt;Did the &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1582&quot; title=&quot;Make TrieRange completely independent from Document/Field with TokenStream of prefix encoded values&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1582&quot;&gt;&lt;del&gt;LUCENE-1582&lt;/del&gt;&lt;/a&gt; patch apply to Lucene correctly?&lt;/p&gt;</comment>
                            <comment id="12695813" author="shalinmangar" created="Sun, 5 Apr 2009 07:53:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;Did the &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1582&quot; title=&quot;Make TrieRange completely independent from Document/Field with TokenStream of prefix encoded values&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1582&quot;&gt;&lt;del&gt;LUCENE-1582&lt;/del&gt;&lt;/a&gt; patch apply to Lucene correctly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that one applies fine. I think going ahead with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1582&quot; title=&quot;Make TrieRange completely independent from Document/Field with TokenStream of prefix encoded values&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1582&quot;&gt;&lt;del&gt;LUCENE-1582&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1079&quot; title=&quot;Rename omitTf to omitTermFreqAndPositions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1079&quot;&gt;&lt;del&gt;SOLR-1079&lt;/del&gt;&lt;/a&gt; and then looking at this patch will make things easier.&lt;/p&gt;</comment>
                            <comment id="12695881" author="thetaphi" created="Sun, 5 Apr 2009 18:33:46 +0100"  >&lt;p&gt;Updated patch, that supports ValueSource (currently not for Date Trie fields, I do not know how this should work, the orginal DateField uses a StringIndex as ValueSource, which is not possible for trie date fields, as no parser available and if using the standard string index, would fail because of more than one term/doc). Some tests for function queries are needed (especially as Double and FloatParser are not tested by Lucene at the moment), maybe change a test for conventional XxxFields to do the same test with a trie field.&lt;/p&gt;</comment>
                            <comment id="12696492" author="thetaphi" created="Tue, 7 Apr 2009 12:56:44 +0100"  >&lt;p&gt;The change is now committed in Lucene trunk!&lt;br/&gt;
Shalin: Can you reopen this issue (I cannot do this), to not forget about it?&lt;/p&gt;</comment>
                            <comment id="12696496" author="shalinmangar" created="Tue, 7 Apr 2009 13:14:49 +0100"  >&lt;p&gt;Re-opening to incorporate changes in Lucene.&lt;/p&gt;</comment>
                            <comment id="12696681" author="thetaphi" created="Tue, 7 Apr 2009 19:41:11 +0100"  >&lt;p&gt;One note to sorting:&lt;br/&gt;
I am not really sure, if sorting works with Solr. The Sortfield returned by TrieUtils.getSortField contains an own parser (new feature in Lucene 2.9). When looking through the solr code, searching for SortField in trunk, I noticed, that QueryComponent has own comparators and FieldCache code (duplicating the Lucene code), and ignoring the parser given in SortField (the parser is not passed to FieldCache.getInts() &amp;amp; Co.).&lt;/p&gt;

&lt;p&gt;If this is the case, it will simply not work. As I do not know anything about the internals of Solr and what QueryComponent does, so can you create a test-case that tests sorting of trie fields?&lt;/p&gt;

&lt;p&gt;By the way: In QueryComponent is a package-private StringFieldable just to convert the strings. Why not simply use a conventional Field instance to do this, why implement the whole interface? You can do everything done with this StringFieldable with Field, too. This is the problem of the omitTf thing: the interface changed again in Lucene 2.9, needing a change in this class. Replacing this by a simple reuseable Field instance solves the interface problem completely.&lt;/p&gt;</comment>
                            <comment id="12696702" author="thetaphi" created="Tue, 7 Apr 2009 20:18:38 +0100"  >&lt;p&gt;I attached a patch to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1079&quot; title=&quot;Rename omitTf to omitTermFreqAndPositions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1079&quot;&gt;&lt;del&gt;SOLR-1079&lt;/del&gt;&lt;/a&gt; to fix the QueryComponent problem (remove the StringFieldable).&lt;/p&gt;</comment>
                            <comment id="12697477" author="shalinmangar" created="Thu, 9 Apr 2009 12:27:41 +0100"  >&lt;p&gt;This patch includes all of Uwe&apos;s changes in addition to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1079&quot; title=&quot;Rename omitTf to omitTermFreqAndPositions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1079&quot;&gt;&lt;del&gt;SOLR-1079&lt;/del&gt;&lt;/a&gt; and another change to SolrHighlighter to accomodate &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1500&quot; title=&quot;Highlighter throws StringIndexOutOfBoundsException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1500&quot;&gt;&lt;del&gt;LUCENE-1500&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All tests pass.&lt;/p&gt;</comment>
                            <comment id="12698184" author="shalinmangar" created="Sun, 12 Apr 2009 08:49:48 +0100"  >&lt;blockquote&gt;
&lt;p&gt;One note to sorting:&lt;br/&gt;
I am not really sure, if sorting works with Solr. The Sortfield returned by TrieUtils.getSortField contains an own parser (new feature in Lucene 2.9). When looking through the solr code, searching for SortField in trunk, I noticed, that QueryComponent has own comparators and FieldCache code (duplicating the Lucene code), and ignoring the parser given in SortField (the parser is not passed to FieldCache.getInts() &amp;amp; Co.).&lt;/p&gt;

&lt;p&gt;If this is the case, it will simply not work. As I do not know anything about the internals of Solr and what QueryComponent does, so can you create a test-case that tests sorting of trie fields?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m also not very familiar with that code in QueryComponent but I guess that is executed only when field-sort-values are requested (for distributed search). I wrote tests for sorting and it works fine! So I think the problem will only be during Distributed Search. I&apos;ll modify TestDistributedSearch to test sorting of trie fields to be sure. If it doesn&apos;t, I&apos;ll open another issue to replace the deprecated ScoreDocComparator with FieldComparator.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Updated patch, that supports ValueSource (currently not for Date Trie fields, I do not know how this should work, the orginal DateField uses a StringIndex as ValueSource, which is not possible for trie date fields, as no parser available and if using the standard string index, would fail because of more than one term/doc). Some tests for function queries are needed (especially as Double and FloatParser are not tested by Lucene at the moment), maybe change a test for conventional XxxFields to do the same test with a trie field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll write tests for these as well. But trie date is just a trie long field so we should be able to use a LongFieldSource for this, right?&lt;/p&gt;</comment>
                            <comment id="12698188" author="thetaphi" created="Sun, 12 Apr 2009 09:14:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m also not very familiar with that code in QueryComponent but I guess that is executed only when field-sort-values are requested (for distributed search). I wrote tests for sorting and it works fine! So I think the problem will only be during Distributed Search. I&apos;ll modify TestDistributedSearch to test sorting of trie fields to be sure. If it doesn&apos;t, I&apos;ll open another issue to replace the deprecated ScoreDocComparator with FieldComparator.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK. If distributed search does not work, the problems are bigger: The problem is not the comparator alone, the problem is the FieldCache. The distributed search should fill the values into FieldCache and then let the comparator do the work. Comparing lucenes code with the solr ones shows, that there are some parts of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1478&quot; title=&quot;Missing possibility to supply custom FieldParser when sorting search results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1478&quot;&gt;&lt;del&gt;LUCENE-1478&lt;/del&gt;&lt;/a&gt; missing. The Comparators use the default parser instead of the one given in SortField.getParser() to parse the values (when retrieving FieldCache.getInts() &amp;amp; Co).&lt;/p&gt;

&lt;p&gt;I am not really sure, why Solr needs to duplicate the sorting code from Lucene? Maybe this is no longer needed? In this case, everything would be ok when removed.&lt;/p&gt;</comment>
                            <comment id="12698202" author="shalinmangar" created="Sun, 12 Apr 2009 11:21:05 +0100"  >&lt;p&gt;Changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Added Tests for Sorting on all trie type fields&lt;/li&gt;
	&lt;li&gt;Return a LongFieldSource for trie date types&lt;/li&gt;
	&lt;li&gt;Added Tests for function queries on all trie type fields&lt;/li&gt;
	&lt;li&gt;Upgraded Lucene jars to r764281&lt;/li&gt;
	&lt;li&gt;Created new ReverseStringFilterFactory for ReverseStringFilter through ant stub-factories&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;All tests pass.&lt;/p&gt;

&lt;p&gt;This patch also contains changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1079&quot; title=&quot;Rename omitTf to omitTermFreqAndPositions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1079&quot;&gt;&lt;del&gt;SOLR-1079&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1500&quot; title=&quot;Highlighter throws StringIndexOutOfBoundsException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1500&quot;&gt;&lt;del&gt;LUCENE-1500&lt;/del&gt;&lt;/a&gt;. These are enough changes for one issue. I&apos;ll commit this shortly and then we can deal with sorting in distributed search through a new issue.&lt;/p&gt;</comment>
                            <comment id="12698208" author="shalinmangar" created="Sun, 12 Apr 2009 12:06:29 +0100"  >&lt;p&gt;Committed revision 764291.&lt;/p&gt;

&lt;p&gt;Thanks Uwe!&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Updating Lucene jars&lt;/li&gt;
	&lt;li&gt;Updating Trie field types per Lucene&apos;s changes&lt;/li&gt;
	&lt;li&gt;Adding ReverseStringFilterFactory&lt;/li&gt;
	&lt;li&gt;Fix compile errors related to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1500&quot; title=&quot;Highlighter throws StringIndexOutOfBoundsException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1500&quot;&gt;&lt;del&gt;LUCENE-1500&lt;/del&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Committing all the above changes in one go to avoid compile errors due to Lucene API updates (except for ReverseStringFilterFactory).&lt;/p&gt;</comment>
                            <comment id="12699694" author="thetaphi" created="Thu, 16 Apr 2009 14:20:51 +0100"  >&lt;p&gt;Again a change....&lt;br/&gt;
*TrieRangeQuery is now available as separate class, *TrieRangeFilter is not needed for Solr range queries (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1602&quot; title=&quot;Rewrite TrieRange to use MultiTermQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1602&quot;&gt;&lt;del&gt;LUCENE-1602&lt;/del&gt;&lt;/a&gt;). It has now equal sematics liek RangeQuery and can also be switched between constant score and boolean query rewrite.&lt;br/&gt;
The next change will be the move to core, package renames and a possibly new name NumericRangeQuery in Lucene core (see java-dev@lucene discussions). Stay tuned.&lt;/p&gt;</comment>
                            <comment id="12699732" author="shalinmangar" created="Thu, 16 Apr 2009 16:45:00 +0100"  >&lt;p&gt;Lets keep this issue open until trie is in core.&lt;/p&gt;</comment>
                            <comment id="12699735" author="shalinmangar" created="Thu, 16 Apr 2009 17:03:44 +0100"  >&lt;p&gt;Patch to incorporate &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1602&quot; title=&quot;Rewrite TrieRange to use MultiTermQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1602&quot;&gt;&lt;del&gt;LUCENE-1602&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Need to upgrade Lucene jars before we can commit this.&lt;/p&gt;</comment>
                            <comment id="12702096" author="thetaphi" created="Thu, 23 Apr 2009 21:43:47 +0100"  >&lt;p&gt;I modified the patch a little bit to also include an updated documentation about sorting and function queries.&lt;/p&gt;</comment>
                            <comment id="12702307" author="shalinmangar" created="Fri, 24 Apr 2009 11:07:13 +0100"  >&lt;p&gt;Committed revision 768240.&lt;/p&gt;

&lt;p&gt;I also added a method SolrIndexSearcher#search(Weight, Filter, Collector) to fix a compile error.&lt;/p&gt;

&lt;p&gt;Thanks Uwe!&lt;/p&gt;</comment>
                            <comment id="12721947" author="thetaphi" created="Fri, 19 Jun 2009 20:21:25 +0100"  >&lt;p&gt;The first part of the move to core is done, when the second part (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1701&quot; title=&quot;Add NumericField, make plain text numeric parsers public in FieldCache, move trie parsers to FieldCache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1701&quot;&gt;&lt;del&gt;LUCENE-1701&lt;/del&gt;&lt;/a&gt;) is done, I will post a patch!&lt;/p&gt;</comment>
                            <comment id="12723342" author="thetaphi" created="Tue, 23 Jun 2009 23:51:55 +0100"  >&lt;p&gt;Patch with changes for new Trie API in Lucene Core, the term &quot;trie&quot; does not appear anymore in Lucene (its now NumericRangeQuery, NumericTokenStream, NumericField, NumericUtils). This patch only contains changes for Trie and FieldCache/ExtendedFieldCache merging (as this affects trie, ExtendedFieldCache was deprecated in Lucene and merged into FieldCache. LongParsers now extend FieldCache.LongParser, for backwards compatibility there is a ExFieldCache.LongParser, too, but the new TrieAPI cannot handle this. So all occurences to ExtendedFieldCache must be removed from Solr)&lt;/p&gt;

&lt;p&gt;The latest changes to Collector (new abstract method handleDocsOutOfOrder()) are not handled!!! Patch is therefore untested, but should work.&lt;/p&gt;

&lt;p&gt;There is also FSDirectory-Factory of Solr changed to use the new FSDirectory.open() call that is the same like your factory (chooses dir dependent on platform).&lt;/p&gt;</comment>
                            <comment id="12723752" author="shalinmangar" created="Wed, 24 Jun 2009 22:30:45 +0100"  >&lt;p&gt;Thanks Uwe!&lt;/p&gt;

&lt;p&gt;Regarding Collector#acceptsDocsOutOfOrder, I think we need to&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Return true when we do not need scores, otherwise false.&lt;/li&gt;
	&lt;li&gt;DocSetCollector and DocSetDelegateCollector collect in order so we return false&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;It&apos;d be great if someone who know more about this stuff can confirm.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1241&quot; title=&quot;Use Lucene&amp;#39;s CharFilter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1241&quot;&gt;&lt;del&gt;SOLR-1241&lt;/del&gt;&lt;/a&gt; must also be committed together with this issue to avoid compile errors.&lt;/p&gt;

&lt;p&gt;I&apos;m also seeing this exception in many tests (DisMaxRequestHandlerTest, TestTrie, TestDistributedSearch) which, I guess, are related to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1630&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SEVERE: java.lang.UnsupportedOperationException&lt;br/&gt;
	at org.apache.lucene.search.Query.createQueryWeight(Query.java:102)&lt;br/&gt;
	at org.apache.lucene.search.BooleanQuery$BooleanWeight.&amp;lt;init&amp;gt;(BooleanQuery.java:185)&lt;br/&gt;
	at org.apache.lucene.search.BooleanQuery.createQueryWeight(BooleanQuery.java:401)&lt;br/&gt;
	at org.apache.lucene.search.Query.queryWeight(Query.java:120)&lt;br/&gt;
	at org.apache.lucene.search.Searcher.createQueryWeight(Searcher.java:237)&lt;br/&gt;
	at org.apache.lucene.search.Searcher.search(Searcher.java:173)&lt;br/&gt;
	at org.apache.solr.search.SolrIndexSearcher.getDocListAndSetNC(SolrIndexSearcher.java:1103)&lt;br/&gt;
	at org.apache.solr.search.SolrIndexSearcher.getDocListC(SolrIndexSearcher.java:880)&lt;br/&gt;
	at org.apache.solr.search.SolrIndexSearcher.search(SolrIndexSearcher.java:341)&lt;br/&gt;
	at org.apache.solr.handler.component.QueryComponent.process(QueryComponent.java:176)&lt;br/&gt;
	at org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:195)&lt;br/&gt;
	at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:131)&lt;br/&gt;
	at org.apache.solr.core.SolrCore.execute(SolrCore.java:1290)&lt;/p&gt;

&lt;p&gt;I&apos;ll try to have another look tomorrow.&lt;/p&gt;</comment>
                            <comment id="12723938" author="thetaphi" created="Thu, 25 Jun 2009 09:10:35 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Regarding Collector#acceptsDocsOutOfOrder, I think we need to&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Return true when we do not need scores, otherwise false.&lt;/li&gt;
	&lt;li&gt;DocSetCollector and DocSetDelegateCollector collect in order so we return false&lt;br/&gt;
It&apos;d be great if someone who know more about this stuff can confirm.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;My explanation without guarantee: If you set it to true or false depends on your collector not on the type of query or sorting or you need scores. It gives the query engine a hint, if it is possible to deliver the doc ids out of order.&lt;/p&gt;

&lt;p&gt;Simple case is the example in the Collector JavaDocs: if you just mark the docids in an OpenBitSet, the order is irrelevant (bitset is not faster/slower when it does not get the docs in correct order). On the other hand collectors like TopDocs and so on can be optimized to be faster when the docs come in order. One example would be: if you read stored fields of documents using the setNextReader() given indexReader, it may be good to have the docs in order to avoid back/forward seeking all the time.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m also seeing this exception in many tests (DisMaxRequestHandlerTest, TestTrie, TestDistributedSearch) which, I guess, are related to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1630&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think, this is because you have a custom query type which implements an own weight. There are possibilities to fix this using a wrapper, not sure.&lt;/p&gt;</comment>
                            <comment id="12723975" author="mikemccand" created="Thu, 25 Jun 2009 10:41:44 +0100"  >&lt;p&gt;Shalin I think that exception you got is a break in back-compat.  Sorry &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I&apos;m reopening &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1630&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt; to fix it...&lt;/p&gt;</comment>
                            <comment id="12724080" author="mikemccand" created="Thu, 25 Jun 2009 14:14:23 +0100"  >&lt;p&gt;OK I just committed a fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1630&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt; that should fix that exception.&lt;/p&gt;</comment>
                            <comment id="12724248" author="shalinmangar" created="Thu, 25 Jun 2009 21:13:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;OK I just committed a fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1630&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt; that should fix that exception&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks Mike. I upgraded to lucene trunk and something is still not right. Now I see a StackOverflowException:&lt;/p&gt;

&lt;p&gt;java.lang.StackOverflowError&lt;br/&gt;
        at org.apache.solr.search.function.FunctionQuery.rewrite(FunctionQuery.java:50)&lt;br/&gt;
        at org.apache.lucene.search.IndexSearcher.rewrite(IndexSearcher.java:291)&lt;br/&gt;
        at org.apache.lucene.search.Query.queryWeight(Query.java:125)&lt;br/&gt;
        at org.apache.lucene.search.Query.weight(Query.java:117)&lt;br/&gt;
        at org.apache.lucene.search.Query.createQueryWeight(Query.java:108)&lt;br/&gt;
        at org.apache.lucene.search.Query.queryWeight(Query.java:126)&lt;br/&gt;
        at org.apache.lucene.search.Query.weight(Query.java:117)&lt;br/&gt;
        at org.apache.lucene.search.Query.createQueryWeight(Query.java:108)&lt;br/&gt;
        at org.apache.lucene.search.Query.queryWeight(Query.java:126)&lt;br/&gt;
        at org.apache.lucene.search.Query.weight(Query.java:117)&lt;/p&gt;</comment>
                            <comment id="12724255" author="mikemccand" created="Thu, 25 Jun 2009 21:28:08 +0100"  >&lt;p&gt;Sigh.  I&apos;ll go reopen &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1630&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt;!&lt;/p&gt;</comment>
                            <comment id="12724286" author="mikemccand" created="Thu, 25 Jun 2009 21:57:39 +0100"  >&lt;p&gt;OK try again?  Maybe 3rd time&apos;s the charm...&lt;/p&gt;</comment>
                            <comment id="12725566" author="shalinmangar" created="Tue, 30 Jun 2009 11:29:38 +0100"  >&lt;p&gt;Uwe, is there a reason to disallow fully open ranges?&lt;/p&gt;

&lt;p&gt;With the previous IntTrieRangeFilter, I could do a query for field:&lt;span class=&quot;error&quot;&gt;&amp;#91;* TO *&amp;#93;&lt;/span&gt; but this is not allowed anymore because NumericRangeQuery can take only one of the boundaries as null but not both.&lt;/p&gt;</comment>
                            <comment id="12725568" author="thetaphi" created="Tue, 30 Jun 2009 11:32:26 +0100"  >&lt;p&gt;Oh, this was intended.&lt;/p&gt;

&lt;p&gt;the reason was, that all other range filters in lucene core do not allow this. In general one should use a MatchAllDocsQuery in this case, as it is more performant.&lt;br/&gt;
I could enable it again, but I have to think about the other range queries and filters then.&lt;/p&gt;

&lt;p&gt;How do you handle that with other range queries?&lt;/p&gt;</comment>
                            <comment id="12725588" author="shalinmangar" created="Tue, 30 Jun 2009 12:55:06 +0100"  >&lt;blockquote&gt;
&lt;p&gt;the reason was, that all other range filters in lucene core do not allow this. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you look at RangeQuery constructor, it creates a new Term instance (even for null lower and upper) so an open ended search executes fine.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In general one should use a MatchAllDocsQuery in this case, as it is more performant&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But a MatchAllDocsQuery is not equivalent to this when some documents do not have a value for this field. For example,  fq=&lt;b&gt;:&lt;/b&gt; AND -f:&lt;span class=&quot;error&quot;&gt;&amp;#91;* TO *&amp;#93;&lt;/span&gt; will match all documents which do not have a value for field f.&lt;/p&gt;</comment>
                            <comment id="12725590" author="thetaphi" created="Tue, 30 Jun 2009 13:08:08 +0100"  >&lt;p&gt;You are right, but normally a new Term(field,null) should be not allowed. The init method should normally prevent this, but only checks for the terms ==null. The RangeTermEnum is then positioned on the null term (should be &quot;&quot;).&lt;/p&gt;

&lt;p&gt;I will change this back (also in FieldCacheRangeFilter) and fix the wrong logic of RangeQuery to clearly support it.&lt;/p&gt;</comment>
                            <comment id="12725594" author="thetaphi" created="Tue, 30 Jun 2009 13:29:44 +0100"  >&lt;p&gt;Fixed in Lucene trunk rev 789692. The strange null handling in RangeQuery (which caused by change) will be fixed together in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1713&quot; title=&quot;Rename RangeQuery -&amp;gt; TermRangeQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1713&quot;&gt;&lt;del&gt;LUCENE-1713&lt;/del&gt;&lt;/a&gt;, when RangeQuery will be deprecated and renamed.&lt;/p&gt;</comment>
                            <comment id="12725597" author="shalinmangar" created="Tue, 30 Jun 2009 13:33:44 +0100"  >&lt;p&gt;&lt;del&gt;I think you are fixing it the wrong way.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Why should it not be allowed? This is something which has worked since a long time. I don&apos;t think it is a bug and it is useful at times.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;Sorry I posted too soon.&lt;/p&gt;

&lt;p&gt;Reading your comment again, I guess that you are indeed going to support such queries?&lt;/p&gt;</comment>
                            <comment id="12725600" author="thetaphi" created="Tue, 30 Jun 2009 13:43:16 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think you are fixing it the wrong way. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You misunderstood, I meant:&lt;br/&gt;
I fix it, that it is clear what it really does. I will not change RangeQuerys behaviour, I will remove the whole internal Term handling in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1713&quot; title=&quot;Rename RangeQuery -&amp;gt; TermRangeQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1713&quot;&gt;&lt;del&gt;LUCENE-1713&lt;/del&gt;&lt;/a&gt; and only use String field, lower, upper. Then it is clear how it works. The current code has this strange behaviour (how it handles Term instances)  because of the retrofitting of RangeQuery to MultiTermQuery.&lt;/p&gt;</comment>
                            <comment id="12725605" author="thetaphi" created="Tue, 30 Jun 2009 13:48:30 +0100"  >&lt;p&gt;Yes, it now works with RangeQuery/Filter (as before), NumericRangeQuery/Filter and FieldCacheRangeFilter.&lt;/p&gt;

&lt;p&gt;I will fix the strange usage of Term instance when we deprecate the old RangeQuery in favour of TermRangeQuery &amp;amp; Co. (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1713&quot; title=&quot;Rename RangeQuery -&amp;gt; TermRangeQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1713&quot;&gt;&lt;del&gt;LUCENE-1713&lt;/del&gt;&lt;/a&gt;).&lt;br/&gt;
The current check in RangeQuery ony prevents you to create a RangeQuery using the Term instances (instead of field, string, string), where both are null (because with both terms entirely null, no field name is available).&lt;/p&gt;</comment>
                            <comment id="12725619" author="shalinmangar" created="Tue, 30 Jun 2009 14:12:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;Yes, it now works with RangeQuery/Filter (as before), NumericRangeQuery/Filter and FieldCacheRangeFilter. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Super, Thanks!&lt;/p&gt;</comment>
                            <comment id="12726047" author="shalinmangar" created="Wed, 1 Jul 2009 14:10:10 +0100"  >&lt;p&gt;This patch includes Uwe&apos;s last patch, changes related to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1614&quot; title=&quot;Add next() and skipTo() variants to DocIdSetIterator that return the current doc, instead of boolean&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LUCENE-1614&quot;&gt;&lt;del&gt;LUCENE-1614&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1241&quot; title=&quot;Use Lucene&amp;#39;s CharFilter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1241&quot;&gt;&lt;del&gt;SOLR-1241&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The QueryElevationComponentTest fails with Lucene trunk which I&apos;ll look into.&lt;/p&gt;</comment>
                            <comment id="12730479" author="thetaphi" created="Mon, 13 Jul 2009 20:43:30 +0100"  >&lt;p&gt;Hi Shalin,&lt;/p&gt;

&lt;p&gt;here is an additional patch (but only for the trie parts), that is more intelligent and also uses NumericTokenStream for the query time factory. Your previous patch must be applied, then revert the changes in analysis.TrieXxxxTokenizerFactory and TrieField. Then apply the patch, which removes the old factories and creates a new one TrieTokenizerFactory. It should compile, but not really tested (it is hard to apply all your changes). If there are compile errors, they can be easily fixed &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The idea is to use the same tokenstream for query time analysis. To only produce the highest precision token needed for that, it is simply using a precisionStep of 32 for int/float and 64 for long/double/date of the former TrieIndexTokenizerFactory. No magic with KeywordTokenizer needed. NumericUtils, which is a expert Lucene class (not really public) is not needed anymore.&lt;/p&gt;</comment>
                            <comment id="12730759" author="thetaphi" created="Tue, 14 Jul 2009 10:51:51 +0100"  >&lt;p&gt;Same patch updated, but uses the new feature of TrieRange to specify any large precStep to index only one token (uses now Integer.MAX_VALUE as precStep for the query tokenizer).&lt;/p&gt;</comment>
                            <comment id="12731320" author="shalinmangar" created="Wed, 15 Jul 2009 08:35:36 +0100"  >&lt;p&gt;Thanks Uwe!&lt;/p&gt;

&lt;p&gt;I&apos;m having trouble figuring out the root cause behind the failure of QueryElevationComponentTest. When elevation is enabled, it seems to be sorting by score desc even if score asc is specified. I&apos;ve written a testcase which I&apos;ll post to java-user to get some info on what could be going wrong.&lt;/p&gt;</comment>
                            <comment id="12731396" author="thetaphi" created="Wed, 15 Jul 2009 12:23:26 +0100"  >&lt;p&gt;I think your problem is solved now (thanks Mike).&lt;/p&gt;

&lt;p&gt;If you update to latest trunk, you must also apply &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1261&quot; title=&quot;Lucene trunk renamed RangeQuery &amp;amp; Co to TermRangeQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1261&quot;&gt;&lt;del&gt;SOLR-1261&lt;/del&gt;&lt;/a&gt; (rename of RangeQuery to TermRangeQuery).&lt;/p&gt;</comment>
                            <comment id="12731558" author="shalinmangar" created="Wed, 15 Jul 2009 18:00:19 +0100"  >&lt;p&gt;Attached patch which combines &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-940&quot; title=&quot;TrieRange support&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-940&quot;&gt;&lt;del&gt;SOLR-940&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1261&quot; title=&quot;Lucene trunk renamed RangeQuery &amp;amp; Co to TermRangeQuery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1261&quot;&gt;&lt;del&gt;SOLR-1261&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1241&quot; title=&quot;Use Lucene&amp;#39;s CharFilter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1241&quot;&gt;&lt;del&gt;SOLR-1241&lt;/del&gt;&lt;/a&gt; which need to be committed together to avoid compile errors.&lt;/p&gt;

&lt;p&gt;I&apos;ll upgrade Lucene jars to Lucene 2.9-dev r794238.&lt;/p&gt;

&lt;p&gt;All tests pass. I&apos;ll commit shortly.&lt;/p&gt;</comment>
                            <comment id="12731567" author="thetaphi" created="Wed, 15 Jul 2009 18:22:12 +0100"  >&lt;p&gt;Patch looks good!&lt;/p&gt;</comment>
                            <comment id="12731571" author="shalinmangar" created="Wed, 15 Jul 2009 18:26:59 +0100"  >&lt;p&gt;Committed revision 794328.&lt;/p&gt;

&lt;p&gt;Thanks Uwe and Mike!&lt;/p&gt;</comment>
                            <comment id="12775620" author="gsingers" created="Tue, 10 Nov 2009 15:51:54 +0000"  >&lt;p&gt;Bulk close for Solr 1.4&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12413224">SOLR-983</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12426825">LUCENE-1673</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12422663">SOLR-1110</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12409265">LUCENE-1470</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12428360">LUCENE-1701</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12421860">LUCENE-1582</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12429537">SOLR-1261</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12404587" name="ASF.LICENSE.NOT.GRANTED--SOLR-940-newTrieAPI.patch" size="11430" author="thetaphi" created="Fri, 3 Apr 2009 22:11:21 +0100"/>
                            <attachment id="12413576" name="SOLR-940-1261-1241.patch" size="85079" author="shalinmangar" created="Wed, 15 Jul 2009 18:00:19 +0100"/>
                            <attachment id="12406280" name="SOLR-940-LUCENE-1602.patch" size="4087" author="thetaphi" created="Thu, 23 Apr 2009 21:43:47 +0100"/>
                            <attachment id="12405656" name="SOLR-940-LUCENE-1602.patch" size="3250" author="shalinmangar" created="Thu, 16 Apr 2009 17:03:44 +0100"/>
                            <attachment id="12413408" name="SOLR-940-LUCENE-1701-addition.patch" size="18064" author="thetaphi" created="Tue, 14 Jul 2009 10:54:52 +0100"/>
                            <attachment id="12412268" name="SOLR-940-LUCENE-1701.patch" size="69854" author="shalinmangar" created="Wed, 1 Jul 2009 14:10:10 +0100"/>
                            <attachment id="12411582" name="SOLR-940-LUCENE-1701.patch" size="17768" author="thetaphi" created="Tue, 23 Jun 2009 23:51:55 +0100"/>
                            <attachment id="12404673" name="SOLR-940-newTrieAPI.patch" size="12695" author="thetaphi" created="Sun, 5 Apr 2009 18:33:46 +0100"/>
                            <attachment id="12402015" name="SOLR-940-rangequery.patch" size="6454" author="shalinmangar" created="Thu, 12 Mar 2009 06:04:06 +0000"/>
                            <attachment id="12401960" name="SOLR-940-rangequery.patch" size="5950" author="shalinmangar" created="Wed, 11 Mar 2009 19:43:32 +0000"/>
                            <attachment id="12402030" name="SOLR-940-test.patch" size="1654" author="shalinmangar" created="Thu, 12 Mar 2009 09:59:46 +0000"/>
                            <attachment id="12405267" name="SOLR-940.patch" size="32572" author="shalinmangar" created="Sun, 12 Apr 2009 11:21:05 +0100"/>
                            <attachment id="12405060" name="SOLR-940.patch" size="24660" author="shalinmangar" created="Thu, 9 Apr 2009 12:27:41 +0100"/>
                            <attachment id="12401704" name="SOLR-940.patch" size="51948" author="shalinmangar" created="Sun, 8 Mar 2009 07:23:54 +0000"/>
                            <attachment id="12401364" name="SOLR-940.patch" size="51563" author="shalinmangar" created="Wed, 4 Mar 2009 04:27:32 +0000"/>
                            <attachment id="12401329" name="SOLR-940.patch" size="50395" author="shalinmangar" created="Tue, 3 Mar 2009 19:33:31 +0000"/>
                            <attachment id="12401319" name="SOLR-940.patch" size="50395" author="shalinmangar" created="Tue, 3 Mar 2009 15:16:38 +0000"/>
                            <attachment id="12401299" name="SOLR-940.patch" size="46178" author="shalinmangar" created="Tue, 3 Mar 2009 11:03:17 +0000"/>
                            <attachment id="12401224" name="SOLR-940.patch" size="42811" author="shalinmangar" created="Mon, 2 Mar 2009 08:57:05 +0000"/>
                            <attachment id="12401193" name="SOLR-940.patch" size="34607" author="shalinmangar" created="Sun, 1 Mar 2009 05:28:35 +0000"/>
                            <attachment id="12401171" name="SOLR-940.patch" size="31870" author="shalinmangar" created="Sat, 28 Feb 2009 20:06:27 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 24 Feb 2009 16:13:29 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6693</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxo9r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20251</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>