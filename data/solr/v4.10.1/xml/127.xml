<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:21:15 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-127/SOLR-127.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-127] Make Solr more friendly to external HTTP caches</title>
                <link>https://issues.apache.org/jira/browse/SOLR-127</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;an offhand comment I saw recently reminded me of something that really bugged me about the serach solution i used &lt;b&gt;before&lt;/b&gt; Solr &amp;#8211; it didn&apos;t play nicely with HTTP caches that might be sitting in front of it.&lt;/p&gt;

&lt;p&gt;at the moment, Solr doesn&apos;t put in particularly usefull info in the HTTP Response headers to aid in caching (ie: Last-Modified), responds to all HEAD requests with a 400, and doesn&apos;t do anything special with If-Modified-Since.&lt;/p&gt;

&lt;p&gt;t the very least, we can set a Last-Modified based on when the current IndexReder was open (if not the Date on the IndexReader) and use the same info to determing how to respond to If-Modified-Since requests.&lt;/p&gt;

&lt;p&gt;(for the record, i think the reason this hasn&apos;t occured to me in the 2+ years i&apos;ve been using Solr, is because with the internal caching, i&apos;ve yet to need to put a proxy cache in front of Solr)&lt;/p&gt;</description>
                <environment></environment>
        <key id="12361541">SOLR-127</key>
            <summary>Make Solr more friendly to external HTTP caches</summary>
                <type id="5" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Wish</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hossman">Hoss Man</assignee>
                                    <reporter username="hossman">Hoss Man</reporter>
                        <labels>
                    </labels>
                <created>Tue, 30 Jan 2007 04:51:30 +0000</created>
                <updated>Fri, 10 May 2013 11:41:14 +0100</updated>
                            <resolved>Thu, 21 Feb 2008 22:55:16 +0000</resolved>
                                                    <fixVersion>1.3</fixVersion>
                                        <due></due>
                            <votes>3</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12526133" author="tpeuss" created="Mon, 10 Sep 2007 12:35:37 +0100"  >&lt;p&gt;Make Solr a bit more friendly for HTTP caches.&lt;/p&gt;</comment>
                            <comment id="12526136" author="tpeuss" created="Mon, 10 Sep 2007 12:44:17 +0100"  >&lt;p&gt;I have not found out (OK, I tried it only 10 minutes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ) where this HEAD requests get blocked. Should be easy to do if you find the right location....&lt;/p&gt;</comment>
                            <comment id="12526164" author="tpeuss" created="Mon, 10 Sep 2007 14:58:12 +0100"  >&lt;p&gt;Solr now responds nicely to HEAD-requests.&lt;/p&gt;</comment>
                            <comment id="12526169" author="tpeuss" created="Mon, 10 Sep 2007 15:14:26 +0100"  >&lt;p&gt;Some code cleanup and a fixed typo.&lt;/p&gt;</comment>
                            <comment id="12527325" author="koji" created="Fri, 14 Sep 2007 02:46:50 +0100"  >&lt;p&gt;Note that this patch can do much for doing better throughput, but unluckily Solr doesn&apos;t take into account in stats (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-176&quot; title=&quot;Add detailed timing data to query response output&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-176&quot;&gt;&lt;del&gt;SOLR-176&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="12527337" author="ehatcher" created="Fri, 14 Sep 2007 04:41:40 +0100"  >&lt;p&gt;What about etags?  &lt;a href=&quot;http://intertwingly.net/blog/2006/06/05/Elevator-Pitch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://intertwingly.net/blog/2006/06/05/Elevator-Pitch&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12527364" author="tpeuss" created="Fri, 14 Sep 2007 07:09:19 +0100"  >&lt;p&gt;@Erik: Adding Etag support should be not that hard. I have a look into that. As the Etag value I propose a hash of the request URI and the index version.&lt;/p&gt;

&lt;p&gt;@Koji: I have a look if I can update the request count for Not-Modified responses. The question there is only if we really want that. The current counter tells us how many requests really reached the search handler. In my opinion that is what I want because the Not-Modified responses put not much pressure on the server.&lt;/p&gt;</comment>
                            <comment id="12527388" author="tpeuss" created="Fri, 14 Sep 2007 08:41:07 +0100"  >&lt;p&gt;Added Etag support.&lt;/p&gt;</comment>
                            <comment id="12527396" author="tpeuss" created="Fri, 14 Sep 2007 09:04:17 +0100"  >&lt;p&gt;After reading the W3C docs I have seen that we can calculate the Etags in a much simpler way.&lt;/p&gt;</comment>
                            <comment id="12527483" author="tpeuss" created="Fri, 14 Sep 2007 13:16:57 +0100"  >&lt;p&gt;Be even more standards compliant. If-Match and If-None-Match headers can appear multiple times.&lt;/p&gt;</comment>
                            <comment id="12527664" author="hossman" created="Sat, 15 Sep 2007 01:24:54 +0100"  >&lt;p&gt;1) it&apos;s not a good idea to assume the indexVersion can be used as a timestamp ... Lucene does not guarantee that.  To be safe we should record the timestamp we opened the index at.  (using the lastModified on files in the Directory is a bad idea as well ... someone could swap out an index with a backup and get &quot;older&quot; files that represent a &quot;newer&quot; index from Solr&apos;s perspective)&lt;/p&gt;

&lt;p&gt;1) isn&apos;t the header named &quot;ETag&quot; (not &quot;Etag&quot;) ?&lt;/p&gt;

&lt;p&gt;2) I&apos;m not an expert on all this new fangled HTTP/1.1 stuff ... but is an ETag based on the URI and the indexVersion/timestamp really that useful?  wouldn&apos;t the Last-Modified header in that case be just as useful?  I thought the value add of an ETag was that even if the content has been modified, if that modification results in no real changes, old cached values can still be useful.  with Solr specificly in mind, the index may have changed, but if the results of a query are identicle to the results before the change, those cna have the same ETag right?  wouldn&apos;t a hash of the URI and the SolrQueryResponse make more sense in that regards?&lt;/p&gt;</comment>
                            <comment id="12527694" author="wunder" created="Sat, 15 Sep 2007 05:38:18 +0100"  >&lt;p&gt;Last-modified does require monotonic time, but ETags are version stamps without any ordering. The indexVersion should be fine for an ETag.&lt;/p&gt;</comment>
                            <comment id="12528002" author="tpeuss" created="Mon, 17 Sep 2007 10:10:53 +0100"  >&lt;p&gt;1.) I now use the time the reader was opened. But we should be aware of the fact that when we have two servers (for HA reasons for example) this times differ for sure. For clients with ETag support this is no problem because the ETag will be still the same.&lt;br/&gt;
2.) You are right it is ETag. Clients/servers handle the headers case-insensitive. This is why I have not seen that...&lt;br/&gt;
3.) Some clients support only ETag, some support only Last-Modified, many support both. That&apos;s why we should support both. And you are right: the ETags can more than we use.&lt;/p&gt;

&lt;p&gt;You spoke about taking the result of a search into account. Maybe we are talking about two different things here. This patch is about getting load off the server. When we want a 100% confident client then we need to take the server response into account. But currently I don&apos;t see a big benefit of this and it makes the code much more complex.&lt;/p&gt;</comment>
                            <comment id="12529634" author="tpeuss" created="Sat, 22 Sep 2007 09:35:27 +0100"  >&lt;p&gt;Changed the behavior to first check for ETag related headers. Clients that support ETags have a greater possibility to have a cache-hit.&lt;/p&gt;</comment>
                            <comment id="12529670" author="tpeuss" created="Sat, 22 Sep 2007 15:54:50 +0100"  >&lt;p&gt;Some code cleanup and refactoring.&lt;/p&gt;</comment>
                            <comment id="12529819" author="tpeuss" created="Mon, 24 Sep 2007 11:12:54 +0100"  >&lt;p&gt;Added a unit test for the cache header stuff...&lt;/p&gt;</comment>
                            <comment id="12529822" author="tpeuss" created="Mon, 24 Sep 2007 11:24:01 +0100"  >&lt;p&gt;Added a unit test to check correct cache header behavior.&lt;/p&gt;</comment>
                            <comment id="12533502" author="ehatcher" created="Tue, 9 Oct 2007 21:53:52 +0100"  >&lt;p&gt;targeting this for the 1.3 release.&lt;/p&gt;</comment>
                            <comment id="12535051" author="hossman" created="Tue, 16 Oct 2007 05:04:46 +0100"  >&lt;p&gt;Okay, i&apos;ve been learning a little more about HTTP Caching, and i looked over the latest patch. a few comments...&lt;/p&gt;


&lt;p&gt;1) do we really want this in all cases?...&lt;/p&gt;

&lt;p&gt;+    resp.setHeader(&quot;Cache-Control&quot;,&lt;br/&gt;
+        &quot;max-age=0, must-revalidate&quot;);&lt;/p&gt;

&lt;p&gt;...that seems a little harsh.  if we&apos;re going to do that it seems like it should be optional.  (NOTE: it&apos;s not backwards compatible if people already have caches in front of Solr right now)&lt;/p&gt;


&lt;p&gt;2) I&apos;ve been reading about etags ... we need to make sure we don&apos;t inadvertently output an etag with &quot;w/&quot; in front (indicating it&apos;s a week entity tag) ... we should future proof against changes to IndexReader.getVersion() by putting a prefix on the version when making an etag.  also: should we obfuscate the version (ie: hash it) so as not to risk disclosing info to people who shouldn&apos;t have it?&lt;/p&gt;


&lt;p&gt;3) all etags are the same until the reader is reopened ... shouldn&apos;t they also hash on the URL? (is there a downside to multiple URLs having the same etag?)&lt;/p&gt;


&lt;p&gt;4) are these semantics right? send PRECON_FAIL when &quot;If-None-Match&quot; tag matches and request is not GET or HEAD? (what about a POSTed query?) ....&lt;/p&gt;

&lt;p&gt;+    if(ifNoneMatchList.size()&amp;gt;0 &amp;amp;&amp;amp; isMatchingEtag(ifNoneMatchList,etag)) {&lt;br/&gt;
+      if(isGETRequest || isHEADRequest) &lt;/p&gt;
{
+        sendNotModified(resp);
+      }
&lt;p&gt; else &lt;/p&gt;
{
+        sendPreconditionFailed(resp);
+      }
&lt;p&gt;+      return true;&lt;/p&gt;


&lt;p&gt;5) using SolrIndexSearcher.openTime() as last-modified for query requests makes sense ... put what about updates?  since RequestHandlers don&apos;t declare what they are, should we use &quot;now&quot; for POSTs and openTime for GET/HEAD ?&lt;/p&gt;</comment>
                            <comment id="12535248" author="tpeuss" created="Tue, 16 Oct 2007 14:50:04 +0100"  >&lt;p&gt;ad 1.)&lt;br/&gt;
I have thought about that as well. We should make it configurable. But I do not know where the best place is for the configuration.&lt;/p&gt;

&lt;p&gt;ad 2.)&lt;br/&gt;
getVersion() delivers a long - how should that ever be converted to w/? According to W3C a weak ETag looks like this: W/&quot;xyzzy&quot;. We always generate ETags like &quot;xyzzy&quot;. So no problem here. Even &quot;W/xyzzy&quot; would be a strong ETag.&lt;/p&gt;

&lt;p&gt;Hashing of the version is a good idea. I add that. But be aware that generating a hash consumes a lot of extra CPU cycles...&lt;/p&gt;

&lt;p&gt;ad 3.)&lt;br/&gt;
As the answer to a request is always the same when the index is not changed it is OK to have the same ETag for all requests IMHO. The ETag has not to be exclusive per request URL. The ETag only allows the browser to send requests like &quot;only execute when changed&quot;. And the ETag only changes when the index has changed.&lt;/p&gt;

&lt;p&gt;ad 4.)&lt;br/&gt;
I have thought about that as well. The problem here is that we have POSTs that change the index and POSTs that do not change the index. The semantics are according to W3C. Here a snippet from &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&lt;/a&gt; (section 14.26):&lt;br/&gt;
&quot;Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache- related header fields (particularly ETag) of one of the entities that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).&quot;&lt;/p&gt;

&lt;p&gt;The idea behind that seems to be that POSTs are for changing things. But we can ignore that of course.&lt;/p&gt;

&lt;p&gt;ad 5.)&lt;br/&gt;
Maybe we should not emit cache related headers for POSTs at all?&lt;/p&gt;</comment>
                            <comment id="12535569" author="tpeuss" created="Wed, 17 Oct 2007 15:29:09 +0100"  >&lt;ul&gt;
	&lt;li&gt;Index version is now an MD5 hash: I am not sure what information we really expose here. It is time consuming to create the hash.&lt;/li&gt;
	&lt;li&gt;Cache-Control HTTP header can now be configured in solr-config.xml:&lt;br/&gt;
  &amp;lt;requestDispatcher handleSelect=&quot;true&quot; &amp;gt;&lt;br/&gt;
    &amp;lt;&lt;span class=&quot;error&quot;&gt;Unable to render embedded object: File (--Make sure your system has some authentication before enabling remote streaming) not found.&lt;/span&gt;  --&amp;gt;&lt;br/&gt;
    &amp;lt;requestParsers enableRemoteStreaming=&quot;false&quot; multipartUploadLimitInKB=&quot;2048&quot; /&amp;gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     &amp;lt;httpCacheControlHeader&amp;gt;no-cache, no-store&amp;lt;/httpCacheControlHeader&amp;gt;&lt;/p&gt;

&lt;p&gt;  &amp;lt;/requestDispatcher&amp;gt;&lt;/p&gt;

&lt;p&gt;The default value is no-cache, no-store when the tag is not there for backward compatibility.&lt;/p&gt;</comment>
                            <comment id="12535579" author="yseeley@gmail.com" created="Wed, 17 Oct 2007 15:51:17 +0100"  >&lt;p&gt;&amp;gt; Index version is now an MD5 hash: I am not sure what information we really expose here. It is time consuming to create the hash.&lt;/p&gt;

&lt;p&gt;I guess the info reveals when the index was created (defaults to current milliseconds, and is incremented by 1 for each new committed change).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;But&lt;/b&gt;, doing any sort of hash on this version  number alone isn&apos;t really secure since I can guess perhaps within a day of when the index was created, and there are only 84M milliseconds in a day.  Since the algorithm is known, I can try them all if I want.  But really, I don&apos;t see the harm in letting someone see the index version either.&lt;/p&gt;

&lt;p&gt;If we want to obfuscate it for some reason, we should just use something simple and fast...&lt;/p&gt;</comment>
                            <comment id="12535611" author="tpeuss" created="Wed, 17 Oct 2007 17:26:41 +0100"  >&lt;p&gt;We should think about what a bad guy can do with that information: &lt;b&gt;nothing&lt;/b&gt;. It is not an id or key that elevates your rights or something like that when you know it.&lt;/p&gt;

&lt;p&gt;I would opt for writing out the index version directly as well: it is fast and simple...&lt;/p&gt;</comment>
                            <comment id="12535856" author="tpeuss" created="Thu, 18 Oct 2007 08:32:34 +0100"  >&lt;p&gt;What do you expect as default behaviour of this patch?&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Emit no cache related headers at all&lt;/li&gt;
	&lt;li&gt;Emit conservative cache related headers
	&lt;ul&gt;
		&lt;li&gt;for example &lt;em&gt;max-age=0, must-revalidate&lt;/em&gt; - this should work with every not completely broken cache implementation without breaking anything (besides  pushing performance because you offload the Solr-server)&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Emit more &quot;cachy&quot; headers
	&lt;ul&gt;
		&lt;li&gt;for example &lt;em&gt;max-age=600&lt;/em&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12536098" author="hossman" created="Fri, 19 Oct 2007 04:44:30 +0100"  >&lt;p&gt;In no particular order...&lt;/p&gt;


&lt;p&gt;Ignore my question about weak etags (w/), this is what happens when I review patches tired ... i forgot getVersion() returns a long AND i missread how weak etags work.&lt;/p&gt;

&lt;p&gt;I wasn&apos;t saying that i think we need to do a hash to &quot;hide&quot; the version, just pointing out that some people might consider it divulging more info then we should.  if no one else cares, i don&apos;t care (especially if it&apos;s prohibitively expensive)&lt;/p&gt;

&lt;p&gt;I like the idea of not emiting caching headers in response to POST requests ... the RFCs say that POSTs by default aren&apos;t cachable right?  that also seems like a reasonable solution to the issues of typical &quot;/update&quot; urls all having both identicle etags and urls, as well as &quot;If-None-Match&quot; leading to PRECON_FAIL.&lt;/p&gt;

&lt;p&gt;Having explicit config options for the Cache-Control header seems good .. i wonder if we should make it a requestHandler option (instead of a SolrCore option).&lt;/p&gt;

&lt;p&gt;In regard to this comment...&lt;br/&gt;
  &quot;The default value is no-cache, no-store when the tag is not there for backward compatibility.&quot;&lt;br/&gt;
...that&apos;s not really true.  Total backwards compatibility would be no new headers at all ... if someone has a surgate proxy in front of Solr 1.2, it can use it&apos;s own configs or hueristics to decide how long to cache.  as soon as we include Cache-Control header that stops working.&lt;/p&gt;

&lt;p&gt;I think the default behavior can be &quot;conservative&quot; headers (Last-Modified, ETag,and must-revalidate) that&apos;s probably the best thing for new users.   But ideally there should be a way to turn it off completely (it&apos;s good to have a mechanism for people upgrading to garuntee they get the same behavior as before&lt;/p&gt;


</comment>
                            <comment id="12536225" author="tpeuss" created="Fri, 19 Oct 2007 15:04:51 +0100"  >&lt;p&gt;Updated patch inspired by Hoss Mans comments.&lt;/p&gt;

&lt;p&gt;Changes:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Cache header settings can now be set per request handler. Omitting the parameters switches off cache header generation (fall back to old behaviour).
	&lt;ul&gt;
		&lt;li&gt;&amp;lt;int name=&quot;httpCacheLivetime&quot;&amp;gt;0&amp;lt;/int&amp;gt;: Set &quot;freshness&quot; timespan in seconds&lt;/li&gt;
		&lt;li&gt;&amp;lt;bool name=&quot;httpCacheForceRevalidation&quot;&amp;gt;true&amp;lt;/bool&amp;gt;: controls if we emit &quot;must-revalidate&quot;&lt;/li&gt;
		&lt;li&gt;&amp;lt;bool name=&quot;httpCacheForcePrivate&quot;&amp;gt;false&amp;lt;/bool&amp;gt;: constrols if we emit &quot;private&quot;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Some refactoring to make the Filter class smaller&lt;/li&gt;
	&lt;li&gt;Updated testcase to check that we do not emit cache headers on POST requests.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12536401" author="otis" created="Sat, 20 Oct 2007 05:44:44 +0100"  >&lt;p&gt;Thomas, minor comment: httpCacheLivetime --&amp;gt; httpCacheTTL?&lt;/p&gt;</comment>
                            <comment id="12536930" author="tpeuss" created="Tue, 23 Oct 2007 08:19:26 +0100"  >&lt;p&gt;Updated as Otis suggested. One thing I don&apos;t like with this patch that it changes the contract of the interface SolrRequestHandler. Maybe a Solr guru can tell me how I  avoid that.&lt;/p&gt;

&lt;p&gt;I need access to the request handlers settings &lt;em&gt;before&lt;/em&gt; execution. getParams() does only deliver the parameters that are on the URI before execution...&lt;/p&gt;</comment>
                            <comment id="12548176" author="tpeuss" created="Tue, 4 Dec 2007 08:57:31 +0000"  >&lt;p&gt;Updated to trunk. Any chance to get this into SVN soon?&lt;/p&gt;</comment>
                            <comment id="12548610" author="tpeuss" created="Wed, 5 Dec 2007 09:39:31 +0000"  >&lt;p&gt;Minor performance update.&lt;/p&gt;</comment>
                            <comment id="12549513" author="otis" created="Fri, 7 Dec 2007 18:43:57 +0000"  >&lt;p&gt;I gave my vote for this one, but ant test failed for me after I applied this patch:&lt;/p&gt;

&lt;p&gt;junit.framework.AssertionFailedError: Unknown request response expected:&amp;lt;0&amp;gt; but was:&amp;lt;400&amp;gt;&lt;br/&gt;
	at org.apache.solr.servlet.CacheHeaderTest.checkResponseBody(CacheHeaderTest.java:175)&lt;br/&gt;
	at org.apache.solr.servlet.CacheHeaderTest.doCacheControl(CacheHeaderTest.java:328)&lt;br/&gt;
	at org.apache.solr.servlet.CacheHeaderTest.testCacheControl(CacheHeaderTest.java:152)&lt;/p&gt;</comment>
                            <comment id="12549650" author="hossman" created="Sat, 8 Dec 2007 05:25:38 +0000"  >&lt;p&gt;Thomas: I have not looked at any of the patch updates since my last comment, but it is my sincere plan to spend some serious time on this issue this week if possible &amp;#8211; and if not, then starting on Jan2 when i get back from vacation.  (it&apos;s on my &quot;work&quot; todo list not just my &quot;spare time apache&quot; todo list)&lt;/p&gt;
</comment>
                            <comment id="12549735" author="tpeuss" created="Sat, 8 Dec 2007 18:33:50 +0000"  >&lt;p&gt;I can reproduce the error. It seems to be caused by the multi-core stuff that has been committed yesterday...&lt;/p&gt;</comment>
                            <comment id="12553272" author="tpeuss" created="Wed, 19 Dec 2007 09:11:17 +0000"  >&lt;p&gt;Updated to trunk. The test was failing because there was an error in the testcase.&lt;/p&gt;</comment>
                            <comment id="12553918" author="tpeuss" created="Fri, 21 Dec 2007 10:01:37 +0000"  >&lt;p&gt;Added the request parameter &quot;httpnocache&quot; (can be true or false - defaults to false) to emit &quot;no-cache&quot; Cache-Control headers for requests you do not want to be cached by shared caches.&lt;/p&gt;
</comment>
                            <comment id="12553924" author="tpeuss" created="Fri, 21 Dec 2007 11:15:08 +0000"  >&lt;p&gt;Updated. Even more aggressive no-cache header get emitted when httpnocache=true.&lt;/p&gt;</comment>
                            <comment id="12556599" author="tpeuss" created="Mon, 7 Jan 2008 15:45:29 +0000"  >&lt;ul&gt;
	&lt;li&gt;Performance optimization:
	&lt;ul&gt;
		&lt;li&gt;ETag is only recalculated when the index changes&lt;/li&gt;
		&lt;li&gt;Shorter ETag&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Updated to trunk&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12561844" author="hossman" created="Wed, 23 Jan 2008 22:29:00 +0000"  >&lt;p&gt;this patch is functionally the same as the last patch from Thomas  but updated to work against the HEAD (r614702) without patch warnings. &lt;/p&gt;

&lt;p&gt;i&apos;m reviewing the patch in depth now.&lt;/p&gt;</comment>
                            <comment id="12561920" author="hossman" created="Thu, 24 Jan 2008 02:28:49 +0000"  >&lt;p&gt;Thomas: first off .. thanks a lot for putting so much effort into this.  Looking over your patch, and seeing the hoops you had to jump through to get per request handler configuration, i feel bad for ever even suggesting it.&lt;/p&gt;

&lt;p&gt;We definitely shouldn&apos;t make a backwards incompatible change like you needed with the getDefaults() to deal with the caching.  I think for now, we should stick with your earlier approach of putting the configuration in the &amp;lt;requestDispatcher&amp;gt; block ... perhaps down the road we will have an easier mechanism for per-handler overrides (maybe using the new components stuff?) but even if we do, having some default configs in &amp;lt;requestDispatcher&amp;gt; will be good.&lt;/p&gt;

&lt;p&gt;I&apos;ve got a modified version of your patch that moves back in this direction (but keeps some of the other good stuff you&apos;ve added recently) that i&apos;ll attach in a moment.&lt;/p&gt;

&lt;p&gt;At a higher level, i have few broader questions/concerns that we should probably think about...&lt;/p&gt;

&lt;p&gt;1) it occurs to me that the etag value needs to include some kind of hashCode for the solrconfig.xml &amp;#8211; otherwise someone could bounce their server (without changing the index) and continue to get identical ETag headers, even if the new config options cause entirely different results to be generated (ie: new default handler params)&lt;br/&gt;
(We probably ought to be including the getVersion() info from both Solr and the specified request handler as well &amp;#8211; just in case they deploy new code that has new behavior without modifying the index, or their configs .. but i&apos;m not really as worried about this ... i&apos;m OK with a FAQ saying you have make a small change to your solrconfig.xml to force new ETags&lt;/p&gt;

&lt;p&gt;2) currently, even if the configs say &quot;don&apos;t be cache friendly&quot; an etag is still computed, and requests are tested for validation headers (it&apos;s even possible to get a 304 if you guess the etag or pick a really old If-Modified-Since header) ... this seems like a bad idea (and i believe it violates the RFC) .. so we should make sure no special work is done relating to cache headers if the solrconfig.xml says to disable it completely.&lt;/p&gt;
</comment>
                            <comment id="12561921" author="hossman" created="Thu, 24 Jan 2008 02:32:40 +0000"  >&lt;p&gt;revised version of Thomas&apos;s most recent patch, that removes the backwards-incompatible changes to SolrRequestHandler by moving all configuration related to caching config options into the &amp;lt;requestDispatcher&amp;gt; block...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
       &amp;lt;!--
          Set HTTP caching related parameters (&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; proxy caches and clients).
          
          To get the behaviour of Solr 1.2 (ie: no caching related headers)
          use the noCachingHeaders=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; option
        --&amp;gt;
    &amp;lt;!-- :TODO: it would be nice to mimic the directives of the Cache-Control header more closely --&amp;gt;
    &amp;lt;httpCaching httpCacheTTL=&lt;span class=&quot;code-quote&quot;&gt;&quot;30&quot;&lt;/span&gt;
                 httpCacheForceRevalidation=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;&quot;&lt;/span&gt;
                 httpCacheForcePrivate=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...as noted in that TODO line, i&apos;d like to rethink what the exact options should be, but that&apos;s a minor issue compared to the functionality itself.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; unit tests currently fail, since caching is now either on or off for the entire server, the test will probably need to be refactored into two separate tests with different configs.&lt;/p&gt;</comment>
                            <comment id="12561974" author="tpeuss" created="Thu, 24 Jan 2008 08:45:35 +0000"  >&lt;blockquote&gt;
&lt;p&gt;1) it occurs to me that the etag value needs to include some kind of hashCode for the solrconfig.xml - otherwise someone could bounce their server (without changing the index) and continue to get identical ETag headers, even if the new config options cause entirely different results to be generated (ie: new default handler params)&lt;br/&gt;
(We probably ought to be including the getVersion() info from both Solr and the specified request handler as well - just in case they deploy new code that has new behavior without modifying the index, or their configs .. but i&apos;m not really as worried about this ... i&apos;m OK with a FAQ saying you have make a small change to your solrconfig.xml to force new ETags&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point. You can get around that problem by using the openTime for the ETags as well.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2) currently, even if the configs say &quot;don&apos;t be cache friendly&quot; an etag is still computed, and requests are tested for validation headers (it&apos;s even possible to get a 304 if you guess the etag or pick a really old If-Modified-Since header) ... this seems like a bad idea (and i believe it violates the RFC) .. so we should make sure no special work is done relating to cache headers if the solrconfig.xml says to disable it completely.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True. I missed that one.&lt;/p&gt;

&lt;p&gt;What do you expect from me now? Should I have a look at the testcase?&lt;/p&gt;</comment>
                            <comment id="12562274" author="hossman" created="Thu, 24 Jan 2008 22:56:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;Good point. You can get around that problem by using the openTime for the ETags as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah ... ugh ... i&apos;m actually starting to question whether or not openTime is even the right choice for Last-Mod ... you made a really good point before about it causing Last-Mod times to differnet between multiple (identical) slaves, but at least the ETags would be in sync ... if we add openTime to the ETag we lose even that.&lt;/p&gt;

&lt;p&gt;my initial concern about using IndexReader.lastModified for Last-Mod was the case where someone rolls back an index, but that&apos;s really the exceptional case ... most people will probably never encounter it (and if they do, they can work around it by &quot;touching&quot; the segments file ... or we could have another option for it ... lastModFrom=&quot;open|disk&quot; ... what do you think?)&lt;/p&gt;

&lt;p&gt;Getting back to the question of the ETag though, i think it would be better to use a hashCode on the config itself ... if the index hasn&apos;t changed, and the config hasn&apos;t changed restarting Solr shouldn&apos;t make the ETag change.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What do you expect from me now? Should I have a look at the testcase?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&quot;expect&quot; ? ... uh, i have no expectations from you ... Solr is an volunteer project, no one is expected to do anything other then contribute when/where/however they can &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;seriously though: you&apos;ve clearly thought about this task more then anyone else at this point, i&apos;m just throwing out ideas and concerns, if you think i&apos;m making stupid suggestions, or over thinking something, or not thinking hard enough about something else let me know.  &lt;/p&gt;

&lt;p&gt;First and foremost: do you think being able to customize the &quot;cache awareness&quot; of Solr on a per request handler basis is important enough that we shouldn&apos;t move forward until we figure out a way to make it work, or do you think it&apos;s useful to have a single SolrCore wide configuration for this sort of thing?&lt;/p&gt;

&lt;p&gt;Assuming we&apos;re on the right track, my game plan moving forward is:&lt;br/&gt;
1)  i&apos;m going to startplay around with the config options and the control flow logic to make sure we don&apos;t do 304 style validation work when we shouldn&apos;t&lt;br/&gt;
2) i suggest we think/discuss the openTime/lastModified and config modified / ETag issues a little more before making any changes there&lt;br/&gt;
3) the tests will need refactored so we have at least 2 variants (&quot;doing caching right&quot;, not doing caching because we said not to&quot;) ... if you want to take a look at doing that now, that would be great &amp;#8211; particularly since i&apos;m not very familiar with the framework Ryan setup for doing JUnit tests that actually spin up Jetty to do the HTTP layer.&lt;/p&gt;


</comment>
                            <comment id="12562286" author="hossman" created="Thu, 24 Jan 2008 23:09:43 +0000"  >&lt;p&gt;Incidentally, the config syntax i&apos;m thinking might work best is something like...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &amp;lt;requestDispatcher handleSelect=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; &amp;gt;
       ...
       &amp;lt;!--
          Set HTTP caching related parameters (&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; proxy caches and clients).
          (These are the defaults)
    &amp;lt;httpCaching lastModifiedFrom=&lt;span class=&quot;code-quote&quot;&gt;&quot;openTime&quot;&lt;/span&gt;&amp;gt;
       &amp;lt;cacheControl max-age=&lt;span class=&quot;code-quote&quot;&gt;&quot;30&quot;&lt;/span&gt; must-revalidate=&lt;span class=&quot;code-quote&quot;&gt;&quot;&quot; &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;=&quot;&lt;/span&gt;Foo&quot; /&amp;gt;
    &amp;lt;/httpCaching&amp;gt;
    --&amp;gt;
    &amp;lt;!-- to prevent Solr from doing any HTTP Cache related work uncomment &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;... --&amp;gt;
    &amp;lt;!--
     &amp;lt;httpCaching never304=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt; /&amp;gt;
    --&amp;gt;
    &amp;lt;!-- to prevent Solr work, and to be really unfriendly to caches, uncomment &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;... --&amp;gt;
    &amp;lt;!--
     &amp;lt;httpCaching never304=&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt;&amp;gt;
       &amp;lt;cacheControl max-age=&lt;span class=&quot;code-quote&quot;&gt;&quot;0&quot;&lt;/span&gt; no-cache=&lt;span class=&quot;code-quote&quot;&gt;&quot;&quot; no-store=&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot; must-revalidate=&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot; &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;=&quot;&lt;/span&gt;Foo&quot; /&amp;gt;
    &amp;lt;/httpCaching&amp;gt;
    --&amp;gt;
   ...
  &amp;lt;/requestDispatcher&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...the idea being that any attribute under &amp;lt;cacheControl&amp;gt; becomes an option in the Cache-Control header .. if it has a non-empty value, then that value is echoed as well.  Expires header will also be output if max-age is specified.&lt;/p&gt;
</comment>
                            <comment id="12562319" author="hossman" created="Fri, 25 Jan 2008 00:53:19 +0000"  >&lt;p&gt;checkpoint.&lt;/p&gt;

&lt;p&gt;made the logic changes as discussed ... etag and lastMod calculation will now only happen if needed based on config.  Cache-Control header is always generated according tothe solrconfig.xml.  I also did some method refacotring and renaming to try and make it a little more explicit what was happening where, and fixed two small bugs i found (1: even on HEAD request we need to execute the request because it might fail; 2) catch and ignore IAE when parsing the date conditional headers - ie: a malformed date shouldnt&apos; cause the page to fail)&lt;/p&gt;

&lt;p&gt;config syntax is the same as the last patch.&lt;/p&gt;</comment>
                            <comment id="12562405" author="tpeuss" created="Fri, 25 Jan 2008 08:53:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;Getting back to the question of the ETag though, i think it would be better to use a hashCode on the config itself ... if the index hasn&apos;t changed, and the config hasn&apos;t changed restarting Solr shouldn&apos;t make the ETag change.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is a good idea to use a hash of the config as well. But we need to write that down somewhere that identical slaves need identical indexes &lt;b&gt;and&lt;/b&gt; config files as well to have the same ETag.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;expect&quot; ? ... uh, i have no expectations from you ... Solr is an volunteer project, no one is expected to do anything other then contribute when/where/however they can&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I know. &quot;Expect&quot; might have been the wrong word for that. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I only want to make sure that we do not work on the same stuff. I love the peer review you get with OSS projects.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;First and foremost: do you think being able to customize the &quot;cache awareness&quot; of Solr on a per request handler basis is important enough that we shouldn&apos;t move forward until we figure out a way to make it work, or do you think it&apos;s useful to have a single SolrCore wide configuration for this sort of thing?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A SolrCore wide config for this is enough IMHO.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Assuming we&apos;re on the right track, my game plan moving forward is:&lt;br/&gt;
1) i&apos;m going to startplay around with the config options and the control flow logic to make sure we don&apos;t do 304 style validation work when we shouldn&apos;t&lt;br/&gt;
2) i suggest we think/discuss the openTime/lastModified and config modified / ETag issues a little more before making any changes there&lt;br/&gt;
3) the tests will need refactored so we have at least 2 variants (&quot;doing caching right&quot;, not doing caching because we said not to&quot;) ... if you want to take a look at doing that now, that would be great - particularly since i&apos;m not very familiar with the framework Ryan setup for doing JUnit tests that actually spin up Jetty to do the HTTP layer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ad 2.: Whatever we choose: Two things must be linked: changed index and/or changed config must change the Etag &lt;b&gt;and&lt;/b&gt; the Last-Modified time (this must be changed on config change as well!). Last-Modified must be the maximum of config file change time and index change time...&lt;br/&gt;
Ad 3.: Most of the time I have spent with the unit test was to fiddle out how this Jetty stuff works... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I have a look at this.&lt;/p&gt;</comment>
                            <comment id="12562410" author="tpeuss" created="Fri, 25 Jan 2008 09:17:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;lt;requestDispatcher handleSelect=&quot;true&quot; &amp;gt;&lt;br/&gt;
       ...&lt;br/&gt;
       &amp;lt;!--&lt;br/&gt;
          Set HTTP caching related parameters (for proxy caches and clients).&lt;br/&gt;
          (These are the defaults)&lt;br/&gt;
    &amp;lt;httpCaching lastModifiedFrom=&quot;openTime&quot;&amp;gt;&lt;br/&gt;
       &amp;lt;cacheControl max-age=&quot;30&quot; must-revalidate=&quot;&quot; private=&quot;Foo&quot; /&amp;gt;&lt;br/&gt;
    &amp;lt;/httpCaching&amp;gt;&lt;br/&gt;
    --&amp;gt;&lt;br/&gt;
    &amp;lt;!-- to prevent Solr from doing any HTTP Cache related work uncomment this... --&amp;gt;&lt;br/&gt;
    &amp;lt;!--&lt;br/&gt;
     &amp;lt;httpCaching never304=&quot;true&quot; /&amp;gt;&lt;br/&gt;
    --&amp;gt;&lt;br/&gt;
    &amp;lt;!-- to prevent Solr work, and to be really unfriendly to caches, uncomment this... --&amp;gt;&lt;br/&gt;
    &amp;lt;!--&lt;br/&gt;
     &amp;lt;httpCaching never304=&quot;true&quot;&amp;gt;&lt;br/&gt;
       &amp;lt;cacheControl max-age=&quot;0&quot; no-cache=&quot;&quot; no-store=&quot;&quot; must-revalidate=&quot;&quot; private=&quot;Foo&quot; /&amp;gt;&lt;br/&gt;
    &amp;lt;/httpCaching&amp;gt;&lt;br/&gt;
    --&amp;gt;&lt;br/&gt;
   ...&lt;br/&gt;
  &amp;lt;/requestDispatcher&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;One comment only: change must-revalidate=&quot;&quot; to must-revalidate=&quot;true/false&quot; . For no-store/no-cache as well.&lt;/p&gt;</comment>
                            <comment id="12562490" author="tpeuss" created="Fri, 25 Jan 2008 13:13:21 +0000"  >&lt;p&gt;Updated unit test. The tests for cache and no-cache tests have now been split into different files. A final update has to take place when the cache related code is stable.&lt;/p&gt;</comment>
                            <comment id="12562803" author="hossman" created="Sat, 26 Jan 2008 02:08:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;Ad 2.: Whatever we choose: Two things must be linked: changed index and/or changed config must change the Etag and the Last-Modified &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure that this is strictly true ... if something changes the Etag, then the Last-Modified should also change, but if the Last-Modified changes the Etag doesn&apos;t necessarily have to change.  consider use cases where solrconfig.xml never changes: we can use openTime for Last-Modified (in case we have to rollback to an older index), and indexVersion for the ETag - bouncing the server will change the Last-Mod because a new searcher is opened, but the Etag won&apos;t change becuase the index hasn&apos;t changed.&lt;/p&gt;

&lt;p&gt;here&apos;s what i&apos;m thinking...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;two new options (we can pobably think of better names for these)...
	&lt;ol&gt;
		&lt;li&gt;lastModFrom=&quot;openTime|dirLastMod&quot; ... default is dirLastMod&lt;/li&gt;
		&lt;li&gt;cacheHeaderSeed=&quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;some date format&amp;#93;&lt;/span&gt;&quot; ... default is epoch&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
	&lt;li&gt;headers are commuted as...
	&lt;ul&gt;
		&lt;li&gt;Last-Modified = the max(lastModFrom, cacheHeaderSeed) ... where lastModFrom is computed using the specified value&lt;/li&gt;
		&lt;li&gt;ETag is a hashcode of the indexVersion and cacheHeaderSeed&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;resulting behavior...
	&lt;ul&gt;
		&lt;li&gt;Users who aren&apos;t pick get the default where slaves with identical snapshots will have identical Etags and Last-Mod headers.&lt;/li&gt;
		&lt;li&gt;Changing configs by default won&apos;t immediately change the Etag or Last-Mod header ... if you&apos;ve got an index that changes semi regularly you can just touch the index to get new headers, or you can add the cacheHeaderSeed option with a timestamp value to force new headers on startup.&lt;/li&gt;
		&lt;li&gt;if you are supper paranoid about making sure your headers are always a perfect reflection of reality (even if you rollback your index to an older copy) use lastModFrom=&quot;openTime&quot; and update the  cacheHeaderSeed option every time you change your config ... downside being that in multi-slave setups every machine will generate a different Last-Mod (but the ETags should be the same)&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;...thoughts?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One comment only: change must-revalidate=&quot;&quot; to must-revalidate=&quot;true/false&quot; . For no-store/no-cache as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah, that&apos;s what i was thinking originally, except i wanted to leave out any special knowledge about what the attributes were (ie: know hardcoded list of directive names) .. any XML attribute in the config would automatically becomes a directive in the header value, if it had a value in the config, itwould have a directive value in the header..&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&amp;lt;cacheControl max-age=&lt;span class=&quot;code-quote&quot;&gt;&quot;23&quot;&lt;/span&gt; no-cache=&lt;span class=&quot;code-quote&quot;&gt;&quot;&quot; no-store=&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot; must-revalidate=&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot; &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;=&quot;&lt;/span&gt;Foo&lt;span class=&quot;code-quote&quot;&gt;&quot; asdf=&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot; qwert=&quot;&lt;/span&gt;666&quot; /&amp;gt;
...becomes...
Cache-Control: max-age=&lt;span class=&quot;code-quote&quot;&gt;&quot;23&quot;&lt;/span&gt;, no-cache, must-revalidate, &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;=&lt;span class=&quot;code-quote&quot;&gt;&quot;Foo&quot;&lt;/span&gt;, asdf, qwert=&lt;span class=&quot;code-quote&quot;&gt;&quot;666&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...that way we don&apos;t have to worry about any HTTP extensions, people can put anything they freaking want in their Cache-Control header. What i forgot until today though is that the numeric directives in the Cache-Control header aren&apos;t suppose to be quoted (ie: max-age=23 ... not max-age=&quot;23&quot;)  ... so that won&apos;t work very easily either.&lt;/p&gt;

&lt;p&gt;So then started thinking maybe we use the named list syntax, and let the data type tell us wether or not the value should be quoted (&amp;lt;str&amp;gt;) or not (&amp;lt;int&amp;gt;) ... but that seems awfully verbose for something this simple ... so now i&apos;m wondering if maybe we should just make it be one big string and use a regex to look for max-age so we can set the Expires header as well.&lt;/p&gt;

&lt;p&gt;I&apos;m liking the simple string + regex approach personally.&lt;/p&gt;
</comment>
                            <comment id="12562848" author="tpeuss" created="Sat, 26 Jan 2008 11:56:47 +0000"  >&lt;p&gt;The cacheHeaderSeed is a good idea. It is like the version number on DNS zonefile entries. The downside of such a thing is that you have to change it manually (but Solr users are clever guys &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ). I would see no special meaning in the seed - just a string that we mix with the version number of the index. The user can choose whatever he wants there as long as he changes it when the config changes substantially. Something like &lt;em&gt;cacheHeaderSeed=&quot;20080126123300&quot;&lt;/em&gt; should be as good as &lt;em&gt;cacheHeaderSeed=&quot;version23&quot;&lt;/em&gt;. As we are caching the ETag now we can use an MD5 or SHA1 hash for the Etag as well. We simply throw the cacheHeaderSeed and the index version number into the hashing function and Base64-encode the result of the hash. With that we obfuscate the index version as well for the paranoid ones and always have an ETag of the same size independent of the length of the seed. Additionally the Etag changes completely if only one bit has changed. This makes the &lt;em&gt;equals&lt;/em&gt; check for the Etag a bit faster as well.&lt;/p&gt;

&lt;p&gt;The problems I see with cacheHeaderVersion beeing a timestamp is that you can really break your caching headers if you put a future time stamp in there. This is not allowed by the RFC. Of course we can check for a future time stamp and give a warning and use the current time instead.&lt;/p&gt;

&lt;p&gt;When I remember right XML attributes don&apos;t need a value. So we can do the following:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&amp;lt;cacheControl max-age=&lt;span class=&quot;code-quote&quot;&gt;&quot;23&quot;&lt;/span&gt; no-cache no-store must-revalidate &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;=&lt;span class=&quot;code-quote&quot;&gt;&quot;Foo&quot;&lt;/span&gt; qwert=&lt;span class=&quot;code-quote&quot;&gt;&quot;666&quot;&lt;/span&gt; /&amp;gt;
...becomes...
Cache-Control: max-age=&lt;span class=&quot;code-quote&quot;&gt;&quot;23&quot;&lt;/span&gt;, no-cache, must-revalidate, &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;=&lt;span class=&quot;code-quote&quot;&gt;&quot;Foo&quot;&lt;/span&gt;, asdf, qwert=&lt;span class=&quot;code-quote&quot;&gt;&quot;666&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;But again a very good idea to be flexible here. But the named list syntax might be easier to handle in the code. A regex solution should work as well (but should fail gracefully with a warning logged to the logfile). max-age is the only value that is of interest for the code.&lt;/p&gt;</comment>
                            <comment id="12563315" author="hossman" created="Mon, 28 Jan 2008 22:21:02 +0000"  >&lt;p&gt;If we allow cacheHeaderSeed to be an arbitrary string, and only fold it into the ETag then what mechanism do we use to support the use case of lastModFrom=&quot;dirLastMod&quot; when we eed the Last-Modified header to change because the solrconfig.xml changed?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The problems I see with cacheHeaderVersion beeing a timestamp is that you can really break your caching headers if you put a future time stamp in there. This is not allowed by the RFC. Of course we can check for a future time stamp and give a warning and use the current time instead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, but like you say: that&apos;s a solvable problem by maxing LastMod out with the current system time.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When I remember right XML attributes don&apos;t need a value. So we can do the following:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But we would still have the problem of knowing to output unquoted values for certain directives (max-age, s-maxage, etc...) and quoted values for others.  If we have to hardcoded all the directive names in code, they might as well be separate options.  Taking in a single literal Cache-Control header string and using a regex to pull out the Expires is definitely appealing to me, but ... &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A regex solution should work as well (but should fail gracefully with a warning logged to the logfile)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;...what kind of failure/warning are you worried about?  I&apos;m assuming that the Cache-Control string will be written verbatim, and if it matches &quot;\bmax-age=(\d+)&quot; we&apos;ll also output an Expires; if the regex doesnt&apos; match, we won&apos;t (no warning either way ... it seems perfectly normal for people to have a Cache-Control header without a max-age.&lt;/p&gt;</comment>
                            <comment id="12563896" author="tpeuss" created="Wed, 30 Jan 2008 08:36:37 +0000"  >&lt;p&gt;What about using the index opening time for last-modified and allow an arbitrary string for the cacheHeaderSeed? The opening time is guaranteed to be greater than both index-last-mod and config-last-mod. When you have a cluster of slaves then their last-mods would differ - but does that really hurt? I think no.&lt;/p&gt;

&lt;p&gt;Think of following scenario:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Slave 1 has opentime X&lt;/li&gt;
	&lt;li&gt;Slave 2 has opentime X+2&lt;/li&gt;
	&lt;li&gt;Slave 3 has opentime X+4&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;When you have round-robin load balancing all clients sometime in the future hit Slave 3 and save &lt;em&gt;X+4&lt;/em&gt; as last-mod for the request. When they now issue a request with a conditional header (If-Modified-Since X+4) Solr on Slave 2 and 3 would send a 304 (Not-Modified) as well. When the index changes you would get a suboptimal behavior for some time - but the code would be much easier.&lt;/p&gt;

&lt;p&gt;This would allow us to use an arbitrary string in cacheHeaderSeed for the ETags. To put semantics in cacheHeaderSeed is error prone. I don&apos;t like that.&lt;/p&gt;

&lt;p&gt;I am fine with the regex solution. It is both flexible and easy to code.&lt;/p&gt;</comment>
                            <comment id="12564228" author="hossman" created="Wed, 30 Jan 2008 23:50:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;When you have a cluster of slaves then their last-mods would differ - but does that really hurt? I think no.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The funny thing is: that&apos;s what i originally thought, and then you got me worried about it : )&lt;/p&gt;

&lt;p&gt;I think you are right: but let&apos;s at least give people who want to have Last-Mod headers which are in sync across all slaves an option for basing it on the dir.lastModified.  We&apos;ll be giving them rope to hang themselves with if they change the cacheHeaderSeed because that will change the ETag without changing the Last-Modified, but it will be soft velvety rope that probably won&apos;t hurt since most caches are either going to use the ETag or the Last-Modified &amp;#8211; not both.  (besides: as long as it&apos;s documented well, they can always force a new snapshot when they change the cacheHeaderSeed (Hmmm... &quot;etagSeed&quot; is better now) so that both headers change consistently.&lt;/p&gt;

&lt;p&gt;So to sum up...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;three http caching related options...
	&lt;ol&gt;
		&lt;li&gt;lastModFrom=&quot;openTime|dirLastMod&quot; ... default is openTime&lt;/li&gt;
		&lt;li&gt;etagSeed=&quot;arbitrary string&quot; ... default is some constant (ie: &quot;Solr&quot;)&lt;/li&gt;
		&lt;li&gt;cacheControlHeader=&quot;arbitrary string&quot; ... default is NULL&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
	&lt;li&gt;headers are commuted as...
	&lt;ul&gt;
		&lt;li&gt;Last-Modified = $lastModFrom&lt;/li&gt;
		&lt;li&gt;ETag is a hashcode of the indexVersion and $etagSeed&lt;/li&gt;
		&lt;li&gt;Cache-Control is $cacheControlHeader if set (otherwise no Cache-Control header)&lt;/li&gt;
		&lt;li&gt;Expires is $now+$maxAge if $maxAge can be found in $cacheControlHeader (otherwise no Expires header)&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;resulting behavior...
	&lt;ul&gt;
		&lt;li&gt;Default behavior (lastModFrom=openTime)...
		&lt;ul&gt;
			&lt;li&gt;Slaves with identical snapshots will have identical Etags and Last-Mod headers that may not be exact but should tend to be close, so only a little extra load around the time of a new snapshot.&lt;/li&gt;
			&lt;li&gt;If you rollback an index to a previous version, you will get a new Last-Mod and ETag headers.&lt;/li&gt;
			&lt;li&gt;Changing configs and restarting core won&apos;t cause Etag to change, but Last-Mod will because of newly opened Searcher &amp;#8211; If you&apos;ve got an index that changes semi regularly then the ETag will get updated as soon as a new version gets opened, or you can add the etagSeed option to force new ETag on startup.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;for people who really want Last-Mod to always be in sync across all slaves (lastModFrom=dirLastMod)...
		&lt;ul&gt;
			&lt;li&gt;Last-Mod will only ever change when index changes.&lt;/li&gt;
			&lt;li&gt;You probably won&apos;t care about ETags, but it will stay consistent until index changes.&lt;/li&gt;
			&lt;li&gt;If you change configs, and you do care about ETag, you could update the etagSeed &amp;#8211; but there&apos;s not much point since you&apos;ll also need to generate a new snapshot on your master to force a new Last-Mod header to be updated.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;does that sound good?&lt;/p&gt;

&lt;p&gt;(fingers crossed i can bang this out on 2007-01-31 between 13:00-18:00 America/Los_Angeles ... unless you want to beat me to it Thomas : ) )&lt;/p&gt;</comment>
                            <comment id="12564317" author="tpeuss" created="Thu, 31 Jan 2008 06:25:47 +0000"  >&lt;p&gt;That sounds like a plan. I love peer-reviews... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12564585" author="hossman" created="Fri, 1 Feb 2008 02:04:48 +0000"  >&lt;p&gt;(NOTE: in my last update where I listed the new options, I forgot about the &quot;never304&quot; option .. obviously that&apos;s still important).&lt;/p&gt;

&lt;p&gt;Before I made any changes, I attempted to merge the previous HTTPCaching.patch with CacheUnitTest.patch, and ran into test failure in NoCacheHeaderTest ... looking at it, i&apos;m not sure what it&apos;s expectation was/is (seemed to expect a Cache-Control header even when no caching options were specified in the config) so i just left it alone for now.&lt;/p&gt;

&lt;p&gt;I have a new unified patch (code+tests) that does everything we talked about, but there&apos;s still some thing that need resolved...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;the test classes still need some work, both in terms of the current failure mentioned above, and to cover more permutations of options.  When we&apos;re all said and done, we&apos;ll probably want at least 3 separate sets of test/configs:
	&lt;ol&gt;
		&lt;li&gt;default, no &amp;lt;httpCaching&amp;gt; section in config at all ... should generate Last-Mod and Etag headers and do validation, stoping/starting port should make Last-Mod change but not ETag.&lt;/li&gt;
		&lt;li&gt;never304=&quot;false&quot;, lastModFrom=&quot;dirLastMod&quot; ... should generate Last-Mod and Etag headers and do validation, no headers should change if we stop/start the port.&lt;/li&gt;
		&lt;li&gt;never304=&quot;true&quot; ... no Last-Mod of ETag headers, no 304 even if we send crazy old If-Modified-Since&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
	&lt;li&gt;there&apos;s also probably some refactoring that can still be done in the tests (i noticed some duplicate code that can be moved up into the Base class)&lt;/li&gt;
	&lt;li&gt;it occurred to me while adding the etagSeed that right now the etag caching is a singleton, we&apos;ll need to make this core-specific (using a WeakHashMap i guess?  i&apos;m not fond of that approach, but these are really tiny pieces of info we are caching)&lt;/li&gt;
	&lt;li&gt;calcLastModified and calcEtag currently assume they can get requestDispatcher/httpCaching config options from SolrConfig ... but this need to be reconciled with &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-350&quot; title=&quot;Manage Multiple SolrCores&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-350&quot;&gt;&lt;del&gt;SOLR-350&lt;/del&gt;&lt;/a&gt; where there is a plan to move all requestDispatcher configs to multicore.xml (but i&apos;ve pointed out in that issue i&apos;m not sure if that is necessary or makes sense.)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Thomas: Can you take a look at the current test failure and help me understand why it&apos;s expecting a Cache-Control header?  (if you want to take a stab at expanding the test case permutations too that would be cool)&lt;/p&gt;

&lt;p&gt;And of course, Thomas (and everyone else), please try out the code changes in the patch and the comments in the example solrconfig.xml and let me know if this looks good.&lt;/p&gt;</comment>
                            <comment id="12564690" author="tpeuss" created="Fri, 1 Feb 2008 09:08:38 +0000"  >&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;the test classes still need some work, both in terms of the current failure mentioned above, and to cover more permutations of options. When we&apos;re all said and done, we&apos;ll probably want at least 3 separate sets of test/configs:&lt;br/&gt;
         1. default, no &amp;lt;httpCaching&amp;gt; section in config at all ... should generate Last-Mod and Etag headers and do validation, stoping/starting port should make Last-Mod change but not ETag.&lt;br/&gt;
         2. never304=&quot;false&quot;, lastModFrom=&quot;dirLastMod&quot; ... should generate Last-Mod and Etag headers and do validation, no headers should change if we stop/start the port.&lt;br/&gt;
         3. never304=&quot;true&quot; ... no Last-Mod of ETag headers, no 304 even if we send crazy old If-Modified-Since&lt;/li&gt;
	&lt;li&gt;there&apos;s also probably some refactoring that can still be done in the tests (i noticed some duplicate code that can be moved up into the Base class)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;I take care of the tests.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;it occurred to me while adding the etagSeed that right now the etag caching is a singleton, we&apos;ll need to make this core-specific (using a WeakHashMap i guess? i&apos;m not fond of that approach, but these are really tiny pieces of info we are caching)&lt;/li&gt;
	&lt;li&gt;calcLastModified and calcEtag currently assume they can get requestDispatcher/httpCaching config options from SolrConfig ... but this need to be reconciled with &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-350&quot; title=&quot;Manage Multiple SolrCores&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-350&quot;&gt;&lt;del&gt;SOLR-350&lt;/del&gt;&lt;/a&gt; where there is a plan to move all requestDispatcher configs to multicore.xml (but i&apos;ve pointed out in that issue i&apos;m not sure if that is necessary or makes sense.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;When I remember right every core has its own classloader. Then every core has its own set of static fields. This is why real singletons are not that easy to do in Java.&lt;/p&gt;</comment>
                            <comment id="12564769" author="tpeuss" created="Fri, 1 Feb 2008 13:59:15 +0000"  >&lt;p&gt;Fixing the test cases is not that easy. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; There is some caching going on somewhere inside Solr that prevents the second (solrconfig-nocache.xml) from being loaded. Well - it is loaded according to the logfile but Solr still uses the configured parameters from solrconfig.xml.&lt;/p&gt;

&lt;p&gt;So your worries about the caching are sound. The problems appear only at another part of Solr than expected...&lt;/p&gt;

&lt;p&gt;I played around with some ClassLoader tricks but that has not helped until now. A solution for the problem would be running this tests with extra processes.&lt;/p&gt;</comment>
                            <comment id="12564868" author="hossman" created="Fri, 1 Feb 2008 18:45:09 +0000"  >&lt;p&gt;Thomas: each core has it&apos;s own classloader for &lt;b&gt;plugins&lt;/b&gt; defined in the lib directory of the solr home &amp;#8211; but the &quot;main&quot; Solr code (in the solr.war) is loaded by the webapp context classloader &amp;#8211; so static variables in &quot;core&quot; solr code really are singletons.&lt;/p&gt;

&lt;p&gt;Would that explain the problems you are seeing in the test?  does it relate to the etagCache?  I thought the problem was that even in the &quot;NoCache&quot; test it as expecting to see a Cache-Control header even though solrconfig-nocache.xml doesn&apos;t have one configured?&lt;/p&gt;

&lt;p&gt;(We have several tests that load cores with different configs that currently work, and we&apos;ve never really noticed any problems like this before ... so i&apos;m hesitant to assume it&apos;s unrelated to the patch)&lt;/p&gt;</comment>
                            <comment id="12565081" author="tpeuss" created="Sat, 2 Feb 2008 16:09:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;Thomas: each core has it&apos;s own classloader for plugins defined in the lib directory of the solr home - but the &quot;main&quot; Solr code (in the solr.war) is loaded by the webapp context classloader - so static variables in &quot;core&quot; solr code really are singletons.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK. Then we need a &quot;per-core&quot; cache. A weak-hashmap would be sufficient to achieve this. You can use the core-name as key for example.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Would that explain the problems you are seeing in the test? does it relate to the etagCache? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am pretty sure that it does not relate to the etagCache. I think it is some static variable stuff in the SolrConfig parts. I try to track that down tonight when I have put my daughter to bed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I thought the problem was that even in the &quot;NoCache&quot; test it as expecting to see a Cache-Control header even though solrconfig-nocache.xml doesn&apos;t have one configured?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This tests are wrong. You are completely right. The current code should fail in the &quot;nocache&quot; scenario. Currently it does not because of the problem I have described.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(We have several tests that load cores with different configs that currently work, and we&apos;ve never really noticed any problems like this before ... so i&apos;m hesitant to assume it&apos;s unrelated to the patch)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But only one of them (the SolrJ tests) loads the Solr code through Jetty (so it might be a Jetty related problem as well).... All other tests use the Solr code directly.&lt;/p&gt;</comment>
                            <comment id="12565119" author="tpeuss" created="Sat, 2 Feb 2008 21:54:59 +0000"  >&lt;p&gt;The unit tests work now as expected. The problem described earlier occurred because of different behavior of the normal unit tests and the ones run with Jetty.&lt;/p&gt;

&lt;p&gt;Please be aware of the changes in&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;SolrDispatchFilter.java: the &lt;em&gt;init&lt;/em&gt; method has changed&lt;/li&gt;
	&lt;li&gt;JettySolrRunner.java: additional constructor&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So we can now go ahead and get this into the codebase... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12566865" author="funtick" created="Fri, 8 Feb 2008 00:19:50 +0000"  >&lt;p&gt;This is an alternative to initially proposed HTTP-caching, and it is extremely easy to implement:&lt;/p&gt;

&lt;p&gt;Simply add request parameter http.header=&quot;If-Modified-Since: Tue, 05 Feb 2008 03:50:00 GMT&quot; (better is to use other names, do not use http.header parameter; see below...)&lt;br/&gt;
Let SOLR to respond via standard XML message &quot;Not Modified&quot;, and avoid using 304 response code&lt;/p&gt;

&lt;p&gt;What do you think? We can even encapsulate MAX-AGE, EXPIRES, and other useful stuff (like as additional UPDATE-FREQUENCY: 30 days) into XML, and all those staff can depend on internal Lucene statistics (and not on hard-coded values in SOLR-CONFIG).&lt;/p&gt;

&lt;p&gt;We should not use HTTP-Protocol response headers such as 304/400/500 to describe SOLR&apos;s external API.&lt;/p&gt;

&lt;p&gt;Sample: Apache HTTPD front-end, Tomcat (Struts-based middleware), and SOLR (backend). With your initial proposal different users will get different data. Why? Multithreading at Apache HTTPD. At least, there are some possible fluctuations, cache is not shared in some configurations, etc. Each thread may get own copy of &quot;last-modified&quot;, and different users will see different data. It won&apos;t work for most business cases.&lt;/p&gt;

&lt;p&gt;Without HTTP:&lt;br/&gt;
&quot;is modified?&quot; &lt;br/&gt;
&quot;when is next update of BOOKS category?&quot;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;all caches around the world have the same timestamp for BOOKS category&lt;br/&gt;
... ... ...&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12566869" author="funtick" created="Fri, 8 Feb 2008 00:43:18 +0000"  >&lt;p&gt;Of course ETag etc. will synchronize caches; but anyway why do we need such features of HTTP specs?&lt;/p&gt;

&lt;p&gt;HTTP Caching is widely used to cache responces from HTTP Servers, content (HTML, PDF, JPG, EXE) can be cached at coprorate proxy, and locally in Internet Explorer&apos;s internal cache. That is the main idea.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Are SOLR-XML responses roving the world and reaching internal cache of Mozilla Firefox, or corporate caching proxies?&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;-Not. &lt;/p&gt;

&lt;p&gt;Clients of SOLR: Middleware. Do they need to act as &quot;caching-proxy&quot;? May be.... Just another use case: middleware publishes &quot;current time&quot; &amp;amp; &quot;weather&quot; together with response from SOLR; middleware wants to cache responses from SOLR and do not rely on requests coming from end users because of frequent weather changes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;   - it depends on implementation of such middleware, for sure, it will try to cache SolrDocument objects instead of pure XML, and such kind of caching is not HTTP-related.&lt;/p&gt;


</comment>
                            <comment id="12566951" author="tpeuss" created="Fri, 8 Feb 2008 08:25:42 +0000"  >&lt;p&gt;Think of two scenarios:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;An AJAXified browser client sending requests to Solr. Caching of unchanged data in the client and corporate caching proxies speeds up things.&lt;/li&gt;
	&lt;li&gt;A cluster of Solr servers behind a loadbalancer with caching functionality. Middleware sends requests to Solr through the loadbalancer. Repeating requests to unchanged data are responded directly from LB cache without putting load to the Solr servers. This is for example our scenario.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Our code works fine with BlueCoat Webcache, Apache HTTPD proxy cache, Squid proxy cache and many other solutions &lt;em&gt;because&lt;/em&gt; we are following standards here. So I don&apos;t really get the point of your comment.&lt;/p&gt;

&lt;p&gt;Besides that you can completely disable this HTTP header stuff in solrconfig.xml if you don&apos;t want it.&lt;/p&gt;</comment>
                            <comment id="12567064" author="funtick" created="Fri, 8 Feb 2008 15:16:37 +0000"  >&lt;p&gt;I agree.&lt;br/&gt;
Caching Load Balancer between SOLR and APP Servers is excellent idea, and it can be &quot;black box&quot; without any knowlege about SOLR API.&lt;br/&gt;
AJAX can use internal cache of web browser; FLEX probably too...&lt;br/&gt;
Question: do we need caching of static (non-changed) content from SOLR such as &quot;400: Query parsing error&quot;?.. &lt;/p&gt;
</comment>
                            <comment id="12567067" author="funtick" created="Fri, 8 Feb 2008 15:30:36 +0000"  >&lt;p&gt;In my configuration I do not need SOLR caching at all; but I use HTTP caching more effectively.&lt;/p&gt;

&lt;p&gt;HTTPD memory- and disk- cache is used between Client and Middleware. No any caching between Middleware and SOLR. Middleware responds to HTTPD with &quot;304&quot; if necessary, with correct Last-Modified etc., and request do not reach SOLR. This caching configuration works fine with AJAX too, without SOLR&apos;s caching headers.&lt;/p&gt;

&lt;p&gt;I&apos;ve seen unnecessary extra-work with this implementation... taking long time... and tried to point on some meanings of response codes (for Web).&lt;/p&gt;</comment>
                            <comment id="12567068" author="wunder" created="Fri, 8 Feb 2008 15:32:14 +0000"  >&lt;p&gt;Two reasons to do HTTP caching for Solr: First, Solr is HTTP and needs to implement that correctly. Second, caches are much harder to implement and test than the cache information in HTTP. HTTP caches already exist and are well tested, so the implementation cost is zero and deployment is very easy.&lt;/p&gt;

&lt;p&gt;The HTTP spec already covers which responses should be cached.  A 400 response may only be cached if it includes explicit cache control headers which allow that. See RFC 2616.&lt;/p&gt;

&lt;p&gt;We are using a caching load balancer and caching in Apache front ends to Tomcat. We see an increase of more than 2X in the capacity of our search farm.&lt;/p&gt;

&lt;p&gt;I would recommend against Solr-specific cache information in the XML part of the responses. Distributed caching is extremely difficult to get right. Around 25% of the HTTP 1.1 spec is devoted to caching and there are still grey areas.&lt;/p&gt;</comment>
                            <comment id="12567072" author="funtick" created="Fri, 8 Feb 2008 15:52:27 +0000"  >&lt;p&gt;Regarding HTTP-Caching-Load-Balancer between SOLR and Middleware:&lt;br/&gt;
You need to deal with additional internal http-cache at middleware. In most cases Middleware generates content from different sources and can&apos;t reroute &quot;If-Modified-Since&quot; request to SOLR without internal caching. For instance, if you are using SOLRJ, you have to implement &lt;b&gt;additional&lt;/b&gt; cache for SolrDocument... &lt;/p&gt;</comment>
                            <comment id="12567077" author="funtick" created="Fri, 8 Feb 2008 16:01:57 +0000"  >&lt;p&gt;Thomas, Walter,&lt;/p&gt;

&lt;p&gt;Finally I agree, thanks!&lt;/p&gt;

&lt;p&gt;Middleware should not send/reroute &quot;If-Modified-Since&quot;, and should not implement internal cache (in provided by me &quot;contr&quot;-sample): with caching enabled, it will simply retrieve cached content.&lt;/p&gt;

&lt;p&gt;I do not agree with 400, it is place for DoS attacks. &quot;Query parsing error&quot; should be 200 with caching response codes. Of course, I know RFC 2616. &lt;/p&gt;</comment>
                            <comment id="12567081" author="funtick" created="Fri, 8 Feb 2008 16:24:40 +0000"  >&lt;p&gt;Fortunately, we are not using 404 trying to retrieve removed document... In initial design (I believe) SOLR developers simply wrapped all exceptions into 400, and &quot;empty result set&quot; is not an exception.&lt;/p&gt;</comment>
                            <comment id="12569123" author="hossman" created="Thu, 14 Feb 2008 22:43:48 +0000"  >&lt;p&gt;checkpoint: unification of the most recent HTTPCaching.patch and Thomas&apos;s last CacheUnitTest.patch&lt;/p&gt;

&lt;p&gt;(note: Thomas, if we have any more iterations of changes to the patches related to testing, it would probably be better to just keep generating  single unified patch containing everything ... having multiple patches attached to an issue is fine as long s they don&apos;t overlap, but it gets really difficult to apply multiple patches when they both add (or modify) the same files)&lt;/p&gt;

&lt;p&gt;next step is some MultiCore aware stuff i mentioned before .. working on that now.&lt;/p&gt;</comment>
                            <comment id="12569156" author="hossman" created="Fri, 15 Feb 2008 01:19:09 +0000"  >&lt;p&gt;Changes made in this version...&lt;/p&gt;

&lt;p&gt;1) refactored etag cache to be core specific.&lt;/p&gt;

&lt;p&gt;2) change etag calculation so that (common case) minor incriments in openTime/lastModTime affect the earlier chars of the etag for faster equals comparisons (using Long.reverse)&lt;/p&gt;

&lt;p&gt;3) refactor config reading into SolrConfig so they don&apos;t happen on every request (the max-age regex was my main concern)&lt;/p&gt;

&lt;p&gt;4) refactored a bit more common code into the abstract test base&lt;/p&gt;

&lt;p&gt;Comments welcome (particularly since the multicore weakref stuff isn&apos;t something I&apos;ve given a huge amount of thought to before).&lt;/p&gt;

&lt;p&gt;I haven&apos;t done enough manual testing to be satisfied that it&apos;s working 100%, but i think everything works as desired.  (I would still like to see more unit tests of the different config variations, but it&apos;s not a huge problem or anything ... we&apos;ve got the 80/20 rule going for us, there&apos;s probably other areas of the code that are more deserving of additional tests)&lt;/p&gt;
</comment>
                            <comment id="12571221" author="hossman" created="Thu, 21 Feb 2008 22:55:16 +0000"  >&lt;p&gt;Committed revision 630037.&lt;/p&gt;

&lt;p&gt;And I updated the SolrConfigXml wiki page to mention the new config options.&lt;/p&gt;

&lt;p&gt;Thank you very much for all your hard work on this Thomas!&lt;/p&gt;</comment>
                            <comment id="12579728" author="shalinmangar" created="Tue, 18 Mar 2008 05:28:44 +0000"  >&lt;p&gt;It seems there is no way to disable caching on a per-handler basis. I&apos;ve read through the comments on this issue but I&apos;m still not convinced as to why we need to enable HTTP Caching by default. The way I see it is that using a HTTP Caching Proxy in front of SOLR is a very rare use case and people using it in their deployments can always go and enable caching in solrconfig. The downside of enabling this by default is that there is no way right now to disable it on a per-handler basis and even if there was a way, everyone would have to explicitly do it in their configuration and is something that we would have to educate users unnecessarily.&lt;/p&gt;

&lt;p&gt;Our use case is the &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-469&quot; title=&quot;Data Import RequestHandler&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-469&quot;&gt;&lt;del&gt;SOLR-469&lt;/del&gt;&lt;/a&gt; DataImportHandler, which should not have responses cached at any time. But there is no way for me to do it currently. I&apos;m sure there will be other use cases too e.g. &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-502&quot; title=&quot;Add search time out support&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-502&quot;&gt;&lt;del&gt;SOLR-502&lt;/del&gt;&lt;/a&gt; for which partial results are also cached right now.&lt;/p&gt;

&lt;p&gt;I appreciate the work you all have put into this issue and all I&apos;m trying to say is that a feature used very rarely should not be enabled by default. I&apos;d like to vote to go back to Solr 1.2 compatibility by default.&lt;/p&gt;</comment>
                            <comment id="12579761" author="tpeuss" created="Tue, 18 Mar 2008 08:23:29 +0000"  >&lt;blockquote&gt;
&lt;p&gt;It seems there is no way to disable caching on a per-handler basis.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;True. And we should work to a point where we can configure this per handler.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I&apos;ve read through the comments on this issue but I&apos;m still not convinced as to why we need to enable HTTP Caching by default. The way I see it is that using a HTTP Caching Proxy in front of SOLR is a very rare use case and people using it in their deployments can always go and enable caching in solrconfig. The downside of enabling this by default is that there is no way right now to disable it on a per-handler basis and even if there was a way, everyone would have to explicitly do it in their configuration and is something that we would have to educate users unnecessarily.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I have no problem with disabling caching headers by default. We might need a functionality where some back-end module can veto on emitting cache headers or can tell the cache header code to emit cache headers that avoid caching of the response. This is not too hard to implement. I have a look into this tonight. We can simply add two methods to the SolrQueryResponse class (like &lt;em&gt;void setAvoidHTTPCaching(boolean)&lt;/em&gt; and &lt;em&gt;boolean isAvoidHTTPCaching()&lt;/em&gt; - the default for the value would be &lt;em&gt;false&lt;/em&gt;). The update request handlers should set this to &lt;em&gt;true&lt;/em&gt; all the time. The partial response stuff can set this to &lt;em&gt;true&lt;/em&gt; as well.&lt;/p&gt;

&lt;p&gt;Another way of getting around emitting cache headers on a &lt;em&gt;per request&lt;/em&gt; basis is to use POST requests. For POST requests we do not emit cache related headers or  &lt;em&gt;Not Modified&lt;/em&gt; responses completely following the W3C specs here.&lt;/p&gt;

&lt;p&gt;And while thinking about that I realize that we need to extend the tests as well that we make sure that we never emit cache related headers in case of errors.&lt;/p&gt;

&lt;p&gt;And still you can already disable caching header related functionality by adding&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   &amp;lt;httpCaching never304=&quot;true&quot;&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;to your solrconfig.xml.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I appreciate the work you all have put into this issue and all I&apos;m trying to say is that a feature used very rarely should not be enabled by default. I&apos;d like to vote to go back to Solr 1.2 compatibility by default.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In my world caching proxies and loadbalancers are the default. This might influence my view on that stuff. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12579767" author="noble.paul" created="Tue, 18 Mar 2008 08:53:09 +0000"  >&lt;p&gt;If we look at the problem that this feature is trying to solve, only the &apos;select&apos; handler should need this . So making it &apos;enabled&apos; by default for all handlers does not serve any purpose.&lt;/p&gt;

&lt;p&gt;This is indeed a useful feature for those who use a caching proxy in front. But those users are educated enough to configure it in solrconfig.xml if they need it .( BTW , We use Solr extensively and we have no caching in front of Solr )&lt;/p&gt;


&lt;p&gt;In an ideal situation the &apos;select&apos; handler must have it enabled by default. &lt;br/&gt;
For all other handlers keep it off by default and provide an option to enable it (if needed)&lt;/p&gt;
</comment>
                            <comment id="12579808" author="tpeuss" created="Tue, 18 Mar 2008 11:23:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;This is indeed a useful feature for those who use a caching proxy in front. But those users are educated enough to configure it in solrconfig.xml if they need it .( BTW , We use Solr extensively and we have no caching in front of Solr )&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;True. We should disable the cache header stuff by default. Please open a new JIRA issue for that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In an ideal situation the &apos;select&apos; handler must have it enabled by default. For all other handlers keep it off by default and provide an option to enable it (if needed)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Exactly. We need to get a bit more specific here. I have opened &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-505&quot; title=&quot;Give RequestHandlers the possiblity to suppress the generation of HTTP caching headers&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-505&quot;&gt;&lt;del&gt;SOLR-505&lt;/del&gt;&lt;/a&gt; for that.&lt;/p&gt;</comment>
                            <comment id="12579812" author="shalinmangar" created="Tue, 18 Mar 2008 11:54:31 +0000"  >&lt;p&gt;I&apos;ve opened &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-506&quot; title=&quot;Enabling HTTP Cache headers should be configurable on a per-handler basis&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-506&quot;&gt;&lt;del&gt;SOLR-506&lt;/del&gt;&lt;/a&gt; to have this feature configurable on a per-handler basis.&lt;/p&gt;

&lt;p&gt;Thanks Thomas for starting &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-505&quot; title=&quot;Give RequestHandlers the possiblity to suppress the generation of HTTP caching headers&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-505&quot;&gt;&lt;del&gt;SOLR-505&lt;/del&gt;&lt;/a&gt;, together these two issues should lead to an &apos;ideal&apos; solution &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12579953" author="hossman" created="Tue, 18 Mar 2008 17:54:05 +0000"  >&lt;p&gt;For the record: most of this discussion should have happened on the solr-dev list, not in the issue comments ... but i would like to address some points, so I&apos;ll do it here since this is where the discussion is.&lt;/p&gt;

&lt;p&gt;1) It&apos;s true, there is no way to configure caching on a per request handler basis &amp;#8211; if you look at the history of the issue we looked into that but because of the necessary API changes we scaled back the scope of the patch &amp;#8211; it can be done, it just needs more thought into how to do it and people interested in working on it.&lt;/p&gt;

&lt;p&gt;2) there is no doubt in my mind that having the cache awareness code on by default is the right approach moving forward.  These options don&apos;t cause Solr do do any caching, or to force any external caches to cache the pages &amp;#8211; they only result in Solr behaving correctly according to the HTTP spec sections relating to cache headers:  &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;b&gt;if&lt;/b&gt; a request is made to Solr via an HTTP cache that cache will receive headers it can use to decide if/how-long to cache the response&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;if&lt;/b&gt; Solr receives a request with cache validation information then it responds with a 304&lt;br/&gt;
if you don&apos;t want that behavior then either don&apos;t access Solr via a cache, or explicitly set the &amp;lt;httpCaching never304=&quot;true&quot;&amp;gt; option; but the default behavior for people who are upgrading from 1.2 should be for Solr to emit Correct headers and to respect validation requests.  Requiring Solr users to explicitly turn on an option to get Solr to emit correct Caching headers would be like requiring them to explicitly set an option to get well formed XML instead of invalid XML &amp;#8211; the default should be the one that behaves the most correctly.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I admit however: this is a notable enough change that it should be mentioned in the &quot;Upgrading from 1.2&quot; section of CHANGES.txt &amp;#8211; I will add that.&lt;/p&gt;

&lt;p&gt;3) if other pending patches attached to other issues have poor behavior as a result of the caching code, the appropriate place to discuss that is in those issue &amp;#8211; the solution may be to mark those issues dependent on a new issue to add the API hooks for request handlers to suppress caching (that&apos;s a good idea in general) but it&apos;s also possible that there are better/safer/more-logical solutions specific to those patches ... if the DataImportHandler is having problems because the caching code, i&apos;m guessing it&apos;s because people use it to trigger updates using an HTTP GET &amp;#8211; that violates the semantics of GET and making work arounds in the the HttpCaching code to allow for that is a bad idea.&lt;/p&gt;

&lt;p&gt;4) saying only the &quot;/select&quot; handler should get it&apos;s responses cached is missleading &amp;#8211; under Solr 1.3 there won&apos;t be anything special about /select ... any handler name can be used for queries, and any handler name can be used for updates ... if you are issuing a request that modifies the index, you should be sending a POST and no caching headers (or validation) will be done by Solr regardless of configuration.&lt;/p&gt;

&lt;p&gt;As I said, discussion about the general topic of HTTP Caching, Solr, and what the defaults should be should really happen on the solr-dev list ... if there are any further comments let&apos;s please conduct them there and then open/update whatever issues we need to once a consensus has been reached.&lt;/p&gt;</comment>
                            <comment id="12585557" author="waltersbox" created="Fri, 4 Apr 2008 15:44:44 +0100"  >&lt;p&gt;Just noticed a small (and functionally irrelevant) typo in solrconfig.xml of the example dir:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
    &amp;lt;!-- Set HTTP caching related parameters (for proxy caches and clients).
          
         To get the behaviour of Solr 1.2 (ie: no caching related headers)
         use the never304=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; option and do not specify a value for
         &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;cacheControl&amp;gt;&lt;/span&gt;
    --&amp;gt;
    &lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- &amp;lt;httpCaching never304=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;look at the last line, it should be&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
    &lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- &amp;lt;httpCaching never304=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt; --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;otherwise who uncomment that will get an exception&lt;/p&gt;</comment>
                            <comment id="12586970" author="hossman" created="Tue, 8 Apr 2008 22:34:14 +0100"  >&lt;blockquote&gt;&lt;p&gt;Just noticed a small (and functionally irrelevant) typo in solrconfig.xml of the example dir:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;that was intentional actually ... if you uncomment that line, you have to comment out the line below it which is an open &amp;lt;httpCaching&amp;gt; tag ... the closing tag is much farther down after the comments and the commented out nested &amp;lt;cacheControl&amp;gt; block.  i figured it would be more obvious for people to deal with just those two lines then to have that never304=&quot;true&quot; example be a self closing tag and make people scroll down to find the other close tag to get rid of it.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12391733">SOLR-505</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12391735">SOLR-506</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12374617" name="CacheUnitTest.patch" size="40686" author="tpeuss" created="Sat, 2 Feb 2008 21:54:59 +0000"/>
                            <attachment id="12374035" name="CacheUnitTest.patch" size="32874" author="tpeuss" created="Fri, 25 Jan 2008 13:13:21 +0000"/>
                            <attachment id="12375648" name="HTTPCaching.patch" size="57691" author="hossman" created="Fri, 15 Feb 2008 01:19:09 +0000"/>
                            <attachment id="12375637" name="HTTPCaching.patch" size="54292" author="hossman" created="Thu, 14 Feb 2008 22:43:48 +0000"/>
                            <attachment id="12374519" name="HTTPCaching.patch" size="54011" author="hossman" created="Fri, 1 Feb 2008 02:04:48 +0000"/>
                            <attachment id="12373995" name="HTTPCaching.patch" size="30807" author="hossman" created="Fri, 25 Jan 2008 00:53:18 +0000"/>
                            <attachment id="12373901" name="HTTPCaching.patch" size="29515" author="hossman" created="Thu, 24 Jan 2008 02:32:40 +0000"/>
                            <attachment id="12373879" name="HTTPCaching.patch" size="34329" author="hossman" created="Wed, 23 Jan 2008 22:28:59 +0000"/>
                            <attachment id="12372630" name="HTTPCaching.patch" size="33623" author="tpeuss" created="Mon, 7 Jan 2008 15:45:29 +0000"/>
                            <attachment id="12372074" name="HTTPCaching.patch" size="32052" author="tpeuss" created="Fri, 21 Dec 2007 11:15:08 +0000"/>
                            <attachment id="12372073" name="HTTPCaching.patch" size="32015" author="tpeuss" created="Fri, 21 Dec 2007 10:01:33 +0000"/>
                            <attachment id="12371935" name="HTTPCaching.patch" size="31017" author="tpeuss" created="Wed, 19 Dec 2007 09:11:17 +0000"/>
                            <attachment id="12371013" name="HTTPCaching.patch" size="38901" author="tpeuss" created="Wed, 5 Dec 2007 09:39:31 +0000"/>
                            <attachment id="12370925" name="HTTPCaching.patch" size="38732" author="tpeuss" created="Tue, 4 Dec 2007 08:57:30 +0000"/>
                            <attachment id="12368195" name="HTTPCaching.patch" size="38512" author="tpeuss" created="Tue, 23 Oct 2007 08:19:26 +0100"/>
                            <attachment id="12368016" name="HTTPCaching.patch" size="38527" author="tpeuss" created="Fri, 19 Oct 2007 15:04:51 +0100"/>
                            <attachment id="12367877" name="HTTPCaching.patch" size="22582" author="tpeuss" created="Wed, 17 Oct 2007 15:29:09 +0100"/>
                            <attachment id="12366453" name="HTTPCaching.patch" size="19584" author="tpeuss" created="Mon, 24 Sep 2007 11:24:01 +0100"/>
                            <attachment id="12366405" name="HTTPCaching.patch" size="9408" author="tpeuss" created="Sat, 22 Sep 2007 15:54:50 +0100"/>
                            <attachment id="12366400" name="HTTPCaching.patch" size="7503" author="tpeuss" created="Sat, 22 Sep 2007 09:35:27 +0100"/>
                            <attachment id="12365990" name="HTTPCaching.patch" size="7416" author="tpeuss" created="Mon, 17 Sep 2007 10:10:53 +0100"/>
                            <attachment id="12365857" name="HTTPCaching.patch" size="6717" author="tpeuss" created="Fri, 14 Sep 2007 13:16:57 +0100"/>
                            <attachment id="12365820" name="HTTPCaching.patch" size="5982" author="tpeuss" created="Fri, 14 Sep 2007 09:04:16 +0100"/>
                            <attachment id="12365814" name="HTTPCaching.patch" size="7306" author="tpeuss" created="Fri, 14 Sep 2007 08:41:07 +0100"/>
                            <attachment id="12365481" name="HTTPCaching.patch" size="4811" author="tpeuss" created="Mon, 10 Sep 2007 15:14:26 +0100"/>
                            <attachment id="12365480" name="HTTPCaching.patch" size="3919" author="tpeuss" created="Mon, 10 Sep 2007 14:58:12 +0100"/>
                            <attachment id="12365470" name="HTTPCaching.patch" size="2686" author="tpeuss" created="Mon, 10 Sep 2007 12:35:37 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 10 Sep 2007 11:35:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7456</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxt8f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21055</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>