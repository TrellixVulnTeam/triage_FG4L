<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:24:27 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-269/SOLR-269.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-269] UpdateRequestProcessorFactory - process requests before submitting them</title>
                <link>https://issues.apache.org/jira/browse/SOLR-269</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;A simple UpdateRequestProcessor was added to a bloated &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-133&quot; title=&quot;change XmlUpdateRequestHandler to use StAX instead of XPP&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-133&quot;&gt;&lt;del&gt;SOLR-133&lt;/del&gt;&lt;/a&gt; commit. &lt;/p&gt;

&lt;p&gt;An UpdateRequestProcessor lets clients plug in logic after a document has been parsed and before it has been &apos;updated&apos; with the index.  This is a good place to add custom logic for:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;transforming the document fields&lt;/li&gt;
	&lt;li&gt;fine grained authorization (can user X updated document Y?)&lt;/li&gt;
	&lt;li&gt;allow update, but not delete (by query?)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;   &amp;lt;requestHandler name=&quot;/update&quot; class=&quot;solr.StaxUpdateRequestHandler&quot; &amp;gt;&lt;br/&gt;
     &amp;lt;str name=&quot;update.processor.class&quot;&amp;gt;org.apache.solr.handler.UpdateRequestProcessor&amp;lt;/str&amp;gt;&lt;br/&gt;
     &amp;lt;lst name=&quot;update.processor.args&quot;&amp;gt;&lt;br/&gt;
      ... (optionally pass in arguments to the factory init method) ...&lt;br/&gt;
     &amp;lt;/lst&amp;gt; &lt;br/&gt;
   &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;http://www.nabble.com/Re%3A-svn-commit%3A-r547495---in--lucene-solr-trunk%3A-example-solr-conf-solrconfig.xml-src-java-org-apache-solr-handler-StaxUpdateRequestHandler.java-src-java-org-apache-solr-handler-UpdateRequestProcessor.jav-tf3950072.html#a11206583&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Re%3A-svn-commit%3A-r547495---in--lucene-solr-trunk%3A-example-solr-conf-solrconfig.xml-src-java-org-apache-solr-handler-StaxUpdateRequestHandler.java-src-java-org-apache-solr-handler-UpdateRequestProcessor.jav-tf3950072.html#a11206583&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12372155">SOLR-269</key>
            <summary>UpdateRequestProcessorFactory - process requests before submitting them</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ryantxu">Ryan McKinley</assignee>
                                    <reporter username="ryantxu">Ryan McKinley</reporter>
                        <labels>
                    </labels>
                <created>Thu, 21 Jun 2007 18:41:54 +0100</created>
                <updated>Fri, 10 May 2013 11:39:34 +0100</updated>
                            <resolved>Sat, 30 Jun 2007 20:49:58 +0100</resolved>
                                                    <fixVersion>1.3</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12509725" author="yseeley@gmail.com" created="Tue, 3 Jul 2007 02:27:39 +0100"  >&lt;p&gt;Looking at UpdateRequestProcessor further, it seems like these should be singletons (instance per entry in solrconfig, no factory needed), and any extra state that is needed&lt;br/&gt;
should be added to classes we already have (like AddCommand, etc), no?&lt;/p&gt;</comment>
                            <comment id="12509732" author="yseeley@gmail.com" created="Tue, 3 Jul 2007 03:06:03 +0100"  >&lt;p&gt;I think the newly added incremental time should not be on by default, as well as logging per id for deletes and adds.&lt;br/&gt;
Mike added the id aggregation code specifically because logging each add was taking so much time.&lt;/p&gt;</comment>
                            <comment id="12509733" author="ryantxu" created="Tue, 3 Jul 2007 03:15:27 +0100"  >&lt;p&gt;maybe.  I&apos;m not sure I totally understand your suggestion though.  &lt;/p&gt;

&lt;p&gt;I need something that is easily subclassed and can cleanly holds state across an entire request cycle.  The alternative is to pass the SolrQueryRequest/Response into each action and maybe pull out the schema/updateHandler/logged in user/etc for each command (each document in the list of 100)&lt;/p&gt;

&lt;p&gt;Is the factory a performance concern?  (to my tastes) it seems nicer to work with:&lt;/p&gt;

&lt;p&gt; processDelete( DeleteUpdateCommand cmd )&lt;br/&gt;
 {&lt;br/&gt;
   if( user.isAdmin() ) &lt;/p&gt;
{
     updateHandler.delete( cmd );
   }
&lt;p&gt;  &lt;br/&gt;
   else &lt;/p&gt;
{
   	...
   }
&lt;p&gt; }&lt;/p&gt;

&lt;p&gt; than:&lt;/p&gt;

&lt;p&gt; processDelete( DeleteUpdateCommand cmd, SolrQueryRequest req, SolrQueryResponse rsp )&lt;br/&gt;
 {&lt;br/&gt;
   User user = req.getContext().get( &quot;user&quot; );&lt;br/&gt;
   if( user.isAdmin() ) &lt;/p&gt;
{
    SolrCore core = req.getCore();
    SolrSchema schema = core.getSchema();
    UpdateHandler updateHandler = core.getUpdateHandler();
    updateHandler.delete( cmd );
   }
&lt;p&gt;  &lt;br/&gt;
   else &lt;/p&gt;
{
     ...
   }
&lt;p&gt; }&lt;/p&gt;

&lt;p&gt;I&apos;m fine either way, like the easy 1 per-request interface.  &lt;/p&gt;</comment>
                            <comment id="12509734" author="ryantxu" created="Tue, 3 Jul 2007 03:16:50 +0100"  >&lt;p&gt;&amp;gt; I think the newly added incremental time should not be on by default, as well as logging per id for deletes and adds.&lt;br/&gt;
&amp;gt; Mike added the id aggregation code specifically because logging each add was taking so much time.&lt;/p&gt;

&lt;p&gt;sounds good.  the testing I did showed that lots of time is spent in the logging phase.&lt;/p&gt;

&lt;p&gt;I will remove it from the default implementation.&lt;/p&gt;</comment>
                            <comment id="12509737" author="yseeley@gmail.com" created="Tue, 3 Jul 2007 03:41:22 +0100"  >&lt;p&gt;&amp;gt; I need something that is easily subclassed and can cleanly holds state across an entire request cycle.&lt;/p&gt;

&lt;p&gt;Having a factory and separate object so that one can use core instead of req.getCore(), etc, seems like overkill for the normal case though since&lt;br/&gt;
getCore(), getSchema(), getUpdateHandler() all just return instance variables.  I was thinking any state like that could be on the UpdateCommand.&lt;/p&gt;

&lt;p&gt;I&apos;d like to have potentially several request processors, but if people start doing single doc add requests, instantiating and initializing all those request processors will get expensive.&lt;/p&gt;

&lt;p&gt;I do see your usecase though, in the case of multiple docs per add and you have some expensive state you only want to calculate once.&lt;br/&gt;
If it&apos;s a relatively rare case, one could put it in the request context.&lt;br/&gt;
The tradeoff would be an extra hash lookup per-document of a multi-document add vs an extra object creation for single-doc adds.&lt;/p&gt;

&lt;p&gt;Different Q on usage: is this where my document mutator stuff should go???  If I want a transformation done on a field, regardless of where the data is coming from (XML update handler, CSV update handler, future REST update handler, etc), how should that be done?  Is there a single place I can register a plugin to do this, and is UpdateRequestProcessor where you see it happening?&lt;/p&gt;</comment>
                            <comment id="12510004" author="hossman" created="Tue, 3 Jul 2007 22:32:10 +0100"  >&lt;p&gt;&amp;gt; Different Q on usage: is this where my document mutator stuff should go??? If I want a transformation done on a field, regardless of &lt;br/&gt;
&amp;gt; where the data is coming from (XML update handler, CSV update handler, future REST update handler, etc), how should that be done? &lt;br/&gt;
&amp;gt; Is there a single place I can register a plugin to do this, and is UpdateRequestProcessor where you see it happening?&lt;/p&gt;

&lt;p&gt;i believe that was acutally the initial intent of UpdateRequestProcesso, note the javadocs...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;This is a good place for subclassed update handlers to process the document before it is&lt;/li&gt;
	&lt;li&gt;indexed.  You may wish to add/remove fields or check if the requested user is allowed to&lt;/li&gt;
	&lt;li&gt;update the given document...&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;Perhaps you continue adding an error message (without indexing the document)...&lt;/li&gt;
	&lt;li&gt;perhaps you throw an error and halt indexing (remove anything already indexed??)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12510009" author="ryantxu" created="Tue, 3 Jul 2007 22:49:33 +0100"  >
&lt;p&gt;&amp;gt; getCore(), getSchema(), getUpdateHandler() all just return instance variables.  &lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;ok, getCore() isn&apos;t a good canidate; It is annoying to start every function with a train wreck: req.getCore().getUpdateHandler()&lt;/p&gt;

&lt;p&gt;Having a single class per request makes sense for a subclass I am working with &amp;#8211; it does some expensive initialization and stores the results.  I could put this in req.getContext()&lt;/p&gt;


&lt;p&gt;&amp;gt; instantiating and initializing all those request processors will get expensive.&lt;/p&gt;

&lt;p&gt;Really?  the default initialize is trivial - stuff that would happen at the beginning of every function anyway.  I suppose GC could be an issue&lt;/p&gt;


&lt;p&gt;&amp;gt; I do see your usecase though, in the case of multiple docs per add and you have some expensive state you only want to calculate once.&lt;/p&gt;

&lt;p&gt;In r552986, I changed the logging to match solr 1.2 &amp;#8211; this required accumulating the id&apos;s and spitting them out at the end.  In 1.2 with processing and parsing entwined, this was just a giant loop.  To get the same behavior we need to stash it somewhere...&lt;/p&gt;


&lt;p&gt;&amp;gt; Different Q on usage: is this where my document mutator stuff should go??? &lt;/p&gt;

&lt;p&gt;Yes.  The intent is to have a simple place between document parsing and indexing where you can do whatever you need to do.  Any parsing strategy (XML,JSON,etc) could share the same processor.&lt;/p&gt;

&lt;p&gt;Looking at &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt;, I now think the most flexible/useful way to support modifiable documents is to build utility functions for the UpdateProcessor that can manipulate SolrInputDocuments. &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will take another crack at &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; implemented in the UpdateProcessor, then we should return to the question of singleton vs factory - trying to work with a more complex processor may make this choice more obvious.&lt;/p&gt;</comment>
                            <comment id="12510012" author="hossman" created="Tue, 3 Jul 2007 23:00:18 +0100"  >&lt;p&gt;&amp;gt; we should return to the question of singleton vs factory - trying to work with a more complex processor may make this choice more obvious.&lt;/p&gt;

&lt;p&gt;i&apos;m not really sure if i understand the issue ... but if it&apos;s a question of performance in the default case then i don&apos;t really see an issue &amp;#8211; a Factory API can return a Singleton provided the impl is threadsafe (iving us all the performance goodness of a Singleton) but switching to a Singleton API really limits what people can do when they &lt;b&gt;want&lt;/b&gt; to have a complex UpdateRequestProcessor and know it might take a while.&lt;/p&gt;

&lt;p&gt;Yonik, would your concerns be relieved if the default UpdateRequestProcessorFactory class was changed to look like this...&lt;/p&gt;

&lt;p&gt;public class UpdateRequestProcessorFactory {&lt;br/&gt;
  private final UpdateRequestProcessor SINGLETON;&lt;br/&gt;
  public UpdateRequestProcessorFactory()  &lt;/p&gt;
{ /*NOOP*/}
&lt;p&gt;  public void init( NamedList&amp;lt;Object&amp;gt; args ) &lt;/p&gt;
{ 
     SINGLETON = new UpdateRequestProcessor( req );
  }
&lt;p&gt;  public UpdateRequestProcessor getInstance( SolrQueryRequest req ) &lt;/p&gt;
{
    return SINGLETON  
  }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;?&lt;/p&gt;</comment>
                            <comment id="12510425" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 18:54:45 +0100"  >&lt;p&gt;FYI, I&apos;m working up a prototype right now to handle multiple request processors.&lt;/p&gt;</comment>
                            <comment id="12510429" author="hossman" created="Thu, 5 Jul 2007 18:59:11 +0100"  >&lt;p&gt;couldn&apos;t that just be a DelegateUpdateRequestProcessor that is constructed using a list of other UpdateRequestProcessors?&lt;/p&gt;

&lt;p&gt;    &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12510478" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 21:53:06 +0100"  >&lt;p&gt;OK, this patch adds the ability to specify multiple processor factories.&lt;/p&gt;

&lt;p&gt;Summary:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;decoupled changing the index from logging... I think it makes it much clearer how things work (there was much more logging code than anything else). This also would allow Ryan to add back his incremental timing to a different processor.&lt;/li&gt;
	&lt;li&gt;added SolrInputDocument to AddUpdateCommand, and added some methods&lt;/li&gt;
	&lt;li&gt;removed NamedList return from the XML update handler and started passing SolrQueryResponse around instead (this is more future-proof and flexible)&lt;/li&gt;
	&lt;li&gt;removed adding all the ids to the response... (back to 1.2 response format). We probably shouldn&apos;t add ids by default... think of CSV uploading millions of records, etc.&lt;/li&gt;
	&lt;li&gt;An array of factories is kept, and when a processor is instantiated, it is passed a &quot;next&quot; pointer. An alternative would be to expose a &quot;next factory&quot; pointer to every factory (any advantage to having the current factory call getInstance() on the next factory instead of us doing that?)&lt;/li&gt;
	&lt;li&gt;untested support for basic syntax to support multiple update processors:&lt;br/&gt;
    &amp;lt;lst name=&quot;update.processor&amp;gt;&lt;br/&gt;
      &amp;lt;str name=&quot;factory&quot;&amp;gt;org.apache.solr....&amp;lt;/str&amp;gt;&lt;br/&gt;
      &amp;lt;lst name=&quot;args&quot;&amp;gt;...&amp;lt;/lst&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12510479" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 21:59:17 +0100"  >&lt;p&gt;&amp;gt; couldn&apos;t that just be a DelegateUpdateRequestProcessor that is constructed using a list of other UpdateRequestProcessors&lt;/p&gt;

&lt;p&gt;That might be the way to go if multiple processors were to be very rare... but then you need to come&lt;br/&gt;
up with a syntax for the args of DelegateUpdateRequestProcessor  to specify multiple delegates, and one ends up writing the same code with more complex configuration.&lt;/p&gt;
</comment>
                            <comment id="12510484" author="ryantxu" created="Thu, 5 Jul 2007 22:23:47 +0100"  >&lt;p&gt;I like the AddUpdateCommand changes&lt;/p&gt;

&lt;p&gt;What do you see as the common use case for wanting to chain request processors?  Is the LogUpdateRequestProcessor just an example?  &lt;/p&gt;

&lt;p&gt;The one compelling chained use case I can think of is for document transformation.  In &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt;, I toyed with SolrInputDocumentTransformer.  The default case does nothing, and a subclass may use something like:&lt;br/&gt;
  for( SolrInputDocumentTransformer t : transformers ) &lt;/p&gt;
{
    doc = t.transform( doc );
  }</comment>
                            <comment id="12510487" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 22:38:02 +0100"  >&lt;p&gt;&amp;gt; What do you see as the common use case for wanting to chain request processors?&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;conditional copyField, field transformations (between multiple fields too... something Analyzer can&apos;t do), loading certain fields from a database if missing,&lt;br/&gt;
   updating a related document, etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; Is the LogUpdateRequestProcessor just an example?&lt;/p&gt;

&lt;p&gt;IMO, it&apos;s a default since no logging is done by the ChangeUpdateRequestProcessor (anyone think of a better name for that?).&lt;br/&gt;
Then in a Benchmarking section of the Solr Wiki, we could advise to remove logging altogether.  Or you could remove the ChangeUpdateRequestProcessor  to skip index&lt;br/&gt;
changes to better benchmark hotspots in the parsing + doc creation phase, etc.&lt;/p&gt;

&lt;p&gt;&amp;gt; The one compelling chained use case I can think of is for document transformation&lt;/p&gt;

&lt;p&gt;Ah, I briefly looked at &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; when you mentioned it before, but missed the transformer stuff.&lt;br/&gt;
In a way multiple update processors are more generic and wide open... you could actually insert two documents into the index for each doc added,&lt;br/&gt;
you could do transforms on the actual Lucene document (add Field options that Solr doesn&apos;t currently support, etc.&lt;/p&gt;</comment>
                            <comment id="12510504" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 23:16:37 +0100"  >&lt;p&gt;Some other issues.... how to configure processors for multiple update handlers? Perhaps allow configuration of a global default for update handlers with no processors specified?  That would make it easy to make sure your custom processor was used everywhere.&lt;br/&gt;
We should probably have a base class for update handlers to implement initialization logic.&lt;/p&gt;</comment>
                            <comment id="12510506" author="ryantxu" created="Thu, 5 Jul 2007 23:21:52 +0100"  >&lt;p&gt;&amp;gt;  - conditional copyField, field transformations (between multiple fields too... something Analyzer can&apos;t do), loading certain fields from a database if missing,&lt;br/&gt;
&amp;gt;    updating a related document, etc.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;This all works nicely with a simple &apos;transform&apos; chain.&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt; Is the LogUpdateRequestProcessor just an example?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; IMO, it&apos;s a default since no logging is done by the ChangeUpdateRequestProcessor (anyone think of a better name for that?).&lt;br/&gt;
&amp;gt; Then in a Benchmarking section of the Solr Wiki, we could advise to remove logging altogether.  Or you could remove the ChangeUpdateRequestProcessor  to skip index&lt;br/&gt;
&amp;gt; changes to better benchmark hotspots in the parsing + doc creation phase, etc.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Isn&apos;t logging best configured with standard java.util.logging settings? If necessary, the base processor could check if the logging level is high enough to keep track of somethings.&lt;/p&gt;

&lt;p&gt;For benchmarking, don&apos;t we just want a single noop processor?&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt; The one compelling chained use case I can think of is for document transformation&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Ah, I briefly looked at &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; when you mentioned it before, but missed the transformer stuff.&lt;br/&gt;
&amp;gt; In a way multiple update processors are more generic and wide open... you could actually insert two documents into the index for each doc added,&lt;br/&gt;
&amp;gt; you could do transforms on the actual Lucene document (add Field options that Solr doesn&apos;t currently support, etc.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;I see what you are getting at, but makes the basic cases more complicated then it needs to be.  I have been considering UpdateRequestProcessor as an &apos;advanced&apos; option where changing their behavior is writing custom code &amp;#8211; not text configuration.&lt;/p&gt;

&lt;p&gt;In the advanced case where you want to build multiple documents or munge the actual Lucene document existing it may be more difficult to live in a chain rather then have explicit control.  If &lt;/p&gt;

&lt;p&gt;I think the cleanest design would be a single entry point and keeping the real functionality in easily subclassed functions or utility classes.  The latest &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; tries that (but it could still use some cleanup)&lt;/p&gt;</comment>
                            <comment id="12510510" author="ryantxu" created="Thu, 5 Jul 2007 23:32:05 +0100"  >
&lt;p&gt;&amp;gt; Some other issues.... how to configure processors for multiple update handlers? Perhaps allow configuration of a global default for update handlers with no processors specified?  That would make it easy to make sure your custom processor was used everywhere.&lt;/p&gt;

&lt;p&gt;SolrCore could have a single UpdateRequestProcessorFactory that handlers could use as the default.  I&apos;m reluctant to add another plugin layer, but this would make it easier to share with the CSV update handler and others.&lt;/p&gt;

&lt;p&gt;Since its a factory, it will be thread safe across multiple handlers.&lt;/p&gt;

&lt;p&gt;Again, I&apos;m reluctant to think about configuring a processor chain in solrconfig.xml &amp;#8211; we should make the most sensible/extendible default implementation, but IMO tweeking RequestProcessor functionality should be done with custom code.&lt;/p&gt;</comment>
                            <comment id="12510518" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 23:59:51 +0100"  >&lt;p&gt;&amp;gt; This all works nicely with a simple &apos;transform&apos; chain. &lt;/p&gt;

&lt;p&gt;I don&apos;t see any code allowing initialization of the transform chain, or anything like that.&lt;br/&gt;
What are you proposing?&lt;/p&gt;

&lt;p&gt;I think it gets tougher when one talks about updates rather than document adds too.&lt;/p&gt;

&lt;p&gt;&amp;gt; Isn&apos;t logging best configured with standard java.util.logging settings?&lt;/p&gt;

&lt;p&gt;Not if you want a different type... for example, you seemed to want timing per-document added for example.&lt;br/&gt;
Having log specific configuration (such as number of ids to log in a big add) in it&apos;s own processor seems slightly nicer too.&lt;br/&gt;
Is there a downside to the logging being separated out in this case?  I really don&apos;t have strong feelings about it though (as long as we can keep the default version lean enough).&lt;/p&gt;

&lt;p&gt;&amp;gt; I see what you are getting at, but makes the basic cases more complicated then it needs to be.&lt;/p&gt;

&lt;p&gt;Yes, with the upside that we know our transform interface isn&apos;t too limiting.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m reluctant to add another plugin layer&lt;/p&gt;

&lt;p&gt;Me too... which is why just doing transform with the processors seems desirable (one less type of plugin).&lt;br/&gt;
If transformations are not to be done with UpdateRequestProcessor, I&apos;m not sure we should expose that interface at all as it&apos;s tightly coupled with DUH2.&lt;br/&gt;
It seems we really only need one type of plugin to do these document transformations.&lt;/p&gt;

&lt;p&gt;&amp;gt; SolrCore could have a single UpdateRequestProcessorFactory that handlers could use as the default.&lt;/p&gt;

&lt;p&gt;Yes, with update processors, the needed interface to add a document changes... you need the processor rather than the update handler.&lt;/p&gt;
</comment>
                            <comment id="12510538" author="yseeley@gmail.com" created="Fri, 6 Jul 2007 01:30:30 +0100"  >&lt;p&gt;&amp;gt; with update processors, the needed interface to add a document changes... you need the processor rather than the update handler.&lt;/p&gt;

&lt;p&gt;Thinking on these lines a bit further... perhaps the extra functionality of transformations and updating should be pushed into the UpdateHandler interface&lt;br/&gt;
(DUH2).  If it makes sense, we could deprecate the existing AddUpdateCommand  &amp;amp; methods in favor of new ones that use SolrInputDocument.&lt;/p&gt;

</comment>
                            <comment id="12510563" author="ryantxu" created="Fri, 6 Jul 2007 04:58:03 +0100"  >&lt;p&gt;&amp;gt; perhaps the extra functionality of transformations and updating should be pushed into the UpdateHandler interface&lt;/p&gt;

&lt;p&gt;That was the first &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; design!&lt;/p&gt;

&lt;p&gt;Having thought about it for a while, i think there are nice advantages to keeping the updating/modifying outside of the UpdateHandler - the biggest one is that various RequestHandlers &lt;b&gt;could&lt;/b&gt; transform the document differently.&lt;/p&gt;

&lt;p&gt;I&apos;m putting together a hybrid example that (I hope) answers questions about chains/configuration/transformation, etc.  I&apos;ll post it shortly.&lt;/p&gt;</comment>
                            <comment id="12510570" author="ryantxu" created="Fri, 6 Jul 2007 05:27:52 +0100"  >&lt;ul&gt;
	&lt;li&gt;loads UpdateRequestProcessorFactories using the plugin loader stuff from &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-260&quot; title=&quot;reusable PluginLoader -- helper class to load plugins&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-260&quot;&gt;&lt;del&gt;SOLR-260&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
	&lt;li&gt;makes a UpdateRequestHandlerBase class that XML and CSV share.&lt;/li&gt;
	&lt;li&gt;loads and configures a chain of InputTransformations.&lt;/li&gt;
	&lt;li&gt;moves UpdateRequestProcessor from o.a.s.handler to o.a.s.update&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is the test config:&lt;/p&gt;

&lt;p&gt;&amp;lt;updateRequestProcessor&amp;gt;&lt;br/&gt;
   &amp;lt;factory name=&quot;standard&quot; class=&quot;solr.UpdateRequestProcessorFactory&quot; /&amp;gt;&lt;br/&gt;
   &amp;lt;factory name=&quot;custom&quot; class=&quot;solr.CustomUpdateRequestProcessorFactory&quot; default=&quot;true&quot;&amp;gt;&lt;br/&gt;
     &amp;lt;args&amp;gt;&lt;br/&gt;
	    &amp;lt;lst name=&quot;name&quot;&amp;gt;&lt;br/&gt;
	      &amp;lt;str name=&quot;n1&quot;&amp;gt;v1&amp;lt;/str&amp;gt;&lt;br/&gt;
	      &amp;lt;str name=&quot;n2&quot;&amp;gt;v2&amp;lt;/str&amp;gt;&lt;br/&gt;
	    &amp;lt;/lst&amp;gt;&lt;br/&gt;
     &amp;lt;/args&amp;gt;&lt;br/&gt;
     &amp;lt;transformer class=&quot;solr.CustomTransformerNoOp&quot; /&amp;gt;&lt;br/&gt;
     &amp;lt;transformer class=&quot;solr.CustomTransformerNoOp&quot; /&amp;gt;&lt;br/&gt;
     &amp;lt;transformer class=&quot;solr.CustomTransformerAdd&quot;&amp;gt;&lt;br/&gt;
       &amp;lt;str name=&quot;f0&quot;&amp;gt;000&amp;lt;/str&amp;gt;&lt;br/&gt;
       &amp;lt;str name=&quot;f1&quot;&amp;gt;111&amp;lt;/str&amp;gt;&lt;br/&gt;
     &amp;lt;/transformer&amp;gt;&lt;br/&gt;
     &amp;lt;transformer class=&quot;solr.CustomTransformerNoOp&quot; /&amp;gt;&lt;br/&gt;
   &amp;lt;/factory&amp;gt;&lt;br/&gt;
 &amp;lt;/updateRequestProcessor&amp;gt;&lt;/p&gt;

&lt;p&gt;I am not sure we want to make the transformer interface public yet, but it is here to show how I think it could be handled.&lt;/p&gt;

&lt;p&gt;If you like this approach, I&apos;ll clean it up some more...&lt;/p&gt;</comment>
                            <comment id="12510574" author="ryantxu" created="Fri, 6 Jul 2007 05:50:01 +0100"  >
&lt;p&gt;&amp;gt; I don&apos;t see any code allowing initialization of the transform chain, or anything like that.&lt;br/&gt;
&amp;gt; What are you proposing?&lt;/p&gt;

&lt;p&gt;Check the latest patch.  I&apos;m not sure we need to have XML configuration for this, but I added it as an example.  The factory would hold a list of transformers:&lt;br/&gt;
 &amp;lt;transformer class=&quot;MyConditionalCopyField&quot; /&amp;gt;&lt;br/&gt;
 &amp;lt;transformer class=&quot;SynonymCleaner&quot; /&amp;gt;&lt;br/&gt;
 &amp;lt;transformer class=&quot;RunAnalyzerAndStoreAsMultiValuedFields&quot;&amp;gt; &lt;/p&gt;


&lt;p&gt;&amp;gt; Is there a downside to the logging being separated out in this case? &lt;/p&gt;

&lt;p&gt;only that it justifies the UpdateRequestProcessorFactory chain &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This patch includes a UpdateRequestProcessorChainFactory - this is a UpdateRequestProcessorFactory that keeps a chain of UpdateRequestProcessorFactories and iterates through them.  This pointed out another thing I don&apos;t like about the chain pattern.&lt;/p&gt;

&lt;p&gt;I need a custom UpdateRequestProcessor that checks all the requests before executing any of them.  I plan to store the valid commands in a list and only execute them in the finish() call.  I&apos;m not sure how to map that plan to an chain.  How would I pass the output from one processor to the next?  &lt;/p&gt;</comment>
                            <comment id="12510749" author="yseeley@gmail.com" created="Fri, 6 Jul 2007 18:43:55 +0100"  >&lt;p&gt;&amp;gt; I&apos;m not sure we need to have XML configuration for this&lt;/p&gt;

&lt;p&gt;If we have those multiple update processor factories, I agree we don&apos;t need XML config for the transformers.&lt;/p&gt;

&lt;p&gt;&amp;gt; I need a custom UpdateRequestProcessor that checks all the requests before executing any of them. I plan to store the valid commands in a list and only execute them in the finish() call. I&apos;m not sure how to map that plan to an chain. How would I pass the output from one processor to the next?&lt;/p&gt;

&lt;p&gt;I had thought of that use-case too (bulk operations), which is why I added explicit flow contol (explicit calling of next.handleAdd() in the processor). &lt;br/&gt;
You can buffer up all the requests (you want to clone the UpdateCommands as they might be reused though) and not call &quot;next&quot;.&lt;br/&gt;
Then in finish, you can delegate all of the buffered commands.&lt;/p&gt;</comment>
                            <comment id="12510754" author="yseeley@gmail.com" created="Fri, 6 Jul 2007 19:02:12 +0100"  >&lt;p&gt;What about working off the version I attached (or at least folding in those changes)?  It had a bunch of changes that I prefer, including&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;explicit flow control between processors for greatest flexibility&lt;/li&gt;
	&lt;li&gt;removal of NamedList return (as you say, chaining those makes less sense anyway)&lt;/li&gt;
	&lt;li&gt;already extracted and optimized the complex (or rather bigger) logging logic from the simple index updating&lt;/li&gt;
	&lt;li&gt;passed in SolrQueryResponse as well, enabling a processor to change the response&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12510759" author="ryantxu" created="Fri, 6 Jul 2007 19:54:18 +0100"  >&lt;p&gt;The only one I&apos;m not sure about is:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;explicit flow control between processors for greatest flexibility&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m still trying to avoid the parent UpdateRequestProcessorFactory chain as a default behavior.  It seems fine as a super-duper custom controlller, but unurly in the default/slightly custom case.&lt;/p&gt;

&lt;p&gt;Folding in:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;removal of NamedList return (as you say, chaining those makes less sense anyway)&lt;/li&gt;
	&lt;li&gt;already extracted and optimized the complex (or rather bigger) logging logic from the simple index updating&lt;/li&gt;
	&lt;li&gt;passed in SolrQueryResponse as well, enabling a processor to change the response&lt;br/&gt;
is no problem.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If you like the general structure / flow of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-269&quot; title=&quot;UpdateRequestProcessorFactory - process requests before submitting them&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-269&quot;&gt;&lt;del&gt;SOLR-269&lt;/del&gt;&lt;/a&gt;-UpdateRequestProcessorFactory.patch, I&apos;ll clean it up and work in this stuff.  Otherwise I&apos;ll look at how to make UpdateRequestProcessorFactory[] feel more palatable.&lt;/p&gt;</comment>
                            <comment id="12510771" author="yseeley@gmail.com" created="Fri, 6 Jul 2007 20:46:36 +0100"  >&lt;p&gt;&amp;gt; The only one I&apos;m not sure about is:&lt;br/&gt;
&amp;gt; - explicit flow control between processors for greatest flexibility&lt;/p&gt;

&lt;p&gt;It&apos;s a single call per hook:&lt;br/&gt;
  if (next != null) next.processAdd();&lt;/p&gt;

&lt;p&gt;And it&apos;s exactly what you need for your &quot;buffering&quot; situation.&lt;br/&gt;
Chaining is the model that Lucene uses for it&apos;s analyzers too (only difference is that it&apos;s a pull instead of a push).&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m still trying to avoid the parent UpdateRequestProcessorFactory chain as a default behavior. It seems fine as a super-duper custom controlller, but unurly in the default/slightly custom case. &lt;/p&gt;

&lt;p&gt;I&apos;m not clear on why... the configuration is more complex?&lt;/p&gt;

&lt;p&gt;&amp;gt; If you like the general structure / flow of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-269&quot; title=&quot;UpdateRequestProcessorFactory - process requests before submitting them&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-269&quot;&gt;&lt;del&gt;SOLR-269&lt;/del&gt;&lt;/a&gt;-UpdateRequestProcessorFactory.patch&lt;/p&gt;

&lt;p&gt;I&apos;m not sure about the named processors... are they needed?&lt;br/&gt;
It seems like we need a &quot;standard&quot; one that is used by default everywhere,&lt;br/&gt;
and then &lt;b&gt;maybe&lt;/b&gt; we need to be able to change them per-handler.  Do we need this up front, or could it be deferred?&lt;/p&gt;

&lt;p&gt;It seems like there does need to be a method on SolrCore to get a RequestProcessor or Factory, since that becomes&lt;br/&gt;
the new interface to do an index change (otherwise you miss the doc transformations, etc).&lt;/p&gt;

&lt;p&gt;&amp;gt; Otherwise I&apos;ll look at how to make UpdateRequestProcessorFactory[] feel more palatable.&lt;/p&gt;

&lt;p&gt;That could be wrapped in another UpdateRequestProcessorFactory if desired... it doesn&apos;t matter much if the impl is hidden by a class or a method IMO.&lt;/p&gt;</comment>
                            <comment id="12510774" author="ryantxu" created="Fri, 6 Jul 2007 21:15:39 +0100"  >
&lt;p&gt;&amp;gt; It&apos;s a single call per hook:&lt;br/&gt;
&amp;gt;   if (next != null) next.processAdd();&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Ok.  I&apos;m convinced.&lt;/p&gt;


&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;m not sure about the named processors... are they needed?&lt;br/&gt;
&amp;gt; It seems like we need a &quot;standard&quot; one that is used by default everywhere,&lt;br/&gt;
&amp;gt; and then &lt;b&gt;maybe&lt;/b&gt; we need to be able to change them per-handler.  Do we need this up front, or could it be deferred?&lt;/p&gt;

&lt;p&gt;I&apos;m not sure.  The only reason I think we &lt;b&gt;may&lt;/b&gt; want to do it now is to keep the initialization standard and in a single place.  If we declare a default processor and have each handler optionally initialize their own, the config may look different.  RequestHandlers only have access to a NamedList while initialized, they can&apos;t (without serious changes) declare something like:&lt;br/&gt;
 &amp;lt;requestHandler ...&amp;gt;&lt;br/&gt;
   &amp;lt;updateProcessor class=&quot;&quot; /&amp;gt;&lt;br/&gt;
 &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;

&lt;p&gt;With that in mind, I think it best to build the updateProcessors using the standard PluginLoader framework and then have RequestHandlers access them by name.&lt;/p&gt;


&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; Otherwise I&apos;ll look at how to make UpdateRequestProcessorFactory[] feel more palatable.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; That could be wrapped in another UpdateRequestProcessorFactory if desired... it doesn&apos;t matter much if the impl is hidden by a class or a method IMO.&lt;/p&gt;

&lt;p&gt;Ok, I&apos;ll start with UpdateProcessor.patch and fold in my changes.&lt;/p&gt;</comment>
                            <comment id="12510819" author="ryantxu" created="Fri, 6 Jul 2007 23:46:51 +0100"  >&lt;p&gt;New version that started with Yonik&apos;s patch.  This masks the &apos;Chain&apos; in a ChainedUpdateProcessorFactory.  By default it has two elements:&lt;br/&gt;
 1. RunUpdateProcessor&lt;br/&gt;
 2. LogUpdateProcessor&lt;/p&gt;

&lt;p&gt;I moved the processor stuff to o.a.s.update.processor.  The Classes need to be public for them to get created with the PluginLoader.  &lt;/p&gt;

&lt;p&gt;This still has a map&amp;lt;String,Factory&amp;gt; in core.&lt;/p&gt;

&lt;p&gt;Here is the XML configuration I am using in the testing:&lt;/p&gt;

&lt;p&gt; &amp;lt;updateRequestProcessor&amp;gt;&lt;br/&gt;
   &amp;lt;factory name=&quot;standard&quot; class=&quot;solr.ChainedUpdateProcessorFactory&quot; &amp;gt;&lt;br/&gt;
     &amp;lt;chain class=&quot;solr.LogUpdateProcessorFactory&quot; &amp;gt;&lt;br/&gt;
	   &amp;lt;int name=&quot;maxNumToLog&quot;&amp;gt;100&amp;lt;/int&amp;gt;&lt;br/&gt;
     &amp;lt;/chain&amp;gt;&lt;br/&gt;
     &amp;lt;chain class=&quot;solr.CustomUpdateRequestProcessorFactory&quot; &amp;gt;&lt;br/&gt;
	    &amp;lt;lst name=&quot;name&quot;&amp;gt;&lt;br/&gt;
	      &amp;lt;str name=&quot;n1&quot;&amp;gt;x1&amp;lt;/str&amp;gt;&lt;br/&gt;
	      &amp;lt;str name=&quot;n2&quot;&amp;gt;x2&amp;lt;/str&amp;gt;&lt;br/&gt;
	    &amp;lt;/lst&amp;gt;&lt;br/&gt;
     &amp;lt;/chain&amp;gt;&lt;br/&gt;
     &amp;lt;chain class=&quot;solr.CustomUpdateRequestProcessorFactory&quot; &amp;gt;&lt;br/&gt;
	    &amp;lt;lst name=&quot;name&quot;&amp;gt;&lt;br/&gt;
	      &amp;lt;str name=&quot;nA&quot;&amp;gt;xA&amp;lt;/str&amp;gt;&lt;br/&gt;
	      &amp;lt;str name=&quot;nA&quot;&amp;gt;xA&amp;lt;/str&amp;gt;&lt;br/&gt;
	    &amp;lt;/lst&amp;gt;&lt;br/&gt;
     &amp;lt;/chain&amp;gt;&lt;br/&gt;
   &amp;lt;/factory&amp;gt;&lt;/p&gt;

&lt;p&gt;   &amp;lt;factory name=&quot;custom&quot; class=&quot;solr.CustomUpdateRequestProcessorFactory&quot; default=&quot;true&quot; &amp;gt;&lt;br/&gt;
    &amp;lt;lst name=&quot;name&quot;&amp;gt;&lt;br/&gt;
      &amp;lt;str name=&quot;n8&quot;&amp;gt;88&amp;lt;/str&amp;gt;&lt;br/&gt;
      &amp;lt;str name=&quot;n9&quot;&amp;gt;99&amp;lt;/str&amp;gt;&lt;br/&gt;
    &amp;lt;/lst&amp;gt;&lt;br/&gt;
   &amp;lt;/factory&amp;gt;&lt;br/&gt;
 &amp;lt;/updateRequestProcessor&amp;gt;&lt;/p&gt;


&lt;p&gt;I&apos;m starting to like the structure.  &lt;/p&gt;

&lt;p&gt;thoughts?&lt;/p&gt;</comment>
                            <comment id="12511178" author="yseeley@gmail.com" created="Mon, 9 Jul 2007 18:16:39 +0100"  >&lt;p&gt;One issue: the current way of having a custom processor (CustomUpdateRequestHandler) seems less than ideal.&lt;br/&gt;
First is that CustomUpdateRequestHandler extends XMLUpdateRequestHandler.... but what if I want one for CSV, etc.&lt;br/&gt;
If update processors are to be a first-class part of Solr, it seems like one should be able to specify the processor to use&lt;br/&gt;
 for any update handler (CSV, XML, etc) without having to write extra classes for those.&lt;/p&gt;

&lt;p&gt;Perhaps something like:&lt;br/&gt;
 &amp;lt;requestHandler name=&quot;/customupdate&quot; class=&quot;solr.XmlUpdateRequestHandler&quot; &amp;gt;&lt;br/&gt;
   &amp;lt;str name=&quot;update.processor&quot;&amp;gt;standard&amp;lt;/str&amp;gt;&lt;br/&gt;
 &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12511195" author="ryantxu" created="Mon, 9 Jul 2007 18:40:26 +0100"  >&lt;p&gt;Hymm.  the behavior on trunk is:&lt;br/&gt;
&amp;lt;requestHandler name=&quot;/customupdate&quot; class=&quot;solr.XmlUpdateRequestHandler&quot; &amp;gt;&lt;br/&gt;
   &amp;lt;str name=&quot;update.processor.factory&quot;&amp;gt;class name for factory&amp;lt;/str&amp;gt;&lt;br/&gt;
 &amp;lt;/requestHandler&amp;gt; &lt;br/&gt;
The latest patch has the argument lookup an XML configured factory.&lt;/p&gt;

&lt;p&gt;Do you mean:&lt;/p&gt;

&lt;p&gt; &amp;lt;requestHandler name=&quot;/customupdate&quot; class=&quot;solr.XmlUpdateRequestHandler&quot; &amp;gt;&lt;br/&gt;
    &amp;lt;lst name=&quot;invariants&quot;&amp;gt;&lt;br/&gt;
      &amp;lt;str name=&quot;update.processor&quot;&amp;gt;standard&amp;lt;/str&amp;gt;&lt;br/&gt;
    &amp;lt;/lst&amp;gt;&lt;br/&gt;
 &amp;lt;/requestHandler&amp;gt; &lt;/p&gt;

&lt;p&gt;Given the direction we are heading, it seems nice to be able to change the update behavior from:&lt;br/&gt;
 /update?update.processor=do-fancy-document-cleanup&lt;br/&gt;
 /update?update.processor=go-quick-i-know-the-docs-are-clean&lt;/p&gt;

&lt;p&gt;I made it a 1-1 relation (processor-handler) to avoid a hash lookup for each request, but from a pram would be ok.&lt;/p&gt;
</comment>
                            <comment id="12511198" author="yseeley@gmail.com" created="Mon, 9 Jul 2007 18:49:01 +0100"  >&lt;p&gt;&amp;gt; I made it a 1-1 relation (processor-handler) to avoid a hash lookup for each request,&lt;/p&gt;

&lt;p&gt;That was my thinking too... I wasn&apos;t suggesting making it  an overrideable parameter, but I&apos;m not really against it either.&lt;/p&gt;

</comment>
                            <comment id="12511206" author="hossman" created="Mon, 9 Jul 2007 19:02:30 +0100"  >&lt;p&gt;the idea of letting people override the processor on a per request basis seems very scary and depending on what kinds of stuff yo uwere expecting hte processor to do, could introduce some serous bugs ... but then again, if it&apos;s a param, it can be specified as an invariant if you want to ensure that doesn&apos;t happen.&lt;/p&gt;

&lt;p&gt;i guess hte key thing is just that the RequestHandler has final say over what Processor gets used ... we can provide handy tools/conventions to get that info from the config or the request, but a very simplistic RequestHandler should be able to hardcode it for absolute control.&lt;/p&gt;</comment>
                            <comment id="12512356" author="ryantxu" created="Fri, 13 Jul 2007 05:06:50 +0100"  >&lt;p&gt;&amp;gt; the RequestHandler has final say over what Processor gets used&lt;/p&gt;

&lt;p&gt;absolutely!  The question is just what do in the default /update case.  I&apos;m inclined to have the request say what processor to use.  With &apos;invariants&apos; that can be fixed to a single implementation, and will let people configure processors without a custom handler.&lt;/p&gt;

&lt;p&gt;How do you all feel about the basic structure?  I like the structure, but am not sure how &apos;public&apos; to make the configuration and implementation.  While it would be nice to keep the base stuff package protected, then we can&apos;t have external configuration and external classes could not reuse the other bits of the chain (defeating the &apos;chain&apos; advantages)&lt;/p&gt;

&lt;p&gt;I have a pending deadline that depends on input processing and &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; modifiable documents &amp;#8211; it would be great to work from a lightly patched trunk rather then a heavily patched one &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12512390" author="ryantxu" created="Fri, 13 Jul 2007 08:48:28 +0100"  >&lt;p&gt;The latest patch on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; includes a cleaned up version of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-269&quot; title=&quot;UpdateRequestProcessorFactory - process requests before submitting them&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-269&quot;&gt;&lt;del&gt;SOLR-269&lt;/del&gt;&lt;/a&gt;.  One clever change is to have the LogUpdateProcessorFactory skip building a LogUpdateProcessor if the log level is not INFO rather then keep a flag.&lt;/p&gt;</comment>
                            <comment id="12512502" author="yseeley@gmail.com" created="Fri, 13 Jul 2007 15:37:26 +0100"  >&lt;p&gt;&amp;gt; How do you all feel about the basic structure?&lt;br/&gt;
It&apos;s a go!&lt;br/&gt;
It will get more complicated, I think, with document modification (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&amp;gt; While it would be nice to keep the base stuff package protected,&lt;/p&gt;

&lt;p&gt;I&apos;m more concerned with the other parts of the API that this moves front-and-center... &lt;br/&gt;
mainly UpdateCommand and friends... those were really quick hacks on my part since there were no custom &quot;update&quot; handlers at the time.&lt;/p&gt;

&lt;p&gt;&amp;gt; One clever change is to have the LogUpdateProcessorFactory skip building a LogUpdateProcessor if the log level is not INFO rather then keep a flag.&lt;/p&gt;

&lt;p&gt;Nice!&lt;/p&gt;

&lt;p&gt;I also need &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-139&quot; title=&quot;Support updateable/modifiable documents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-139&quot;&gt;&lt;del&gt;SOLR-139&lt;/del&gt;&lt;/a&gt; btw, is it easy for you to commit this first to limit the size and scope of that patch?&lt;/p&gt;</comment>
                            <comment id="12616457" author="shalinmangar" created="Thu, 24 Jul 2008 13:08:06 +0100"  >&lt;p&gt;I&apos;ve read through most of the discussion here and the wiki page at &lt;a href=&quot;http://wiki.apache.org/solr/UpdateRequestProcessor&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/solr/UpdateRequestProcessor&lt;/a&gt; but I couldn&apos;t understand the reasons behind the current design.&lt;/p&gt;

&lt;p&gt;Looking at the configuration we have:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessor&amp;gt;&lt;/span&gt;                                               
   &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;factory name=&lt;span class=&quot;code-quote&quot;&gt;&quot;standard&quot;&lt;/span&gt; class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.ChainedUpdateProcessorFactory&quot;&lt;/span&gt; default=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;
     &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;chain class=&lt;span class=&quot;code-quote&quot;&gt;&quot;org.apache.solr.ConditionalCopyProcessorFactory&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;                                    
     &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;chain class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessorFactory&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;                    
     &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;chain class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.LogUpdateProcessorFactory&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;                   
   &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/factory&amp;gt;&lt;/span&gt;                                                           
 &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessor&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Why can&apos;t it be written as:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessor name=&lt;span class=&quot;code-quote&quot;&gt;&quot;standard&quot;&lt;/span&gt; default=&lt;span class=&quot;code-quote&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;com.MyUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessor&amp;gt;&lt;/span&gt;

&lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- Another one --&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessor name=&lt;span class=&quot;code-quote&quot;&gt;&quot;alternate&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;org.apache.solr.ConditionalCopyProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.LogUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessor&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Why do we need factories here? It seems like there is no advantage being added by multiple factories. If the only advantage is with the factory being able to choose between instantiating on each request or using an already instantiated processor then one can argue on having factories for RequestHandlers or SearchComponents too. The Processors should be created once and re-used. Most of them are stateless and the others can use the init method and store state in instance variables. The same is done with RequestHandlers and SearchComponents at present.&lt;/p&gt;

&lt;p&gt;Why should we have a explicit ChainedUpdateRequestProcessorFactory? Seems from the use-cases that processors will always be chained. Let us have the implementation do the chaining instead of asking users to add a factory in the configuration.&lt;/p&gt;

&lt;p&gt;Not trying to be critical but seems like this is too complex for the use-cases it needs to support.&lt;/p&gt;</comment>
                            <comment id="12616483" author="ryantxu" created="Thu, 24 Jul 2008 15:11:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;Not trying to be critical but seems like this is too complex for the use-cases it needs to support.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nonsense &amp;#8211; the more review / feedback / critique we get, the better &amp;#8211; especially &lt;b&gt;before&lt;/b&gt; a release &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&quot;Why do we need factories here?&quot;  &amp;#8211;  the model came from how things work with Token/Filter factories.  Many processors need to maintain state within a request.  Check the &apos;log&apos; processor.  I have one that checks if the user has permission on &lt;b&gt;everything&lt;/b&gt; in the request before executing the commands.  We could have something that keeps track of what it did and backs out the changes if there is an error.  If each processor were shared across all requests, any state access would need to be synchronized and have some Map&amp;lt;Request,State&amp;gt; that seems to get ugly pretty fast.&lt;/p&gt;

&lt;p&gt;Why ChainedUpdateRequestProcessorFactory?  I see your point here.  I think we can force everything to be &apos;chained&apos; &amp;#8211; The original implementation was not chained, but then the functional parts got split into their own components and chained together.  Removing the parent chained factory could simplify the whole thing.&lt;/p&gt;</comment>
                            <comment id="12616511" author="noble.paul" created="Thu, 24 Jul 2008 16:59:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;Many processors need to maintain state within a request. Check the &apos;log&apos; processor. I have one that checks &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;if the user has permission on everything in the request before executing the commands. &lt;/p&gt;

&lt;p&gt;I do not think we need a factory where we need to maintain local state . Everything can be maintained in the method stack &lt;/p&gt;

&lt;p&gt;example&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class LocalState{

  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; SolrQueryRequest req;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; SolrQueryResponse rsp;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; UpdateRequestProcessor next;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; NamedList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; toLog;
doSomething(){
&lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; your thing
&lt;/span&gt;}
}

 &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class LogUpdateProcessor &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; UpdateRequestProcessor
   

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void processAdd(AddUpdateCommand cmd) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
     LocalState state = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LocalState ();&lt;span class=&quot;code-comment&quot;&gt;//pass the params
&lt;/span&gt;     state.doSomeThing()
    }
    
    }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here the method acts as the factory and not the fra&lt;/p&gt;</comment>
                            <comment id="12616520" author="shalinmangar" created="Thu, 24 Jul 2008 17:16:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;If each processor were shared across all requests, any state access would need to be synchronized and have some Map&amp;lt;Request,State&amp;gt; that seems to get ugly pretty fast.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;But we do have SolrQueryRequest#getContext to handle those cases, don&apos;t we? IMHO, we should not force users to write a factory class for each processor when the benefit is minimal and easy workarounds exist. Please correct me if I&apos;m misunderstanding something.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Nonsense - the more review / feedback / critique we get, the better - especially before a release &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Glad to hear that, though I realize that I&apos;m a year late and that we are very close to a release &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It&apos;s just that I set out to use this API and had to jump around for quite a while to figure out how to use it and how it works. I was quite surprised to find the actual chaining happening in a class which is named NoOpUpdateProcessor &amp;#8211; though it made sense to me later. Also, it took me a while to find the wiki page for this feature because it is not linked off the main page (or the update xml/csv pages). I could find it because I knew that a class named UpdateRequestProcessor existed. We should link it off the main page so that it can be found more easily.&lt;/p&gt;</comment>
                            <comment id="12616544" author="ryantxu" created="Thu, 24 Jul 2008 18:27:52 +0100"  >&lt;p&gt;I&apos;m all for simplifying the API.  If you guys want to take a crack at it, I&apos;ll review it ASAP.  &lt;/p&gt;</comment>
                            <comment id="12616649" author="yseeley@gmail.com" created="Thu, 24 Jul 2008 21:44:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;But we do have SolrQueryRequest#getContext to handle those cases, don&apos;t we? IMHO, we should not force users to write a factory class for each processor when the benefit is minimal and easy workarounds exist.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right... the alternative to a per-request instance would be to use the request context.&lt;br/&gt;
In general, I think that would be more complex for a user though (if it&apos;s something they want to do per request-batch).&lt;br/&gt;
I think that can be made more efficient for bulk loading by using factories too... context lookups and decisions don&apos;t have to be made  for every document.&lt;/p&gt;</comment>
                            <comment id="12616778" author="noble.paul" created="Fri, 25 Jul 2008 08:08:51 +0100"  >&lt;p&gt;A very simple implementation. No factory. No state &lt;br/&gt;
The attached patch has not removed the existing stuff and it is not a working model . But it demonstrates how you can put in a simpler API . The design is inspired by the &lt;em&gt;ServletFilter&lt;/em&gt; API. but without the &lt;em&gt;filterChain.doFilter()&lt;/em&gt; part.(it relies on the return code)  &lt;/p&gt;

&lt;p&gt;The configuration format is &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessorChain&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;com.MyUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessor&amp;gt;&lt;/span&gt;

&lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- Another one --&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessorChain name=&lt;span class=&quot;code-quote&quot;&gt;&quot;alternate&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;org.apache.solr.ConditionalCopyProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.LogUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessorChain&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The usage must be as follows&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
solrCore.getUpdateProcessorChain(name).processXXX(command,  solrQueryRequest, solrQueryResponse);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;this patch relies on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-614&quot; title=&quot;Allow components to read any kind of XML from solrconfig&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-614&quot;&gt;&lt;del&gt;SOLR-614&lt;/del&gt;&lt;/a&gt; for simplifying configuration&lt;/p&gt;</comment>
                            <comment id="12616923" author="yseeley@gmail.com" created="Fri, 25 Jul 2008 16:29:27 +0100"  >&lt;p&gt;While I like the syntax of the config (getting rid of explicit chained update processor), I&apos;m not sure about the internal changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I think that removing the factories does not simplify things... most processors that do interesting things will need to parse some request arguments and keep some state. So they will end up with a separate object that is looked up in the Context (and created if it&apos;s not there and stuffed into the Context).  Same number of classes, but maybe even a little more complex.&lt;/li&gt;
	&lt;li&gt;We lose power by removing the explicit calling of &quot;next&quot; by components.  I actually have a component that needs to buffer up some documents and pass them down the chain in batches later.  I think Ryan might have something like this too.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12616927" author="ryantxu" created="Fri, 25 Jul 2008 16:51:32 +0100"  >&lt;p&gt;I also like the simplified syntax, and I think the parent should always be a &apos;chain&apos; &amp;#8211; this can get rid of some of the ugliness.&lt;/p&gt;

&lt;p&gt;But the power of the chain model is that each link can take over control without the others needing to know.  For example, I have a processor that validates everything in the request before passing it on to next processors.  To do this, it reads them all in without passing them down the chain and only continues when finish() is called.&lt;/p&gt;

&lt;p&gt;I also don&apos;t see a problem with the factory model.  creating a factory is no more/less difficult then creating a special &apos;state&apos; object that gets put into the context.  But the the context option, the state is always a Map call away rather them being right there.  Now you have to worry about what key you used etc...&lt;/p&gt;</comment>
                            <comment id="12616929" author="shalinmangar" created="Fri, 25 Jul 2008 16:52:06 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think that removing the factories does not simplify things... most processors that do interesting things will need to parse some request arguments and keep some state. So they will end up with a separate object that is looked up in the Context (and created if it&apos;s not there and stuffed into the Context). Same number of classes, but maybe even a little more complex.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about giving this independence through configuration?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-xml&quot;&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessorChain scope=&lt;span class=&quot;code-quote&quot;&gt;&quot;request&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;com.MyUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessor&amp;gt;&lt;/span&gt;

&lt;span class=&quot;code-tag&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;&amp;lt;!-- Another one --&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;updateRequestProcessorChain name=&lt;span class=&quot;code-quote&quot;&gt;&quot;alternate&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;org.apache.solr.ConditionalCopyProcessor&quot;&lt;/span&gt; scope=&lt;span class=&quot;code-quote&quot;&gt;&quot;request&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.RunUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;code-tag&quot;&gt;&amp;lt;processor class=&lt;span class=&quot;code-quote&quot;&gt;&quot;solr.LogUpdateProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
&lt;span class=&quot;code-tag&quot;&gt;&amp;lt;/updateRequestProcessorChain&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A &quot;request&quot; scope will create the chain or individual processor for each request so that you may maintain state without using request&apos;s context. Otherwise, it will be created once and re-used for all requests. Will that solve this problem?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We lose power by removing the explicit calling of &quot;next&quot; by components. I actually have a component that needs to buffer up some documents and pass them down the chain in batches later. I think Ryan might have something like this too.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In Noble&apos;s patch, instead of calling super.processXXX method, you can return true/false to signal or avoid chaining.&lt;/p&gt;</comment>
                            <comment id="12616932" author="ryantxu" created="Fri, 25 Jul 2008 17:08:05 +0100"  >&lt;blockquote&gt;&lt;p&gt;A &quot;request&quot; scope will create the chain or individual processor for each request so that you may maintain state without using request&apos;s context. Otherwise, it will be created once and re-used for all requests. Will that solve this problem?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;-&lt;del&gt;To me, that makes it more confusing then having each processor call next() explicitly...&lt;/del&gt;-  (dooh - answering the wrong question)  This gets overly complex too... do we add a special init() function?  would everything need a factory, but it may or may not be used?&lt;/p&gt;

&lt;p&gt;If the motivation for making the objects shared across requests is clarity, i&apos;m not sure it helps.  Is there some other reason?&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;In Noble&apos;s patch, instead of calling super.processXXX method, you can return true/false to signal or avoid chaining.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;but then how would a processor be able to continue the chain?  Consider the buffering example... how would I be able to call all buffered functions on finish()?  What if I want a processor to make sure only one document is sent at a time?&lt;/p&gt;</comment>
                            <comment id="12616949" author="shalinmangar" created="Fri, 25 Jul 2008 17:57:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;This gets overly complex too... do we add a special init() function? would everything need a factory, but it may or may not be used?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No, why would we need special methods or a factory? Just the init/inform will be fine. Just that they would be called once in their scope. Am I missing something?&lt;/p&gt;

&lt;p&gt;I don&apos;t really care about sharing objects across requests. My motivation is only to help make the API simpler.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Consider the buffering example... how would I be able to call all buffered functions on finish()? What if I want a processor to make sure only one document is sent at a time?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I see your point here. The next UpdateProcessor or a Servlet FilterChain like design will be necessary in that case.&lt;/p&gt;

&lt;p&gt;Let me think more on this since I&apos;ve obviously under-estimated the use-cases for this API. I always thought that one should do heavy-duty processing like authentication etc. on the client side before sending documents to Solr or else one should extend/write an UpdateHandler.&lt;/p&gt;</comment>
                            <comment id="12616966" author="noblepaul" created="Fri, 25 Jul 2008 18:46:33 +0100"  >&lt;p&gt;The idea is to make the API simple. If a Processor wishes to create a&lt;br/&gt;
state object , it is easier to do it without a factory than with a&lt;br/&gt;
factory. The user has to care about very few interfaces. I can draw&lt;br/&gt;
parallels with Servlet Filter. Users write very complex  filters and I&lt;br/&gt;
have never seen people complaining about it not having a factory .&lt;br/&gt;
SolrDispatchFilter is a very good example. If it is simple enough&lt;br/&gt;
people will use it. If it is complex only the &apos;very smart people&apos; use&lt;br/&gt;
it. Most of the users are not power users and they just want to get&lt;br/&gt;
things done.&lt;/p&gt;

&lt;p&gt;On Fri, Jul 25, 2008 at 10:27 PM, Shalin Shekhar Mangar (JIRA)&lt;/p&gt;



&lt;p&gt;&amp;#8211; &lt;br/&gt;
--Noble Paul&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12361944">SOLR-139</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12401044">SOLR-660</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12361331" name="SOLR-269-UpdateRequestProcessorFactory.patch" size="54923" author="ryantxu" created="Fri, 6 Jul 2007 23:46:51 +0100"/>
                            <attachment id="12361261" name="SOLR-269-UpdateRequestProcessorFactory.patch" size="46417" author="ryantxu" created="Fri, 6 Jul 2007 05:27:52 +0100"/>
                            <attachment id="12360309" name="SOLR-269-UpdateRequestProcessorFactory.patch" size="6412" author="ryantxu" created="Thu, 21 Jun 2007 18:43:58 +0100"/>
                            <attachment id="12386858" name="SOLR-269-simple.patch" size="7645" author="noble.paul" created="Fri, 25 Jul 2008 08:08:51 +0100"/>
                            <attachment id="12361231" name="UpdateProcessor.patch" size="18450" author="yseeley@gmail.com" created="Thu, 5 Jul 2007 21:53:06 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 3 Jul 2007 01:27:39 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7320</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxsdb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20915</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>