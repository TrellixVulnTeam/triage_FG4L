<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:18:33 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-799/SOLR-799.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-799] Add support for hash based exact/near duplicate document handling</title>
                <link>https://issues.apache.org/jira/browse/SOLR-799</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;Hash based duplicate document detection is efficient and allows for blocking as well as field collapsing. Lets put it into solr. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.apache.org/solr/Deduplication&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/solr/Deduplication&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12405727">SOLR-799</key>
            <summary>Add support for hash based exact/near duplicate document handling</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                    <reporter username="markrmiller@gmail.com">Mark Miller</reporter>
                        <labels>
                    </labels>
                <created>Sat, 4 Oct 2008 03:42:34 +0100</created>
                <updated>Wed, 24 Mar 2010 15:36:44 +0000</updated>
                            <resolved>Tue, 10 Feb 2009 23:32:01 +0000</resolved>
                                                    <fixVersion>1.4</fixVersion>
                                    <component>update</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="12637617" author="markrmiller@gmail.com" created="Tue, 7 Oct 2008 20:25:48 +0100"  >&lt;p&gt;First pass for comments/reaction&lt;/p&gt;</comment>
                            <comment id="12637649" author="ab" created="Tue, 7 Oct 2008 21:57:41 +0100"  >&lt;p&gt;Interesting development in light of &lt;a href=&quot;https://issues.apache.org/jira/browse/NUTCH-442&quot; title=&quot;Integrate Solr/Nutch&quot; class=&quot;issue-link&quot; data-issue-key=&quot;NUTCH-442&quot;&gt;&lt;del&gt;NUTCH-442&lt;/del&gt;&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Some comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;in MD5Signature I suggest using the code from org.apache.hadoop.io.MD5Hash.toString() instead of BigInteger.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;TextProfileSignature should contain a remark that it&apos;s copied from Nutch, since AFAIK the algorithm that it implements is currently used only in Nutch.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;in Nutch the concept of a page Signature is only a part of the deduplication process. The other part is the algorithm to decide which copy to keep and which one to discard. In your patch the latest update always removes all other documents with the same signature. IMHO this decision should be isolated into a DuplicateDeletePolicy class that gets all duplicates and can decide (based on arbitrary criteria) which one to keep, with the default implementation that simply keeps the latest document.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12637719" author="markrmiller@gmail.com" created="Wed, 8 Oct 2008 01:02:14 +0100"  >&lt;p&gt;Thanks for the review Andrzej. I&apos;ve made the first two changes (I put at the top of TextProfileSignature that its &apos;borrowed&apos; from Nutch and grabbed Hadoops MD5Hash class and stripped its Hadoop dependencies) and I&apos;m investigating change 3. I&apos;ll put up another patch in a couple days.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12637965" author="gsingers" created="Wed, 8 Oct 2008 16:36:07 +0100"  >&lt;p&gt;Haven&apos;t looked at the patch, but I agree that it is wise to separate the detection of duplication from the handling of found duplicates.  The default can be to remove all as in the patch, but it should be easy to override.  Scenarios I can see being useful:&lt;br/&gt;
1. Prevent new insert&lt;br/&gt;
2. Remove old (i.e. same as an update works now)&lt;br/&gt;
3.  Note the duplicate on the existing document in a &quot;duplicates&quot; field.  This obviously requires either deleting and re-adding the doc, or Lucene to better support appending/updating fields, maybe via the column-stride payloads (if that ever happens).  No need for this anytime soon.&lt;/p&gt;</comment>
                            <comment id="12637976" author="yseeley@gmail.com" created="Wed, 8 Oct 2008 17:41:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;I agree that it is wise to separate the detection of duplication from the handling of found duplicates&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Though in some implementations (like #2, which may be the default), detecting that duplicate and handling it are truly coupled... forcing a decoupling would not be a good thing in that case.&lt;/p&gt;</comment>
                            <comment id="12638009" author="yseeley@gmail.com" created="Wed, 8 Oct 2008 19:03:13 +0100"  >&lt;p&gt;Some thoughts...&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;How should different &quot;types&quot; be handled (for example when we support binary fields).  For example, different base64 encoders might use different line lengths or different line endings (CR/LF).  Perhaps it&apos;s good enough to say that the string form must be identical, and leave it at that for now?  The alternative would be signatures based on the Lucene Document about to be indexed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It would be nice to be able to calculate a signature for a document w/o having to catenate all the fields together.&lt;br/&gt;
Perhaps change calculate(String content) to something like calculate(Iterable&amp;lt;CharSequence&amp;gt; content)?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;An alternative option would be incremental hashing...&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Signature sig = ourSignatureCreator.create();
sig.add(f1)
sig.add(f2)
sig.add(f3)
&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s = sig.getSignature()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at how TextProfileSignature works, i&apos;d lean toward incremental hashing to avoid building yet another big string. Having a hashing object also opens up the possibility to easily add other method signatures for more efficient hashing.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It appears that if you put fields in a different order that the signature will change&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It appears that documents with different field names but the same content will have the same signature.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I don&apos;t understand the dedup logic in DUH2... it seems like we want to delete by id and by sig... unfortunately there is no&lt;br/&gt;
  IndexWriter.updateDocument(Term[] terms, Document doc) so we&apos;ll have to do a separate non-atomic delete on the sig for now, right?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;There&apos;s probably no need for a separate test solrconfig-deduplicate.xml if all it adds is an update processor.  Tests could just explicitly specify the update handler on updates.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12638048" author="markrmiller@gmail.com" created="Wed, 8 Oct 2008 20:44:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;I agree that it is wise to separate the detection of duplication from the handling of found duplicates&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;Though in some implementations (like #2, which may be the default), detecting that duplicate and handling it are truly coupled... forcing a decoupling would not be a good thing in that case.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Still looking at this. Was hoping to avoid any of the old &apos;if solr crashes you can have 2 docs with same id in the index&apos; type stuff. Guess I won&apos;t easily get away with that &amp;lt;g&amp;gt; Hopefully we can make it so the default implementation can still be as efficient and atomic.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How should different &quot;types&quot; be handled (for example when we support binary fields). For example, different base64 encoders might use different line lengths or different line endings (CR/LF). Perhaps it&apos;s good enough to say that the string form must be identical, and leave it at that for now? The alternative would be signatures based on the Lucene Document about to be indexed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, may be best to worry about it when we support binary fields...would be nice to look forward though. I think returning a byte[] rather than a String will future proof the sig implementations a bit along those lines (though doesn&apos;t address your point)...still mulling - this shouldn&apos;t trip up Fuzzy hashing implementations to much, and so how exact should MD5Signature be...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;*  It appears that if you put fields in a different order that the signature will change&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;* It appears that documents with different field names but the same content will have the same signature.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Two good points I have addressed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It would be nice to be able to calculate a signature for a document w/o having to catenate all the fields together.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Perhaps change calculate(String content) to something like calculate(Iterable&amp;lt;CharSequence&amp;gt; content)?&lt;/p&gt;

&lt;p&gt;I like the idea of incremental as well.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t understand the dedup logic in DUH2... it seems like we want to delete by id and by sig... unfortunately there is no&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;IndexWriter.updateDocument(Term[] terms, Document doc) so we&apos;ll have to do a separate non-atomic delete on the sig for now, right?&lt;/p&gt;

&lt;p&gt;Another one I was hoping to get away with. My current strategy was to say that setting an update term means that updating by id is overridden and &lt;b&gt;only&lt;/b&gt; the update Term is used - effectively, the update Term (signature) becomes the update id - and you can control whether the id factors into that update signature or not.  Didn&apos;t get passes the goalie I suppose &amp;lt;g&amp;gt; I guess I give up on clean atomic imp and perhaps investigate update(terms[], doc) for the future. I wanted to deal with both signature and id, but figured its best to start with most efficient bare bones and work out.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There&apos;s probably no need for a separate test solrconfig-deduplicate.xml if all it adds is an update processor. Tests could just explicitly specify the update handler on updates.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Its mainly for me at the moment (testing config settings loading and what not), I&apos;ll be sure to pull it once the patch is done.&lt;/p&gt;

&lt;p&gt;Thanks for all of the feedback.&lt;/p&gt;</comment>
                            <comment id="12638217" author="ab" created="Thu, 9 Oct 2008 08:27:25 +0100"  >&lt;p&gt;+1 on the incremental sig calculation.&lt;/p&gt;

&lt;p&gt;Re: different &quot;types&quot; of signatures. Our experience in Nutch is that signature type is rarely changed, and we assume that this setting is selected once per lifetime of an index, i.e. there are never any mixed cases of documents with incompatible signatures. If we want to be sure that they are comparable, we could prepend a byte or two of unique signature type id - this way, even if a signature value matches but was calculated using other impl. the documents won&apos;t be considered duplicates, which is the way it should work, because different signature algorithms are incomparable.&lt;/p&gt;

&lt;p&gt;Re: signature as byte[] - I think it&apos;s better if we return byte[] from Signature, and until we support binary fields we just turn this into a hex string.&lt;/p&gt;

&lt;p&gt;Re: field ordering in DeduplicateUpdateProcessorFactory: I think that both sigFields (if defined) and any other document fields (if sigFields is undefined) should be first ordered in a predictable way (lexicographic?). Current patch uses a HashSet which doesn&apos;t guarantee any particular ordering - in fact the ordering may be different if you run the same code under different JVMs, which may introduce a random factor to the sig. calculation.&lt;/p&gt;</comment>
                            <comment id="12638426" author="hossman" created="Fri, 10 Oct 2008 00:10:24 +0100"  >&lt;p&gt;(disclaimer: haven&apos;t looked at the patch)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Though in some implementations (like #2, which may be the default), detecting that duplicate and handling it are truly coupled... forcing a decoupling would not be a good thing in that case.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t follow your reasoning.  all the usecases i&apos;ve seen mentioned seem like they could/would decouple very nicely...&lt;/p&gt;

&lt;p&gt;1. Prevent new insert &amp;#8211; SignatureUpdateProcessor generates a signature and adds it as a field; AbortIfExistingUpdateProcessor aborts the update if a doc exists with a specific field in common with the doc to be added.&lt;br/&gt;
2. Remove old (i.e. same as an update works now) &amp;#8211; SignatureUpdateProcessor as mentioned before, and signature field is used as the uniqueKey field.&lt;br/&gt;
3. Note the duplicate on the existing document in a &quot;duplicates&quot; field &amp;#8211; SignatureUpdateProcessor as mentioned before; AnnotateDuplicatesProcessor checks for existing docs with a specific field in common with the doc to be added and executes additional opperations to &quot;udpate&quot; those docs, as well as the doc to be added.&lt;/p&gt;</comment>
                            <comment id="12638427" author="hossman" created="Fri, 10 Oct 2008 00:20:10 +0100"  >&lt;p&gt;some misc comments from a user perspective based on the current state of the wiki...&lt;/p&gt;

&lt;p&gt;1) rather then a comma seperated &amp;lt;str&amp;gt; fields, we should just use an &amp;lt;arr&amp;gt;&lt;/p&gt;

&lt;p&gt;2) we should consider if/how we want to support using dynamicFields (ie: field name globs) in listing fields that are included in the signature)&lt;/p&gt;

&lt;p&gt;3) &quot;By default, all non null fields on the document will be used.&quot; ... there&apos;s no such thing as a null field &amp;#8211; there are fields that have no value, and there are fields whose value is an empty string, but no null value.&lt;/p&gt;

&lt;p&gt;4) yonik already asked other questions i had based on the wiki: how the order of fields in the update command affects the signature that gets computed &amp;#8211; both in terms of fields with different names, and fields with the same name.  the fields should probably be stable sorted by field name, so that the order of fields with teh same name affects the signature, but the relative order of fields with different names doesn&apos;t (since the order of fields with the same name actually affects the way the document is indexed, but the order of different field names does not)&lt;/p&gt;</comment>
                            <comment id="12638850" author="markrmiller@gmail.com" created="Sun, 12 Oct 2008 15:41:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;1. Prevent new insert - SignatureUpdateProcessor generates a signature and adds it as a field; AbortIfExistingUpdateProcessor aborts the update if a doc exists with a specific field in common with the doc to be added.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like the idea of using UpdateProcessors for all of this. Its very clean compared to hacking around the DirectUpdateHandler. Unfortunately, I think AbortIfExistingUpdateProcessor would require locks that are too course. Ideally, you want to be able to inject code into the DirectUpdateHandlers 3 levels of locking (iw,sync(this),none). Thats whats needed for efficiency, but the cleanness gets whacked - its ugly to get that done, and doesn&apos;t really mesh with the UpdateHandler API thats been defined. The linking of DirectUpdateHandlers2&apos;s addDoc implementation to the whole idea...there would have to be changes that just don&apos;t seem worth the added functionality.&lt;/p&gt;

&lt;p&gt;Which leaves just hardcoding the support into DirectUpdateHandler, kind of like was done before for deletes/id dupes, and then just give options on the add doc cmd. Again I don&apos;t like it. But the anything else quickly breaks down for me. Any suggestions, insights?&lt;/p&gt;</comment>
                            <comment id="12639304" author="hossman" created="Tue, 14 Oct 2008 06:02:22 +0100"  >&lt;p&gt;If we assume for a minute that users who want to prevent or overwrite duplicates using a signature should always use the signature field as their uniqueKey, then doesn&apos;t use case#1 simplify to just running using a SignatureUpdateProcessor and then another processor that forces &quot;allowDups=false,overwritePending=false,overwriteCommitted=false&quot; ?&lt;/p&gt;

&lt;p&gt;Conceptually that seems right ... but at the moment DIH2 doesn&apos;t seem to care about allowDups at all (it only looks at overwriteCommitted and overwritePending to decide if it&apos;s allowing duplicates) and i&apos;m not sure how to make it work off the top of my head, but assuming we need to muck with DIH2 internals in some way to make signatures (and aborting if the signature already exists) work, implementing the changes to happen for those combination of existing options seems like the cleanest approach.: the functional changes to DIH2 become generally useful to anyone who doesn&apos;t want to overwrite existing docs with the same id, regardless of whether they are computing a signature.&lt;/p&gt;

&lt;p&gt;the only hangup is whether we&apos;re okay with the initial assumption: that users who want duplicate detection by signature are willing to use the signature as the uniqueKey.  If not then perhaps the cleanest way to support that would be to add more generalized &quot;unique field&quot; support ... a list of field names in the schema.xml and a (hopefully) simple call writer.deleteDocuments(Term[]) call in DIH2 should do the trick right?  ... this could also be potentially useful to people for other purposes besides signatures, but i haven&apos;t thought throw all the permutations so i&apos;m sure there would be funky corner cases.&lt;/p&gt;
</comment>
                            <comment id="12639456" author="otis" created="Tue, 14 Oct 2008 16:41:42 +0100"  >&lt;p&gt;Haven&apos;t looked at the patch yet.&lt;br/&gt;
Have looked at the Deduplication wiki page (and realize the stuff I&apos;ll write below is briefly mentioned there).&lt;br/&gt;
Have skimmed the above comments.&lt;/p&gt;

&lt;p&gt;I want to bring up the use case that seems to have been mentioned already, but only in passing.  The focus of the previous comments seems to be on index-time duplication detection.  Another huge use case is search-time near-duplicate detection.  Sometimes it&apos;s about straight forward field collapsing (collapsing adjacent docs with identical values in some field), but sometimes it&apos;s more complicated.&lt;/p&gt;

&lt;p&gt;For example, sometimes multiple fields need to be compared.  Sometimes they have to be identical for collapsing to happen.  Sometimes they only need to be &quot;similar&quot;.  How similarity is calculated is very application-dependent.  I believe this similarity computation has to be completely open/extensible/overridable, allowing one to write a custom search component, examine returned hits and compare them using app-specific similarity....&lt;/p&gt;

&lt;p&gt;Ideally one would have the option not to save the document/field at index-time (for examination at search-time), since that prevents one from experimenting and dynamically changing the similarity computation.&lt;/p&gt;

&lt;p&gt;Here is one example.  Imagine a field called &quot;IDs&quot; that can have 1 or more tokens in it and imagine docs with the following &quot;IDs&quot; get returned:&lt;/p&gt;

&lt;p&gt;1) id:aaa&lt;br/&gt;
2) id:bbb&lt;br/&gt;
3) id:ccc ddd&lt;br/&gt;
4) id:aaa bbb&lt;br/&gt;
5) id:eee ddd&lt;br/&gt;
6) id:aaa&lt;/p&gt;

&lt;p&gt;A custom similarity may look at all of the above (e.g. a page&apos;s worth of hits) and decide that:&lt;br/&gt;
1) and 4) are similar&lt;br/&gt;
2) and 4) are also similar&lt;br/&gt;
3) and 5) are similar&lt;br/&gt;
1) and 4) and 6) are similar&lt;/p&gt;

&lt;p&gt;Another custom similarity may say that only 1) and 6) are similar because they are identical.&lt;/p&gt;

&lt;p&gt;My point is really that we have to leave it up to the application to provide similarity implementation, just like we make it possible for the app to provide a custom Lucene Similarity.&lt;/p&gt;

&lt;p&gt;Is the goal of this issue to make this possible?&lt;/p&gt;</comment>
                            <comment id="12639470" author="yseeley@gmail.com" created="Tue, 14 Oct 2008 17:19:33 +0100"  >&lt;p&gt;&quot;overwriting&quot; is implemented and supported in Lucene now (and we gain a number of benefits from using that).  Conditionally adding a document, or testing if a document already exists, is not supported.&lt;/p&gt;

&lt;p&gt;Since we can&apos;t currently determine if something is a duplicate, it seems like this issue should go ahead with just a single option: whether to remove older documents with the same signature or not.&lt;/p&gt;
</comment>
                            <comment id="12639474" author="yseeley@gmail.com" created="Tue, 14 Oct 2008 17:21:29 +0100"  >&lt;p&gt;Otis: this issue only handles the index side of things.  The signature generating class is pluggable.  Is there anything else needed on the indexing side?&lt;/p&gt;</comment>
                            <comment id="12639479" author="otis" created="Tue, 14 Oct 2008 17:39:40 +0100"  >&lt;p&gt;Thanks Yonik.  Good thing I asked for the clarification, since Marks&apos; issue description does mention search-time stuff (field collapsing).&lt;/p&gt;

&lt;p&gt;Mark: Do you still plan on tackling search-time duplicate/near-duplicate/similar doc detection?  In a separate issue?  Thanks.&lt;/p&gt;</comment>
                            <comment id="12642245" author="markrmiller@gmail.com" created="Thu, 23 Oct 2008 20:37:09 +0100"  >&lt;p&gt;I find the pluggable replace/prevent/append policy idea appealing, but I have not yet found a great way to plug it into the UpdateHandler. Any approach other than sub-classing DirectUpdateHandler2 appears to lead to tying an IndexWriter to UpdateHandler. There is a connection now, UpdateHandler has a method to create a main IndexWriter, but further tying seems wrong without a stronger reason. That point is arguable, but in the end, sub-classing results in simpler code in any case. The trade off is that now you have a PreventDupesDirectUpdateHandler that extends DirectUpdateHandler2. This would have to be used in combination with the SignatureUpdateProcessor if you want to prevent dupes from entering the index. Other use cases (other than overwriting) would require another UpdateHandler. Less than ideal in both cases (subclassing, pluggable interface/class).&lt;/p&gt;

&lt;p&gt;Both approaches lead to less than ideal solutions beyond that as well . Because many docs that have been added to Solr might not yet be visible to an IndexReader, you have to keep a pending commit set of docs to check against. This list should be resilient against AddDoc, DelDocWquery, AddDoc, Commit. You&apos;d essentially have to keep a mini index around to search against to accomplish this, due to delete by query. The other options are to either auto-commit sans a user commit before a delete, or just say we don&apos;t support that use case when using that UpdateHandler. None of it is very pretty.&lt;/p&gt;

&lt;p&gt;Another option is to do things with an UpdateProcessor. This is the most elegant solution really, but it requires putting big,coarse syncs around the more precise syncs in DirectUpdateHandler2. That may not be a huge deal, I am not sure. The previous two options allow you to maintain similar syncs as to what is already there. Beyond that,  the UpdateProcessor approach still has the delete by query issues.&lt;/p&gt;

&lt;p&gt;Maybe we just do overwrite dupe for now? It has none of these issues. I am open to whatever path you guys want. The other use cases do have their place - we will just have to compromise some to get there. Or maybe there are other suggestions?&lt;/p&gt;

&lt;p&gt;Another point that was brought up is whether or not to delete any docs that match the update docs uniqueField id term, but not its similarity/update term. At the current moment, IMO, we shouldn&apos;t. You are choosing to use the updateTerm to do updates rather then the unique term. This allows you to have duplicate signatures but also uniqueField Ids for other operations (say delete). Also, if you already have a unique field that your using, it may be desirable to do dupe detection with a different field. There is always the option of setting the signature field to the uniqueField term. In the end, your call, I&apos;ll add it if we want it.&lt;/p&gt;

&lt;p&gt;As far as search time dupe collapsing, I think I could see a search component that takes the page numbers to collapse (start, end) and does dupe elimination on that range at query time. It wouldn&apos;t be very fast, and I&apos;m not sure how useful page at a time collapsing is, but it would be fairly easy to do. Not sure that it fits into this issue, but certainly could share some of its classes.&lt;/p&gt;
</comment>
                            <comment id="12643966" author="markrmiller@gmail.com" created="Thu, 30 Oct 2008 14:00:11 +0000"  >&lt;p&gt;Whoops...thought I had posted this. Heres another draft I did a couple weeks ago.&lt;/p&gt;

&lt;p&gt;Fixes most of the comments brought up. There will need to be another draft - leaving the schema test file in for now as its still helpful to me.&lt;/p&gt;

&lt;p&gt;No prevent/append etc options here due to all the issues I mentioned, but I do have unposted code experimenting in the different directions if we want to try to go there anyway.&lt;/p&gt;</comment>
                            <comment id="12645061" author="yseeley@gmail.com" created="Tue, 4 Nov 2008 20:06:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;Maybe we just do overwrite dupe for now?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1, as long as we don&apos;t do anything to preclude the other stuff - we just need to leave &quot;room&quot; in the config XML and the update API such that we don&apos;t have to break the back compatibility of this patch if/when future features are implemented.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Another point that was brought up is whether or not to delete any docs that match the update docs uniqueField id term, but not its similarity/update term.  You are choosing to use the updateTerm to do updates rather then the unique term.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It seems like uniqueField should normally enforce uniqueness, regardless of what this component does.  If one wants duplicate ids, then it seems like a different field should be used for that (other than the uniqueKey field).  If one wants to delete &lt;b&gt;only&lt;/b&gt; on the hash field, then they can make the hash field the id field.&lt;/p&gt;</comment>
                            <comment id="12645073" author="markrmiller@gmail.com" created="Tue, 4 Nov 2008 20:44:45 +0000"  >&lt;p&gt;Ok. I cant muster up much of a defense for leaving it out I suppose.&lt;/p&gt;

&lt;p&gt;I&apos;ll polish off a final patch.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On Nov 4, 2008, at 3:06 PM, &quot;Yonik Seeley (JIRA)&quot; &amp;lt;jira@apache.org&amp;gt;  &lt;/p&gt;
</comment>
                            <comment id="12646417" author="hossman" created="Tue, 11 Nov 2008 00:03:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;It seems like uniqueField should normally enforce uniqueness, regardless of what this component does.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;agreed.&lt;/p&gt;

&lt;p&gt;Whilei can imagine use cases for adding a signature field that is independent from the uniqueKey field (ie: query time duplicate pruning/collapsing) I&apos;m having a really hard time thinking of any use cases where someone would need special deletion logic on a (non uniqueKey) signature field.  if you want docs with identical signatures deleted, why wouldn&apos;t you make that the uniqueKey field? ... if you have both, you could really confuse the hell out of someone who doesn&apos;t understand why adding one doc deleted a different doc with a completely different uniqueKey.&lt;/p&gt;</comment>
                            <comment id="12647148" author="markrmiller@gmail.com" created="Thu, 13 Nov 2008 01:10:17 +0000"  >&lt;p&gt;This ensures the id field stays unique. Are there any other issues that need to be addressed? If not I&apos;ll work up one last patch removing the test config file and possibly adding a couple more tests.&lt;/p&gt;</comment>
                            <comment id="12649826" author="markrmiller@gmail.com" created="Fri, 21 Nov 2008 22:10:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;There&apos;s probably no need for a separate test solrconfig-deduplicate.xml if all it adds is an update processor. Tests could just explicitly specify the update handler on updates.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Now that I look to fix this, I am not understanding - I don&apos;t need to change the update handler, I need to change the update chain...I am not seeing how that can be done dynamically...is it possible? If not I think I need the config xml.&lt;/p&gt;</comment>
                            <comment id="12652815" author="markrmiller@gmail.com" created="Wed, 3 Dec 2008 14:52:09 +0000"  >&lt;p&gt;I&apos;m going to put up another patch for this soon. I&apos;d like to have some getters on the factory for manual exploration of the settings.&lt;/p&gt;</comment>
                            <comment id="12652836" author="yseeley@gmail.com" created="Wed, 3 Dec 2008 15:51:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;Now that I look to fix this, I am not understanding - I don&apos;t need to change the update handler, I need to change the update chain...I am not seeing how that can be done dynamically...is it possible?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, you can dynamically change an update processor: update.processor=hash&lt;/p&gt;</comment>
                            <comment id="12652837" author="markrmiller@gmail.com" created="Wed, 3 Dec 2008 15:56:35 +0000"  >&lt;p&gt;Okay, I see. I was too intent on changing the current chain - problem indeed goes away by just plugging in an entirely new chain.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;edit&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;So it looks like I can change the UpdateRequestProcessorChain.chain because its package protected. So I can make a new chain in the test rather than add a config file - but I lose the testing of the parsing of the config settings for the SignatureUpdateProcessor. I suppose I am not so attached them, but I kind of like the idea of some of that hitting a test...no? &lt;/p&gt;</comment>
                            <comment id="12652923" author="ryantxu" created="Wed, 3 Dec 2008 19:39:22 +0000"  >&lt;p&gt;I&apos;m not sure how you have the test set up, so I could be way off base.&lt;/p&gt;

&lt;p&gt;You could subclass SearchHandler and set the protected List&amp;lt;SearchComponent&amp;gt; components directly...&lt;/p&gt;
</comment>
                            <comment id="12653484" author="yseeley@gmail.com" created="Thu, 4 Dec 2008 21:06:14 +0000"  >&lt;p&gt;Why not plug in an entirely new chain?  That is one of the way it would be done for users of this component, right?&lt;/p&gt;

&lt;p&gt;  &amp;lt;updateRequestProcessorChain name=&quot;hash&quot;&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And then in the test send in update.processor=hash as a parameter.&lt;/p&gt;</comment>
                            <comment id="12669720" author="markrmiller@gmail.com" created="Mon, 2 Feb 2009 19:49:18 +0000"  >&lt;p&gt;This patch fixes some oddness with how the enabled setting worked and removes the test solrconfig.xml file that was added.&lt;/p&gt;

&lt;p&gt;Wiki has been updated as well.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12672453" author="yseeley@gmail.com" created="Tue, 10 Feb 2009 23:32:01 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed so that all values of a multi-valued field are included in the hash&lt;/li&gt;
	&lt;li&gt;changed so that no string additions are done for performance&lt;/li&gt;
	&lt;li&gt;moved HEX_CHARS to StrUtils&lt;/li&gt;
	&lt;li&gt;changed &quot;fields&quot; to be a comma separated list (per the wiki documentation... this may be more consistent if we allow this to be specified as a request parameter later, but it&apos;s subjective for sure.  we could always add support for both arrays and comma separated lists).&lt;/li&gt;
	&lt;li&gt;changed the hashcode generation to work with any sized hash (was previously hardcoded to 16 bytes)&lt;/li&gt;
	&lt;li&gt;added lookup3ycs &lt;a href=&quot;http://yonik.wordpress.com/2008/06/14/lookup3ycs-a-standard-high-performance-string-hash/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://yonik.wordpress.com/2008/06/14/lookup3ycs-a-standard-high-performance-string-hash/&lt;/a&gt;   lookup3ycs can do hashes directly on strings (no need to convert to bytes first).  I used the 64 bit variant, which is more than enough to prevent false collisions, and it resulted in a 27% speedup in total indexing time (after removing other cruft from the schema such as copyFields and default values).&lt;/li&gt;
	&lt;li&gt;tested with 10M documents to verify that no collisions occur with both MD5 and lookup3&lt;/li&gt;
	&lt;li&gt;Committed!  Thanks Mark!  And thanks to everyone else for the great feedback.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12675748" author="lancenorskog" created="Mon, 23 Feb 2009 03:17:38 +0000"  >&lt;p&gt;I came into Solr with no search experience and it was quite a learning curve. The modular design of the configuration really helped, and we should maintain that modularity. There are two different designs: the design of the configuration and the design of the implementation. This comment only addresses the design of the configuration files.  &lt;/p&gt;

&lt;p&gt;The patch as committed moves the specification of one field out of schema.xml file to another file. This breaks the modularity of the configurations.  I suggest that the files should look like this:&lt;/p&gt;

&lt;p&gt;schema.xml:&lt;br/&gt;
&amp;lt;field name=&quot;signatureField&quot; type=&quot;signatureField&quot; indexed=&quot;true&quot; stored=&quot;false&quot; signature=&quot;solr.TextProfileSignature&quot; fields=&quot;product_name, model_t, *_s&quot; /&amp;gt;&lt;/p&gt;

&lt;p&gt;solrconfig.xml:&lt;br/&gt;
&amp;lt;updateRequestProcessorChain name=&quot;dedupe&quot;&amp;gt;&lt;br/&gt;
    &amp;lt;processor class=&quot;org.apache.solr.update.processor.SignatureUpdateProcessorFactory&quot;&amp;gt;&lt;br/&gt;
      &amp;lt;string name=&quot;signatureField&quot;&amp;gt;signatureField&amp;lt;/string&amp;gt;&lt;br/&gt;
      &amp;lt;bool name=&quot;enabled&quot;&amp;gt;false&amp;lt;/bool&amp;gt;&lt;br/&gt;
      &amp;lt;bool name=&quot;overwriteDupes&quot;&amp;gt;true&amp;lt;/bool&amp;gt;&lt;br/&gt;
   &amp;lt;/processor&amp;gt;&lt;/p&gt;

&lt;p&gt;   &amp;lt;processor class=&quot;solr.RunUpdateProcessorFactory&quot; /&amp;gt;&lt;br/&gt;
 &amp;lt;/updateRequestProcessorChain&amp;gt;&lt;/p&gt;

&lt;p&gt;That is, the design of the signature field should go in schema.xml, and each updateRequest section should only describe how it is used with that section&apos;s declared name. Also, there should be no default field, since every field in the schema should be described in schema.xml. &lt;/p&gt;
</comment>
                            <comment id="12675770" author="shalinmangar" created="Mon, 23 Feb 2009 05:47:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;&amp;lt;field name=&quot;signatureField&quot; type=&quot;signatureField&quot; indexed=&quot;true&quot; stored=&quot;false&quot; signature=&quot;solr.TextProfileSignature&quot; fields=&quot;product_name, model_t, *_s&quot; /&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think signatureField is a separate type. It is just a string, right?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The patch as committed moves the specification of one field out of schema.xml file to another file.&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;That is, the design of the signature field should go in schema.xml, and each updateRequest section should only describe how it is used with that section&apos;s declared name. Also, there should be no default field, since every field in the schema should be described in schema.xml.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The design of the signature field goes into schema.xml right now too. The wiki clearly states the following about signatureField:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
The name of the field used to hold the fingerprint/signature. Be sure the field is defined in schema.xml. 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;&lt;p&gt;&amp;lt;field name=&quot;signatureField&quot; type=&quot;signatureField&quot; indexed=&quot;true&quot; stored=&quot;false&quot; signature=&quot;solr.TextProfileSignature&quot; fields=&quot;product_name, model_t, *_s&quot; /&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t agree with the above. The method of computing the contents of the field should not be part of schema.xml. I do not understand your concern, maybe because I&apos;m not very familiar with this feature.&lt;/p&gt;</comment>
                            <comment id="12676041" author="hossman" created="Mon, 23 Feb 2009 19:56:55 +0000"  >&lt;p&gt;The separation of concerns between schema.xml and solrconfig.xml has always been...&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;schema.xml: what is the data, what is it&apos;s nature, what are it&apos;s intrinsic properties?&lt;/li&gt;
	&lt;li&gt;solrconfig.xml: what can people do with your data, how can they use it?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;fields, fieldTypes, analyzers, copyFields go in the schema.xml because they are (in theory) intrinsic to the nature of your data regardless of where a given document comes from: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;documents should only have one author&lt;/li&gt;
	&lt;li&gt;categoryName should always be tokenized in a particular way&lt;/li&gt;
	&lt;li&gt;prices need to sort numericly not lexigraphicallyy&lt;/li&gt;
	&lt;li&gt;any text indexed in the shortSummary field shoudl also be indexed in the searchableAbstract field&lt;/li&gt;
	&lt;li&gt;etc...&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;request handlers that dictate how people can use the data are specified in solrconfig.xml &amp;#8211; when searching data request handlers (which may leverage search componets) dictate what a user is allowed to get/see;  when modifying an index request handlers (which may leverage update processors) dictate what data is allowed to come from various sources and in what formats.&lt;/p&gt;

&lt;p&gt;In short: as far as document indexing goes, the options configured in solrconfig.xml specify how to &quot;build up&quot; a Document object from user input, while the options in schema.xml specify how to &quot;tear it down&quot; into it&apos;s individual terms and values for indexing.&lt;/p&gt;

&lt;p&gt;With the near duplicate detection code, it is the schema&apos;s job to say which fields can exist in the input documents, including a signature field &amp;#8211;  but it is the solrconfig&apos;s job to decide how to compute that signature field ... after all: the computation might be different depending on the source of the data (ie: different processor chains could be configured for different request handlers)&lt;/p&gt;</comment>
                            <comment id="12775546" author="gsingers" created="Tue, 10 Nov 2009 15:51:48 +0000"  >&lt;p&gt;Bulk close for Solr 1.4&lt;/p&gt;</comment>
                            <comment id="12849091" author="psyence" created="Wed, 24 Mar 2010 07:45:06 +0000"  >&lt;p&gt;Hello,&lt;/p&gt;

&lt;p&gt;For my current project I need to implement an index-time mechanism to detect (near) duplicate documents. The TextProfileSignature available out-of-the-box (&lt;a href=&quot;http://wiki.apache.org/solr/Deduplication&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/solr/Deduplication&lt;/a&gt;) seems alright but does not use global collection statistics in deciding which terms will be used for calculating the signature. &lt;br/&gt;
Most state-of-the-art hash-based duplication detection algorithms make use of this information to improve precision and recall (e.g. &lt;a href=&quot;http://portal.acm.org/citation.cfm?id=506311&amp;amp;dl=GUIDE&amp;amp;coll=GUIDE&amp;amp;CFID=83187370&amp;amp;CFTOKEN=47052122&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://portal.acm.org/citation.cfm?id=506311&amp;amp;dl=GUIDE&amp;amp;coll=GUIDE&amp;amp;CFID=83187370&amp;amp;CFTOKEN=47052122&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Is it possible to access collection statistics - especially IDF values for all non-discarded terms in the current document - from within an implementation of the Signature class?&lt;/p&gt;

&lt;p&gt;Kind regards,&lt;/p&gt;

&lt;p&gt;Thomas&lt;/p&gt;</comment>
                            <comment id="12849225" author="ab" created="Wed, 24 Mar 2010 15:36:44 +0000"  >&lt;p&gt;This issue is closed - please use the mailing lists for discussions.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12399290" name="SOLR-799.patch" size="23570" author="markrmiller@gmail.com" created="Mon, 2 Feb 2009 19:49:18 +0000"/>
                            <attachment id="12393828" name="SOLR-799.patch" size="36523" author="markrmiller@gmail.com" created="Thu, 13 Nov 2008 01:10:17 +0000"/>
                            <attachment id="12393054" name="SOLR-799.patch" size="35833" author="markrmiller@gmail.com" created="Thu, 30 Oct 2008 14:00:11 +0000"/>
                            <attachment id="12391662" name="SOLR-799.patch" size="33835" author="markrmiller@gmail.com" created="Tue, 7 Oct 2008 20:25:48 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 7 Oct 2008 20:57:41 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6824</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxp53:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20392</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>