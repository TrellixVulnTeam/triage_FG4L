<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:15:59 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/SOLR-104/SOLR-104.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[SOLR-104] Update Plugins</title>
                <link>https://issues.apache.org/jira/browse/SOLR-104</link>
                <project id="12310230" key="SOLR">Solr</project>
                    <description>&lt;p&gt;The plugin framework should work for &apos;update&apos; actions in addition to &apos;search&apos; actions.&lt;/p&gt;

&lt;p&gt;For more discussion on this, see:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/Re%3A-Handling-disparate-data-sources-in-Solr-tf2918621.html#a8305828&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Re%3A-Handling-disparate-data-sources-in-Solr-tf2918621.html#a8305828&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12360483">SOLR-104</key>
            <summary>Update Plugins</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hossman">Hoss Man</assignee>
                                    <reporter username="ryantxu">Ryan McKinley</reporter>
                        <labels>
                    </labels>
                <created>Sun, 14 Jan 2007 02:33:58 +0000</created>
                <updated>Fri, 10 May 2013 11:40:06 +0100</updated>
                            <resolved>Mon, 29 Jan 2007 20:38:02 +0000</resolved>
                                    <version>1.2</version>
                                    <fixVersion>1.2</fixVersion>
                                    <component>update</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12464557" author="ryantxu" created="Sun, 14 Jan 2007 03:12:23 +0000"  >&lt;p&gt;I tried my hand at refactoring solr to have a more flexible plugin framework.  &lt;/p&gt;

&lt;p&gt;To apply this patch, you will need to:&lt;br/&gt;
1) apply: HandlerRefactoring.DRAFT.patch&lt;br/&gt;
2) download HandlerRefactoring.DRAFT.zip and extract the contents to:&lt;br/&gt;
    \solr\src\java\org\apache\solr\handler&lt;/p&gt;

&lt;p&gt;(svn patches don&apos; t let you add new directories!)&lt;/p&gt;

&lt;p&gt;All tests pass, and &lt;a href=&quot;http://localhost:8983/solr/select/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/select/&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://localhost:8983/solr/update&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/update&lt;/a&gt; point to the same servlets as before and &lt;b&gt;should&lt;/b&gt; behave exactly as they did before.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I changed the RequestHandlers framework to map &quot;action&quot; &amp;gt; &quot;name&quot; &amp;gt; handler, rather then just &quot;name&quot; &amp;gt; handler&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I added a filter (SolrRequestFilter.java) that gets applied to every request and checks if the path is a registered &quot;action&quot;.  If it is, it will be handled by the RequestHander otherwise it is passed down the filter chain.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I refactored &apos;SolrParams&apos; to handles the general case, not only query params.  I moved the specific params to o.a.s.handler.search.QueryParams.  I deleted a few deprecated parameter options: it just got too messy to refactor depricated things.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I moved the &apos;query&apos; handlers into org.apache.solr.handler.search.*  In general, handlers are in a package with the name of their action.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The generic SolrRequest must somehow encapsulate the posted stream&lt;/li&gt;
	&lt;li&gt;Add cookies, remote host, remote user to the SolrRequest?  (standard requests won&apos;t use them, but custom handlers may have a good use for them)&lt;/li&gt;
	&lt;li&gt;and much much more!&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Usage: &lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/$&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/$&lt;/a&gt;&lt;/p&gt;
{action}
&lt;p&gt;/$&lt;/p&gt;
{handler}
&lt;p&gt;?args&lt;/p&gt;

&lt;p&gt;If no handler is specified, it will use the default handler for that action.&lt;/p&gt;


&lt;p&gt;Current: (still works)&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/select/?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/select/?q=solr&lt;/a&gt;  (current style)&lt;/p&gt;

&lt;p&gt;New: (should be exact same output)&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/search/?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/search/?q=solr&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/search/standard/?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/search/standard/?q=solr&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/search/dismax/?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/search/dismax/?q=solr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://localhost:8983/solr/update2/commit&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/update2/commit&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/update2/optimize&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/update2/optimize&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;note: I am using &apos;search&apos; and &apos;update2&apos; so that the old URL still works and points to what people are used to.&lt;/p&gt;

&lt;p&gt;Document adding stubs:&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/add/xml/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/add/xml/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/add/csv/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/add/csv/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/add/sql/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/add/sql/&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Let me know what you think!&lt;/p&gt;
</comment>
                            <comment id="12464559" author="ryantxu" created="Sun, 14 Jan 2007 04:03:39 +0000"  >&lt;p&gt;I just uploaded: HandlerRefactoring-DRAFT-SRC.zip.  It is not a patch, but it will be easier to integrate with /trunk.&lt;/p&gt;

&lt;p&gt;1) Extract the zip files&lt;br/&gt;
2) Copy them into your solr directory.  Overwrite all files (svn will give you diff)&lt;br/&gt;
3) delete the following files:  (they have been renamed or moved)&lt;/p&gt;

&lt;p&gt;src/java/org/apache/solr/request/DisMaxRequestHandler.java&lt;br/&gt;
src/java/org/apache/solr/request/LocalSolrQueryRequest.java&lt;br/&gt;
src/java/org/apache/solr/request/SolrQueryRequest.java&lt;br/&gt;
src/java/org/apache/solr/request/SolrQueryRequestBase.java&lt;br/&gt;
src/java/org/apache/solr/request/SolrRequestHandler.java&lt;br/&gt;
src/java/org/apache/solr/request/StandardRequestHandler.java&lt;br/&gt;
src/java/org/apache/solr/util/CommonParams.java&lt;br/&gt;
src/java/org/apache/solr/util/DisMaxParams.java&lt;/p&gt;
</comment>
                            <comment id="12464640" author="ryantxu" created="Sun, 14 Jan 2007 23:26:31 +0000"  >&lt;p&gt;I just upload a new version of HandlerRefactoring-DRAFT-SRC.zip&lt;/p&gt;

&lt;p&gt;In addition to the 8 files above, also delete:&lt;br/&gt;
src/java/org/apache/solr/request/SolrQueryResponse.java&lt;br/&gt;
src/webapp/src/org/apache/solr/servlet/SolrServlet.java&lt;br/&gt;
src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java&lt;/p&gt;

&lt;p&gt;There is also a clean copy on:&lt;br/&gt;
  &lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/&lt;/a&gt;&lt;br/&gt;
This should be easier to install - or look at (without having to install)&lt;/p&gt;

&lt;p&gt;This version converts everything to use the new framework rather then keeping /select and /update on the old one.  It also includes a draft proposal on how to deal with deal with GET vs POST body vs multipart content.&lt;/p&gt;

&lt;p&gt;It passes all the tests and seems to work exactly as before (with a few exceptions)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/update content is returned with a ResponseWriter&lt;/li&gt;
	&lt;li&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;my-BUG&amp;#93;&lt;/span&gt; I am unable to get some posted content to read its stream properly.  I had to modify:&lt;br/&gt;
&lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/example/exampledocs/post.sh&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/example/exampledocs/post.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;to call:&lt;br/&gt;
 curl $URL --data-binary &apos;&amp;lt;commit/&amp;gt;&apos; -H &apos;Content-type:text/xml;&apos; &lt;br/&gt;
rather then just:&lt;br/&gt;
 curl $URL --data-binary &apos;&amp;lt;commit/&amp;gt;&apos;&lt;/p&gt;

&lt;p&gt;(any ideas?)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I define three basic types of request handlers in: &lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/&lt;/a&gt;&lt;br/&gt;
1) standard.  This gets everything from parameters (get or post) &lt;br/&gt;
2) posted.  This gets a reader from the posted body:&lt;br/&gt;
&lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/PostedRequestHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/PostedRequestHandler.java&lt;/a&gt;&lt;br/&gt;
3) multipart.  This gets an iterator over each file item using commons-upload streaming API&lt;br/&gt;
&lt;a href=&quot;http://jakarta.apache.org/commons/fileupload/streaming.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jakarta.apache.org/commons/fileupload/streaming.html&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/MultipartRequestHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/MultipartRequestHandler.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I &lt;b&gt;think&lt;/b&gt; this takes care of every case...  is anything missing?&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/webapp/src/org/apache/solr/servlet/SolrRequestFilter.java RequestFilter&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/webapp/src/org/apache/solr/servlet/SolrRequestFilter.java RequestFilter&lt;/a&gt; manages setting the reader or iterator for the proper handlers.&lt;/p&gt;

&lt;p&gt;When you run the example, i added the page &lt;a href=&quot;http://localhost:8983/solr/up.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/up.html&lt;/a&gt; that should help you see a little of it in action.  &lt;/p&gt;

&lt;p&gt;I added an example for each type:&lt;br/&gt;
&lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/add/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/add/&lt;/a&gt;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This added:&lt;br/&gt;
commons-io-1.2.jar&lt;br/&gt;
mysql-connector-java-5.0.4.jar&lt;br/&gt;
commons-fileupload-20070107.jar&lt;/p&gt;

&lt;p&gt;to the library.  If we want to get rid of commons-io, I am only using IOUtils.java&lt;/p&gt;











</comment>
                            <comment id="12464653" author="skeptikos" created="Mon, 15 Jan 2007 04:47:46 +0000"  >&lt;p&gt;I think this is a fantastic effort, so please take my comments and suggestions for improvement below in the context of my appreciation you took the time to wade deeply into the SOLR request-handling code looking for places to improve it.  If the request structure is cleaned up along these lines it will make it much simpler for people to develop and contribute alternate request handlers (both update and query varieties) and further SOLRs standing as an open-source community-driven project.&lt;/p&gt;

&lt;p&gt;1. I really like your idea of using the URL suffix to specify the handler.  But it looks like you have required this to be a fixed 2-level hierarchy, with URLs of the form&lt;/p&gt;

&lt;p&gt;    http://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;solr-root&amp;gt;/&amp;lt;action&amp;gt;/&amp;lt;handler&amp;gt;&lt;/p&gt;

&lt;p&gt;which are looked up in a handler table keyed by &amp;lt;action&amp;gt; and then &amp;lt;handler&amp;gt;. For example search/standard looks for a &amp;lt;requestHandler action=&quot;search&quot; name=&quot;standard&quot;...&amp;gt;, loads the indicated handler class, and associates it with the config.&lt;/p&gt;

&lt;p&gt;But this hierarchy seems a little overdetermined and the implementation overcomplex.  It could be argued that one would want &amp;lt;handler&amp;gt;/&amp;lt;action&amp;gt;, for the &amp;lt;handler&amp;gt; alone to resolve to a handler class, and the handler class to be responsible for deciding how to act on the &amp;lt;action&amp;gt; part... but any hierarchical arrangement that makes perfect sense to one person can seem wrong to another. And in your implementation I see no actual action taken by the &amp;lt;action&amp;gt; argument other than selection of a per-&amp;lt;action&amp;gt; default &amp;lt;handler&amp;gt;, and that seems more complexity than it&apos;s worth; there are easier ways.&lt;/p&gt;

&lt;p&gt;I would suggest the simpler approach of simply taking the entire path after &amp;lt;solr-root&amp;gt; to be a handler configuration name,  without conforming it to any fixed hierarchy, e.g. a developer could set up&lt;/p&gt;

&lt;p&gt;	&amp;lt;requestHandler name=&quot;search/products/bysku&quot; class=&quot;...&quot;&amp;gt;...&amp;lt;/&amp;gt;&lt;br/&gt;
	&amp;lt;requestHandler name=&quot;search/products/byname&quot; class=&quot;...&quot;&amp;gt;...&amp;lt;/&amp;gt;&lt;br/&gt;
	&amp;lt;requestHandler name=&quot;search/companies&quot; class=&quot;...&quot;&amp;gt;...&amp;lt;/&amp;gt;&lt;br/&gt;
	&amp;lt;requestHandler name=&quot;index/csv&quot; class=&quot;...&quot;&amp;gt;...&amp;lt;/&amp;gt;&lt;/p&gt;

&lt;p&gt;In that way establishing a command/subcommand hierarchy is entirely up to the user&apos;s solrconfig.xml setup, and there is no imposed logic as to whether the different behavior between the 3 search examples is achieved through different config of the same handler class, different handler classes, or both.&lt;/p&gt;

&lt;p&gt;As for default actions, there is no need for special code, they can entirely be defined in solrconfig.  For example, if a developer sets up a /search/xxx space as above, the response to a client request /search without further qualification is entirely up to what is defined in solrconfig.xml:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If there is no request handler defined under name=&quot;search&quot; SOLR would return a standard &quot;No handler found&quot; message&lt;/li&gt;
	&lt;li&gt;If it has a query request handler under that name (e.g. with name=&quot;search&quot; class=&quot;solr.StandardRequestHandler&quot;) it would get to handle less-qualified requests with developer-defined defaults.&lt;/li&gt;
	&lt;li&gt;It could be defined to explicitly invoke your UnavailableRequestHandler &amp;#8211; a great idea which should be extended so the error code and error message could be custom-configured with handler config params.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Thus I think this free-form hierarchy would achieve greater simplicity and greater flexibility at the same time.&lt;/p&gt;

&lt;p&gt;2. What would make this even more powerful would be the ability to &quot;subclass&quot; (meaning refine and/or extend) request handler configs: If the requestHandler element allowed an attribute extends=&quot;&amp;lt;another-requesthandler-name&amp;gt;&quot; and chained the SolrParams, then one could do something like:&lt;/p&gt;

&lt;p&gt;  &amp;lt;requestHandler name=&quot;search/products/all&quot; class=&quot;solr.DisMaxRequestHandler&quot; &amp;gt;&lt;br/&gt;
    &amp;lt;lst name=&quot;defaults&quot;&amp;gt;&lt;br/&gt;
     &amp;lt;float name=&quot;tie&quot;&amp;gt;0.01&amp;lt;/float&amp;gt;&lt;br/&gt;
     &amp;lt;str name=&quot;qf&quot;&amp;gt;&lt;br/&gt;
        text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4&lt;br/&gt;
     &amp;lt;/str&amp;gt;&lt;br/&gt;
     ... much more, per the &quot;dismax&quot; example in the sample solrconfig.xml ...&lt;br/&gt;
  &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;

&lt;p&gt;  ... and replacing the &quot;partitioned&quot; example ...&lt;br/&gt;
  &amp;lt;requestHandler name=&quot;search/products/instock&quot; extends=&quot;search/products/all&quot; &amp;gt;&lt;br/&gt;
    &amp;lt;lst name=&quot;appends&quot;&amp;gt;&lt;br/&gt;
      &amp;lt;str name=&quot;fq&quot;&amp;gt;inStock:true&amp;lt;/str&amp;gt;&lt;br/&gt;
    &amp;lt;/lst&amp;gt;&lt;br/&gt;
  &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;

&lt;p&gt;One could even allow the extending requestHandler to set a different handler class, in the case where the difference in behavior requires a different handler implementation but can share all or part of the params.&lt;/p&gt;

&lt;p&gt;3. Structuring the code and action under /add is conceptually limiting because update-style request plugins such as SQL-based or CSV-based (and certainly XML-based) should still be able to add, replace, and delete, either based on internal logic or external command.&lt;/p&gt;

&lt;p&gt;Your code suggests further refactoring improvements along those lines.  For example, in your SQLUpdateHandler example you call:&lt;/p&gt;

&lt;p&gt;    AddUpdateCommand cmd = UpdateUtils.getAddUpdateCommandFromParams( params );&lt;/p&gt;

&lt;p&gt;and then for each assembled Document&lt;/p&gt;

&lt;p&gt;    cmd.doc = docmap.toDocument( schema );&lt;br/&gt;
    UpdateUtils.addDoc( cmd );&lt;br/&gt;
	&lt;span class=&quot;error&quot;&gt;&amp;#91;which does SolrCore.getSolrCore().getUpdateHandler().addDoc( cmd );&amp;#93;&lt;/span&gt;&lt;br/&gt;
    addedDocumentCount++;&lt;/p&gt;

&lt;p&gt;Lets say:&lt;/p&gt;

&lt;p&gt;  A. We standardized on action=... as a way to define an action in a param&lt;/p&gt;

&lt;p&gt;  B. A new method UpdateUtils.getUpdateCommandFromParams( params ) would use the action= param to decide which xxxUpdateCommand class to instantiate &amp;#8211; though this might be better placed as a static class method getCommandFromParams defined in UpdateCommand itself.&lt;/p&gt;

&lt;p&gt;(Perhaps once it decodes the action param it could call another UpdateCommand static method getCommandFromString( name ), which would centralize the instantiation logic, and provide a pathway for it it to evolve into a name-&amp;gt;class soft mapping should extensibility to other commands ever be desired.)&lt;/p&gt;

&lt;p&gt;  C. Responsibility for initializing each update command from params would be the responsibility of the xxxUpdateCommand itself, e.g. base class UpdateCommand would define an abstract initializeFromParams( params ) which each subclass would implement.&lt;/p&gt;

&lt;p&gt;  D. Responsibility for executing each update command would also lay with the xxxUpdateCommand via an abstract execute() method, which for AddUpdateCommand would be:&lt;/p&gt;

&lt;p&gt;    SolrCore.getSolrCore().getUpdateHandler().addDoc( this );&lt;/p&gt;

&lt;p&gt;(It could be argued that some of the various UpdateHandler functionality should migrate to the xxxUpdateCommands themselves, but that&apos;s another discussion)&lt;/p&gt;

&lt;p&gt;  E. The DeleteUpdateCommand could allow the target record to be defined by setting a Document, and using the schema keyfield definition to extract the ID.  The logic could be encapsulated in DeleteUpdateCommand.execute() itself, extracting the keyfield value from the Document and setting it in its own id field before calling getUpdateHandler().delete( cmd ). Or if setters were defined for the internal fields, setDocument(doc) could call setId(id) and not need to keep a reference to the document.  In either case the existing UpdateHandlers don&apos;t even need to know about this new modality.&lt;/p&gt;

&lt;p&gt;Then SQLUpdateHandler or CSVUpdateHandler or whatever (which should really be called xxxRequestHandler since UpdateHandler is quite another beast) would be agnostic as to whether they are doing adds or deletes of the selected rows; they could just ask for an UpdateCommand implementation, and in a loop set the constructed Document, and call updateCommand.execute().  While it would be most efficient if for deletes the query or data file only specified a single keyfield column, there is no harm in creating Documents with many more fields and simply ignoring all but the keyfield.&lt;/p&gt;

&lt;p&gt;Either way one could set up an explicit deletion-only CSV handler:&lt;/p&gt;

&lt;p&gt;    &amp;lt;!-- Could be csv/delete, delete/csv, product/delete, or whatever --&amp;gt;&lt;br/&gt;
    &amp;lt;requestHandler name=&quot;csv/delete&quot; class=&quot;solr.CSVUpdateHandler&quot;&amp;gt;&lt;br/&gt;
        &amp;lt;lst name=&quot;invariants&quot;&amp;gt;&lt;br/&gt;
            &amp;lt;str name=&quot;action&quot;&amp;gt;delete&amp;lt;/str&amp;gt;&lt;br/&gt;
	&amp;lt;/lst&amp;gt;&lt;br/&gt;
    &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;

&lt;p&gt;or more flexibly allow the parameter to be passed in a URL query param:&lt;/p&gt;

&lt;p&gt;    /&amp;lt;solr-root&amp;gt;/update/product?action=delete&amp;amp;...&lt;/p&gt;

&lt;p&gt;4. Similarly with this structure your CommitHandler and OptimizeHandler classes can be replaced with a simple CommandHandler which is defined in solrconfig; it could even handle deletion by ID or query:&lt;/p&gt;

&lt;p&gt;    &amp;lt;requestHandler name=&quot;commit-and-flush&quot; class=&quot;solr.CommandHandler&quot;&amp;gt;&lt;br/&gt;
        &amp;lt;lst name=&quot;invariants&quot;&amp;gt;&lt;br/&gt;
            &amp;lt;str name=&quot;action&quot;&amp;gt;commit&amp;lt;/str&amp;gt;&lt;br/&gt;
            &amp;lt;str name=&quot;waitFlush&quot;&amp;gt;true&amp;lt;/str&amp;gt; &lt;br/&gt;
	&amp;lt;/lst&amp;gt;&lt;br/&gt;
        &amp;lt;lst name=&quot;defaults&quot;&amp;gt;&lt;br/&gt;
            &amp;lt;str name=&quot;waitSearcher&quot;&amp;gt;false&amp;lt;/str&amp;gt;&lt;br/&gt;
	&amp;lt;/lst&amp;gt;&lt;br/&gt;
    &amp;lt;/requestHandler&amp;gt;&lt;/p&gt;

&lt;p&gt;5. Of course a RequestHandler could be non-command-agnostic as well, for example the XML update parsing code now in SolrCore.update() could be recast as a RequestHandler which reads the &amp;lt;add&amp;gt;, &amp;lt;delete&amp;gt;, &amp;lt;commit&amp;gt;, &amp;lt;optimize&amp;gt; tags and decides itself which type of UpdateCommand(s) to instantiate (using UpdateCommand.getCommandFromString as described above).&lt;/p&gt;

&lt;p&gt;But it could be made more agnostic and simpler still, for example by parsing the action and parameters from XML into a SolrParams and calling getCommandFromParams as described above.  That would forge a path for other non-XML command-stream-based  update handlers by leaving only XML parsing logic in the XML update RequestHandler &amp;#8211; all the rest of the logic would be in UpdateCommand, the UpdateCommand implementations, and UpdateHandler.&lt;/p&gt;

&lt;p&gt;Anyway, those are some ideas, for what they&apos;re worth.&lt;/p&gt;</comment>
                            <comment id="12464654" author="skeptikos" created="Mon, 15 Jan 2007 05:01:31 +0000"  >&lt;p&gt;6. I may be going a little crazy with this soft-configuration concept, but thinking about how to support the legacy&lt;/p&gt;

&lt;p&gt;    /select?qt=faceted...&lt;/p&gt;

&lt;p&gt;format leads me to think there could be a trivial (3-line handleRequestBody) NamedRequestHandler which uses one parameter to provide the name of another parameter which names another requestHandler definition which it would then invoke.  With that,&lt;/p&gt;

&lt;p&gt;	&amp;lt;requestHandler name=&quot;select&quot; class=&quot;solr. NamedRequestHandler&quot;&amp;gt;&lt;br/&gt;
	    &amp;lt;lst name=&quot;invariants&quot;&amp;gt;&lt;br/&gt;
		&amp;lt;str name=&quot;handlerNameParameter&quot;&amp;gt;qt&amp;lt;/str&amp;gt;&lt;br/&gt;
	    &amp;lt;/lst&amp;gt;&lt;br/&gt;
	    &amp;lt;lst name=&quot;defaults&quot;&amp;gt;&lt;br/&gt;
		&amp;lt;str name=&quot;qt&quot;&amp;gt;standard&amp;lt;/str&amp;gt;&lt;br/&gt;
	    &amp;lt;/lst&amp;gt;&lt;br/&gt;
	&amp;lt;/requestHandler&amp;gt;&lt;/p&gt;

&lt;p&gt;would allow /select?qt=dismax... to be soft-implemented; a developer who had no use for the non-URL-path selectors could strip it out, another developer who wanted to use a different parameter to set the handler could define it that way.&lt;/p&gt;</comment>
                            <comment id="12464655" author="yseeley@gmail.com" created="Mon, 15 Jan 2007 05:07:24 +0000"  >&lt;p&gt;I haven&apos;t had a chance to look at all this stuff yet, but we should take care to not try and implement too much.&lt;br/&gt;
In some cases the right &quot;plugin&quot; mechanism might be the servlet spec and web.xml (made me think of it when I saw the &quot;cookies&quot; comment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12464667" author="ryantxu" created="Mon, 15 Jan 2007 07:05:27 +0000"  >&lt;p&gt;I agree with points J.J&apos;s points 1-6.  thanks&lt;/p&gt;

&lt;p&gt;If one were to look at only one thing, the stuff i to look at woud be how Handlers get their parameters and content streams. &lt;/p&gt;

&lt;p&gt;from my previous post:&lt;/p&gt;

&lt;p&gt;I define three basic types of request handlers in: &lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/&lt;/a&gt;&lt;br/&gt;
1) standard. This gets everything from parameters (get or post)&lt;br/&gt;
2) posted. This gets a reader from the posted body:&lt;br/&gt;
&lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/PostedRequestHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/PostedRequestHandler.java&lt;/a&gt;&lt;br/&gt;
3) multipart. This gets an iterator over each file item using commons-upload streaming API&lt;br/&gt;
&lt;a href=&quot;http://jakarta.apache.org/commons/fileupload/streaming.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jakarta.apache.org/commons/fileupload/streaming.html&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/MultipartRequestHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/MultipartRequestHandler.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;and: &lt;a href=&quot;http://svn.lapnap.net/solr/handler-draft/solr/src/webapp/src/org/apache/solr/servlet/SolrRequestFilter.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.lapnap.net/solr/handler-draft/solr/src/webapp/src/org/apache/solr/servlet/SolrRequestFilter.java&lt;/a&gt;  fills them up.  &lt;/p&gt;

&lt;p&gt;It currently uses instanceof... any other ideas?  &lt;/p&gt;





</comment>
                            <comment id="12465538" author="ryantxu" created="Wed, 17 Jan 2007 20:13:26 +0000"  >&lt;p&gt;I attached &apos;DispatchFilter.patch&apos;  This extracts some stuff from my previous (monstrous) refactoring that will be useful.  I did not refactor anything, but I did:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Added SolrRequestParser interface&lt;/li&gt;
	&lt;li&gt;Added ContentStream interface&lt;/li&gt;
	&lt;li&gt;Extracted common handler code into RequestHandlerBase.&lt;/li&gt;
	&lt;li&gt;Added &apos;getRequestParser() to Handler interface.  The RequestHandlerBase would return a Parser from the &apos;invariant&apos; &apos;rp&apos;&lt;/li&gt;
	&lt;li&gt;modified StandardRequest/DisMaxRequest to use the HandlerBase&lt;/li&gt;
	&lt;li&gt;Added Iterable&amp;lt;ContentStream&amp;gt; getContentStreams() to SolrQueryRequest&lt;/li&gt;
	&lt;li&gt;Added UpdateHandlerRequest that acts as /update  The only difference is the returned format&lt;/li&gt;
	&lt;li&gt;Replaced SolrServelt and UpdateServlet with SolrRequestFilter.  This now dispatches all requests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With the example solrconfig.xml, you can run queries like:&lt;br/&gt;
 &lt;a href=&quot;http://localhost:8983/solr/select/?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/select/?q=solr&lt;/a&gt;&lt;br/&gt;
 &lt;a href=&quot;http://localhost:8983/solr/standard?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/standard?q=solr&lt;/a&gt;&lt;br/&gt;
 &lt;a href=&quot;http://localhost:8983/solr/dismax?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/dismax?q=solr&lt;/a&gt;&lt;br/&gt;
 &lt;a href=&quot;http://localhost:8983/solr/dismax?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/dismax?q=solr&lt;/a&gt;&lt;br/&gt;
 &lt;a href=&quot;http://localhost:8983/solr/instock?q=solr&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/instock?q=solr&lt;/a&gt;&lt;br/&gt;
 &lt;a href=&quot;http://localhost:8983/solr/update&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/update&lt;/a&gt; &lt;/p&gt;


&lt;p&gt;TODO: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;actually build the RequestParser registry.  currently everything returns StandardRequestParser&lt;/li&gt;
	&lt;li&gt;handle multipart requests in StandardRequestParser&lt;/li&gt;
	&lt;li&gt;move update( reader, writer ) out of SolrCore into UpdateRequestHandler&lt;/li&gt;
&lt;/ul&gt;



&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - -&lt;br/&gt;
SVN NOTE: &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;when i tested this patch, I got strange results for the files it added.  Specifically, new files are repeated twice.&lt;/p&gt;

&lt;p&gt;src\java\org\apache\solr\handler\UpdateRequestHandler.java&lt;br/&gt;
 package org.apache.solr.handler;&lt;br/&gt;
 public class UpdateRequestHandler()&lt;/p&gt;
 {
   ...
 }&lt;br/&gt;
&lt;br/&gt;
 package org.apache.solr.handler;&lt;br/&gt;
 public class UpdateRequestHandler()&lt;br/&gt;
 {
   ...
 }

&lt;p&gt;Delete the second copy of the class it it will compile ok.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Is it possible to delete previous file attachments?  I don&apos;t think  HandlerRefactoring.DRAFT.* is useful for anyone to see anymore.&lt;/p&gt;

&lt;p&gt;ryan&lt;/p&gt;



</comment>
                            <comment id="12465563" author="ryantxu" created="Wed, 17 Jan 2007 21:18:05 +0000"  >&lt;p&gt;removed getRequestParser() from Handler interface.&lt;/p&gt;

&lt;p&gt;using &apos;:&apos; in the URL to specify the request parser.&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;http://localhost:8983/solr/standard:requestparser?q=video&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/standard:requestparser?q=video&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NOTE:  it still uses a defalt request parser.&lt;/p&gt;</comment>
                            <comment id="12466273" author="ryantxu" created="Sat, 20 Jan 2007 19:44:24 +0000"  >&lt;p&gt;I just updated DispatchFilter.path to implement most of our discussion on solr-dev&lt;/p&gt;

&lt;p&gt;The implemented URL structure is:&lt;br/&gt;
&lt;a href=&quot;http://$&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://$&lt;/a&gt;&lt;/p&gt;
{host}
&lt;p&gt;:$&lt;/p&gt;
{port}
&lt;p&gt;/$&lt;/p&gt;
{context}/${path/defined/in/solrconfig.xml}:${optional/path/for/handler}?${params}&lt;br/&gt;
&lt;br/&gt;
(If there needs to be a constant between ${context}
&lt;p&gt;  and  $&lt;/p&gt;
{path}
&lt;p&gt; I am ok with it, but i don&apos;t think its necessary.)&lt;/p&gt;

&lt;p&gt;If you get this running, check:&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/test.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/test.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a test page that shows the various methods to get streamed content into the handler&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;with param stream.URL - puts the content of remote url into stream&lt;/li&gt;
	&lt;li&gt;with stream.BODY - puts the content of the parameter into a stream&lt;/li&gt;
	&lt;li&gt;multipart upload.  put the fields into SolrParams and the Files into streams&lt;/li&gt;
	&lt;li&gt;POST with no query string.  - uses the fields to fill SolrParams&lt;/li&gt;
	&lt;li&gt;POST with query string.  - uses the post body as the ContentStream, fills SolrParams from the query string&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think this covers all the normal cases.  If you can think of others, let me know.  I believe things that would iterate over a huge collection of streams should be implemented as a RequestHandler, not as the RequestBuilder&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Things to note:&lt;/p&gt;

&lt;p&gt;1) /select and /update are handled with their same old servlets.  They have just been refactored to LegacyUpdateServlet etc.  I &lt;b&gt;think&lt;/b&gt; the example solrconfig.xml should map /update to the new framework, not the old one.  This would get people who start using solr to use the new framework, but still work for people who don&apos;t map /update in their solrconfig.xml.  This would also require we change the included &apos;post.sh&apos; to use: URL=&lt;a href=&quot;http://localhost:8983/solr/update?stream&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8983/solr/update?stream&lt;/a&gt;  (so the content is read as a stream)&lt;/p&gt;

&lt;p&gt;2) Even when /update is mapped to the legacy servlet, you can map subfolders to the new one.  I included /update/commit in this patch&lt;/p&gt;

&lt;p&gt;3) Configuration?  Where should we configure enable/disable streams?  max file upload size?  upload temp directory?  I REALLY think its a bad idea to enable stream.URL by default.  Although the model is that solr sits in a private network, we know that is not always the case.  It may also be good to configure a required user role to be able to stream.  for example, stream.URL requires isUserInRole( &apos;admin&apos; );&lt;/p&gt;

&lt;p&gt;4) Sending context to handlers.  Some handlers will want/need additional information about the request (headers,user,remote host,path, etc).  In this patch, I add &apos;path&apos; to all requests.  There should be a way for the handler to say what information it needs&lt;/p&gt;


&lt;p&gt;ryan&lt;/p&gt;</comment>
                            <comment id="12466277" author="ryantxu" created="Sat, 20 Jan 2007 20:34:32 +0000"  >
&lt;p&gt;I just thought of something that will make Hoss&apos; blod curl!  I KNOW it&lt;br/&gt;
is a bad idea for things within solr-core, but it would be the&lt;br/&gt;
cleanest/cheapest way to expose the unknown things a potential&lt;br/&gt;
RequestHandler would want from the HttpServletRequest without changing&lt;br/&gt;
the existing API.  It goes like this:&lt;/p&gt;

&lt;p&gt;  SolrRequest solrReq = (build the solr request)&lt;br/&gt;
  solrReq.getContent().put( &quot;HttpServletRequest&quot;, req );&lt;/p&gt;

&lt;p&gt;It would never be used by anything in core.&lt;/p&gt;

&lt;p&gt;The alternative I see is to give each handler some mechanism to tell&lt;br/&gt;
the RequestBuilder what attributes it needs set, then have the&lt;br/&gt;
RequestBuilder put those attributes in the context or solr params.  In&lt;br/&gt;
my opinion, that is a lot of overhead to do stuff that clearly falls&lt;br/&gt;
outside of what solr-core should be doing.&lt;/p&gt;

&lt;p&gt;ryan&lt;/p&gt;</comment>
                            <comment id="12466356" author="ryantxu" created="Sun, 21 Jan 2007 21:40:37 +0000"  >&lt;p&gt;this can replace the special servlet for &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-85&quot; title=&quot;[PATCH] Add update form to the admin screen&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-85&quot;&gt;&lt;del&gt;SOLR-85&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12466357" author="ryantxu" created="Sun, 21 Jan 2007 21:41:19 +0000"  >&lt;p&gt;can be implemented with RequestHandler with ContentStreams&lt;/p&gt;</comment>
                            <comment id="12466358" author="ryantxu" created="Sun, 21 Jan 2007 21:42:09 +0000"  >&lt;p&gt;could be implemented with ContentStreams&lt;/p&gt;</comment>
                            <comment id="12466359" author="ryantxu" created="Sun, 21 Jan 2007 21:47:47 +0000"  >&lt;p&gt;this extracts the common things into RequestHandlerBase&lt;/p&gt;</comment>
                            <comment id="12466912" author="yseeley@gmail.com" created="Wed, 24 Jan 2007 05:58:11 +0000"  >&lt;p&gt;Finally got a chance to review this... it&apos;s really great stuff Ryan!&lt;/p&gt;

&lt;p&gt;Random questions:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;What&apos;s the funny chars at the start of web.xml?&lt;/li&gt;
	&lt;li&gt;Why is there a 2MB upload limit, and why does it only apply to multi-part uploads?  I think I&apos;m missing some background in this area...&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m not going to try and pick out little bugs or suggest little changes to a patch of this scope and size...&lt;br/&gt;
I think we should have more frequent Solr releases, and that the Solr trunk  can have APIs change from one day to the next w/o having to maintaining back-compatibility.&lt;/p&gt;

&lt;p&gt;So since we agree on the direction, I think this patch should be committed and we should work from there.&lt;br/&gt;
I&apos;d like to hear from hoss though, since he was following along more than I was, esp at the start of that marathon thread.&lt;/p&gt;</comment>
                            <comment id="12466913" author="yseeley@gmail.com" created="Wed, 24 Jan 2007 06:01:21 +0000"  >&lt;p&gt;Oh, and where possible, it would be nice to have some unit tests.&lt;br/&gt;
Servlet related stuff is probably too hard, but things like stream.body should be easy.&lt;/p&gt;</comment>
                            <comment id="12466914" author="ryantxu" created="Wed, 24 Jan 2007 06:02:54 +0000"  >&lt;p&gt;If there are funny chars at the start of web.xml, it was an SVN error.&lt;/p&gt;

&lt;p&gt;the 2MB limit is set in solrconfig.xml&lt;/p&gt;

&lt;p&gt;  &amp;lt;requestParsers enableRemoteStreaming=&quot;true&quot; multipartUploadLimitInKB=&quot;2048&quot; /&amp;gt;&lt;/p&gt;

&lt;p&gt;maybe 2MB is too small as the default, but i figured it shoudl be configurable.&lt;/p&gt;
</comment>
                            <comment id="12466928" author="ryantxu" created="Wed, 24 Jan 2007 07:30:28 +0000"  >&lt;p&gt;This is minor changes to the previous filter it &lt;/p&gt;

&lt;p&gt;1. Adds unit tests for stream.BODY and stream.URL&lt;br/&gt;
2. uses different init logic for HandlerBase and DisMax (legacy stuff)&lt;br/&gt;
3. Adds Size() to the content stream.  filled up if we know it otherwise not.&lt;br/&gt;
4. A few comments here and there...&lt;/p&gt;</comment>
                            <comment id="12467305" author="hossman" created="Thu, 25 Jan 2007 09:35:22 +0000"  >&lt;p&gt;Woot! ... i think we&apos;re really close to comiting this. &lt;/p&gt;

&lt;p&gt;I made a hodgepodge list of comments as i read through everything, and then tried to organize them.  I agree with yonik that we should feel free to commit new functionality without being afraid of needing to change the api of that functionality befor the next release, but i&apos;m not 100% comfortable with how backwards compatible this patch is for the existing /select and /update URLs ... this may just be an issue of me being paranoid (and tired) but there&apos;s at least one code path difference.&lt;/p&gt;

&lt;p&gt;Anyway, here are my notes...&lt;/p&gt;





&lt;p&gt;Comments regarding backwards compatibility of the patch...&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SolrCore.update(Reader,Writer) was a public method that&apos;s been&lt;br/&gt;
   removed ... this is probably fine, just pointing it out for the &lt;br/&gt;
   record.&lt;/li&gt;
	&lt;li&gt;SolrUpdateServlet used HttpServletRequest.getReader, the new&lt;br/&gt;
   UpdateRequestHandler uses an InputStreamReader arround&lt;br/&gt;
   HttpServletRequest.getInputStream() ... this seems bad for legacy&lt;br/&gt;
   update support from a char encoding standpoint.&lt;/li&gt;
	&lt;li&gt;While i think it&apos;s important to refactor the XML Update&lt;br/&gt;
   parsing out of SolrCore - I&apos;m still not clear what is gained by &lt;br/&gt;
   eliminating SolrServlet and SolrUpdate.  The big advantage of&lt;br/&gt;
   the new dispatcher being a Filter is that it can pass requests on&lt;br/&gt;
   that it doesn&apos;t want to deal with, so why not leave the existing&lt;br/&gt;
   servlets arround with only the minimum neccessary changes...&lt;/li&gt;
	&lt;li&gt;move SolrCore&apos;s init to Dispatcher&lt;/li&gt;
	&lt;li&gt;use 3 arg core.execute in SolrServlet&lt;/li&gt;
	&lt;li&gt;have SolrUpdateServlet call UpdateRequestHandler.update(Reader)&lt;br/&gt;
      and generate the legacy response XML&lt;br/&gt;
   ...in order to reduce the possibility of an introducing bugs&lt;br/&gt;
   (particularly since the existing Servlets are the one area where we&lt;br/&gt;
   don&apos;t have &lt;b&gt;any&lt;/b&gt; unit tests)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Comments regarding functionality that i think we &lt;b&gt;may&lt;/b&gt; want to address&lt;br/&gt;
before commiting (but i won&apos;t fight over if i&apos;m the only one that cares)...&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;UpdateRequestHandler should probably renamed XmlUpdateRequestHandler&lt;br/&gt;
   (particularly since i expect Yonik to commit a&lt;br/&gt;
   CsvUpdateRequestHandler real soon now) &lt;/li&gt;
	&lt;li&gt;StandardRequestParser can&apos;t assume that a POST which isn&apos;t&lt;br/&gt;
   multipart/* should be handled by a RawRequestParser ... if the&lt;br/&gt;
   content type is &quot;application/x-www-form-urlencoded&quot; then&lt;br/&gt;
   SimpleRequestParser should be used (so all params from query string&lt;br/&gt;
   and body are included)&lt;/li&gt;
	&lt;li&gt;What should the expectations of&lt;br/&gt;
   ContentStream.getInputStream().close() be? Should the Dispatcher&lt;br/&gt;
   iterate over any Iterable streams when writing the output and try&lt;br/&gt;
   to close them, ignoring any Exceptions?&lt;/li&gt;
	&lt;li&gt;I&apos;m really not fond of having SolrParams.STREAM_TYPE. Can we please,&lt;br/&gt;
   please leave it out for now and rely on on content-type detection?&lt;br/&gt;
   We can add it back in if/when we make RequestParser a public&lt;br/&gt;
   interface and let people register them in solrconfig.&lt;/li&gt;
	&lt;li&gt;I really don&apos;t think we want to open the pandoras box of putting&lt;br/&gt;
   the HttpServletRequest in the SolrQueryRequest ... i&apos;d hate to put&lt;br/&gt;
   that in and then have to support it forever.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Things in the current patch that aren&apos;t strictly neccessary&lt;br/&gt;
for the current issue and can (should?) be commited seperately...&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;are we definitely deprecating SolrQueryResponse.getException ?&lt;/li&gt;
	&lt;li&gt;StandardRequestHandler and DisMaxRequestHandler have only been&lt;br/&gt;
   changed to subclass the new base class.&lt;/li&gt;
	&lt;li&gt;only whitespace changes in SolrRequestHandler.java&lt;/li&gt;
	&lt;li&gt;SolrServletRequest has only imports rearranged&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Things which definitely shouldn&apos;t block up the patch, but should go on&lt;br/&gt;
a short term todo list...&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;see backwards compatibility comment about (Xml)UpdateRequestHandler&lt;br/&gt;
   using InputStreamReader without specifying a charset ... in general&lt;br/&gt;
   the handler should look at the ContentStream&apos;s content type to determine&lt;br/&gt;
   the encoding of the InputStream (and probably default to UTF-8)&lt;/li&gt;
	&lt;li&gt;need to work out what kind of NamedList should be returned by&lt;br/&gt;
   (Xml)UpdateRequestHandler.update(Reader)&lt;/li&gt;
	&lt;li&gt;some of the new files are missing the Apache boilerplate.&lt;/li&gt;
	&lt;li&gt;a use case we talked about that still isn&apos;t covered is opening local&lt;br/&gt;
   files as a stream ... this should be easy to add later right along &lt;br/&gt;
   side STREAM_URL.&lt;/li&gt;
	&lt;li&gt;we should fill in the getURL methods for DisMax/Standard to point at wiki&lt;/li&gt;
	&lt;li&gt;CommitRequestHandler should use UpdateParams.OPTIMIZE&lt;/li&gt;
	&lt;li&gt;the init semantics for (Xml)UpdateRequestHandler are odd: as a&lt;br/&gt;
   RequestHandler it&apos;s garunteed that init(NamedList) will be called, but&lt;br/&gt;
   instead it uses it&apos;s own private init() that&apos;s called lazily.&lt;/li&gt;
	&lt;li&gt;DumpRequestHandler should dump ContentStream.getSize().&lt;/li&gt;
	&lt;li&gt;doFilter should call parsers.parse( path, req ) as soon as it has&lt;br/&gt;
   the path, and then delegate to a helper method that doesn&apos;t have &lt;br/&gt;
   access to the HttpServletRequest ... this reduces both the&lt;br/&gt;
   complexity of the method, and the likelyhood of &lt;br/&gt;
   someone inadvertently introducing an error (mangling the POST body)&lt;br/&gt;
   when making future changes in the long deep method.  &lt;br/&gt;
   The one thing to watch out for is forcing POST in legacy&lt;br/&gt;
   update. (assuming legacy update stays in the Filter) &lt;/li&gt;
	&lt;li&gt;STREAM_URL based ContentStreams can have a meaningful getSize()&lt;br/&gt;
   and getContentType() if we use openConnection instead of openStream.&lt;/li&gt;
	&lt;li&gt;STREAM_BODY based ContentStreams can get their size from the char[]&lt;/li&gt;
	&lt;li&gt;it&apos;s not clear to me why the interface for SolrRequestParser is...&lt;br/&gt;
     public SolrParams parseParamsAndFillStreams(&lt;br/&gt;
       final HttpServletRequest, ArrayList&amp;lt;ContentStream&amp;gt;)&lt;br/&gt;
   ...instead of just...&lt;br/&gt;
     public SolrQueryRequest(final HttpServletRequest)&lt;br/&gt;
   ...with the param parsing loops in&lt;br/&gt;
   SolrRequestParsers.buildRequestFrom &lt;br/&gt;
   in static utility methods (in case a RequestParser doesn&apos;t want to&lt;br/&gt;
   support STREAM_URL or STREAM_BODY)&lt;/li&gt;
&lt;/ul&gt;




</comment>
                            <comment id="12467330" author="ryantxu" created="Thu, 25 Jan 2007 11:10:49 +0000"  >
&lt;p&gt;Thanks for going through this!&lt;/p&gt;

&lt;p&gt;I&apos;ll comment on points i have answers or questions.  The rest will go&lt;br/&gt;
on the TODO list.&lt;/p&gt;


&lt;p&gt;Ok, so we should make sure to put the charset into&lt;br/&gt;
ContentStream.getContentType() and open the Reader with:&lt;/p&gt;

&lt;p&gt;  String charset = getCharset( stream.getContentType() );&lt;br/&gt;
  new InputStreamReader( stream.getStream(),  charset );&lt;/p&gt;



&lt;p&gt;Sounds reasonable.  I took them out because (at the time) it seemed&lt;br/&gt;
clearer and has less duplicated code.&lt;/p&gt;



&lt;p&gt;yes.  At some point it would also be good to make a stronger name&lt;br/&gt;
distinction between UpdateHandler (the thing that handles the nity&lt;br/&gt;
gritty lucene indexing) and the UpdateRequestHandler &amp;#8211; but lets save&lt;br/&gt;
that for another day!&lt;/p&gt;



&lt;p&gt;As written, the StandardRequestParser:&lt;br/&gt;
1) checks if multipart&lt;br/&gt;
2) checks if it has parameters in the URL (?xxx=yyy)&lt;br/&gt;
  if it has parameters (?xxx=yyy) then use the RawRequestParser&lt;br/&gt;
  otherwise it pulls parameters from the map. (SimpleRequestParser)&lt;/p&gt;

&lt;p&gt;To trigger raw request reading you &lt;b&gt;must&lt;/b&gt; have a parameter on the URL.&lt;br/&gt;
 This was my design in response to Yonik&apos;s observation that curl puts&lt;br/&gt;
&quot;application/x-www-form-urlencoded&quot; in the header even if it is not&lt;br/&gt;
form-urlencoded encoded.&lt;/p&gt;

&lt;p&gt;As written, it does not rely on clients putting accurate headers&lt;br/&gt;
(except for multipart) - it relies on a URL convention.&lt;/p&gt;



&lt;p&gt;I only put it in there to make you happy!  I&apos;ll take it out and we can&lt;br/&gt;
deal with it later if necessary.&lt;/p&gt;



&lt;p&gt;I didn&apos;t think i could get that past you!  I&apos;ll take it out and save&lt;br/&gt;
the pleeding for another time.&lt;/p&gt;



&lt;p&gt;for a local file, you can use stream.url=&lt;a href=&quot;file:///C:/pathtofile.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;file:///C:/pathtofile.txt&lt;/a&gt;,&lt;br/&gt;
for remote ones, you use stream.url=&lt;a href=&quot;http://&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://&lt;/a&gt;...&lt;/p&gt;

&lt;p&gt;We should have a good notice in the config warning people to have some&lt;br/&gt;
security running before enabling streaming.&lt;/p&gt;



&lt;p&gt;I had implemented it the normal way, BUT it broke many tests (since&lt;br/&gt;
they never call init).   The better solution is to make sure the tests&lt;br/&gt;
call init a standard way, but that got me into editing many files I&lt;br/&gt;
don&apos;t quite understand, so i opted for lazy init.&lt;/p&gt;


&lt;p&gt;That sounds fine.  Since it is a tenative private interface, i was not&lt;br/&gt;
too worried about it.&lt;/p&gt;</comment>
                            <comment id="12467755" author="ryantxu" created="Fri, 26 Jan 2007 08:29:57 +0000"  >
&lt;p&gt;Hymm, this is awkward.  I&apos;m not quite sure what happened.  But this is what I thought I sent.  (I apologize that you already took the time to try to decipher it).  I&apos;ll include the original, for clarification&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt; Woot! ... i think we&apos;re really close to comiting this.&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;Thanks for going through this!&lt;/p&gt;

&lt;p&gt;I&apos;ll comment on points i have answers or questions.  The rest will go&lt;br/&gt;
on the TODO list.&lt;/p&gt;

&lt;p&gt;&amp;gt;  - SolrUpdateServlet used HttpServletRequest.getReader, the new&lt;br/&gt;
&amp;gt;    UpdateRequestHandler uses an InputStreamReader arround&lt;br/&gt;
&amp;gt;    HttpServletRequest.getInputStream() ... this seems bad for legacy&lt;br/&gt;
&amp;gt;    update support from a char encoding standpoint.&lt;/p&gt;

&lt;p&gt;Ok, so we should make sure to put the charset into&lt;br/&gt;
ContentStream.getContentType() and open the Reader with:&lt;/p&gt;

&lt;p&gt; String charset = getCharset( stream.getContentType() );&lt;br/&gt;
 new InputStreamReader( stream.getStream(),  charset );&lt;/p&gt;


&lt;p&gt;&amp;gt;  - While i think it&apos;s important to refactor the XML Update&lt;br/&gt;
&amp;gt;    parsing out of SolrCore - I&apos;m still not clear what is gained by&lt;br/&gt;
&amp;gt;    eliminating SolrServlet and SolrUpdate.  The big advantage of&lt;br/&gt;
&amp;gt;    the new dispatcher being a Filter is that it can pass requests on&lt;br/&gt;
&amp;gt;    that it doesn&apos;t want to deal with, so why not leave the existing&lt;br/&gt;
&amp;gt;    servlets arround with only the minimum neccessary changes...&lt;/p&gt;

&lt;p&gt;Sounds reasonable.  I took them out because (at the time) it seemed&lt;br/&gt;
clearer and has less duplicated code.&lt;/p&gt;


&lt;p&gt;&amp;gt; Comments regarding functionality that i think we &lt;b&gt;may&lt;/b&gt; want to address&lt;br/&gt;
&amp;gt; before commiting (but i won&apos;t fight over if i&apos;m the only one that cares)...&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  - UpdateRequestHandler should probably renamed XmlUpdateRequestHandler&lt;br/&gt;
&amp;gt;    (particularly since i expect Yonik to commit a&lt;br/&gt;
&amp;gt;    CsvUpdateRequestHandler real soon now)&lt;/p&gt;

&lt;p&gt;yes.  At some point it would also be good to make a stronger name&lt;br/&gt;
distinction between UpdateHandler (the thing that handles the nity&lt;br/&gt;
gritty lucene indexing) and the UpdateRequestHandler &amp;#8211; but lets save&lt;br/&gt;
that for another day!&lt;/p&gt;


&lt;p&gt;&amp;gt;  - StandardRequestParser can&apos;t assume that a POST which isn&apos;t&lt;br/&gt;
&amp;gt;    multipart/* should be handled by a RawRequestParser ... if the&lt;br/&gt;
&amp;gt;    content type is &quot;application/x-www-form-urlencoded&quot; then&lt;br/&gt;
&amp;gt;    SimpleRequestParser should be used (so all params from query string&lt;br/&gt;
&amp;gt;    and body are included)&lt;/p&gt;

&lt;p&gt;As written, the StandardRequestParser:&lt;br/&gt;
1) checks if multipart&lt;br/&gt;
2) checks if it has parameters in the URL (?xxx=yyy)&lt;br/&gt;
 if it has parameters (?xxx=yyy) then use the RawRequestParser&lt;br/&gt;
 otherwise it pulls parameters from the map. (SimpleRequestParser)&lt;/p&gt;

&lt;p&gt;To trigger raw request reading you &lt;b&gt;must&lt;/b&gt; have a parameter on the URL.&lt;br/&gt;
 This was my design in response to Yonik&apos;s observation that curl puts&lt;br/&gt;
&quot;application/x-www-form-urlencoded&quot; in the header even if it is not&lt;br/&gt;
form-urlencoded encoded.&lt;/p&gt;

&lt;p&gt;As written, it does not rely on clients putting accurate headers&lt;br/&gt;
(except for multipart) - it relies on a URL convention.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - I&apos;m really not fond of having SolrParams.STREAM_TYPE. Can we please,&lt;br/&gt;
&amp;gt;    please leave it out for now and rely on on content-type detection?&lt;br/&gt;
&amp;gt;    We can add it back in if/when we make RequestParser a public&lt;br/&gt;
&amp;gt;    interface and let people register them in solrconfig.&lt;/p&gt;

&lt;p&gt;I only put it in there to make you happy!  I&apos;ll take it out and we can&lt;br/&gt;
deal with it later if necessary.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - I really don&apos;t think we want to open the pandoras box of putting&lt;br/&gt;
&amp;gt;    the HttpServletRequest in the SolrQueryRequest ... i&apos;d hate to put&lt;br/&gt;
&amp;gt;    that in and then have to support it forever.&lt;/p&gt;

&lt;p&gt;I didn&apos;t think i could get that past you!  I&apos;ll take it out and save&lt;br/&gt;
the pleading for another time.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - a use case we talked about that still isn&apos;t covered is opening local&lt;br/&gt;
&amp;gt;    files as a stream ... this should be easy to add later right along&lt;br/&gt;
&amp;gt;    side STREAM_URL.&lt;/p&gt;

&lt;p&gt;for a local file, you can use stream.url=&lt;a href=&quot;file:///C:/pathtofile.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;file:///C:/pathtofile.txt&lt;/a&gt;,&lt;br/&gt;
for remote ones, you use stream.url=&lt;a href=&quot;http://&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://&lt;/a&gt;...&lt;/p&gt;

&lt;p&gt;We should have a good notice in the config warning people to have some&lt;br/&gt;
security running before enabling streaming.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - the init semantics for (Xml)UpdateRequestHandler are odd: as a&lt;br/&gt;
&amp;gt;    RequestHandler it&apos;s garunteed that init(NamedList) will be called, but&lt;br/&gt;
&amp;gt;    instead it uses it&apos;s own private init() that&apos;s called lazily.&lt;/p&gt;

&lt;p&gt;I had implemented it the normal way, BUT it broke many tests (since&lt;br/&gt;
they never call init).   The better solution is to make sure the tests&lt;br/&gt;
call init a standard way, but that got me into editing many files I&lt;br/&gt;
don&apos;t quite understand, so i opted for lazy init.&lt;/p&gt;

&lt;p&gt;&amp;gt;  - it&apos;s not clear to me why the interface for SolrRequestParser is...&lt;br/&gt;
&amp;gt;      public SolrParams parseParamsAndFillStreams(&lt;br/&gt;
&amp;gt;        final HttpServletRequest, ArrayList&amp;lt;ContentStream&amp;gt;)&lt;br/&gt;
&amp;gt;    ...instead of just...&lt;br/&gt;
&amp;gt;      public SolrQueryRequest(final HttpServletRequest)&lt;br/&gt;
&amp;gt;    ...with the param parsing loops in&lt;br/&gt;
&amp;gt;    SolrRequestParsers.buildRequestFrom&lt;br/&gt;
&amp;gt;    in static utility methods (in case a RequestParser doesn&apos;t want to&lt;br/&gt;
&amp;gt;    support STREAM_URL or STREAM_BODY)&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;That sounds fine.  Since it is a tentative private interface, i was not&lt;br/&gt;
too worried about it.&lt;/p&gt;



</comment>
                            <comment id="12467787" author="ryantxu" created="Fri, 26 Jan 2007 11:23:57 +0000"  >
&lt;p&gt;Ok, I just uploaded (hopefully) a final version.  It takes care of (most) everything you suggest.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - SolrUpdateServlet used HttpServletRequest.getReader, the new&lt;br/&gt;
&amp;gt;    UpdateRequestHandler uses an InputStreamReader arround&lt;br/&gt;
&amp;gt;    HttpServletRequest.getInputStream() ... this seems bad for legacy&lt;br/&gt;
&amp;gt;    update support from a char encoding standpoint.&lt;/p&gt;

&lt;p&gt;Can you check: XmlUpdateRequestHandler.handleRequestBody();&lt;/p&gt;

&lt;p&gt;I added a check for charset, but am not totally confident in the method.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - StandardRequestParser can&apos;t assume that a POST which isn&apos;t&lt;br/&gt;
&amp;gt;    multipart/* should be handled by a RawRequestParser ... if the&lt;br/&gt;
&amp;gt;    content type is &quot;application/x-www-form-urlencoded&quot; then&lt;br/&gt;
&amp;gt;    SimpleRequestParser should be used (so all params from query string&lt;br/&gt;
&amp;gt;    and body are included)&lt;/p&gt;

&lt;p&gt;done.  &lt;/p&gt;


&lt;p&gt;&amp;gt;  - What should the expectations of&lt;br/&gt;
&amp;gt;    ContentStream.getInputStream().close() be? Should the Dispatcher&lt;br/&gt;
&amp;gt;    iterate over any Iterable streams when writing the output and try&lt;br/&gt;
&amp;gt;    to close them, ignoring any Exceptions?&lt;/p&gt;

&lt;p&gt;Each handler is responsible to make sure they are closed.  Since it is an Iterable&amp;lt;ContentStream&amp;gt; - I don&apos;t think it is OK to iterate a &lt;b&gt;second&lt;/b&gt; time.  If we make it a Collection&amp;lt;&amp;gt; then that would be a reasonable behavior.&lt;/p&gt;


&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Things in the current patch that aren&apos;t strictly neccessary&lt;br/&gt;
&amp;gt; for the current issue and can (should?) be commited seperately...&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;  - are we definitely deprecating SolrQueryResponse.getException ?&lt;/p&gt;

&lt;p&gt;I took it out. we can commit it separately.&lt;/p&gt;

&lt;p&gt;&amp;gt;  - StandardRequestHandler and DisMaxRequestHandler have only been&lt;br/&gt;
&amp;gt;    changed to subclass the new base class.&lt;/p&gt;

&lt;p&gt;I left it in.  You can ignore changes to StandardRequestHandler and DisMax if that makes more sense.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - doFilter should call parsers.parse( path, req ) as soon as it has &lt;br/&gt;
&amp;gt;    the path, and then delegate to a helper method that doesn&apos;t have &lt;br/&gt;
&amp;gt;    access to the HttpServletRequest ... this reduces both the&lt;br/&gt;
&amp;gt;    complexity of the method, and the likelyhood of &lt;br/&gt;
&amp;gt;    someone inadvertently introducing an error (mangling the POST body)&lt;br/&gt;
&amp;gt;    when making future changes in the long deep method.  &lt;br/&gt;
&amp;gt;    The one thing to watch out for is forcing POST in legacy&lt;br/&gt;
&amp;gt;    update. (assuming legacy update stays in the Filter) &lt;/p&gt;

&lt;p&gt;I removed the legacy handling from SolrDispatchFilter - this simplifies it greatly, so i&apos;m not sure if you still think this is necessary.&lt;/p&gt;


&lt;p&gt;&amp;gt;  - it&apos;s not clear to me why the interface for SolrRequestParser is...&lt;br/&gt;
&amp;gt;      public SolrParams parseParamsAndFillStreams(&lt;br/&gt;
&amp;gt;        final HttpServletRequest, ArrayList&amp;lt;ContentStream&amp;gt;)&lt;br/&gt;
&amp;gt;    ...instead of just...&lt;br/&gt;
&amp;gt;      public SolrQueryRequest(final HttpServletRequest)&lt;br/&gt;
&amp;gt;    ...with the param parsing loops in&lt;br/&gt;
&amp;gt;    SolrRequestParsers.buildRequestFrom &lt;br/&gt;
&amp;gt;    in static utility methods (in case a RequestParser doesn&apos;t want to&lt;br/&gt;
&amp;gt;    support STREAM_URL or STREAM_BODY)&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;I left it as is for now.  Since it is a private interface, we should feel free to clean it up / change it as we see fit.  But now I go to sleep!&lt;/p&gt;
</comment>
                            <comment id="12468403" author="hossman" created="Mon, 29 Jan 2007 20:38:02 +0000"  >&lt;p&gt;Kick Ass!&lt;/p&gt;

&lt;p&gt;Ryan, Everything looks great ... I&apos;ve commited a minor variation on your latest patch.&lt;/p&gt;

&lt;p&gt;Modifications I made to your patch before commiting...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Removed an empty handleRequest method from SolrDispatchFilter&lt;/li&gt;
	&lt;li&gt;cleaned up some funky chars in web.xml&lt;/li&gt;
	&lt;li&gt;moved LICENSE info to top of all new files (before package declaration)&lt;/li&gt;
	&lt;li&gt;refactored some duplicate code from SolrUpdateServlet and TestHarness&lt;br/&gt;
   into XmlUpdateRequestHandler.doLegacyUpdate&lt;/li&gt;
	&lt;li&gt;did not commit test.html&lt;/li&gt;
	&lt;li&gt;I also set svn:keywords on all of your new RequestHandlers, as well&lt;br/&gt;
   as the DisMaxRequestHandler (aparently it had never been set there,&lt;br/&gt;
   so the keywords weren&apos;t getting replaced properly)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(The charset detection from content-type seems good enough for now ... there&apos;s some more crazy stuff that can be done diferentiating between text/xml and application/xml and inspecting the InputStream itself for specific indicator bytes &amp;#8211;  but that can be dealt with in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-96&quot; title=&quot;Solr should support alternate charsets for XML update messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-96&quot;&gt;&lt;del&gt;SOLR-96&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Thanks for putting in all of this work, and sticking with it through my (most likely extremely paranoid) critical comments ... what you&apos;ve done is really going to help catapult Solr&apos;s flexibility.&lt;/p&gt;
</comment>
                            <comment id="12468406" author="ryantxu" created="Mon, 29 Jan 2007 20:53:14 +0000"  >&lt;p&gt;Thanks Hoss!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12360482">SOLR-103</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12360581">SOLR-110</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12354480">SOLR-61</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12358618">SOLR-85</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12354850">SOLR-66</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12360581">SOLR-110</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12349676" name="DispatchFilter.patch" size="97408" author="ryantxu" created="Fri, 26 Jan 2007 11:17:06 +0000"/>
                            <attachment id="12349491" name="DispatchFilter.patch" size="97471" author="ryantxu" created="Wed, 24 Jan 2007 07:30:28 +0000"/>
                            <attachment id="12349345" name="DispatchFilter.patch" size="92251" author="ryantxu" created="Sun, 21 Jan 2007 21:08:30 +0000"/>
                            <attachment id="12349332" name="DispatchFilter.patch" size="63612" author="ryantxu" created="Sun, 21 Jan 2007 10:27:32 +0000"/>
                            <attachment id="12349322" name="DispatchFilter.patch" size="63419" author="ryantxu" created="Sat, 20 Jan 2007 19:18:17 +0000"/>
                            <attachment id="12349115" name="DispatchFilter.patch" size="41840" author="ryantxu" created="Wed, 17 Jan 2007 21:15:45 +0000"/>
                            <attachment id="12349111" name="DispatchFilter.patch" size="44212" author="ryantxu" created="Wed, 17 Jan 2007 20:00:52 +0000"/>
                            <attachment id="12348925" name="HandlerRefactoring-DRAFT-SRC.zip" size="767469" author="ryantxu" created="Sun, 14 Jan 2007 22:45:31 +0000"/>
                            <attachment id="12348913" name="HandlerRefactoring-DRAFT-SRC.zip" size="379215" author="ryantxu" created="Sun, 14 Jan 2007 04:00:23 +0000"/>
                            <attachment id="12348912" name="HandlerRefactoring.DRAFT.patch" size="266186" author="ryantxu" created="Sun, 14 Jan 2007 03:38:24 +0000"/>
                            <attachment id="12348910" name="HandlerRefactoring.DRAFT.patch" size="129963" author="ryantxu" created="Sun, 14 Jan 2007 02:39:45 +0000"/>
                            <attachment id="12348911" name="HandlerRefactoring.DRAFT.zip" size="23628" author="ryantxu" created="Sun, 14 Jan 2007 02:42:39 +0000"/>
                            <attachment id="12349320" name="commons-fileupload-20070107.jar" size="50101" author="ryantxu" created="Sat, 20 Jan 2007 19:17:27 +0000"/>
                            <attachment id="12349321" name="commons-io-1.2.jar" size="65621" author="ryantxu" created="Sat, 20 Jan 2007 19:17:46 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>14.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 15 Jan 2007 04:47:46 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7478</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxxtdj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21078</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>