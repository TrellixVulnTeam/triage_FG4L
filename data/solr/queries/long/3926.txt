The Solrj api uses ortogonal concepts for setting/removing and getting sort information. Setting/removing uses a combination of (name,order), while getters return a String "name order":



public SolrQuery setSortField(String field, ORDER order);
public SolrQuery addSortField(String field, ORDER order);
public SolrQuery removeSortField(String field, ORDER order);
public String[] getSortFields();
public String getSortField();



If you want to use the current sort information to present a list of active sorts, with the possibility to remove then, you need to manually parse the string(s) returned from getSortFields, to recreate the information required by removeSortField(). Not difficult, but not convenient either 

Therefore this suggestion: Add a new method public Map<String,ORDER> getSortFieldMap(); which returns an ordered map of active sort fields. This will make introspection of the current sort setup much easier.



  public Map<String, ORDER> getSortFieldMap() {
    String[] actualSortFields = getSortFields();
    if (actualSortFields == null || actualSortFields.length == 0)
      return Collections.emptyMap();

    Map<String, ORDER> sortFieldMap = new LinkedHashMap<String, ORDER>();
    for (String sortField : actualSortFields) {
      String[] fieldSpec = sortField.trim().split(" ");
      sortFieldMap.put(fieldSpec[0], ORDER.valueOf(fieldSpec[1]));
    }

    return Collections.unmodifiableMap(sortFieldMap);
  }



For what it's worth, this is possible client code:



System.out.println("Active sorts");

Map<String, ORDER> fieldMap = getSortFieldMap(query);
for (String field : fieldMap.keySet()) {
   System.out.println("- " + field + "; dir=" + fieldMap.get(field));
}

