<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat May 16 23:26:08 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/BOOKKEEPER-272/BOOKKEEPER-272.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[BOOKKEEPER-272] Provide automatic mechanism to know bookie failures</title>
                <link>https://issues.apache.org/jira/browse/BOOKKEEPER-272</link>
                <project id="12311293" key="BOOKKEEPER">Bookkeeper</project>
                    <description>&lt;p&gt;The idea is to build automatic mechanism to find out the bookie failures. Setup the bookie failure notifications to start the re-replication process.&lt;/p&gt;

&lt;p&gt;There are multiple approaches to findout bookie failures. Please refer the documents attached in BookKeeper-237.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12558237">BOOKKEEPER-272</key>
            <summary>Provide automatic mechanism to know bookie failures</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12553925">BOOKKEEPER-237</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rakeshr">Rakesh R</assignee>
                                    <reporter username="rakeshr">Rakesh R</reporter>
                        <labels>
                    </labels>
                <created>Sat, 26 May 2012 10:07:26 +0100</created>
                <updated>Wed, 13 Feb 2013 15:47:02 +0000</updated>
                            <resolved>Mon, 27 Aug 2012 17:03:52 +0100</resolved>
                                                    <fixVersion>4.2.0</fixVersion>
                                    <component>bookkeeper-auto-recovery</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="13284030" author="fpj" created="Sat, 26 May 2012 19:01:04 +0100"  >&lt;p&gt;Hi Rakesh, One clarification. In the design document of &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-237&quot; title=&quot;Automatic recovery of under-replicated ledgers and its entries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-237&quot;&gt;&lt;del&gt;BOOKKEEPER-237&lt;/del&gt;&lt;/a&gt;, we say: &lt;em&gt;Auditor would be forming the recovery chain based on the myIds added to the ZooKeeper under the zNode /ledgers/bookie/myId&lt;/em&gt;. If the chain is logical and formed through zookeeper, then I don&apos;t understand why the auditor needs to be involved in the chain formation. In my understanding of the proposal, the role of the auditor is essentially to assign work (replication) to bookies. What am I missing?&lt;/p&gt;</comment>
                            <comment id="13284884" author="rakeshr" created="Tue, 29 May 2012 16:40:16 +0100"  >&lt;p&gt;Hi Flavio,&lt;/p&gt;

&lt;p&gt;Thanks for your interest and comments, actually I was doing prototype for the &apos;CircularChain&apos; algorithm without a central auditor guy. Sorry for the late reply&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;But I faced a problem in handling the following situation.&lt;/p&gt;

&lt;p&gt;1 &amp;lt;- 2 &amp;lt;- 3 &amp;lt;- 4 &amp;lt;- 5 &amp;lt;- 6 &amp;lt;- 1&lt;/p&gt;

&lt;p&gt;Consider the scenario where 2,3,4 went down. Now 5 got the notification and marked 4 as failed and moves to 4&apos;s neighbour 3. Whenever 5 is checking about 3&apos;s status, say 3 rejoins and is alive, this inturn will stop searching. Say, immediately 3 also went down. Here the chance of missing 2&apos;s failure is high. &lt;/p&gt;

&lt;p&gt;One solution that comes in my mind is, when 5 identifies 3 is alive he will add watcher to 3. Here again another problem is, consider 4 has rejoined and will also try adding watcher to 3. Now if we analyse the chain, the previous watcher added by 5 also will be there to 3(as ZK doesn&apos;t has unregister of watcher). Also, the level of watcher reformation will gradually increases.&lt;/p&gt;

&lt;p&gt;I&apos;m bit worrying about the chances of missing watchers and isolation/race conditions with this approach. &lt;/p&gt;

&lt;p&gt;If I&apos;m having an auditor, only he will look to all and inform about failure Bookies. I feel, there is no chance of missing watchers and isolation/race conditions in this approach. Only the overhead will be Auditor election. &lt;/p&gt;

&lt;p&gt;He(central node) will publish about the failed bookie(through znode) and after recieving the notification anyone can acquire the lock and started re-replication and cycle will continue till complete re-replication. &lt;/p&gt;

&lt;p&gt;I&apos;d like to know your opinion on handling bookie failures through central entity?.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Rakesh&lt;/p&gt;</comment>
                            <comment id="13286688" author="rakeshr" created="Thu, 31 May 2012 17:08:57 +0100"  >&lt;p&gt;Here&apos;s a rough draft attached for reviewing the approach. Please have a look and appreciate your comments/thoughts.&lt;/p&gt;</comment>
                            <comment id="13287314" author="rakeshr" created="Fri, 1 Jun 2012 11:17:03 +0100"  >&lt;p&gt;Modified the ServerConfiguration file and fixed complilation issues.&lt;/p&gt;</comment>
                            <comment id="13290811" author="rakeshr" created="Thu, 7 Jun 2012 06:43:29 +0100"  >&lt;p&gt;I have uploaded latest patch with few test cases for knowing the algo.&lt;/p&gt;

&lt;p&gt;&lt;cite&gt;How the Bookie failure detection algo works&lt;/cite&gt;&lt;br/&gt;
This scheme is made based on distributed approach. Apart from the single bookie auditor for detecting the bookie failures all other logics are completely distributed. I&apos;m thinking Auditor would make the detection more simple as we have existing &apos;available&apos; znode in zookeeper for knowing the bookie failures.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Following are the logical steps:&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;cite&gt;Generate BookieId:&lt;/cite&gt;&lt;br/&gt;
Each bookie will be creating a unique Id under &apos;bookieids&apos; path, this is a persistent node in ZooKeeper.&lt;br/&gt;
Keep IP:PORT info as his data into respective &apos;bookieid&apos; znode.&lt;br/&gt;
For ex: 0001 is the bookieId and 10.18.40.13:2181 is bokkie IP. 0001 znode contains 10.18.40.13:2181 as data.&lt;/li&gt;
	&lt;li&gt;&lt;cite&gt;Build per bookie-ledger mappings:&lt;/cite&gt;&lt;br/&gt;
This will help to know the bookie&apos;s content very quickly and avoid parsing of all the ledgers for knowing the failed bookie&apos;s ledgers again and again. &lt;/li&gt;
	&lt;li&gt;&lt;cite&gt;How to build per bookie-ledger mappings:&lt;/cite&gt;&lt;br/&gt;
When creating/reforming the ensemble, the&apos;ledgerid&apos; is putting under the respective &apos;bookieid&apos;. During ensemble formation, metadata will give us the bookies info. We will this and add the &apos;ledgerid&apos; only to the respective &apos;bookieid&apos;.&lt;br/&gt;
For ex: &lt;br/&gt;
0001 is the bookieId, say it contains children znodes as ledgers like: 0001/L_001,L_005 etc. &lt;br/&gt;
0002 is another, say it contains children znodes as ledgers like: 0002/L_005 etc.&lt;/li&gt;
	&lt;li&gt;&lt;cite&gt;Elect an Auditor Bookie for the entire Bookie cluster:&lt;/cite&gt; Makes it simple and minimize the duplication efforts.&lt;br/&gt;
Only one Auditor is monitoring the available bookies, his responsibility is to watch the bookies &apos;available&apos; znode. When he detects any bookie failure through &apos;NodeChildrenChanged&apos; watcher, will publish the same in &apos;failedbookies&apos; path in Zookeeper. Publishing is done by creating the respective unique &apos;bookieid&apos; persistent znode in the &apos;failedbookies&apos; path. All the other bookies will be watching on the &apos;failedbookies&apos; znode.&lt;/li&gt;
	&lt;li&gt;&lt;cite&gt;Starts Re-replication:&lt;/cite&gt;&lt;br/&gt;
Upon receiving the &apos;failebookies&apos; notification, all the bookies will compete eachother for acquiring the lock(using zk distributed lock-ephemeral znode). Whoever acquires will start re-replication, all others will look into this lock for knowing the re-replication status. When creating the lock, the replica bookie will add its IP:PORT info to it. After finishing the re-replication, he will delete the lock and so that others will takeup and continue this cycle till the end.&lt;br/&gt;
For ex: 0002/L_005/lock&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;How Re-replication works, I have commented in BookKeeper-237. Please go through the link.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-237?focusedCommentId=13281470&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13281470&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/BOOKKEEPER-237?focusedCommentId=13281470&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13281470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Responsible classes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ServerConfiguration : for zk path configurations&lt;/li&gt;
	&lt;li&gt;LedgerCreateOp,LedgerHandle : forming bookie-ledger mappings&lt;/li&gt;
	&lt;li&gt;Bookie : starting bookie chain&lt;/li&gt;
	&lt;li&gt;BKLedgerMapper : for updating bookie-ledger mapping&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BookieIdGenerator : generating unique bookieId&lt;/li&gt;
	&lt;li&gt;BookieChain : forming the detection chain&lt;/li&gt;
	&lt;li&gt;AuditorBookieChain : by default auditor based, later it can have CircularBookieChain etc.&lt;/li&gt;
	&lt;li&gt;AuditorElector : do auditor election&lt;/li&gt;
	&lt;li&gt;Auditor : watch bookies&lt;/li&gt;
	&lt;li&gt;BookieObserver : listening failedbookie notifications.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Tests:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BookieLedgerMetadataTest&lt;/li&gt;
	&lt;li&gt;AuditorBookieTest&lt;/li&gt;
	&lt;li&gt;BookieDetectionTest&lt;/li&gt;
	&lt;li&gt;BookieIdGenTest&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-Rakesh&lt;/p&gt;</comment>
                            <comment id="13290837" author="rakeshr" created="Thu, 7 Jun 2012 07:42:56 +0100"  >&lt;p&gt;&lt;cite&gt;Why BKLedgerMapping :&lt;/cite&gt; Parsing of ledgers and identifying failed bookies may take long time, consider the case where lakhs of ledgers created by NN-HA edit logs. So I thought of having a reverse mapping(bk vs its ledgers). Since this mapping is constant until any re-replication, so I made it as persistent node under &apos;bookieid&apos;.&lt;/p&gt;

&lt;p&gt;&lt;cite&gt;Why Auditor :&lt;/cite&gt; Single instance for entire bk cluster. After analyzing multiple approaches I found this would avoid many problems, like few cases I mentioned earlier in this JIRA.Please see links:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-272?focusedCommentId=13284884&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13284884&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/BOOKKEEPER-272?focusedCommentId=13284884&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13284884&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13291558" author="rakeshr" created="Fri, 8 Jun 2012 06:43:53 +0100"  >&lt;p&gt;I have edited the JIRA subjectline inorder to reduce the scope of this task.&lt;/p&gt;</comment>
                            <comment id="13291581" author="rakeshr" created="Fri, 8 Jun 2012 07:59:54 +0100"  >&lt;p&gt;Thanks Ivan for the comments.I have updated the latest patch.&lt;/p&gt;

&lt;p&gt;Auditor Bookie(single entity in bk cluster) - watching the available bookies and setup bookie failure notifications. &lt;/p&gt;

&lt;p&gt;Please have a look.&lt;/p&gt;</comment>
                            <comment id="13291802" author="ikelly" created="Fri, 8 Jun 2012 15:31:12 +0100"  >&lt;p&gt;New patch is a lot clearer. Comments follow;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The changes to ServerConfiguration are unnesessary. The paths aren&apos;t actually configurable, so the shouldn&apos;t be in the configuration. Also, i don&apos;t think they should be configurable. I think that all auditor data should be under the auditor znode also. So eventually we&apos;ll have the three paths:&lt;br/&gt;
      /ledgers/auditor/election&lt;br/&gt;
      /ledgers/auditor/failedbookies&lt;br/&gt;
      /ledgers/auditor/underreplicated&lt;br/&gt;
      /ledgers/auditor/&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Election watcher does an election on the expired event. If you get this event, the bookie will shutdown (see Bookie.java)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;For the moment, and maybe for ever, whether the auditor runs should be configurable. During the course of 4.2 we&apos;re going to be building up this stuff incrementally. We should only enable it for tests which specifically use it (to start with).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;getMyInfo() should be called getIdentifier(). It would be great if you could modify registerBookie() to take a String rather than a port, so that the identifier for the bookie is only generated at one point ever.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collections.sort() on children isn&apos;t fully correct. V_1 &amp;amp; V_10 will sort before V_2, as it sorts alphabetically. Better to define a comparator, which splits on the &apos;_&apos;, parses the number and does a comparison of that.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Checking if you&apos;ve won the election should be a matter of children.get(0).equals(myVote), once children is sorted correctly.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Check for specific exceptions. findbugs warns on catch (Exception e) because this also catches RuntimeExceptions. IOException is the wrong exception to use for this stuff also. Custom exceptions, defined under BookieException.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Instead of watching a specific node, watch for the ChildrenChanged event on the zkAuditorElectPath. Even the current winner of the election can watch this. When triggered, doElection should be fine, though you should shutdown the Auditor thread if running if you loose the election.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I don&apos;t understand the point of writing auditor data to the auditor znode. It doesn&apos;t seem to do anything.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The auditor code seems to check for failed bookies, and publishes these. We should skip a step here though, and instead of publishing the bookes, publish the ledgers which are on that bookie. In fact, it&apos;s much more efficient if it runs like this. If we only publish the failed bookies, each worker picking up a bookie to recover has to read all ledgers to find which ledgers to recover. If the auditor is maintaining a bookie -&amp;gt; ledger index, only one node needs to be reading all the ledgers.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The run loop method of Auditor isn&apos;t a loop. I think the run loop should look as like:&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
   Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; bookies = getAvailableBookies();
   &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
       waitForNotification();
       Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; newBookies = getAvailableBookies();
       Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; lostBookies = bookies;
       lostBookies.removeAll(newBookies);
       bookies = newBookies;

       &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (lostBookies.size() &amp;gt; 0) {
           &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
       }

       Map&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt;&amp;gt; bookie2ledgersMap = generateBookie2LedgersIndex();
       Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt; suspectedLedgers = HashSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt;();
       &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; b : lostBookies) {
           suspectedLedgers.addAll(bookie2ledgersMap.get(b));
       }
       publishSuspectedLedgers(suspectedLedgers);
   }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getAvailableBookies() should put a watch on the available znode, and fire a notification when triggered.&lt;/p&gt;</comment>
                            <comment id="13292802" author="rakeshr" created="Mon, 11 Jun 2012 14:41:07 +0100"  >&lt;p&gt;Thanks Ivan, again for the detailed comments. I&apos;d like to know more on the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Instead of watching a specific node, watch for the ChildrenChanged event on the zkAuditorElectPath. Even the current winner of the election can watch this. When triggered, doElection should be fine, though you should shutdown the Auditor thread if running if you loose the election.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I have used the predecessor watching approach, used to avoid the herd effect with zookeeper leader election. Rule is, bookie will be watching to my predecessor bookie based on the ephemeral seq id. At any point of time, least ephemeral znode bookie only will get the chance to become Auditor. So I thought it would be more efficient to watch on my predecessor bookie. How does it sound?&lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt;I don&apos;t understand the point of writing auditor data to the auditor znode. It doesn&apos;t seem to do anything.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hope you meant, after the auditor election I&apos;m keeping the auditor&apos;s myInfo to the auditor election path(/ledgers/auditor/election). At present there is no logic, I&apos;ve just kept for debugging purpose only(using ZK znodes).&lt;br/&gt;
Below one:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;auditorElector.zkclient.setData(auditorElector.conf
+                    .getZkAuditorElectionPath(), auditorElector.myInfo
+                    .getBytes(), -1);

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;The run loop method of Auditor isn&apos;t a loop. I think the run loop should look as like:&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yup, I&apos;ll remove the volatile flag and do other modifications. &lt;br/&gt;
Here I&apos;d like to keep the generate &amp;amp; publishing suspected ledgers before entering to the waitForNotification(). Consider the scenario where the auditor bookie(say BK1) has failed and new auditor(BK2) comes, he will not recieve any notifications for the BK1 failures(from the available bookie&apos;s path).&lt;/p&gt;
</comment>
                            <comment id="13293507" author="ikelly" created="Tue, 12 Jun 2012 11:55:18 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I have used the predecessor watching approach, used to avoid the herd effect with zookeeper leader election. Rule is, bookie will be watching to my predecessor bookie based on the ephemeral seq id. At any point of time, least ephemeral znode bookie only will get the chance to become Auditor. So I thought it would be more efficient to watch on my predecessor bookie. How does it sound?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is fine. I just thought having all watch for children changed would make simpler code. I don&apos;t have a strong opinion on this though.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hope you meant, after the auditor election I&apos;m keeping the auditor&apos;s myInfo to the auditor election path(/ledgers/auditor/election). At present there is no logic, I&apos;ve just kept for debugging purpose only(using ZK znodes).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ok. Thats fine. Before releasing i&apos;d like to convert the data stored in the znode as a protobuf text serialization. I&apos;ve already done a conversion of ledger metadata but havent&apos; generated a patch/jira yet. I&apos;ve made these changes to make moving between bk versions easier. This is fine as it is for now though.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Here I&apos;d like to keep the generate &amp;amp; publishing suspected ledgers before entering to the waitForNotification(). Consider the scenario where the auditor bookie(say BK1) has failed and new auditor(BK2) comes, he will not recieve any notifications for the BK1 failures(from the available bookie&apos;s path).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yup, that sounds good.&lt;/p&gt;</comment>
                            <comment id="13294398" author="rakeshr" created="Wed, 13 Jun 2012 13:06:41 +0100"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;As part of this Auditor logic, I&apos;m planning to publish the suspected/underreplicated ledger metatdata as Ledger_BookieIP:PORT:&lt;/p&gt;

&lt;p&gt;Assume we have three bookies BK1, BK2, BK3 and has ledgers L0001, L0002, L0003&lt;/p&gt;

&lt;p&gt;Example:&lt;br/&gt;
Say, BK1 BK2 has failed and started two new bookies, then Auditor will be publishing as:&lt;br/&gt;
/ledgers/auditor/underreplicated/L0001_BK1&lt;br/&gt;
/ledgers/auditor/underreplicated/L0002_BK1&lt;br/&gt;
/ledgers/auditor/underreplicated/L0003_BK1&lt;br/&gt;
/ledgers/auditor/underreplicated/L0001_BK2&lt;br/&gt;
/ledgers/auditor/underreplicated/L0002_BK2&lt;br/&gt;
/ledgers/auditor/underreplicated/L0003_BK2&lt;/p&gt;

&lt;p&gt;By this, I&apos;m thinking the target re-replicators would be able to acquire distributed lock on L0001_BK1...etc and start re-replicating. Is this ok for you?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Rakesh&lt;/p&gt;</comment>
                            <comment id="13294493" author="ikelly" created="Wed, 13 Jun 2012 15:31:36 +0100"  >&lt;p&gt;I don&apos;t think we need the bookie. As we need to run a check on the ledger to find which parts are underreplicated (since some segments may not include the failed bookie), we may as well just record the ledger id. Also, it&apos;d be better to only have one worker fixing a single ledger to avoid conflicting writes when updating the ledger metadata.&lt;/p&gt;</comment>
                            <comment id="13294534" author="rakeshr" created="Wed, 13 Jun 2012 16:47:51 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I don&apos;t think we need the bookie&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Here I could see one race condition. Say first Auditor is coming to publish failure of BK2 in L0001. Meantime BK4 has finished the re-replication of BK3&apos;s L0001 and about to delete the entry from /underreplicated. In this case, Auditor will silently continues by seeing L0001 and the other worker will delete the L0001 entry thinking there is no more failures.&lt;/p&gt;

&lt;p&gt;Solution I&apos;m thinking to check the data version before doing zk operation(similar logic we built in BKJM CurrentInProgress). I&apos;m planning to keep data as failed bookie information.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As we need to run a check on the ledger to find which parts are underreplicated (since some segments may not include the failed bookie), we may as well just record the ledger id.Also, it&apos;d be better to only have one worker fixing a single ledger to avoid conflicting writes when updating the ledger metadata.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah, I understand. I&apos;m having one suggestion, anyway auditor knows about the failed bookies and its ledgers when publishing the underreplicated ledgers. Why don&apos;t we keep the failed bookie as data inside the underreplicated ledger. So the worker(segment checker) only looks to this bookie and get corresponding index directly from the ZK ledger metadata?.&lt;/p&gt;</comment>
                            <comment id="13294542" author="ikelly" created="Wed, 13 Jun 2012 16:56:27 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I don&apos;t think we need the bookie&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Here I could see one race condition. Say first Auditor is coming to publish failure of BK2 in L0001. Meantime BK4 has finished the re-replication of BK3&apos;s L0001 and about to delete the entry from /underreplicated. In this case, Auditor will silently continues by seeing L0001 and the other worker will delete the L0001 entry thinking there is no more failures.&lt;/p&gt;

&lt;p&gt;Solution I&apos;m thinking to check the data version before doing zk operation(similar logic we built in BKJM CurrentInProgress). I&apos;m planning to keep data as failed bookie information.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, I think in this case, when we see BK3&apos;s failure and L0001 already exists, we should bump the version number. We shouldn&apos;t really be changing any vital data in zookeeper without checking the version number anyhow. Hopefully this will be a very rare situation anyhow, in a 3e2q ledger, two machines dropping like this would probably mean data loss.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;br/&gt;
Yeah, I understand. I&apos;m having one suggestion, anyway auditor knows about the failed bookies and its ledgers when publishing the underreplicated ledgers. Why don&apos;t we keep the failed bookie as data inside the underreplicated ledger. So the worker(segment checker) only looks to this bookie and get corresponding index directly from the ZK ledger metadata?.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Im not sure what you mean here. Having the failed bookie stored in the data is useful for debugging purposes, but we should do a check on the ledger beforehand anyhow to determine what to recover. Are you trying to avoid another read to the ledger znode?&lt;/p&gt;</comment>
                            <comment id="13294548" author="rakeshr" created="Wed, 13 Jun 2012 17:23:04 +0100"  >&lt;p&gt;Oh, seems that I did&apos;t explain clearly at my comment.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Im not sure what you mean here. Having the failed bookie stored in the data is useful for debugging purposes, but we should do a check on the ledger beforehand anyhow to determine what to recover. Are you trying to avoid another read to the ledger znode?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;My point is, rather than reading with bookieclient and finding the badReplicas, why don&apos;t we find the fragments using the ledgermetadata present in zookeeper as we already knows the failed bookie.&lt;/p&gt;</comment>
                            <comment id="13294606" author="ikelly" created="Wed, 13 Jun 2012 19:28:24 +0100"  >&lt;p&gt;I think we should probe in any case though. For example, if a bookie has restarted, it&apos;s znode will disappear momentarily. All ledgers will be marked for checking by the auditor, but they&apos;re still available after the bookie comes back up.&lt;/p&gt;</comment>
                            <comment id="13294839" author="rakeshr" created="Thu, 14 Jun 2012 07:49:15 +0100"  >&lt;p&gt;Its just suggestion only. I think will see whether any advantage in using failedbookies information during detection logic &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-247&quot; title=&quot;Detection of under replication&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-247&quot;&gt;&lt;del&gt;BOOKKEEPER-247&lt;/del&gt;&lt;/a&gt; JIRA.&lt;/p&gt;

&lt;p&gt;From Auditor side, anyway it needs the data version logic to address the race condition mentioned in our above comments. So the auditor is publishing the underreplicated ledgerIds and the metadata looks like:&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; LedgerId with failedbookie details as comma separated data.&lt;/p&gt;

&lt;p&gt;Example:&lt;br/&gt;
/ledgers/auditor/underreplicated/L0001 (data as -&amp;gt; Metadataversion, BK1, BK2)&lt;br/&gt;
/ledgers/auditor/underreplicated/L0002 (data as -&amp;gt; Metadataversion, BK1, BK2)&lt;br/&gt;
/ledgers/auditor/underreplicated/L0003 (data as -&amp;gt; Metadataversion, BK1, BK2)&lt;/p&gt;</comment>
                            <comment id="13400518" author="rakeshr" created="Mon, 25 Jun 2012 16:06:35 +0100"  >&lt;p&gt;@Ivan&lt;br/&gt;
I&apos;ve refactored as per the comments, please go through this. &lt;/p&gt;

&lt;p&gt;Also, I think there is a bit cross over with &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-246&quot; title=&quot;Recording of underreplication of ledger entries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-246&quot;&gt;&lt;del&gt;BOOKKEEPER-246&lt;/del&gt;&lt;/a&gt; patch. I&apos;ll go through it.&lt;/p&gt;

&lt;p&gt;I just created AutoRecoveryService layer which has #start #stop #isRunning apis, just to plugin as a service.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For the moment, and maybe for ever, whether the auditor runs should be configurable&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I haven&apos;t included in this patch, since there is still confusions whether to treat as a plugin service or not.&lt;/p&gt;</comment>
                            <comment id="13400522" author="fpj" created="Mon, 25 Jun 2012 16:10:54 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;For the moment, and maybe for ever, whether the auditor runs should be configurable&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I haven&apos;t included in this patch, since there is still confusions whether to treat as a plugin service or not.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that whether the auditor runs or not should be configurable. Is that a problem?&lt;/p&gt;</comment>
                            <comment id="13400531" author="rakeshr" created="Mon, 25 Jun 2012 16:28:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think that whether the auditor runs or not should be configurable. Is that a problem?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hi Flavio, Following are the options to make thie feature configurable:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Initially I was thinking to provide new configuration item &apos;enableAutoRecovery=true&apos; in the bk_server.conf file. By default this feature will be disabled.&lt;/li&gt;
	&lt;li&gt;But after seeing the comments in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-304&quot; title=&quot;Prepare bookie vs ledgers cache and will be used by the Auditor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-304&quot;&gt;&lt;del&gt;BOOKKEEPER-304&lt;/del&gt;&lt;/a&gt;. Whether to consider as plugin process?&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-304?focusedCommentId=13398408&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13398408&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/BOOKKEEPER-304?focusedCommentId=13398408&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13398408&lt;/a&gt;&lt;br/&gt;
For this, we need to expose a ServicePlugin interface and will be configured in the bk_server.conf for enabling the feature.&lt;/li&gt;
&lt;/ol&gt;



&lt;p&gt;I&apos;m just confused to take which one is more feasible?&lt;/p&gt;</comment>
                            <comment id="13400581" author="ikelly" created="Mon, 25 Jun 2012 17:19:34 +0100"  >&lt;p&gt;For the moment, I think we should keep it in the bookie process and enabled by default. We shouldn&apos;t worry about making a plugin interface, or keeping it in a separate maven module. There&apos;s no strong requirement for it, and it just confuses matters. &lt;/p&gt;

&lt;p&gt;However, it is good to have a clean interface for starting and stopping the service. &lt;/p&gt;

&lt;p&gt;Regarding &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-246&quot; title=&quot;Recording of underreplication of ledger entries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-246&quot;&gt;&lt;del&gt;BOOKKEEPER-246&lt;/del&gt;&lt;/a&gt;, this patch should call the interface defined to record the failed ledgers. I&apos;ll take a look at this in a while. I&apos;ll also work out the order in which the patches will need to go in.&lt;/p&gt;</comment>
                            <comment id="13400586" author="umamaheswararao" created="Mon, 25 Jun 2012 17:27:45 +0100"  >&lt;p&gt;+1, I am also more inclined to keep in bookie process for now.&lt;/p&gt;</comment>
                            <comment id="13400628" author="fpj" created="Mon, 25 Jun 2012 17:54:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think we should keep it in the bookie process and enabled by default&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve expressed this concern before that I don&apos;t understand completely the use cases for the auditor. Short-lived ledgers will not need it because the window of vulnerability is narrow. In my mind the auditor is mainly for use cases that require long-lived ledgers. What&apos;s the rationale for having it enabled by default? &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There&apos;s no strong requirement for it, and it just confuses matters. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It confuses matters to mix both. BookKeeper provides a set of guarantees, and the auditor complements that set of properties by healing the replica set of under-replicated ledgers. The auditor also does not provide any functionality in the critical path of BookKeeper client calls. Given these two observations, it makes more sense to me to keep it separated. It makes it simpler to reason about what the system is doing and may avoid undesirable interferences.   &lt;/p&gt;</comment>
                            <comment id="13400853" author="fpj" created="Mon, 25 Jun 2012 21:30:41 +0100"  >&lt;p&gt;To summarize an offline discussion I had with Ivan, there are two points that I raised during the discussion:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;If the bookie and the auditor run on the same jvm, is it possible that runtime exceptions thrown by the auditor will kill the whole jvm and consequently the bookie as well?&lt;/li&gt;
	&lt;li&gt;If the bookie and the auditor run on the same jvm, it might be more difficult to debug. In particular, I was wondering about how to separate the log messages for postmortem analysis and debugging in general.&lt;/li&gt;
	&lt;li&gt;The performance of a bookie is more critical than the performance of the auditor. Running them on separate jvms might improve performance isolation.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="13436765" author="rakeshr" created="Fri, 17 Aug 2012 15:45:14 +0100"  >&lt;p&gt;Thanks Ivan,Uma,Flavio for your thoughts. It would be great if others could review my changes.&lt;/p&gt;


&lt;p&gt;Following are the changes made in the latest patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;by considering Ivan&apos;s point, provided AutoRecoveryManager#start() and #stop() methods and removed the dependency with Bookie server. Anyone can plugin the service by invoking start() and stop() operational methods.&lt;/li&gt;
	&lt;li&gt;I&apos;ve raised another JIRA &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-319&quot; title=&quot;Manage auditing and replication processes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-319&quot;&gt;&lt;del&gt;BOOKKEEPER-319&lt;/del&gt;&lt;/a&gt; to finalize the way to manage the recovery service.&lt;/li&gt;
	&lt;li&gt;also corrected ZkLedgerUnderreplicationManager.java, where adding duplicate &apos;missingreplica&apos; in case of an underreplicated ledger contains multiple bookie failures.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;ins&gt;Note:&lt;/ins&gt; This patch has dependency with &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-304&quot; title=&quot;Prepare bookie vs ledgers cache and will be used by the Auditor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-304&quot;&gt;&lt;del&gt;BOOKKEEPER-304&lt;/del&gt;&lt;/a&gt; and to be applied after &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-304&quot; title=&quot;Prepare bookie vs ledgers cache and will be used by the Auditor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-304&quot;&gt;&lt;del&gt;BOOKKEEPER-304&lt;/del&gt;&lt;/a&gt; patch&lt;/p&gt;
</comment>
                            <comment id="13436766" author="rakeshr" created="Fri, 17 Aug 2012 15:47:51 +0100"  >&lt;p&gt;Hi All, Could you have a look and review the latest patch.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Rakesh&lt;/p&gt;</comment>
                            <comment id="13438689" author="ikelly" created="Tue, 21 Aug 2012 14:05:22 +0100"  >&lt;p&gt;I&apos;ve had another look over this patch. I have some comments.&lt;/p&gt;

&lt;p&gt;Logic change in ZkLedgerUnderreplicationManager is wrong &lt;span class=&quot;error&quot;&gt;&amp;#91;previous was wrong also&amp;#93;&lt;/span&gt;. the break should be a return.&lt;/p&gt;

&lt;p&gt;Auditor will be a top level daemon, so it should own its create it&apos;s own LedgerManagers and ZooKeeper client. The only thing passed in to is should be the configuration.&lt;/p&gt;

&lt;p&gt;There should be a main method in AutoRecoveryManager. I think AutoRecoveryManager should be responsible for running recoveryworker as well. Im not sure whether the node which runs auditor should run a recovery worker at the same time. This is an open question.&lt;/p&gt;

&lt;p&gt;auditorElector should never be null, unless initialization fails. If initialization fails, start and stop should never be run. Perhaps we should us guava service &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; here as I also suggested to Uma for &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-248&quot; title=&quot;Rereplicating of under replicated data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-248&quot;&gt;&lt;del&gt;BOOKKEEPER-248&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Pattern &quot;ELECTION_PATH + PATH_SEPARATOR + vote&quot; is used in a lot of places. It would be nice to move this into a method &quot;String getVotePath(String vote);&quot;&lt;/p&gt;

&lt;p&gt;In Auditor, don&apos;t call getChildren from process(). Instead all it just after the take() in main loop. In general, you shouldn&apos;t call any blocking methods from the zk event handler thread.&lt;/p&gt;</comment>
                            <comment id="13438711" author="umamaheswararao" created="Tue, 21 Aug 2012 14:21:03 +0100"  >&lt;blockquote&gt;
&lt;p&gt;There should be a main method in AutoRecoveryManager. I think AutoRecoveryManager should be responsible for running recoveryworker as well. Im not sure whether the node which runs auditor should run a recovery worker at the same time. This is an open question.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oh, I was assuming that, every Recovery node will have (Auditor Participants + RW ) services running. But one will actually win for doing auditor work. But RW will do its job normally in all nodes. All other recovery node&apos;s auditor participants will look for the next election to win the Real Auditing job. &lt;br/&gt;
I am not sure my assumption is same as others. Any other thoughts?&lt;/p&gt;</comment>
                            <comment id="13438718" author="ikelly" created="Tue, 21 Aug 2012 14:26:55 +0100"  >&lt;p&gt;I was thinking along the same lines.&lt;/p&gt;</comment>
                            <comment id="13438856" author="rakeshr" created="Tue, 21 Aug 2012 18:00:48 +0100"  >&lt;p&gt;Thanks again Ivan for detailed review. Could you please give few more info on the following:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In Auditor, don&apos;t call getChildren from process(). Instead all it just after the take() in main loop. In general, you shouldn&apos;t call any blocking methods from the zk event handler thread&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oh yeah, Thanks for bringing this good point. Correct, this will delay other watch notifications also.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Logic change in ZkLedgerUnderreplicationManager is wrong &lt;span class=&quot;error&quot;&gt;&amp;#91;previous was wrong also&amp;#93;&lt;/span&gt;. the break should be a return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If I understand correctly, on NodeExistsException we are trying to append the missingReplica to the underreplicated ledger so that will notifies about one more down bookie which contains the ledger copy.&lt;br/&gt;
If we return simply, then the setData() method will not be called and there is a chance of missing the info about second replica.&lt;/p&gt;

&lt;p&gt;For Ex: L00001 ensemble BK1, BK2, BK3. &lt;br/&gt;
Say BK1 fails initially, then will markUnderreplicated ledger as L000001(BK1 as the data).&lt;br/&gt;
Now again BK2 has failed, then while creating will get NEE, so we will append BK2 also like: L000001(BK1 BK2).&lt;/p&gt;

&lt;p&gt;I think &quot;break; statement&quot; is making sense and after that the duplicate entry addition should be removed as per my latest patch.&lt;br/&gt;
Am I missing anything?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There should be a main method in AutoRecoveryManager. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah I&apos;ll add main method also. But what about retaining start() and stop() method as public. In future this will allow others(any external entity) to manage the recovery process easily ?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think AutoRecoveryManager should be responsible for running recoveryworker as well. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ofcourse, I&apos;ll integrate RW also be initialized as part of ARM.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;auditorElector should never be null, unless initialization fails. If initialization fails, start and stop should never be run. Perhaps we should us guava service &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; here as I also suggested to Uma for &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-248&quot; title=&quot;Rereplicating of under replicated data&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-248&quot;&gt;&lt;del&gt;BOOKKEEPER-248&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I just added null check, since start() and stop() methods are public.&lt;/p&gt;


&lt;p&gt;I&apos;ll rework on other points.&lt;/p&gt;</comment>
                            <comment id="13438865" author="rakeshr" created="Tue, 21 Aug 2012 18:07:21 +0100"  >&lt;p&gt;I also agree with you guys. Since Auditor is a stateless light weight daemon thread and only a single instance within the bk cluster, he can start RW service also along.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Oh, I was assuming that, every Recovery node will have (Auditor Participants + RW ) services running. But one will actually win for doing auditor work. But RW will do its job normally in all nodes. All other recovery node&apos;s auditor participants will look for the next election to win the Real Auditing job. &lt;br/&gt;
I am not sure my assumption is same as others. Any other thoughts?&lt;/p&gt;&lt;/blockquote&gt;</comment>
                            <comment id="13439427" author="rakeshr" created="Wed, 22 Aug 2012 12:28:47 +0100"  >&lt;p&gt;Hi Ivan, Hope I&apos;m not confusing you&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As per the discussion/comments, now AutoRecoveryManager will have dependency with RW(that is still under dev stage) and also will make use of guava service for cleaner. Shall I move the ARM initialization phase to &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-319&quot; title=&quot;Manage auditing and replication processes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-319&quot;&gt;&lt;del&gt;BOOKKEEPER-319&lt;/del&gt;&lt;/a&gt; and will work there?&lt;/p&gt;

&lt;p&gt;So that will make this JIRA completely independent and will discuss only the auditing job. Are you agreeing with me?&lt;/p&gt;

&lt;p&gt;Also I will get some more time to familiarize with the guava service.&lt;/p&gt;</comment>
                            <comment id="13440181" author="ikelly" created="Thu, 23 Aug 2012 10:52:57 +0100"  >&lt;blockquote&gt;
&lt;p&gt;If I understand correctly, on NodeExistsException we are trying to append the missingReplica to the underreplicated ledger so that will notifies about one more down bookie which contains the ledger copy.&lt;br/&gt;
If we return simply, then the setData() method will not be called and there is a chance of missing the info about second replica.&lt;/p&gt;

&lt;p&gt;For Ex: L00001 ensemble BK1, BK2, BK3.&lt;br/&gt;
Say BK1 fails initially, then will markUnderreplicated ledger as L000001(BK1 as the data).&lt;br/&gt;
Now again BK2 has failed, then while creating will get NEE, so we will append BK2 also like: L000001(BK1 BK2).&lt;/p&gt;

&lt;p&gt;I think &quot;break; statement&quot; is making sense and after that the duplicate entry addition should be removed as per my latest patch.&lt;br/&gt;
Am I missing anything?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The point of this code is, that if the node already exists, then there is already a missing replica. We loop through the missingReplicas, to see if the new missingReplica is already there or not. If so, then we can assume someone else has reported this replica missing, so we return. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yeah I&apos;ll add main method also. But what about retaining start() and stop() method as public. In future this will allow others(any external entity) to manage the recovery process easily ?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;start() and stop() as public is fine. But if initialization fails, the ctor should throw and exception. This way, the null checks are unneeded. &lt;/p&gt;

&lt;p&gt;Regarding Service, we can look at that again after this is in. See my comment on &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-247&quot; title=&quot;Detection of under replication&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-247&quot;&gt;&lt;del&gt;BOOKKEEPER-247&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13440194" author="rakeshr" created="Thu, 23 Aug 2012 11:34:40 +0100"  >&lt;p&gt;Thanks for the clarifications. Just commented the fix I&apos;m thinking. Could you have a look.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The point of this code is, that if the node already exists, then there is already a missing replica. We loop through the missingReplicas, to see if the new missingReplica is already there or not. If so, then we can assume someone else has reported this replica missing, so we return.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;so we have two scenarios:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;L0001 contains only BK1. while marking missingReplica of BK2, got NEE. Assume there is already a missing replica. Silently return as you told&lt;/li&gt;
	&lt;li&gt;L0001 contains only BK2. while marking missingReplica of BK2, got NEE. Assume only single auditor and no other is marking. So again we need to merge to the zkMetadata and update in zk.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;On NEE, &lt;br/&gt;
check whether missing replica has already present in the zk urLedger metadata. If yes return otherwise merge the missing replica to the urLedger missingreplicas and call setData()&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
       &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes = zkc.getData(znode, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, s);
       &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; existingMissingReplicas = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;(bytes, UTF8);
       &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(existingMissingReplicas.contains(missingReplica)){
              &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
       }
       TextFormat.merge(existingMissingReplicas, builder);
       zkc.setData(znode,
                  TextFormat.printToString(builder.build()).getBytes(UTF8),
                  s.getVersion());
       &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}&lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (KeeperException.NoNodeException nne) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13440199" author="ikelly" created="Thu, 23 Aug 2012 11:48:33 +0100"  >&lt;blockquote&gt;
&lt;p&gt;L0001 contains only BK1. while marking missingReplica of BK2, got NEE. Assume there is already a missing replica. Silently return as you told&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No, In this case we need to add BK2 as a missingReplica also.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;L0001 contains only BK2. while marking missingReplica of BK2, got NEE. Assume only single auditor and no other is marking. So again we need to merge to the zkMetadata and update in zk.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In this case we want to return. BK2 is already marked as a missingReplica, so it will be picked up for replication anyhow.&lt;/p&gt;

&lt;p&gt;The necessary change is:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
                } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (KeeperException.NodeExistsException nee) {
                    Stat s = zkc.exists(znode, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (s == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                        &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
                    }
                    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                        &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes = zkc.getData(znode, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, s);
                        TextFormat.merge(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;(bytes, UTF8), builder);
                        UnderreplicatedLedgerFormat data = builder.build();
                        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; r : data.getReplicaList()) {
                            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (r.equals(missingReplica)) {
-                                &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// nothing to add
&lt;/span&gt;+                                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// nothing to add
&lt;/span&gt;                            }
                        }
                        builder.addReplica(missingReplica);
                        zkc.setData(znode,
                                    TextFormat.printToString(builder.build()).getBytes(UTF8),
                                    s.getVersion());
                    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (KeeperException.NoNodeException nne) {
                        &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
                    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (KeeperException.BadVersionException bve) {
                        &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
                    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (TextFormat.ParseException pe) {
                        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReplicationException.UnavailableException(
                                &lt;span class=&quot;code-quote&quot;&gt;&quot;Invalid data found&quot;&lt;/span&gt;, pe);
                    }
                }
                &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

</comment>
                            <comment id="13440202" author="rakeshr" created="Thu, 23 Aug 2012 11:53:20 +0100"  >&lt;p&gt;Oh! yeah, there was a small mistake in my previous comment with BK1. Please read the scenario as:&lt;/p&gt;

&lt;p&gt;L0001 contains only BK1. while marking missingReplica of BK2, got NEE. Assume only single auditor and no other is marking. So again we need to merge to the zkMetadata and update in zk.&lt;/p&gt;</comment>
                            <comment id="13440205" author="ikelly" created="Thu, 23 Aug 2012 11:58:04 +0100"  >&lt;p&gt;Yes, the code I posted does exactly that. &quot;Merging&quot; is simply adding if it it doesn&apos;t already exist.&lt;/p&gt;</comment>
                            <comment id="13440211" author="rakeshr" created="Thu, 23 Aug 2012 12:08:29 +0100"  >&lt;p&gt;Thanks Ivan. I&apos;ll do the changes by just return if it matches as you suggested. I&apos;ll investigate it later.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Auditor will be a top level daemon, so it should own its create it&apos;s own LedgerManagers and ZooKeeper client. The only thing passed in to is should be the configuration.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Anyway we are planning to have initialization class which does starting Auditor and RW threads. Would you agree to create ledgerManagers there and pass it to the Auditor and RW daemons?&lt;/p&gt;

&lt;p&gt;In that case, shall I keep the ctor as it is. (by taking managers)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Auditor(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; bookieIdentifier, AbstractConfiguration conf,
            ZooKeeper zkc, LedgerManager ledgerManager,
            LedgerUnderreplicationManager ledgerUnderreplicationManager) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13440310" author="rakeshr" created="Thu, 23 Aug 2012 15:16:50 +0100"  >&lt;p&gt;Attached latest patch addressing Ivan&apos;s comment and also refactored tests. &lt;/p&gt;

&lt;p&gt;Hi Ivan, would be great to know your feedback.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Rakesh&lt;/p&gt;</comment>
                            <comment id="13441167" author="rakeshr" created="Fri, 24 Aug 2012 15:08:37 +0100"  >&lt;p&gt;&lt;ins&gt;Updates:&lt;/ins&gt;&lt;/p&gt;

&lt;p&gt;I&apos;ve raised another issue &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-380&quot; title=&quot;ZkLedgerUnderreplicationManager.markLedgerUnderreplicated() is adding duplicate missingReplicas while multiple bk failed for the same ledger&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-380&quot;&gt;&lt;del&gt;BOOKKEEPER-380&lt;/del&gt;&lt;/a&gt; for discussing the scenario about updating duplicate missing replicas in ZkLedgerUnderreplicationManager. &lt;/p&gt;

&lt;p&gt;Also, I rebased the patch for this issue by making it independent.&lt;/p&gt;</comment>
                            <comment id="13441400" author="ikelly" created="Fri, 24 Aug 2012 20:03:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;Anyway we are planning to have initialization class which does starting Auditor and RW threads. Would you agree to create ledgerManagers there and pass it to the Auditor and RW daemons?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think both auditor and RW daemon should have their own instances of the managers. We&apos;re only putting them in the same process for convenience. Otherwise they should be completely isolated except for communication though zookeeper.&lt;/p&gt;

&lt;p&gt;ZK_MAX_RETRY_TIMES - how can you still be auditor if you&apos;ve lost your zk connection? Have you guys actually seen intermittency with zookeeper? I dont think it&apos;s necessary to try and handle it. If the zk connection goes away, you lose your lock, someone else becomes auditor. The auditor does a scan when it comes online in any case, so it&apos;s not like we would miss an event.&lt;/p&gt;</comment>
                            <comment id="13441835" author="rakeshr" created="Sat, 25 Aug 2012 11:49:00 +0100"  >&lt;p&gt;Hi Ivan, Attached patch addressing the above comments.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think both auditor and RW daemon &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Now similar to the RW daemon, Auditor also initializing the managers himself.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ZK_MAX_RETRY_TIMES - how can you still be auditor if you&apos;ve lost your zk connection? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah, its true. I&apos;ve removed the retry logic and make the publishing logic simple&lt;/p&gt;

&lt;p&gt;Could you have a look at the latest patch.&lt;/p&gt;</comment>
                            <comment id="13442490" author="ikelly" created="Mon, 27 Aug 2012 17:03:52 +0100"  >&lt;p&gt;Committed as 1377716. Good work Rakesh.&lt;/p&gt;</comment>
                            <comment id="13442495" author="hudson" created="Mon, 27 Aug 2012 17:08:19 +0100"  >&lt;p&gt;Integrated in bookkeeper-trunk #674 (See &lt;a href=&quot;https://builds.apache.org/job/bookkeeper-trunk/674/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/bookkeeper-trunk/674/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-272&quot; title=&quot;Provide automatic mechanism to know bookie failures&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-272&quot;&gt;&lt;del&gt;BOOKKEEPER-272&lt;/del&gt;&lt;/a&gt;: Provide automatic mechanism to know bookie failures (rakeshr via ivank) (Revision 1377716)&lt;/p&gt;

&lt;p&gt;     Result = FAILURE&lt;br/&gt;
ivank : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                            <outwardlinks description="requires">
                                        <issuelink>
            <issuekey id="12595250">BOOKKEEPER-304</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12530531" name="BOOKKEEPER-272.1.patch" size="37055" author="rakeshr" created="Fri, 1 Jun 2012 11:17:03 +0100"/>
                            <attachment id="12531216" name="BOOKKEEPER-272.2.patch" size="79827" author="rakeshr" created="Thu, 7 Jun 2012 05:22:43 +0100"/>
                            <attachment id="12541372" name="BOOKKEEPER-272.3.patch" size="52684" author="rakeshr" created="Fri, 17 Aug 2012 15:27:03 +0100"/>
                            <attachment id="12542133" name="BOOKKEEPER-272.4.patch" size="51196" author="rakeshr" created="Thu, 23 Aug 2012 15:14:05 +0100"/>
                            <attachment id="12542275" name="BOOKKEEPER-272.5.patch" size="48515" author="rakeshr" created="Fri, 24 Aug 2012 15:04:39 +0100"/>
                            <attachment id="12542406" name="BOOKKEEPER-272.6.patch" size="46438" author="rakeshr" created="Sat, 25 Aug 2012 11:42:53 +0100"/>
                            <attachment id="12533319" name="BOOKKEEPER-272.Auditor.1.patch" size="43773" author="rakeshr" created="Mon, 25 Jun 2012 15:39:18 +0100"/>
                            <attachment id="12531374" name="BOOKKEEPER-272.Auditor.patch" size="29436" author="rakeshr" created="Fri, 8 Jun 2012 07:59:54 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 26 May 2012 18:01:04 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>293546</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyn6fz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>169231</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>