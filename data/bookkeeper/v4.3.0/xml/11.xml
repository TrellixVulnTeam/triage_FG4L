<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat May 16 23:29:14 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/BOOKKEEPER-11/BOOKKEEPER-11.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[BOOKKEEPER-11] Read from open ledger</title>
                <link>https://issues.apache.org/jira/browse/BOOKKEEPER-11</link>
                <project id="12311293" key="BOOKKEEPER">Bookkeeper</project>
                    <description>&lt;p&gt;The BookKeeper client currently does not allow a client to read from an open ledger. That is, if the creator of a ledger is still writing to it (and the ledger is not closed), then an attempt to open the same ledger for reading will execute the code to recover the ledger, assuming that the ledger has not been correctly closed.&lt;/p&gt;

&lt;p&gt;It seems that there are applications that do require the ability to read from a ledger while it is being written to, and the main goal of this jira is to discuss possible implementations of this feature.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12499416">BOOKKEEPER-11</key>
            <summary>Read from open ledger</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ikelly">Ivan Kelly</assignee>
                                    <reporter username="fpj">Flavio Junqueira</reporter>
                        <labels>
                    </labels>
                <created>Tue, 22 Feb 2011 22:45:38 +0000</created>
                <updated>Wed, 7 Dec 2011 15:56:14 +0000</updated>
                            <resolved>Thu, 28 Jul 2011 19:34:55 +0100</resolved>
                                                    <fixVersion>4.0.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="12998468" author="fpj" created="Wed, 23 Feb 2011 17:42:11 +0000"  >&lt;p&gt;Ben and I discussed this issue offline, and I&apos;d like to summarize our discussion. &lt;/p&gt;

&lt;p&gt;To enable readers to read from a ledger open for writing we need to have a couple of things in place:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;An openLedger call that does not try to recover the ledger if it can&apos;t find the corresponding ledger znode on zookeeper;&lt;/li&gt;
	&lt;li&gt;A notification mechanism to let the reader know how far it can read into a ledger and when.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;For the first point, we can add a new call to the api for unsafely opening a ledger. This call is unsafe in the sense that the end of the ledger is not known and the client needs to figure out what entries have been committed so that it can safely read them. &lt;/p&gt;

&lt;p&gt;This last point brings us to the discussion of how to notify the reader that new entries have been committed (we don&apos;t want a reader either waiting too long to read new entries or trying to guess when new entries have come in). &lt;br/&gt;
We see it possibly implemented in one of two ways: inside or outside bookkeeper. Implementing it inside bookkeeper is not trivial, since our replication protocol does not require bookies to talk to each other and no bookie individually knows when an entry has been committed. The second option seems to be more feasible. The writer can communicate periodically to one or more readers the entries that have been committed either directly or through zookeeper.&lt;/p&gt;

&lt;p&gt;One alternative for a reader to learn what entries have been committed is to read the last hint from bookies. We have a mechanism implemented that enables a reader to determine what was the last entry confirmed at the time the last entry of a ledger was generated. This approach, however, has the drawback that the hint is behind the last committed entry, since an entry can only have a previous entry as a hint.   &lt;/p&gt;

&lt;p&gt;Thoughts or questions?&lt;/p&gt;
</comment>
                            <comment id="12998501" author="dhruba" created="Wed, 23 Feb 2011 18:48:32 +0000"  >&lt;p&gt;when a reader is reading data from a ledger that is being written to concurrently, it should be fine even if the reader reads uncommitted data (i.e. data that is not yet written to a quorum set of bookies). In fact, the reader can go to any bookie and query how many records it currently have, and then read all those records. This could mean that we do not need any notification mechanism between the writer and concurrent-readers.&lt;/p&gt;</comment>
                            <comment id="12998546" author="fpj" created="Wed, 23 Feb 2011 21:06:12 +0000"  >&lt;p&gt;The problem of reading uncommitted entries is that the uncommitted entries may never be committed, and it may lead to inconsistencies in the system. Say that the writer writes entry n+1 to a single bookie and crashes before it is able to commit it. A concurrent reader may end up reading n+1, and a later client that recovers the ledger may end up reading up to n only. This might lead to inconsistencies in some use cases, perhaps not yours.&lt;/p&gt;

&lt;p&gt;At the same time, your description sort of supports our preference for notifying outside bookkeeper. If your use case does not require it, then you may choose not to implement it.&lt;/p&gt;



</comment>
                            <comment id="12999446" author="fpj" created="Fri, 25 Feb 2011 16:51:10 +0000"  >&lt;p&gt;Based on the previous discussion, I&apos;d like to propose that for now we expose a call that allows clients to open a ledger for reading unsafely in the sense that I explained above. Any objection or word of support? Dhruba?&lt;/p&gt;</comment>
                            <comment id="12999462" author="dhruba" created="Fri, 25 Feb 2011 18:40:04 +0000"  >&lt;p&gt;I think ur proposal allows a concurrent reader to read all entries upto the pennultimate committed record from the ledger. This sounds fine for now.&lt;/p&gt;

&lt;p&gt;On a related question: if the writer of the ledger dies a sudden death,  how long will it take after that event before the reader can read &lt;b&gt;all&lt;/b&gt; the committed entries from that ledger?&lt;/p&gt;</comment>
                            <comment id="13000400" author="breed" created="Mon, 28 Feb 2011 16:57:14 +0000"  >&lt;p&gt;the time to get the rest of the ledgers will be dominated by the time to detect the failure of the writer. for most applications you will already have something in place for failure detection. for example, in the case of the namenode, you will have a backup watching for the primary to die. when that happens, the backup will simply reopen the ledger and allow recovery to take place and read the last few entries. since it only needs to read the ones that were committed during recovery, this will happen very fast. &lt;/p&gt;</comment>
                            <comment id="13008693" author="fpj" created="Sat, 19 Mar 2011 00:11:17 +0000"  >&lt;p&gt;Adding a preliminary design doc. Comments are welcome as usual.&lt;/p&gt;</comment>
                            <comment id="13008738" author="dhruba" created="Sat, 19 Mar 2011 07:21:57 +0000"  >&lt;p&gt;design looks good.&lt;/p&gt;

&lt;p&gt;&quot;For example, the writer may report &lt;br/&gt;
every 10k writes or every minute, whichever happens &#64257;rst.&quot;&lt;/p&gt;

&lt;p&gt;I like this. It would be nice if zk can up updated with the last committed record id in the ledger. Also, can we make these two parameters configurable?&lt;/p&gt;</comment>
                            <comment id="13009158" author="ikelly" created="Mon, 21 Mar 2011 15:08:03 +0000"  >&lt;p&gt;Is &quot;Unsafe&quot; a good name for this? Once you&apos;ve written the last committed id, the operation is the same as reading from a ledger which had been closed at that last committed id. Isn&apos;t this safe?&lt;/p&gt;</comment>
                            <comment id="13009208" author="fpj" created="Mon, 21 Mar 2011 17:03:44 +0000"  >&lt;p&gt;Dhruba, I have updated the document to include a figure that illustrates the interaction I was trying to describe. Could you please have a look and let me know if it is clear for you and if you agree?&lt;/p&gt;</comment>
                            <comment id="13009211" author="fpj" created="Mon, 21 Mar 2011 17:07:53 +0000"  >&lt;p&gt;Ivan, the problem is that if you have no information on what entries have been committed, the application process might end up reading one entry that has only been partially written. For safety, the application has to implement a mechanism to guarantee that it will only read committed entries, a la TeaKeeper. The open call, however, is not aware of what the application is doing, so it doesn&apos;t know if the application is really reading only committed entries, and in that sense the open operation is unsafe. &lt;/p&gt;

&lt;p&gt;Do you agree now or it is still unclear for you? &lt;/p&gt;</comment>
                            <comment id="13009226" author="ikelly" created="Mon, 21 Mar 2011 17:33:28 +0000"  >&lt;p&gt;Ah, I thought you were going put those checks inside the client. i.e. Something like create a subclass of LedgerHandle, which puts a watcher on the lastConfirmed value and if the client tries to read past it, throw an exception. That does raise the issue of how do you see if new data becomes available. Perhaps you could have a watchLastAddConfirmed() call on LedgerHandle that triggers a callback when it comes available.&lt;/p&gt;</comment>
                            <comment id="13009233" author="dhruba" created="Mon, 21 Mar 2011 17:43:56 +0000"  >&lt;p&gt;Thanks for the picture, Flavio. I like Option 2. The folowing two comments are for Option 2:&lt;/p&gt;

&lt;p&gt;1. It would be nice to have the two parameters that Option 2 uses (the time or size after which ZK is updated) be configurable.&lt;/p&gt;

&lt;p&gt;2. The diagram shows that the App1 periodically informs ZK about the last committed seqid.  Can this interaction be handled by the BK client itself (instead of the App). For example,BookKeeper.java  can have the following API:&lt;/p&gt;

&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;  public long createLedger(...., boolean updateZk)&lt;/p&gt;
{quite}

&lt;p&gt;If updateZk is true, then the BookKeeper client itself will udpate zk with the last committed transaction at some given periodicity. This is similar in some sense to filesystems where the file-metadata becomes globally visible/readable after some time (even though the writer is continuing to write to the file).&lt;/p&gt;
</comment>
                            <comment id="13009704" author="fpj" created="Tue, 22 Mar 2011 16:34:22 +0000"  >&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-10&quot; title=&quot;Last hint for open ledger&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-10&quot;&gt;ZOOKEEPER-462&lt;/a&gt;, Utkarsh was not really in favor of having the BK client updating ZK periodically, since he thought that it was a functionality that should be implemented by the application. I avoided this direction mostly due to those comments.&lt;/p&gt;

&lt;p&gt;Now, discussing with Ivan earlier today, he gave a suggestion that I thought was interesting. He suggested that we could treat the CLOSED znode as checkpoint (and perhaps rename it) instead of updating it only at the end. That is, we could have a call that is something like &quot;checkpoint but keep open&quot;, which essentially updates the CLOSED znode with the last committed operation, but it does not represent the end of the ledger. The application could update it as often as it wants. &lt;/p&gt;

&lt;p&gt;How do you feel about this approach?&lt;/p&gt;</comment>
                            <comment id="13009992" author="dhruba" created="Wed, 23 Mar 2011 04:37:09 +0000"  >&lt;p&gt;Hi Flavio and Utkarsh: I see your point. Do you really want a BK application to directly interact with ZK? Isn&apos;t it better if the znodes are all hidden behind a BK api, so that it is easy to upgrade to a possibly new layout in future without impacting BK clients?&lt;/p&gt;

&lt;p&gt;is there any other reason why a BK api directly interacts with Znodes?&lt;/p&gt;

&lt;p&gt;another option would be to wrap the Znode access via a seperate BK api.&lt;/p&gt;</comment>
                            <comment id="13009998" author="utkarsh" created="Wed, 23 Mar 2011 05:04:45 +0000"  >&lt;p&gt;Dhruba, you bring up a good point. It&apos;s a broader issue with the whole BK design. The client is smart and the bookies are dumb. For Hedwig, this didn&apos;t bother me because the Hedwig servers were the BK clients, and the actual hedwig clients were insulated from all this ZK access. But for general BK clients, it might be better to have all this ZK access be done server side.&lt;/p&gt;</comment>
                            <comment id="13010000" author="dhruba" created="Wed, 23 Mar 2011 05:11:08 +0000"  >&lt;p&gt;Thanks Utkarsh.&lt;/p&gt;

&lt;p&gt;Maybe, at a minimum, we could have a BK client side APi that accesses the znode and sets the metatadata. We can still keep the Bookie dumb and at the same time shield the app form directly using the znodes.&lt;/p&gt;</comment>
                            <comment id="13010170" author="fpj" created="Wed, 23 Mar 2011 15:17:46 +0000"  >&lt;p&gt;Hi guys, Thanks for the comments.&lt;/p&gt;

&lt;p&gt;Utkarsh, I&apos;m not sure I understand why you say &quot;ZK access done server side&quot;. If we have access to ZK for open ledgers, I feel that it should be on the client, either through the application directly or through the BK client.&lt;/p&gt;

&lt;p&gt;Dhruba, what you suggest sounds like the proposal I posted yesterday. Could you please check it again?&lt;/p&gt;</comment>
                            <comment id="13010529" author="utkarsh" created="Thu, 24 Mar 2011 00:37:23 +0000"  >&lt;p&gt;Ideally, all ZK access would be done by the bookie, so that the client is as thin as possible. This scheme has certain nice properties like easy upgrades, changes to layout etc. as mentioned by Dhruba. But it&apos;s also a radical departure from the current BK design.&lt;/p&gt;

&lt;p&gt;I agree that accessing ZK through the BK client api is the only sane option right now.&lt;/p&gt;</comment>
                            <comment id="13010591" author="fpj" created="Thu, 24 Mar 2011 07:25:33 +0000"  >&lt;p&gt;Agreed, one main difficulty with updating ZK from bookies is that no bookie alone has all the information about a ledger, and bookies don&apos;t communicate with regular read/write protocol.&lt;/p&gt;</comment>
                            <comment id="13011434" author="chansler" created="Fri, 25 Mar 2011 21:37:48 +0000"  >&lt;p&gt;Trying too hard? For the HDFS application, and a big cluster, a reader that reaches the end of the ledger can sleep for a second, and then confidently expect to find hundreds of additional records. &lt;br/&gt;
Whether and/or how to fault the writing process should be a separate issue. (See Ben&apos;s comment from 28 February.)&lt;/p&gt;</comment>
                            <comment id="13011983" author="fpj" created="Mon, 28 Mar 2011 10:43:33 +0100"  >&lt;p&gt;Rob, I agree with handling writer failures separately. What I&apos;m trying to understand, and this is how I interpret the discussion so far, is if we should provide some functionality in the BK client to write periodically to ZooKeeper ranges of entry identifiers that have been committed or if we should leave to the application on top of BK to do it (if the app needs it, of course).&lt;/p&gt;</comment>
                            <comment id="13012192" author="chansler" created="Mon, 28 Mar 2011 20:36:20 +0100"  >&lt;p&gt;Flavio, for the HDFS journal, there is no need for elaborate connections with ZooKeeper. A feature that would be convenient for readers, is an indication whether a returned record is committed. (All records of a closed ledger are committed; record N of an open ledger is committed only if exists record M where M.LC is greater or equal to N.) Otherwise a reader must buffer an arbitrary number of records, or else be in close agreement with the writer that the number of uncommitted records is bounded. (OK for HDFS, I&apos;d think.) Read(N) has 4 return possibilities: Here is committed record N, here is record N but it&apos;s not yet committed, there is no record N in the open ledger, N is beyond the end of the closed ledger.&lt;/p&gt;</comment>
                            <comment id="13012416" author="fpj" created="Tue, 29 Mar 2011 10:59:49 +0100"  >&lt;p&gt;I also agree that it is not strictly necessary for the HDFS journal to have the NN connecting to ZooKeeper, since the information of what entries have been committed can be conveyed in other ways, e.g., by explicitly sending from the writer to the reader(s). Bookies can&apos;t provide the hints you&apos;re referring to because no single bookie has a global view of a ledger. Consequently, I can only see those hints working either via ZooKeeper or via direct communication.&lt;/p&gt;

&lt;p&gt;Since we use a ZooKeeper instance to manage a bookie pool and the BK client talks to ZooKeeper today, the discussion so far seems to converge to using ZooKeeper to pass the information on what entries are committed. One idea we have suggested in this jira to do it through the BK client is to have the writer periodically writing to the CLOSED znode the last committed entry, and having the reader(s) reading this value. The mechanism to write the CLOSED znode is there already, so there is a small amount of code change needed. We need essentially to introduce a call to the BK api that forces the BK client to write the CLOSED znode.&lt;/p&gt;

&lt;p&gt;Given that some applications, including the NN, might learn of committed entries through ZooKeeper, it seems to make sense to incorporate such accesses to ZooKeeper to the BK client, but I don&apos;t think we have reached agreement on it yet and leaving to the application to implement it when needed is still an option. If we do it in the way I suggest, then an application would not be forced to use ZooKeeper for such hints, and direct communication would also be possible. &lt;/p&gt;

&lt;p&gt;Also, If we end up going this direction of periodically writing to the CLOSED znode, we should change the name of the znode to something else, since it doesn&apos;t really represent any longer what the znode does.&lt;/p&gt;

</comment>
                            <comment id="13012843" author="dhruba" created="Wed, 30 Mar 2011 05:40:09 +0100"  >&lt;p&gt;&amp;gt; to do it through the BK client is to have the writer periodically writing to the CLOSED znode the last committed entry, &lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; incorporate such accesses to ZooKeeper to the BK client&lt;/p&gt;

&lt;p&gt;+1 &lt;/p&gt;</comment>
                            <comment id="13014857" author="chansler" created="Fri, 1 Apr 2011 23:33:50 +0100"  >&lt;p&gt;Can a client reading an open ledger from bookie B ever be confident that it will see committed record N &lt;em&gt;short of the ledger being closed&lt;/em&gt;? If the answer is No, then it seems that even if an oracle tells me that N is committed, then my reading client must survey a quorum of bookies to be certain of finding record N. And a survey of a quorum of bookies would also find the record that commits N, obviating the need for any oracle. If the answer is Yes, the reading client will see record N without the complexity of consulting the oracle if only the reader is a little patient.&lt;/p&gt;

&lt;p&gt;Anyway, for HDFS, why not just start a new ledger every minute, and have the standby server only read from closed ledgers? (Sixty seconds of latency.)&lt;/p&gt;</comment>
                            <comment id="13014944" author="dhruba" created="Sat, 2 Apr 2011 04:47:52 +0100"  >&lt;p&gt;On a related question: is the writing of a ledger entry atomic (for a single bookie)? For example, if an application writes a ledger entry to a certain bookie and a concurrent reader tries to read that entry (even if that entry is not committed to all bookies), is it possible that only a part of that ledger entry is visible to the reader?&lt;/p&gt;</comment>
                            <comment id="13015314" author="fpj" created="Mon, 4 Apr 2011 09:36:09 +0100"  >&lt;p&gt;@Rob&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can a client reading an open ledger from bookie B ever be confident that it will see committed record N short of the ledger being closed? If the answer is No, then it seems that even if an oracle tells me that N is committed, then my reading client must survey a quorum of bookies to be certain of finding record N. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;An oracle tells you that entry up to N has been committed (written to a quorum), so the client knows that if it reads up to N, the it is safe. To find any given entry, we follow the same order scheme as the writer does (for efficiency), so the client does not have to scan all bookies to find an entry, so your observation about reading from a quorum is correct. However, it is important to note that quorums in BookKeeper are not necessarily majorities. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;And a survey of a quorum of bookies would also find the record that commits N, obviating the need for any oracle. If the answer is Yes, the reading client will see record N without the complexity of consulting the oracle if only the reader is a little patient.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is not correct. The fact that a client finds a copy of an entry in one bookie does necessarily mean that the entry has been committed. Not finding it in a quorum also does not mean that it hasn&apos;t been committed, since one bookie might be unavailable at the time of the query.&lt;/p&gt;

&lt;p&gt;There has to be agreement somewhere in the system about the committed entries, and so far we have done it through zookeeper when a ledger closes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Anyway, for HDFS, why not just start a new ledger every minute, and have the standby server only read from closed ledgers? (Sixty seconds of latency.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t see any important problem with this solution, aside from the overhead of creating many ledgers over time. &lt;/p&gt;

&lt;p&gt;@dhruba&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;is the writing of a ledger entry atomic (for a single bookie)? For example, if an application writes a ledger entry to a certain bookie and a concurrent reader tries to read that entry (even if that entry is not committed to all bookies), is it possible that only a part of that ledger entry is visible to the reader?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The interface to a bookie is simple: if you ask for an entry of a given ledger and the entry exists, then the bookie will return. That&apos;s main reason why we need to make sure that the reader only requests committed entries.&lt;/p&gt;</comment>
                            <comment id="13015496" author="chansler" created="Mon, 4 Apr 2011 17:58:51 +0100"  >&lt;p&gt;Thanks, Flavio, for your patient explanations!&lt;/p&gt;

&lt;p&gt;I have one more question about reading while writing. If I ask a bookie for record M, either the bookie has the record or doesn&apos;t have the record. Regardless, the bookie has a greatest record N, and let X=N.lc. Now record N may not be committed, but record X &lt;em&gt;is&lt;/em&gt; committed. And so the bookie can return not only record M, if available, but also a flag indicating whether X&#8805;M. If my bookie returns M but X&amp;lt;M, I can wait a little bit and ask again. If the writer agrees that the difference between N and N.lc is bounded, won&apos;t a reader with just a little patience (the expected time between M and N.lc&#8805;M) continue to make progress? Making progress is the goal, not knowing the very last committed record. And you can&apos;t &lt;em&gt;know&lt;/em&gt; the &lt;em&gt;last&lt;/em&gt; committed record until the ledger is closed, in any case. &lt;/p&gt;</comment>
                            <comment id="13017177" author="fpj" created="Thu, 7 Apr 2011 23:02:07 +0100"  >&lt;p&gt;Hi Rob, No problem at all!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If I ask a bookie for record M, either the bookie has the record or doesn&apos;t have the record. Regardless, the bookie has a greatest record N, and let X=N.lc. Now record N may not be committed, but record X is committed. And so the bookie can return not only record M, if available, but also a flag indicating whether X&#8805;M. If my bookie returns M but X&amp;lt;M, I can wait a little bit and ask again. If the writer agrees that the difference between N and N.lc is bounded, won&apos;t a reader with just a little patience (the expected time between M and N.lc&#8805;M) continue to make progress? Making progress is the goal, not knowing the very last committed record. And you can&apos;t know the last committed record until the ledger is closed, in any case. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, we have an equivalent feature implemented in bookies today. If I send a request to some bookie to read an entry from a given ledger and the entry id is -1, it will return the id of the last committed write it knows about (we have called it confirmed writes so far, and not committed). The bookie learns of committed writes through regular writes, since one of the fields of the write request is the &quot;last confirmed hint&quot;, which is the last confirmed entry the client writer has.&lt;/p&gt;

&lt;p&gt;Using the hint is actually one of strategies I suggest in the very first post of this jira. I think it is a good approach too, and might simply require exposing it to the application.   &lt;/p&gt;</comment>
                            <comment id="13017525" author="chansler" created="Fri, 8 Apr 2011 17:37:31 +0100"  >&lt;p&gt;Of course Flavio had the right answer in the first comment!&lt;/p&gt;

&lt;p&gt;Now that is settled, I have one more question out of curiosity. When the ledger is closed, all bookies may have received record N, but the writing client may not have committed N by setting X.LC&#8805;N for some other record X &amp;gt; N. Is N committed in the closed ledger? Sometimes? Always? Never?&lt;/p&gt;</comment>
                            <comment id="13017643" author="fpj" created="Fri, 8 Apr 2011 22:06:10 +0100"  >&lt;p&gt;One drawback I see with the solution in the first comment that you rederived is that the reader has to keep probing bookies for new entries, which generates unnecessary traffic when the application running on top is idle. It might not be a big deal in the case of the NN, but this is just to point out that with the LC hint, we can&apos;t benefit from notifications (through ZK watches).&lt;/p&gt;

&lt;p&gt;When we close a ledger, we write the last committed entry to a closed znode, and that znode also establishes that the writer is done with the ledger. We don&apos;t change the LC hint on bookies once we close a ledger. &lt;/p&gt;</comment>
                            <comment id="13053704" author="fpj" created="Thu, 23 Jun 2011 09:22:06 +0100"  >&lt;p&gt;Preliminary patch, it does not include tests, but compiles and original tests pass (not surprising given the patch).&lt;/p&gt;

&lt;p&gt;This patch changes the API to add calls that allow an application to:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Open a ledger unsafely for reading. Unsafely means that the client won&apos;t try to recover if the ledger is not closed. Opening a ledger this way, enables a client app to read from an open ledger;&lt;/li&gt;
	&lt;li&gt;Request the last confirmed entry from some quorum of bookies.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="13053910" author="ikelly" created="Thu, 23 Jun 2011 15:55:37 +0100"  >&lt;p&gt;Patch looks good. I have a few comments.&lt;/p&gt;

&lt;p&gt;Im not sure asyncOpenLedgerUnsafe conveys what it actually does. To the user of the api it may convey that it is unsafe to do this. I think something like asyncOpenActiveLedger would be more descriptive.&lt;/p&gt;

&lt;p&gt;There&apos;s a couple of variables, such as LedgerOpenOp#unsafe which should be declared final. If they should never change they should be marked as such so people don&apos;t try to change them in the future.&lt;/p&gt;

&lt;p&gt;In the line:&lt;br/&gt;
+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, lh.ledgerId, -1, this, i);&lt;br/&gt;
-1 is a magic number. This should be defined as a MAX_ENTRY_ID or UNKNOWN_ENTRY_ID constant somewhere. &lt;/p&gt;

&lt;p&gt;In the readEntryComplete, it looks as if you return the maximum value you see on any bookie. However, since this isn&apos;t a quorum, it could come from only one machine which could subsequently crash (along with the writing client) before the other bookies see it. Is this correct?&lt;/p&gt;</comment>
                            <comment id="13054400" author="fpj" created="Fri, 24 Jun 2011 13:26:23 +0100"  >&lt;p&gt;Thanks for checking, Ivan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Im not sure asyncOpenLedgerUnsafe conveys what it actually does. To the user of the api it may convey that it is unsafe to do this. I think something like asyncOpenActiveLedger would be more descriptive. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The problem is that the writer of the ledger might have failed at the time the application invokes &quot;asyncOpenActiveLedger&quot;. Consequently, the ledger might not really be active anymore, and the application must know of that possibility. I don&apos;t mind changing the name, but I don&apos;t feel that OpenActive makes it better.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There&apos;s a couple of variables, such as LedgerOpenOp#unsafe which should be declared final. If they should never change they should be marked as such so people don&apos;t try to change them in the future. &lt;/p&gt;&lt;/blockquote&gt; 

&lt;p&gt;Ok. Listing the variables will help.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the readEntryComplete, it looks as if you return the maximum value you see on any bookie. However, since this isn&apos;t a quorum, it could come from only one machine which could subsequently crash (along with the writing client) before the other bookies see it. Is this correct? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Due to concurrent writes and striping, we are not guaranteed to have a quorum returning the same last hint. But, given that we compute a digest and verify upon reading, whatever value we return should be correct. In fact, it is ok to return the first value we receive. I&apos;ve made it wait for a quorum because by assumption there must be at least one quorum available, ans we have a chance of returning a larger value (assuming there is one) if we read from more bookies . Waiting for more than a quorum does not guarantee that the operation will return.&lt;/p&gt;

</comment>
                            <comment id="13055515" author="ikelly" created="Mon, 27 Jun 2011 13:59:45 +0100"  >&lt;blockquote&gt;
&lt;p&gt;The problem is that the writer of the ledger might have failed at the time the application invokes &quot;asyncOpenActiveLedger&quot;. Consequently, the ledger might not really be active anymore, and the application must know of that possibility. I don&apos;t mind changing the name, but I don&apos;t feel that OpenActive makes it better.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is true. &quot;Active&quot; doesn&apos;t adequately describe either given this. How about openLedgerReadOnly? I have doubts about this too because usually opening a ledger is a read only op anyhow. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ok. Listing the variables will help.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;So, in this patch, LedgerOpenOp#unsafe, ReadLastConfirmedOp#lh &amp;amp; ReadLastConfirmedOp#ctx are the new member variables which should be final. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Due to concurrent writes and striping, we are not guaranteed to have a quorum returning the same last hint. But, given that we compute a digest and verify upon reading, whatever value we return should be correct. In fact, it is ok to return the first value we receive. I&apos;ve made it wait for a quorum because by assumption there must be at least one quorum available, ans we have a chance of returning a larger value (assuming there is one) if we read from more bookies . Waiting for more than a quorum does not guarantee that the operation will return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ah, I think my understanding was that I didnt see it was using lastAddConfirmed and not entryId itself. &lt;/p&gt;</comment>
                            <comment id="13055627" author="dhruba" created="Mon, 27 Jun 2011 17:16:57 +0100"  >&lt;p&gt;Does this patch implement Option 1 or Option 2.... looks like it is Option 2, but instead of updating the znode periodically, the new reader will request the last-committed-entry from a set of quorum bookies, is that right?&lt;/p&gt;</comment>
                            <comment id="13059542" author="fpj" created="Mon, 4 Jul 2011 19:48:16 +0100"  >&lt;p&gt;It is actually neither &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ... But you&apos;re right, it is closer to Option 2, and it obtains a committed entry by reading the last confirmed entry from a quorum.&lt;/p&gt;</comment>
                            <comment id="13062755" author="fpj" created="Sun, 10 Jul 2011 17:28:54 +0100"  >&lt;p&gt;I&apos;ve updated the design doc to reflect the changes of the patch I proposed.&lt;/p&gt;</comment>
                            <comment id="13062797" author="dhruba" created="Sun, 10 Jul 2011 20:49:35 +0100"  >&lt;p&gt;Nice document. Are we going to implement Option 3?&lt;/p&gt;</comment>
                            <comment id="13062804" author="fpj" created="Sun, 10 Jul 2011 21:50:38 +0100"  >&lt;p&gt;My understanding of the previous discussions was that it was the overall preferred option, but I&apos;m happy to consider another option if you see any problem with Option 3, Dhruba.&lt;/p&gt;</comment>
                            <comment id="13062844" author="dhruba" created="Mon, 11 Jul 2011 04:25:01 +0100"  >&lt;p&gt;Option 3 looks great to me. it should satisfy the requirements for supporting AvatarNode.&lt;/p&gt;</comment>
                            <comment id="13063870" author="fpj" created="Tue, 12 Jul 2011 14:06:10 +0100"  >&lt;p&gt;Implemented the changes Ivan suggested and replaced &quot;Unsafe&quot; with &quot;NoRecovery&quot; in the new API calls. &lt;/p&gt;

&lt;p&gt;The patch includes tests, but does not include changes to the documentation. I actually need to get used to the new way of generating documentation. &lt;/p&gt;</comment>
                            <comment id="13067073" author="fpj" created="Mon, 18 Jul 2011 16:11:22 +0100"  >&lt;p&gt;Patch includes changes to the documentation.&lt;/p&gt;</comment>
                            <comment id="13072474" author="ikelly" created="Thu, 28 Jul 2011 19:34:36 +0100"  >&lt;p&gt;+1 &lt;/p&gt;

&lt;p&gt;Committed in r1151958.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12430130">BOOKKEEPER-10</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12486878" name="BOOKKEEPER-11.patch" size="27180" author="fpj" created="Mon, 18 Jul 2011 16:10:13 +0100"/>
                            <attachment id="12486179" name="BOOKKEEPER-11.patch" size="23463" author="fpj" created="Tue, 12 Jul 2011 14:06:10 +0100"/>
                            <attachment id="12483557" name="BOOKKEEPER-11.patch" size="13147" author="fpj" created="Thu, 23 Jun 2011 09:22:06 +0100"/>
                            <attachment id="12485999" name="bk-11-design-doc.pdf" size="83281" author="fpj" created="Sun, 10 Jul 2011 17:28:54 +0100"/>
                            <attachment id="12474188" name="zk-1001-design-doc.pdf" size="63418" author="fpj" created="Mon, 21 Mar 2011 17:02:14 +0000"/>
                            <attachment id="12474046" name="zk-1001-design-doc.pdf" size="28086" author="fpj" created="Sat, 19 Mar 2011 00:11:17 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 23 Feb 2011 18:48:32 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>66696</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy9ozj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>90527</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>