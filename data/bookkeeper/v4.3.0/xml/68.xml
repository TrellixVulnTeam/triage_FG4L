<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat May 16 23:30:52 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/BOOKKEEPER-68/BOOKKEEPER-68.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[BOOKKEEPER-68] Conditional setData</title>
                <link>https://issues.apache.org/jira/browse/BOOKKEEPER-68</link>
                <project id="12311293" key="BOOKKEEPER">Bookkeeper</project>
                    <description>&lt;p&gt;The write to ZooKeeper to store ledger metadata when closing a ledger must be conditional, otherwise concurrent clients might end up writing in a way that the update of a client overwrites the update of the other. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12523619">BOOKKEEPER-68</key>
            <summary>Conditional setData</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ikelly">Ivan Kelly</assignee>
                                    <reporter username="fpj">Flavio Junqueira</reporter>
                        <labels>
                    </labels>
                <created>Mon, 19 Sep 2011 22:07:43 +0100</created>
                <updated>Wed, 7 Dec 2011 15:56:12 +0000</updated>
                            <resolved>Tue, 18 Oct 2011 09:43:31 +0100</resolved>
                                                    <fixVersion>4.0.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="13108214" author="fpj" created="Tue, 20 Sep 2011 00:08:05 +0100"  >&lt;p&gt;Preliminary patch (no new test, but current tests pass).&lt;/p&gt;</comment>
                            <comment id="13108620" author="ikelly" created="Tue, 20 Sep 2011 13:05:20 +0100"  >&lt;p&gt;This patch seems to just cause the open ledger to fail. Shouldn&apos;t the failing one just retry to read the metadata?&lt;/p&gt;</comment>
                            <comment id="13108627" author="fpj" created="Tue, 20 Sep 2011 13:25:24 +0100"  >&lt;p&gt;I&apos;d rather leave to the application to decide because of the following argument. Suppose that two clients try to recover the ledger because are on the way of taking over the role of primary. The fact that one attempt to open the ledger and recover fails indicates that there has a been a concurrent attempt, and in this case I would say that the client that gets a failed request should actually back off. &lt;/p&gt;

&lt;p&gt;Does it make sense to you, Ivan?&lt;/p&gt;</comment>
                            <comment id="13108746" author="ikelly" created="Tue, 20 Sep 2011 15:38:05 +0100"  >&lt;p&gt;Im not sure. I think that situations like this should have an external mechanism. I&apos;ve actually implemented a bit of the handling for BadVersion. It&apos;ll need a lot of testing though.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ivankelly/bookkeeper/commit/7b2d2f9163afb735e73e3e285f2d358bb4b71fda&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/ivankelly/bookkeeper/commit/7b2d2f9163afb735e73e3e285f2d358bb4b71fda&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13108761" author="fpj" created="Tue, 20 Sep 2011 15:58:57 +0100"  >&lt;p&gt;I think you&apos;re right in that we would need such an external mechanism anyway because the absence of a failure does not imply that it is ok to take over in my example. Consequently, retrying does not make it more difficult for the application. &lt;/p&gt;

&lt;p&gt;I still feel that the code is simpler without retrying, though, and it doesn&apos;t sound like a big deal for the application to retry if it needs to. At the same time, I&apos;m possibly not the best person to ask about APIs, so I&apos;m willing to change my mind here if there is a good reason for doing it.&lt;/p&gt;</comment>
                            <comment id="13109832" author="fpj" created="Wed, 21 Sep 2011 21:01:32 +0100"  >&lt;p&gt;I was also thinking that leaving to the application gives the opportunity to the client to give up. One case I can think of in which not retrying might be better is this. We have two cold backup servers, and both try to become the primary. They concurrently start to read from bookkeeper and, in the process, they try to recover the ledger. If one fails to recover because of the concurrent write of the ledger metadata, then it is better to have one replica giving up, since it will leave more read bandwidth free to the other backup server. &lt;/p&gt;

&lt;p&gt;I need to point out that I think both approaches are correct, and the argument I&apos;m making is based on performance. My conclusion is that I don&apos;t feel strongly about having one way or the other, but I&apos;m slightly inclined to leaving it to the application. &lt;/p&gt;</comment>
                            <comment id="13112216" author="dhruba" created="Thu, 22 Sep 2011 00:15:09 +0100"  >&lt;p&gt;I am more inclined to say that for the use case of NN using BK, it makes sense to make one of the standby namenodes  to fail the recover-ledger api call (rather than retrying inside the BK client). The standby namenode will go back to ZK to see if a new namenode master has been selected, if not then the standby namenode can retry.&lt;/p&gt;

&lt;p&gt;Ivan: is there some other approach that you have in mind?&lt;/p&gt;</comment>
                            <comment id="13112411" author="ikelly" created="Thu, 22 Sep 2011 09:36:16 +0100"  >&lt;p&gt;The approach I had is at:&lt;br/&gt;
&lt;a href=&quot;https://github.com/ivankelly/bookkeeper/tree/Fencing&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/ivankelly/bookkeeper/tree/Fencing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Basically, if you fail to update, you jump back to the very start of recovery. The recovery operation is idempotent in this case, so it will succeed in opening for reading. For NN, there would be another mechanism to ensure that only one ledger is open for writing at a time, as really that&apos;s where we want collisions to happen if they do happen. &lt;/p&gt;

&lt;p&gt;Flavio made a good point yesterday that multiple concurrent recoveries will steal bandwidth from each other though, which I think is the best argument for erroring one of them out.&lt;/p&gt;

&lt;p&gt;Actually, the BKJournal for NN is available at:&lt;br/&gt;
&lt;a href=&quot;https://github.com/ivankelly/hadoop-common/tree/BKJournal&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/ivankelly/hadoop-common/tree/BKJournal&lt;/a&gt;&lt;br/&gt;
if you want to take a look. &lt;/p&gt;</comment>
                            <comment id="13123473" author="fpj" created="Sat, 8 Oct 2011 13:53:58 +0100"  >&lt;p&gt;Patch with test. In the end, the test was way easier to write than I expected. I simply create a reader before the writer closes the ledger, and I check that the writer call to close the ledger fails. &lt;/p&gt;

&lt;p&gt;To be able to verify that the call to close has failed, I needed to change the signature of the close call, which was returning void. Hope no one finds it to be a big deal.&lt;/p&gt;</comment>
                            <comment id="13124529" author="fpj" created="Mon, 10 Oct 2011 23:20:44 +0100"  >&lt;p&gt;After making the modifications that Ivan suggested, I noticed while running the tests that BookieRecoveryTest was failing intermittently, so I investigated it a bit and found the following. &lt;/p&gt;

&lt;p&gt;Currently when we recover a ledger, we acknowledge the open before waiting for the ledger to close. Not waiting was causing a race while recovering bookies. I have fixed the problem in the patch I&apos;m attaching.&lt;/p&gt;

&lt;p&gt;There is one tiny thing that is bugging me in this patch and I need to fix. I need to access the znodeVersion variable from BookKeeperTools, and to do it I made the variable public just to test. I need to find a better way of accessing the znode version variable in LedgerMetadata, though.&lt;/p&gt;</comment>
                            <comment id="13126668" author="fpj" created="Thu, 13 Oct 2011 16:31:45 +0100"  >&lt;p&gt;Posted the diff on the review board.&lt;/p&gt;</comment>
                            <comment id="13129262" author="fpj" created="Mon, 17 Oct 2011 23:22:22 +0100"  >&lt;p&gt;Fixed the last point on the return code that Ivan raised on the review board. -F&lt;/p&gt;</comment>
                            <comment id="13129596" author="ikelly" created="Tue, 18 Oct 2011 09:43:18 +0100"  >&lt;p&gt;Committed r1185532, thanks Flavio.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12499459" name="BOOKKEEPER-68.patch" size="16030" author="fpj" created="Mon, 17 Oct 2011 23:22:22 +0100"/>
                            <attachment id="12498889" name="BOOKKEEPER-68.patch" size="15909" author="fpj" created="Thu, 13 Oct 2011 16:31:45 +0100"/>
                            <attachment id="12498478" name="BOOKKEEPER-68.patch" size="15295" author="fpj" created="Mon, 10 Oct 2011 23:20:44 +0100"/>
                            <attachment id="12498310" name="BOOKKEEPER-68.patch" size="9953" author="fpj" created="Sat, 8 Oct 2011 13:53:58 +0100"/>
                            <attachment id="12495160" name="BOOKKEEPER-68.patch" size="3336" author="fpj" created="Tue, 20 Sep 2011 00:08:05 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 20 Sep 2011 12:05:20 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>50588</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hynzh3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>173934</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>