<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat May 16 23:30:25 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/BOOKKEEPER-365/BOOKKEEPER-365.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[BOOKKEEPER-365] Ledger will never recover if one of the quorum bookie is down forever and others dont have entry</title>
                <link>https://issues.apache.org/jira/browse/BOOKKEEPER-365</link>
                <project id="12311293" key="BOOKKEEPER">Bookkeeper</project>
                    <description>&lt;p&gt;As discussed in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;, current fix to handle the below issue is not correct. Need to find out new solution&lt;br/&gt;
If some bookies of a quorum gone forever, some bookies of this quorum are still alive but doesn&apos;t have that entry (NoSuchEntry or NoSuchLedger), then the ledger doesn&apos;t have any evidence to recovery/close it.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12603455">BOOKKEEPER-365</key>
            <summary>Ledger will never recover if one of the quorum bookie is down forever and others dont have entry</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hustlmsp">Sijie Guo</assignee>
                                    <reporter username="hustlmsp">Sijie Guo</reporter>
                        <labels>
                    </labels>
                <created>Tue, 14 Aug 2012 15:09:04 +0100</created>
                <updated>Wed, 13 Feb 2013 15:46:25 +0000</updated>
                            <resolved>Thu, 13 Dec 2012 11:33:40 +0000</resolved>
                                    <version>4.0.0</version>
                    <version>4.1.0</version>
                                    <fixVersion>4.2.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13434177" author="hustlmsp" created="Tue, 14 Aug 2012 16:09:46 +0100"  >&lt;p&gt;I would try to summarize the problem of recovery read causing by current read strategy.&lt;/p&gt;

&lt;p&gt;suppose A, B, C is the quorum that an entry try to read.&lt;/p&gt;

&lt;p&gt;1) if A, B returns NoSuchEntry/NoSuchLedger, C couldn&apos;t connect. the read response return CouldNotConnectException.&lt;br/&gt;
2) if A couldn&apos;t connect, B, C returns NoSuchEntry/NoSuchLedger. the read response return NoSuchEntry/NoSuchLedger.&lt;/p&gt;

&lt;p&gt;LedgerRecovery treats 1) as failure would not close ledger while treats 2) as normal case to close the ledger.&lt;/p&gt;

&lt;p&gt;But neither 1) nor 2) acts correctly.&lt;/p&gt;

&lt;p&gt;For 1), if recovery read tries read an non-existed entry, all A, B, C don&apos;t have the entry. if C goes down&apos;t forever, BookKeeperAdmin runs BookieRecovery to replace C. But it still can&apos;t close the ledger to proceed recovery. so the ledger would not be available for read.&lt;/p&gt;

&lt;p&gt;For 2), closing the ledger would cause entry loss if A encountering a transient failure such as network partition.&lt;/p&gt;

&lt;p&gt;One possible idea for recovery read of last entry, we only close the ledger when received NoSuchLedger/NoSuchEntry from all quorums, which resolves 2). But it still have problem 1) if a machine is gone forever. for 1), the ledger status is undetermined. it would cause lots of ledgers are unreadable (could not be open) if we try to replace a bookie (using BookieAdmin) which happens to be the last bookie in last ensemble. &lt;/p&gt;

&lt;p&gt;Just wrote down my previous ideas. Welcome for comments.&lt;/p&gt;</comment>
                            <comment id="13490273" author="yx3zhu@gmail.com" created="Sun, 4 Nov 2012 19:30:23 +0000"  >&lt;p&gt;In general, Quorum based read/write requires that Qw + Qr &amp;gt; Q. e.g. the ensemble size is 3, write quorum is 2, read quorum needs to be at least 2.&lt;/p&gt;

&lt;p&gt;In BK, we relax it by using read quorum 1. It works because it never updates an entry once its written.&lt;/p&gt;

&lt;p&gt;In your example, it seems the ensemble size 3, read quorum 1, write quorum 2.&lt;/p&gt;

&lt;p&gt;During recovery, we can raise the standard, requiring read quorum 2, which address above issue.&lt;/p&gt;
</comment>
                            <comment id="13490288" author="yx3zhu@gmail.com" created="Sun, 4 Nov 2012 20:15:33 +0000"  >&lt;p&gt;To add more detail, the recovery needs to consult at least read-quorum (2) bookies to get last-confirmed entry id, instead of max of all, uses the max entry id which at least two bookies have. Let us call this read_quorum_rule.&lt;/p&gt;

&lt;p&gt;Now we go back to your example,&lt;br/&gt;
1) can proceed since both A, B claim no entries for the ledger, the last-confirmed-entry-id is 0 based on the read_quorum_rule.&lt;br/&gt;
2) is correct, as B and C claim no entries for the ledger.&lt;/p&gt;

&lt;p&gt;Of course, if recovery cannot reach at least read-quorum(2) bookies, then it cannot close the ledger.&lt;/p&gt;

&lt;p&gt;The reasoning is based on the fact that if Write-quorum is not reached, then the entry is not acknowledged to clients. It is legal for it to be lost.&lt;/p&gt;</comment>
                            <comment id="13529078" author="fpj" created="Tue, 11 Dec 2012 16:02:07 +0000"  >&lt;p&gt;Let me add a few comments to this discussion.&lt;/p&gt;

&lt;p&gt;In Sijie&apos;s example, has the entry is being read ever written successfully to all of A, B, and C? From the example, it is not clear, but I&apos;m assuming that the write quorum is 3. If so, then it violates an assumption we make for the system. We can detect corrupt entries with the digest, but we can&apos;t really always guarantee recovery in the case that bookies drop entries altogether. &lt;/p&gt;

&lt;p&gt;To simplify perhaps the discussion and illustrate what we guarantee, say that we write entries to two bookies. When it is time to read a given entry (successfully written) let&apos;s say that one bookie has corrupted it and the other is partitioned away. The client executing the recovery procedure see the corrupt copy of the entry and it doesn&apos;t know if the other bookie has a good copy or not. If it does, then the entry has been written successfully. If it doesn&apos;t, then the entry hasn&apos;t been written successfully. To decide, we need the second bookie, so we can&apos;t close the ledger until the second bookie comes back. We should perhaps review what exception we would get in this case. &lt;/p&gt;

&lt;p&gt;In Andrew&apos;s observation, it is correct that if the client hasn&apos;t written enough copies (ack quorum), then we don&apos;t guarantee that the entry will be there when the ledger is closed. Keep in mind that we don&apos;t use all possible read/write quorums, since we pick quorums in a round-robin fashion. When recovering a ledger, we need to touch every write quorum we can possibly use to fence off the writer. Read and write quorums overlap fully by design. &lt;/p&gt;

&lt;p&gt;One point I don&apos;t understand is why we should expect to get the same LAC (Last Add Confirmed) from two different bookies. Each bookie could have a different one, and it would be ok. Also, keep in mind that LAC is only a hint. After we pick a LAC, we still try to read after that value to see how far we can go.&lt;/p&gt;

&lt;p&gt;Finally, it would be good to decide if there is anything here to fix for 4.2.0. I&apos;m smelling that there isn&apos;t, but I&apos;d like to hear opinions.&lt;/p&gt;</comment>
                            <comment id="13529398" author="hustlmsp" created="Tue, 11 Dec 2012 22:22:09 +0000"  >&lt;p&gt;Rethinking a bit of &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-365&quot; title=&quot;Ledger will never recover if one of the quorum bookie is down forever and others dont have entry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-365&quot;&gt;&lt;del&gt;BOOKKEEPER-365&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;. They are quite irrelative.&lt;/p&gt;

&lt;p&gt;NoSuchEntry and NoSuchLedger are treated as the termination condition for LedgerRecovery. So it is important that how to decide it was NoSuchEntry/NoSuchLedger. otherwise, the client would be be mislead.&lt;/p&gt;

&lt;p&gt;Currently we used a kind of read-all-write-quorums to ensure it was actually NoSuchLedger and NoSuchEntry. But it wasn&apos;t necessary, we just need check at least (write_quorum_size - ack_quorum_size + 1) bookies regarding entries missing case. So when the write_quorum_size and ack_quorum_size is same, we just need 1 bookie to confirm NoSuchLedger and NoSuchEntry (it is what we did currently). But it should be fixed since we already separated ack_quorum_size from write_quorum_size. This jira tends to fix it.&lt;/p&gt;

&lt;p&gt;Go back to entries/ledgers missing case. How would missing case happen?&lt;/p&gt;

&lt;p&gt;1) a ledger disk (ledger directory) doesn&apos;t mount correctly. All the ledgers in that ledger disk would be lost and respond NoSuchLedger.&lt;br/&gt;
2) an entry is corrupted. &lt;br/&gt;
3) A brand new bookie is replaced when changing ensemble.&lt;br/&gt;
4) a ledger index file is removed or truncated by mistake.&lt;br/&gt;
5) some other bugs causing entries missing.&lt;/p&gt;

&lt;p&gt;1) is already addressed by Cookie. &lt;/p&gt;

&lt;p&gt;for 2), bookie should respond ReadException rather than NoSuchLedger and NoSuchEntry. so it would be treated as a valid read instead of NoSuchLedger and NoSuchEntry. so it would not affect how we decide if it was NoSuchEntry.&lt;/p&gt;

&lt;p&gt;for 3), it was actually the root cause of &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;. A brand new bookie is introduced in last ensemble which affect how we decide if it was NoSuchEntry/NoSuchLedger. Lets take an example from &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Suppose there are 3 bookie A, B, C. ensemble size = 2, write quorum size = 2, ack quorum size = 1.&lt;/p&gt;

&lt;p&gt;1) Ledger L is created with A, B.&lt;br/&gt;
2) Add entry 0. entry 0 is written to A. but failed to add to B.&lt;br/&gt;
3) A client came in and fence ledger L.&lt;br/&gt;
4) client reads entry 0 and try to add this entry back to A, B again.&lt;br/&gt;
5) network partition happened, client could not connect to A.&lt;br/&gt;
6) C is picked up to replace A.&lt;br/&gt;
7) B, C are not connected. client failed the recovery&lt;br/&gt;
8) another client tried to recover again.&lt;br/&gt;
9) it connected to B, C. they respond NoSuchLedger. and the ledger is closed with zero entries. and entry 0 is lost.&lt;/p&gt;

&lt;p&gt;the problem is that we replaced C with A before writing recovered entries, which caused the info in A are lost, which would cause wrong decision during ledger recover. even worse, if the whole ensemble is replaced totally, we lost all the info to recover a ledger. it would be pretty bad.&lt;/p&gt;

&lt;p&gt;so fixing &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt; doesn&apos;t depend on how we read from the quorum, but how we could avoid such replacement by mistake.&lt;/p&gt;

&lt;p&gt;for 4), I think it should not be addressed by the project itself, shouldn&apos;t it?&lt;/p&gt;

&lt;p&gt;for 5), I have to say we need to avoid such bugs at the best.&lt;/p&gt;

&lt;p&gt;I think for &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;, we have to fix it in 4.2.0. otherwise, it looks bad. for &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-365&quot; title=&quot;Ledger will never recover if one of the quorum bookie is down forever and others dont have entry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-365&quot;&gt;&lt;del&gt;BOOKKEEPER-365&lt;/del&gt;&lt;/a&gt;, we need to add some code to cover the cases we separating write_quorum_size and ack_quorum_size. so it tends to be in 4.2.0 too.&lt;/p&gt;</comment>
                            <comment id="13529638" author="hustlmsp" created="Wed, 12 Dec 2012 05:46:57 +0000"  >&lt;p&gt;Attach a patch tries to address the issue separating write_quorum_size and ack_quorum_size.&lt;/p&gt;

&lt;p&gt;the patch includes:&lt;/p&gt;

&lt;p&gt;1) a test case produce the issue separating write_quorum_size and ack_quorum_size.&lt;br/&gt;
2) move LedgerRecoveryTest to client package, for ease to access ledger metadata. and it also make more sense that ledger recovery is a client procedure.&lt;br/&gt;
3) the fix check how many missed read (NoSuchLedger/NoSuchEntry) we had received and if it reaches more than (write_quorum_size - ack_quorum_size + 1) and there was no sensible exceptions (like ReadException) found during reading. we treated the entry is missed, return submit NoSuchEntry to client.&lt;/p&gt;</comment>
                            <comment id="13530001" author="ikelly" created="Wed, 12 Dec 2012 14:47:10 +0000"  >&lt;p&gt;Part of the problem here is that we&apos;re updating ledger metadata on recovery before we actually write anything to the new bookie. On an active ledgerhandle we need to update the metadata before writing so that we don&apos;t loose data. But on a recovery ledger handle, we can do all the recovery, and just update the ledger handle when we close. So why don&apos;t we do just that? We already have a ReadOnlyLedgerHandle. We can just block metadata updates for handleBookieFailure and that should solve the problem.&lt;/p&gt;
</comment>
                            <comment id="13530072" author="ikelly" created="Wed, 12 Dec 2012 16:21:26 +0000"  >&lt;p&gt;Actually, the client will never get NoSuchLedger back from the bookie. It only ever gets NoSuchEntry. See PerChannelBookieClient.java. This should allow you to make your patch simpler. I&apos;m unclear on what maxMissedReadsAllowed actually means.&lt;/p&gt;</comment>
                            <comment id="13530184" author="hustlmsp" created="Wed, 12 Dec 2012 18:29:51 +0000"  >&lt;blockquote&gt;
&lt;p&gt;But on a recovery ledger handle, we can do all the recovery, and just update the ledger handle when we close. So why don&apos;t we do just that? We already have a ReadOnlyLedgerHandle. We can just block metadata updates for handleBookieFailure and that should solve the problem.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yup. this is the idea fixing &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;, which the case 3) I described in previous comment.&lt;/p&gt;

&lt;p&gt;for this jira, I tends to fix the issue caused by separating write_quorum_size and ack_quorum_size.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It only ever gets NoSuchEntry. See PerChannelBookieClient.java. This should allow you to make your patch simpler&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You are right. I missed that part in PerChannelBookieClient.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;m unclear on what maxMissedReadsAllowed actually means.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;maxMissedReadsAllowed means the max number of NoSuchEntry reads happened in a quorum. if this number is larger than (write_quorum_size - ack_quorum_size), it means that the entry hasn&apos;t ack&apos;ed successfully based on the guarantee provides by &apos;ack_quorum&apos;.&lt;/p&gt;

</comment>
                            <comment id="13530227" author="ikelly" created="Wed, 12 Dec 2012 19:19:39 +0000"  >&lt;p&gt;ah, so the test in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt; and your test are different. I didn&apos;t go through them line by line, as they looked very similiar, I thought you were fixing 355 within this patch also. In that case, I have a preliminary patch for 355, ill post it tomorrow after I submit this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;br/&gt;
maxMissedReadsAllowed means the max number of NoSuchEntry reads happened in a quorum. if this number is larger than (write_quorum_size - ack_quorum_size), it means that the entry hasn&apos;t ack&apos;ed successfully based on the guarantee provides by &apos;ack_quorum&apos;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ok, I understand now. If the number of NoSuchEntry is greater than the difference between ack quorum and write quorum, then the ack quorum could never have been completed. However, in your patch, you have&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
maxMissedReadsAllowed = lh.metadata.getWriteQuorumSize() - lh.metadata.getAckQuorumSize() + 1;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Is the + 1 correct?&lt;/p&gt;</comment>
                            <comment id="13530261" author="hustlmsp" created="Wed, 12 Dec 2012 19:58:40 +0000"  >&lt;p&gt;Update a new patch to reflect right meaning for maxMissingReadsAllowed. and also remove NoSuchLedger checking in the code.&lt;/p&gt;</comment>
                            <comment id="13530265" author="hustlmsp" created="Wed, 12 Dec 2012 20:01:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;ah, so the test in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt; and your test are different. I didn&apos;t go through them line by line, as they looked very similiar, I thought you were fixing 355 within this patch also.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it would fix &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt; because the test case in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt; is not perfect to cover the reason you described.&lt;/p&gt;

&lt;p&gt;the solution you described in the previous comment would be the right way to fix &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is the + 1 correct?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Update a new patch to reflect to right meaning of maxMissingReadsAllowed.&lt;/p&gt;</comment>
                            <comment id="13530419" author="fpj" created="Wed, 12 Dec 2012 22:15:03 +0000"  >&lt;p&gt;Hey guys, I&apos;m trying to catch up with all the updates. If I understand your patch, Sijie, you&apos;re making sure that we return NoSuchEntry when enough bookies say they don&apos;t know about a given entry. Your patch also performs this check using write and quorum sizes. If this is the case, it sounds reasonable to me.&lt;/p&gt;

&lt;p&gt;I don&apos;t particularly like the example you used here, though:  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-365?focusedCommentId=13529398&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13529398&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/BOOKKEEPER-365?focusedCommentId=13529398&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13529398&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If ack quorum size is 1, then we can&apos;t tolerate a single failure, consequently the example is not fault tolerant by definition. Replacing the bookie actually is the wrong thing to do, but I think it is a special case that we shouldn&apos;t take care of. &lt;/p&gt;

&lt;p&gt;I was actually wondering about warning users in the case they use such a value for ack quorums.&lt;/p&gt;</comment>
                            <comment id="13530686" author="hustlmsp" created="Thu, 13 Dec 2012 05:13:51 +0000"  >&lt;blockquote&gt;
&lt;p&gt;If this is the case, it sounds reasonable to me.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, as you described.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If ack quorum size is 1, then we can&apos;t tolerate a single failure, consequently the example is not fault tolerant by definition.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Taking quorum size 1 just to ease explaining that it was a bad idea to replace a bookie before writing entries for a recover procedure. I think we need to avoid it using Ivan&apos;s proposal. This would be adressed in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-355&quot; title=&quot;Ledger recovery will mark ledger as closed with -1, in case of slow bookie is added to ensemble during  recovery add&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-355&quot;&gt;&lt;del&gt;BOOKKEEPER-355&lt;/del&gt;&lt;/a&gt;. Ivan already worked on it, I think.&lt;/p&gt;</comment>
                            <comment id="13530912" author="ikelly" created="Thu, 13 Dec 2012 11:31:17 +0000"  >&lt;p&gt;new patch lgtm +1&lt;/p&gt;

&lt;p&gt;committing.&lt;/p&gt;</comment>
                            <comment id="13530914" author="ikelly" created="Thu, 13 Dec 2012 11:33:40 +0000"  >&lt;p&gt;Committed as r1421235. Thanks Sijie.&lt;/p&gt;</comment>
                            <comment id="13532107" author="hudson" created="Fri, 14 Dec 2012 06:51:28 +0000"  >&lt;p&gt;Integrated in bookkeeper-trunk #860 (See &lt;a href=&quot;https://builds.apache.org/job/bookkeeper-trunk/860/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/bookkeeper-trunk/860/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-365&quot; title=&quot;Ledger will never recover if one of the quorum bookie is down forever and others dont have entry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-365&quot;&gt;&lt;del&gt;BOOKKEEPER-365&lt;/del&gt;&lt;/a&gt;: Ledger will never recover if one of the quorum bookie is down forever and others dont have entry (sijie via ivank) (Revision 1421235)&lt;/p&gt;

&lt;p&gt;     Result = FAILURE&lt;br/&gt;
ivank : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12602144">BOOKKEEPER-355</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="12602475">BOOKKEEPER-361</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12602404">BOOKKEEPER-356</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12560626" name="BOOKKEEPER-365.diff" size="19122" author="hustlmsp" created="Wed, 12 Dec 2012 19:58:40 +0000"/>
                            <attachment id="12560509" name="BOOKKEEPER-365.diff" size="18989" author="hustlmsp" created="Wed, 12 Dec 2012 05:46:57 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 4 Nov 2012 19:30:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>255149</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy8k8n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>83922</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>