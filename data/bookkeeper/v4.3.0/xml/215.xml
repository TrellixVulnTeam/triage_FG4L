<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat May 16 23:31:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/BOOKKEEPER-215/BOOKKEEPER-215.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[BOOKKEEPER-215] Deadlock occurs under high load</title>
                <link>https://issues.apache.org/jira/browse/BOOKKEEPER-215</link>
                <project id="12311293" key="BOOKKEEPER">Bookkeeper</project>
                    <description>&lt;p&gt;LedgerHandle uses a Semaphore(opCounterSem) with a default value of 5000 permits to implement throttling for outstanding requests. This is causing a deadlock under high load. What I&apos;ve observed is the following - There are a fixed number of threads created by OrderedSafeExecutor(mainWorkerPool in BookKeeper) and this is used to execute operations by PerChannelBookieClient. Under high load, the bookies are not able to satisfy requests at the rate at which they are being generated. This exhausts all permits in the Semaphore and any further operations block on lh.opCounterSem.acquire(). In this scenario, if the connection to the bookies is shut down, channelDisconnected in PerChannelBookieClient tries to error out all outstanding entries. The errorOutReadKey and errorOutAddKey functions enqueue these operations in the same mainWorkerPool, all threads in which are blocked on acquire. So, handleBookieFailure is never executed and the server stops responding. &lt;/p&gt;

&lt;p&gt;Blocking operations in a fixed size thread pool doesn&apos;t sound quite right. Temporarily, I fixed this by having another ExecutorService for every PerChannelBookieClient and queuing the operations from the errorOut* functions in it, but this is just a quick fix. I feel that the server shouldn&apos;t rely on LedgerHandle to throttle connections, but do this itself. Any other ideas on how to fix this? I&apos;d be happy to contribute a patch. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12550470">BOOKKEEPER-215</key>
            <summary>Deadlock occurs under high load</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hustlmsp">Sijie Guo</assignee>
                                    <reporter username="i0exception">Aniruddha</reporter>
                        <labels>
                    </labels>
                <created>Wed, 11 Apr 2012 06:16:04 +0100</created>
                <updated>Mon, 22 Oct 2012 15:50:17 +0100</updated>
                            <resolved>Wed, 9 May 2012 08:45:32 +0100</resolved>
                                    <version>4.1.0</version>
                                    <fixVersion>4.1.0</fixVersion>
                                    <component>hedwig-server</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="13251376" author="fpj" created="Wed, 11 Apr 2012 07:50:45 +0100"  >&lt;p&gt;Hi Aniruddha, The thread blocking due to the exhaustion of permits is the application thread, not a thread from the bk client pool. Consequently, I don&apos;t see how the deadlock situation you describe can happen. Is there anything I&apos;m missing?&lt;/p&gt;</comment>
                            <comment id="13251414" author="ikelly" created="Wed, 11 Apr 2012 09:29:26 +0100"  >&lt;p&gt;opCounterSem is only acquired in PendingReadOp#initiate and LedgerHandle#doAsyncAddEntry, which are only run in the context of the application thread, so this deadlock cannot happen as described. &lt;/p&gt;

&lt;p&gt;@Aniruddha, a dump of all thread stacks would be very helpful in diagnosing the problem here.&lt;/p&gt;</comment>
                            <comment id="13251924" author="i0exception" created="Wed, 11 Apr 2012 22:13:24 +0100"  >&lt;p&gt;Hi Ivan and Flavio, &lt;/p&gt;

&lt;p&gt;I&apos;ve attached the thread dump of the hedwig-server when it is deadlocked. As you can see, both pool-1-thread-1 and pool-52-thread-1 are blocked on the semaphore. pool-52-thread-1 is one of the threads in the mainWorkerPool. It seems that PendingReadOp is executed in pool-1-thread-1 always, except for just before I get the error, when it&apos;s executed in pool-52-thread-1. Now, when the channel is disconnected, the errorOut* functions enqueue all their SafeRunnables in this same thread (using OrderedSafeExecutor.submitOrdered with ledgerId as the key) - pool-52-thread-1. Even when PerChannelBookieClient closes the channel after errorOutOutstandingEntries, the callbacks that would release the semaphore are never called because all of them are being queued in the same thread. So, now you have a PendingReadOp waiting to acquire a lock at the front of the queue while operations that will release the lock are queued behind it. &lt;/p&gt;

&lt;p&gt;In short, there is a PendingReadOp being queued in pool-52-thread-1 which shouldn&apos;t be there. The only operations in that thread should be PendingAddOps. &lt;/p&gt;

&lt;p&gt;edit : From the logfile it seems that PendingReadOps are being queued in pool-52-thread-1 quite a few times. In all previous instances, it could acquire the Semaphore. &lt;/p&gt;</comment>
                            <comment id="13252153" author="hustlmsp" created="Thu, 12 Apr 2012 04:05:50 +0100"  >&lt;p&gt;thanks Aniruddha providing thread stacks. &lt;/p&gt;

&lt;p&gt;yes, pool-52-thread-1 introduced the deadlock. in Hedwig bookkeeper persistence manager, it call next asyncReadEntries in the callback of previous asyncReadEntries. &lt;/p&gt;

&lt;p&gt;One possible fix is in hedwig part, we need to submit a Runnable to execute asyncReadEntries in other thread, not in the bookkeeper threads pool to avoid such deadlock. This solution could fix the hedwig issue.&lt;/p&gt;

&lt;p&gt;beside that, we can&apos;t assume that other users would not do such action to call readEntries in a callback. so a fix in bookkeeper itself may be needed.&lt;/p&gt;</comment>
                            <comment id="13252238" author="fpj" created="Thu, 12 Apr 2012 07:29:36 +0100"  >&lt;p&gt;I don&apos;t think it is good practice to have calls to bookkeeper itself from a callback. The callback will be executed by a bookkeeper thread, so you really want to give control back to the application shortly.&lt;/p&gt;

&lt;p&gt;My preference is to leave the bookkeeper client as is.&lt;/p&gt;</comment>
                            <comment id="13252610" author="hustlmsp" created="Thu, 12 Apr 2012 18:16:23 +0100"  >&lt;p&gt;adding a patch, 1) includes a test case which reproduce the hedwig issue as thread stacks provided in this jira, 2) includes a test case to test ledger recovery with limited permits, which also introduce same deadlock issue as hedwig, 3) add a possible fix to avoid call bookkeeper operation in bookkeeper callback.&lt;/p&gt;

&lt;p&gt;this patch is based on &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-173&quot; title=&quot;Uncontrolled number of threads in bookkeeper&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-173&quot;&gt;&lt;del&gt;BOOKKEEPER-173&lt;/del&gt;&lt;/a&gt; &apos;s patch, because I need to limit the number of worker threads in the test case to 1, so I could let the ledger operations are executed in same thread to reproduce deadlock issue.&lt;/p&gt;</comment>
                            <comment id="13252920" author="i0exception" created="Thu, 12 Apr 2012 23:18:07 +0100"  >&lt;p&gt;Thanks. The deadlock does not happen after I apply the patch. However, it might be worth looking into moving the lock acquisition out of PendingReadOp and putting it into the application. Is there any reason why the acquire is inside the initiate method and not in an application thread? &lt;/p&gt;</comment>
                            <comment id="13252958" author="fpj" created="Fri, 13 Apr 2012 00:13:02 +0100"  >&lt;p&gt;This is the code for asyncReadEntries:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;public void asyncReadEntries(long firstEntry, long lastEntry,
                                 ReadCallback cb, Object ctx) {
        // Little sanity check
        if (firstEntry &amp;lt; 0 || lastEntry &amp;gt; lastAddConfirmed
                || firstEntry &amp;gt; lastEntry) {
            cb.readComplete(BKException.Code.ReadException, this, null, ctx);
            return;
        }

        try {
            new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();
        } catch (InterruptedException e) {
            cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;initiate() is called form the application thread, right?&lt;/p&gt;</comment>
                            <comment id="13252983" author="i0exception" created="Fri, 13 Apr 2012 00:53:44 +0100"  >&lt;p&gt;Sorry, should have been clearer. Would it be better if we have a doAsyncReadEntry function inside LedgerHandle, call this from asyncReadEntries and let it acquire the lock and queue the PendingReadOp into a threadpool? This is similar to what is being done for add operations. &lt;/p&gt;</comment>
                            <comment id="13253011" author="hustlmsp" created="Fri, 13 Apr 2012 01:26:26 +0100"  >&lt;p&gt;I don&apos;t think we need to do that. from an application they call asyncReadEntries and asyncAddEntry, it has done the same thing to acquire lock. (one thing we might need to add is more documentation to let user know they acquire the lock when calling these two methods) &lt;/p&gt;

&lt;p&gt;Beside that, add operation is quite different from read operation.&lt;/p&gt;

&lt;p&gt;for add operation, bookkeeper needs to guarantee order so it has a PendingAddOps queue to queue all the add operations, so the acquire is better to execute in LedgerHandle before putting it in the pending queue.&lt;/p&gt;

&lt;p&gt;for read operation, we don&apos;t need to guarantee the order between different asycReadEntries calls, so we don&apos;t has a queue for read ops. beside that, read is actually a range read so we have to acquire the lock per entry for a asyncReadEntries operation, so PendingReadOp is a better place to manage such logic for a read op. &lt;/p&gt;

&lt;p&gt;does it make sense for you?&lt;/p&gt;

&lt;p&gt;BTW, just curious, why the issue is marked as fixed?&lt;/p&gt;</comment>
                            <comment id="13254486" author="hustlmsp" created="Mon, 16 Apr 2012 03:10:02 +0100"  >&lt;p&gt;the patch is not passed reviewing, so just reopen it.&lt;/p&gt;</comment>
                            <comment id="13256601" author="fpj" created="Wed, 18 Apr 2012 15:31:20 +0100"  >&lt;p&gt;Hi Sijie, Here are some comments on the patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;One clarification. I understand the call to lh.bk.callbackWorker.submitOrdered in readComplete, but not the one in doRecoveryRead. Why do we need to give it to a worker thread in this case?&lt;/li&gt;
	&lt;li&gt;It is not performance critical in this case, but it sounds like a good ideal in general to have LOG.debug statements wrapped with isDebugEnabled() (LedgerRecoveryOp:86). You may have simply missed this one.&lt;/li&gt;
	&lt;li&gt;Is this change gratuitous or really necessary:
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    protected Bookie newBookie(ServerConfiguration conf)
        throws IOException, KeeperException, InterruptedException, BookieException {
        return new Bookie(conf);
    }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; &lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;testRecoveryDeadlockWithLimitedPermits() has no assertion or fail clause. What is it testing?&lt;/li&gt;
	&lt;li&gt;I&apos;m not entirely sure why we need this method:&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    /**
     * Add configuration object.
     *
     * @param conf configuration object
     */
    public void addConf(Configuration otherConf) throws ConfigurationException {
        conf.addConfiguration(otherConf);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Why can&apos;t we set the bk client configuration in the constructor?&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Typo: &quot;... so a scan request need to scan over two ledger&quot; -&amp;gt; &quot;... so a scan request need to scan over two ledgers&quot;&lt;/li&gt;
	&lt;li&gt;In TestDeadlock, if I understand the test correctly, consumeQueue.take() is supposed to hang due to the bug of this jira. Consequently, we have to wait until junit times out the test? I was wondering if there is a way of avoiding the time out.&lt;/li&gt;
	&lt;li&gt;Suggestion for rephrasing comment:&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;// it obtains the permit and wait for a response,
// but the response is delayed and readEntries is called
// in the readComplete callback to read entries of the 
// same ledger. since there is no permit, it blocks.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13256602" author="fpj" created="Wed, 18 Apr 2012 15:31:52 +0100"  >&lt;p&gt;Cancelling patch until comments are addressed.&lt;/p&gt;</comment>
                            <comment id="13256625" author="hustlmsp" created="Wed, 18 Apr 2012 15:59:44 +0100"  >&lt;p&gt;thanks Flavio for reviewing.&lt;/p&gt;

&lt;p&gt;&amp;gt; but not the one in doRecoveryRead. Why do we need to give it to a worker thread in this case?&lt;/p&gt;

&lt;p&gt;doRecoveryRead() will be executed in #addComplete, which is also in the callback of bookkeeper. so it should do same as what it did in #readComplete.&lt;/p&gt;

&lt;p&gt;&amp;gt; It is not performance critical in this case, but it sounds like a good ideal in general to have LOG.debug statements wrapped with isDebugEnabled() (LedgerRecoveryOp:86). You may have simply missed this one.&lt;/p&gt;

&lt;p&gt;if we use &apos;+&apos; to concatenate string it would introduce the performance issue. but we don&apos;t concatenate the string in debug message, so it would not introduce the performance issue. besides that, I remembered that because we use slf4j, Ivan suggested to use such kind of pattern to log debug message.&lt;/p&gt;

&lt;p&gt;&amp;gt; Is this change gratuitous or really necessary:&lt;/p&gt;

&lt;p&gt;actually I used this method in hedwig BookKeeperTestBase class, which extends existed Bookie class to simulate response delay for #readEntry. It helps testing the deadlock in bookkeeper persistence manager.&lt;/p&gt;

&lt;p&gt;&amp;gt; testRecoveryDeadlockWithLimitedPermits() has no assertion or fail clause. What is it testing?&lt;/p&gt;

&lt;p&gt;if we don&apos;t apply the patch, the test case will hang due to deadlock. so I am not sure how to add assertion and fail clause. what is your opinion?&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m not entirely sure why we need this method:&lt;/p&gt;

&lt;p&gt;the method is used in TestDeadLock#getServerConfiguration. it used to load a bookkeeper client configuration object. so the hub server could use bookkeeper client settings we provided.&lt;/p&gt;

&lt;p&gt;&amp;gt; In TestDeadlock, if I understand the test correctly, consumeQueue.take() is supposed to hang due to the bug of this jira. Consequently, we have to wait until junit times out the test? I was wondering if there is a way of avoiding the time out.&lt;/p&gt;

&lt;p&gt;yes. we have to wait until timeout if we don&apos;t apply this patch. I have no perfect solution to test such hang due to deadlock.&lt;/p&gt;

&lt;p&gt;&amp;gt; typos &amp;amp; comments&lt;/p&gt;

&lt;p&gt;yeah. thanks for fixing them. I would update them to new patch.&lt;/p&gt;
</comment>
                            <comment id="13258115" author="hustlmsp" created="Fri, 20 Apr 2012 10:36:51 +0100"  >&lt;p&gt;attach a new patch to improve comments according to Flavio&apos;s suggestions.&lt;/p&gt;</comment>
                            <comment id="13258855" author="fpj" created="Sat, 21 Apr 2012 14:49:45 +0100"  >&lt;p&gt;One idea occurred to me and I wanted to run it by you guys. I don&apos;t think it is critical that we throttle for recovery, so I was wondering if it makes sense that the calls to read entries from LedgerRecoveryOp do not try to acquire permits. This way we avoid the problem altogether. &lt;/p&gt;</comment>
                            <comment id="13259024" author="hustlmsp" created="Sun, 22 Apr 2012 08:04:08 +0100"  >&lt;p&gt;I think it is OK to not try to acquire permits in LedgerRecoveryOp, it could resolve the issue in LedgerRecoveryOp. but it could not resolve the issue in BookKeeper persistence manager in hedwig. so I am not sure I understand what you said that &quot;we avoid the problem altogether&quot;.&lt;/p&gt;</comment>
                            <comment id="13259046" author="fpj" created="Sun, 22 Apr 2012 09:37:10 +0100"  >&lt;p&gt;Your patch seems to fix the hedwig issue without changing the flow of regular asyncReadEntries. It only changes LedgerRecoveryOp on the bookkeeper side, right? One option I see is to keep your changes to hedwig and not have recovery acquiring permits.&lt;/p&gt;

&lt;p&gt;One clarification, if you don&apos;t mind, Sijie. It is not clear from your patch how your modifications to the persistence manager prevents callbacks from calling asyncReadEntries. Could you give me some more insight, please?  &lt;/p&gt;</comment>
                            <comment id="13259385" author="hustlmsp" created="Mon, 23 Apr 2012 06:13:04 +0100"  >&lt;p&gt;sure, the code change in bookkeeper persistence manager is to put the asyncReadEntries in opQueue instead of calling asyncReadEntries directly in the callback.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
                         }
                     }
 
-                    startReadingFrom(imlr.startSeqIdIncluded + entry.getEntryId() + 1);
-
+                    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt; scanning messages
&lt;/span&gt;+                    scanMessages(request, imlr.startSeqIdIncluded + entry.getEntryId() + 1);
                 }
             }, request.ctx);
         }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;the detail code change is as above. it call scanMessages, which put a range scan op again in topic op queue, instead of startReadingFrom. so the asyncReadEntries would be executed only the range op is executed, which is in hedwig thread not in bookkeeper thread.&lt;/p&gt;</comment>
                            <comment id="13260359" author="hustlmsp" created="Tue, 24 Apr 2012 09:39:14 +0100"  >&lt;p&gt;Flavio and I had a discussion about this jira, &lt;/p&gt;

&lt;p&gt;1) for LedgerRecoveryOp, it would better to acquire permit per recovery op. we don&apos;t need to acquire permits for the read/add ops executed in a recovery op. so the issue could be resolved. to do the change, we need a flag in PendingAddOp/PendingReadOp to control whether acquire/release permits when read/add. we leverage PendingAddOp#enableRecoveryAdd() as the flag.&lt;/p&gt;

&lt;p&gt;2) in Bookkeeper SafeOrderExecutor, I proposed to introduce deadlock checking mechanism in runtime. when a callback is submitted to SafeOrderExecutor, we would check whether the thread is blocked on the semaphore or not. If the thread is blocked, we would fail the callback directly. Doing such deadlock checking would affect performance, so it would better to provide a flag to control whether enabling it or not. The benefit of introducing such mechanism, we could avoid using timeout in the test case.&lt;/p&gt;

&lt;p&gt;I would like to come out a draft patch about the above proposal, then we could discuss more.&lt;/p&gt;</comment>
                            <comment id="13260631" author="hustlmsp" created="Tue, 24 Apr 2012 15:54:08 +0100"  >&lt;p&gt;Attach a prototype of deadlock check executor for discussion.&lt;/p&gt;

&lt;p&gt;the idea for deadlock check executor is used Semaphore#getQueuedThreads() to check whether  a thread is blocked when summiting a task to it.&lt;/p&gt;

&lt;p&gt;If a deadlock is found, a RejectedExecutionException is thrown. so the thread should catch such exception to handle it (such as fail the response directly).&lt;/p&gt;

&lt;p&gt;Unfortunately, I found that submitOrdered is used at least 5 places. It would make the source code unmaintainable.&lt;/p&gt;

&lt;p&gt;so I am not sure it worth doing such deadlock checking. Flavio, how is your opinion?&lt;/p&gt;


&lt;p&gt;another thing that I were thinking is the way using Semaphore to throttle the best way. I thought throttle is to not overwhelm a bookie server, so why not throttle in PerChannelBookieClient which talks with a bookie server directly.&lt;/p&gt;
</comment>
                            <comment id="13260690" author="hustlmsp" created="Tue, 24 Apr 2012 17:37:36 +0100"  >&lt;p&gt;BTW, attach a v3 patch that address 1) in previous comment, not acquire/release permits in ledger recovery op. &lt;/p&gt;

&lt;p&gt;the deadlock checking idea introduced is trying to remove timeout mechanism in testing deadlock. but from my draft patch, seems that is not easy to adapt a deadlock checking mechanism. so how about creating a separated for it?&lt;/p&gt;</comment>
                            <comment id="13268952" author="fpj" created="Sat, 5 May 2012 13:56:04 +0100"  >&lt;p&gt;It really feels like we have three issues here: the hedwig deadlock, the changes to recovery, deadlock detection. In this jira, it sounds like we only need to solve the first. The other two we should address in different jiras.&lt;/p&gt;

&lt;p&gt;On the changes to recovery to not acquire/release permits, I don&apos;t really like the conditional acquire/permit, and I was thinking if we could remove it by just acquiring and releasing in different places. For adds, we could acquire the permits before doAsyncAddEntry, while for the release part, we may need a different callback in PendingAddOp. What do you think, Sijie? &lt;/p&gt;</comment>
                            <comment id="13269397" author="hustlmsp" created="Mon, 7 May 2012 07:32:15 +0100"  >&lt;p&gt;I agreed to separated it into three jiras and we fix the first one.&lt;/p&gt;

&lt;p&gt;&amp;gt; For adds, we could acquire the permits before doAsyncAddEntry, while for the release part, we may need a different callback in PendingAddOp.&lt;/p&gt;

&lt;p&gt;for Add it is OK, but how about readEntries? since releasing permits in PendingReadOp is not in single place, if you want to fix it in a different callback, I think you have to wrap the callback passed by user and do release in the wrapper. &lt;/p&gt;

&lt;p&gt;What I am thinking to resolve recovery deadlock issue is to revisit the throttle mechanism used in bookkeeper.&lt;/p&gt;</comment>
                            <comment id="13270333" author="hustlmsp" created="Tue, 8 May 2012 10:20:35 +0100"  >&lt;p&gt;Attach a new patch just resolve the deadlock issue in Hedwig bookkeeper persistence manager.&lt;/p&gt;

&lt;p&gt;for the ledger recovery issue, it would be discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt;. And the deadlock checking mechanism would be resolved in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-240&quot; title=&quot;Need a deadlock checking mechanism to avoid deadlock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-240&quot;&gt;BOOKKEEPER-240&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13271188" author="ikelly" created="Wed, 9 May 2012 08:43:40 +0100"  >&lt;p&gt;lgtm +1,&lt;/p&gt;

&lt;p&gt;committing&lt;/p&gt;</comment>
                            <comment id="13271191" author="ikelly" created="Wed, 9 May 2012 08:45:36 +0100"  >&lt;p&gt;Committed as r1335958&lt;/p&gt;</comment>
                            <comment id="13271195" author="hudson" created="Wed, 9 May 2012 08:56:40 +0100"  >&lt;p&gt;Integrated in bookkeeper-trunk #496 (See &lt;a href=&quot;https://builds.apache.org/job/bookkeeper-trunk/496/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/bookkeeper-trunk/496/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-215&quot; title=&quot;Deadlock occurs under high load&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-215&quot;&gt;&lt;del&gt;BOOKKEEPER-215&lt;/del&gt;&lt;/a&gt;: Deadlock occurs under high load (sijie via ivank) (Revision 1335958)&lt;/p&gt;

&lt;p&gt;     Result = SUCCESS&lt;br/&gt;
ivank : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12554161">BOOKKEEPER-239</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12554162">BOOKKEEPER-240</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12523990" name="BK-215-check-deadlock.patch" size="53235" author="hustlmsp" created="Tue, 24 Apr 2012 15:54:08 +0100"/>
                            <attachment id="12522451" name="BK-215.patch" size="21742" author="hustlmsp" created="Thu, 12 Apr 2012 18:16:23 +0100"/>
                            <attachment id="12523471" name="BK-215.patch_v2" size="22641" author="hustlmsp" created="Fri, 20 Apr 2012 10:36:51 +0100"/>
                            <attachment id="12524004" name="BK-215.patch_v3" size="29954" author="hustlmsp" created="Tue, 24 Apr 2012 17:37:33 +0100"/>
                            <attachment id="12525973" name="BK-215.patch_v4" size="21524" author="hustlmsp" created="Tue, 8 May 2012 10:20:33 +0100"/>
                            <attachment id="12523989" name="DeadlockCheckOrderedSafeExecutor.java" size="3466" author="hustlmsp" created="Tue, 24 Apr 2012 15:54:08 +0100"/>
                            <attachment id="12522316" name="hedwig_ts.log" size="53009" author="i0exception" created="Wed, 11 Apr 2012 21:59:22 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 11 Apr 2012 06:50:45 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>235334</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy4s0f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>61694</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>