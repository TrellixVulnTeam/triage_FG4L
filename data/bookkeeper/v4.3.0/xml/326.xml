<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat May 16 23:29:20 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/BOOKKEEPER-326/BOOKKEEPER-326.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[BOOKKEEPER-326] DeadLock during ledger recovery </title>
                <link>https://issues.apache.org/jira/browse/BOOKKEEPER-326</link>
                <project id="12311293" key="BOOKKEEPER">Bookkeeper</project>
                    <description>&lt;p&gt;Deadlock found during ledger recovery. please find the attached thread dump.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12597399">BOOKKEEPER-326</key>
            <summary>DeadLock during ledger recovery </summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rakeshr">Rakesh R</assignee>
                                    <reporter username="vinayrpet">Vinayakumar B</reporter>
                        <labels>
                    </labels>
                <created>Wed, 4 Jul 2012 05:38:34 +0100</created>
                <updated>Wed, 13 Feb 2013 15:46:32 +0000</updated>
                            <resolved>Mon, 13 Aug 2012 10:39:18 +0100</resolved>
                                    <version>4.1.0</version>
                                    <fixVersion>4.2.0</fixVersion>
                    <fixVersion>4.1.1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                <comments>
                            <comment id="13406272" author="vinayrpet" created="Wed, 4 Jul 2012 05:39:42 +0100"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Found one Java-level deadlock:
=============================
&lt;span class=&quot;code-quote&quot;&gt;&quot;pool-91-thread-1&quot;&lt;/span&gt;:
  waiting to lock monitor 0x000000004039bce0 (object 0x00007f3dc329b6a0, a org.apache.bookkeeper.proto.PerChannelBookieClient),
  which is held by &lt;span class=&quot;code-quote&quot;&gt;&quot;main-EventThread&quot;&lt;/span&gt;
&lt;span class=&quot;code-quote&quot;&gt;&quot;main-EventThread&quot;&lt;/span&gt;:
  waiting to lock monitor 0x00000000401f4e50 (object 0x00007f3dc329b958, a org.apache.bookkeeper.client.ReadLastConfirmedOp),
  which is held by &lt;span class=&quot;code-quote&quot;&gt;&quot;pool-91-thread-1&quot;&lt;/span&gt;

Java stack information &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the threads listed above:
===================================================
&lt;span class=&quot;code-quote&quot;&gt;&quot;pool-91-thread-1&quot;&lt;/span&gt;:
	at org.apache.bookkeeper.proto.PerChannelBookieClient.connectIfNeededAndDoOp(PerChannelBookieClient.java:184)
	- waiting to lock &amp;lt;0x00007f3dc329b6a0&amp;gt; (a org.apache.bookkeeper.proto.PerChannelBookieClient)
	at org.apache.bookkeeper.proto.BookieClient.readEntry(BookieClient.java:144)
	at org.apache.bookkeeper.client.PendingReadOp.sendRead(PendingReadOp.java:109)
	at org.apache.bookkeeper.client.PendingReadOp.initiate(PendingReadOp.java:93)
	at org.apache.bookkeeper.client.LedgerHandle.asyncReadEntries(LedgerHandle.java:382)
	at org.apache.bookkeeper.client.LedgerRecoveryOp.doRecoveryRead(LedgerRecoveryOp.java:92)
	at org.apache.bookkeeper.client.LedgerRecoveryOp.access$000(LedgerRecoveryOp.java:46)
	at org.apache.bookkeeper.client.LedgerRecoveryOp$1.readLastConfirmedDataComplete(LedgerRecoveryOp.java:70)
	at org.apache.bookkeeper.client.ReadLastConfirmedOp.readEntryComplete(ReadLastConfirmedOp.java:116)
	- locked &amp;lt;0x00007f3dc329b958&amp;gt; (a org.apache.bookkeeper.client.ReadLastConfirmedOp)
	at org.apache.bookkeeper.proto.PerChannelBookieClient.handleReadResponse(PerChannelBookieClient.java:634)
	at org.apache.bookkeeper.proto.PerChannelBookieClient$7.safeRun(PerChannelBookieClient.java:539)
	at org.apache.bookkeeper.util.SafeRunnable.run(SafeRunnable.java:31)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
	at java.util.concurrent.FutureTask.run(FutureTask.java:138)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:619)
&lt;span class=&quot;code-quote&quot;&gt;&quot;main-EventThread&quot;&lt;/span&gt;:
	at org.apache.bookkeeper.client.ReadLastConfirmedOp.readEntryComplete(ReadLastConfirmedOp.java:79)
	- waiting to lock &amp;lt;0x00007f3dc329b958&amp;gt; (a org.apache.bookkeeper.client.ReadLastConfirmedOp)
	at org.apache.bookkeeper.proto.BookieClient$3.operationComplete(BookieClient.java:132)
	at org.apache.bookkeeper.proto.BookieClient$3.operationComplete(BookieClient.java:128)
	at org.apache.bookkeeper.proto.PerChannelBookieClient$1.operationComplete(PerChannelBookieClient.java:168)
	at org.jboss.netty.channel.DefaultChannelFuture.notifyListener(DefaultChannelFuture.java:381)
	at org.jboss.netty.channel.DefaultChannelFuture.addListener(DefaultChannelFuture.java:148)
	at org.apache.bookkeeper.proto.PerChannelBookieClient.connect(PerChannelBookieClient.java:137)
	- locked &amp;lt;0x00007f3dc329b6a0&amp;gt; (a org.apache.bookkeeper.proto.PerChannelBookieClient)
	at org.apache.bookkeeper.proto.PerChannelBookieClient.connectIfNeededAndDoOp(PerChannelBookieClient.java:200)
	- locked &amp;lt;0x00007f3dc329b6a0&amp;gt; (a org.apache.bookkeeper.proto.PerChannelBookieClient)
	at org.apache.bookkeeper.proto.BookieClient.readEntryAndFenceLedger(BookieClient.java:128)
	at org.apache.bookkeeper.client.ReadLastConfirmedOp.initiateWithFencing(ReadLastConfirmedOp.java:69)
	at org.apache.bookkeeper.client.LedgerRecoveryOp.initiate(LedgerRecoveryOp.java:84)
	at org.apache.bookkeeper.client.LedgerHandle$5.processResult(LedgerHandle.java:804)
	at org.apache.bookkeeper.util.RetryableZookeeper$6.processResult(RetryableZookeeper.java:633)
	at org.apache.zookeeper.ClientCnxn$EventThread.processEvent(ClientCnxn.java:545)
	at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:497)

Found 1 deadlock.&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13406274" author="vinayrpet" created="Wed, 4 Jul 2012 05:40:49 +0100"  >&lt;p&gt;Attached jstack threaddump.&lt;/p&gt;</comment>
                            <comment id="13406283" author="rakeshr" created="Wed, 4 Jul 2012 06:33:48 +0100"  >&lt;p&gt;After analyzing the threaddump I could see, the DefaultChannelFuture.notifyListener() is notifying in the same thread where the PerChannelBookieClient.connect() is invoked. Now the pendingOp.operationComplete(rc, null); is executing and inturn reaches the ReadLastConfirmedOp.readEntryComplete() and is waiting for ReadLastConfirmedOp lock acquisition.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
at org.apache.bookkeeper.client.ReadLastConfirmedOp.readEntryComplete(ReadLastConfirmedOp.java:79)
	- waiting to lock &amp;lt;0x00007f3dc329b958&amp;gt; (a org.apache.bookkeeper.client.ReadLastConfirmedOp)
	at org.apache.bookkeeper.proto.BookieClient$3.operationComplete(BookieClient.java:132)
	at org.apache.bookkeeper.proto.BookieClient$3.operationComplete(BookieClient.java:128)
	at org.apache.bookkeeper.proto.PerChannelBookieClient$1.operationComplete(PerChannelBookieClient.java:168)
	at org.jboss.netty.channel.DefaultChannelFuture.notifyListener(DefaultChannelFuture.java:381)
	at org.jboss.netty.channel.DefaultChannelFuture.addListener(DefaultChannelFuture.java:148)
	at org.apache.bookkeeper.proto.PerChannelBookieClient.connect(PerChannelBookieClient.java:137)
	- locked &amp;lt;0x00007f3dc329b6a0&amp;gt; (a org.apache.bookkeeper.proto.PerChannelBookieClient)
	at org.apache.bookkeeper.proto.PerChannelBookieClient.connectIfNeededAndDoOp(PerChannelBookieClient.java:200)
	- locked &amp;lt;0x00007f3dc329b6a0&amp;gt; (a org.apache.bookkeeper.proto.PerChannelBookieClient)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;I think the contract mentioned in the comment &apos;trick to not do operations under the lock&apos; is broken, since the DefaultChannelFuture.notifyListener() is coming in the same thread where PerChannelBookieClient.connect() is invoked.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void connect() {
        &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.addListener(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ChannelFutureListener() {
            @Override
            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void operationComplete(ChannelFuture &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
                &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; rc;
                Queue&amp;lt;GenericCallback&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Void&lt;/span&gt;&amp;gt;&amp;gt; oldPendingOps;

                &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (PerChannelBookieClient.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;) {
                    .....
                    .....
                    .....
                    &lt;span class=&quot;code-comment&quot;&gt;// trick to not &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; operations under the lock, take the list
&lt;/span&gt;                    &lt;span class=&quot;code-comment&quot;&gt;// of pending ops and assign it to a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; variable, &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;
&lt;/span&gt;                    &lt;span class=&quot;code-comment&quot;&gt;// emptying the pending ops by just assigning it to a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;
&lt;/span&gt;                    &lt;span class=&quot;code-comment&quot;&gt;// list
&lt;/span&gt;                    oldPendingOps = pendingOps;
                    pendingOps = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;GenericCallback&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Void&lt;/span&gt;&amp;gt;&amp;gt;();
                }
                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (GenericCallback&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Void&lt;/span&gt;&amp;gt; pendingOp : oldPendingOps) {
                    pendingOp.operationComplete(rc, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
                }
            }
        });
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;-Rakesh&lt;/p&gt;</comment>
                            <comment id="13406296" author="vinayrpet" created="Wed, 4 Jul 2012 07:24:57 +0100"  >&lt;p&gt;Hi Rakesh,&lt;/p&gt;

&lt;p&gt;I did some investigation on netty behaviour while invoking the listeners.&lt;/p&gt;

&lt;p&gt;Here it is:&lt;br/&gt;
1. The race is between following 2 lines of PerChannelBookieClient.&lt;/p&gt;
    &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
         ChannelFuture &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; = bootstrap.connect(addr);

        &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.addListener(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ChannelFutureListener() &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2. bootstrap.connect(addr) will put a connection request to one queue which will be processed by another thread and set the connection result.  &lt;br/&gt;
  If the result of connection is available before  adding the listener to future in future.addListener(..), &lt;br/&gt;
    then listener will be invoked in same thread immediately still holding the locks.&lt;/p&gt;


&lt;p&gt;Overall scenario &lt;br/&gt;
--------------------------&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Ledger is created and entries are writter to 3 bookies.&lt;/li&gt;
	&lt;li&gt;one of bookie is killed. (say this bookie is not the first bookie in the ensemble)&lt;/li&gt;
	&lt;li&gt;New bookie started.&lt;/li&gt;
	&lt;li&gt;now openLedger() call is made to recover the ledger. as part of this readLastConfirmed request will be added each of the bookies with callback ReadLastConfirmedOp.readEntryComplete which is synchronized.&lt;/li&gt;
	&lt;li&gt;First callback came from first bookie which is alive in separate thread and entered ReadLastConfirmedOp.readEntryComplete() and processing.&lt;/li&gt;
	&lt;li&gt;Another Callback came for the failed bookie from connect() method by holding the lock of PerChannelBookieClient instance of failed bookie, and trying to invoke the same callback, but BLOCKED. ( Here to invoke the listener in same thread, need to wait before future.addListener(..) by putting debug point)&lt;/li&gt;
	&lt;li&gt;As part of first call back, doRecoveryRead() will put one PendingReadOp request for asyncread. If this PendingReadOp selects same PerChannelBookieClient of failed bookie for read, then it will enter to deadlock. (To reproduce, bookieIndex variable can be changed to index of the failed bookie in PendingReadOp.sendRead(..))&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;( Can reuse the existing test BookieFailureTest.testLedgerOpenAfterBKCrashed())&lt;/p&gt;</comment>
                            <comment id="13406489" author="umamaheswararao" created="Wed, 4 Jul 2012 13:51:53 +0100"  >&lt;p&gt;Will it be a good idea to execute the callback on separate thread always? that would be one options to solve.&lt;/p&gt;

&lt;p&gt;Shall we mark this as blocker as this is coming frequently in CI(internal)? also this is at main flows.&lt;/p&gt;


</comment>
                            <comment id="13406824" author="hustlmsp" created="Thu, 5 Jul 2012 03:39:03 +0100"  >&lt;p&gt;ah, this issue is quite similar as &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-215&quot; title=&quot;Deadlock occurs under high load&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-215&quot;&gt;&lt;del&gt;BOOKKEEPER-215&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt;. The common cause of these jiras are we call bookkeeper operations (addEntry/readEntry) in previous operations&apos; callbacks. &lt;/p&gt;

&lt;p&gt;a possible fix (as Uma mentioned) is to submit bookkeeper operations in another OrderedSafeExecutor (callbackWorker) not call them directly in previous operations&apos; callback, which is in the early patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-215&quot; title=&quot;Deadlock occurs under high load&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-215&quot;&gt;&lt;del&gt;BOOKKEEPER-215&lt;/del&gt;&lt;/a&gt;. I think this fix could resolve deadlock issue encountered in ledger recovery both &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-326&quot; title=&quot;DeadLock during ledger recovery &quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-326&quot;&gt;&lt;del&gt;BOOKKEEPER-326&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.bookkeeper.client.DigestManager.RecoveryData;
 &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.bookkeeper.proto.BookieProtocol;
 &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
+&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.bookkeeper.util.SafeRunnable;
 
 &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.zookeeper.KeeperException;
 &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.slf4j.Logger;
@@ -89,16 +90,22 @@ class LedgerRecoveryOp &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; ReadCallback, AddCallback {
      */
     &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void doRecoveryRead() {
         lh.lastAddConfirmed++;
-        lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
+        LOG.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Submit recovery read entry {} &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ledger {}&quot;&lt;/span&gt;, lh.lastAddConfirmed, lh.getId());
+        lh.bk.callbackWorker.submitOrdered(lh.getId(), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SafeRunnable() {
+            @Override
+            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void safeRun() {
+                lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, LedgerRecoveryOp.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
+            }
+        });
     }
 
     @Override
-    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void readComplete(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; rc, LedgerHandle lh, Enumeration&amp;lt;LedgerEntry&amp;gt; seq, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; ctx) {
+    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void readComplete(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; rc, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; LedgerHandle lh, Enumeration&amp;lt;LedgerEntry&amp;gt; seq, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; ctx) {
         &lt;span class=&quot;code-comment&quot;&gt;// get back to prev value
&lt;/span&gt;         lh.lastAddConfirmed--;
         &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (rc == BKException.Code.OK) {
             LedgerEntry entry = seq.nextElement();
-            &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] data = entry.getEntry();
+            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] data = entry.getEntry();
 
             /*
              * We will add &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; entry again to make sure it is written to enough
@@ -106,7 +113,12 @@ class LedgerRecoveryOp &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; ReadCallback, AddCallback {
              * be added again when processing the call to add it.
              */
             lh.length = entry.getLength() - (&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;) data.length;
-            lh.asyncRecoveryAddEntry(data, 0, data.length, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
+            lh.bk.callbackWorker.submitOrdered(lh.getId(), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SafeRunnable() {
+                @Override
+                &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void safeRun() {
+                    lh.asyncRecoveryAddEntry(data, 0, data.length, LedgerRecoveryOp.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
+                }
+            });
 
             &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
         }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13406825" author="hustlmsp" created="Thu, 5 Jul 2012 03:42:33 +0100"  >&lt;p&gt;marked it as blocker, since the deadlock issue is in ledger recovery which is a core operation.&lt;/p&gt;</comment>
                            <comment id="13406826" author="hustlmsp" created="Thu, 5 Jul 2012 03:43:19 +0100"  >&lt;p&gt;similar issue in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13406869" author="rakeshr" created="Thu, 5 Jul 2012 07:29:22 +0100"  >&lt;p&gt;Hi All,&lt;/p&gt;

&lt;p&gt;I just moved the addlistener() outside the lock, so that notifications will invoke all the pendingOps not under the PerChannelBookieClient.this lock.&lt;/p&gt;

&lt;p&gt;I&apos;ve uploaded initial draft patch to discuss more on the problem and identifying better approach.&lt;/p&gt;

&lt;p&gt;IMHO, it would be good if we able to correct the PerChannelBookieClient rather than fixing in the callbacks.&lt;/p&gt;</comment>
                            <comment id="13412897" author="ikelly" created="Thu, 12 Jul 2012 17:07:10 +0100"  >&lt;p&gt;I don&apos;t think the problem here is that callbacks are running in the same thread. Rather, in LedgerHandle, even though we have an executor, we only use it for add operations. If we put all read operations and readLastConfirmed operations into the executor, we shouldn&apos;t be able to get deadlocks like this, as operations on a single ledger should be serialized. &lt;/p&gt;

&lt;p&gt;Of course this doesn&apos;t address the Semaphore based deadlock. I was thinking recently that we could start using something like &lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/RateLimiter.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/RateLimiter.html&lt;/a&gt; to alleviate the problem.  &lt;/p&gt;</comment>
                            <comment id="13412898" author="ikelly" created="Thu, 12 Jul 2012 17:08:24 +0100"  >&lt;p&gt;Is this deadlock easily reproducible? &lt;/p&gt;</comment>
                            <comment id="13413492" author="rakeshr" created="Fri, 13 Jul 2012 05:48:03 +0100"  >&lt;p&gt;@Ivan&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I don&apos;t think the problem here is that callbacks are running in the same thread&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;ChannelFuture javadoc says that if the connection has already established before adding the listener, it will be notified immediately.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    /**
     * Adds the specified listener to &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.  The
     * specified listener is notified when &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; is
     * {@linkplain #isDone() done}.  If &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; is already
     * completed, the specified listener is notified immediately.
     */
    void addListener(ChannelFutureListener listener);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also, I&apos;ve seen netty is creating &apos;DefaultChannelFuture&apos; instance and the addListener() method invokes operationComplete() call in the same thread.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void addListener(ChannelFutureListener listener) {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (listener == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;code-quote&quot;&gt;&quot;listener&quot;&lt;/span&gt;);
        }

        &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; notifyNow = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (done) {
                notifyNow = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;code-comment&quot;&gt;//.......
&lt;/span&gt;            }
        }

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (notifyNow) {
            notifyListener(listener);
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;We will be able to see this by just hold(debug point) the &apos;future.addListener()&apos; invocation for few ms/secs. After connection establishment if we execute future.addListener will notifies the operationComplete() in the same thread. &lt;/p&gt;</comment>
                            <comment id="13413497" author="rakeshr" created="Fri, 13 Jul 2012 06:06:23 +0100"  >&lt;p&gt;I&apos;m thinking the following contract broken due to this behaviour of netty notifications. &lt;br/&gt;
Either we should have an executor for &apos;pendingOp.operationComplete(rc, null);&apos; or like the uploaded patch we will fully exclude addlistener() call outside PerChannelBookieClient lock?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// trick to not &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; operations under the lock, take the list
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// of pending ops and assign it to a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; variable, &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// emptying the pending ops by just assigning it to a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// list&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13413642" author="ikelly" created="Fri, 13 Jul 2012 11:33:32 +0100"  >&lt;blockquote&gt;
&lt;p&gt;We will be able to see this by just hold(debug point) the &apos;future.addListener()&apos; invocation for few ms/secs. After connection establishment if we execute future.addListener will notifies the operationComplete() in the same thread. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;What test case are you executing when you do this? I&apos;ve added a mod, to await on the future and then add the listener, but it&apos;s not hitting the deadlock.&lt;/p&gt;
</comment>
                            <comment id="13413681" author="rakeshr" created="Fri, 13 Jul 2012 12:59:05 +0100"  >&lt;p&gt;Hi Ivan, Hope you have seen the netty notification are coming in the same thread after adding the wait before addListener()?&lt;/p&gt;

&lt;p&gt;Test case: BookieFailureTest.testLedgerOpenAfterBKCrashed()&lt;/p&gt;

&lt;p&gt;Scenario link:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-326?focusedCommentId=13406296&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13406296&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/BOOKKEEPER-326?focusedCommentId=13406296&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13406296&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13413813" author="ikelly" created="Fri, 13 Jul 2012 16:24:04 +0100"  >&lt;p&gt;I managed to repro this.&lt;/p&gt;

&lt;p&gt;I think the solution should be two-fold.&lt;br/&gt;
1. We should tighten up the the synchronization as Rakesh&apos;s patch does.&lt;br/&gt;
2. We should ensure that call to the client don&apos;t reenter. I&apos;ve attached a patch which insures it doesn&apos;t happen on the public methods of LedgerHandle.&lt;/p&gt;

&lt;p&gt;In fact, I think 1 could go even further. The only thing that needs to be protected by synchronization in PerChannelBookieClient#connect is the state variable. As such, that&apos;s all we should be protecting.&lt;/p&gt;</comment>
                            <comment id="13414963" author="rakeshr" created="Mon, 16 Jul 2012 10:49:34 +0100"  >&lt;p&gt;Thanks a lot Ivan for your time&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I&apos;ve uploaded new patch by incorporating Ivan&apos;s point. Here I tried to keep only the &apos;state&apos; and &apos;channel&apos; under the PerChannelBookieClient.this lock.&lt;/p&gt;

&lt;p&gt;Also, I&apos;ve added a test case but this will only forcing to establish new client connections. With this there is high chance of getting notifications in the same thread and invoke the pending operations in the caller thread itself. We would be able to reproduce the deadlock scenario only by putting debug points.&lt;/p&gt;

&lt;p&gt;Hi others, Please have a look on the latest patch.&lt;/p&gt;

&lt;p&gt;Thanks, &lt;br/&gt;
Rakesh &lt;/p&gt;</comment>
                            <comment id="13415077" author="hustlmsp" created="Mon, 16 Jul 2012 13:58:28 +0100"  >&lt;p&gt;thanks for Rakesh providing the patch.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void connect() {
-        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (state == ConnectionState.CONNECTING) {
-            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
-        } 
-        &lt;span class=&quot;code-comment&quot;&gt;// Start the connection attempt to the input server host.
&lt;/span&gt;-        state = ConnectionState.CONNECTING;
-
+    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void connect() {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I am not sure I understood the above changes. but if you removed the above codes. how you could prevent concurrently call to #connect method? as Ivan suggested, synchronized on state variable would be enough.&lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt;2. We should ensure that call to the client don&apos;t reenter. I&apos;ve attached a patch which insures it doesn&apos;t happen on the public methods of LedgerHandle.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;-1 on the changes Ivan made to LedgerHandle. it breaks the throttle mechanism we deployed in BookKeeper now. for now, we use semaphore to do rate limit on both read/write operations, if permits are exhausted, the client which called addEntry/readEntries would be blocked until the permits are releases. the changes would not block client when permits are exhausted.&lt;/p&gt;

&lt;p&gt;so before we had a new throttling mechanism (may be using RateLimit as Ivan mentioned), we don&apos;t need to include these changes in this jira. And I think it would be in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt; discussing new throttling mechanism.&lt;/p&gt;</comment>
                            <comment id="13415113" author="rakeshr" created="Mon, 16 Jul 2012 14:42:35 +0100"  >&lt;p&gt;Thanks a lot Sijie for your time and review.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;as Ivan suggested, synchronized on state variable would be enough.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;@Sijie&lt;br/&gt;
As I understood from Ivan&apos;s comment, we should protect only the state variable in the synchronization and suggested to move the connection logic outside the sync block. &lt;/p&gt;

&lt;p&gt;Could you please clarify whether you are suggesting to use &apos;synchronized on state variable&apos;? IMHO shouldn&apos;t use enum as lock(since the object will change when state changes and lock will be no more)&lt;/p&gt;

&lt;p&gt;Ivan&apos;s comment: &quot;The only thing that needs to be protected by synchronization in PerChannelBookieClient#connect is the state variable&quot;&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;but if you removed the above codes. how you could prevent concurrently call to #connect method?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I haven&apos;t completely cleared, instead just moved the checks to connectIfNeededAndDoOp() so that if the state is connecting then returning silently by adding op to &apos;pendingOps&apos;. Here the flow will not come to connect at all.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;) {
   &lt;span class=&quot;code-comment&quot;&gt;//....
&lt;/span&gt;   &lt;span class=&quot;code-comment&quot;&gt;//...
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (state == ConnectionState.CONNECTING) {
      &lt;span class=&quot;code-comment&quot;&gt;// just &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; as connection request has already send
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// and waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the response.
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
  }
  &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;switch&lt;/span&gt; state to connecting and &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; connection attempt
&lt;/span&gt;  state = ConnectionState.CONNECTING;

  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!doOpNow) {
    &lt;span class=&quot;code-comment&quot;&gt;// Start the connection attempt to the input server host.
&lt;/span&gt;    connect();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;blockquote&gt;&lt;p&gt;-1 on the changes Ivan made to LedgerHandle. it breaks the throttle mechanism we deployed in BookKeeper now. for now, we use semaphore to do rate limit on both read/write operations, if permits are exhausted, the client which called addEntry/readEntries would be blocked until the permits are releases. the changes would not block client when permits are exhausted.&lt;br/&gt;
so before we had a new throttling mechanism (may be using RateLimit as Ivan mentioned), we don&apos;t need to include these changes in this jira. And I think it would be in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt; discussing new throttling mechanism.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;BTW, if you have any suggestions/logic to be done as part of this JIRA, could you please explain me so that I&apos;ll take care.&lt;/p&gt;</comment>
                            <comment id="13415138" author="hustlmsp" created="Mon, 16 Jul 2012 15:04:15 +0100"  >&lt;p&gt;ah, sorry, I just missed the part you move from #connect() to #connectIfNeededAndDoOp(). you changes are correct.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; BTW, if you have any suggestions/logic to be done as part of this JIRA, could you please explain me so that I&apos;ll take care&lt;/p&gt;

&lt;p&gt;I don&apos;t have any logic to add here. As my comment, if we want to change throttling mechanism, it would be in &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-239&quot; title=&quot;Deadlock in ledger recovery when there is limited permits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-239&quot;&gt;&lt;del&gt;BOOKKEEPER-239&lt;/del&gt;&lt;/a&gt; not here.&lt;/p&gt;

&lt;p&gt;+1 on Rakesh&apos;s changes.&lt;/p&gt;</comment>
                            <comment id="13420502" author="rakeshr" created="Mon, 23 Jul 2012 09:42:16 +0100"  >&lt;p&gt;Hi Sijie, as per the suggestion uploaded latest patch includes only PerChannelBookieClient changes. &lt;/p&gt;

&lt;p&gt;It would be great if others can have a look on the changes.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Rakesh&lt;/p&gt;</comment>
                            <comment id="13420527" author="umamaheswararao" created="Mon, 23 Jul 2012 10:38:28 +0100"  >&lt;p&gt;@Rakesh, change looks good to me.&lt;/p&gt;

&lt;p&gt;I have some observations in test but they are not be really related to this chnage alone.&lt;br/&gt;
In Tests: Default BookieRecoveryTest taking the number of bookies as argument in constructors.&lt;br/&gt;
So, setUp will start the number of bookies for testCase. If we start any bookies our own, do we need to clean all the resources( ex: bsConf) to that Bookie our own? what is the contract here?&lt;br/&gt;
Otherwise I have seen one problem with restartBookies API. This API is useing the bsConf for restarting the bookies. But tearDown is leaving that extra started Bookies confs in bsConf. So, restartBookies may start that older bookies also.&lt;br/&gt;
In my opinion, we should clean that bsConf in tearSown or stopBKCluster.&lt;br/&gt;
Since this change is not related to this particular change, does it make sense to file a separate JIRA? Why I raised this concerne here is, when I saw the test code observed there are extra bookies started in this test.&lt;br/&gt;
What do you say Sijie?&lt;/p&gt;

&lt;p&gt;Also, I am not sure, that test will reproduce the case, but it may be worth keeping the test as he is using newer clients. I am not sure, is there a better way to automat this deadLock here by tests. So,keeping this test should be ok from me.&lt;/p&gt;

&lt;p&gt;Thanks&lt;br/&gt;
Uma&lt;/p&gt;
</comment>
                            <comment id="13429196" author="ikelly" created="Mon, 6 Aug 2012 16:31:02 +0100"  >&lt;blockquote&gt;
&lt;p&gt;-1 on the changes Ivan made to LedgerHandle. it breaks the throttle mechanism we deployed in BookKeeper now. for now, we use semaphore to do rate limit on both read/write operations, if permits are exhausted, the client which called addEntry/readEntries would be blocked until the permits are releases. the changes would not block client when permits are exhausted.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I had forgotten that PendingReadOp reaches into the ledger handle to take the permit. I think, even if don&apos;t move to a rate limiting semaphore, we should move all calls to the semaphore into LedgerHandle and remove all accesses from without. This way, we could make the change I suggested, which would be another safeguard against deadlocking, and is generally better software engineering practice also.&lt;/p&gt;

&lt;p&gt;@Rakesh&lt;br/&gt;
The patch you have up is good. Is there a reason this JIRA isn&apos;t patch available?&lt;/p&gt;</comment>
                            <comment id="13429929" author="rakeshr" created="Tue, 7 Aug 2012 05:51:12 +0100"  >&lt;p&gt;@Ivan&lt;br/&gt;
I was trying to reproduce deadlock through test case, but couldn&apos;t&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13429993" author="ikelly" created="Tue, 7 Aug 2012 08:40:52 +0100"  >&lt;p&gt;I think it&apos;s near impossible to automatically and reliably trigger this deadlock, as it&apos;s reliant on a delay occurring between bootstrap.connect, and adding the FutureListener. I think I could get it to trigger fairly reliably with some hacks in the code (no suitable for putting into production), so you you submit a patch with the fix, forgetting about the test case, run with the hack to ensure it hits, apply your patch, and then run with the hack again to verify the deadlock does not occur.&lt;/p&gt;</comment>
                            <comment id="13430316" author="rakeshr" created="Tue, 7 Aug 2012 13:33:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think it&apos;s near impossible to automatically and reliably trigger this deadlock&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;@Ivan&lt;br/&gt;
Then could you have a look on &apos;&lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-326&quot; title=&quot;DeadLock during ledger recovery &quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-326&quot;&gt;&lt;del&gt;BOOKKEEPER-326&lt;/del&gt;&lt;/a&gt;.2.patch&apos;. Here I had kept only the necessary changes.&lt;/p&gt;</comment>
                            <comment id="13432695" author="rakeshr" created="Fri, 10 Aug 2012 11:53:37 +0100"  >&lt;p&gt;I&apos;ve rebased the patch in the latest trunk code. Could you please help to review.&lt;/p&gt;</comment>
                            <comment id="13432698" author="surendrasingh" created="Fri, 10 Aug 2012 12:04:02 +0100"  >&lt;p&gt;@Ivan&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I think it&apos;s near impossible to automatically and reliably trigger this deadlock, as it&apos;s reliant on a delay occurring between bootstrap.connect, and adding the FutureListener. I think I could get it to trigger fairly reliably with some hacks in the code (no suitable for putting into production), so you you submit a patch with the fix, forgetting about the test case, run with the hack to ensure it hits, apply your patch, and then run with the hack again to verify the deadlock does not occur.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The following scenario was tested by applying the patch and &quot;JCarder agent&quot; enabled (for deadlock detection).&lt;/p&gt;

&lt;p&gt;1.Ledger is created and entries are writter to 3 bookies.&lt;br/&gt;
2.one of bookie is killed. (say this bookie is not the first bookie in the ensemble)&lt;br/&gt;
3.New bookie started.&lt;br/&gt;
4.now openLedger() call is made to recover the ledger. as part of this readLastConfirmed request will be added each of the bookies with callback ReadLastConfirmedOp.readEntryComplete which is synchronized.&lt;br/&gt;
5.First callback came from first bookie which is alive in separate thread and entered ReadLastConfirmedOp.readEntryComplete() and processing.&lt;br/&gt;
6.Another Callback came for the failed bookie from connect() method by holding the lock of PerChannelBookieClient instance of failed bookie, and trying to invoke the same callback, but BLOCKED. ( Here to invoke the listener in same thread, need to wait before future.addListener(..) by putting debug point)&lt;br/&gt;
7.As part of first call back, doRecoveryRead() will put one PendingReadOp request for asyncread. If this PendingReadOp selects same PerChannelBookieClient of failed bookie for read, then it will enter to deadlock. (To reproduce, bookieIndex variable can be changed to index of the failed bookie in PendingReadOp.sendRead(..))&lt;/p&gt;

&lt;p&gt;JCarder Output:&lt;br/&gt;
==================&lt;br/&gt;
Loaded from database files:&lt;br/&gt;
   Nodes: 4112&lt;br/&gt;
   Edges: 5946 (excluding 5786 duplicated)&lt;/p&gt;

&lt;p&gt;Cycle analysis result:&lt;br/&gt;
   Cycles:          0&lt;br/&gt;
   Edges in cycles: 0&lt;br/&gt;
   Nodes in cycles: 0&lt;br/&gt;
   Max cycle depth: 0&lt;br/&gt;
   Max graph depth: 2&lt;/p&gt;

&lt;p&gt;Ignoring 0 gated cycle(s).&lt;br/&gt;
No cycles found!&lt;/p&gt;
</comment>
                            <comment id="13432701" author="ikelly" created="Fri, 10 Aug 2012 12:13:01 +0100"  >&lt;p&gt;@surendra&lt;br/&gt;
Do you have the same output for the scenario without the patch applied?&lt;/p&gt;</comment>
                            <comment id="13433026" author="ikelly" created="Mon, 13 Aug 2012 10:39:18 +0100"  >&lt;p&gt;Committed as r1372343. Thanks Rakesh&lt;/p&gt;</comment>
                            <comment id="13433038" author="hudson" created="Mon, 13 Aug 2012 11:16:14 +0100"  >&lt;p&gt;Integrated in bookkeeper-trunk #645 (See &lt;a href=&quot;https://builds.apache.org/job/bookkeeper-trunk/645/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/bookkeeper-trunk/645/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/BOOKKEEPER-326&quot; title=&quot;DeadLock during ledger recovery &quot; class=&quot;issue-link&quot; data-issue-key=&quot;BOOKKEEPER-326&quot;&gt;&lt;del&gt;BOOKKEEPER-326&lt;/del&gt;&lt;/a&gt;: DeadLock during ledger recovery (rakeshr via ivank) (Revision 1372343)&lt;/p&gt;

&lt;p&gt;     Result = ABORTED&lt;br/&gt;
ivank : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java&lt;/li&gt;
	&lt;li&gt;/zookeeper/bookkeeper/trunk/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13433041" author="surendrasingh" created="Mon, 13 Aug 2012 11:22:15 +0100"  >&lt;p&gt;@Ivan&lt;/p&gt;

&lt;p&gt;Jcarder Report without applying the patch : &lt;/p&gt;

&lt;p&gt;========================================================================&lt;br/&gt;
Opening for reading: D:\out\jcarder_contexts.db&lt;br/&gt;
Opening for reading: D:\out\jcarder_events.db&lt;/p&gt;

&lt;p&gt;Loaded from database files:&lt;br/&gt;
   Nodes: 843&lt;br/&gt;
   Edges: 774 (excluding 10449 duplicated)&lt;/p&gt;

&lt;p&gt;Cycle analysis result:&lt;br/&gt;
   Cycles:          1&lt;br/&gt;
   Edges in cycles: 2&lt;br/&gt;
   Nodes in cycles: 2&lt;br/&gt;
   Max cycle depth: 2&lt;br/&gt;
   Max graph depth: 3&lt;/p&gt;

&lt;p&gt;Ignoring 0 gated cycle(s).&lt;br/&gt;
Ignoring 0 almost identical cycle(s).&lt;/p&gt;

&lt;p&gt;===================================================================================&lt;/p&gt;

&lt;p&gt;Here one cycle is found.&lt;br/&gt;
I have attached one BK326.PNG file which show the graphically Deadlock cycle.&lt;/p&gt;</comment>
                            <comment id="13433062" author="ikelly" created="Mon, 13 Aug 2012 12:05:28 +0100"  >&lt;p&gt;Committed to 4.1 branch as r1372362.&lt;/p&gt;</comment>
                            <comment id="13433067" author="ikelly" created="Mon, 13 Aug 2012 12:16:25 +0100"  >&lt;p&gt;Thanks for the numbers Surendra&lt;/p&gt;</comment>
                            <comment id="13433897" author="rakeshr" created="Tue, 14 Aug 2012 06:06:45 +0100"  >&lt;p&gt;Thanks a lot Surendra. Its great work!&lt;br/&gt;
Also Thanks Sijie &amp;amp; Ivan for the reviews and committing the issue&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12554161">BOOKKEEPER-239</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12540637" name="BK326.png" size="21672" author="surendrasingh" created="Mon, 13 Aug 2012 11:20:32 +0100"/>
                            <attachment id="12535037" name="BK_DeadLock.log" size="40238" author="vinayrpet" created="Wed, 4 Jul 2012 05:40:49 +0100"/>
                            <attachment id="12536609" name="BOOKKEEPER-326.1.patch" size="8461" author="rakeshr" created="Mon, 16 Jul 2012 10:36:10 +0100"/>
                            <attachment id="12537552" name="BOOKKEEPER-326.2.patch" size="5613" author="rakeshr" created="Mon, 23 Jul 2012 09:42:16 +0100"/>
                            <attachment id="12540468" name="BOOKKEEPER-326.3.patch" size="5291" author="rakeshr" created="Fri, 10 Aug 2012 11:53:37 +0100"/>
                            <attachment id="12536396" name="BOOKKEEPER-326.part2.diff" size="2828" author="ikelly" created="Fri, 13 Jul 2012 16:24:04 +0100"/>
                            <attachment id="12535151" name="BOOKKEEPER-326.patch" size="2933" author="rakeshr" created="Thu, 5 Jul 2012 07:18:28 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 4 Jul 2012 05:33:48 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>293515</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyn5dj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>169058</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>