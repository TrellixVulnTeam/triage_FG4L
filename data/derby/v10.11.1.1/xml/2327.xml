<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:52:13 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2327/DERBY-2327.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2327] Reduce monitor contention in LockSet</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2327</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When multiple threads enter the lock manager, only one can access the hash table in LockSet. To improve scalability on multiple CPUs, it should be possible to have more than one thread accessing the lock table at the same time.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12362667">DERBY-2327</key>
            <summary>Reduce monitor contention in LockSet</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12348056">DERBY-1704</parent>
                                    <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 13 Feb 2007 09:21:16 +0000</created>
                <updated>Mon, 29 Jun 2009 15:16:21 +0100</updated>
                            <resolved>Thu, 24 May 2007 08:30:33 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Services</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12472704" author="djd" created="Tue, 13 Feb 2007 15:21:22 +0000"  >&lt;p&gt;Does it make sense to use java.util.concurrent.ConcurrentHashMap and have two implementation of the lock factory.&lt;br/&gt;
Ie. use Java&apos;s existing mechanisms to solve this problem rather than re-inventing stuff?&lt;br/&gt;
Obviously the benefit would only be seeon on JDK 5.0 or later but I don&apos;t think that&apos;s a problem.&lt;/p&gt;</comment>
                            <comment id="12472716" author="knutanders" created="Tue, 13 Feb 2007 15:40:48 +0000"  >&lt;p&gt;I agree that ConcurrentHashMap is the way to go. ConcurrentHashMap.diff is an experimental patch which replaces the HashMap in LockSet with a ConcurrentHashMap. It seems to have good effect on the 1000x10000 join load from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1961&quot; title=&quot;Investigate resource usage for different types of load on an in-memory database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1961&quot;&gt;&lt;del&gt;DERBY-1961&lt;/del&gt;&lt;/a&gt; on multi-CPUs. It doesn&apos;t come for free in single-user environments though, but that could just as well be caused by stupid implementation by me. Note that the patch is in a very experimental state. It runs, but exotic features like deadlock detection certainly don&apos;t work. Also, in its current state it requires JDK6 to compile and run.&lt;/p&gt;</comment>
                            <comment id="12478128" author="knutanders" created="Mon, 5 Mar 2007 19:10:10 +0000"  >&lt;p&gt;To make it easier to plug in another LockSet implementation, LockSet should be better encapsulated. I&apos;m attaching a patch (derby-2327-1a) which makes these changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;creates a new interface (LockTable) which LockSet implements&lt;/li&gt;
	&lt;li&gt;replaces all references to LockSet with references to the new LockTable interface&lt;/li&gt;
	&lt;li&gt;moves code that explicitly synchronizes on the LockSet object from LockSpace.unlockReference() and SinglePool.zeroDurationlockObject() to LockSet so that the granularity of the synchronization can be controlled by the LockSet implementation alone&lt;/li&gt;
	&lt;li&gt;adds setter methods for deadlock timeout and wait timeout&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Derbyall and suites.All passed on Solaris 10, Java SE 6.&lt;/p&gt;</comment>
                            <comment id="12478322" author="knutanders" created="Tue, 6 Mar 2007 09:18:58 +0000"  >&lt;p&gt;Committed 1a with revision 515040.&lt;/p&gt;</comment>
                            <comment id="12479595" author="knutanders" created="Fri, 9 Mar 2007 14:12:35 +0000"  >&lt;p&gt;Here are my thoughts on how to attack this issue:&lt;/p&gt;

&lt;p&gt;With the refactoring that improved the encapsulation of LockSet, it&lt;br/&gt;
should be possible to plug in another implementation of LockSet (say&lt;br/&gt;
ConcurrentLockSet) with very little need for changes in other&lt;br/&gt;
classes. The new implementation of LockSet will use a&lt;br/&gt;
ConcurrentHashMap instead of a HashMap, and it will not synchronize on&lt;br/&gt;
the LockSet object. With the exception of the creation of the&lt;br/&gt;
diagnostic lock table (VTI) and the deadlock detection, all the&lt;br/&gt;
synchronized blocks in LockSet touch only one entry in the lock table,&lt;br/&gt;
so I think the natural synchronization granularity is a single entry&lt;br/&gt;
(which corresponds to a single Lockable object).&lt;/p&gt;

&lt;p&gt;For the parts of the code that only touch one entry, I think the new&lt;br/&gt;
implementation could basically be the same as the old one, only that&lt;br/&gt;
it synchronizes on the lock entry instead of on the LockSet. Since&lt;br/&gt;
they only lock one entry at a time, there shouldn&apos;t be any risk of a&lt;br/&gt;
Java-level deadlock.&lt;/p&gt;

&lt;p&gt;One thing that becomes trickier with a ConcurrentHashMap, is that you&lt;br/&gt;
don&apos;t synchronize on the map so another thread might for instance&lt;br/&gt;
remove an entry from the map after you have fetched it and before you&lt;br/&gt;
have locked/synchronized on it. Therefore, the fetching from the map&lt;br/&gt;
must be performed in a loop where you fetch, lock and finally check&lt;br/&gt;
that no one has removed it.&lt;/p&gt;

&lt;p&gt;In the current LockSet implementation, the creation of the virtual&lt;br/&gt;
lock table synchronizes on the LockSet. In order to guarantee that a&lt;br/&gt;
consistent snapshot of the lock table is made, some sort of global&lt;br/&gt;
synchronization is needed, but that would bring us back to square one&lt;br/&gt;
with regards to concurrency. However, the javadoc for the LockTable&lt;br/&gt;
VTI says that consistency is not a requirement:&lt;/p&gt;

&lt;p&gt;&amp;gt; The LockTable virtual table takes a snap shot of the lock table&lt;br/&gt;
&amp;gt; while the system is in flux, so it is possible that some locks may&lt;br/&gt;
&amp;gt; be in transition state while the snap shot is taken. We choose to do&lt;br/&gt;
&amp;gt; this rather then impose extranous timing restrictions so that the&lt;br/&gt;
&amp;gt; use of this tool will not alter the normal timing and flow of&lt;br/&gt;
&amp;gt; execution in the application.&lt;/p&gt;

&lt;p&gt;Therefore, I think it will be OK to just get an iterator from the&lt;br/&gt;
ConcurrentHashMap (whose javadoc says that the iterator is &quot;weakly&lt;br/&gt;
consistent&quot;) and lock/synchronize the entries one by one.&lt;/p&gt;

&lt;p&gt;On the other hand, the deadlock detection does require a certain&lt;br/&gt;
amount of consistency in the snapshot it&apos;s working on. To illustrate&lt;br/&gt;
it, consider this example:&lt;/p&gt;

&lt;p&gt;  1. When the deadlock detection starts, A is waiting for B.&lt;br/&gt;
  2. The deadlock detection sees that A waits for B.&lt;br/&gt;
  3. B unlocks the object A is waiting for, and A can continue.&lt;br/&gt;
  4. B then tries to lock an object which A holds and must wait.&lt;br/&gt;
  5. The deadlock detection sees that B waits for A.&lt;/p&gt;

&lt;p&gt;The deadlock detection then believes that A waits for B which waits&lt;br/&gt;
for A. That is, it believes we have a deadlock, when in fact A is not&lt;br/&gt;
waiting for B anymore. &lt;/p&gt;

&lt;p&gt;I think this problem can be avoided by following a two-phase locking&lt;br/&gt;
scheme when synchronizing on the entries of the lock table. That is,&lt;br/&gt;
we lock the entries one by one as we see them, but don&apos;t unlock any of&lt;br/&gt;
them until we have finished the traversal. This way, we know that all&lt;br/&gt;
the waiters we have seen while traversing the lock table are still&lt;br/&gt;
waiting. In the example above, it would mean that in (3) B would not&lt;br/&gt;
be allowed to unlock the object until the deadlock detection had&lt;br/&gt;
finished. It would therefore see that A was waiting for B, but not&lt;br/&gt;
that B was waiting for A, so it would (correctly) not report a&lt;br/&gt;
deadlock between A and B.&lt;/p&gt;

&lt;p&gt;This approach does not ensure that the deadlock detection has a&lt;br/&gt;
complete and consistent wait-for graph, since ConcurrentHashMap&apos;s&lt;br/&gt;
iterator doesn&apos;t guarantee that concurrent modifications are visible,&lt;br/&gt;
but I think it will ensure that (a) all deadlocks present when the&lt;br/&gt;
deadlock detection starts will be detected, and (b) no false deadlocks&lt;br/&gt;
will be reported.&lt;/p&gt;

&lt;p&gt;Since the iterator doesn&apos;t guarantee that the ordering will be the&lt;br/&gt;
same each time, we can only have one thread performing deadlock&lt;br/&gt;
detection at a time in order to avoid Java-level deadlocks. Also, no&lt;br/&gt;
thread can start deadlock detection when it is synchronized on an&lt;br/&gt;
entry in the lock table.&lt;/p&gt;

&lt;p&gt;Are there any comments to this approach? Any false/suspicious&lt;br/&gt;
assumptions or anything I have forgotten?&lt;/p&gt;</comment>
                            <comment id="12479638" author="djd" created="Fri, 9 Mar 2007 16:36:28 +0000"  >&lt;p&gt;Thanks for the detailed writeup. This section has me confused though:&lt;/p&gt;

&lt;p&gt;&amp;gt; I think this problem can be avoided by following a two-phase locking&lt;br/&gt;
&amp;gt; scheme when synchronizing on the entries of the lock table. That is,&lt;br/&gt;
&amp;gt; we lock the entries one by one as we see them, but don&apos;t unlock any of&lt;br/&gt;
&amp;gt; them until we have finished the traversal.&lt;/p&gt;

&lt;p&gt;What does &quot;lock the entries&quot; mean here, java synchronization on the object, or logical lock (e.g. row lock/table lock)?&lt;/p&gt;

&lt;p&gt;I don&apos;t see how one could code so that java synchronization is kept on many objects without deep stack nesting.&lt;/p&gt;

&lt;p&gt;The entries are already logically locked so I&apos;m not sure how locking them again would help?.&lt;/p&gt;</comment>
                            <comment id="12479813" author="knutanders" created="Sat, 10 Mar 2007 08:21:31 +0000"  >&lt;p&gt;I was thinking of using java.util.concurrent.locks.ReentrantLock, which should give us the same as synchronization only with more flexibility. Then we don&apos;t need one stack frame per lock. Instead we can keep the locks in a list, like this:&lt;/p&gt;

&lt;p&gt;  LinkedList&amp;lt;ReentrantLock&amp;gt; mutexes = new LinkedList&amp;lt;ReentrantLock&amp;gt;();&lt;br/&gt;
  try {&lt;br/&gt;
    for (Entry e : locks.values()) &lt;/p&gt;
{
       mutexes.add(e.mutex);
       e.mutex.lock();
       // .....
    }
&lt;p&gt;  } finally &lt;/p&gt;
{
    for (ReentrantLock mutex : mutexes) mutex.unlock();
  }

&lt;p&gt;Of course, this will give us a small space overhead compared to a plain synchronization approach.&lt;/p&gt;</comment>
                            <comment id="12480111" author="knutanders" created="Mon, 12 Mar 2007 14:50:09 +0000"  >&lt;p&gt;Attaching a new refactoring patch (2a). The patch moves all the methods from SinglePool to a new abstract class called AbstractPool. AbstractPool is now the super-class of SinglePool. The only code left in SinglePool is the creation of the LockSet instance. The purpose of the patch is to make it easier to create a new LockFactory class which is identical to SinglePool except that it uses another LockSet implementation.&lt;/p&gt;

&lt;p&gt;To apply the patch, first issue this command:&lt;/p&gt;

&lt;p&gt;  svn cp java/engine/org/apache/derby/impl/services/locks/SinglePool.java java/engine/org/apache/derby/impl/services/locks/AbstractPool.java&lt;/p&gt;

&lt;p&gt;All the tests passed on Solaris 10, Sun Java SE 6.&lt;/p&gt;</comment>
                            <comment id="12480309" author="knutanders" created="Tue, 13 Mar 2007 08:30:15 +0000"  >&lt;p&gt;Committed 2a with revision 517586.&lt;/p&gt;</comment>
                            <comment id="12480386" author="knutanders" created="Tue, 13 Mar 2007 13:11:41 +0000"  >&lt;p&gt;derby-2327-3a.diff makes the methods in Deadlock.java take an AbstractPool instance instead a SinglePool. All tests ran cleanly.&lt;/p&gt;</comment>
                            <comment id="12480388" author="knutanders" created="Tue, 13 Mar 2007 13:14:51 +0000"  >&lt;p&gt;Committed 3a with revision 517680.&lt;/p&gt;</comment>
                            <comment id="12483463" author="knutanders" created="Fri, 23 Mar 2007 08:40:35 +0000"  >&lt;p&gt;Attaching a new patch (4a) which contains the implementation of a lock&lt;br/&gt;
manager which uses ConcurrentHashMap. Before the patch is applied, one&lt;br/&gt;
must execute the following command:&lt;/p&gt;

&lt;p&gt;  svn cp \&lt;br/&gt;
    java/engine/org/apache/derby/impl/services/locks/LockSet.java \&lt;br/&gt;
    java/engine/org/apache/derby/impl/services/locks/ConcurrentLockSet.java&lt;/p&gt;

&lt;p&gt;And after the patch is applied:&lt;/p&gt;

&lt;p&gt;  svn add java/engine/org/apache/derby/impl/services/locks/ConcurrentPool.java&lt;/p&gt;

&lt;p&gt;--------------&lt;/p&gt;

&lt;p&gt;Description of the patch:&lt;/p&gt;

&lt;p&gt;The patch adds two classes&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ConcurrentLockSet - which is supposed to behave exactly as LockSet,&lt;br/&gt;
    only that it uses a ConcurrentHashMap instead of a HashMap.&lt;/li&gt;
	&lt;li&gt;ConcurrentPool - which is like SinglePool only that it creates a&lt;br/&gt;
    instance of ConcurrentLockSet instead of LockSet.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ConcurrentLockSet is basically a copy of LockSet that uses&lt;br/&gt;
ConcurrentLockSet and replaces all occurrences of&lt;/p&gt;

&lt;p&gt;  synchronized (this) &lt;/p&gt;
{ ... }&lt;br/&gt;
&lt;br/&gt;
with&lt;br/&gt;
&lt;br/&gt;
  entry.lock();&lt;br/&gt;
  try { ... }
&lt;p&gt;  finally &lt;/p&gt;
{ entry.unlock(); }

&lt;p&gt;where entry.lock()/entry.unlock() locks/unlocks a&lt;br/&gt;
java.util.concurrent.locks.ReentrantLock associated with each&lt;br/&gt;
LockControl.&lt;/p&gt;

&lt;p&gt;To avoid Java deadlocks, each thread is normally not allowed to lock&lt;br/&gt;
more than one of the ReentrantLocks at a time. The exception is when a&lt;br/&gt;
thread performs deadlock detection. To prevent threads running&lt;br/&gt;
deadlock detection from running into deadlocks with each other,&lt;br/&gt;
different threads cannot run deadlock detection at the same time. A&lt;br/&gt;
thread must also release its ReentrantLocks before it starts deadlock&lt;br/&gt;
detection, since it might have to wait if another thread is already&lt;br/&gt;
running deadlock detection, and if it holds any ReentrantLocks, it&lt;br/&gt;
might deadlock with the other deadlock detection thread.&lt;/p&gt;

&lt;p&gt;Although the ReentrantLock is released before deadlock detection is&lt;br/&gt;
started, we don&apos;t want normal lock requests to be able to lock&lt;br/&gt;
it. Therefore a flag (actually a java.util.concurrent.locks.Condition&lt;br/&gt;
variable) is set to indicate that only threads performing deadlock&lt;br/&gt;
detection should be able to lock it. If normal requests try to lock&lt;br/&gt;
it, they will see the Condition variable and call await() on it, which&lt;br/&gt;
blocks until the thread that started deadlock detection has finished&lt;br/&gt;
and reacquired the ReentrantLock.&lt;/p&gt;

&lt;p&gt;The new lock manager only works with JDK5 and higher. I made the build&lt;br/&gt;
files use the optional jdk16 target, with source and target level set&lt;br/&gt;
to 1.5. Is that OK? I thought this was better than requiring yet&lt;br/&gt;
another JDK to build Derby.&lt;/p&gt;

&lt;p&gt;I have successfully run suites.All and derbyall on Sun&apos;s Java 1.4 and&lt;br/&gt;
Java 1.6 (1.4 uses SinglePool, 1.6 uses ConcurrentPool). Reviews would&lt;br/&gt;
be greatly appreciated. Thanks.&lt;/p&gt;</comment>
                            <comment id="12483475" author="knutanders" created="Fri, 23 Mar 2007 09:10:37 +0000"  >&lt;p&gt;I&apos;m attaching some throughput graphs to give an impression of the&lt;br/&gt;
effect of the 4a patch. I have used the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1961&quot; title=&quot;Investigate resource usage for different types of load on an in-memory database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1961&quot;&gt;&lt;del&gt;DERBY-1961&lt;/del&gt;&lt;/a&gt; test client with&lt;br/&gt;
single-record select load (primary key), 1 to 70 concurrent clients,&lt;br/&gt;
running embedded Derby with all data in the page cache. The graphs&lt;br/&gt;
show the throughput for trunk and the patched version of trunk with&lt;br/&gt;
JDK5 and JDK6. I have run the tests on three different machines: one&lt;br/&gt;
dual CPU Opteron, one machine with 8 CPUs, and one Niagara with 8&lt;br/&gt;
cores and 32 hardware threads. All the test machines were running&lt;br/&gt;
Solaris 10.&lt;/p&gt;

&lt;p&gt;With the exception of JDK6 on the dual Opteron machine, all the tests&lt;br/&gt;
show improved throughput with multiple clients. They don&apos;t show any&lt;br/&gt;
significant reduction in throughput in the single-user case.&lt;/p&gt;</comment>
                            <comment id="12483476" author="knutanders" created="Fri, 23 Mar 2007 09:17:31 +0000"  >&lt;p&gt;Also attaching throughput graphs for an identical configuration, only that it uses the 1000x10000 primary key joins in the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1961&quot; title=&quot;Investigate resource usage for different types of load on an in-memory database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1961&quot;&gt;&lt;del&gt;DERBY-1961&lt;/del&gt;&lt;/a&gt; test client. This load is more lock intensive than the single-record select load, and the effect of the patch is therefore greater. All configurations show improved throughput for concurrent connections (and some show improvement even in the single-user case).&lt;/p&gt;</comment>
                            <comment id="12489042" author="kristwaa" created="Mon, 16 Apr 2007 09:35:06 +0100"  >&lt;p&gt;I&apos;ve been using this patch in various loads, and have not seen any problems because of it.&lt;br/&gt;
Note that I have not reviewed the patch, so it would be nice if anyone took a look at it.&lt;/p&gt;

&lt;p&gt;But my experience from using the patch is that it works without problems and I do see performance improvements. The increase varies quite a lot depending on the type of load.&lt;/p&gt;

&lt;p&gt;+1 for commit, with a wish for code review first &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12489054" author="knutanders" created="Mon, 16 Apr 2007 10:31:06 +0100"  >&lt;p&gt;Thanks a lot for testing the patch, Kristian! It&apos;s nice to know that it works outside my sandbox too. And I agree that it would be great if someone reviewed the code as well! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Thanks.&lt;/p&gt;</comment>
                            <comment id="12494020" author="knutanders" created="Mon, 7 May 2007 12:30:33 +0100"  >&lt;p&gt;Committed revision 535851.&lt;/p&gt;</comment>
                            <comment id="12494822" author="djd" created="Thu, 10 May 2007 20:35:33 +0100"  >&lt;p&gt;Since a commit:&lt;br/&gt;
 &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2327&quot; title=&quot;Reduce monitor contention in LockSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2327&quot;&gt;&lt;del&gt;DERBY-2327&lt;/del&gt;&lt;/a&gt;: Reduce monitor contention in LockSet Added a new LockSet implementation which uses the classes in java.util.concurrent to achieve more concurrency.&quot;&lt;/p&gt;

&lt;p&gt;I see these build issues.&lt;/p&gt;

&lt;p&gt;/home/djd/cruise/cruisecontrol-bin-2.6.1/projects/derby_build/trunk/java/engine/org/apache/derby/impl/services/locks/ConcurrentLockSet.java:83: generics are not supported in -source 1.4&lt;/p&gt;

&lt;p&gt;(try -source 1.5 to enable generics)&lt;/p&gt;

&lt;p&gt;private final ConcurrentHashMap&amp;lt;Lockable, Entry&amp;gt; locks;&lt;/p&gt;

&lt;p&gt;^&lt;/p&gt;

&lt;p&gt;/home/djd/cruise/cruisecontrol-bin-2.6.1/projects/derby_build/trunk/java/engine/org/apache/derby/impl/services/locks/ConcurrentLockSet.java:278: for-each loops are not supported in -source 1.4&lt;/p&gt;

&lt;p&gt;(try -source 1.5 to enable for-each loops)&lt;/p&gt;

&lt;p&gt;for (Entry e : seenByDeadlockDetection) {&lt;/p&gt;</comment>
                            <comment id="12494992" author="knutanders" created="Fri, 11 May 2007 09:08:32 +0100"  >&lt;p&gt;Dan, I&apos;m not able to reproduce the build failure. Could you please provide more details? For instance,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;which version of ant are you using?&lt;/li&gt;
	&lt;li&gt;which build target is failing? (the file is supposed to be compiled by compile_impl_services_jdk15, which does set source level and target level to 1.5)&lt;/li&gt;
	&lt;li&gt;do you see the build failure if you comment out the jdk16 setting in ant.properties?&lt;/li&gt;
	&lt;li&gt;which flags does ant -verbose report that it invokes javac with when it fails?&lt;/li&gt;
	&lt;li&gt;from the error messages it seems like you use IBM&apos;s SDK. Do you see the same failure if jdk16 points to Sun&apos;s JDK6? IBM&apos;s SDK for Java 6 is still early access; have you upgraded to the latest snapshot?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12498522" author="knutanders" created="Thu, 24 May 2007 08:30:33 +0100"  >&lt;p&gt;Re-closing the issue due to lack of feedback. If there still is a build problem, please open a new JIRA issue and provide more details.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12325504">DERBY-698</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12354041" name="2cpu-join.png" size="5093" author="knutanders" created="Fri, 23 Mar 2007 09:17:31 +0000"/>
                            <attachment id="12354038" name="2cpu-select.png" size="4800" author="knutanders" created="Fri, 23 Mar 2007 09:10:37 +0000"/>
                            <attachment id="12354042" name="8cpu-join.png" size="5306" author="knutanders" created="Fri, 23 Mar 2007 09:17:31 +0000"/>
                            <attachment id="12354039" name="8cpu-select.png" size="5397" author="knutanders" created="Fri, 23 Mar 2007 09:10:37 +0000"/>
                            <attachment id="12351046" name="ConcurrentHashMap.diff" size="13453" author="knutanders" created="Tue, 13 Feb 2007 15:40:48 +0000"/>
                            <attachment id="12352652" name="derby-2327-1a.diff" size="25302" author="knutanders" created="Mon, 5 Mar 2007 19:10:10 +0000"/>
                            <attachment id="12352653" name="derby-2327-1a.stat" size="561" author="knutanders" created="Mon, 5 Mar 2007 19:10:10 +0000"/>
                            <attachment id="12353115" name="derby-2327-2a.diff" size="15279" author="knutanders" created="Mon, 12 Mar 2007 14:50:09 +0000"/>
                            <attachment id="12353116" name="derby-2327-2a.stat" size="146" author="knutanders" created="Mon, 12 Mar 2007 14:50:09 +0000"/>
                            <attachment id="12353190" name="derby-2327-3a.diff" size="1307" author="knutanders" created="Tue, 13 Mar 2007 13:11:41 +0000"/>
                            <attachment id="12354032" name="derby-2327-4a.diff" size="33471" author="knutanders" created="Fri, 23 Mar 2007 08:40:35 +0000"/>
                            <attachment id="12354033" name="derby-2327-4a.stat" size="369" author="knutanders" created="Fri, 23 Mar 2007 08:40:35 +0000"/>
                            <attachment id="12354043" name="niagara-join.png" size="5052" author="knutanders" created="Fri, 23 Mar 2007 09:17:31 +0000"/>
                            <attachment id="12354040" name="niagara-select.png" size="5196" author="knutanders" created="Fri, 23 Mar 2007 09:10:37 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>14.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 13 Feb 2007 15:21:22 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30382</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0wnr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39109</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>