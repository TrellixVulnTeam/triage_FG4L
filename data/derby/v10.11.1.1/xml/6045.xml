<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:34:59 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-6045/DERBY-6045.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-6045] in list multi-probe by primary key not chosen on tables with &gt;256 rows</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6045</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I have a table with a long integer primary key field and 11 million rows. I seem to be unable to load large chunks of rows via id in a reasonably efficient manner.&lt;/p&gt;

&lt;p&gt;  1. If I do individual lookups via the primary key, then a fast indexed lookup occurs. However, if I do large numbers of such queries, then the time is overwhelmed by round-trip overhead which makes everything incredibly slow.&lt;/p&gt;

&lt;p&gt;  2. If I use a single query with a disjunction of the primary keys of interest,  then a table scan is performed (even if the clause only contains 1-3 items), which walks over 11 million rows...incredibly inefficient.&lt;/p&gt;

&lt;p&gt;  3. If I use an IN clause, then a table scan is performed (even if the clause only contains 1-3 items), which walks over 11 million rows...incredibly inefficient.&lt;/p&gt;

&lt;p&gt;I&apos;m guessing that this might have something to do with the fact that I&apos;m using large integers and really big numbers that don&apos;t start anywhere at or about 1 for my keys. Could this possibly be confusing the optimizer?&lt;/p&gt;

&lt;p&gt;Here are the unlimited query plans for the 3 cases that I enumerated:&lt;br/&gt;
*********************************************************************************************&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;EL Fine&amp;#93;&lt;/span&gt;: 2013-01-17 11:09:53.384-&lt;del&gt;ServerSession(582235416)&lt;/del&gt;&lt;del&gt;Connection(1430986883)&lt;/del&gt;&lt;del&gt;Thread(Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;Initial Lisp Listener&amp;quot;,5,SubL Thread Group&amp;#93;&lt;/span&gt;)&lt;/del&gt;-SELECT TERM_ID, ARG0, ARG1, ARG2, ARG3, FORMULA_HASH, FORMULA_LENGTH, FORMULA_TYPE, KB_STATUS FROM KB.FORMULA_TERM WHERE (TERM_ID = ?)&lt;br/&gt;
	bind =&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;2251799814033500&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Thu Jan 17 11:09:53 CST 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;Initial Lisp Listener&amp;quot;,5,SubL Thread Group&amp;#93;&lt;/span&gt; (XID = 4711079), (SESSIONID = 3), SELECT TERM_ID, ARG0, ARG1, ARG2, ARG3, FORMULA_HASH, FORMULA_LENGTH, FORMULA_TYPE, KB_STATUS FROM KB.FORMULA_TERM WHERE (TERM_ID = ?) ******* Project-Restrict ResultSet (3):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 1&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 1.00&lt;br/&gt;
	optimizer estimated cost: 6.59&lt;br/&gt;
Source result set:&lt;br/&gt;
	Index Row to Base Row ResultSet for FORMULA_TERM:&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 1&lt;br/&gt;
	Columns accessed from heap = &lt;/p&gt;
{1, 2, 3, 4, 5, 6, 7, 8}
&lt;p&gt;		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 1.00&lt;br/&gt;
		optimizer estimated cost: 6.59&lt;br/&gt;
		Index Scan ResultSet for FORMULA_TERM using constraint KB_FORMULA_TERM_TERM_ID_PK at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 1&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 1&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;		scan information:&lt;br/&gt;
			Bit set of columns fetched=All&lt;br/&gt;
			Number of columns fetched=2&lt;br/&gt;
			Number of deleted rows visited=0&lt;br/&gt;
			Number of pages visited=3&lt;br/&gt;
			Number of rows qualified=1&lt;br/&gt;
			Number of rows visited=1&lt;br/&gt;
			Scan type=btree&lt;br/&gt;
			Tree height=-1&lt;br/&gt;
			start position:&lt;br/&gt;
				&amp;gt;= on first 1 column(s).&lt;br/&gt;
				Ordered null semantics on the following columns: &lt;br/&gt;
			stop position:&lt;br/&gt;
				&amp;gt; on first 1 column(s).&lt;br/&gt;
				Ordered null semantics on the following columns: &lt;br/&gt;
			qualifiers:&lt;br/&gt;
				None&lt;br/&gt;
			optimizer estimated row count: 1.00&lt;br/&gt;
			optimizer estimated cost: 6.59&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;EL Fine&amp;#93;&lt;/span&gt;: 2013-01-17 11:01:00.732-&lt;del&gt;ServerSession(1237006689)&lt;/del&gt;&lt;del&gt;Connection(927179828)&lt;/del&gt;&lt;del&gt;Thread(Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;Initial Lisp Listener&amp;quot;,5,SubL Thread Group&amp;#93;&lt;/span&gt;)&lt;/del&gt;-SELECT TERM_ID, ARG0, ARG1, ARG2, ARG3, FORMULA_HASH, FORMULA_LENGTH, FORMULA_TYPE, KB_STATUS FROM KB.FORMULA_TERM WHERE (((TERM_ID = ?) OR (TERM_ID = ?)) OR (TERM_ID = ?))&lt;br/&gt;
	bind =&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;2251799814033500, 2251799814033501, 2251799814033499&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Thu Jan 17 11:01:10 CST 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;Initial Lisp Listener&amp;quot;,5,SubL Thread Group&amp;#93;&lt;/span&gt; (XID = 4711078), (SESSIONID = 3), SELECT TERM_ID, ARG0, ARG1, ARG2, ARG3, FORMULA_HASH, FORMULA_LENGTH, FORMULA_TYPE, KB_STATUS FROM KB.FORMULA_TERM WHERE (((TERM_ID = ?) OR (TERM_ID = ?)) OR (TERM_ID = ?)) ******* Project-Restrict ResultSet (3):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 3&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 1176730.30&lt;br/&gt;
	optimizer estimated cost: 5931065.54&lt;br/&gt;
Source result set:&lt;br/&gt;
	Project-Restrict ResultSet (2):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 11767298&lt;br/&gt;
	Rows filtered = 11767295&lt;br/&gt;
	restriction = true&lt;br/&gt;
	projection = false&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 1176730.30&lt;br/&gt;
		optimizer estimated cost: 5931065.54&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Table Scan ResultSet for FORMULA_TERM at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 11767298&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 16&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;		scan information:&lt;br/&gt;
			Bit set of columns fetched=All&lt;br/&gt;
			Number of columns fetched=9&lt;br/&gt;
			Number of pages visited=34358&lt;br/&gt;
			Number of rows qualified=11767298&lt;br/&gt;
			Number of rows visited=11767298&lt;br/&gt;
			Scan type=heap&lt;br/&gt;
			start position:&lt;br/&gt;
				null&lt;br/&gt;
			stop position:&lt;br/&gt;
				null&lt;br/&gt;
			qualifiers:&lt;br/&gt;
				None&lt;br/&gt;
			optimizer estimated row count: 1176730.30&lt;br/&gt;
			optimizer estimated cost: 5931065.54&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;EL Fine&amp;#93;&lt;/span&gt;: 2013-01-17 11:27:00.627-&lt;del&gt;ServerSession(1237006689)&lt;/del&gt;&lt;del&gt;Connection(1688096771)&lt;/del&gt;&lt;del&gt;Thread(Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;Initial Lisp Listener&amp;quot;,5,SubL Thread Group&amp;#93;&lt;/span&gt;)&lt;/del&gt;-SELECT TERM_ID, ARG0, ARG1, ARG2, ARG3, FORMULA_HASH, FORMULA_LENGTH, FORMULA_TYPE, KB_STATUS FROM KB.FORMULA_TERM WHERE (TERM_ID IN (?,?,?))&lt;br/&gt;
	bind =&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;2251799814033500, 2251799814033501, 2251799814033499&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Thu Jan 17 11:47:26 CST 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;Initial Lisp Listener&amp;quot;,5,SubL Thread Group&amp;#93;&lt;/span&gt; (XID = 4711080), (SESSIONID = 3), SELECT TERM_ID, ARG0, ARG1, ARG2, ARG3, FORMULA_HASH, FORMULA_LENGTH, FORMULA_TYPE, KB_STATUS FROM KB.FORMULA_TERM WHERE (TERM_ID IN (?,?,?)) ******* Project-Restrict ResultSet (3):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 3&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 1176730.30&lt;br/&gt;
	optimizer estimated cost: 5931065.54&lt;br/&gt;
Source result set:&lt;br/&gt;
	Project-Restrict ResultSet (2):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 11767298&lt;br/&gt;
	Rows filtered = 11767295&lt;br/&gt;
	restriction = true&lt;br/&gt;
	projection = false&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 1176730.30&lt;br/&gt;
		optimizer estimated cost: 5931065.54&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Table Scan ResultSet for FORMULA_TERM at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 11767298&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 16&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;		scan information:&lt;br/&gt;
			Bit set of columns fetched=All&lt;br/&gt;
			Number of columns fetched=9&lt;br/&gt;
			Number of pages visited=34358&lt;br/&gt;
			Number of rows qualified=11767298&lt;br/&gt;
			Number of rows visited=11767298&lt;br/&gt;
			Scan type=heap&lt;br/&gt;
			start position:&lt;br/&gt;
				null&lt;br/&gt;
			stop position:&lt;br/&gt;
				null&lt;br/&gt;
			qualifiers:&lt;br/&gt;
				None&lt;br/&gt;
			optimizer estimated row count: 1176730.30&lt;br/&gt;
			optimizer estimated cost: 5931065.54&lt;/p&gt;</description>
                <environment>Linux Debian 6.0.5</environment>
        <key id="12628077">DERBY-6045</key>
            <summary>in list multi-probe by primary key not chosen on tables with &gt;256 rows</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="apb">Tony Brusseau</reporter>
                        <labels>
                    </labels>
                <created>Thu, 17 Jan 2013 17:59:56 +0000</created>
                <updated>Wed, 21 Jan 2015 00:23:11 +0000</updated>
                            <resolved>Thu, 30 May 2013 19:01:19 +0100</resolved>
                                    <version>10.9.1.0</version>
                    <version>10.10.1.1</version>
                                    <fixVersion>10.8.3.3</fixVersion>
                    <fixVersion>10.9.2.2</fixVersion>
                    <fixVersion>10.10.2.0</fixVersion>
                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="13557475" author="apb" created="Fri, 18 Jan 2013 18:55:44 +0000"  >&lt;p&gt;I did some more testing and it looks like if I create a table with 128 rows, then b-tree searches are performed in every case. However, if I increase the table to 256 rows or larger, then I start getting heap searches that scan every row when querying for multiple rows via primary key. Here is some code that will generate the SQL for a table that demonstrates the problem:&lt;/p&gt;

&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;
    final Logger logger = Logger.getLogger(DerbyTester.class.toString());&lt;br/&gt;
    try {&lt;br/&gt;
      StringBuilder buf = new StringBuilder(1024*1024);&lt;br/&gt;
      buf.append(&quot;DROP TABLE VARIABLE_TERM;\n&quot;);&lt;br/&gt;
      buf.append(&quot;\n&quot;);&lt;br/&gt;
      buf.append(&quot;CREATE TABLE VARIABLE_TERM\n&quot;);&lt;br/&gt;
      buf.append(&quot;(\n&quot;);&lt;br/&gt;
      buf.append(&quot;        term_id                  BIGINT NOT NULL,\n&quot;);&lt;br/&gt;
      buf.append(&quot;        var_name              VARCHAR(1024) NOT NULL,\n&quot;);&lt;br/&gt;
      buf.append(&quot;        var_type                SMALLINT NOT NULL,     \n&quot;);&lt;br/&gt;
      buf.append(&quot;        kb_status              INTEGER NOT NULL        \n&quot;);&lt;br/&gt;
      buf.append(&quot;);\n&quot;);&lt;br/&gt;
      buf.append(&quot;\n&quot;);&lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_term_id_pk PRIMARY KEY (term_id);\n&quot;);&lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT variable_term_id_check CHECK ((TERM_ID &amp;gt;= 1688849860263936) AND (TERM_ID &amp;lt;= 1970324836974591));\n&quot;);&lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type);\n&quot;);&lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_var_type_enum_check CHECK ((var_type &amp;gt;= 0) AND (var_type &amp;lt;= 4));\n&quot;);&lt;br/&gt;
      buf.append(&quot;\n&quot;);&lt;br/&gt;
      int count = 256; // @note count should be at least 40&lt;br/&gt;
      long idStart = 1688849860263936L;&lt;br/&gt;
      for (int i = 0; i &amp;lt; count; i++) &lt;/p&gt;
{
        buf.append(&quot;INSERT INTO VARIABLE_TERM VALUES (&quot;).append(idStart++).append(&quot;, \&apos;?var&quot;).append(i).append(&quot;\&apos;, &quot;).append(((i %2) == 0) ? 1 : 4).append(&quot;, 1);\n&quot;);
      }
&lt;p&gt;      buf.append(&quot;\n&quot;);&lt;br/&gt;
      buf.append(&quot;SELECT * FROM VARIABLE_TERM WHERE TERM_ID = 1688849860263966;\n&quot;);&lt;br/&gt;
      buf.append(&quot;SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 1688849860263937) OR (TERM_ID =1688849860263975) OR (TERM_ID = 1688849860263960);\n&quot;);&lt;br/&gt;
      buf.append(&quot;SELECT * FROM VARIABLE_TERM WHERE (TERM_ID  IN (1688849860263937, 1688849860263975, 1688849860263960));\n&quot;);&lt;br/&gt;
       buf.append(&quot;\n&quot;);&lt;br/&gt;
       System.out.println(buf.toString());&lt;br/&gt;
       System.out.flush();&lt;br/&gt;
    } catch (Exception e) &lt;/p&gt;
{
      logger.log(Level.SEVERE, e.getMessage(), e);
    }
&lt;p&gt; finally &lt;/p&gt;
{
      System.exit(0);
    }
&lt;p&gt;  }&lt;/p&gt;</comment>
                            <comment id="13557551" author="mikem" created="Fri, 18 Jan 2013 20:07:44 +0000"  >&lt;p&gt;the bug description is confusing to me.  Is the following a valid statement of the 2 problem queries:&lt;/p&gt;

&lt;p&gt;1) in clause with 3 values on primary key on table with 11 million rows does not use index.&lt;br/&gt;
2) or with 2 equality constaints on primary key does not use index.&lt;/p&gt;

&lt;p&gt;I don&apos;t think the optmizer will do #2 as currently designed.  I thought the optmizer had been improved to do #1.  &lt;/p&gt;
</comment>
                            <comment id="13557552" author="mikem" created="Fri, 18 Jan 2013 20:09:20 +0000"  >&lt;p&gt;you might see if your test case is affected by adding an update statistics call after loading the data in the base table.  with unique indexes I would not think so, but &lt;br/&gt;
something wierd is going on so may lend some light.&lt;/p&gt;</comment>
                            <comment id="13557558" author="mikem" created="Fri, 18 Jan 2013 20:15:30 +0000"  >&lt;p&gt;since just doing a single select has more overhead than you want, does your real use case want a lot of values in the in list?  As a workarount you might try loading your search values into a temp table and doing a join for the result, and see if the optimizer will internally do the index probes that make sense.&lt;/p&gt;

&lt;p&gt;a union might be another workaround.&lt;/p&gt;</comment>
                            <comment id="13557562" author="mikem" created="Fri, 18 Jan 2013 20:18:24 +0000"  >&lt;p&gt;also for debugging would be good to understand if the problem is specific to BIGINT or not.  &lt;/p&gt;

&lt;p&gt;For in list optmization we use to just translate it to a index scan bounded by the min and max values in the list, which would be bad for your case.  I thought it had been changed to do multiple probes into the index.  &lt;/p&gt;</comment>
                            <comment id="13557579" author="mikem" created="Fri, 18 Jan 2013 20:36:30 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; is the orignal project that implemented the IN-LIST optimization that seems like it should be being applied in this case.&lt;/p&gt;</comment>
                            <comment id="13557637" author="apb" created="Fri, 18 Jan 2013 21:41:22 +0000"  >&lt;p&gt;*******************&lt;br/&gt;
&amp;gt;the bug description is confusing to me. Is the following a valid statement of the 2 problem queries:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;1) in clause with 3 values on primary key on table with 11 million rows does not use index.&lt;br/&gt;
&amp;gt;2) or with 2 equality constaints on primary key does not use index.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I don&apos;t think the optmizer will do #2 as currently designed. I thought the optmizer had been improved to do #1.&lt;/p&gt;

&lt;p&gt;The main problem is that both of these 2 queries do a complete table scan for me on tables with more than 256 entries:&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID  IN (1688849860263937, 1688849860263975, 1688849860263960));&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 1688849860263937) OR (TERM_ID =1688849860263975) OR (TERM_ID = 1688849860263960);&lt;/p&gt;

&lt;p&gt;If either one did a multiprobe, I&apos;d be happy although it is pretty clear that both of them should be doing multiprobes in this case. &lt;/p&gt;

&lt;p&gt;*******************&lt;br/&gt;
&amp;gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; is the original project that implemented the IN-LIST optimization that seems like it should be being applied in this case. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; sounds like it might be related, but that bug is resolved and I&apos;m able to do an IN query and it is still doing an entire table scan. Maybe this is a regression of that bug?&lt;/p&gt;

&lt;p&gt;*******************&lt;br/&gt;
&amp;gt;you might see if your test case is affected by adding an update statistics call after loading the data in the base table. with unique indexes I would not think so, but&lt;br/&gt;
&amp;gt;something wierd is going on so may lend some light. &lt;/p&gt;

&lt;p&gt;I&apos;ll try that out, but none of my queries use the unique index columns in the WHERE, so this doesn&apos;t sound very likely and the FormulaTerm table that I&apos;m able to do this on, doesn&apos;t have a unique index defined for it.&lt;/p&gt;

&lt;p&gt;*******************&lt;br/&gt;
&amp;gt; also for debugging would be good to understand if the problem is specific to BIGINT or not.&lt;/p&gt;

&lt;p&gt;I&apos;ll try it with regular ints.&lt;/p&gt;

&lt;p&gt;*******************&lt;br/&gt;
&amp;gt; since just doing a single select has more overhead than you want, does your real use case want a lot of values in the in list? As a workarount you might try loading your &lt;br/&gt;
&amp;gt; search values into a temp table and doing a join for the result, and see if the optimizer will internally do the index probes that make sense.&lt;/p&gt;

&lt;p&gt;Hmm, can you give me an example on how to do this? The common case is that I&apos;ll have 10&apos;s to 100&apos;s of rows  to look up by id at once in tables with &amp;gt; 10 million rows.&lt;/p&gt;

&lt;p&gt;*******************&lt;br/&gt;
&amp;gt; a union might be another workaround. &lt;/p&gt;

&lt;p&gt;I&apos;m using JPA which doesn&apos;t support UNIONs.&lt;/p&gt;

</comment>
                            <comment id="13557660" author="apb" created="Fri, 18 Jan 2013 22:00:46 +0000"  >&lt;p&gt;CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;APP&apos;, &apos;VARIABLE_TERM&apos;, null);&lt;br/&gt;
had no effect.&lt;/p&gt;</comment>
                            <comment id="13557677" author="mikem" created="Fri, 18 Jan 2013 22:14:21 +0000"  >&lt;p&gt;if regular ints work, it might be a casting issue.  Not necessarily a problem with BIGINT itself, but somehow derby having the wrong type for the constant in the &lt;br/&gt;
query.&lt;/p&gt;</comment>
                            <comment id="13557684" author="mikem" created="Fri, 18 Jan 2013 22:21:50 +0000"  >&lt;p&gt;at the high level for join workaround i am suggesting - syntax is problably not exact&lt;/p&gt;

&lt;p&gt;// table with 11 milion rows&lt;br/&gt;
create table a (primary key a int, data int)&lt;/p&gt;

&lt;p&gt;instead of &lt;br/&gt;
select * from a where a IN (num1, num2, num3)&lt;/p&gt;

&lt;p&gt;do&lt;br/&gt;
create table temp (a int)&lt;br/&gt;
insert values num1, num2, and num2 3 into temp&lt;/p&gt;

&lt;p&gt;and then&lt;br/&gt;
select * from a where a.a = temp.a&lt;/p&gt;


&lt;p&gt;if that works then you can optimize by using user temp tables.&lt;br/&gt;
And also you may be able to optimize by building a user defined table that just materializes the rows from an in memory array and avoid inserts, but &lt;br/&gt;
the optimizer support of user defined tables is still evolving so not sure if it would pick right plan. &lt;/p&gt;</comment>
                            <comment id="13557713" author="apb" created="Fri, 18 Jan 2013 22:53:29 +0000"  >&lt;p&gt;I just tried it with regular integers, starting from 1 and the only indexing being the primary key. Still get the same issue. If I make a table with 64 rows, then it does fast b-tree scans using the IN query. If the table has 256 or more rows, it does slow heap scans over every row in the table when using the IN query. It looks like maybe there is a logic-po in the code. Doing full table scans over small tables might be faster than multi-probing, but instead it is doing it on large tables. This is just a wild guess.&lt;/p&gt;

&lt;p&gt;Here is the SQL:&lt;/p&gt;

&lt;p&gt;DROP TABLE VARIABLE_TERM;&lt;/p&gt;

&lt;p&gt;CREATE TABLE VARIABLE_TERM&lt;br/&gt;
(&lt;br/&gt;
        term_id                  INTEGER NOT NULL,&lt;br/&gt;
        var_name              VARCHAR(1024) NOT NULL,&lt;br/&gt;
        var_type                SMALLINT NOT NULL,     &lt;br/&gt;
        kb_status              INTEGER NOT NULL        &lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_term_id_pk PRIMARY KEY (term_id);&lt;/p&gt;

&lt;p&gt;INSERT INTO VARIABLE_TERM VALUES (1, &apos;?var0&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (2, &apos;?var1&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (3, &apos;?var2&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (4, &apos;?var3&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (5, &apos;?var4&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (6, &apos;?var5&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (7, &apos;?var6&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (8, &apos;?var7&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (9, &apos;?var8&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (10, &apos;?var9&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (11, &apos;?var10&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (12, &apos;?var11&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (13, &apos;?var12&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (14, &apos;?var13&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (15, &apos;?var14&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (16, &apos;?var15&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (17, &apos;?var16&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (18, &apos;?var17&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (19, &apos;?var18&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (20, &apos;?var19&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (21, &apos;?var20&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (22, &apos;?var21&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (23, &apos;?var22&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (24, &apos;?var23&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (25, &apos;?var24&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (26, &apos;?var25&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (27, &apos;?var26&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (28, &apos;?var27&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (29, &apos;?var28&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (30, &apos;?var29&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (31, &apos;?var30&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (32, &apos;?var31&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (33, &apos;?var32&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (34, &apos;?var33&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (35, &apos;?var34&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (36, &apos;?var35&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (37, &apos;?var36&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (38, &apos;?var37&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (39, &apos;?var38&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (40, &apos;?var39&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (41, &apos;?var40&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (42, &apos;?var41&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (43, &apos;?var42&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (44, &apos;?var43&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (45, &apos;?var44&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (46, &apos;?var45&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (47, &apos;?var46&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (48, &apos;?var47&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (49, &apos;?var48&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (50, &apos;?var49&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (51, &apos;?var50&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (52, &apos;?var51&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (53, &apos;?var52&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (54, &apos;?var53&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (55, &apos;?var54&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (56, &apos;?var55&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (57, &apos;?var56&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (58, &apos;?var57&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (59, &apos;?var58&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (60, &apos;?var59&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (61, &apos;?var60&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (62, &apos;?var61&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (63, &apos;?var62&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (64, &apos;?var63&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (65, &apos;?var64&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (66, &apos;?var65&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (67, &apos;?var66&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (68, &apos;?var67&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (69, &apos;?var68&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (70, &apos;?var69&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (71, &apos;?var70&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (72, &apos;?var71&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (73, &apos;?var72&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (74, &apos;?var73&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (75, &apos;?var74&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (76, &apos;?var75&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (77, &apos;?var76&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (78, &apos;?var77&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (79, &apos;?var78&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (80, &apos;?var79&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (81, &apos;?var80&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (82, &apos;?var81&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (83, &apos;?var82&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (84, &apos;?var83&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (85, &apos;?var84&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (86, &apos;?var85&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (87, &apos;?var86&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (88, &apos;?var87&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (89, &apos;?var88&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (90, &apos;?var89&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (91, &apos;?var90&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (92, &apos;?var91&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (93, &apos;?var92&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (94, &apos;?var93&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (95, &apos;?var94&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (96, &apos;?var95&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (97, &apos;?var96&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (98, &apos;?var97&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (99, &apos;?var98&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (100, &apos;?var99&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (101, &apos;?var100&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (102, &apos;?var101&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (103, &apos;?var102&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (104, &apos;?var103&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (105, &apos;?var104&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (106, &apos;?var105&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (107, &apos;?var106&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (108, &apos;?var107&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (109, &apos;?var108&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (110, &apos;?var109&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (111, &apos;?var110&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (112, &apos;?var111&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (113, &apos;?var112&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (114, &apos;?var113&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (115, &apos;?var114&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (116, &apos;?var115&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (117, &apos;?var116&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (118, &apos;?var117&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (119, &apos;?var118&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (120, &apos;?var119&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (121, &apos;?var120&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (122, &apos;?var121&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (123, &apos;?var122&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (124, &apos;?var123&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (125, &apos;?var124&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (126, &apos;?var125&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (127, &apos;?var126&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (128, &apos;?var127&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (129, &apos;?var128&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (130, &apos;?var129&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (131, &apos;?var130&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (132, &apos;?var131&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (133, &apos;?var132&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (134, &apos;?var133&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (135, &apos;?var134&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (136, &apos;?var135&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (137, &apos;?var136&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (138, &apos;?var137&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (139, &apos;?var138&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (140, &apos;?var139&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (141, &apos;?var140&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (142, &apos;?var141&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (143, &apos;?var142&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (144, &apos;?var143&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (145, &apos;?var144&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (146, &apos;?var145&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (147, &apos;?var146&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (148, &apos;?var147&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (149, &apos;?var148&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (150, &apos;?var149&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (151, &apos;?var150&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (152, &apos;?var151&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (153, &apos;?var152&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (154, &apos;?var153&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (155, &apos;?var154&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (156, &apos;?var155&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (157, &apos;?var156&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (158, &apos;?var157&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (159, &apos;?var158&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (160, &apos;?var159&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (161, &apos;?var160&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (162, &apos;?var161&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (163, &apos;?var162&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (164, &apos;?var163&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (165, &apos;?var164&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (166, &apos;?var165&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (167, &apos;?var166&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (168, &apos;?var167&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (169, &apos;?var168&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (170, &apos;?var169&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (171, &apos;?var170&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (172, &apos;?var171&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (173, &apos;?var172&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (174, &apos;?var173&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (175, &apos;?var174&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (176, &apos;?var175&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (177, &apos;?var176&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (178, &apos;?var177&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (179, &apos;?var178&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (180, &apos;?var179&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (181, &apos;?var180&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (182, &apos;?var181&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (183, &apos;?var182&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (184, &apos;?var183&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (185, &apos;?var184&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (186, &apos;?var185&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (187, &apos;?var186&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (188, &apos;?var187&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (189, &apos;?var188&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (190, &apos;?var189&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (191, &apos;?var190&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (192, &apos;?var191&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (193, &apos;?var192&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (194, &apos;?var193&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (195, &apos;?var194&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (196, &apos;?var195&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (197, &apos;?var196&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (198, &apos;?var197&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (199, &apos;?var198&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (200, &apos;?var199&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (201, &apos;?var200&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (202, &apos;?var201&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (203, &apos;?var202&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (204, &apos;?var203&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (205, &apos;?var204&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (206, &apos;?var205&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (207, &apos;?var206&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (208, &apos;?var207&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (209, &apos;?var208&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (210, &apos;?var209&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (211, &apos;?var210&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (212, &apos;?var211&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (213, &apos;?var212&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (214, &apos;?var213&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (215, &apos;?var214&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (216, &apos;?var215&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (217, &apos;?var216&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (218, &apos;?var217&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (219, &apos;?var218&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (220, &apos;?var219&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (221, &apos;?var220&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (222, &apos;?var221&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (223, &apos;?var222&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (224, &apos;?var223&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (225, &apos;?var224&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (226, &apos;?var225&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (227, &apos;?var226&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (228, &apos;?var227&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (229, &apos;?var228&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (230, &apos;?var229&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (231, &apos;?var230&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (232, &apos;?var231&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (233, &apos;?var232&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (234, &apos;?var233&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (235, &apos;?var234&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (236, &apos;?var235&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (237, &apos;?var236&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (238, &apos;?var237&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (239, &apos;?var238&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (240, &apos;?var239&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (241, &apos;?var240&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (242, &apos;?var241&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (243, &apos;?var242&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (244, &apos;?var243&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (245, &apos;?var244&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (246, &apos;?var245&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (247, &apos;?var246&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (248, &apos;?var247&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (249, &apos;?var248&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (250, &apos;?var249&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (251, &apos;?var250&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (252, &apos;?var251&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (253, &apos;?var252&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (254, &apos;?var253&apos;, 4, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (255, &apos;?var254&apos;, 1, 1);&lt;br/&gt;
INSERT INTO VARIABLE_TERM VALUES (256, &apos;?var255&apos;, 4, 1);&lt;/p&gt;

&lt;p&gt;CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;APP&apos;, &apos;VARIABLE_TERM&apos;, null);&lt;/p&gt;

&lt;p&gt;SELECT * FROM VARIABLE_TERM WHERE TERM_ID = 11;&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 11) OR (TERM_ID =21) OR (TERM_ID = 31);&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID  IN (11, 21, 31));&lt;/p&gt;</comment>
                            <comment id="13562907" author="mamtas" created="Fri, 25 Jan 2013 18:58:21 +0000"  >&lt;p&gt;On the trunk, I tried experimenting with Tony&apos;s table with primary key as shown below&lt;br/&gt;
CREATE TABLE VARIABLE_TERM&lt;br/&gt;
(&lt;br/&gt;
        term_id INTEGER NOT NULL,&lt;br/&gt;
        var_name VARCHAR(1024) NOT NULL,&lt;br/&gt;
        var_type SMALLINT NOT NULL, &lt;br/&gt;
        kb_status INTEGER NOT NULL &lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_term_id_pk PRIMARY KEY (term_id);&lt;/p&gt;

&lt;p&gt;The following queries show different query plan(as pointed by Tony) depending on the number of rows in the variable_term table.&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 11) OR (TERM_ID =21) OR (TERM_ID = 31);&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID IN (11, 21, 31)); &lt;/p&gt;

&lt;p&gt;The queries above used index scan with KB_VARIABLE_TERM_TERM_ID_PK  when there were 10 rows in the table. But if I had even 25 rows, they started using table scan. &lt;/p&gt;

&lt;p&gt;The following query always used index scan with 10/25/64 rows&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE TERM_ID = 11;&lt;/p&gt;</comment>
                            <comment id="13564390" author="apb" created="Mon, 28 Jan 2013 16:36:43 +0000"  >&lt;p&gt;Thanks for confirming that Mamta. I get exactly the same behavior except for the breakpoints at which things switch from multiprobe to table scan which I believe is due to relative page size differences. My DB used 32k pages and the default is 4k (a factor of 8 difference). If you take your breakpoint of 25 and multiply by 8 you get 200 which is roughly around the breakpoint that I&apos;m seeing.&lt;/p&gt;</comment>
                            <comment id="13571092" author="mamtas" created="Tue, 5 Feb 2013 06:45:40 +0000"  >&lt;p&gt;BTW, I tried the little experiment I tried on the trunk(on 25/Jan/13) on 10.9.1.0 release and saw the same behavior as trunk. But on 10.8.1.1 and 10.8.1.2, I saw that even after 25 rows, we still use index scan rather than switching to table scan. So something has changed between 10.8 and 10.9 release apparently which has changed the behavior.&lt;/p&gt;</comment>
                            <comment id="13571551" author="mamtas" created="Tue, 5 Feb 2013 18:30:07 +0000"  >&lt;p&gt;The test scenario from comment on 25/Jan/13 show incorrect table scan usage on trunk and 10.9 releases. The same test behaves correctly (ie uses index scan) on all 3 releases of 10.8 codeline - 10.8.1.1, 10.8.1.2 and 10.8.3.0, The top of the 10.8 codeline also works correctly. So something has changed between 10.8 and 10.9 release apparently which has changed the behavior. &lt;/p&gt;</comment>
                            <comment id="13571580" author="apb" created="Tue, 5 Feb 2013 18:53:10 +0000"  >&lt;p&gt;I have another similar case that I believe might be related. If I have a disjunction in a delete statement it appears to use table scans:&lt;/p&gt;

&lt;p&gt;This takes 10.5 min on a very small DB to run the following command 17,200 times:&lt;br/&gt;
DELETE FROM kb.mt_gaf_top_level_term_counts WHERE (term = ?) OR (mt = ?)&lt;/p&gt;

&lt;p&gt;However, if I break the delete statement into 2 separate calls, then the total time is only 17 secs:&lt;br/&gt;
DELETE FROM kb.mt_gaf_top_level_term_counts WHERE (term = ?) &lt;br/&gt;
DELETE FROM kb.mt_gaf_top_level_term_counts WHERE (mt = ?) &lt;/p&gt;

&lt;p&gt;The table has about 10k rows.&lt;/p&gt;

&lt;p&gt;Table looks like:&lt;br/&gt;
DROP TABLE KB.MT_GAF_TOP_LEVEL_TERM_COUNTS;&lt;/p&gt;

&lt;p&gt;CREATE TABLE KB.MT_GAF_TOP_LEVEL_TERM_COUNTS&lt;br/&gt;
(&lt;br/&gt;
        mt BIGINT NOT NULL, &lt;br/&gt;
        term BIGINT NOT NULL,&lt;br/&gt;
        term_index INTEGER NOT NULL,&lt;br/&gt;
        usage_count BIGINT NOT NULL&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;ALTER TABLE kb.mt_gaf_top_level_term_counts ADD CONSTRAINT kb_mt_gaf_top_level_term_counts_pk PRIMARY KEY (mt, term, term_index);&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_mt_index ON kb.mt_gaf_top_level_term_counts(mt);&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_term_index ON kb.mt_gaf_top_level_term_counts(term);&lt;/p&gt;</comment>
                            <comment id="13574910" author="mamtas" created="Fri, 8 Feb 2013 22:47:47 +0000"  >&lt;p&gt;I went through various checkins that went into 10.9 and found the checkin that has caused the regression to be r1341481. This checkin was made for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3790&quot; title=&quot;Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3790&quot;&gt;&lt;del&gt;DERBY-3790&lt;/del&gt;&lt;/a&gt;(Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column). When I try the test scenario from comment on 25/Jan/13 on codeline synced upto r1341481, I see us using table scans but if I sync up the client to the immediate earlier checkin 1341350, I see us using index scan. I will work on writing a junit test for test scenario that I have been trying.&lt;/p&gt;</comment>
                            <comment id="13574915" author="mamtas" created="Fri, 8 Feb 2013 22:49:46 +0000"  >&lt;p&gt;Checkin for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3790&quot; title=&quot;Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3790&quot;&gt;&lt;del&gt;DERBY-3790&lt;/del&gt;&lt;/a&gt; may have caused the regression tracked under &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13574996" author="mikem" created="Sat, 9 Feb 2013 00:34:25 +0000"  >&lt;p&gt;since &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; has to do with background statistics, it would be good to see if the problem existed in releases before automatic statistics.&lt;/p&gt;

&lt;p&gt;Also might be interesting to run test with automatic statistics disabled, in current system.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; was about not creating cardinality stats for unique one key indexes, which really should not be useful to the optimizer.  Could see&lt;br/&gt;
if running update statistics by hand before the query helps or not?&lt;/p&gt;

&lt;p&gt;Should see if the system did the right thing pre-auto statistics&lt;br/&gt;
if table is first created with index and then loaded (so should mean no statistics),&lt;/p&gt;</comment>
                            <comment id="13576356" author="mamtas" created="Tue, 12 Feb 2013 03:58:11 +0000"  >&lt;p&gt;I have aded a junit test which won&apos;t run at this point since it starts with name xtest... rather than test... Once this jira is fixed, we should enable the test. The revision number for the checkin is 1445030 and the commit comments are &lt;br/&gt;
********************&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; (in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows)&lt;/p&gt;

&lt;p&gt;Adding a junit test but it will not run since the the fixture name is not starting with &quot;test&quot;... We should remove the x in front of test fixture&apos;s name once &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; has been fixed&lt;br/&gt;
********************&lt;/p&gt;</comment>
                            <comment id="13578175" author="mamtas" created="Thu, 14 Feb 2013 05:50:48 +0000"  >&lt;p&gt;Made some changes to the junit test and committed it into trunk with revision 1446048 with following commit comments&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;
					&lt;ul&gt;
						&lt;li&gt;
						&lt;ul&gt;
							&lt;li&gt;
							&lt;ul&gt;
								&lt;li&gt;
								&lt;ul&gt;
									&lt;li&gt;
									&lt;ul&gt;
										&lt;li&gt;
										&lt;ul&gt;
											&lt;li&gt;
											&lt;ul&gt;
												&lt;li&gt;
												&lt;ul&gt;
													&lt;li&gt;
													&lt;ul&gt;
														&lt;li&gt;
														&lt;ul&gt;
															&lt;li&gt;
															&lt;ul&gt;
																&lt;li&gt;
																&lt;ul&gt;
																	&lt;li&gt;
																	&lt;ul&gt;
																		&lt;li&gt;
																		&lt;ul&gt;
																			&lt;li&gt;
																			&lt;ul&gt;
																				&lt;li&gt;&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; (in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows)&lt;/li&gt;
																			&lt;/ul&gt;
																			&lt;/li&gt;
																		&lt;/ul&gt;
																		&lt;/li&gt;
																	&lt;/ul&gt;
																	&lt;/li&gt;
																&lt;/ul&gt;
																&lt;/li&gt;
															&lt;/ul&gt;
															&lt;/li&gt;
														&lt;/ul&gt;
														&lt;/li&gt;
													&lt;/ul&gt;
													&lt;/li&gt;
												&lt;/ul&gt;
												&lt;/li&gt;
											&lt;/ul&gt;
											&lt;/li&gt;
										&lt;/ul&gt;
										&lt;/li&gt;
									&lt;/ul&gt;
									&lt;/li&gt;
								&lt;/ul&gt;
								&lt;/li&gt;
							&lt;/ul&gt;
							&lt;/li&gt;
						&lt;/ul&gt;
						&lt;/li&gt;
					&lt;/ul&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Added a new test scenario where we add about 10K rows into a table with primary key and check if we are still using index scan for the queries being tested&lt;/p&gt;

&lt;p&gt;Additionally, cleaned up the test a little bit.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;
					&lt;ul&gt;
						&lt;li&gt;
						&lt;ul&gt;
							&lt;li&gt;
							&lt;ul&gt;
								&lt;li&gt;
								&lt;ul&gt;
									&lt;li&gt;
									&lt;ul&gt;
										&lt;li&gt;
										&lt;ul&gt;
											&lt;li&gt;
											&lt;ul&gt;
												&lt;li&gt;
												&lt;ul&gt;
													&lt;li&gt;
													&lt;ul&gt;
														&lt;li&gt;
														&lt;ul&gt;
															&lt;li&gt;
															&lt;ul&gt;
																&lt;li&gt;
																&lt;ul&gt;
																	&lt;li&gt;
																	&lt;ul&gt;
																		&lt;li&gt;
																		&lt;ul&gt;
																			&lt;li&gt;
																			&lt;ul&gt;
																				&lt;li&gt;&lt;/li&gt;
																			&lt;/ul&gt;
																			&lt;/li&gt;
																		&lt;/ul&gt;
																		&lt;/li&gt;
																	&lt;/ul&gt;
																	&lt;/li&gt;
																&lt;/ul&gt;
																&lt;/li&gt;
															&lt;/ul&gt;
															&lt;/li&gt;
														&lt;/ul&gt;
														&lt;/li&gt;
													&lt;/ul&gt;
													&lt;/li&gt;
												&lt;/ul&gt;
												&lt;/li&gt;
											&lt;/ul&gt;
											&lt;/li&gt;
										&lt;/ul&gt;
										&lt;/li&gt;
									&lt;/ul&gt;
									&lt;/li&gt;
								&lt;/ul&gt;
								&lt;/li&gt;
							&lt;/ul&gt;
							&lt;/li&gt;
						&lt;/ul&gt;
						&lt;/li&gt;
					&lt;/ul&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13578183" author="mamtas" created="Thu, 14 Feb 2013 06:17:58 +0000"  >&lt;p&gt;I ran the new junit test org.apache.derbyTesting.functionTests.tests.lang.InListMultiProbeTest:xtestDerby6045 on my clients for trunk and all the codelines upto 10.3 release. I find that the test fails on trunk and 10.9 but passes on 10.8 through 10.3 codelines.&lt;/p&gt;

&lt;p&gt;What I found though is that in 10.8 through 10.3 codelines, if I do not have &lt;br/&gt;
        s.execute(&quot;call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;APP&apos;, &apos;VARIABLE_TERM&apos;, null)&quot;);&lt;br/&gt;
(actually 10.4 and 10.3 codelines do not have update statistics procedure. On those 2 codelines, I used compress table procedure to re-generate the statistics, s.execute(&quot;call syscs_util.syscs_compress_table(&apos;APP&apos;,&apos;VARIABLE_TERM&apos;,1)&quot;)&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
after inserting total of 24 rows in the table, then we do not pick up index scan. &lt;/p&gt;

&lt;p&gt;I am copying following from the junit test for reference&lt;br/&gt;
        //Add 14 more rows&lt;br/&gt;
        for (int i=11; i&amp;lt;=25; i++) &lt;/p&gt;
{
            ps.setInt(1, i);
            ps.executeUpdate();
        }
&lt;p&gt;        s.execute(&quot;call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;APP&apos;, &apos;VARIABLE_TERM&apos;, null)&quot;);&lt;br/&gt;
        //Need to execute the query with an extra white space so that the&lt;br/&gt;
        // queries will get recompiled. If the following queries looked &lt;br/&gt;
        // exactly like the earlier queries in this fixture, we would &lt;br/&gt;
        // end up using the earloer query plan rather than creating a &lt;br/&gt;
        // new query plan which is going recognize the additional rows.&lt;br/&gt;
        runThreeQueries(1);&lt;br/&gt;
If I take out update statistics call, following 2 queries(which are run inside runThreeQueries method) end up using table scan rather than index scan on 10.8 through 10.3 codelines&lt;br/&gt;
       SELECT  *  FROM VARIABLE_TERM WHERE (TERM_ID = 11) OR (TERM_ID =21) OR (TERM_ID = 31)&lt;br/&gt;
       SELECT  *  FROM VARIABLE_TERM WHERE (TERM_ID IN (11, 21, 31))&lt;/p&gt;

&lt;p&gt;trunk and 10.9 codelines use table scan no matter whether we run update statistics or not. This appears to be because of checkin r1341481 that went in for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3790&quot; title=&quot;Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3790&quot;&gt;&lt;del&gt;DERBY-3790&lt;/del&gt;&lt;/a&gt; into 10.9 and trunk.&lt;/p&gt;</comment>
                            <comment id="13578225" author="kristwaa" created="Thu, 14 Feb 2013 08:28:11 +0000"  >&lt;p&gt;I think specifying derby.storage.indexStats.debug.keepDisposableStats=true &lt;b&gt;and&lt;/b&gt; regenerating statistics for the relevant tables will suffice as a work-around for this issue.&lt;/p&gt;

&lt;p&gt;Given that we agree the statistics for single-column unique indexes aren&apos;t needed, do we know what puts off the optimizer?&lt;br/&gt;
The lack of statistics, or stale row estimates?&lt;br/&gt;
(I don&apos;t have time to dig into that, and I don&apos;t know what the optimizer does in this case.)&lt;/p&gt;</comment>
                            <comment id="13578596" author="mamtas" created="Thu, 14 Feb 2013 19:39:44 +0000"  >&lt;p&gt;Kristian, thanks for your suggestion about the property(derby.storage.indexStats.debug.keepDisposableStats=true) to revert back to old behavior. I tried that property on trunk with the experiment I tried on the trunk(on 25/Jan/13), and I see that now we pick up index scan both in case of 10rows and 24rows in the table. Like you said, I ran update statistics before running the SELECT statements. The number of rows in sys.systatistics is 0 before calling update statistics. After the call to update statistics, one row gets added(when the derby.storage.indexStats.debug.keepDisposableStats=true property is used) as shown below&lt;br/&gt;
ij&amp;gt;  select * from sys.sysstatistics;&lt;br/&gt;
STATID                              |REFERENCEID                         |TABLEID                             |CREATIONTIMESTAMP            |&amp;amp;|VALID|COLCOUNT   |STATISTICS&lt;br/&gt;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
6839c016-013c-da22-2265-00000011dd90|560740aa-013c-da21-c463-000000124308|ed8940a7-013c-da21-c463-000000124308|2013-02-14 11:15:44.381      |I|true |1          |numunique= 25 &amp;amp;&lt;/p&gt;

&lt;p&gt;Without the property derby.storage.indexStats.debug.keepDisposableStats=true on trunk, the number of rows remain 0 in sys.systatistics before and after the update statisitcs call and that is the case when we use table scan rather than index scan for 24rows in the table.&lt;/p&gt;</comment>
                            <comment id="13578733" author="mamtas" created="Thu, 14 Feb 2013 22:06:05 +0000"  >&lt;p&gt;BTW, I found that on trunk, we do use index scan with 10K rows in table. So, for 10rows and 10K rows, we use index scan but for 24rows, we use table scan. These three test scenarios are in the junit test org.apache.derbyTesting.functionTests.tests.lang.InListMultiProbeTest:xtestDerby6045 &lt;/p&gt;</comment>
                            <comment id="13578786" author="mikem" created="Thu, 14 Feb 2013 22:59:03 +0000"  >&lt;p&gt;Tony, at least for the int test that mamta has added we are seeing index scan used for 10k rows.  I am worried now that our test cases may not&lt;br/&gt;
be reflecting the actual problem you are seeing in your real environment of millions of rows. Can you verify in your test case if there are a large&lt;br/&gt;
number of rows for the int case you are seeing the bug? Some interesting values for &quot;large&quot; are those that cause there to be multiple pages in the&lt;br/&gt;
base table.  In your case you have 32k pages and your test data looks like it is something like ~20 bytes per row (just a guess from the datatypes&lt;br/&gt;
and that varchar only takes up the necessary room).  I just pulled 10k out a hat for mamta&apos;s test.&lt;/p&gt;

&lt;p&gt;Also can you verify that update statistics has been run on your big table?  I think it is a bug, but it looks like the existing behavior in all code lines&lt;br/&gt;
is that you need to run update statistics for the optimizer to pick index scan in this case, even if the interesting index is unique.  &lt;/p&gt;

&lt;p&gt; I always worry about optimizer cost bugs with test&lt;br/&gt;
cases involving a really small number of rows, as the bugs uncovered there may not apply to the large number of row case. I think what mamta&lt;br/&gt;
is seeing now is, in all cases run update statistics after data is loaded and before queries are executed:&lt;/p&gt;

&lt;p&gt;10.9 - 10 rows index scan, 24 rows table scan , 10k rows index scan&lt;br/&gt;
10.8 through 10.3 - 10 rows index scan, 24 rows table scan, 10k rows test not tried, but assume it will pick index scan&lt;/p&gt;


&lt;p&gt;At the low number of rows end if you just look at costs it may make perfect sense from just a cycle cost perspective to choose a table scan&lt;br/&gt;
vs. using index.   The reason for this is that I/O cost dominates over the cost to scan every row on a page.  So in the case where the base&lt;br/&gt;
table has 1 page and the index has 1 page, pure costing will often choose to scan the 1 data page rather than pay 1 i/o to get index page and&lt;br/&gt;
then another i/o to get data page.  For other reasons (mostly to not have to lock all the rows you see during a table scan) the derby code has been &lt;br/&gt;
changed to fudge the costs a little to get index scans chosen &lt;br/&gt;
in this case, most notably a single probe query using with an exact key match using an index.  These fixes tend to aplly only to low number of &lt;br/&gt;
rows anomaly&apos;s, and not to the real life issues like your 11 million row case.&lt;/p&gt;</comment>
                            <comment id="13578905" author="apb" created="Fri, 15 Feb 2013 02:35:25 +0000"  >&lt;p&gt;I&apos;m still seeing full heap scans even with 10k rows. I used the same table as in my comment on: 18/Jan/13 22:53, just with  more rows.&lt;/p&gt;

&lt;p&gt;However, if I run derby with:&lt;br/&gt;
   derby.storage.indexStats.debug.keepDisposableStats=true&lt;br/&gt;
   and then explicitly update statistics, with CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;APP&apos;, &apos;VARIABLE_TERM&apos;, null);&lt;br/&gt;
, then I start seeing index scans on the 10k table. I imagine this will work as a temporary work-around on the 11m row table, although I haven&apos;t tried it yet.&lt;/p&gt;



</comment>
                            <comment id="13578914" author="apb" created="Fri, 15 Feb 2013 02:48:00 +0000"  >&lt;p&gt;Feel free to lower the priority since there is a work-around. However, I still feel like this is a very important issue. People shouldn&apos;t have to add special configurations to  Derby in order for blatantly obvious indexing to take place. &lt;/p&gt;</comment>
                            <comment id="13579064" author="kristwaa" created="Fri, 15 Feb 2013 09:52:18 +0000"  >&lt;p&gt;Ticking work-around field and lowering the priority.&lt;br/&gt;
With Seen in production, Regression and Performance ticked the release manager should be able to notice this issue &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I agree this is something that must be fixed, and it should be fixed before 10.10 goes out.&lt;br/&gt;
It can be done in two ways:&lt;br/&gt;
 a) change the optimizer behavior&lt;br/&gt;
 b) start generating statistics for single-column indexes again&lt;/p&gt;

&lt;p&gt;I&apos;d prefer (a), but realize that&apos;s the more difficult approach.&lt;br/&gt;
I know the community has been looking into some other optimizer issues lately, maybe we can take advantage of that to ease the investigation of this issue.&lt;/p&gt;</comment>
                            <comment id="13587387" author="mamtas" created="Tue, 26 Feb 2013 18:50:23 +0000"  >&lt;p&gt;Hi Tony, regarding your following comment(BTW, you probably meant 18th Jan rather than 8th Jan)&lt;br/&gt;
****************************************************&lt;br/&gt;
I&apos;m still seeing full heap scans even with 10k rows. I used the same table as in my comment on: 8/Jan/13 22:53, just with more rows.&lt;br/&gt;
****************************************************&lt;/p&gt;

&lt;p&gt;I worked on the test case provided by you on 18/Jan/13 22:53 and found that if I remove the 2nd unique index(copying below for reference) from the table, we start using index scan with 10K rows. I plan to add a junit test for this case to trunk. That test will be named such that it won&apos;t get run for now until we understand the impact of the 2nd unique index on the selection of scan for 10K rows.&lt;br/&gt;
buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type);\n&quot;); &lt;/p&gt;</comment>
                            <comment id="13587395" author="mamtas" created="Tue, 26 Feb 2013 18:57:29 +0000"  >&lt;p&gt;Forgot to mention in the earlier comment that the primary key column doesn&apos;t have to be BIGINT. I saw during my testing that even when term_id is declared to be INTEGER NOT NULL, we use table scan for 10K rows if there is following additional unique index defined on the table(along with term_id being the primary key)&lt;br/&gt;
ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type)&lt;/p&gt;</comment>
                            <comment id="13587406" author="mamtas" created="Tue, 26 Feb 2013 19:06:24 +0000"  >&lt;p&gt;Committed the the test case in trunk with revision 1450363.&lt;/p&gt;</comment>
                            <comment id="13587408" author="apb" created="Tue, 26 Feb 2013 19:07:46 +0000"  >&lt;p&gt;****&lt;br/&gt;
(BTW, you probably meant 18th Jan rather than 8th Jan) &lt;br/&gt;
****&lt;br/&gt;
Yes, you are absolutely correct, I meant 18/Jan/13 22:53.&lt;/p&gt;

&lt;p&gt;***************&lt;br/&gt;
I worked on the test case provided by you on 18/Jan/13 22:53 and found that if I remove the 2nd unique index(copying below for reference) from the table, we start using index scan with 10K rows. I plan to add a junit test for this case to trunk. That test will be named such that it won&apos;t get run for now until we understand the impact of the 2nd unique index on the selection of scan for 10K rows.&lt;br/&gt;
buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type);\n&quot;);&lt;br/&gt;
***************&lt;br/&gt;
I&apos;m confused about this, the comment from 18/Jan/13 22:53 only has 1 primary key index and no unique indexes. It also uses regular integers and not bigints.&lt;/p&gt;

&lt;p&gt;I&apos;m definitely seeing slow index scans on the latest release even with the simplified table in that comment. Are you seeing a difference between the latest trunk and the last release when running this? If so, are you possibly running with derby.storage.indexStats.debug.keepDisposableStats=true which would change the results?&lt;/p&gt;
</comment>
                            <comment id="13588052" author="mamtas" created="Wed, 27 Feb 2013 06:22:14 +0000"  >&lt;p&gt;I am copying the JDBC program which will show that on trunk, SELECT query with OR clause does not use index scan if there is following constraint defined on the table(haven&apos;t tried 10.9 codeline because my 10.9 client has pending work from other jira). 10.8 and 10.7 codelines continue to use index scan even with the following constraint defined on the table.&lt;br/&gt;
            s.execute(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type)&quot;); &lt;/p&gt;

&lt;p&gt;In trunk, if I comment out the code for creating kb_variable_term_variable_name_unique, the SELECT query with OR clause starts using index scan. NOTE that table has 10K rows in it. To run the program, do following and then look at derby.log for the query plans for the SELECT queries&lt;br/&gt;
java  -Dderby.language.logQueryPlan=true MamtaJDBC &lt;/p&gt;


&lt;p&gt;public class MamtaJDBC { &lt;br/&gt;
   public static void main(String[] args) { &lt;br/&gt;
      try { &lt;br/&gt;
            Class.forName(&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;); &lt;br/&gt;
            Connection conn = DriverManager &lt;br/&gt;
                    .getConnection(&quot;jdbc:derby:db1;create=true&quot;); &lt;br/&gt;
            Statement s = conn.createStatement();&lt;br/&gt;
            s.execute(&quot;CREATE TABLE VARIABLE_TERM (&quot; + &lt;br/&gt;
  	  &quot; term_id int NOT NULL,&quot; + &lt;br/&gt;
  	  &quot; var_name VARCHAR(1024) NOT NULL,&quot;+ &lt;br/&gt;
  	  &quot; var_type SMALLINT NOT NULL, &quot;+ &lt;br/&gt;
  	  &quot; kb_status INTEGER NOT NULL )&quot;); &lt;br/&gt;
            s.execute(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_term_id_pk PRIMARY KEY (term_id)&quot;); &lt;br/&gt;
            s.execute(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type)&quot;); &lt;br/&gt;
            int count = 10000;&lt;/p&gt;

&lt;p&gt;            for (int i = 0; i &amp;lt; count; i++) &lt;/p&gt;
{ 
    	s.execute(&quot;INSERT INTO VARIABLE_TERM VALUES (&quot; + i + &quot;, \&apos;?var&quot;+i+&quot;\&apos;,&quot;+ (((i %2) == 0) ? 1 : 4)+&quot;,1)&quot;);
            }
&lt;p&gt; &lt;br/&gt;
            s.execute(&quot;SELECT * FROM VARIABLE_TERM WHERE TERM_ID = 30&quot;); &lt;br/&gt;
            s.execute(&quot;SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 1) OR (TERM_ID =39) OR (TERM_ID = 24)&quot;); &lt;br/&gt;
       } catch (SQLException se) { &lt;br/&gt;
            while (se != null) &lt;/p&gt;
{ 
                System.out.println(&quot;SQLState=&quot; + se.getSQLState() 
                        + se.getMessage()); 
                se.printStackTrace(); 
                se = se.getNextException(); 
        }
&lt;p&gt; &lt;br/&gt;
     } catch (Exception ex) &lt;/p&gt;
{
          System.out.println(&quot;exception &quot; + ex.getMessage());
     }
&lt;p&gt; finally &lt;/p&gt;
{ 
          System.exit(0); 
    }
&lt;p&gt; &lt;br/&gt;
  } &lt;br/&gt;
}&lt;/p&gt;</comment>
                            <comment id="13588057" author="mamtas" created="Wed, 27 Feb 2013 06:27:02 +0000"  >&lt;p&gt;Hi Tony, I am talking about the very first comment in this jira by you. There you have 1 primary key index  and one unique index on the table. I will copy part of that code from 18th Jan for reference here&lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_term_id_pk PRIMARY KEY (term_id);\n&quot;); &lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT variable_term_id_check CHECK ((TERM_ID &amp;gt;= 1688849860263936) AND (TERM_ID &amp;lt;= 1970324836974591));\n&quot;); &lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_variable_name_unique UNIQUE (var_name, var_type);\n&quot;); &lt;br/&gt;
      buf.append(&quot;ALTER TABLE variable_term ADD CONSTRAINT kb_variable_term_var_type_enum_check CHECK ((var_type &amp;gt;= 0) AND (var_type &amp;lt;= 4));\n&quot;); &lt;/p&gt;

&lt;p&gt;I have created a small JDBC program which I have in my previous comment. Maybe you can give that a try and see what plan gets used with and without the additional unique index.&lt;/p&gt;</comment>
                            <comment id="13593048" author="mamtas" created="Tue, 5 Mar 2013 04:03:55 +0000"  >&lt;p&gt;I was curious to see what query plans are considered by trunk and 10.8(with the selectivity details) to see if I can figure out what is different between the two codelines which requires us to use table scan in trunk and index scan on 10.8. This is for the test case provided in comment  18/Jan/13 22:53 (but I tried only with 25 rows. With 25 rows is when I see tunk using table scan where as 10.8 using index scan). &lt;/p&gt;

&lt;p&gt;To get the query plans, I followed Knut&apos;s suggestion in another email by defining following 2 stored procedures&lt;br/&gt;
public static void trace() &lt;/p&gt;
{
    org.apache.derby.iapi.db.OptimizerTrace.setOptimizerTrace(true);
}
&lt;p&gt;public static void printTrace() &lt;/p&gt;
{
   System.out.println(org.apache.derby.iapi.db.OptimizerTrace.getOptimizerTraceOutput());
}

&lt;p&gt;And then I ran the query in question in ij as follows&lt;br/&gt;
java -Dij.exceptionTrace=true -Dderby.language.logQueryPlan=true org.apache.derby.tools.ij&lt;br/&gt;
connect &apos;jdbc:derby:db1&apos;;&lt;br/&gt;
create procedure trace() language java parameter style java external name &apos;org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC.trace&apos;;&lt;br/&gt;
create procedure print_trace() language java parameter style java external name &apos;org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC.printTrace&apos;;&lt;br/&gt;
call trace();&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 1) OR (TERM_ID =39) OR (TERM_ID = 24);&lt;br/&gt;
call print_trace();&lt;/p&gt;


&lt;p&gt;With both 10.8 and trunk(as shown in the attached email), I see coming up with the same numbers for different query plans considered by optimizer and hence I am not sure what the difference might be. I will look in the actual code to see if I can figure something out. Thanks&lt;/p&gt;</comment>
                            <comment id="13594880" author="mamtas" created="Wed, 6 Mar 2013 17:24:55 +0000"  >&lt;p&gt;I reran the query above with update statistics before running the query on both trunk and 10.8 to see what the optimizer trace looks like and indeed is different for the two codelines. I have attached the optimizer trace for the 2 codelines(optimizerTraceOutputWithUpdateStatsFor10_8.txt and optimizerTraceOutputWithUpdateStatsForTrunk.txt)&lt;br/&gt;
java -Dij.exceptionTrace=true -Dderby.language.logQueryPlan=true org.apache.derby.tools.ij &lt;br/&gt;
connect &apos;jdbc:derby:db1&apos;; &lt;br/&gt;
create procedure trace() language java parameter style java external name &apos;org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC.trace&apos;; &lt;br/&gt;
create procedure print_trace() language java parameter style java external name &apos;org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC.printTrace&apos;; &lt;br/&gt;
call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;APP&apos;, &apos;VARIABLE_TERM&apos;, null);&lt;br/&gt;
call trace();&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 1) OR (TERM_ID =39) OR (TERM_ID = 24);&lt;br/&gt;
call print_trace();&lt;/p&gt;</comment>
                            <comment id="13597292" author="mamtas" created="Fri, 8 Mar 2013 17:06:22 +0000"  >&lt;p&gt;After debugging the code, I have found that in o.a.d.impl.sql.compile.FromBaseTable, while estimating the cost for the given conglomerate and predicate list, in the method below,&lt;br/&gt;
	public CostEstimate estimateCost(OptimizablePredicateList predList,&lt;br/&gt;
		ConglomerateDescriptor cd,&lt;br/&gt;
		CostEstimate outerCost,&lt;br/&gt;
                     	Optimizer optimizer,&lt;br/&gt;
		RowOrdering rowOrdering)&lt;br/&gt;
			throws StandardException&lt;br/&gt;
we do not find any statistics for one-column unique index below&lt;br/&gt;
	statisticsForConglomerate = tableDescriptor.statisticsExist(cd);&lt;br/&gt;
This is because as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3790&quot; title=&quot;Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3790&quot;&gt;&lt;del&gt;DERBY-3790&lt;/del&gt;&lt;/a&gt;, we are not keeping the stats for one-column unique index any more. Later on in the same method, estimateCost, based on the existence of statistics and two other conditions, we change the selectivity value to be more favorable for the one-column unique index &lt;br/&gt;
                       if (seenFirstColumn &amp;amp;&amp;amp; statisticsForConglomerate &amp;amp;&amp;amp;&lt;br/&gt;
                               (startStopPredCount &amp;gt; 0))&lt;/p&gt;

&lt;p&gt;but since the statistics don&apos;t exist for one-column unique indexanymore, we do not improve the selectivity in trunk anymore. I will look into fixing this to recognize one-column unique index.&lt;/p&gt;</comment>
                            <comment id="13599413" author="mamtas" created="Mon, 11 Mar 2013 22:34:01 +0000"  >&lt;p&gt;FromBaseTable.java has following code to change the selectivity if statistics exist for a conglomerate but since we do not collect statistics for single-column unique index anymore, following if condition will never be true for single-column unique index and hence we will not consider that index even if it is a faster plan)&lt;br/&gt;
    if (seenFirstColumn &amp;amp;&amp;amp; statisticsForConglomerate &amp;amp;&amp;amp;&lt;br/&gt;
          (startStopPredCount &amp;gt; 0))&lt;/p&gt;
    {
           statStartStopSelectivity =
                 tableDescriptor.selectivityForConglomerate(cd, startStopPredCount);
      }

&lt;p&gt;In my attached patch, I am changing the code above to as follows&lt;/p&gt;

&lt;p&gt; if (seenFirstColumn &amp;amp;&amp;amp; (startStopPredCount &amp;gt; 0))&lt;br/&gt;
 {&lt;br/&gt;
    if (statisticsForConglomerate)&lt;br/&gt;
       statStartStopSelectivity =&lt;br/&gt;
          tableDescriptor.selectivityForConglomerate(cd,&lt;br/&gt;
              startStopPredCount);&lt;br/&gt;
    else {&lt;br/&gt;
       if (cd.isIndex())  &lt;/p&gt;
{
          //DERBY-3790 (Investigate if request for update
          // statistics can be skipped for certain kind of
          // indexes, one instance may be unique indexes based
          // on one column.) But as found in DERBY-6045 (in list
          // multi-probe by primary key not chosen on tables with
          // &amp;gt;256 rows), even though we do not keep the
          // statistics for single-column unique indexes, we
          // should improve the selectivity of such an index
          // when the index is being considered by the optimizer.
          IndexRowGenerator irg = null;
          irg = cd.getIndexDescriptor();
          if (irg.isUnique()
             &amp;amp;&amp;amp; irg.numberOfOrderedColumns() == 1
             &amp;amp;&amp;amp; startStopPredCount == 1)
                statStartStopSelectivity =
                   (double)(1/(double)baseRowCount());
       }
&lt;p&gt;    }&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt;With the new code, if we come across a conglomerate with no available statistics, then we check if &lt;br/&gt;
1)we are dealing with an index and&lt;br/&gt;
2)if it is single-column unique index and &lt;br/&gt;
3)there is one start-stop predicate, then&lt;br/&gt;
go ahead and set the start-stop selectivity to 1/number of rows in the table.&lt;/p&gt;

&lt;p&gt;I changed the InListMultiProbeTest.java by removing x in fron of the 2 fixtures xtestDerby6045 and xtestDerby6045InsertAllRowsAdditionalUniqueIndex and both those fixtures ran fine with my patch.&lt;/p&gt;

&lt;p&gt;I will appreciate another pair of eyes on the code rework, especially, the check for &quot;there is one start-stop predicate&quot; in the if clause. The reason I think we need this check is based on the existing code that we have in TableDescriptor for indexes with statistics&lt;br/&gt;
public double selectivityForConglomerate(ConglomerateDescriptor cd, int numKeys) &lt;br/&gt;
  throws StandardException&lt;br/&gt;
{&lt;br/&gt;
     UUID referenceUUID = cd.getUUID();&lt;br/&gt;
     List sdl = getStatistics();&lt;br/&gt;
     for (Iterator li = sdl.iterator(); li.hasNext(); )&lt;/p&gt;
     {
         StatisticsDescriptor statDesc = (StatisticsDescriptor) li.next();
         if (!referenceUUID.equals(statDesc.getReferenceID()))
            continue;
			
         if (statDesc.getColumnCount() != numKeys)
            continue;
			
         return statDesc.getStatistic().selectivity((Object[])null);
}</comment>
                            <comment id="13599420" author="mamtas" created="Mon, 11 Mar 2013 22:39:33 +0000"  >&lt;p&gt;I am running derbyall and junit with the patch&lt;/p&gt;</comment>
                            <comment id="13599702" author="mamtas" created="Tue, 12 Mar 2013 04:44:30 +0000"  >&lt;p&gt;derbyall ran fine with no errors. &lt;/p&gt;

&lt;p&gt;With junit suite, there was one new failure but it is just the order of the rows that is different.&lt;br/&gt;
1) refActions1(org.apache.derbyTesting.functionTests.tests.lang.LangScripts)junit.framework.ComparisonFailure: Output at line 8859 expected:&amp;lt;&lt;span class=&quot;error&quot;&gt;&amp;#91;2          |K52|OFC       |ROBIN&amp;#93;&lt;/span&gt;     &amp;gt; but was:&amp;lt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1          |K55|DB        |JOHN &amp;#93;&lt;/span&gt;     &amp;gt;&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.util.CanonTestCase.compareCanon(CanonTestCase.java:109)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.util.ScriptTestCase.runTest(ScriptTestCase.java:204)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:117)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseJDBCTestCase.runBareOverridable(BaseJDBCTestCase.java:424)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseJDBCTestCase.runBare(BaseJDBCTestCase.java:441)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;/p&gt;

&lt;p&gt;The query in question in refActions1 is as follows and it returns 2 rows&lt;br/&gt;
select * from db2test.dept where dno in (select vdno from&lt;br/&gt;
  db2test.vempunion)&lt;br/&gt;
  and dno in (&apos;K55&apos;, &apos;K52&apos;);&lt;/p&gt;

&lt;p&gt;In the master file, the output for this query is as follows(looks like this test is still not completely converted to junit and that is why there is a master for it)&lt;br/&gt;
select * from db2test.dept where dno in (select vdno from&lt;br/&gt;
  db2test.vempunion)&lt;br/&gt;
  and dno in (&apos;K55&apos;, &apos;K52&apos;);&lt;br/&gt;
C0         |DNO|DNAME     |DMGRNAME  &lt;br/&gt;
-------------------------------------&lt;br/&gt;
2          |K52|OFC       |ROBIN     &lt;br/&gt;
1          |K55|DB        |JOHN      &lt;/p&gt;

&lt;p&gt;With my patch, the query returns the same rows but in different order as shown below&lt;br/&gt;
select * from db2test.dept where dno in (select vdno from&lt;br/&gt;
  db2test.vempunion)&lt;br/&gt;
  and dno in (&apos;K55&apos;, &apos;K52&apos;);&lt;br/&gt;
C0         |DNO|DNAME     |DMGRNAME  &lt;br/&gt;
-------------------------------------&lt;br/&gt;
1          |K55|DB        |JOHN      &lt;br/&gt;
2          |K52|OFC       |ROBIN     &lt;/p&gt;

&lt;p&gt;Since there is no order by clause, should this diff be considered harmless? &lt;/p&gt;</comment>
                            <comment id="13599711" author="mamtas" created="Tue, 12 Mar 2013 05:09:29 +0000"  >&lt;p&gt;I debugged the code a little bit to see why on trunk following query uses index scan&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE TERM_ID = 11;&lt;br/&gt;
when we have found that the following query uses table scan on trunk. Just to recap, table VARIABLE_TERM has primary key on TERM_ID and it has 25 rows&lt;br/&gt;
SELECT * FROM VARIABLE_TERM WHERE (TERM_ID = 1) OR (TERM_ID =39) OR (TERM_ID = 24);&lt;/p&gt;

&lt;p&gt;I found that when optimizer is considering different plans for the query, one of things that get checked is &lt;br/&gt;
				if (! isOneRowResultSet(predList))&lt;br/&gt;
This check is in FromBaseTable.nextAccessPath. For a query with IN clause, this isOneRowResultSet(predList) will always return false but for the query with one = predicate, isOneRowResultSet(predList) will return true and hence we will pick primary key index scan for that query. Hope this helps understanding why query with = predicate uses index scan.&lt;/p&gt;</comment>
                            <comment id="13599865" author="knutanders" created="Tue, 12 Mar 2013 09:41:40 +0000"  >&lt;p&gt;The suggested fix looks reasonable to me. I agree that the ordering change in refActions1 looks benign. Still, it might be prudent to compare the query plans of the query before and after the fix to verify that the change is not an unexpected one.&lt;/p&gt;

&lt;p&gt;The check for startStopPredCount being exactly one is probably redundant, since I don&apos;t think it is possible to have more start/stop predicates than the number of key columns. I&apos;m not sure, though, and I don&apos;t think keeping it will do any harm.&lt;/p&gt;

&lt;p&gt;Some code nits:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Please add braces around the if branch in the new if/else statement.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The nested if statement inside the else branch could pulled up one level by changing &quot;else&quot; to &quot;else if&quot; in the parent if statement. That would save one indentation level and give more horizontal space to the code and comments inside it.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The irg variable is first initialized to null and then on the next line set to cd.getIndexDescriptor(). Setting it to the index descriptor immediately, and skipping the intermediate step where it&apos;s null, would make it a bit clearer.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13600114" author="mikem" created="Tue, 12 Mar 2013 15:49:21 +0000"  >&lt;p&gt;I agree with knut&apos;s comments.  change looks good to me.  &lt;/p&gt;</comment>
                            <comment id="13600117" author="mikem" created="Tue, 12 Mar 2013 15:51:16 +0000"  >&lt;p&gt;With your change will the code now pick index even if update statistics has never been run?  Looking to see if this would be a good change to backport to 10.8 and before.  Have thought that it was bad that you needed update statistics at all to get this kind of query with a unique index to pick the index.&lt;/p&gt;</comment>
                            <comment id="13600120" author="mikem" created="Tue, 12 Mar 2013 15:54:50 +0000"  >&lt;p&gt;after verifying the plan is ok for the diff query, I suggest changing the test to add an order by to make the result order deterministic.&lt;/p&gt;</comment>
                            <comment id="13609271" author="mamtas" created="Thu, 21 Mar 2013 18:30:45 +0000"  >&lt;p&gt;I debugged the failure in refActions1. I found that with my changes, with only 3 rows in the table db2test.dept, we use table scan but without my changes, we use index scan. But if I add just few more rows in db2test.dept - totalling to be say 30 rows, we use index scan for both with and without my changes. I believe that the reason behind table scan (with only 3 rows in the table) with my changes is that there are not enough rows in the table for it to make sense to use index scan. I am attaching a new patch (DERBY6045_patch2_diff.txt) which uses order by for the query below so we will not see the order change in the rows. Additionally, I have taken care of comments from Knut. If there are no further comments, then I will go ahead and commit the patch soon, Thanks&lt;br/&gt;
select * from db2test.dept where dno in (select vdno from&lt;br/&gt;
  db2test.vempunion)&lt;br/&gt;
  and dno in (&apos;K55&apos;, &apos;K52&apos;)&lt;br/&gt;
  order by dno;&lt;/p&gt;</comment>
                            <comment id="13610121" author="knutanders" created="Fri, 22 Mar 2013 10:48:41 +0000"  >&lt;p&gt;The #2 patch probably also needs to update the canon for refActions1.&lt;/p&gt;</comment>
                            <comment id="13619507" author="mamtas" created="Tue, 2 Apr 2013 05:33:39 +0100"  >&lt;p&gt;Committed changes for this jira with revision 1463378. The commit comments were as follows&lt;br/&gt;
****************************************************&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; (in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows)&lt;/p&gt;

&lt;p&gt;Changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3790&quot; title=&quot;Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3790&quot;&gt;&lt;del&gt;DERBY-3790&lt;/del&gt;&lt;/a&gt; (Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.) caused Derby to use table scan rather than index scan since we do not generate stats for single column unique index. As part of that change, we forgot to make code changes in optimizer to compensate for missing stats for such indexes. As found in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; (in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows), even though we do not keep the statistics for single-column unique indexes, we should improve the selectivity of such an index when the index is being considered by the optimizer.&lt;/p&gt;

&lt;p&gt;Making the relevant code changes now allows us to enable the tests in InListMultiProbeTest.java since they will now run correctly by picking up index scan rather than table scan.&lt;/p&gt;

&lt;p&gt;Additionally, one test in refActions1.sql does not have order by to it and there are only 3 rows in the table. Without the changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6045&quot; title=&quot;in list multi-probe by primary key not chosen on tables with &amp;gt;256 rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6045&quot;&gt;&lt;del&gt;DERBY-6045&lt;/del&gt;&lt;/a&gt; we were using index scan for it but now it uses table scan which is giving the rows in different order. I have added order by to the query so plan selection does not change order of the rows. The reason behind table scan might be that with only 3 rows in the table, it is cheaper to do table sccan rather than index scan. &lt;br/&gt;
****************************************************&lt;/p&gt;</comment>
                            <comment id="13619937" author="apb" created="Tue, 2 Apr 2013 16:49:47 +0100"  >&lt;p&gt;Thanks Mamta and everyone involoved!&lt;/p&gt;</comment>
                            <comment id="13626758" author="mamtas" created="Tue, 9 Apr 2013 17:14:13 +0100"  >&lt;p&gt;Committed few more regression tests in trunk(10.11) with revisions 1465830 and 1466097&lt;/p&gt;</comment>
                            <comment id="13649806" author="mamtas" created="Mon, 6 May 2013 16:44:29 +0100"  >&lt;p&gt;I committed a junit test for DELETE statement on trunk with revision 1479607.&lt;br/&gt;
Commiting test that shows that we use index scan for DELETE statement on a table with appropriate indexes. This happens with or without update statistics and with or without parameterized statement.&lt;/p&gt;

&lt;p&gt;Tony, can you please try the jars from the trunk and see if resolves the problem with the SELECT and DELETE test cases that you provided? The DELETE case may be different than the SELECTproblem that got fixed through the engine changes for this jira, and if so, then may be we can open a new jira for the DELETE case and pursue it as part of that jira.&lt;/p&gt;</comment>
                            <comment id="13649813" author="mikem" created="Mon, 6 May 2013 17:00:18 +0100"  >&lt;p&gt;Did your new delete tests show any problem before your fix?  It would be nice to get a junit test case checked in that shows the&lt;br/&gt;
delete problem being reported, especially if it is still a problem.&lt;/p&gt;</comment>
                            <comment id="13649821" author="apb" created="Mon, 6 May 2013 17:08:23 +0100"  >&lt;p&gt;OK. I&apos;ll do some addtional testing and try to create a reproducible test case. It may be a couple of days till I can get to this though.&lt;/p&gt;</comment>
                            <comment id="13650027" author="mamtas" created="Mon, 6 May 2013 20:38:57 +0100"  >&lt;p&gt;I tried the new junit delete test case in 10.10 and I see that the test runs fine on 10.10 without any code changes that went in for this jira. It is possible that the delete test case does not exactly do what Tony is trying to do. Tony, thanks for doing the additional testing for a reproducible test case. I am copying part of the junit test here for easier reference&lt;/p&gt;

&lt;p&gt;            CREATE TABLE MT_GAF_TOP_LEVEL_TERM_COUNTS (mt BIGINT NOT NULL, term BIGINT NOT NULL, term_index INTEGER NOT NULL, usage_count BIGINT NOT NULL );&lt;br/&gt;
            ALTER TABLE MT_GAF_TOP_LEVEL_TERM_COUNTS ADD CONSTRAINT kb_mt_gaf_top_level_term_counts_pk PRIMARY KEY (mt, term, term_index);&lt;br/&gt;
            CREATE INDEX kb_mt_gaf_top_level_term_counts_mt_index ON MT_GAF_TOP_LEVEL_TERM_COUNTS(mt);&lt;br/&gt;
            CREATE INDEX kb_mt_gaf_top_level_term_counts_term_index ON MT_GAF_TOP_LEVEL_TERM_COUNTS(term);&lt;/p&gt;

&lt;p&gt;Then I insert 10K rows in the table&lt;br/&gt;
            PreparedStatement ps = s.getConnection().prepareStatement(&lt;br/&gt;
                &quot;insert into &quot; + DERBY_6045_DATA_TABLE2 +&lt;br/&gt;
                &quot; VALUES (?, ?, ?, ?)&quot;);&lt;br/&gt;
            int numberOfRows = 10000;&lt;br/&gt;
            for (int i=1; i&amp;lt;=numberOfRows; i++) &lt;/p&gt;
{
                ps.setInt(1, i);
                ps.setInt(2, i);
                ps.setInt(3, i);
                ps.setInt(4, i);
                ps.executeUpdate();
            }
&lt;p&gt;Next, I execute following 2 delete statements and check the runtime statistics for them&lt;br/&gt;
        if (useParameterMarkers) &lt;/p&gt;
{
            ps = prepareStatement(&quot;DELETE FROM MT_GAF_TOP_LEVEL_TERM_COUNTS WHERE (term = ?) &quot;);
            ps.setInt(1,1);
            ps.execute();
        }
&lt;p&gt; else &lt;/p&gt;
{
        	s.execute(&quot;DELETE FROM MT_GAF_TOP_LEVEL_TERM_COUNTS WHERE (term = 2) &quot;);
        }
&lt;p&gt;        rtsp = SQLUtilities.getRuntimeStatisticsParser(s);&lt;br/&gt;
        assertTrue(rtsp.usedIndexScan());&lt;/p&gt;

&lt;p&gt;        if (useParameterMarkers) &lt;/p&gt;
{
            ps = prepareStatement(&quot;DELETE FROM mt_gaf_top_level_term_counts WHERE (term = ?) OR (mt = ?)&quot;);
      	    ps.setInt(1,3);
            ps.setInt(2,4);
            ps.execute();
        }
&lt;p&gt; else &lt;/p&gt;
{
        	s.execute(&quot;DELETE FROM mt_gaf_top_level_term_counts WHERE (term = 5) OR (mt = 6)&quot;);
        }
&lt;p&gt;        rtsp = SQLUtilities.getRuntimeStatisticsParser(s);&lt;br/&gt;
        assertTrue(rtsp.usedIndexScan());&lt;/p&gt;
</comment>
                            <comment id="13650028" author="mamtas" created="Mon, 6 May 2013 20:40:28 +0100"  >&lt;p&gt;In the mean time, I will work on backporting the changes to 10.10 codeline since the changes certainly fix the problem with the SELECT statement in this jira not using the index scan.&lt;/p&gt;</comment>
                            <comment id="13651601" author="mamtas" created="Wed, 8 May 2013 05:01:13 +0100"  >&lt;p&gt;Backported the code changes and some additional test to 10.10 with revision 1480153&lt;/p&gt;</comment>
                            <comment id="13651983" author="mamtas" created="Wed, 8 May 2013 16:20:26 +0100"  >&lt;p&gt;Backported changes to 10.9 with revision 1480320&lt;/p&gt;</comment>
                            <comment id="13653393" author="mamtas" created="Fri, 10 May 2013 00:53:07 +0100"  >&lt;p&gt;Backported changes to 10.8 with revision 1480730&lt;/p&gt;</comment>
                            <comment id="13654595" author="mikem" created="Fri, 10 May 2013 17:49:04 +0100"  >&lt;p&gt;thanks for backporting this to 10.8.  Even though the regression was introduced in 10.9, this change actually&lt;br/&gt;
also helps previous releases.  With this change some queries that use unique indexes will pick better plans.&lt;br/&gt;
In those cases previous to this fix one would first have to update the statistics to get the right plan to be picked.&lt;/p&gt;</comment>
                            <comment id="13654752" author="mamtas" created="Fri, 10 May 2013 20:19:49 +0100"  >&lt;p&gt;It should be fine to backport this jira further back if someone is interested in doing so. I have backported it upto 10.8 so far.&lt;/p&gt;

&lt;p&gt;Also, I will leave the jira open for another week in case if Tony finds something while trying to reproduce the DELETE case. &lt;/p&gt;</comment>
                            <comment id="13662910" author="dagw" created="Tue, 21 May 2013 12:39:10 +0100"  >&lt;p&gt;Tony, any results by now?&lt;/p&gt;</comment>
                            <comment id="13663083" author="apb" created="Tue, 21 May 2013 17:18:06 +0100"  >&lt;p&gt;I can confirm that the issue with disjunction in deletes is still an issue even in 10.10.1.1. I&apos;m trying to create a reproducible test now. Should I open a new bug for this?&lt;/p&gt;</comment>
                            <comment id="13663095" author="apb" created="Tue, 21 May 2013 17:35:16 +0100"  >&lt;p&gt;Here is the query plan for the disjunctive delete, notice the full table scan on 29K rows even though term, pred and mt all have individual indexes (which I&apos;ve confirmed):&lt;/p&gt;

&lt;p&gt;Tue May 21 11:28:34 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88632), (SESSIONID = 1), DELETE FROM kb.mt_gaf_top_level_term_counts WHERE (term = 1407374883554049) OR (pred = 1407374883554049) OR (mt = 1407374883554049) ******* Delete Cascade ResultSet using row locking:&lt;br/&gt;
deferred: false&lt;br/&gt;
Rows deleted = 418&lt;br/&gt;
Indexes updated = 9&lt;br/&gt;
Execute Time = 0&lt;br/&gt;
	Project-Restrict ResultSet (1):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 418&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	restriction = false&lt;br/&gt;
	projection = true&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 14751.50&lt;br/&gt;
		optimizer estimated cost: 12365.71&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Table Scan ResultSet for MT_GAF_TOP_LEVEL_TERM_COUNTS at read committed isolation level using exclusive row locking chosen by the optimizer&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 418&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 1&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;		scan information:&lt;br/&gt;
			Bit set of columns fetched=&lt;/p&gt;
{0, 1, 2, 3, 4}
&lt;p&gt;			Number of columns fetched=5&lt;br/&gt;
			Number of pages visited=67&lt;br/&gt;
			Number of rows qualified=418&lt;br/&gt;
			Number of rows visited=29498&lt;br/&gt;
			Scan type=heap&lt;br/&gt;
			start position:&lt;br/&gt;
				null&lt;br/&gt;
			stop position:&lt;br/&gt;
				null&lt;br/&gt;
			qualifiers:&lt;br/&gt;
				Column&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 3&lt;br/&gt;
				Operator: =&lt;br/&gt;
				Ordered nulls: false&lt;br/&gt;
				Unknown return value: false&lt;br/&gt;
				Negate comparison result: false&lt;br/&gt;
				Column&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Id: 2&lt;br/&gt;
				Operator: =&lt;br/&gt;
				Ordered nulls: false&lt;br/&gt;
				Unknown return value: false&lt;br/&gt;
				Negate comparison result: false&lt;br/&gt;
				Column&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; Id: 1&lt;br/&gt;
				Operator: =&lt;br/&gt;
				Ordered nulls: false&lt;br/&gt;
				Unknown return value: false&lt;br/&gt;
				Negate comparison result: false&lt;br/&gt;
			optimizer estimated row count: 14751.50&lt;br/&gt;
			optimizer estimated cost: 12365.71&lt;br/&gt;
Referential Actions On Dependent Tables:&lt;br/&gt;
	Delete Cascade ResultSet using row locking:&lt;br/&gt;
	deferred: false&lt;br/&gt;
	Rows deleted = 860&lt;br/&gt;
	Indexes updated = 3&lt;br/&gt;
	Execute Time = 0&lt;br/&gt;
	Project-Restrict ResultSet (3):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 860&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	restriction = false&lt;br/&gt;
	projection = true&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 129341.00&lt;br/&gt;
		optimizer estimated cost: 38529.20&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Index Scan ResultSet for GAF_ARG using index On Foreign Key at serializable isolation level using exclusive table locking chosen by the optimizer&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 860&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 1&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;		scan information:&lt;br/&gt;
			Bit set of columns fetched=All&lt;br/&gt;
			Number of columns fetched=2&lt;br/&gt;
			Number of deleted rows visited=0&lt;br/&gt;
			Number of pages visited=837&lt;br/&gt;
			Number of rows qualified=860&lt;br/&gt;
			Number of rows visited=1278&lt;br/&gt;
			Scan type=btree&lt;br/&gt;
			Tree height=2&lt;br/&gt;
			start position:&lt;br/&gt;
				&amp;gt;= on first 1 column(s).&lt;br/&gt;
				Ordered null semantics on the following columns: &lt;br/&gt;
			stop position:&lt;br/&gt;
				&amp;gt; on first 1 column(s).&lt;br/&gt;
				Ordered null semantics on the following columns: &lt;br/&gt;
			qualifiers:&lt;br/&gt;
				None&lt;br/&gt;
			optimizer estimated row count: 129341.00&lt;br/&gt;
			optimizer estimated cost: 38529.20&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88634), (SESSIONID = 1), CALL SYSIBM.SQLTABLES(?,?,?,?,?) ******* null&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88634), (SESSIONID = 1), EXECUTE STATEMENT SYS.&quot;getTables&quot; ******* Sort ResultSet:&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows input = 0&lt;br/&gt;
Rows returned = 0&lt;br/&gt;
Eliminate duplicates = false&lt;br/&gt;
In sorted order = false&lt;br/&gt;
Sort information: &lt;br/&gt;
	Number of rows input=0&lt;br/&gt;
	Number of rows output=0&lt;br/&gt;
	Sort type=internal&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 0.00&lt;br/&gt;
	optimizer estimated cost: 6.08&lt;br/&gt;
Source result set:&lt;br/&gt;
	Project-Restrict ResultSet (19):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 0&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	restriction = false&lt;br/&gt;
	projection = true&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 0.00&lt;br/&gt;
		optimizer estimated cost: 6.08&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Nested Loop Join ResultSet:&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen from the left = 48&lt;br/&gt;
		Rows seen from the right = 0&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Rows returned = 0&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 0.00&lt;br/&gt;
			optimizer estimated cost: 6.08&lt;br/&gt;
		Left result set:&lt;br/&gt;
			Nested Loop Join ResultSet:&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen from the left = 12&lt;br/&gt;
			Rows seen from the right = 48&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Rows returned = 48&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 1.70&lt;br/&gt;
				optimizer estimated cost: 4.99&lt;br/&gt;
			Left result set:&lt;br/&gt;
				Project-Restrict ResultSet (5):&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 12&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				restriction = true&lt;br/&gt;
				projection = true&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					restriction time (milliseconds) = 0&lt;br/&gt;
					projection time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 0.43&lt;br/&gt;
					optimizer estimated cost: 4.99&lt;br/&gt;
				Source result set:&lt;br/&gt;
					Index Row to Base Row ResultSet for SYSSCHEMAS:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 12&lt;br/&gt;
					Columns accessed from heap = &lt;/p&gt;
{0, 1}&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 0.43&lt;br/&gt;
						optimizer estimated cost: 4.99&lt;br/&gt;
						Index Scan ResultSet for SYSSCHEMAS using index SYSSCHEMAS_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen = 12&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Fetch Size = 16&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
						scan information:&lt;br/&gt;
							Bit set of columns fetched=All&lt;br/&gt;
							Number of columns fetched=2&lt;br/&gt;
							Number of deleted rows visited=0&lt;br/&gt;
							Number of pages visited=1&lt;br/&gt;
							Number of rows qualified=12&lt;br/&gt;
							Number of rows visited=12&lt;br/&gt;
							Scan type=btree&lt;br/&gt;
							Tree height=1&lt;br/&gt;
							start position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
							stop position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
							qualifiers:&lt;br/&gt;
								None&lt;br/&gt;
							optimizer estimated row count: 0.43&lt;br/&gt;
							optimizer estimated cost: 4.99&lt;br/&gt;
&lt;br/&gt;
			Right result set:&lt;br/&gt;
				Union ResultSet:&lt;br/&gt;
				Number of opens = 12&lt;br/&gt;
				Rows seen from the left = 36&lt;br/&gt;
				Rows seen from the right = 12&lt;br/&gt;
				Rows returned = 48&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 1.70&lt;br/&gt;
					optimizer estimated cost: 0.00&lt;br/&gt;
				Left result set:&lt;br/&gt;
					Union ResultSet:&lt;br/&gt;
					Number of opens = 12&lt;br/&gt;
					Rows seen from the left = 24&lt;br/&gt;
					Rows seen from the right = 12&lt;br/&gt;
					Rows returned = 36&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 1.28&lt;br/&gt;
						optimizer estimated cost: 0.00&lt;br/&gt;
					Left result set:&lt;br/&gt;
						Union ResultSet:&lt;br/&gt;
						Number of opens = 12&lt;br/&gt;
						Rows seen from the left = 12&lt;br/&gt;
						Rows seen from the right = 12&lt;br/&gt;
						Rows returned = 24&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 0.85&lt;br/&gt;
							optimizer estimated cost: 0.00&lt;br/&gt;
						Left result set:&lt;br/&gt;
							Normalize ResultSet:&lt;br/&gt;
							Number of opens = 12&lt;br/&gt;
							Rows seen = 12&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 0.85&lt;br/&gt;
								optimizer estimated cost: 0.00&lt;br/&gt;
							Source result set:&lt;br/&gt;
								Row ResultSet:&lt;br/&gt;
								Number of opens = 12&lt;br/&gt;
								Rows returned = 12&lt;br/&gt;
									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
									optimizer estimated row count: 0.43&lt;br/&gt;
									optimizer estimated cost: 0.00&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
						Right result set:&lt;br/&gt;
							Row ResultSet:&lt;br/&gt;
							Number of opens = 12&lt;br/&gt;
							Rows returned = 12&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 0.43&lt;br/&gt;
								optimizer estimated cost: 0.00&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
					Right result set:&lt;br/&gt;
						Normalize ResultSet:&lt;br/&gt;
						Number of opens = 12&lt;br/&gt;
						Rows seen = 12&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 1.28&lt;br/&gt;
							optimizer estimated cost: 0.00&lt;br/&gt;
						Source result set:&lt;br/&gt;
							Row ResultSet:&lt;br/&gt;
							Number of opens = 12&lt;br/&gt;
							Rows returned = 12&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 0.43&lt;br/&gt;
								optimizer estimated cost: 0.00&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
				Right result set:&lt;br/&gt;
					Normalize ResultSet:&lt;br/&gt;
					Number of opens = 12&lt;br/&gt;
					Rows seen = 12&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 1.70&lt;br/&gt;
						optimizer estimated cost: 0.00&lt;br/&gt;
					Source result set:&lt;br/&gt;
						Row ResultSet:&lt;br/&gt;
						Number of opens = 12&lt;br/&gt;
						Rows returned = 12&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 0.43&lt;br/&gt;
							optimizer estimated cost: 0.00&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
		Right result set:&lt;br/&gt;
			Project-Restrict ResultSet (18):&lt;br/&gt;
			Number of opens = 48&lt;br/&gt;
			Rows seen = 0&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			restriction = true&lt;br/&gt;
			projection = true&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				restriction time (milliseconds) = 0&lt;br/&gt;
				projection time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 0.00&lt;br/&gt;
				optimizer estimated cost: 1.08&lt;br/&gt;
			Source result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for SYSTABLES:&lt;br/&gt;
				Number of opens = 48&lt;br/&gt;
				Rows seen = 0&lt;br/&gt;
				Columns accessed from heap = {1, 2, 3}&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 0.00&lt;br/&gt;
					optimizer estimated cost: 1.08&lt;br/&gt;
					Index Scan ResultSet for SYSTABLES using index SYSTABLES_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 48&lt;br/&gt;
					Rows seen = 0&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
					scan information:&lt;br/&gt;
						Bit set of columns fetched=All&lt;br/&gt;
						Number of columns fetched=3&lt;br/&gt;
						Number of deleted rows visited=0&lt;br/&gt;
						Number of pages visited=48&lt;br/&gt;
						Number of rows qualified=0&lt;br/&gt;
						Number of rows visited=48&lt;br/&gt;
						Scan type=btree&lt;br/&gt;
						Tree height=1&lt;br/&gt;
						start position:&lt;br/&gt;
							&amp;gt;= on first 2 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							1 &lt;br/&gt;
						stop position:&lt;br/&gt;
							&amp;gt;= on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
						qualifiers:&lt;br/&gt;
							Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 1&lt;br/&gt;
							Operator: =&lt;br/&gt;
							Ordered nulls: false&lt;br/&gt;
							Unknown return value: false&lt;br/&gt;
							Negate comparison result: false&lt;br/&gt;
						optimizer estimated row count: 0.00&lt;br/&gt;
						optimizer estimated cost: 1.08&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88635), (SESSIONID = 1), CALL SYSIBM.SQLPRIMARYKEYS(?,?,?,?) ******* null&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88635), (SESSIONID = 1), EXECUTE STATEMENT SYS.&quot;getPrimaryKeys&quot; ******* Sort ResultSet:&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows input = 1&lt;br/&gt;
Rows returned = 1&lt;br/&gt;
Eliminate duplicates = false&lt;br/&gt;
In sorted order = false&lt;br/&gt;
Sort information: &lt;br/&gt;
	Number of rows input=1&lt;br/&gt;
	Number of rows output=1&lt;br/&gt;
	Sort type=internal&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 47.58&lt;br/&gt;
	optimizer estimated cost: 688.05&lt;br/&gt;
Source result set:&lt;br/&gt;
	Project-Restrict ResultSet (23):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 1&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	restriction = false&lt;br/&gt;
	projection = true&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 47.58&lt;br/&gt;
		optimizer estimated cost: 688.05&lt;br/&gt;
	Source result set:&lt;br/&gt;
		User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
		Nested Loop Join ResultSet:&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen from the left = 1&lt;br/&gt;
		Rows seen from the right = 1&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Rows returned = 1&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 47.58&lt;br/&gt;
			optimizer estimated cost: 688.05&lt;br/&gt;
		Left result set:&lt;br/&gt;
			User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
			Nested Loop Join ResultSet:&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen from the left = 1&lt;br/&gt;
			Rows seen from the right = 1&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Rows returned = 1&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 4.82&lt;br/&gt;
				optimizer estimated cost: 290.29&lt;br/&gt;
			Left result set:&lt;br/&gt;
				User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
				Nested Loop Exists Join ResultSet:&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen from the left = 1&lt;br/&gt;
				Rows seen from the right = 1&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				Rows returned = 1&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 2.34&lt;br/&gt;
					optimizer estimated cost: 121.22&lt;br/&gt;
				Left result set:&lt;br/&gt;
					User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
					Nested Loop Join ResultSet:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen from the left = 1&lt;br/&gt;
					Rows seen from the right = 1&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Rows returned = 1&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 2.34&lt;br/&gt;
						optimizer estimated cost: 112.46&lt;br/&gt;
					Left result set:&lt;br/&gt;
						User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
						Nested Loop Join ResultSet:&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen from the left = 1&lt;br/&gt;
						Rows seen from the right = 1&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Rows returned = 1&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 2.30&lt;br/&gt;
							optimizer estimated cost: 35.38&lt;br/&gt;
						Left result set:&lt;br/&gt;
							Project-Restrict ResultSet (8):&lt;br/&gt;
							Number of opens = 1&lt;br/&gt;
							Rows seen = 1&lt;br/&gt;
							Rows filtered = 0&lt;br/&gt;
							restriction = false&lt;br/&gt;
							projection = true&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								restriction time (milliseconds) = 0&lt;br/&gt;
								projection time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 2.70&lt;br/&gt;
								optimizer estimated cost: 15.68&lt;br/&gt;
							Source result set:&lt;br/&gt;
								Index Row to Base Row ResultSet for SYSTABLES:&lt;br/&gt;
								Number of opens = 1&lt;br/&gt;
								Rows seen = 1&lt;br/&gt;
								Columns accessed from heap = {0, 1, 3}&lt;br/&gt;
									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
									optimizer estimated row count: 2.70&lt;br/&gt;
									optimizer estimated cost: 15.68&lt;br/&gt;
									User supplied optimizer overrides on SYSTABLES are { index=SYSTABLES_INDEX1 }&lt;br/&gt;
									Index Scan ResultSet for SYSTABLES using index SYSTABLES_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
									Number of opens = 1&lt;br/&gt;
									Rows seen = 1&lt;br/&gt;
									Rows filtered = 0&lt;br/&gt;
									Fetch Size = 16&lt;br/&gt;
										constructor time (milliseconds) = 0&lt;br/&gt;
										open time (milliseconds) = 0&lt;br/&gt;
										next time (milliseconds) = 0&lt;br/&gt;
										close time (milliseconds) = 0&lt;br/&gt;
										next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
									scan information:&lt;br/&gt;
										Bit set of columns fetched={0, 2}&lt;br/&gt;
										Number of columns fetched=2&lt;br/&gt;
										Number of deleted rows visited=0&lt;br/&gt;
										Number of pages visited=1&lt;br/&gt;
										Number of rows qualified=1&lt;br/&gt;
										Number of rows visited=2&lt;br/&gt;
										Scan type=btree&lt;br/&gt;
										Tree height=1&lt;br/&gt;
										start position:&lt;br/&gt;
											&amp;gt;= on first 1 column(s).&lt;br/&gt;
											Ordered null semantics on the following columns: &lt;br/&gt;
										stop position:&lt;br/&gt;
											&amp;gt; on first 1 column(s).&lt;br/&gt;
											Ordered null semantics on the following columns: &lt;br/&gt;
										qualifiers:&lt;br/&gt;
											None&lt;br/&gt;
										optimizer estimated row count: 2.70&lt;br/&gt;
										optimizer estimated cost: 15.68&lt;br/&gt;
&lt;br/&gt;
						Right result set:&lt;br/&gt;
							Project-Restrict ResultSet (11):&lt;br/&gt;
							Number of opens = 1&lt;br/&gt;
							Rows seen = 1&lt;br/&gt;
							Rows filtered = 0&lt;br/&gt;
							restriction = true&lt;br/&gt;
							projection = true&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								restriction time (milliseconds) = 0&lt;br/&gt;
								projection time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 2.30&lt;br/&gt;
								optimizer estimated cost: 19.70&lt;br/&gt;
							Source result set:&lt;br/&gt;
								Index Row to Base Row ResultSet for SYSSCHEMAS:&lt;br/&gt;
								Number of opens = 1&lt;br/&gt;
								Rows seen = 1&lt;br/&gt;
								Columns accessed from heap = {0, 1}
&lt;p&gt;									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
									optimizer estimated row count: 2.30&lt;br/&gt;
									optimizer estimated cost: 19.70&lt;br/&gt;
									User supplied optimizer overrides on SYSSCHEMAS are &lt;/p&gt;
{ index=SYSSCHEMAS_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
									Index Scan ResultSet for SYSSCHEMAS using index SYSSCHEMAS_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
									Number of opens = 1&lt;br/&gt;
									Rows seen = 1&lt;br/&gt;
									Rows filtered = 0&lt;br/&gt;
									Fetch Size = 16&lt;br/&gt;
										constructor time (milliseconds) = 0&lt;br/&gt;
										open time (milliseconds) = 0&lt;br/&gt;
										next time (milliseconds) = 0&lt;br/&gt;
										close time (milliseconds) = 0&lt;br/&gt;
										next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
									scan information:&lt;br/&gt;
										Bit set of columns fetched=All&lt;br/&gt;
										Number of columns fetched=2&lt;br/&gt;
										Number of deleted rows visited=0&lt;br/&gt;
										Number of pages visited=1&lt;br/&gt;
										Number of rows qualified=1&lt;br/&gt;
										Number of rows visited=2&lt;br/&gt;
										Scan type=btree&lt;br/&gt;
										Tree height=1&lt;br/&gt;
										start position:&lt;br/&gt;
											&amp;gt;= on first 1 column(s).&lt;br/&gt;
											Ordered null semantics on the following columns: &lt;br/&gt;
										stop position:&lt;br/&gt;
											&amp;gt;= on first 1 column(s).&lt;br/&gt;
											Ordered null semantics on the following columns: &lt;br/&gt;
										qualifiers:&lt;br/&gt;
											None&lt;br/&gt;
										optimizer estimated row count: 2.30&lt;br/&gt;
										optimizer estimated cost: 19.70&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
					Right result set:&lt;br/&gt;
						Project-Restrict ResultSet (14):&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen = 2&lt;br/&gt;
						Rows filtered = 1&lt;br/&gt;
						restriction = true&lt;br/&gt;
						projection = true&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							restriction time (milliseconds) = 0&lt;br/&gt;
							projection time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 2.34&lt;br/&gt;
							optimizer estimated cost: 77.08&lt;br/&gt;
						Source result set:&lt;br/&gt;
							Index Row to Base Row ResultSet for SYSCONSTRAINTS:&lt;br/&gt;
							Number of opens = 1&lt;br/&gt;
							Rows seen = 2&lt;br/&gt;
							Columns accessed from heap = {0, 1, 2, 3}&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 2.34&lt;br/&gt;
								optimizer estimated cost: 77.08&lt;br/&gt;
								User supplied optimizer overrides on SYSCONSTRAINTS are { index=SYSCONSTRAINTS_INDEX3, joinStrategy=NESTEDLOOP }&lt;br/&gt;
								Index Scan ResultSet for SYSCONSTRAINTS using index SYSCONSTRAINTS_INDEX3 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
								Number of opens = 1&lt;br/&gt;
								Rows seen = 2&lt;br/&gt;
								Rows filtered = 0&lt;br/&gt;
								Fetch Size = 16&lt;br/&gt;
									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
									next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
								scan information:&lt;br/&gt;
									Bit set of columns fetched=All&lt;br/&gt;
									Number of columns fetched=2&lt;br/&gt;
									Number of deleted rows visited=0&lt;br/&gt;
									Number of pages visited=2&lt;br/&gt;
									Number of rows qualified=2&lt;br/&gt;
									Number of rows visited=3&lt;br/&gt;
									Scan type=btree&lt;br/&gt;
									Tree height=2&lt;br/&gt;
									start position:&lt;br/&gt;
										&amp;gt;= on first 1 column(s).&lt;br/&gt;
										Ordered null semantics on the following columns: &lt;br/&gt;
										0 &lt;br/&gt;
									stop position:&lt;br/&gt;
										&amp;gt; on first 1 column(s).&lt;br/&gt;
										Ordered null semantics on the following columns: &lt;br/&gt;
										0 &lt;br/&gt;
									qualifiers:&lt;br/&gt;
										None&lt;br/&gt;
									optimizer estimated row count: 2.34&lt;br/&gt;
									optimizer estimated cost: 77.08&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
				Right result set:&lt;br/&gt;
					Index Row to Base Row ResultSet for SYSKEYS:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 1&lt;br/&gt;
					Columns accessed from heap = {1}&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 2.34&lt;br/&gt;
						optimizer estimated cost: 8.75&lt;br/&gt;
						User supplied optimizer overrides on SYSKEYS are { index=SYSKEYS_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
						Index Scan ResultSet for SYSKEYS using index SYSKEYS_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen = 1&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Fetch Size = 1&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
						scan information:&lt;br/&gt;
							Bit set of columns fetched=All&lt;br/&gt;
							Number of columns fetched=2&lt;br/&gt;
							Number of deleted rows visited=0&lt;br/&gt;
							Number of pages visited=1&lt;br/&gt;
							Number of rows qualified=1&lt;br/&gt;
							Number of rows visited=1&lt;br/&gt;
							Scan type=btree&lt;br/&gt;
							Tree height=1&lt;br/&gt;
							start position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
								0 &lt;br/&gt;
							stop position:&lt;br/&gt;
								&amp;gt; on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
								0 &lt;br/&gt;
							qualifiers:&lt;br/&gt;
								None&lt;br/&gt;
							optimizer estimated row count: 2.34&lt;br/&gt;
							optimizer estimated cost: 8.75&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
			Right result set:&lt;br/&gt;
				Project-Restrict ResultSet (19):&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 1&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				restriction = true&lt;br/&gt;
				projection = true&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					restriction time (milliseconds) = 0&lt;br/&gt;
					projection time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 4.82&lt;br/&gt;
					optimizer estimated cost: 169.07&lt;br/&gt;
				Source result set:&lt;br/&gt;
					Index Row to Base Row ResultSet for SYSCONGLOMERATES:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 1&lt;br/&gt;
					Columns accessed from heap = {1, 5, 7}&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 4.82&lt;br/&gt;
						optimizer estimated cost: 169.07&lt;br/&gt;
						User supplied optimizer overrides on SYSCONGLOMERATES are { index=SYSCONGLOMERATES_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
						Index Scan ResultSet for SYSCONGLOMERATES using index SYSCONGLOMERATES_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen = 1&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Fetch Size = 16&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
						scan information:&lt;br/&gt;
							Bit set of columns fetched=All&lt;br/&gt;
							Number of columns fetched=2&lt;br/&gt;
							Number of deleted rows visited=0&lt;br/&gt;
							Number of pages visited=2&lt;br/&gt;
							Number of rows qualified=1&lt;br/&gt;
							Number of rows visited=2&lt;br/&gt;
							Scan type=btree&lt;br/&gt;
							Tree height=2&lt;br/&gt;
							start position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
								0 &lt;br/&gt;
							stop position:&lt;br/&gt;
								&amp;gt; on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
								0 &lt;br/&gt;
							qualifiers:&lt;br/&gt;
								None&lt;br/&gt;
							optimizer estimated row count: 4.82&lt;br/&gt;
							optimizer estimated cost: 169.07&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
		Right result set:&lt;br/&gt;
			Project-Restrict ResultSet (22):&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen = 6&lt;br/&gt;
			Rows filtered = 5&lt;br/&gt;
			restriction = true&lt;br/&gt;
			projection = true&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				restriction time (milliseconds) = 0&lt;br/&gt;
				projection time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 47.58&lt;br/&gt;
				optimizer estimated cost: 397.76&lt;br/&gt;
			Source result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for SYSCOLUMNS:&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 6&lt;br/&gt;
				Columns accessed from heap = {0, 1, 2}&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 47.58&lt;br/&gt;
					optimizer estimated cost: 397.76&lt;br/&gt;
					User supplied optimizer overrides on SYSCOLUMNS are { index=SYSCOLUMNS_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
					Index Scan ResultSet for SYSCOLUMNS using index SYSCOLUMNS_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 6&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
					scan information:&lt;br/&gt;
						Bit set of columns fetched={0, 2}&lt;br/&gt;
						Number of columns fetched=2&lt;br/&gt;
						Number of deleted rows visited=0&lt;br/&gt;
						Number of pages visited=2&lt;br/&gt;
						Number of rows qualified=6&lt;br/&gt;
						Number of rows visited=7&lt;br/&gt;
						Scan type=btree&lt;br/&gt;
						Tree height=2&lt;br/&gt;
						start position:&lt;br/&gt;
							&amp;gt;= on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						stop position:&lt;br/&gt;
							&amp;gt; on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						qualifiers:&lt;br/&gt;
							None&lt;br/&gt;
						optimizer estimated row count: 47.58&lt;br/&gt;
						optimizer estimated cost: 397.76&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88638), (SESSIONID = 1), CALL SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?) ******* null&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88638), (SESSIONID = 1), EXECUTE STATEMENT SYS.&quot;getImportedKeys&quot; ******* Sort ResultSet:&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows input = 0&lt;br/&gt;
Rows returned = 0&lt;br/&gt;
Eliminate duplicates = false&lt;br/&gt;
In sorted order = false&lt;br/&gt;
Sort information: &lt;br/&gt;
	Number of rows input=0&lt;br/&gt;
	Number of rows output=0&lt;br/&gt;
	Sort type=internal&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 17909.93&lt;br/&gt;
	optimizer estimated cost: 1583882.90&lt;br/&gt;
Source result set:&lt;br/&gt;
	Project-Restrict ResultSet (41):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 0&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	restriction = false&lt;br/&gt;
	projection = true&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 17909.93&lt;br/&gt;
		optimizer estimated cost: 1583882.90&lt;br/&gt;
	Source result set:&lt;br/&gt;
		User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
		Nested Loop Join ResultSet:&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen from the left = 0&lt;br/&gt;
		Rows seen from the right = 0&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Rows returned = 0&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 17909.93&lt;br/&gt;
			optimizer estimated cost: 1583882.90&lt;br/&gt;
		Left result set:&lt;br/&gt;
			User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
			Nested Loop Join ResultSet:&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen from the left = 0&lt;br/&gt;
			Rows seen from the right = 0&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Rows returned = 0&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 18151.34&lt;br/&gt;
				optimizer estimated cost: 86691.48&lt;br/&gt;
			Left result set:&lt;br/&gt;
				User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
				Nested Loop Exists Join ResultSet:&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen from the left = 0&lt;br/&gt;
				Rows seen from the right = 0&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				Rows returned = 0&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 881.13&lt;br/&gt;
					optimizer estimated cost: 23051.65&lt;br/&gt;
				Left result set:&lt;br/&gt;
					User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
					Nested Loop Exists Join ResultSet:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen from the left = 0&lt;br/&gt;
					Rows seen from the right = 0&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Rows returned = 0&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 881.13&lt;br/&gt;
						optimizer estimated cost: 19756.65&lt;br/&gt;
					Left result set:&lt;br/&gt;
						User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
						Nested Loop Exists Join ResultSet:&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen from the left = 0&lt;br/&gt;
						Rows seen from the right = 0&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Rows returned = 0&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 881.13&lt;br/&gt;
							optimizer estimated cost: 15848.39&lt;br/&gt;
						Left result set:&lt;br/&gt;
							User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
							Nested Loop Exists Join ResultSet:&lt;br/&gt;
							Number of opens = 1&lt;br/&gt;
							Rows seen from the left = 0&lt;br/&gt;
							Rows seen from the right = 0&lt;br/&gt;
							Rows filtered = 0&lt;br/&gt;
							Rows returned = 0&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 881.13&lt;br/&gt;
								optimizer estimated cost: 12553.39&lt;br/&gt;
							Left result set:&lt;br/&gt;
								Project-Restrict ResultSet (27):&lt;br/&gt;
								Number of opens = 1&lt;br/&gt;
								Rows seen = 0&lt;br/&gt;
								Rows filtered = 0&lt;br/&gt;
								restriction = false&lt;br/&gt;
								projection = true&lt;br/&gt;
									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
									restriction time (milliseconds) = 0&lt;br/&gt;
									projection time (milliseconds) = 0&lt;br/&gt;
									optimizer estimated row count: 881.13&lt;br/&gt;
									optimizer estimated cost: 7718.61&lt;br/&gt;
								Source result set:&lt;br/&gt;
									User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
									Nested Loop Join ResultSet:&lt;br/&gt;
									Number of opens = 1&lt;br/&gt;
									Rows seen from the left = 0&lt;br/&gt;
									Rows seen from the right = 0&lt;br/&gt;
									Rows filtered = 0&lt;br/&gt;
									Rows returned = 0&lt;br/&gt;
										constructor time (milliseconds) = 0&lt;br/&gt;
										open time (milliseconds) = 0&lt;br/&gt;
										next time (milliseconds) = 0&lt;br/&gt;
										close time (milliseconds) = 0&lt;br/&gt;
										optimizer estimated row count: 881.13&lt;br/&gt;
										optimizer estimated cost: 7718.61&lt;br/&gt;
									Left result set:&lt;br/&gt;
										User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
										Nested Loop Join ResultSet:&lt;br/&gt;
										Number of opens = 1&lt;br/&gt;
										Rows seen from the left = 0&lt;br/&gt;
										Rows seen from the right = 0&lt;br/&gt;
										Rows filtered = 0&lt;br/&gt;
										Rows returned = 0&lt;br/&gt;
											constructor time (milliseconds) = 0&lt;br/&gt;
											open time (milliseconds) = 0&lt;br/&gt;
											next time (milliseconds) = 0&lt;br/&gt;
											close time (milliseconds) = 0&lt;br/&gt;
											optimizer estimated row count: 89.30&lt;br/&gt;
											optimizer estimated cost: 352.73&lt;br/&gt;
										Left result set:&lt;br/&gt;
											User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
											Nested Loop Exists Join ResultSet:&lt;br/&gt;
											Number of opens = 1&lt;br/&gt;
											Rows seen from the left = 2&lt;br/&gt;
											Rows seen from the right = 0&lt;br/&gt;
											Rows filtered = 0&lt;br/&gt;
											Rows returned = 0&lt;br/&gt;
												constructor time (milliseconds) = 0&lt;br/&gt;
												open time (milliseconds) = 0&lt;br/&gt;
												next time (milliseconds) = 0&lt;br/&gt;
												close time (milliseconds) = 0&lt;br/&gt;
												optimizer estimated row count: 4.34&lt;br/&gt;
												optimizer estimated cost: 39.63&lt;br/&gt;
											Left result set:&lt;br/&gt;
												User supplied optimizer overrides for join are { joinOrder=FIXED }&lt;br/&gt;
												Nested Loop Join ResultSet:&lt;br/&gt;
												Number of opens = 1&lt;br/&gt;
												Rows seen from the left = 1&lt;br/&gt;
												Rows seen from the right = 2&lt;br/&gt;
												Rows filtered = 0&lt;br/&gt;
												Rows returned = 2&lt;br/&gt;
													constructor time (milliseconds) = 0&lt;br/&gt;
													open time (milliseconds) = 0&lt;br/&gt;
													next time (milliseconds) = 0&lt;br/&gt;
													close time (milliseconds) = 0&lt;br/&gt;
													optimizer estimated row count: 4.34&lt;br/&gt;
													optimizer estimated cost: 20.86&lt;br/&gt;
												Left result set:&lt;br/&gt;
													Project-Restrict ResultSet (17):&lt;br/&gt;
													Number of opens = 1&lt;br/&gt;
													Rows seen = 1&lt;br/&gt;
													Rows filtered = 0&lt;br/&gt;
													restriction = false&lt;br/&gt;
													projection = true&lt;br/&gt;
														constructor time (milliseconds) = 0&lt;br/&gt;
														open time (milliseconds) = 0&lt;br/&gt;
														next time (milliseconds) = 0&lt;br/&gt;
														close time (milliseconds) = 0&lt;br/&gt;
														restriction time (milliseconds) = 0&lt;br/&gt;
														projection time (milliseconds) = 0&lt;br/&gt;
														optimizer estimated row count: 0.43&lt;br/&gt;
														optimizer estimated cost: 6.58&lt;br/&gt;
													Source result set:&lt;br/&gt;
														Nested Loop Exists Join ResultSet:&lt;br/&gt;
														Number of opens = 1&lt;br/&gt;
														Rows seen from the left = 1&lt;br/&gt;
														Rows seen from the right = 1&lt;br/&gt;
														Rows filtered = 0&lt;br/&gt;
														Rows returned = 1&lt;br/&gt;
															constructor time (milliseconds) = 0&lt;br/&gt;
															open time (milliseconds) = 0&lt;br/&gt;
															next time (milliseconds) = 0&lt;br/&gt;
															close time (milliseconds) = 0&lt;br/&gt;
															optimizer estimated row count: 0.43&lt;br/&gt;
															optimizer estimated cost: 6.58&lt;br/&gt;
														Left result set:&lt;br/&gt;
															Project-Restrict ResultSet (14):&lt;br/&gt;
															Number of opens = 1&lt;br/&gt;
															Rows seen = 1&lt;br/&gt;
															Rows filtered = 0&lt;br/&gt;
															restriction = true&lt;br/&gt;
															projection = true&lt;br/&gt;
																constructor time (milliseconds) = 0&lt;br/&gt;
																open time (milliseconds) = 0&lt;br/&gt;
																next time (milliseconds) = 0&lt;br/&gt;
																close time (milliseconds) = 0&lt;br/&gt;
																restriction time (milliseconds) = 0&lt;br/&gt;
																projection time (milliseconds) = 0&lt;br/&gt;
																optimizer estimated row count: 0.43&lt;br/&gt;
																optimizer estimated cost: 4.99&lt;br/&gt;
															Source result set:&lt;br/&gt;
																Index Row to Base Row ResultSet for SYSSCHEMAS:&lt;br/&gt;
																Number of opens = 1&lt;br/&gt;
																Rows seen = 1&lt;br/&gt;
																Columns accessed from heap = {0}&lt;br/&gt;
																	constructor time (milliseconds) = 0&lt;br/&gt;
																	open time (milliseconds) = 0&lt;br/&gt;
																	next time (milliseconds) = 0&lt;br/&gt;
																	close time (milliseconds) = 0&lt;br/&gt;
																	optimizer estimated row count: 0.43&lt;br/&gt;
																	optimizer estimated cost: 4.99&lt;br/&gt;
																	User supplied optimizer overrides on SYSSCHEMAS are { index=SYSSCHEMAS_INDEX1, joinStrategy=NESTEDLOOP }
&lt;p&gt;																	Index Scan ResultSet for SYSSCHEMAS using index SYSSCHEMAS_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
																	Number of opens = 1&lt;br/&gt;
																	Rows seen = 1&lt;br/&gt;
																	Rows filtered = 0&lt;br/&gt;
																	Fetch Size = 1&lt;br/&gt;
																		constructor time (milliseconds) = 0&lt;br/&gt;
																		open time (milliseconds) = 0&lt;br/&gt;
																		next time (milliseconds) = 0&lt;br/&gt;
																		close time (milliseconds) = 0&lt;br/&gt;
																		next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;																	scan information:&lt;br/&gt;
																		Bit set of columns fetched=All&lt;br/&gt;
																		Number of columns fetched=2&lt;br/&gt;
																		Number of deleted rows visited=0&lt;br/&gt;
																		Number of pages visited=1&lt;br/&gt;
																		Number of rows qualified=1&lt;br/&gt;
																		Number of rows visited=2&lt;br/&gt;
																		Scan type=btree&lt;br/&gt;
																		Tree height=1&lt;br/&gt;
																		start position:&lt;br/&gt;
																			&amp;gt;= on first 1 column(s).&lt;br/&gt;
																			Ordered null semantics on the following columns: &lt;br/&gt;
																		stop position:&lt;br/&gt;
																			&amp;gt;= on first 1 column(s).&lt;br/&gt;
																			Ordered null semantics on the following columns: &lt;br/&gt;
																		qualifiers:&lt;br/&gt;
																			None&lt;br/&gt;
																		optimizer estimated row count: 0.43&lt;br/&gt;
																		optimizer estimated cost: 4.99&lt;/p&gt;

&lt;p&gt;														Right result set:&lt;br/&gt;
															Index Row to Base Row ResultSet for SYSTABLES:&lt;br/&gt;
															Number of opens = 1&lt;br/&gt;
															Rows seen = 1&lt;br/&gt;
															Columns accessed from heap = &lt;/p&gt;
{0}
&lt;p&gt;																constructor time (milliseconds) = 0&lt;br/&gt;
																open time (milliseconds) = 0&lt;br/&gt;
																next time (milliseconds) = 0&lt;br/&gt;
																close time (milliseconds) = 0&lt;br/&gt;
																optimizer estimated row count: 0.43&lt;br/&gt;
																optimizer estimated cost: 1.59&lt;br/&gt;
																User supplied optimizer overrides on SYSTABLES are &lt;/p&gt;
{ index=SYSTABLES_INDEX1 }
&lt;p&gt;																Index Scan ResultSet for SYSTABLES using index SYSTABLES_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
																Number of opens = 1&lt;br/&gt;
																Rows seen = 1&lt;br/&gt;
																Rows filtered = 0&lt;br/&gt;
																Fetch Size = 1&lt;br/&gt;
																	constructor time (milliseconds) = 0&lt;br/&gt;
																	open time (milliseconds) = 0&lt;br/&gt;
																	next time (milliseconds) = 0&lt;br/&gt;
																	close time (milliseconds) = 0&lt;br/&gt;
																	next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;																scan information:&lt;br/&gt;
																	Bit set of columns fetched=All&lt;br/&gt;
																	Number of columns fetched=3&lt;br/&gt;
																	Number of deleted rows visited=0&lt;br/&gt;
																	Number of pages visited=1&lt;br/&gt;
																	Number of rows qualified=1&lt;br/&gt;
																	Number of rows visited=1&lt;br/&gt;
																	Scan type=btree&lt;br/&gt;
																	Tree height=1&lt;br/&gt;
																	start position:&lt;br/&gt;
																		&amp;gt;= on first 2 column(s).&lt;br/&gt;
																		Ordered null semantics on the following columns: &lt;br/&gt;
																		1 &lt;br/&gt;
																	stop position:&lt;br/&gt;
																		&amp;gt; on first 2 column(s).&lt;br/&gt;
																		Ordered null semantics on the following columns: &lt;br/&gt;
																		1 &lt;br/&gt;
																	qualifiers:&lt;br/&gt;
																		None&lt;br/&gt;
																	optimizer estimated row count: 0.43&lt;br/&gt;
																	optimizer estimated cost: 1.59&lt;/p&gt;


&lt;p&gt;												Right result set:&lt;br/&gt;
													Index Row to Base Row ResultSet for SYSCONSTRAINTS:&lt;br/&gt;
													Number of opens = 1&lt;br/&gt;
													Rows seen = 2&lt;br/&gt;
													Columns accessed from heap = &lt;/p&gt;
{0, 2}
&lt;p&gt;														constructor time (milliseconds) = 0&lt;br/&gt;
														open time (milliseconds) = 0&lt;br/&gt;
														next time (milliseconds) = 0&lt;br/&gt;
														close time (milliseconds) = 0&lt;br/&gt;
														optimizer estimated row count: 4.34&lt;br/&gt;
														optimizer estimated cost: 14.27&lt;br/&gt;
														User supplied optimizer overrides on SYSCONSTRAINTS are &lt;/p&gt;
{ index=SYSCONSTRAINTS_INDEX3, joinStrategy=NESTEDLOOP }
&lt;p&gt;														Index Scan ResultSet for SYSCONSTRAINTS using index SYSCONSTRAINTS_INDEX3 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
														Number of opens = 1&lt;br/&gt;
														Rows seen = 2&lt;br/&gt;
														Rows filtered = 0&lt;br/&gt;
														Fetch Size = 1&lt;br/&gt;
															constructor time (milliseconds) = 0&lt;br/&gt;
															open time (milliseconds) = 0&lt;br/&gt;
															next time (milliseconds) = 0&lt;br/&gt;
															close time (milliseconds) = 0&lt;br/&gt;
															next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;														scan information:&lt;br/&gt;
															Bit set of columns fetched=All&lt;br/&gt;
															Number of columns fetched=2&lt;br/&gt;
															Number of deleted rows visited=0&lt;br/&gt;
															Number of pages visited=2&lt;br/&gt;
															Number of rows qualified=2&lt;br/&gt;
															Number of rows visited=3&lt;br/&gt;
															Scan type=btree&lt;br/&gt;
															Tree height=2&lt;br/&gt;
															start position:&lt;br/&gt;
																&amp;gt;= on first 1 column(s).&lt;br/&gt;
																Ordered null semantics on the following columns: &lt;br/&gt;
																0 &lt;br/&gt;
															stop position:&lt;br/&gt;
																&amp;gt; on first 1 column(s).&lt;br/&gt;
																Ordered null semantics on the following columns: &lt;br/&gt;
																0 &lt;br/&gt;
															qualifiers:&lt;br/&gt;
																None&lt;br/&gt;
															optimizer estimated row count: 4.34&lt;br/&gt;
															optimizer estimated cost: 14.27&lt;/p&gt;


&lt;p&gt;											Right result set:&lt;br/&gt;
												Index Row to Base Row ResultSet for SYSFOREIGNKEYS:&lt;br/&gt;
												Number of opens = 2&lt;br/&gt;
												Rows seen = 0&lt;br/&gt;
												Columns accessed from heap = &lt;/p&gt;
{1, 2, 3}
&lt;p&gt;													constructor time (milliseconds) = 0&lt;br/&gt;
													open time (milliseconds) = 0&lt;br/&gt;
													next time (milliseconds) = 0&lt;br/&gt;
													close time (milliseconds) = 0&lt;br/&gt;
													optimizer estimated row count: 4.34&lt;br/&gt;
													optimizer estimated cost: 18.78&lt;br/&gt;
													User supplied optimizer overrides on SYSFOREIGNKEYS are &lt;/p&gt;
{ index=SYSFOREIGNKEYS_INDEX1, joinStrategy=NESTEDLOOP }
&lt;p&gt;													Index Scan ResultSet for SYSFOREIGNKEYS using index SYSFOREIGNKEYS_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
													Number of opens = 2&lt;br/&gt;
													Rows seen = 0&lt;br/&gt;
													Rows filtered = 0&lt;br/&gt;
													Fetch Size = 1&lt;br/&gt;
														constructor time (milliseconds) = 0&lt;br/&gt;
														open time (milliseconds) = 0&lt;br/&gt;
														next time (milliseconds) = 0&lt;br/&gt;
														close time (milliseconds) = 0&lt;/p&gt;

&lt;p&gt;													scan information:&lt;br/&gt;
														Bit set of columns fetched=All&lt;br/&gt;
														Number of columns fetched=2&lt;br/&gt;
														Number of deleted rows visited=0&lt;br/&gt;
														Number of pages visited=2&lt;br/&gt;
														Number of rows qualified=0&lt;br/&gt;
														Number of rows visited=2&lt;br/&gt;
														Scan type=btree&lt;br/&gt;
														Tree height=1&lt;br/&gt;
														start position:&lt;br/&gt;
															&amp;gt;= on first 1 column(s).&lt;br/&gt;
															Ordered null semantics on the following columns: &lt;br/&gt;
															0 &lt;br/&gt;
														stop position:&lt;br/&gt;
															&amp;gt; on first 1 column(s).&lt;br/&gt;
															Ordered null semantics on the following columns: &lt;br/&gt;
															0 &lt;br/&gt;
														qualifiers:&lt;br/&gt;
															None&lt;br/&gt;
														optimizer estimated row count: 4.34&lt;br/&gt;
														optimizer estimated cost: 18.78&lt;/p&gt;


&lt;p&gt;										Right result set:&lt;br/&gt;
											Index Row to Base Row ResultSet for SYSCONGLOMERATES:&lt;br/&gt;
											Number of opens = 0&lt;br/&gt;
											Rows seen = 0&lt;br/&gt;
											Columns accessed from heap = &lt;/p&gt;
{5}
&lt;p&gt;												constructor time (milliseconds) = 0&lt;br/&gt;
												open time (milliseconds) = 0&lt;br/&gt;
												next time (milliseconds) = 0&lt;br/&gt;
												close time (milliseconds) = 0&lt;br/&gt;
												optimizer estimated row count: 89.30&lt;br/&gt;
												optimizer estimated cost: 313.10&lt;br/&gt;
												User supplied optimizer overrides on SYSCONGLOMERATES are &lt;/p&gt;
{ index=SYSCONGLOMERATES_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
												Index Scan ResultSet for SYSCONGLOMERATES using index SYSCONGLOMERATES_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
												Number of opens = 0&lt;br/&gt;
												Rows seen = 0&lt;br/&gt;
												Rows filtered = 0&lt;br/&gt;
												Fetch Size = 1&lt;br/&gt;
													constructor time (milliseconds) = 0&lt;br/&gt;
													open time (milliseconds) = 0&lt;br/&gt;
													next time (milliseconds) = 0&lt;br/&gt;
													close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
												scan information:&lt;br/&gt;
													start position:&lt;br/&gt;
														Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
													stop position:&lt;br/&gt;
														Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
													qualifiers:&lt;br/&gt;
														None&lt;br/&gt;
													optimizer estimated row count: 89.30&lt;br/&gt;
													optimizer estimated cost: 313.10&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
									Right result set:&lt;br/&gt;
										Project-Restrict ResultSet (26):&lt;br/&gt;
										Number of opens = 0&lt;br/&gt;
										Rows seen = 0&lt;br/&gt;
										Rows filtered = 0&lt;br/&gt;
										restriction = true&lt;br/&gt;
										projection = true&lt;br/&gt;
											constructor time (milliseconds) = 0&lt;br/&gt;
											open time (milliseconds) = 0&lt;br/&gt;
											next time (milliseconds) = 0&lt;br/&gt;
											close time (milliseconds) = 0&lt;br/&gt;
											restriction time (milliseconds) = 0&lt;br/&gt;
											projection time (milliseconds) = 0&lt;br/&gt;
											optimizer estimated row count: 881.13&lt;br/&gt;
											optimizer estimated cost: 7365.89&lt;br/&gt;
										Source result set:&lt;br/&gt;
											Index Row to Base Row ResultSet for SYSCOLUMNS:&lt;br/&gt;
											Number of opens = 0&lt;br/&gt;
											Rows seen = 0&lt;br/&gt;
											Columns accessed from heap = {2}&lt;br/&gt;
												constructor time (milliseconds) = 0&lt;br/&gt;
												open time (milliseconds) = 0&lt;br/&gt;
												next time (milliseconds) = 0&lt;br/&gt;
												close time (milliseconds) = 0&lt;br/&gt;
												optimizer estimated row count: 881.13&lt;br/&gt;
												optimizer estimated cost: 7365.89&lt;br/&gt;
												User supplied optimizer overrides on SYSCOLUMNS are { index=SYSCOLUMNS_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
												Index Scan ResultSet for SYSCOLUMNS using index SYSCOLUMNS_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
												Number of opens = 0&lt;br/&gt;
												Rows seen = 0&lt;br/&gt;
												Rows filtered = 0&lt;br/&gt;
												Fetch Size = 1&lt;br/&gt;
													constructor time (milliseconds) = 0&lt;br/&gt;
													open time (milliseconds) = 0&lt;br/&gt;
													next time (milliseconds) = 0&lt;br/&gt;
													close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
												scan information:&lt;br/&gt;
													start position:&lt;br/&gt;
														Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
													stop position:&lt;br/&gt;
														Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
													qualifiers:&lt;br/&gt;
														None&lt;br/&gt;
													optimizer estimated row count: 881.13&lt;br/&gt;
													optimizer estimated cost: 7365.89&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
							Right result set:&lt;br/&gt;
								Index Row to Base Row ResultSet for SYSCONSTRAINTS:&lt;br/&gt;
								Number of opens = 0&lt;br/&gt;
								Rows seen = 0&lt;br/&gt;
								Columns accessed from heap = {1, 2}&lt;br/&gt;
									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
									optimizer estimated row count: 881.13&lt;br/&gt;
									optimizer estimated cost: 4834.78&lt;br/&gt;
									User supplied optimizer overrides on SYSCONSTRAINTS are { index=SYSCONSTRAINTS_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
									Index Scan ResultSet for SYSCONSTRAINTS using index SYSCONSTRAINTS_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
									Number of opens = 0&lt;br/&gt;
									Rows seen = 0&lt;br/&gt;
									Rows filtered = 0&lt;br/&gt;
									Fetch Size = 1&lt;br/&gt;
										constructor time (milliseconds) = 0&lt;br/&gt;
										open time (milliseconds) = 0&lt;br/&gt;
										next time (milliseconds) = 0&lt;br/&gt;
										close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
									scan information:&lt;br/&gt;
										start position:&lt;br/&gt;
											Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
										stop position:&lt;br/&gt;
											Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
										qualifiers:&lt;br/&gt;
											None&lt;br/&gt;
										optimizer estimated row count: 881.13&lt;br/&gt;
										optimizer estimated cost: 4834.78&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
						Right result set:&lt;br/&gt;
							Index Row to Base Row ResultSet for SYSTABLES:&lt;br/&gt;
							Number of opens = 0&lt;br/&gt;
							Rows seen = 0&lt;br/&gt;
							Columns accessed from heap = {1, 3}&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
								optimizer estimated row count: 881.13&lt;br/&gt;
								optimizer estimated cost: 3295.00&lt;br/&gt;
								User supplied optimizer overrides on SYSTABLES are { index=SYSTABLES_INDEX2, joinStrategy=NESTEDLOOP }&lt;br/&gt;
								Index Scan ResultSet for SYSTABLES using index SYSTABLES_INDEX2 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
								Number of opens = 0&lt;br/&gt;
								Rows seen = 0&lt;br/&gt;
								Rows filtered = 0&lt;br/&gt;
								Fetch Size = 1&lt;br/&gt;
									constructor time (milliseconds) = 0&lt;br/&gt;
									open time (milliseconds) = 0&lt;br/&gt;
									next time (milliseconds) = 0&lt;br/&gt;
									close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
								scan information:&lt;br/&gt;
									start position:&lt;br/&gt;
										Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
									stop position:&lt;br/&gt;
										Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
									qualifiers:&lt;br/&gt;
										None&lt;br/&gt;
									optimizer estimated row count: 881.13&lt;br/&gt;
									optimizer estimated cost: 3295.00&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
					Right result set:&lt;br/&gt;
						Index Row to Base Row ResultSet for SYSSCHEMAS:&lt;br/&gt;
						Number of opens = 0&lt;br/&gt;
						Rows seen = 0&lt;br/&gt;
						Columns accessed from heap = {1}&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							optimizer estimated row count: 881.13&lt;br/&gt;
							optimizer estimated cost: 3908.27&lt;br/&gt;
							User supplied optimizer overrides on SYSSCHEMAS are { index=SYSSCHEMAS_INDEX2, joinStrategy=NESTEDLOOP }&lt;br/&gt;
							Index Scan ResultSet for SYSSCHEMAS using index SYSSCHEMAS_INDEX2 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
							Number of opens = 0&lt;br/&gt;
							Rows seen = 0&lt;br/&gt;
							Rows filtered = 0&lt;br/&gt;
							Fetch Size = 1&lt;br/&gt;
								constructor time (milliseconds) = 0&lt;br/&gt;
								open time (milliseconds) = 0&lt;br/&gt;
								next time (milliseconds) = 0&lt;br/&gt;
								close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
							scan information:&lt;br/&gt;
								start position:&lt;br/&gt;
									Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
								stop position:&lt;br/&gt;
									Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
								qualifiers:&lt;br/&gt;
									None&lt;br/&gt;
								optimizer estimated row count: 881.13&lt;br/&gt;
								optimizer estimated cost: 3908.27&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
				Right result set:&lt;br/&gt;
					Index Row to Base Row ResultSet for SYSKEYS:&lt;br/&gt;
					Number of opens = 0&lt;br/&gt;
					Rows seen = 0&lt;br/&gt;
					Columns accessed from heap = {1}&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 881.13&lt;br/&gt;
						optimizer estimated cost: 3295.00&lt;br/&gt;
						User supplied optimizer overrides on SYSKEYS are { index=SYSKEYS_INDEX1, joinStrategy=NESTEDLOOP }&lt;br/&gt;
						Index Scan ResultSet for SYSKEYS using index SYSKEYS_INDEX1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
						Number of opens = 0&lt;br/&gt;
						Rows seen = 0&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Fetch Size = 1&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
&lt;br/&gt;
						scan information:&lt;br/&gt;
							start position:&lt;br/&gt;
								Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
							stop position:&lt;br/&gt;
								Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
							qualifiers:&lt;br/&gt;
								Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
								Operator: =&lt;br/&gt;
								Ordered nulls: false&lt;br/&gt;
								Unknown return value: false&lt;br/&gt;
								Negate comparison result: false&lt;br/&gt;
							optimizer estimated row count: 881.13&lt;br/&gt;
							optimizer estimated cost: 3295.00&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
			Right result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for SYSCONGLOMERATES:&lt;br/&gt;
				Number of opens = 0&lt;br/&gt;
				Rows seen = 0&lt;br/&gt;
				Columns accessed from heap = {5, 7}&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 18151.34&lt;br/&gt;
					optimizer estimated cost: 63639.83&lt;br/&gt;
					User supplied optimizer overrides on SYSCONGLOMERATES are { index=SYSCONGLOMERATES_INDEX1, joinStrategy=NESTEDLOOP }
&lt;p&gt;					Index Scan ResultSet for SYSCONGLOMERATES using index SYSCONGLOMERATES_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 0&lt;br/&gt;
					Rows seen = 0&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;/p&gt;

&lt;p&gt;					scan information:&lt;br/&gt;
						start position:&lt;br/&gt;
							Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
						stop position:&lt;br/&gt;
							Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
						qualifiers:&lt;br/&gt;
							None&lt;br/&gt;
						optimizer estimated row count: 18151.34&lt;br/&gt;
						optimizer estimated cost: 63639.83&lt;/p&gt;


&lt;p&gt;		Right result set:&lt;br/&gt;
			Project-Restrict ResultSet (40):&lt;br/&gt;
			Number of opens = 0&lt;br/&gt;
			Rows seen = 0&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			restriction = true&lt;br/&gt;
			projection = true&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				restriction time (milliseconds) = 0&lt;br/&gt;
				projection time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 17909.93&lt;br/&gt;
				optimizer estimated cost: 1497191.43&lt;br/&gt;
			Source result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for SYSCOLUMNS:&lt;br/&gt;
				Number of opens = 0&lt;br/&gt;
				Rows seen = 0&lt;br/&gt;
				Columns accessed from heap = &lt;/p&gt;
{0, 1, 2}
&lt;p&gt;					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 17909.93&lt;br/&gt;
					optimizer estimated cost: 1497191.43&lt;br/&gt;
					User supplied optimizer overrides on SYSCOLUMNS are &lt;/p&gt;
{ index=SYSCOLUMNS_INDEX1, joinStrategy=NESTEDLOOP }
&lt;p&gt;					Index Scan ResultSet for SYSCOLUMNS using index SYSCOLUMNS_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 0&lt;br/&gt;
					Rows seen = 0&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;/p&gt;

&lt;p&gt;					scan information:&lt;br/&gt;
						start position:&lt;br/&gt;
							Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
						stop position:&lt;br/&gt;
							Positioning information not available because this ResultSet was never opened.&lt;br/&gt;
						qualifiers:&lt;br/&gt;
							None&lt;br/&gt;
						optimizer estimated row count: 17909.93&lt;br/&gt;
						optimizer estimated cost: 1497191.43&lt;/p&gt;



&lt;p&gt;Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88640), (SESSIONID = 1), CALL SYSIBM.SQLCOLUMNS(?,?,?,?,?) ******* null&lt;br/&gt;
Tue May 21 11:29:56 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 88640), (SESSIONID = 1), EXECUTE STATEMENT SYS.&quot;getColumns&quot; ******* Sort ResultSet:&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows input = 6&lt;br/&gt;
Rows returned = 6&lt;br/&gt;
Eliminate duplicates = false&lt;br/&gt;
In sorted order = false&lt;br/&gt;
Sort information: &lt;br/&gt;
	Number of rows input=6&lt;br/&gt;
	Number of rows output=6&lt;br/&gt;
	Sort type=internal&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 0.86&lt;br/&gt;
	optimizer estimated cost: 10.74&lt;br/&gt;
Source result set:&lt;br/&gt;
	Project-Restrict ResultSet (12):&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 6&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	restriction = false&lt;br/&gt;
	projection = true&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		restriction time (milliseconds) = 0&lt;br/&gt;
		projection time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 0.86&lt;br/&gt;
		optimizer estimated cost: 10.74&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Nested Loop Join ResultSet:&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen from the left = 1&lt;br/&gt;
		Rows seen from the right = 6&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Rows returned = 6&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 0.86&lt;br/&gt;
			optimizer estimated cost: 10.74&lt;br/&gt;
		Left result set:&lt;br/&gt;
			Nested Loop Join ResultSet:&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen from the left = 1&lt;br/&gt;
			Rows seen from the right = 1&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Rows returned = 1&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 0.11&lt;br/&gt;
				optimizer estimated cost: 6.42&lt;br/&gt;
			Left result set:&lt;br/&gt;
				Project-Restrict ResultSet (5):&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 1&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				restriction = true&lt;br/&gt;
				projection = true&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					restriction time (milliseconds) = 0&lt;br/&gt;
					projection time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 0.43&lt;br/&gt;
					optimizer estimated cost: 4.99&lt;br/&gt;
				Source result set:&lt;br/&gt;
					Index Row to Base Row ResultSet for SYSSCHEMAS:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 1&lt;br/&gt;
					Columns accessed from heap = &lt;/p&gt;
{0, 1}
&lt;p&gt;						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 0.43&lt;br/&gt;
						optimizer estimated cost: 4.99&lt;br/&gt;
						Index Scan ResultSet for SYSSCHEMAS using index SYSSCHEMAS_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen = 1&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Fetch Size = 16&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;						scan information:&lt;br/&gt;
							Bit set of columns fetched=All&lt;br/&gt;
							Number of columns fetched=2&lt;br/&gt;
							Number of deleted rows visited=0&lt;br/&gt;
							Number of pages visited=1&lt;br/&gt;
							Number of rows qualified=1&lt;br/&gt;
							Number of rows visited=2&lt;br/&gt;
							Scan type=btree&lt;br/&gt;
							Tree height=1&lt;br/&gt;
							start position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
							stop position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
							qualifiers:&lt;br/&gt;
								None&lt;br/&gt;
							optimizer estimated row count: 0.43&lt;br/&gt;
							optimizer estimated cost: 4.99&lt;/p&gt;

&lt;p&gt;			Right result set:&lt;br/&gt;
				Project-Restrict ResultSet (8):&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 3&lt;br/&gt;
				Rows filtered = 2&lt;br/&gt;
				restriction = true&lt;br/&gt;
				projection = true&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					restriction time (milliseconds) = 0&lt;br/&gt;
					projection time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 0.11&lt;br/&gt;
					optimizer estimated cost: 1.43&lt;br/&gt;
				Source result set:&lt;br/&gt;
					Index Row to Base Row ResultSet for SYSTABLES:&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 3&lt;br/&gt;
					Columns accessed from heap = &lt;/p&gt;
{0, 1, 3}
&lt;p&gt;						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						optimizer estimated row count: 0.11&lt;br/&gt;
						optimizer estimated cost: 1.43&lt;br/&gt;
						Index Scan ResultSet for SYSTABLES using index SYSTABLES_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
						Number of opens = 1&lt;br/&gt;
						Rows seen = 3&lt;br/&gt;
						Rows filtered = 0&lt;br/&gt;
						Fetch Size = 16&lt;br/&gt;
							constructor time (milliseconds) = 0&lt;br/&gt;
							open time (milliseconds) = 0&lt;br/&gt;
							next time (milliseconds) = 0&lt;br/&gt;
							close time (milliseconds) = 0&lt;br/&gt;
							next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;						scan information:&lt;br/&gt;
							Bit set of columns fetched=All&lt;br/&gt;
							Number of columns fetched=3&lt;br/&gt;
							Number of deleted rows visited=0&lt;br/&gt;
							Number of pages visited=1&lt;br/&gt;
							Number of rows qualified=3&lt;br/&gt;
							Number of rows visited=4&lt;br/&gt;
							Scan type=btree&lt;br/&gt;
							Tree height=1&lt;br/&gt;
							start position:&lt;br/&gt;
								&amp;gt;= on first 2 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
								1 &lt;br/&gt;
							stop position:&lt;br/&gt;
								&amp;gt;= on first 1 column(s).&lt;br/&gt;
								Ordered null semantics on the following columns: &lt;br/&gt;
							qualifiers:&lt;br/&gt;
								Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 1&lt;br/&gt;
								Operator: =&lt;br/&gt;
								Ordered nulls: false&lt;br/&gt;
								Unknown return value: false&lt;br/&gt;
								Negate comparison result: false&lt;br/&gt;
							optimizer estimated row count: 0.11&lt;br/&gt;
							optimizer estimated cost: 1.43&lt;/p&gt;


&lt;p&gt;		Right result set:&lt;br/&gt;
			Project-Restrict ResultSet (11):&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen = 6&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			restriction = true&lt;br/&gt;
			projection = true&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				restriction time (milliseconds) = 0&lt;br/&gt;
				projection time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 0.86&lt;br/&gt;
				optimizer estimated cost: 4.32&lt;br/&gt;
			Source result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for SYSCOLUMNS:&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 6&lt;br/&gt;
				Columns accessed from heap = &lt;/p&gt;
{0, 1, 2, 3, 4, 7, 8}
&lt;p&gt;					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 0.86&lt;br/&gt;
					optimizer estimated cost: 4.32&lt;br/&gt;
					Index Scan ResultSet for SYSCOLUMNS using index SYSCOLUMNS_INDEX1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 6&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;					scan information:&lt;br/&gt;
						Bit set of columns fetched=All&lt;br/&gt;
						Number of columns fetched=3&lt;br/&gt;
						Number of deleted rows visited=0&lt;br/&gt;
						Number of pages visited=2&lt;br/&gt;
						Number of rows qualified=6&lt;br/&gt;
						Number of rows visited=7&lt;br/&gt;
						Scan type=btree&lt;br/&gt;
						Tree height=2&lt;br/&gt;
						start position:&lt;br/&gt;
							&amp;gt;= on first 2 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						stop position:&lt;br/&gt;
							&amp;gt;= on first 2 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						qualifiers:&lt;br/&gt;
							None&lt;br/&gt;
						optimizer estimated row count: 0.86&lt;br/&gt;
						optimizer estimated cost: 4.32&lt;/p&gt;
</comment>
                            <comment id="13663121" author="apb" created="Tue, 21 May 2013 17:58:54 +0100"  >&lt;p&gt;Ive attached table.del which is a table dump that should reproduce the disjunctive delete table scan. This is proprietary and should be deleted when testing is complete.&lt;/p&gt;</comment>
                            <comment id="13663130" author="apb" created="Tue, 21 May 2013 18:04:10 +0100"  >&lt;p&gt;I&apos;ve attached a dump of the table that should reproduce the issue. &lt;br/&gt;
The table was dumped with:&lt;br/&gt;
CALL SYSCS_UTIL.SYSCS_EXPORT_TABLE(&apos;KB&apos;, &apos;MT_GAF_TOP_LEVEL_TERM_COUNTS&apos;, &apos;table.del&apos;, null, null, &apos;UTF-8&apos;);&lt;/p&gt;

&lt;p&gt;The current table definition looks like:&lt;/p&gt;

&lt;p&gt;CREATE TABLE KB.MT_GAF_TOP_LEVEL_TERM_COUNTS&lt;br/&gt;
(&lt;br/&gt;
        id BIGINT NOT NULL,&lt;br/&gt;
        mt BIGINT NOT NULL, &lt;br/&gt;
        pred BIGINT NOT NULL,&lt;br/&gt;
        term BIGINT NOT NULL,&lt;br/&gt;
        term_index INTEGER NOT NULL,&lt;br/&gt;
        usage_count BIGINT NOT NULL&lt;br/&gt;
);&lt;/p&gt;


&lt;p&gt;ALTER TABLE kb.mt_gaf_top_level_term_counts &lt;br/&gt;
  ADD CONSTRAINT kb_mt_gaf_top_level_term_counts_pk PRIMARY KEY (id);&lt;br/&gt;
ALTER TABLE kb.mt_gaf_top_level_term_counts &lt;br/&gt;
   ADD CONSTRAINT kb_mt_gaf_top_level_term_counts_non_negative_usage_count_check CHECK (usage_count &amp;gt;= 0);&lt;/p&gt;


&lt;p&gt;CREATE INDEX kb_mt_gaf_top_level_term_counts_mt_index ON kb.mt_gaf_top_level_term_counts(mt);&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_term_index ON kb.mt_gaf_top_level_term_counts(term);&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_pred_index ON kb.mt_gaf_top_level_term_counts(pred);&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_mt_pred_term_index_index ON kb.mt_gaf_top_level_term_counts(mt, pred, term_index); &amp;#8211; fast find of terms&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_pred_term_term_index_index ON kb.mt_gaf_top_level_term_counts(pred, term, term_index); &amp;#8211; fast find of mts&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_mt_term_term_index_index ON kb.mt_gaf_top_level_term_counts(mt, term, term_index); &amp;#8211; fast find of preds&lt;br/&gt;
CREATE INDEX  kb_mt_gaf_top_level_term_counts_mt_pred_term_index ON kb.mt_gaf_top_level_term_counts(mt, pred, term); &amp;#8211; fast find of term indices&lt;br/&gt;
CREATE INDEX kb_mt_gaf_top_level_term_counts_mt_pred_term_index_term_index ON kb.mt_gaf_top_level_term_counts(mt, pred, term_index, term); &amp;#8211; fast find of ids&lt;/p&gt;

&lt;p&gt;The following delete currently produces a full table scan:&lt;/p&gt;

&lt;p&gt;DELETE FROM kb.mt_gaf_top_level_term_counts WHERE (term = 1407374883554049) OR (pred = 1407374883554049) OR (mt = 1407374883554049)&lt;/p&gt;

&lt;p&gt;However, breaking it up into 3 separate deletes does not produce a table scan.&lt;/p&gt;


&lt;p&gt;Note: I am maintaining statistics on the table if that matters:&lt;/p&gt;

&lt;p&gt;call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(&apos;KB&apos;, &apos;MT_GAF_TOP_LEVEL_TERM_COUNTS&apos;, null);&lt;/p&gt;</comment>
                            <comment id="13664246" author="mikem" created="Wed, 22 May 2013 17:47:28 +0100"  >&lt;p&gt;i think we should move the delete bug to a new linked JIRA.  Tony, can you verify that&lt;br/&gt;
the current submitted fix, fixes your original reported select issue.&lt;/p&gt;</comment>
                            <comment id="13664255" author="mikem" created="Wed, 22 May 2013 17:59:33 +0100"  >&lt;p&gt;just looked more carefully at the problem delete query, an optimal execution would do single probes in 3 different indexes.  I am not sure if the in list optimization is coded to do that.  This may be a feature request vs a bug.  Could someone who knows the optimizer comment?  It would be good to know if a select that looks like the delete query has a problem or not.&lt;/p&gt;</comment>
                            <comment id="13665288" author="apb" created="Thu, 23 May 2013 16:59:49 +0100"  >&lt;p&gt;Is there a way I can get quick access to fixed jar files (client and embedded)? I&apos;m not currently set up to do Derby development. &lt;/p&gt;

&lt;p&gt;Also, once you enable statistics with SYSCS_UTIL.SYSCS_UPDATE_STATISTICS, is there a way to turn it off again? Since this bypasses the issue, I&apos;ll need to undo this change so I can test accurately.&lt;/p&gt;</comment>
                            <comment id="13665612" author="apb" created="Thu, 23 May 2013 21:22:46 +0100"  >&lt;p&gt;I tried the SELECT version of the DELETE statement:&lt;/p&gt;

&lt;p&gt;SELECT *  FROM kb.mt_gaf_top_level_term_counts WHERE (term = 1407374883554049) OR (pred = 1407374883554049) OR (mt = 1407374883554049) &lt;/p&gt;

&lt;p&gt;It looks like it is doing a table scan as well.&lt;/p&gt;

&lt;p&gt;Number of pages visited=67&lt;br/&gt;
Number of rows qualified=418&lt;br/&gt;
Number of rows visited=29498&lt;/p&gt;

&lt;p&gt;Note: this was tried without the Mamta&apos;s patches for this bug so far. However, I am using table statics which would avoid this bug, so I&apos;m pretty sure this is still a real issue.&lt;/p&gt;

&lt;p&gt;Here is the query plan:&lt;/p&gt;

&lt;p&gt;Thu May 23 15:17:22 CDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_3,5,main&amp;#93;&lt;/span&gt; (XID = 80859), (SESSIONID = 1), SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM (SELECT *  FROM kb.mt_gaf_top_level_term_counts WHERE (term = 1407374883554049) OR (pred = 1407374883554049) OR (mt = 1407374883554049)) C2668 ******* Project-Restrict ResultSet (4):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 1&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 1.00&lt;br/&gt;
	optimizer estimated cost: 12365.71&lt;br/&gt;
Source result set:&lt;br/&gt;
	Scalar Aggregate ResultSet:&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows input = 418&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 14751.50&lt;br/&gt;
		optimizer estimated cost: 12365.71&lt;br/&gt;
	Index Key Optimization = false&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Project-Restrict ResultSet (3):&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 418&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		restriction = false&lt;br/&gt;
		projection = true&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			restriction time (milliseconds) = 0&lt;br/&gt;
			projection time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 14751.50&lt;br/&gt;
			optimizer estimated cost: 12365.71&lt;br/&gt;
		Source result set:&lt;br/&gt;
			Table Scan ResultSet for MT_GAF_TOP_LEVEL_TERM_COUNTS at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen = 418&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Fetch Size = 1&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;			scan information:&lt;br/&gt;
				Bit set of columns fetched=All&lt;br/&gt;
				Number of columns fetched=6&lt;br/&gt;
				Number of pages visited=67&lt;br/&gt;
				Number of rows qualified=418&lt;br/&gt;
				Number of rows visited=29498&lt;br/&gt;
				Scan type=heap&lt;br/&gt;
				start position:&lt;br/&gt;
					null&lt;br/&gt;
				stop position:&lt;br/&gt;
					null&lt;br/&gt;
				qualifiers:&lt;br/&gt;
					Column&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 3&lt;br/&gt;
					Operator: =&lt;br/&gt;
					Ordered nulls: false&lt;br/&gt;
					Unknown return value: false&lt;br/&gt;
					Negate comparison result: false&lt;br/&gt;
					Column&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Id: 2&lt;br/&gt;
					Operator: =&lt;br/&gt;
					Ordered nulls: false&lt;br/&gt;
					Unknown return value: false&lt;br/&gt;
					Negate comparison result: false&lt;br/&gt;
					Column&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; Id: 1&lt;br/&gt;
					Operator: =&lt;br/&gt;
					Ordered nulls: false&lt;br/&gt;
					Unknown return value: false&lt;br/&gt;
					Negate comparison result: false&lt;br/&gt;
				optimizer estimated row count: 14751.50&lt;br/&gt;
				optimizer estimated cost: 12365.71&lt;/p&gt;
</comment>
                            <comment id="13665813" author="mikem" created="Fri, 24 May 2013 00:06:42 +0100"  >&lt;p&gt;I have created &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6226&quot; title=&quot;enhance optmizer to use multiple probes into multiple indexes to satisfy OR queries on different columns.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6226&quot;&gt;DERBY-6226&lt;/a&gt; to track the discussion on the &quot;delete/select&quot; with OR&apos;s on multiple columns.  Tony I think you can delete your private data as we actually did repro the problem, just did not know it.  &lt;/p&gt;</comment>
                            <comment id="13670535" author="mamtas" created="Thu, 30 May 2013 18:58:59 +0100"  >&lt;p&gt;I will go ahead and close this jira since we are following issue with OR on multiple columns as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6226&quot; title=&quot;enhance optmizer to use multiple probes into multiple indexes to satisfy OR queries on different columns.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6226&quot;&gt;DERBY-6226&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14284761" author="myrna" created="Wed, 21 Jan 2015 00:23:11 +0000"  >&lt;p&gt;bulk change to close all issues resolved but not closed and not changed since June 1, 2014.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12649208">DERBY-6226</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12400684">DERBY-3790</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="27899">DERBY-47</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12641497">DERBY-6156</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12573199" name="DERBY6045_patch1_diff.txt" size="3410" author="mamtas" created="Mon, 11 Mar 2013 22:34:01 +0000"/>
                            <attachment id="12574847" name="DERBY6045_patch2_diff.txt" size="3912" author="mamtas" created="Thu, 21 Mar 2013 18:30:45 +0000"/>
                            <attachment id="12572025" name="optimizerTraceOutputFor10_8.txt" size="6332" author="mamtas" created="Tue, 5 Mar 2013 04:03:55 +0000"/>
                            <attachment id="12572026" name="optimizerTraceOutputForTrunk.txt" size="6330" author="mamtas" created="Tue, 5 Mar 2013 04:03:55 +0000"/>
                            <attachment id="12572351" name="optimizerTraceOutputWithUpdateStatsFor10_8.txt" size="6561" author="mamtas" created="Wed, 6 Mar 2013 17:25:37 +0000"/>
                            <attachment id="12572352" name="optimizerTraceOutputWithUpdateStatsForTrunk.txt" size="6329" author="mamtas" created="Wed, 6 Mar 2013 17:25:37 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    <customfieldvalue key="10421"><![CDATA[Seen in production]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 18 Jan 2013 20:07:44 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>304928</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    <customfieldvalue key="10427"><![CDATA[Workaround attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hz1rjr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>254306</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>