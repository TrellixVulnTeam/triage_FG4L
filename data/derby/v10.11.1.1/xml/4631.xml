<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:52:43 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4631/DERBY-4631.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4631] Wrong join column returned by right outer join with NATURAL or USING and territory-based collation</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4631</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;SQL:2003 says that the join columns in a natural join or in a named&lt;br/&gt;
columns join should be added to the select list by coalescing the&lt;br/&gt;
column from the left table with the column from the right table.&lt;/p&gt;

&lt;p&gt;Section 7.7, &amp;lt;joined table&amp;gt;, syntax rules:&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) Let TR1 be the first &amp;lt;table reference&amp;gt;, and let TR2 be the &amp;lt;table&lt;br/&gt;
&amp;gt; reference&amp;gt; or &amp;lt;table factor&amp;gt; that is the second operand of the&lt;br/&gt;
&amp;gt; &amp;lt;joined table&amp;gt;. Let RT1 and RT2 be the row types of TR1 and TR2,&lt;br/&gt;
&amp;gt; respectively. Let TA and TB be the range variables of TR1 and TR2,&lt;br/&gt;
&amp;gt; respectively. (...)&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;&amp;gt; 7) If NATURAL is specified or if a &amp;lt;join specification&amp;gt; immediately&lt;br/&gt;
&amp;gt; containing a &amp;lt;named columns join&amp;gt; is specified, then:&lt;br/&gt;
(...)&lt;br/&gt;
&amp;gt; d) If there is at least one corresponding join column, then let SLCC&lt;br/&gt;
&amp;gt; be a &amp;lt;select list&amp;gt; of &amp;lt;derived column&amp;gt;s of the form&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; COALESCE ( TA.C, TB.C ) AS C&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; for every column C that is a corresponding join column, taken in&lt;br/&gt;
&amp;gt; order of their ordinal positions in RT1.&lt;/p&gt;

&lt;p&gt;For a right outer join, Derby doesn&apos;t use COALESCE(TA.C, TB.C), but&lt;br/&gt;
rather just TB.C (the column in the right table) directly.&lt;/p&gt;

&lt;p&gt;This is in most cases OK, because COALESCE(TA.C, TB.C) = TB.C is an&lt;br/&gt;
invariant in a right outer join. (Because TA.C is either NULL or equal&lt;br/&gt;
to TB.C.)&lt;/p&gt;

&lt;p&gt;However, in a database with territory-based collation, equality&lt;br/&gt;
between two values does not mean they are identical, especially now&lt;br/&gt;
that the strength of the collator can be specified (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1748&quot; title=&quot;Global case insensitive setting&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1748&quot;&gt;&lt;del&gt;DERBY-1748&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Take for instance this join:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; connect &apos;jdbc:derby:testdb;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY&apos;;&lt;br/&gt;
ij&amp;gt; create table big(x varchar(5));&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into big values &apos;A&apos;,&apos;B&apos;,&apos;C&apos;;&lt;br/&gt;
3 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table small(x varchar(5));&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into small values &apos;b&apos;,&apos;c&apos;,&apos;d&apos;;&lt;br/&gt;
3 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select x, t1.x, t2.x, coalesce(t1.x, t2.x) from small t1 natural right outer join big t2;&lt;br/&gt;
X    |X    |X    |4    &lt;br/&gt;
-----------------------&lt;br/&gt;
A    |NULL |A    |A    &lt;br/&gt;
B    |b    |B    |b    &lt;br/&gt;
C    |c    |C    |c    &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;/p&gt;

&lt;p&gt;I believe that the expected result from the above query is that the&lt;br/&gt;
first column should have the same values as the last column. That is,&lt;br/&gt;
the first column should contain &lt;/p&gt;
{&apos;A&apos;, &apos;b&apos;, &apos;c&apos;}
&lt;p&gt;, not &lt;/p&gt;
{&apos;A&apos;, &apos;B&apos;, &apos;C&apos;}
&lt;p&gt;.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12463019">DERBY-4631</key>
            <summary>Wrong join column returned by right outer join with NATURAL or USING and territory-based collation</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                            <label>derby_triage10_8</label>
                    </labels>
                <created>Mon, 26 Apr 2010 14:36:29 +0100</created>
                <updated>Mon, 17 Jun 2013 10:27:18 +0100</updated>
                            <resolved>Fri, 14 Sep 2012 23:20:42 +0100</resolved>
                                    <version>10.6.1.0</version>
                                    <fixVersion>10.6.2.4</fixVersion>
                    <fixVersion>10.7.1.4</fixVersion>
                    <fixVersion>10.8.3.0</fixVersion>
                    <fixVersion>10.9.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12864741" author="knutanders" created="Thu, 6 May 2010 12:50:07 +0100"  >&lt;p&gt;This problem also makes us accept some statements that should not be accepted. For example:&lt;/p&gt;

&lt;p&gt;SELECT country,count(country) FROM&lt;br/&gt;
COUNTRIES JOIN CITIES USING (COUNTRY) group by countries.country&lt;/p&gt;

&lt;p&gt;Here, the query should be rejected because countries.country is not specified in the select list. However, it&apos;s accepted because we replace the column country with countries.country instead of coalesce(countries.country, cities.country).&lt;/p&gt;</comment>
                            <comment id="12890350" author="mamtas" created="Tue, 20 Jul 2010 18:52:49 +0100"  >&lt;p&gt;It seems like what we need is to replace the join column references(which are not tied to the join table specifically) in select column list to COALESCE functions. Additionally, in case of a named join order, the join column names in USING clause should be replaced with COALESCE function. eg of each of the cases&lt;br/&gt;
select x, t1.x, t2.x, coalesce(t1.x, t2.x) from small t1 natural right outer join big t2; &lt;br/&gt;
The first column in the select above which is x should be internally replaced with coalesce(t1.x, t2.x) &lt;/p&gt;

&lt;p&gt;SELECT country,count(country) FROM COUNTRIES JOIN CITIES USING (COUNTRY) group by countries.country &lt;br/&gt;
The first column in the select and the COUNTRY in USING clause should be replaced with coalesce internally.&lt;/p&gt;

&lt;p&gt;I looked at the code a bindExpressions code in impl.sql.compile.JoinNode There, we already have a code to recognize natural join&lt;br/&gt;
        if (naturalJoin) &lt;/p&gt;
{
            usingClause = getCommonColumnsForNaturalJoin();
        }

&lt;p&gt;I think after this code, we should go through join columns in select column list and in USING clause and replace them with corresponding COALESEC functions.&lt;/p&gt;</comment>
                            <comment id="13164165" author="mamtas" created="Wed, 7 Dec 2011 05:47:44 +0000"  >&lt;p&gt;I debugged the code to figure out what (and where) are we doing in the code which causes us to give wrong results for join column in case of territory based database and right outer join with NATURAL or USING clause. As Knut pointed out earlier in this jira, as per the SQL spec, &quot;the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table. &quot; What I have found is that Derby decides to pick up join column&apos;s value from the left table when we are working with natural left outer join and it picks up the join column&apos;s value from the right table when we are working with natural right outer join. This is not a problem when we are dealing with non-territory based databases but the assumption to rely on just one table&apos;s join column is incorrect when working with territory based databases. Following is the test case I used for debugging which further explains Derby&apos;s current implementation.&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY&apos;; &lt;br/&gt;
create table big(x varchar(5)); &lt;br/&gt;
insert into big values &apos;A&apos;,&apos;B&apos;, null; &lt;br/&gt;
create table small(x varchar(5)); &lt;br/&gt;
insert into small values &apos;b&apos;,&apos;c&apos;, null; &lt;br/&gt;
select * from small t1 natural left outer join big t2;&lt;br/&gt;
select * from small t1 natural right outer join big t2;&lt;/p&gt;

&lt;p&gt;For both natural left outer join and natural right outer join, at execution time, we create a merged row which has columns merged from the left and right tables. The column(in my example, there is only one column)s in the select sql maps to a column from the merged row. The mapping is determined at the sql compile phase. &lt;br/&gt;
In the case of &apos;select * from small t1 natural left outer join big t2&apos;, there will be three merged rows with 2 columns each&lt;br/&gt;
&apos;b&apos;  &apos;B&apos;&lt;br/&gt;
&apos;c&apos;  null&lt;br/&gt;
null null&lt;br/&gt;
And for natural left outer join, the generated code has column in the select SQL map to the first column in the merged row. This will always work fine even in a territory based database because as per the SQL standards, the column x should be equivalent to the return value of coalesce(t1.x, t2.x). Since we are working with left outer join, then if the first column in the merged row is null, then even the 2nd column(from the right table) will be null and hence it is ok to always pick up the value from the 1st column in the merged row. This mapping will always lead column x to have the same value as coalesce(t1.x, t2.x).&lt;/p&gt;

&lt;p&gt;But for a territory based database, we can&apos;t count on a logic like that for natural right outer join. The way Derby works right now, the column x in the select always gets mapped to the 2nd column in the merged row. In the case of &apos;select * from small t1 natural right outer join big t2&apos;, there will be three merged rows with 2 columns each&lt;br/&gt;
null &apos;A&apos;&lt;br/&gt;
&apos;b&apos;  &apos;B&apos;&lt;br/&gt;
null null&lt;br/&gt;
And for natural right outer join, the generated code has column in the select SQL map to the second column in the merged row. This will work fine in a non-territory database, because if column 1 in the merged row has a non-null value, then it will always be the same value as the column 2 in the merged row. But in our example, with territor based database(with SECONDARY strength, meaning it is case insensitive comparison), values &apos;B&apos; and &apos;b&apos; are considered equal. Hence the coalesce(t1.x, t2,x) will not be same as value in the 2nd column of the merged row. For natural right outer join with the data given in the example above, &lt;br/&gt;
coalesce(t1.x, t2,x) will return &apos;A&apos;, &apos;b&apos; and null. But with the mapping of column x in the SELECT to the 2nd column in the merged row will return &apos;A&apos;, &apos;B&apos; and null thus returning data which does not comply with SQL standard which says that column x&apos;s value should be the return value of coalesce(t1.x, t2.x). So it seems like may be we need some of kind projection in case of natural right outer join (rather than simple column mapping to the 2nd column which is what happens right now) so that we look at both the columns in the merged row to determine the value of column x.&lt;/p&gt;

&lt;p&gt;Hope this explanation helps understand what Derby is doing internally and based on that, we can come up with some proposal to fix the issue.&lt;/p&gt;</comment>
                            <comment id="13165798" author="mamtas" created="Fri, 9 Dec 2011 03:00:22 +0000"  >&lt;p&gt;As mentioned earlier in this jira, the SQL spec says that the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table. Derby implements the SQL spec by using left table&apos;s column value when doing natural left outer join. For natural right outer join, Derby uses the right&lt;br/&gt;
table&apos;s join column value. This logic correctly implements the SQL spec requirements for both left and right outer joins for non-territory based database and for left outer join for territory based database but the logic for the natural right outer join doesn&apos;t work for territory based database. Taking the example from earlier in this jira&lt;br/&gt;
create table big(x varchar(5)); &lt;br/&gt;
insert into big values &apos;A&apos;,&apos;B&apos;; &lt;br/&gt;
create table small(x varchar(5)); &lt;br/&gt;
insert into small values &apos;b&apos;,&apos;c&apos;; &lt;/p&gt;

&lt;p&gt;For this data, following shows that selecting the join column doesn&apos;t give the same results as coalesce(t1.x, t2.x)&lt;br/&gt;
select x, t1.x t1x, t2.x t2x, coalesce(t1.x, t2.x) cx from small t1 natural right outer join big t2;&lt;br/&gt;
X    |T1X  |T2X  |CX   &lt;br/&gt;
--------------------------------------------------------------------&lt;br/&gt;
A    |NULL |A    |A    &lt;br/&gt;
B    |b         |B    |b    &lt;/p&gt;

&lt;p&gt;For the 1st row above, coalesce(t1.x, t2.x) will return &apos;A&apos; and that is what we got for the join column in that row, so we are good for the 1st row. But for the 2nd row, coalesce(t1.x, t2.x) will return &apos;b&apos; whereas the join column for that row shows &apos;B&apos;. This is because as per Derby&apos;s implementation, for natural right outer join, we just pick the value from the right table row which for the 2nd row happens to be &apos;B&apos;. &lt;/p&gt;

&lt;p&gt;We can leave the logic as it is for natural left outer joins since it works fine for both territory and non-terrtory based databases. We can also leave the logic untouched for natural right outer joins for non-territory based databases. The only broken case is natural right outer join in case of territory based database. For this specific case, we can generate a project restrict resultset which will pick the join column&apos;s value based on following logic&lt;br/&gt;
1)if the left table&apos;s column value is null then pick up the right table&apos;s column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s column value is non-null, then pick up that value&lt;/p&gt;

&lt;p&gt;I have not done much work in code generation and hence wanted to run this logic by the community to see if anyone has any feedback and if this looks like the correct approach to solve the problem. Any suggestions on alternative/better fix?&lt;/p&gt;</comment>
                            <comment id="13170002" author="knutanders" created="Thu, 15 Dec 2011 07:39:53 +0000"  >&lt;p&gt;If that approach doesn&apos;t work, another possibility might be to insert a CoalesceFunctionNode in JoinNode.buildRCL() or perhaps in JoinNode.getAllResultColumns().&lt;/p&gt;</comment>
                            <comment id="13185724" author="mamtas" created="Fri, 13 Jan 2012 18:13:52 +0000"  >&lt;p&gt;Want to copy the commit comments from the revision r1230873. After the commit comments, I have proposal for 2 possible fixes for the problems described in the commit comments.&lt;br/&gt;
*************************************&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4631&quot; title=&quot;Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4631&quot;&gt;&lt;del&gt;DERBY-4631&lt;/del&gt;&lt;/a&gt; Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&lt;/p&gt;

&lt;p&gt;I am adding more tests for this jira to show the kind of joins and queries that are impacted by this defect.&lt;/p&gt;

&lt;p&gt;In short, any join query which is either a NATURAL join or has a USING clause can run into the two problems as described in this jira.&lt;/p&gt;

&lt;p&gt;Problem 1)As per SQL spec, the join column&apos;s value should be derived by&lt;br/&gt;
               COALESCE(leftTable.joinColumn, rightTable.joinColumn).&lt;br/&gt;
       But Derby has it&apos;s own rule for deriving the join column&apos;s value. Derby&apos;s implementation, for a right outer join, gets the join column&apos;s value from the right table and for left outer join, it gets the value from the left table. This logic works for most cases, but it can give incorrect value for a right outer join (with NATURAL JOIN or USING clause) in case of a territory based database. Additionally, the join column in the SELECT list(with NATURAL JOIN or USING clause) gets associated with the left table&apos;s join column(for inner joins and left outer joins) or it gets associated with the right table&apos;s join column(for rihgt outer joins). Since SQL spec requires the join column to be COALESCE ( leftTable.C, rightTable.C ) AS C, the join column should not be really associated with any of the 2 join tables.&lt;/p&gt;

&lt;p&gt;Problem 2)The Derby&apos;s assocation of join column to left or right table as described in problem 1) causes it to allow incorrect queries. eg query&lt;br/&gt;
select i from t1_D3880 inner join t2_D3880 USING&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; group by t1_D3880.i;&lt;br/&gt;
       The query above works because join column i got associated with left table which is t1_D3880. If the query was rewritten to do the group by on right table, it would fail.&lt;br/&gt;
select i from t1_D3880 inner join t2_D3880 USING&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; group by t2_D3880.i;&lt;br/&gt;
*************************************&lt;/p&gt;


&lt;p&gt;There are 2 solutions that we have talked about in the jira. &lt;br/&gt;
Solution 1)Currently, at execution time, Derby creates a merged row for join column which has columns merged from the left and right tables and picks up the 1st column&apos;s value for a left outer join and picks up the 2nd column&apos;s value for right outer join. (I don&apos;t remember debugging the inner join case but from it&apos;s behavior, it probably also picks up the value from the 1st column&apos;s value just like left outer join).&lt;br/&gt;
	Rather than this logic, we can change the code to pick the join column&apos;s value based on following logic &lt;br/&gt;
1)if the left table&apos;s column value is null then pick up the right table&apos;s column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s column value is non-null, then pick up that value &lt;br/&gt;
	We can implement this logic for all kinds of joins except the cross join(which doesn&apos;t allow NATURAL	JOIN or USING clause and hence we will never be able to run in the problem described by this jira or we can implement the logic only for right outer joins which is the only case which will run into problem because we do not implement COALESCE.  The problem with this solution is it will not catch Problem 2) described above because join column is getting associated with left table or right table depending on what kind of join we are working with.&lt;br/&gt;
Solution 2)This solution will take care of all the problems described earlier. With this solution, at bind time, we should replace the join column with COALESCE as described by SQL spec. This is a cleaner  solution then solution 1) because it takes care of all the problem cases but it can cause existing queries with group by using table name for association for join columns will stop working and will have to be rewritten. &lt;/p&gt;

&lt;p&gt;I lean towards solution 2) for it&apos;s cleanliness and direct implementation of SQL spec COALESCE behavior for join columns but I am interested to know what are the community&apos;s thoughts on this.&lt;/p&gt;</comment>
                            <comment id="13185752" author="mikem" created="Fri, 13 Jan 2012 18:57:01 +0000"  >&lt;p&gt;So far you have added a number of tests, and some of the comments seem to indicate some of the tests&lt;br/&gt;
are coded so they pass, but that they are actually exhibiting the wrong behavior.  I find this confusing, but&lt;br/&gt;
know you prefer this methodology.  Could you at least make it clearer in the test comments somehow which&lt;br/&gt;
of the test cases are actually bugs.&lt;/p&gt;</comment>
                            <comment id="13185764" author="mikem" created="Fri, 13 Jan 2012 19:07:42 +0000"  >&lt;p&gt;I am concerned by the performance characteristics of you proposed solution #2.  Could you go into more detail on what it involves and what&lt;br/&gt;
set of queries it will affect.  I am most interested in what happens at execution time for a large join.  I think my most basic question is in a &lt;br/&gt;
1 to 1 million row join will you be adding 1 million new function calls for the coalesce, or is this somehow optimized after bind?  I am assuming&lt;br/&gt;
that the reason the code does not currently do an explicit coalesce already is an optimization, where it was assumed the implementation &lt;br/&gt;
behavior would match the external behavior that the spec is describing.&lt;/p&gt;

&lt;p&gt;Solution 1 seems safer to me, and if implemented we should log the SQL syntax problems you have uncovered in a separate JIRA.  &lt;/p&gt;

&lt;p&gt;Also can you explicitly give some queries that currently work today that will not after your change, so that the compatibility impact of your&lt;br/&gt;
solutions can be understood.  Do those queries return correct results?  Once you list a few of these queries maybe we can try them on other&lt;br/&gt;
platforms to verify that they are incorrect SQL.  &lt;/p&gt;</comment>
                            <comment id="13185859" author="mamtas" created="Fri, 13 Jan 2012 21:14:31 +0000"  >&lt;p&gt;Revision 1231296 has addressed Mike&apos;s concern about the tests. The commit comment was as follows&lt;br/&gt;
******************************&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4631&quot; title=&quot;Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4631&quot;&gt;&lt;del&gt;DERBY-4631&lt;/del&gt;&lt;/a&gt; Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&lt;/p&gt;

&lt;p&gt;Adding comments to some of the tests, stating that Derby is allowing incorrect behavior because of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4631&quot; title=&quot;Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4631&quot;&gt;&lt;del&gt;DERBY-4631&lt;/del&gt;&lt;/a&gt;. Once the jira is fixed, these tests should start failing and would need to be changed to show the correct behavior.&lt;br/&gt;
******************************&lt;/p&gt;</comment>
                            <comment id="13187090" author="mamtas" created="Mon, 16 Jan 2012 19:05:55 +0000"  >&lt;p&gt;Here are answers to some of Mike&apos;s comments&lt;br/&gt;
********************************************************&lt;br/&gt;
Mike&apos;s comment&lt;br/&gt;
I am concerned by the performance characteristics of you proposed solution #2. Could you go into more detail on what it involves and what set of queries it will affect&lt;br/&gt;
********************************************************&lt;br/&gt;
As part of solution #2, I am proposing that during the bind phase, we are going through the join query&apos;s column list, we replace the join column in the list with coalesce function and make sure that newly added coalesce node to the select list gets bound. This node will generate a call to following method in DataTypejava&lt;br/&gt;
	public DataValueDescriptor coalesce(DataValueDescriptor[] argumentsList, DataValueDescriptor returnValue)&lt;br/&gt;
						throws StandardException&lt;br/&gt;
	{&lt;br/&gt;
		// arguments list should have at least 2 arguments&lt;br/&gt;
		if (SanityManager.DEBUG)&lt;/p&gt;
		{
			SanityManager.ASSERT(argumentsList != null,
				&quot;argumentsList expected to be non-null&quot;);
			SanityManager.ASSERT(argumentsList.length &amp;gt; 1,
				&quot;argumentsList.length expected to be &amp;gt; 1&quot;);
		}

&lt;p&gt;		/* Walk the arguments list until we find a non-null value. Otherwise we will return null&lt;br/&gt;
		 */&lt;br/&gt;
		int index;&lt;br/&gt;
		for (index = 0; index &amp;lt; argumentsList.length; index++)&lt;br/&gt;
		{&lt;br/&gt;
			if (!(argumentsList&lt;span class=&quot;error&quot;&gt;&amp;#91;index&amp;#93;&lt;/span&gt;.isNull()))&lt;/p&gt;
			{
				returnValue.setValue(argumentsList[index]);
				return returnValue;
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;		returnValue.setToNull();&lt;br/&gt;
		return returnValue;&lt;/p&gt;

&lt;p&gt;	}&lt;br/&gt;
In our case, there will always be only 2 arguments to the coalesce function and the first non-null value will have us return with that value from the method and if for some reason, if both the values are null, then we will return null value. All this work will be done for joins using NATURAL JOINS or USING clause which can happen for inner joins, left outer join and right outer joins. eg of each of these kind of joins&lt;br/&gt;
CREATE TABLE derby4631_t1(x varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t1 VALUES &apos;A&apos;,&apos;B&apos;;&lt;br/&gt;
CREATE TABLE derby4631_t2(x varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t2 VALUES &apos;b&apos;,&apos;c&apos;;&lt;/p&gt;

&lt;p&gt;SELECT x FROM derby4631_t2 NATURAL INNER JOIN derby4631_t1;&lt;br/&gt;
SELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;&lt;br/&gt;
SELECT x FROM derby4631_t2 NATURAL LEFT OUTER JOIN derby4631_t1;&lt;br/&gt;
select x from derby4631_t2 INNER JOIN derby4631_t1 USING&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;
select x from derby4631_t2 RIGHT OUTERJOIN derby4631_t1 USING&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;
select x from derby4631_t2 LEFT OUTERJOIN derby4631_t1 USING&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/p&gt;

&lt;p&gt;Currently, at execution time, Derby already does special handling to figure out if it is dealing with left outer join or right outer join and based on that, it determines whether it should pick up the value from the left column or the right column in the merged row(consisting of 2 columns, join column from left and join column from right) for each of the join columns. Instead of this, now we will let coalesce pick up &lt;br/&gt;
1)the left column&apos;s value if it is not null. If it is null then&lt;br/&gt;
2)pick up the right column&apos;s value if it is not null. If it is null then simply return null.&lt;/p&gt;

&lt;p&gt;So, there is special code happening with both the existing Derby behavior and proposed Derby behavior but at this point, I am not sure how much more/same/less performance impact the new changes might cause. This is all in theory at this point. I have never worked on the code to replace a user supplied column from the select list with another kind of node at bind time, so if we do decide to go this path, I will be greatful to have community&apos;s knowledge on this kind of change. I will work on it my own too to figure out what needs to be done if we decide to go with this solution.&lt;/p&gt;

&lt;p&gt;********************************************************&lt;br/&gt;
Mike&apos;s comment&lt;br/&gt;
I am assuming that the reason the code does not currently do an explicit coalesce already is an optimization, where it was assumed the implementation behavior would match the external behavior that the spec is describing, &lt;br/&gt;
********************************************************&lt;br/&gt;
You are probably right Mike, but I am not sure if coalesce functionality was available in Derby when joins were implemented. It could very well be that we had coalesce available but we didn&apos;t use it for optimization reasons but I just wanted to raise that it might be a possibility that we never have had coalesce available.&lt;/p&gt;</comment>
                            <comment id="13187453" author="mamtas" created="Tue, 17 Jan 2012 05:09:13 +0000"  >&lt;p&gt;*********************************************************************&lt;br/&gt;
Mike&apos;s comment&lt;br/&gt;
(With solution 2) I think my most basic question is in a 1 to 1 million row join will you be adding 1 million new function calls for the coalesce, or is this somehow optimized after bind?&lt;br/&gt;
*********************************************************************&lt;/p&gt;

&lt;p&gt;Yes, if the join column is part of the join query (say as SELECT list or GROUP BY, WHERE clause etc), then we will be calling it for every qualified row in join. At this point, I think if join column is only part of USING clause or used internally through NATURAL join to do equi join, then I do not think we will have to generate coalesce function for the join columns.&lt;/p&gt;

&lt;p&gt;I debugged through the existing code more and found that to do equijoin for USING clause or NATURAL join, we generate merged row which includes the necessary join columns values from both sides (for USING clause, the necessary join column(s) will be what was specified with the USING clause, for NATURAL joins, it will be all the join columns). If we find that the join column is getting referenced outside of the equi join, then in order to get the join column&apos;s value, we do the mapping of the join column to the merged row&apos;s column (the mapping happens to either the left table&apos;s column value in merged row(if we are dealing with inner join or left outer join) or to the right table&apos;s column value(if we are dealing with right outer join)).&lt;/p&gt;

&lt;p&gt;If we go with Solution 1), then this mapping of join column to merge row will need to change so that we look at teft table&apos;s column value first. If it is null, then we should pick up the right table&apos;s column value. This should happen no matter if we are dealing with inner join, left outer join or right outer join with natural or uisng clause.&lt;/p&gt;</comment>
                            <comment id="13187459" author="mamtas" created="Tue, 17 Jan 2012 05:30:46 +0000"  >&lt;p&gt;********************************************************&lt;br/&gt;
Mike&apos;s comment&lt;br/&gt;
Also can you explicitly give some queries that currently work today that will not after your change, so that the compatibility impact of your solutions can be understood&quot;.&lt;br/&gt;
********************************************************&lt;br/&gt;
Following queries will be fixed by both the solutions.&lt;br/&gt;
java -Dij.exceptionTrace=true org.apache.derby.tools.ij&lt;br/&gt;
connect &apos;jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY&apos;; &lt;br/&gt;
CREATE TABLE derby4631_t1(x varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t1 VALUES &apos;A&apos;,&apos;B&apos;;&lt;br/&gt;
CREATE TABLE derby4631_t2(x varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t2 VALUES &apos;b&apos;,&apos;c&apos;;&lt;br/&gt;
SELECT x, coalesce(derby4631_t2.x, derby4631_t1.x) FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;&lt;br/&gt;
select x, coalesce(derby4631_t2.x, derby4631_t1.x) from derby4631_t2 RIGHT OUTER JOIN derby4631_t1 USING&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/p&gt;

&lt;p&gt;The 2 select queries above return following today(which is incorrect)&lt;br/&gt;
X    |2&lt;br/&gt;
-----------&lt;br/&gt;
A    |A&lt;br/&gt;
B    |b&lt;br/&gt;
2 rows selected&lt;/p&gt;

&lt;p&gt;With both the solutions proposed in this jira, they will return following(correct results)&lt;br/&gt;
X    |2&lt;br/&gt;
-----------&lt;br/&gt;
A    |A&lt;br/&gt;
b    |b&lt;br/&gt;
2 rows selected&lt;/p&gt;

&lt;p&gt;Additionally, each of the 2 proposed solutions affect few other queries, but unfortunately not the same way.&lt;/p&gt;

&lt;p&gt;Here is example query that will be affected by solution 1).&lt;br/&gt;
SELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1 group by derby4631_t1.x;&lt;br/&gt;
Since join column x can have different results with solution 1(compared to existing behavior), the group by query below will result in different results too. This is kind of obvious but still wanted to point out how different results for join columns can affect join queries with group by/having clause etc&lt;/p&gt;

&lt;p&gt;With solution 2), the group by query above will fail because column derby4631_t1.x is not part of the SELECT columns list. With solution 2), join column x is not going to be assoicated with left table(in case of left outer join and inner joins) or right table(in case of right outer join). Because of that, the group by will result in compilation error but column derby4631_t1.x is not in the SELECT list.&lt;/p&gt;</comment>
                            <comment id="13188739" author="mamtas" created="Wed, 18 Jan 2012 22:10:22 +0000"  >&lt;p&gt;With solution 1), we will need to know where the current code generation happens for join columns. Solution 1) requires that we change the code generation to following logic.&lt;br/&gt;
1)if the left table&apos;s join column value is null then pick up the right table&apos;s join column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s join column value is non-null, then pick up that value &lt;/p&gt;

&lt;p&gt;Following is what I found while looking for code generation logic for the join columns.&lt;/p&gt;

&lt;p&gt;In the bind phase of a query, we start looking at result columns and assigning virutal column numbers to them (impl.sql.compile.ResultColumn:virtualColumnId). These virtual column ids are used to find mapping for those columns into runtime resultset for the query.&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY&apos;; &lt;br/&gt;
CREATE TABLE derby4631_t1(x varchar(5)); &lt;br/&gt;
INSERT INTO derby4631_t1 VALUES &apos;A&apos;,&apos;B&apos;; &lt;br/&gt;
CREATE TABLE derby4631_t2(x varchar(5)); &lt;br/&gt;
INSERT INTO derby4631_t2 VALUES &apos;b&apos;,&apos;c&apos;; &lt;br/&gt;
SELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1; &lt;/p&gt;

&lt;p&gt;For the NATURAL JOIN query above, an equi-join is generated which will be derby4631_t2.x = derby4631_t1.x. For this equi join, the join column x from left table(derby4631_t2) will get virtual column id of 1 and join column x from right table(derby4631_t1) will get virtual column id of 2. The column x in the SELECT query in Derby today gets associated with right table in case of RIGHT OUTER JOIN and hence that column&apos;s virtual column id is also 2. At the time of code generation, we use this information to decide what column position from the run time resultset would be used to get the values. Following is the stack trace of where the code generation for join column happens.&lt;/p&gt;

&lt;p&gt;Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 1421 in ProjectRestrictNode))	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1421	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1334	&lt;br/&gt;
	ScrollInsensitiveResultSetNode.generate(ActivationClassBuilder, MethodBuilder) line: 109	&lt;br/&gt;
	CursorNode.generate(ActivationClassBuilder, MethodBuilder) line: 641	&lt;br/&gt;
	CursorNode(StatementNode).generate(ByteArray) line: 345	&lt;br/&gt;
	GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 518	&lt;br/&gt;
	GenericStatement.prepare(LanguageConnectionContext, boolean) line: 97	&lt;br/&gt;
	GenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 1103	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 610	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String) line: 559	&lt;br/&gt;
	ij.executeImmediate(String) line: 367	&lt;br/&gt;
	utilMain.doCatch(String) line: 527	&lt;br/&gt;
	utilMain.runScriptGuts() line: 369	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput) line: 245	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput) line: 229	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 184	&lt;br/&gt;
	Main.main(String[]) line: 75	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;</comment>
                            <comment id="13191280" author="mamtas" created="Mon, 23 Jan 2012 17:32:15 +0000"  >&lt;p&gt;The code generation code in impl.sql.compile.ConditionalNode:generateExpression might be a good resource for us to make make the code generation changes for NATURAL JOIN&apos;s join column in the SELECT query. ConditionalNode generates &quot;if then else&quot; code which is similar to what solution 1) will require, ie if lefTablJoinColumn is null, then use rightTableJoinColumnValue else use leftTableJoinColumnValue.&lt;/p&gt;</comment>
                            <comment id="13191655" author="mamtas" created="Tue, 24 Jan 2012 00:07:26 +0000"  >&lt;p&gt;I stepped through the ConditionalNode&apos;s code generation logic to see how &quot;if..then..else..&quot; code is generated. Based on that, I have following pseudo code for code generation for solution 1). The following psuedo code is for generating if(lefTablJoinColumnValue is null) then return rightTableJoinColumnValue else return lefTablJoinColumnValue. I have not done recent work in the code generation part and would appreciate feedback if the psuedo code looks incorrect. I will next work on trying to identify how to make this pseudo code kick in for ResultColumn code generation if we are dealing with join column.&lt;/p&gt;

&lt;p&gt;		String	receiverType = ClassName.DataValueDescriptor;&lt;br/&gt;
		String resultTypeName = &lt;br/&gt;
			getTypeCompiler(DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN).getTypeId()).interfaceName();&lt;/p&gt;

&lt;p&gt;		//Following will generate if(lefTablJoinColumnValue is null)&lt;br/&gt;
		//Then call generateExpression on left Table&apos;s column&lt;br/&gt;
		LeftTableColumn.generateExpression(acb, mb);			&lt;br/&gt;
		mb.cast(receiverType); // cast the method instance&lt;br/&gt;
		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,&lt;br/&gt;
			&quot;isNullOp&quot;,resultTypeName, 0);&lt;br/&gt;
		mb.cast(ClassName.BooleanDataValue);&lt;br/&gt;
		mb.push(true);&lt;br/&gt;
		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, &quot;equals&quot;, &quot;boolean&quot;, 1);&lt;/p&gt;

&lt;p&gt;		//Following will generate then part of the if condition by generating expression for rightTablJoinColumnValue&lt;br/&gt;
		mb.conditionalIf();&lt;br/&gt;
		  ((ValueNode) RightTableColumn.generateExpression(acb, mb);&lt;br/&gt;
		//Following will generate else part of the if condition by generating expression for lefTablJoinColumnValue &lt;br/&gt;
		mb.startElseCode();&lt;br/&gt;
		  ((ValueNode) LeftTableColumn.generateExpression(acb, mb);&lt;br/&gt;
		mb.completeConditional();&lt;/p&gt;</comment>
                            <comment id="13196694" author="mamtas" created="Tue, 31 Jan 2012 04:39:10 +0000"  >&lt;p&gt;I have a patch which is not ready for commit. It is a work in progress for the solution 1) proposed earlier in the jira which is as follows&lt;br/&gt;
Solution 1) requires that we change the code generation to following logic. &lt;br/&gt;
1)if the left table&apos;s join column value is null then pick up the right table&apos;s join column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s join column value is non-null, then pick up that value &lt;br/&gt;
We should have the solution 1) kickin for only RIGHT OUTER JOIN with USING clause or NATURAL JOIN. &lt;br/&gt;
LEFT OUTER JOINs and INNER JOINs with USING clause or NATURAL JOIN will work correctly with current Derby logic which is to always pickup the left table&apos;s join column value. &lt;br/&gt;
This will work for LEFT OUTER JOINs and INNER JOINs with USING clause or NATURAL JOIN in both territory and non-territory based databases&lt;/p&gt;


&lt;p&gt;The attached patch now makes the following query return the correct results&lt;br/&gt;
java -Dij.exceptionTrace=true org.apache.derby.tools.ij &lt;br/&gt;
connect &apos;jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY&apos;; &lt;br/&gt;
CREATE TABLE derby4631_t1(x varchar(5)); &lt;br/&gt;
INSERT INTO derby4631_t1 VALUES &apos;A&apos;,&apos;B&apos;; &lt;br/&gt;
CREATE TABLE derby4631_t2(x varchar(5)); &lt;br/&gt;
INSERT INTO derby4631_t2 VALUES &apos;b&apos;,&apos;c&apos;; &lt;br/&gt;
SELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1; &lt;br/&gt;
ij&amp;gt; X&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A&lt;br/&gt;
b&lt;/p&gt;

&lt;p&gt;The patch in it&apos;s current state is quite a bit of hacking because currently a ResultColumn does not need to know if it belongs to a Join ResultSet. But with solution 1), if ResultColumn is a join column part of a RIGHT OUTER JOIN with USING/NATURAL JOIN, then we want the join column&apos;s value to be determined using the solution 1) described above. For that, a ResultColumn will now need to know if it is part of a RIGHT OUTER JOIN with USING/NATURAL JOIN and it will need to know the column positions of the left table&apos;s&lt;br/&gt;
join column and rigt table&apos;s join colunm and it will need to know the resultset number of the resultset from which these join colunms&apos;s values will be extracted. &lt;/p&gt;

&lt;p&gt;I get these values in this patch by putting extra information related to joins in ResultColunm at bind time and using them at code generation time.&lt;/p&gt;

&lt;p&gt;This patch may break many other queries and I will continue to work on the patch to make it more stable but I wanted to put the general approach for this solution out sooner than later to see if community has any feedback on keeping the extra information on ResultColumn needed to implement solution 1). Although, all this additional information maintenance is pretty localized and not many files are impacted by this solution. &lt;/p&gt;

&lt;p&gt;Next I plan to work on the patch more to make it stable and do more testing with it to see how it will work for the rest of the queries. &lt;/p&gt;

&lt;p&gt;Alternative to this approach would be to introduce a new kind of compilation node which will be created during the bind phase(unlike most nodes which get created during parsing) when we find that the ResultColumn belongs to Join Node(which means we will still have to do the checking I do in this patch to see if ResultColumn is part of RIGHT OUTER JOIN with USING/NATURAL JOIN but at code generation time, &lt;br/&gt;
we can have the new node do this special code generation which is how we handle all the other special nodes like Conditional If node, Coalesce node etc). This approach of adding new node will require us to somehow fire the binding of the new node after replacing the ResultColumn which was created during the Parse time. At this point, I am unfamiliar with how to replace a node during the bind time with some other node and make it go through the binding step. Also, replacing the ResultColumn with a new node might also impact queries like following where I think order by column from right table is associated with the join column in the select list&lt;br/&gt;
SELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1 ORDER BY derby4631_t1.x; &lt;/p&gt;


&lt;p&gt;The files changed by this patch are as follows&lt;br/&gt;
$ svn stat -q&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\ResultColumn.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\ProjectRestrictNode.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\JoinNode.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\ResultColumnList.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\HashTableNode.java&lt;/p&gt;

&lt;p&gt;Following explains the changes in brief for the files touched by this patch&lt;br/&gt;
ResultColumn.java has additioanl columns to keep RIGHT OUTER JOIN with USING/NATURAL JOIN information. These&lt;br/&gt;
columns will get updated during bind time if ResultColumn is part of such a join. In my next patch, I think I should be able to remove virtualColumnIdLeftTable and virtualColumnIdRightTable and just get that information&lt;br/&gt;
from joinResultSet. &lt;/p&gt;

&lt;p&gt;The signature of ResultColumnList.mapSourceColumns has changed and hence the changes in &lt;br/&gt;
ProjectRestrictNode.java and HashTableNode.java.&lt;/p&gt;

&lt;p&gt;JoinNode.java - checks if it is RIGHT OUTER JOIN with USING/NATURAL JOIN and if yes, then it marks the right &lt;br/&gt;
table&apos;s join column&apos;s ResultColumn to recognize that.&lt;/p&gt;

&lt;p&gt;ResultColumnList.java in it&apos;s code generation logic checks if the ResultColumn is a join column for RIGHT OUTER JOIN with USING/NATURAL JOIN and if yes, then it generates the following code for that column&lt;br/&gt;
1)if the left table&apos;s join column value is null then pick up the right table&apos;s join column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s join column value is non-null, then pick up that value &lt;/p&gt;

&lt;p&gt;Will appreciate any feedback on this patch. I plan to work more on it to clean it up by looking at removing some of the redundant new informaiton in ResultColumn and also to check if there is a better place for code generation for a join column part of RIGHT OUTER JOIN with USING/NATURAL JOIN. I also anticipate existing queries failing with this current patch. I will work on identifying such queries. But I wanted to get feedback on general approach of this patch.&lt;/p&gt;</comment>
                            <comment id="13198885" author="mamtas" created="Thu, 2 Feb 2012 15:45:45 +0000"  >&lt;p&gt;I cam across atleast following 2 queries that both fail with NPE and I am looking into those,&lt;/p&gt;

&lt;p&gt;create table t1(a int, b int, c int);&lt;br/&gt;
create table t2(b int, c int, d int);&lt;br/&gt;
create table t3(d int, e varchar(5), f int);&lt;/p&gt;

&lt;p&gt;insert into t1 values (1,2,3),(2,3,4),(4,4,4);&lt;br/&gt;
insert into t2 values (1,2,3),(2,3,4),(5,5,5);&lt;br/&gt;
insert into t3 values &lt;br/&gt;
                (2,&apos;abc&apos;,3),(4,&apos;def&apos;,5),(null,null,null);&lt;/p&gt;

&lt;p&gt;select c from t1 right join t2 using (c) &lt;br/&gt;
                           order by t1.c;&lt;br/&gt;
select c,a+1 from t1 right join t2 using (c);&lt;/p&gt;

&lt;p&gt;The order by query is failing in generated code whereas the query with &quot;a+1&quot; is failing during bind time. &lt;/p&gt;</comment>
                            <comment id="13202037" author="mamtas" created="Tue, 7 Feb 2012 03:09:40 +0000"  >&lt;p&gt;Attaching an updated patch which is still not ready for commit but it fixes two queries listed earlier which were failing with 1st patch, &lt;/p&gt;

&lt;p&gt;With the query using column a+1 in the select query, I was looking for field name in ResultColumn which would be null for an expression like a+1. Instead, I need to use exposedName which will not be null for an expression. Instead, we internally generate a name for such columns.&lt;/p&gt;

&lt;p&gt;With the query using order by, I found that in the new code for code generation, I need to let Derby do what it does today for ResultColumns with VirtualColumnNode underneath. Such a case can happen for order by query where we pull columns if needed for order by columns,&lt;/p&gt;

&lt;p&gt;Next I plan to make the code changes less of a hack and then run the derbyall and junit suite to see if we catch any failures. Another thing to do would be to add more RIGHT OUTER JOIN test variations to see if the suggested code changes work fine with it. I will appreciate any suggestion on what kind of RIGHT OUTER JOIN tests can be added to test the functionality.&lt;/p&gt;</comment>
                            <comment id="13208166" author="mamtas" created="Wed, 15 Feb 2012 00:57:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4631&quot; title=&quot;Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4631&quot;&gt;&lt;del&gt;DERBY-4631&lt;/del&gt;&lt;/a&gt; Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&lt;/p&gt;

&lt;p&gt;I have a patch(DERBY_4631_patch3_diff.txt) which is ready for review and commit. To recap the issue, SQL:2003 says that the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table&lt;/p&gt;

&lt;p&gt;Derby has it&apos;s on logic to retrieve the join column values. It always picks up join column&apos;s value from the left table when we are working with natural left outer join and it picks up the join column&apos;s value from the right table when we are working with natural right outer join. &lt;/p&gt;

&lt;p&gt;But this logic does not work for all cases for right outer join. The fix provided in this patch will pick the join column&apos;s value based on following logic(this logic mimics the functionality of COALESCE) &lt;br/&gt;
1)if the left table&apos;s column value is null then pick up the right table&apos;s column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s column value is non-null, then pick up that value &lt;/p&gt;

&lt;p&gt;Following are the files impacted by this patch&lt;br/&gt;
$ svn stat -q&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\ResultColumn.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\JoinNode.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\sql\compile\ResultColumnList.java&lt;br/&gt;
M       java\testing\org\apache\derbyTesting\functionTests\tests\lang\CollationTest.java&lt;/p&gt;

&lt;p&gt;The changes are as follows&lt;br/&gt;
Two additional fields have been added to ResultColumn.java rightOuterJoinUsingClause  and joinResultSet &lt;br/&gt;
rightOuterJoinUsingClause will be set to true for following 2 cases&lt;br/&gt;
1)if this column represents the join column which is part of the SELECT list of a RIGHT OUTER JOIN with USING/NATURAL. eg&lt;br/&gt;
 select c from t1 right join t2 using (c)&lt;br/&gt;
This case is talking about column c as in &quot;select c&quot;&lt;br/&gt;
2)if this column represents the join column from the right table for predicates generated for the USING/NATURAL of RIGHT OUTER JOIN eg&lt;br/&gt;
  select c from t1 right join t2 using (c)&lt;br/&gt;
For &quot;using(c)&quot;, a join predicate will be created as follows&lt;br/&gt;
   t1.c=t2.c&lt;br/&gt;
This case is talking about column t2.c of the join predicate.&lt;/p&gt;

&lt;p&gt;joinResultSet will be non-null for the case 1) above. It will show the association of this result column to the join resultset created for the RIGHT OUTER JOIN with USING/NATURAL. This information along with rightOuterJoinUsingClause will be used during the code generation time.&lt;br/&gt;
These 2 additional fields will be used to identify ResultColumn which belong to a join column in the SELECT&lt;br/&gt;
list and identify ResultColumn which belong to right join column for the predicate generated for USING/NATURAL&lt;br/&gt;
columns. Additionally, ResultColumn which belong to a join column in the SELECT list will also know about the&lt;br/&gt;
JoinNode which they belong to. These 2 pieces of information will then be used at the code generation time&lt;br/&gt;
for join column for RIGHT OUTER JOIN with USING/NATURAL based on following logic&lt;br/&gt;
1)if the left table&apos;s column value is null then pick up the right table&apos;s column&apos;s value.&lt;br/&gt;
2)If the left table&apos;s column value is non-null, then pick up that value &lt;/p&gt;

&lt;p&gt;Changes in JoinNode.java just identifies the ResultColumn which represent the join column from the right table &lt;br/&gt;
for predicates generated for the USING/NATURAL of RIGHT OUTER JOIN eg&lt;br/&gt;
     select c from t1 right join t2 using (c)&lt;br/&gt;
For &quot;using(c)&quot;, a join predicate will be created, t1.c=t2.c. JoinNode changes will set &lt;br/&gt;
ResultColumn.rightOuterJoinUsingClause flag to true for t2.c&lt;/p&gt;

&lt;p&gt;The code generation changes have gone into ResultColumnList.java&lt;/p&gt;
</comment>
                            <comment id="13212276" author="mamtas" created="Tue, 21 Feb 2012 01:19:40 +0000"  >&lt;p&gt;I have been working on writing more tests for JOINs to see nothing breaks with my changes. Unfortunately, the following script with the patch DERBY_4631_patch3_diff.txt patch gives  ERROR 38000: The exception &apos;java.lang.ArrayIndexOutOfBoundsException: Array index out of range: -2&apos; was thrown while evaluating an expression.&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY&apos;; &lt;br/&gt;
CREATE TABLE derby4631_t1(x varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t1 VALUES &apos;A&apos;,&apos;B&apos;;&lt;br/&gt;
CREATE TABLE derby4631_t2(x varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t2 VALUES &apos;b&apos;,&apos;c&apos;;&lt;br/&gt;
CREATE TABLE derby4631_t3(x1 varchar(5), y1 varchar(5));&lt;br/&gt;
INSERT INTO derby4631_t3 &lt;br/&gt;
        		SELECT x, &lt;br/&gt;
        		&apos;a&apos;&lt;br/&gt;
          		FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;&lt;/p&gt;

&lt;p&gt;I am debugging the patch to see what is causing the failure.&lt;/p&gt;</comment>
                            <comment id="13214345" author="mamtas" created="Thu, 23 Feb 2012 06:01:23 +0000"  >&lt;p&gt;I found the problem which was causing array index out of bound exception with the previous patch(patch 3).&lt;/p&gt;

&lt;p&gt;The query which was throwing the exception is as follows&lt;br/&gt;
INSERT INTO derby4631_t3&lt;br/&gt;
                       SELECT x,&lt;br/&gt;
                       &apos;a&apos;&lt;br/&gt;
                       FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;&lt;/p&gt;

&lt;p&gt;The columns in derby4631_t3 are named x1 and y1. The source for column x1 in insert above is join column x. In the patch, when we look to determine if the column is a join column, I was looking at column&apos;s external name rather than it&apos;s base name. So instead of looking for column named &apos;x&apos;, the earlier patch was looking for column &apos;x1&apos; to see if it is a join column. Because of that, it didn&apos;t identify join column x in the SELECT query. I have fixed one line of code in ResultColumnList to fix the problem. So, instead of &lt;br/&gt;
if (joinColumn.getName().equals(rc.getName())) {&lt;br/&gt;
it now checks&lt;br/&gt;
if (joinColumn.getName().equals(rc.name)) {&lt;/p&gt;

&lt;p&gt;I will run the derbyall and junit suite to make sure no existing tests fail with this new patch. I will also continue writing few more tests for JOINs.&lt;/p&gt;</comment>
                            <comment id="13214878" author="mikem" created="Thu, 23 Feb 2012 17:44:48 +0000"  >&lt;p&gt;from review of latest patch.  &lt;/p&gt;

&lt;p&gt;ResultColumn:&lt;br/&gt;
It would be good to get a review of this with someone with more expertise in this area of the code.  The placement&lt;br/&gt;
of the code at 672 just seems strange given how simple the logic use to be.  There is a lot of checking for instances&lt;br/&gt;
here, is there anyway to do this work in the affected nodes like HalfOuterJoinNode.&lt;/p&gt;

&lt;p&gt;At end of ResultColumn changes why do you check and set for one of the new fields and not the other?&lt;br/&gt;
+       if (isRightOuterJoinUsingClause()) &lt;/p&gt;
{
+           newResultColumn.setRightOuterJoinUsingClause(true);
+       }
&lt;p&gt;+&lt;br/&gt;
+       newResultColumn.setJoinResultset(getJoinResultSet());&lt;br/&gt;
+&lt;/p&gt;

&lt;p&gt;ResultColumnList.java:&lt;br/&gt;
1266: get rid of the commented out line of code that you fixed with patch 4&lt;/p&gt;

&lt;p&gt;a comment in allExpressionsAreColumns explaining why returning false for isRightOuterJoinUsingClause would be useful.&lt;/p&gt;

&lt;p&gt;in mapSourceColumns() what does the -1 for right outer join columns mean?  &lt;/p&gt;

&lt;p&gt;nits:&lt;br/&gt;
typo - search for &quot;righ &quot;&lt;br/&gt;
would be nice to have comments for setJoinResultset and setRightOuterJoinUsingClause, maybe something about what is expected&lt;br/&gt;
to call this routine and in what circumstances.&lt;br/&gt;
would be nice if code was 80 columns, critical bug at line 672 of ResultColumn is unreadable at 80.&lt;/p&gt;

&lt;p&gt;JoinNode change:&lt;br/&gt;
inconsistent bracket use in if/then/else&lt;/p&gt;

&lt;p&gt;ResultColumnList:&lt;br/&gt;
more &amp;gt; 80 lines&lt;/p&gt;

&lt;p&gt;indentation looks wrong for this code, maybe editor got confused by commented out if block:&lt;br/&gt;
                        if (joinColumn.getName().equals(rc.name)) &lt;/p&gt;
{
                                if (joinColumn.isRightOuterJoinUsingClause())
                                    virtualColumnIdRightTable = joinColumn.getVirtualColumnId();
                                else
                                    virtualColumnIdLeftTable = joinColumn.getVirtualColumnId();
                        }</comment>
                            <comment id="13218807" author="mamtas" created="Wed, 29 Feb 2012 01:28:46 +0000"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;thanks for reviewing patch 4. Here are some comments to your feedback(Attaching a new patch DERBY_4631_patch5_diff.txt which takes care of some of your comments.)&lt;/p&gt;

&lt;p&gt;1)ResultColumn:&lt;br/&gt;
********&lt;br/&gt;
Mike&apos;s comment - There is a lot of checking for instances here, is there anyway to do this work in the affected nodes like HalfOuterJoinNode?&lt;br/&gt;
********&lt;br/&gt;
Yes, I am concerned about the instance checking too but I had researched into putting the code in HalfOuterJoinNode and found that HalfOuterJoinNode does not ever get to see the ResultColumns for the query and hence it has no way of marking those ResultColumns as join columns.&lt;/p&gt;

&lt;p&gt;********&lt;br/&gt;
Mike&apos;s comment - At end of ResultColumn changes why do you check and set for one of the new fields and not the other?&lt;br/&gt;
********&lt;br/&gt;
I was trying to follow the existing code where the boolean kinds of fields are first checked and then set to true if the check returned true. rightOuterJoinUsingClause is a boolean field and hence I checked for the return value and then set the new object&apos;s value to true. But joinResultSet is a non-boolean field and hence I simply used it&apos;s value to set new object&apos;s joinResultSet value. For clarity, I will go ahead and replace following&lt;br/&gt;
  		newResultColumn.setJoinResultset(getJoinResultSet());&lt;br/&gt;
with&lt;br/&gt;
  		if (getJoinResultSet() != null) &lt;/p&gt;
{
	  		newResultColumn.setJoinResultset(getJoinResultSet());
  		}

&lt;p&gt;2)ResultColumnList.java:&lt;br/&gt;
********&lt;br/&gt;
Mike&apos;s comment - get rid of the commented out line of code that you fixed with patch 4&lt;br/&gt;
********&lt;br/&gt;
Removed it. &lt;/p&gt;

&lt;p&gt;********&lt;br/&gt;
Mike&apos;s comment - a comment in allExpressionsAreColumns explaining why returning false for isRightOuterJoinUsingClause would be useful. &lt;br/&gt;
********&lt;br/&gt;
Added a comment.&lt;/p&gt;

&lt;p&gt;********&lt;br/&gt;
Mike&apos;s comment - in mapSourceColumns() what does the -1 for right outer join columns mean? &lt;br/&gt;
********&lt;br/&gt;
allExpressionsAreColumns() uses the -1 value set by mapSourceColumns() to decide if there are columns which require special consideration during code generation. When mapSourceColumns() assigns -1 to right outer join column, allExpressionsAreColumns() will return false. This will allow Derby to later generate code equivalent to COASLECE for right outer join columns(this code generation happens in newly added code in ResultColumnList.generateCore.)&lt;/p&gt;

&lt;p&gt;********&lt;br/&gt;
Mike&apos;s comment - typo - search for &quot;righ &quot; &lt;br/&gt;
********&lt;br/&gt;
Fixed it.&lt;/p&gt;

&lt;p&gt;********&lt;br/&gt;
Mike&apos;s comment - would be nice to have comments for setJoinResultset and setRightOuterJoinUsingClause, maybe something about what is expected to call this routine and in what circumstances. &lt;br/&gt;
********&lt;br/&gt;
Added comments around for both those methods.&lt;/p&gt;

&lt;p&gt;Additionally, took care of some indentation problems with the code.&lt;/p&gt;</comment>
                            <comment id="13221108" author="mamtas" created="Fri, 2 Mar 2012 18:04:14 +0000"  >&lt;p&gt;I have the final patch which is ready for commit. I have added couple more tests &lt;br/&gt;
1)have left or right table empty before doing joins &lt;br/&gt;
2)Do arithmetic operation on join columns.&lt;/p&gt;

&lt;p&gt;I will commit it in a week&apos;s time but will appreciate any feedback on the patch before that.&lt;/p&gt;</comment>
                            <comment id="13230601" author="mamtas" created="Thu, 15 Mar 2012 21:55:26 +0000"  >&lt;p&gt;Attaching the release note for the issue&lt;/p&gt;</comment>
                            <comment id="13231656" author="mamtas" created="Fri, 16 Mar 2012 21:40:51 +0000"  >&lt;p&gt;I am attaching another patch (DERBY_4631_patch7_diff.txt) which is very similar to previous patch(DERBY_4631_patch6_diff.txt) except that I do not have instance of checks in ResultColumn to find JoinNodes from the FromList. Instead, I have added a new method isJoinColumnForRightOuterJoin which will allow HalfOuterJoinNode to see if the ResultColumn is a join column for a right outer join with using/natural clause. This makes the code more readable and removes the instanceof checkings. Please let me know if there are any comments to this patch. Thanks&lt;/p&gt;</comment>
                            <comment id="13280490" author="mamtas" created="Mon, 21 May 2012 22:03:46 +0100"  >&lt;p&gt;Committed(revision 1341204) changes for this jira with following comments&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4631&quot; title=&quot;Wrong join column returned by right outer join with NATURAL or USING and territory-based collation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4631&quot;&gt;&lt;del&gt;DERBY-4631&lt;/del&gt;&lt;/a&gt; Wrong join column returned by right outer join with NATURAL or USING and territory-based collation &lt;/p&gt;

&lt;p&gt;To recap this issue, SQL:2003 says that the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table &lt;/p&gt;

&lt;p&gt;Derby has it&apos;s on logic to retrieve the join column values. It always picks up join column&apos;s value from the left table when we are working with natural left outer join and it picks up the join column&apos;s value from the right table when we are working with natural right outer join. &lt;/p&gt;

&lt;p&gt;But this logic does not work for all cases for right outer join. The fix provided in this patch will pick the join column&apos;s value based on following logic(this logic mimics the functionality of COALESCE) &lt;br/&gt;
1)if the left table&apos;s column value is null then pick up the right table&apos;s column&apos;s value. &lt;br/&gt;
2)If the left table&apos;s column value is non-null, then pick up that value &lt;/p&gt;</comment>
                            <comment id="13453375" author="kmarsden" created="Tue, 11 Sep 2012 21:27:48 +0100"  >&lt;p&gt;Reopen for backport analysis. Temporarily assign to yourself if you backport and then reassign to Mamta before closing.&lt;/p&gt;</comment>
                            <comment id="13455145" author="mamtas" created="Thu, 13 Sep 2012 20:02:12 +0100"  >&lt;p&gt;I will work on backporting this issue&lt;/p&gt;</comment>
                            <comment id="13455567" author="mamtas" created="Fri, 14 Sep 2012 05:30:38 +0100"  >&lt;p&gt;Backported to 10.8 with revision 1384638&lt;/p&gt;</comment>
                            <comment id="13455861" author="mamtas" created="Fri, 14 Sep 2012 16:22:44 +0100"  >&lt;p&gt;Backported to 10.7 with revision 1384814&lt;/p&gt;</comment>
                            <comment id="13456185" author="mamtas" created="Fri, 14 Sep 2012 22:55:45 +0100"  >&lt;p&gt;Backported to 10.6 with revision 1384940.&lt;/p&gt;</comment>
                            <comment id="13456193" author="mamtas" created="Fri, 14 Sep 2012 23:20:20 +0100"  >&lt;p&gt;No further backporting required because NATURAL/USING clause on join queries was added in 10.6&lt;/p&gt;</comment>
                            <comment id="13456194" author="mamtas" created="Fri, 14 Sep 2012 23:20:42 +0100"  >&lt;p&gt;Backport finished&lt;/p&gt;</comment>
                            <comment id="13488934" author="mamtas" created="Thu, 1 Nov 2012 19:01:34 +0000"  >&lt;p&gt;Attaching release note&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12542441">DERBY-5613</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                                                <inwardlinks description="is required by">
                                        <issuelink>
            <issuekey id="12607119">DERBY-5923</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12512530" name="DERBY_4631_not_for_commit_patch1_diff.txt" size="11415" author="mamtas" created="Tue, 31 Jan 2012 04:39:10 +0000"/>
                            <attachment id="12512531" name="DERBY_4631_not_for_commit_patch1_stat.txt" size="373" author="mamtas" created="Tue, 31 Jan 2012 04:39:10 +0000"/>
                            <attachment id="12513563" name="DERBY_4631_not_for_commit_patch2_diff.txt" size="13536" author="mamtas" created="Tue, 7 Feb 2012 03:09:39 +0000"/>
                            <attachment id="12513564" name="DERBY_4631_not_for_commit_patch2_stat.txt" size="463" author="mamtas" created="Tue, 7 Feb 2012 03:09:39 +0000"/>
                            <attachment id="12514584" name="DERBY_4631_patch3_diff.txt" size="17348" author="mamtas" created="Wed, 15 Feb 2012 00:57:01 +0000"/>
                            <attachment id="12514585" name="DERBY_4631_patch3_stat.txt" size="309" author="mamtas" created="Wed, 15 Feb 2012 00:57:01 +0000"/>
                            <attachment id="12515709" name="DERBY_4631_patch4_diff.txt" size="11570" author="mamtas" created="Thu, 23 Feb 2012 06:01:23 +0000"/>
                            <attachment id="12516491" name="DERBY_4631_patch5_diff.txt" size="13514" author="mamtas" created="Wed, 29 Feb 2012 01:28:45 +0000"/>
                            <attachment id="12516867" name="DERBY_4631_patch6_diff.txt" size="47931" author="mamtas" created="Fri, 2 Mar 2012 18:04:14 +0000"/>
                            <attachment id="12518740" name="DERBY_4631_patch7_diff.txt" size="49690" author="mamtas" created="Fri, 16 Mar 2012 21:40:51 +0000"/>
                            <attachment id="12551745" name="releaseNote.html" size="3539" author="mamtas" created="Thu, 1 Nov 2012 19:01:34 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10367"><![CDATA[Deviation from standard]]></customfieldvalue>
    <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 20 Jul 2010 17:52:49 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24378</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy09wv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35424</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>