<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:22:45 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3872/DERBY-3872.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3872] NullPoinerException thrown when INTEGER function used as a predicate in a WHERE clause of a SELECT .. GROUP BY ..  HAVING statement</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3872</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Use attached SQL script to create two tables , execute the following SQL and throw the exception and stack trace below.  NOTE:  removing the &apos;always true&apos; clause &apos;.. ( integer (1.1) = 1) ..&quot; from the SQL and the query does not fail.  Releated??&lt;/p&gt;

&lt;p&gt;select  q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 where  ( integer (1.1) = 1)  and  ( q2.&quot;DEPT_DEPTNO&quot; =  q1.&quot;DEPTNO&quot;)  &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; &lt;br/&gt;
HAVING  max( q2.&quot;SALARY&quot;) &amp;gt;=  ( select  q3.&quot;SALARY&quot; from EMPTAB q3 where  ( q3.&quot;EMPID&quot; =  q1.&quot;DEPTNO&quot;) ) &lt;/p&gt;

&lt;p&gt;ERROR 38000: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.&lt;br/&gt;
. . .derby.iapi.error.StandardException.newException&lt;br/&gt;
. . .derby.iapi.error.StandardException.unexpectedUserException&lt;br/&gt;
. . .derby.impl.services.reflect.DirectCall.invoke&lt;br/&gt;
. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow&lt;br/&gt;
. . .derby.impl.jdbc.EmbedResultSet.movePosition&lt;br/&gt;
. . .derby.impl.jdbc.EmbedResultSet.next&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.DisplayResults&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.displayResult&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.doCatch&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.runScriptGuts&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.go&lt;br/&gt;
. . .derby.impl.tools.ij.Main.go&lt;br/&gt;
. . .derby.impl.tools.ij.Main.mainCore&lt;br/&gt;
. . .derby.impl.tools.ij.Main14.main&lt;br/&gt;
. . .derby.tools.ij.main&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
. . .derby.iapi.types.NumberDataType.compare&lt;br/&gt;
. . .derby.impl.store.access.btree.ControlRow.compareIndexRowFromPageToKey&lt;br/&gt;
. . .derby.impl.store.access.btree.ControlRow.searchForEntry&lt;br/&gt;
. . .derby.impl.store.access.btree.LeafControlRow.search&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeScan.positionAtStartForForwardScan&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeForwardScan.positionAtStartPosition&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeForwardScan.fetchRows&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeScan.fetchNext&lt;br/&gt;
. . .derby.impl.sql.execute.TableScanResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.OnceResultSet.getNextRowCore&lt;br/&gt;
. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.g0&lt;br/&gt;
. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.e6&lt;br/&gt;
	... 17 more&lt;br/&gt;
============= begin nested exception, level (1) ===========&lt;br/&gt;
java.lang.NullPointerException&lt;br/&gt;
. . .derby.iapi.types.NumberDataType.compare&lt;br/&gt;
. . .derby.impl.store.access.btree.ControlRow.compareIndexRowFromPageToKey&lt;br/&gt;
. . .derby.impl.store.access.btree.ControlRow.searchForEntry&lt;br/&gt;
. . .derby.impl.store.access.btree.LeafControlRow.search&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeScan.positionAtStartForForwardScan&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeForwardScan.positionAtStartPosition&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeForwardScan.fetchRows&lt;br/&gt;
. . .derby.impl.store.access.btree.BTreeScan.fetchNext&lt;br/&gt;
. . .derby.impl.sql.execute.TableScanResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.OnceResultSet.getNextRowCore&lt;br/&gt;
. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.g0&lt;br/&gt;
. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.e6&lt;br/&gt;
. . .derby.impl.services.reflect.DirectCall.invoke&lt;br/&gt;
. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore&lt;br/&gt;
. . .derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow&lt;br/&gt;
. . .derby.impl.jdbc.EmbedResultSet.movePosition&lt;br/&gt;
. . .derby.impl.jdbc.EmbedResultSet.next&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults&lt;br/&gt;
. . .derby.tools.JDBCDisplayUtil.DisplayResults&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.displayResult&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.doCatch&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.runScriptGuts&lt;br/&gt;
. . .derby.impl.tools.ij.utilMain.go&lt;br/&gt;
. . .derby.impl.tools.ij.Main.go&lt;br/&gt;
. . .derby.impl.tools.ij.Main.mainCore&lt;br/&gt;
. . .derby.impl.tools.ij.Main14.main&lt;br/&gt;
. . .derby.tools.ij.main&lt;br/&gt;
============= end nested exception, level (1) ===========&lt;br/&gt;
Cleanup action completed&lt;/p&gt;</description>
                <environment></environment>
        <key id="12404026">DERBY-3872</key>
            <summary>NullPoinerException thrown when INTEGER function used as a predicate in a WHERE clause of a SELECT .. GROUP BY ..  HAVING statement</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="stan">Stan Bradbury</reporter>
                        <labels>
                    </labels>
                <created>Tue, 9 Sep 2008 21:55:23 +0100</created>
                <updated>Fri, 21 Jan 2011 17:52:06 +0000</updated>
                            <resolved>Tue, 28 Oct 2008 04:26:54 +0000</resolved>
                                    <version>10.3.3.0</version>
                                    <fixVersion>10.4.2.1</fixVersion>
                    <fixVersion>10.5.1.1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12629686" author="bryanpendleton" created="Wed, 10 Sep 2008 03:49:13 +0100"  >&lt;p&gt;With the current trunk, I also see a NPE, but the stack trace is different. My stack trace is:&lt;/p&gt;

&lt;p&gt;java.lang.NullPointerException&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.BaseActivation.getColumnFromRow(BaseActivation.java:1419)&lt;br/&gt;
        at org.apache.derby.exe.ac4ac48095x011cx4a35x4fd4x00000013bb68f.e8(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:155)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TableScanResultSet.openCore(TableScanResultSet.java:250)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.openCore(IndexRowToBaseRowResultSet.java:202)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:168)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.OnceResultSet.openCore(OnceResultSet.java:119)&lt;br/&gt;
        at org.apache.derby.exe.ac4ac48095x011cx4a35x4fd4x00000013bb68f.g0(Unknown Source)&lt;br/&gt;
        at org.apache.derby.exe.ac4ac48095x011cx4a35x4fd4x00000013bb68f.e6(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:151)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:267)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:460)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:423)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedResultSet.next(EmbedResultSet.java:367)&lt;br/&gt;
        at org.apache.derby.tools.JDBCDisplayUtil.indent_DisplayResults(JDBCDisplayUtil.java:382)&lt;br/&gt;
        at org.apache.derby.tools.JDBCDisplayUtil.indent_DisplayResults(JDBCDisplayUtil.java:338)&lt;br/&gt;
        at org.apache.derby.tools.JDBCDisplayUtil.indent_DisplayResults(JDBCDisplayUtil.java:241)&lt;br/&gt;
        at org.apache.derby.tools.JDBCDisplayUtil.DisplayResults(JDBCDisplayUtil.java:229)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.displayResult(utilMain.java:435)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:509)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:350)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.go(Main.java:215)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:181)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.main(Main.java:73)&lt;/p&gt;</comment>
                            <comment id="12629791" author="knutanders" created="Wed, 10 Sep 2008 14:03:56 +0100"  >&lt;p&gt;This bug was introduced by the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; (revision 516454).&lt;/p&gt;</comment>
                            <comment id="12629906" author="kmarsden" created="Wed, 10 Sep 2008 19:39:14 +0100"  >&lt;p&gt;The stack trace changed with &lt;/p&gt;

&lt;p&gt;r662947 | bpendleton | 2008-06-03 19:44:17 -0700 (Tue, 03 Jun 2008) | 4 lines&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3097&quot; title=&quot;Unnecessary if statement can be removed from BaseActivation.getColumnFromNow&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3097&quot;&gt;&lt;del&gt;DERBY-3097&lt;/del&gt;&lt;/a&gt;: Remove unnecessary if stmt from BaseActivation.getColumnFromRow&lt;/p&gt;

&lt;p&gt;This change removes an unnecessary if statement from BaseActivation.java.&lt;/p&gt;

&lt;p&gt;My first take is that there is not a problem with removing the if statement, just that it moved the NPE to a different place.&lt;/p&gt;</comment>
                            <comment id="12629950" author="kmarsden" created="Wed, 10 Sep 2008 21:32:15 +0100"  >&lt;p&gt;It doesn&apos;t seem related directly to the integer function as described in the summary. If we use (1 =1) as in:&lt;/p&gt;

&lt;p&gt;select  q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 where (1 =1) and ( q2.&quot;DEPT_DEPTNO&quot; =  q1.&quot;DEPTNO&quot;)  GROUP BY q1.&quot;DEPTNO&quot; HAVING  max( q2.&quot;SALARY&quot;) &amp;gt;=  ( select  q3.&quot;SALARY&quot; from EMPTAB q3 where  ( q3.&quot;EMPID&quot; =  q1.&quot;DEPTNO&quot;) ) ;&lt;/p&gt;

&lt;p&gt;the same problem occurs, but as stan mentioned if the always true predicate is removed the query runs fine.&lt;/p&gt;
</comment>
                            <comment id="12630300" author="kmarsden" created="Thu, 11 Sep 2008 19:43:18 +0100"  >&lt;p&gt;Well I put some printlns in for calls to BaseActivation.setCurrentRow, clearCurrentRow and getColumnFromRow and looked at the difference between the query with and without the (1 = 1) predicate.&lt;br/&gt;
The results are posted here as &lt;br/&gt;
QueryWithTruePred.out&lt;br/&gt;
and&lt;br/&gt;
QueryWithoutTruePred.out &lt;/p&gt;

&lt;p&gt;I noticed two notable differences.  &lt;br/&gt;
1)&lt;br/&gt;
setCurrentRow is called twice for each row with the true predicate ( the failing case). I don&apos;t know if this is normal.&lt;/p&gt;

&lt;p&gt;2) &lt;br/&gt;
When compiling the final result, the failing case calls getColumnFromRow(5,1) for result set 5 when result set 5 has not been set, thus causing the NPE.  It seems it should be&lt;br/&gt;
getColumnFromRow(1,1) as it is for the passing case.&lt;/p&gt;

&lt;p&gt;I did a little debugging of ExpressionClassBuilder.pushColumnReference() and found that the ResultColumn that is being referenced in result set 5 is DEPTNO, but I haven&apos;t gotten much further than that.&lt;/p&gt;

&lt;p&gt;I am not actually sure what all the result set numbers are referring to.  &lt;/p&gt;

&lt;p&gt;Any suggestions are welcome.&lt;/p&gt;


</comment>
                            <comment id="12630401" author="bryanpendleton" created="Thu, 11 Sep 2008 23:21:06 +0100"  >&lt;p&gt;I suspect that the problem is happening during the code generation phase&lt;br/&gt;
of the compiler, so you&apos;ll want to be debugging the &apos;generate()&apos; methods that&lt;br/&gt;
are being called. Sometimes having a look at the overall &apos;shape&apos; of the query&lt;br/&gt;
tree is useful, by e.g. dumping the query plan, as it will tell you what result set 5&lt;br/&gt;
is and then you may be able to figure out which generate() method to step through.&lt;/p&gt;

&lt;p&gt;I suspect that the problem involves result set handling. Why does the&lt;br/&gt;
ExpressionClassBuilder for the (1=1) expression think that there are any&lt;br/&gt;
column references at all? There should only be literal references, not column references,&lt;br/&gt;
in the (1=1) expression.&lt;/p&gt;

&lt;p&gt;Hope this helps, I know it&apos;s pretty free-form.&lt;/p&gt;</comment>
                            <comment id="12630594" author="kmarsden" created="Fri, 12 Sep 2008 16:31:08 +0100"  >&lt;p&gt;I looked at the plans and noticed that the passing case (the one without the true predicate) was using a nested loop join and the failing case (the one with the true predicate was using a hash join), so I forced a hash join  for the query without the true predicate and also get a NPE.&lt;/p&gt;

&lt;p&gt;e.g.&lt;br/&gt;
select  q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH&lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; =  q1.&quot;DEPTNO&quot;)  GROUP BY q1.&quot;DEPTNO&quot; HAVING  max( q2.&quot;SALARY&quot;) &amp;gt;=  ( select  q3.&quot;SALARY&quot; from EMPTAB q3 where  ( q3.&quot;EMPID&quot; =  q1.&quot;DEPTNO&quot;) ) &lt;/p&gt;

&lt;p&gt;;&lt;br/&gt;
and the trace is:&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BaseActivation.getColumnFromRow(BaseActivation.java:1422)&lt;br/&gt;
	at org.apache.derby.exe.acf81e0010x011cx571bx0fbfx000000428ba82.e7(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:153)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TableScanResultSet.reopenCore(TableScanResultSet.java:536)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.reopenCore(IndexRowToBaseRowResultSet.java:285)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.reopenCore(ProjectRestrictResultSet.java:212)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.OnceResultSet.reopenCore(OnceResultSet.java:149)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.OnceResultSet.openCore(OnceResultSet.java:113)&lt;br/&gt;
	at org.apache.derby.exe.acf81e0010x011cx571bx0fbfx000000428ba82.g0(Unknown Source)&lt;br/&gt;
	at org.apache.derby.exe.acf81e0010x011cx571bx0fbfx000000428ba82.e5(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:149)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:267)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:460)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:423)&lt;br/&gt;
	... 13 more&lt;/p&gt;</comment>
                            <comment id="12631437" author="mamtas" created="Tue, 16 Sep 2008 16:46:23 +0100"  >&lt;p&gt;I spent some time simplifying the test case which reproduces the null pointer exception. The test case is as follows&lt;/p&gt;

&lt;p&gt;CREATE TABLE EMPTAB&lt;br/&gt;
  (EMPID INTEGER NOT NULL,&lt;br/&gt;
   SALARY DECIMAL(10, 4),&lt;br/&gt;
   DEPT_DEPTNO INTEGER);&lt;/p&gt;

&lt;p&gt;ALTER TABLE EMPTAB&lt;br/&gt;
  ADD CONSTRAINT PK_EMPTAB PRIMARY KEY (EMPID);&lt;/p&gt;

&lt;p&gt;CREATE TABLE DEPTTAB&lt;br/&gt;
  (DEPTNO INTEGER NOT NULL);&lt;/p&gt;

&lt;p&gt;ALTER TABLE DEPTTAB&lt;br/&gt;
  ADD CONSTRAINT PK_DEPTTAB PRIMARY KEY (DEPTNO);&lt;/p&gt;

&lt;p&gt;insert into DEPTTAB values( 1 );&lt;/p&gt;

&lt;p&gt;insert into EMPTAB values( 1, 1000, 1 );&lt;/p&gt;

&lt;p&gt;select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
  ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) &lt;/p&gt;</comment>
                            <comment id="12631439" author="bryanpendleton" created="Tue, 16 Sep 2008 16:50:59 +0100"  >&lt;p&gt;Thanks Mamta! I verified that your repro script produces the NPE in my environment,&lt;br/&gt;
 too, with the current trunk.&lt;/p&gt;</comment>
                            <comment id="12631843" author="mamtas" created="Wed, 17 Sep 2008 17:50:18 +0100"  >&lt;p&gt;Thanks for verifying it, Bryan. I spent little more time on following 2 queries to see how we generate the code for them&lt;br/&gt;
Query1&lt;br/&gt;
   select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
    where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
    GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
    ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) ;&lt;/p&gt;

&lt;p&gt;Query2&lt;br/&gt;
  select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &lt;br/&gt;
     where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
     GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
     ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) ;&lt;/p&gt;

&lt;p&gt;Query1 results in a NPE whereas Query2 runs fine. Notice that Query1 has optimizer override to use hashjoin.&lt;/p&gt;

&lt;p&gt;What I found during the code generation phase of the 2 queries is that &lt;br/&gt;
1)The number of resultsets generated for the 2 queries are not same. Query1 has 11 generated resultsets whereas Query2 has 10 generated resultsets.&lt;br/&gt;
2)For the outer query, in case of Query1, the DEPTTAB is the left operand of the join node and EMPTAB is the right operand. The generated resultset for DEPTTAB get resultset number 3 assigned to it and the generated resultset for EMPTAB gets resultset number 4 assigned to it. For some reason, the order of these resultsets are switched in case of Query2. So, EMPTAB is the left operand for the join node and DEPTTAB is the right operand for the join node.&lt;br/&gt;
3)Another thing to note at code generation time is for subquery. In case of Query1, we have 2 nodes associated with EMPTAB q3, namely IndexToBaseRowNode and FromBaseTable. In case of Query2, we have only one node for EMPTAB q3 and that is FromBaseTable.&lt;/p&gt;

&lt;p&gt;Lastly, at runtime, right before we hit the NPE, activation object shows following current rows associated with each of the 11 generated resultsets&lt;br/&gt;
[null, &lt;/p&gt;
{ 1 }, null, null, null, null, { 1 }
&lt;p&gt;, null, null, null, null]&lt;br/&gt;
Notice that current row for resultset number 3 is null and that is causing the npe.&lt;br/&gt;
For Query2, the activation object shows following current rows associated with each of it&apos;s 10 generated resultsets&lt;br/&gt;
[null, null, null, &lt;/p&gt;
{ 1 }
&lt;p&gt;, null, null, null, null, null, null]&lt;br/&gt;
Notice that current row for resultset number 3 is not null.&lt;/p&gt;

&lt;p&gt;I am not sure how useful information is this, but I wanted to share what I have. I will continue debugging more.&lt;/p&gt;


</comment>
                            <comment id="12632395" author="mamtas" created="Thu, 18 Sep 2008 22:20:51 +0100"  >&lt;p&gt;I have some more finidings to share on Query1&lt;br/&gt;
   select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
    where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
    GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
    ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) ; &lt;/p&gt;

&lt;p&gt;The query as written above results in NPE but if I change the order of tables in the outer query&apos;s from list as shown below, there is no NPE&lt;br/&gt;
   select q1.&quot;DEPTNO&quot; from EMPTAB q2, DEPTTAB q1 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
    where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
    GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
    ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) ; &lt;/p&gt;

&lt;p&gt;It appears that changing the order of the tables makes Derby bypass the sort avoidance code. To be more specific, impl.sql.compile.GroupByNode:init method has following check&lt;br/&gt;
if (index == glSize) &lt;/p&gt;
{
    isInSortedOrder = childResult.isOrderedOn(crs, true, (Vector)null);
}
&lt;p&gt;This piece of code assigns true to isInSortedOrder if DEPTTAB is first in the from list of query. The code comment in JoinNode.isOrdered which is what gets called by the code segment above has following interesting comment&lt;br/&gt;
/* RESOLVE - easiest thing for now is to only consider the leftmost child */&lt;br/&gt;
This is why if I change the order of the tables in the from list, DEPTTAB is no more the leftmost child and hence isInSortedOrder ends up getting a value of FALSE when DEPTTAB is not the first table in the from list. (This piece of code so far is in Derby&apos;s query compile code.)&lt;/p&gt;

&lt;p&gt;At query execution time, we check this flag is impl.sql.execute.GroupedAggregateResultSet:openCore as shown below&lt;br/&gt;
/* If this is an in-order group by then we do not need the sorter.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;(We can do the aggregation ourselves.)&lt;/li&gt;
	&lt;li&gt;We save a clone of the first row so that subsequent next()s&lt;/li&gt;
	&lt;li&gt;do not overwrite the saved row.&lt;br/&gt;
 */&lt;br/&gt;
if (isInSortedOrder)&lt;br/&gt;
{&lt;br/&gt;
	currSortedRow = getNextRowFromRS();&lt;br/&gt;
	if (currSortedRow != null)
	{
		currSortedRow = (ExecIndexRow)currSortedRow.getClone();
		initializeVectorAggregation(currSortedRow);
	}
&lt;p&gt;}&lt;br/&gt;
else&lt;/p&gt;
{
/*
** Load up the sorter
*/
	scanController = loadSorter();
}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If isInSortOrder is found to be true, we go through the code path which causes us to run into NPE. I need to do more debugging but I think what happens in this code path is we set the current row associated with various internal resutsets hanging off of the Activation object and most of these current row end up being NULL and later on, the code is looking for specific column value in the current row not expecting the current row to be NULL. &lt;/p&gt;

&lt;p&gt;I will also try to compare the code flow in 10.2 codeline vs trunk because the query in question works fine in 10.2 no matter how the tables are listed the from list in the query.&lt;/p&gt;</comment>
                            <comment id="12633378" author="mamtas" created="Mon, 22 Sep 2008 17:50:18 +0100"  >&lt;p&gt;While trying to run through the 10.2 codeline and trunk, one of the things I noticed is that impl.sql.compile.SelectNode:preprocess method has code around line number 1000 that looks like following in 10.2 codeline&lt;br/&gt;
	/* A valid group by without any aggregates is equivalent to &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;a distinct without the group by.  We do the transformation&lt;/li&gt;
	&lt;li&gt;in order to simplify the group by code.&lt;br/&gt;
	 */&lt;br/&gt;
	if (groupByList != null &amp;amp;&amp;amp;&lt;br/&gt;
		selectAggregates.size() == 0 &amp;amp;&amp;amp;&lt;br/&gt;
		whereAggregates.size() == 0)
	{
		isDistinct = true;
		groupByList = null;
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The corresponding code in trunk has additional check in the if condition as shown below&lt;br/&gt;
	/* A valid group by without any aggregates or a having clause&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;is equivalent to a distinct without the group by.  We do the transformation&lt;/li&gt;
	&lt;li&gt;in order to simplify the group by code.&lt;br/&gt;
	 */&lt;br/&gt;
	if (groupByList != null &amp;amp;&amp;amp;&lt;br/&gt;
		havingClause == null &amp;amp;&amp;amp;&lt;br/&gt;
		selectAggregates.size() == 0 &amp;amp;&amp;amp;&lt;br/&gt;
		whereAggregates.size() == 0)
	{
		isDistinct = true;
		groupByList = null;
		wasGroupBy = true;
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Just to see what would happen I removed the (havingClause == null &amp;amp;&amp;amp;) check in the trunk codeline and ran our queries that are running in NPE in this jira entry and they ran fine with no NPE. But of course, the solution couldn&apos;t be this easy because this change causes existing tests in junit suite to fail. I will try to undestand what was the logic behind the changes that went in for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; but any other tips at all to make progress on this jira entry will be greatly appreciated. I am not sure if the queries in question in this jira entry should follow the new code path introduced by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am wondering if anyone who has looked at other regressions caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; know why removing the havingClause == null &amp;amp;&amp;amp; check makes the queries in this jira entry run with no NPE. &lt;/p&gt;</comment>
                            <comment id="12633670" author="knutanders" created="Tue, 23 Sep 2008 11:08:29 +0100"  >&lt;p&gt;The (havingClause==null) check is not in the 10.2 code line because the abstract syntax tree would be rewritten so that it never had HAVING clauses in 10.2. In 10.3, the abstract syntax tree would preserve the HAVING clauses, so that&apos;s probably why the check was added. Adding more checks to the if statement shouldn&apos;t be problematic, though. It&apos;s just an optimization, so even removing the entire if should not cause any wrong results, I hope.&lt;/p&gt;</comment>
                            <comment id="12633967" author="bryanpendleton" created="Wed, 24 Sep 2008 00:23:17 +0100"  >&lt;p&gt;Hi Mamta, thanks for all the hard work you&apos;ve been doing to investigate this!&lt;/p&gt;

&lt;p&gt;I think your observation about the &quot;if&quot; statement in SelectNode.preprocess is very interesting.&lt;/p&gt;

&lt;p&gt;I believe that the idea behind that &quot;if&quot; statement is that some queries that are written&lt;br/&gt;
as GROUP BY queries can be replaced (rewritten) to be DISTINCT queries instead.&lt;/p&gt;

&lt;p&gt;As an example, consider this very simple query:&lt;/p&gt;

&lt;p&gt;   select last_name from employee group by last_name&lt;/p&gt;

&lt;p&gt;That query can be re-written (internally) to be:&lt;/p&gt;

&lt;p&gt;  select distinct last_name from employee&lt;/p&gt;

&lt;p&gt;as the two queries have the same meaning (we only want 1 row in the&lt;br/&gt;
output for each different value of the LAST_NAME column).&lt;/p&gt;

&lt;p&gt;This transformation is only valid if no aggregate functions (MIN MAX COUNT SUM AVG)&lt;br/&gt;
are used, because if the aggregate functions are used then GROUP BY does&lt;br/&gt;
something different than DISTINCT.&lt;/p&gt;

&lt;p&gt;Now, in the particular case of your problematic query, there are in fact no&lt;br/&gt;
aggregate functions being used, which is why this &quot;if&quot; statement is relevant.&lt;/p&gt;

&lt;p&gt;I think that what removing the (havingClause == null) check from the &quot;if&quot; statement&lt;br/&gt;
did was to give SelectNode.preprocess permission to convert your query:&lt;/p&gt;

&lt;p&gt;  select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH&lt;br/&gt;
    where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
    GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 =&lt;br/&gt;
          (  select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) &lt;/p&gt;

&lt;p&gt;into the simpler, but (I think) equivalent query:&lt;/p&gt;

&lt;p&gt;select distinct q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;  and &lt;br/&gt;
   1 =  ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ) &lt;/p&gt;

&lt;p&gt;  (I&apos;m not totally sure the above is valid syntax but hopefully it&apos;s close)&lt;/p&gt;

&lt;p&gt;That is, the &quot;having&quot; clause is pretty much like the &quot;where&quot; clause, but it is&lt;br/&gt;
applied &lt;b&gt;after&lt;/b&gt; the GROUP BY is performed, whereas the where clause is&lt;br/&gt;
applied &lt;b&gt;before&lt;/b&gt; the GROUP BY.  By transforming the query internally to&lt;br/&gt;
remove the GROUP BY, the HAVING clause is essentially collapsed into the where.&lt;/p&gt;

&lt;p&gt;Now, regarding why this is so relevant to your case, and why the &quot;sort avoidance&quot;&lt;br/&gt;
question is important, here&apos;s a few more ideas:&lt;/p&gt;

&lt;p&gt;GROUP BY grouping can basically be performed in two fundamental ways:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;sorting&lt;/li&gt;
	&lt;li&gt;hashing&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Either one of these techniques clusters the &quot;like&quot; values together so that they&lt;br/&gt;
can be recognized as belonging to the same group and be collapsed.&lt;/p&gt;

&lt;p&gt;In Derby, I think, we &lt;b&gt;only&lt;/b&gt; use the sorting techinque for group by processing,&lt;br/&gt;
&lt;b&gt;not&lt;/b&gt; the hashing technique (but please don&apos;t trust me on this, instead verify&lt;br/&gt;
this yourself). However, there is a weird little optimization where the sorting-based&lt;br/&gt;
group by processing can either happen:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in the sorter, during a sort&lt;/li&gt;
	&lt;li&gt;or in the GROUP BY result set&lt;br/&gt;
Regardless of where it happens, the idea is that the rows are sorted on the&lt;br/&gt;
values that we&apos;re grouping by, then as we process them we compare the&lt;br/&gt;
current row to the previous row, and if they have the same &quot;key&quot; then they&lt;br/&gt;
go into the same &quot;group&quot; in the result.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Sorting the data can be &lt;b&gt;very&lt;/b&gt; expensive, which is why the sort avoidance&lt;br/&gt;
algorithm is an important optimization. If the compilation / optimization processing&lt;br/&gt;
can determine that the rows are going to appear in sorted order by the group by&lt;br/&gt;
column(s), then we can skip the sort, so we do so.&lt;/p&gt;

&lt;p&gt;Being able to skip the sort is usually because the column that we are&lt;br/&gt;
grouping on is a column which is used in an index, and by doing an&lt;br/&gt;
index-to-base-table access for that data, we can ensure that we get&lt;br/&gt;
the data via the index, and hence it is in sorted order.&lt;/p&gt;

&lt;p&gt;It sounds like the bug may have something to do with &lt;b&gt;thinking&lt;/b&gt; that the rows&lt;br/&gt;
are going to appear in sorted order, so we can skip the sort, but then the &lt;br/&gt;
query plan gets changed around late in optimization and the actual rows&lt;br/&gt;
do not appear in sorted order, so the assumption that we could group them&lt;br/&gt;
without needing to sort them was wrong.&lt;/p&gt;

&lt;p&gt;And the extra result set that you were seeing in the one case (11 result sets&lt;br/&gt;
versus 10) may have to do with the result set that would have been present&lt;br/&gt;
to perform the sorting, or it may have to do with an index-to-base traversal&lt;br/&gt;
that was expected to occur in order to ensure that the rows were in sorted order.&lt;/p&gt;

&lt;p&gt;I hope some of this is helpful; you are definitely going in the right direction with&lt;br/&gt;
trying to track this problem down; these problems are really tough so don&apos;t&lt;br/&gt;
get discouraged just keep it up!&lt;/p&gt;</comment>
                            <comment id="12634137" author="mamtas" created="Wed, 24 Sep 2008 14:31:10 +0100"  >&lt;p&gt;Bryan, thank you so much. I can see that you spent lot of your time to analyze this issue. I will look through your comment further and use the information to debug this jira entry more.&lt;/p&gt;</comment>
                            <comment id="12634288" author="bryanpendleton" created="Wed, 24 Sep 2008 21:46:23 +0100"  >&lt;p&gt;Thanks Mamta for the kind words, they are much appreciated. I had&lt;br/&gt;
another thought I wanted to share:&lt;/p&gt;

&lt;p&gt;I think that in the code in SelectNode.preprocess, the (havingClause == null)&lt;br/&gt;
check is correct, and should be present, for the reasons that I mentioned&lt;br/&gt;
in the previous comment.&lt;/p&gt;

&lt;p&gt;But it occurs to me that perhaps the bug is that (havingClause == null)&lt;br/&gt;
is missing from some &lt;b&gt;other&lt;/b&gt; location in the code, and should have&lt;br/&gt;
been added as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt;; it could have been overlooked for&lt;br/&gt;
the reasons that Knut mentioned earlier.&lt;/p&gt;

&lt;p&gt;So it might be worth searching around through the compiler and optimizer&lt;br/&gt;
code, to see if there are any other places where we have an &quot;if&quot; statement like:&lt;/p&gt;

&lt;p&gt;   if (groupByList != null &amp;amp;&amp;amp;  selectAggregates.size() == 0 &amp;amp;&amp;amp; whereAggregates.size() == 0) &lt;/p&gt;

&lt;p&gt;and, if you find such code, consider whether possibly (havingClause == null)&lt;br/&gt;
should be added there as well.&lt;/p&gt;</comment>
                            <comment id="12635443" author="mamtas" created="Mon, 29 Sep 2008 17:52:25 +0100"  >&lt;p&gt;I have spent more time on the execution side of the query in question to see why exactly we are running into NPE and following is what I found. At the high level, when a query is executed at the JDBC layer, Derby execution code goes through opening the language resultsets associated with the query. This code is in the method open() for the topmost language resultset and for all the language resultsets underneath the topmost resultset, openCore() method gets called. When the user natigates throught the JDBC resultset after the query execution, Derby execution code goes through getNextRow() method for the topmost language resultset and getNextRowCore() method for the resultsets underneath the topmost resultset. There are some exceptions in Derby code where the row fetching on the resultsets happen during the query execution (ie even before the user has requested say &quot;next&quot; on the JDBC resultset). One such example is when we have GroupedAggregateRS which has it&apos;s isInSortedOrder flag set to true. In this specific query, this flag is set to true indicating a performance optimization to avoid sorting and this pre-fetching of the rows at the time of JDBC query execution is resulting in NPE. More detailed information below.&lt;/p&gt;

&lt;p&gt;In the following discussion &lt;br/&gt;
	RS stands for generated language resultset.&lt;br/&gt;
	PRS stands for ProjectRestrictedRS.&lt;br/&gt;
	RSN stands for resultset number associated with the RS.&lt;br/&gt;
	LeftRS stands for left RS.&lt;br/&gt;
	RightRS stands for right RS.&lt;/p&gt;

&lt;p&gt;The query in question which results in NPE is as follows&lt;br/&gt;
select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
  ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ); &lt;/p&gt;


&lt;p&gt;The topmost generated RS for the entire query is a PRS(RSN = 6) and the source for this topmost PRS is GroupedAggregateRS (RSN = 1). The topmost PRS has restriction associated with it. The restriction handles just the HAVING clause of the query. The rest of the query (before the HAVING clause) is handled through GroupedAggregateRS (RSN = 1).&lt;/p&gt;

&lt;p&gt;To be specific, GroupedAggregateRS (RSN=1) covers the following part of the query&lt;br/&gt;
select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; &lt;br/&gt;
The generated RSs for this part of the query look as follows&lt;br/&gt;
   The topmost generated RS for the entire query is a PRS(RSN = 6)&lt;br/&gt;
	The source for PRS is GroupedAggregateRS (RSN = 1)&lt;br/&gt;
		The source for GroupedAggregateRS is PRS (RSN = 5)&lt;br/&gt;
			The source for PRS is HashJoinRS (RSN = 2)&lt;br/&gt;
				LeftRS is BulkTableScanRS (RSN = 3) DEPTTAB q1***&lt;br/&gt;
				RightRS is HashScanRS (RSN = 4) EMPTAB q2 ***Has qualifier associated with it.&lt;/p&gt;

&lt;p&gt;The remaining part of the query as shown below is covered by the &quot;restriction&quot; field in PRS (RSN=6)&lt;br/&gt;
HAVING 1 = ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ); &lt;br/&gt;
The generated RSs for the &quot;restriction&quot; on PRS (RSN=6) looks as follows&lt;br/&gt;
  The topmost RS for 2nd part of query is OnceRS (RSN = 10)&lt;br/&gt;
     The source for OnceRS is PRS (RSN = 9)&lt;br/&gt;
        The source for PRS is IndexRowToBaseRowRS (RSN = 7) for EMPTAB q3&lt;br/&gt;
           The source for IndexRowToBaseRowRS is TableScanRS (RSN = 8)**has startKeyGetter associated with it.&lt;/p&gt;

&lt;p&gt;When the query is executed from JDBC layer (say using PreparedStatement.execute), we start by calling the open() method (which calls openCore) on the topmost RS which is PRS (RSN=6). On all the subsequent RSs underneath the topmost RS, we will be calling the openCore() method. The openCore method on PRS (RSN=6) calls the openCore method on GroupedAggregateRS(RSN=1) which calls openCore on PRS (RSN=5) which makes a call to openCore on HashJoinRS(RSN=2). The *&lt;b&gt;interesting thing here is&lt;/b&gt;* HashJoinRS calls openCore on the leftRS and then it *&lt;b&gt;gets the next row on that leftRS&lt;/b&gt;*. This results in call to BulkTableScanRS(RSN=3).getNextRowCore The row that is obtained here is set as the current row for this RS in the activation object. So, the current rows for various RSs in activation object at this point looks as follows&lt;br/&gt;
[null, null, null, &lt;/p&gt;
{ 1 }, null, null, null, null, null, null, null]&lt;br/&gt;
&lt;br/&gt;
Then the openCore method on HashJoinRS(RSN=2) calls openCore method on the rightRS(RSN=4) which is a HashScanRS. HashScanRS in it&apos;s openCore method deals with the qualifiers associated with it. In this particular query, the qualifier code looks at the current row associated with the leftRS in the activation object. The call to look at current row for leftRS in activation object happens in BaseActivation.getColumnFromRow(int, int) line: 1419	&lt;br/&gt;
Once this work is done for the rightRS(RSN=4), the control goes back to openCore in GroupedAggregateRS (RSN=1). We check if isInSortedOrder is set to true for GroupedAggregateRS which in this particular case is set to true. Because of that, we execute following piece of code&lt;br/&gt;
	if (isInSortedOrder)&lt;br/&gt;
	{&lt;br/&gt;
		currSortedRow = getNextRowFromRS();&lt;br/&gt;
		if (currSortedRow != null)&lt;br/&gt;
		{
			currSortedRow = (ExecIndexRow) currSortedRow.getClone();
			initializeVectorAggregation(currSortedRow);
		}&lt;br/&gt;
	}&lt;br/&gt;
Notice that the above piece of code is causing us to start getting rows from the resultset even before the JDBC user has requested a next on the JDBC ResultSet. The code above causes us to get next row in HashJoinRS rightRS(RSN=4) because we have already gotten the next row on the leftRS earlier. Once we have the current row for HashJoinRS, we set it as the current row for this RS in the activation object. So, the current rows for various RSs in activation object at this point looks as follows &lt;br/&gt;
[null, null, null, { 1 }
&lt;p&gt;, &lt;/p&gt;
{ 1 }, null, null, null, null, null, null]&lt;br/&gt;
&lt;br/&gt;
Now that we have the current row for the leftRS and the rightRS, we merge the 2 rows and establish the current row for HashJoinRS(RSN=2) and once again, we set this current row for HashJoinRS in the activation object. So, the current rows for various RSs in activation object at this point looks as follows&lt;br/&gt;
[null, null, { 1, 1 }, { 1 }
&lt;p&gt;, &lt;/p&gt;
{ 1 }, null, null, null, null, null, null]&lt;br/&gt;
&lt;br/&gt;
Next, we set the current row of the PRS(RSN=5) and the current rows for various RSs in activation object at this point looks as follows&lt;br/&gt;
[null, null, { 1, 1 }, { 1 }
&lt;p&gt;, &lt;/p&gt;
{ 1 }, { 1 }
&lt;p&gt;, null, null, null, null, null]&lt;/p&gt;

&lt;p&gt;Once the current rows for various RSs associated with GroupedAggregateRS and RSs underneath are set, the openCore processing is over. We do not set the current row for the GroupedAggregateRS in openCore, it wil lbe done when the JDBC user invokes next on the JDBC resultset. The code associated with HAVING clause also gets run when the JDBC user requests next on the JDBC ResultSet. The code path for that next request is described below and that is where we run into NPE. &lt;/p&gt;

&lt;p&gt;All the language RSs have methods called getNextRow() and getNextRowCore(). getNextRow() gets called only on the topmost RS. getNextRowCore() gets called on RSs underneath the topmost RS. We start out with following code flow&lt;br/&gt;
	PRN(RSN=6).getNextRow&lt;br/&gt;
	  PRN(RSN=6).getNextRowCore&lt;br/&gt;
	    GroupedAggregateRS(RSN=1).getNextRowCore&lt;br/&gt;
	      PRN(RSN=5).getNextRowCore&lt;br/&gt;
	        HashJoinRS(RSN=2).getNextRowCore&lt;br/&gt;
	          rightRS which is HashScanRS(RSN=4).getNextRowCore&lt;/p&gt;

&lt;p&gt;There are no more rows in EMPTAB this time which is what HashScanRS (RSN=4) is dealing with and hence the current row for it will be null and it will set to that in the activation object as well as shown below.&lt;br/&gt;
[null, null, &lt;/p&gt;
{ 1, 1 }, { 1 }, null, { 1 }, null, null, null, null, null]&lt;br/&gt;
Since there is no row on the rightRS, we check if there is a row on the leftRS(BulkTableScanRS (RSN=3)). There is no row in the leftRS also. We mark it so in the activation object.&lt;br/&gt;
[null, null, { 1, 1 }
&lt;p&gt;, null, null, &lt;/p&gt;
{ 1 }, null, null, null, null, null]&lt;br/&gt;
&lt;br/&gt;
Absence of row on the leftRS results in closing the rightRS. Also, since there is no row on the leftRS and rightRS, we clear the current row for the HashJoinRS and also mark current row null for it in the activation object as shown below.&lt;br/&gt;
[null, null, null, null, null, { 1 }
&lt;p&gt;, null, null, null, null, null]&lt;br/&gt;
This current row null setting goes up to PRS(RSN=5) which is on top of HashJoinRS as shown below&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;null, null, null, null, null, null, null, null, null, null, null&amp;#93;&lt;/span&gt;&lt;br/&gt;
GroupedAggreateRS.getNextRowCore code sees that there are no more rows that could be used aggregation and hence it settles with the row prior to finding the null row. The activation object reflects that as follows&lt;br/&gt;
[null, &lt;/p&gt;
{ 1 }, null, null, null, null, null, null, null, null, null]&lt;br/&gt;
&lt;br/&gt;
At this point, the only RS that has a current row set on it is the GroupedAggregateRS and control of the code at this point is in the topmost RS PRS(RSN=6) &lt;br/&gt;
	ProjectRestrictResultSet.getNextRowCore() line: 266&lt;br/&gt;
Here we check if there is any restriction associated with this PRS and in this particular query, the HAVING clause is implemented as the restriction on the PRS. We first set the current row for this PRS to be what we got from the GroupedAggregateRS and next we will apply restriction to that row. The activation object looks as follows&lt;br/&gt;
[null, { 1 }
&lt;p&gt;, null, null, null, null, &lt;/p&gt;
{ 1 }
&lt;p&gt;, null, null, null, null]&lt;br/&gt;
The code for applying the restriction is as follows in PRS.getNextRowCore() line: 267&lt;br/&gt;
            restrictBoolean = (DataValueDescriptor) &lt;br/&gt;
			restriction.invoke(activation);&lt;br/&gt;
The execution of the code above causes us the create the RSs associated with the HAVING clause which are as follows	&lt;br/&gt;
The topmost RS for 2nd part of query is OnceRS (RSN = 10)&lt;br/&gt;
  The source for OnceRS is PRS (RSN = 9)&lt;br/&gt;
    The source for PRS is IndexRowToBaseRowRS (RSN = 7) for EMPTAB q3&lt;br/&gt;
      The source for IndexRowToBaseRowRS is TableScanRS (RSN = 8)**has startKeyGetter associated with it.&lt;/p&gt;

&lt;p&gt;We go through the process of opening each one of these RSs by calling the openCore methods on them. The NullPointerException happens when we are opening the TableScanRS(RSN=8) which has startKeyGetter associated with it. We try to find the startPosition using the startKeyGetter as shown below&lt;br/&gt;
		if (startKeyGetter != null)&lt;br/&gt;
		{&lt;br/&gt;
			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);&lt;br/&gt;
			if (sameStartStopPosition)&lt;/p&gt;
			{
				stopPosition = startPosition;
			}
&lt;p&gt;		}&lt;br/&gt;
The startKeyGetter.invoke causes us to look at the current row of the RSN=3 which is the RS associated with the BulkTableScanRS for &quot;DEPTTAB q1&quot; but since the current row for it in activation object has been set to null, we run into NPE. &lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 1419 in BaseActivation))	&lt;br/&gt;
	acf81e0010x011cxa07fxbcfex0000003f01400(BaseActivation).getColumnFromRow(int, int) line: 1419	&lt;br/&gt;
	acf81e0010x011cxa07fxbcfex0000003f01400.e6() line: not available	&lt;br/&gt;
	DirectCall.invoke(Object) line: 151	&lt;br/&gt;
	TableScanResultSet.openCore() line: 250	&lt;br/&gt;
	IndexRowToBaseRowResultSet.openCore() line: 202	&lt;br/&gt;
	ProjectRestrictResultSet.openCore() line: 168	&lt;br/&gt;
	OnceResultSet.openCore() line: 119	&lt;br/&gt;
	acf81e0010x011cxa07fxbcfex0000003f01400.g0() line: not available &lt;span class=&quot;error&quot;&gt;&amp;#91;local variables unavailable&amp;#93;&lt;/span&gt;	&lt;br/&gt;
	acf81e0010x011cxa07fxbcfex0000003f01400.e4() line: not available	&lt;br/&gt;
	DirectCall.invoke(Object) line: 147	&lt;br/&gt;
	ProjectRestrictResultSet.getNextRowCore() line: 267	&lt;br/&gt;
	ProjectRestrictResultSet(BasicNoPutResultSetImpl).getNextRow() line: 460	&lt;br/&gt;
	EmbedResultSet40(EmbedResultSet).movePosition(int, int, String) line: 423	&lt;br/&gt;
	JDBCDisplayUtil.indent_DisplayResults(PrintWriter, ResultSet, Connection, int, int[], int[]) line: 338	&lt;br/&gt;
	JDBCDisplayUtil.DisplayResults(PrintWriter, Statement, Connection) line: 229	&lt;br/&gt;
	utilMain.doCatch(String) line: 509	&lt;br/&gt;
	JDBCDisplayUtil.indent_DisplayResults(PrintWriter, Statement, Connection, int, int[], int[]) line: 241	&lt;br/&gt;
	JDBCDisplayUtil.DisplayResults(PrintWriter, Statement, Connection) line: 229	&lt;br/&gt;
	utilMain.displayResult(LocalizedOutput, ijResult, Connection) line: 435	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248	&lt;br/&gt;
	utilMain.runScriptGuts() line: 350	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 181	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput, Properties) line: 215	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 181	&lt;br/&gt;
	Main.main(String[]) line: 73	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;

&lt;p&gt;Now, that I understand what is causing the NPE to happen, the next step is to figure out should the current row for the RS for DEPTTAB be null at this point when we know from the query that it needs to be available for us to enforce HAVING clause.&lt;/p&gt;

&lt;p&gt;I realize that this is a very long comment but I wanted to share the code flow during the query execution to pinpoint what is exactly happening. &lt;/p&gt;

&lt;p&gt;As always, will appreciate any insight in understanding should the row which is needed to enforce the HAVING clause be null. Is the issue with code generation where we are trying to avoid sorting when the rows used for sorting are actually needed for the HAVING clause enforcement.&lt;/p&gt;</comment>
                            <comment id="12635496" author="mamtas" created="Mon, 29 Sep 2008 20:19:56 +0100"  >&lt;p&gt;Also, I thought I should mention that I do not think the test case (the query which causes NPE) can be made any easier because we have to ensure that we have a group by which will be converted into an aggregate and we have to have a HAVING clause which is referencing the same table as the one in the outer query because the group by sort avoidance is going to make the table from outer query position itself on a null row which will in turn make having clause fail because it didn&apos;t expect to find a null row for that table.&lt;/p&gt;</comment>
                            <comment id="12635564" author="bryanpendleton" created="Mon, 29 Sep 2008 23:38:02 +0100"  >&lt;p&gt;Hi Mamta ,thanks for the wonderful writeup! &lt;/p&gt;

&lt;p&gt;&amp;gt; The startKeyGetter.invoke causes us to look at the current row of the &lt;br/&gt;
&amp;gt; RSN=3 which is the RS associated with the BulkTableScanRS for &quot;DEPTTAB q1&quot;&lt;/p&gt;

&lt;p&gt;This seems incorrect to me; it seems like the startKeyGetter in the RSN 8&lt;br/&gt;
should be pointing to result set #1, not to result set #3.&lt;/p&gt;

&lt;p&gt;This might be the sort of thing that would work in most queries by accident,&lt;br/&gt;
but would fail in your particular case because everything lined up just right.&lt;/p&gt;

&lt;p&gt;Can you step through the code generation for the HAVING clause&lt;br/&gt;
sub-tree, and see where the startKeyGetter is getting its RSN from? Perhaps&lt;br/&gt;
there is some missing code that should have run when we were generating&lt;br/&gt;
the GroupBy result set (#5) and its parent PRN result set (#1) which should&lt;br/&gt;
have re-numbered the startKeyGetter result set reference in the having clause?&lt;/p&gt;</comment>
                            <comment id="12637536" author="mamtas" created="Tue, 7 Oct 2008 17:30:25 +0100"  >&lt;p&gt;I did code walk through during the code generation phase of the above query. Different resultsets and columns get their RSNs assigned to them during the code generation phase.&lt;/p&gt;

&lt;p&gt;The stack trace below shows when the column belonging to HAVING clause indirectly gets the RSN 3 assigned to it.&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 413 in ResultColumn))	&lt;br/&gt;
	ResultColumn.setResultSetNumber(int) line: 413	&lt;br/&gt;
	ResultColumnList.setResultSetNumber(int) line: 2141	&lt;br/&gt;
	FromBaseTable(ResultSetNode).assignResultSetNumber() line: 213	&lt;br/&gt;
	FromBaseTable.generateResultSet(ExpressionClassBuilder, MethodBuilder) line: 3098	&lt;br/&gt;
	FromBaseTable.generate(ActivationClassBuilder, MethodBuilder) line: 3065	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1385	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336	&lt;br/&gt;
	JoinNode.getJoinArguments(ActivationClassBuilder, MethodBuilder, ValueNode) line: 1577	&lt;br/&gt;
	JoinNode.generateCore(ActivationClassBuilder, MethodBuilder, int, ValueNode, SubqueryList) line: 1555	&lt;br/&gt;
	JoinNode.generate(ActivationClassBuilder, MethodBuilder) line: 1479	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1472	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336	&lt;br/&gt;
	GroupByNode.generate(ActivationClassBuilder, MethodBuilder) line: 1013	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1472	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336	&lt;br/&gt;
	ScrollInsensitiveResultSetNode.generate(ActivationClassBuilder, MethodBuilder) line: 109	&lt;br/&gt;
	CursorNode.generate(ActivationClassBuilder, MethodBuilder) line: 564	&lt;br/&gt;
	CursorNode(StatementNode).generate(ByteArray) line: 347	&lt;br/&gt;
	GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 447	&lt;br/&gt;
	GenericStatement.prepare(LanguageConnectionContext, boolean) line: 88	&lt;br/&gt;
	GenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 796	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 606	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String) line: 555	&lt;br/&gt;
	ij.executeImmediate(String) line: 329	&lt;br/&gt;
	utilMain.doCatch(String) line: 508	&lt;br/&gt;
	utilMain.runScriptGuts() line: 350	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput, Properties) line: 215	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 181	&lt;br/&gt;
	Main.main(String[]) line: 73	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;

&lt;p&gt;The stack trace above is handling the first part of the use query(the first part is shown below)&lt;br/&gt;
select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; &lt;br/&gt;
Note that we are not dealing with the HAVING clause at all at this point in the stack trace but the problem arises from the fact that the ResultColumn associated with the HAVING clause is the same object that is associated with the join node. Because of that, even though we are setting the RSN number 3 for the join node column, the ResultColumn associated with the HAVING clause ends up getting the same RSN 3 associated with it. I have tried to show below how different language ResultSet and column objects are associated with the entire user query&lt;br/&gt;
this	org.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=192)	&lt;br/&gt;
   childResult	org.apache.derby.impl.sql.compile.GroupByNode  (id=156)	&lt;br/&gt;
      childResult	org.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=151)	&lt;br/&gt;
         childResult	org.apache.derby.impl.sql.compile.JoinNode  (id=221)	&lt;br/&gt;
            leftResultSet	org.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=233)	&lt;br/&gt;
               childResult	org.apache.derby.impl.sql.compile.FromBaseTable  (id=241)	&lt;br/&gt;
                  resultColumns	org.apache.derby.impl.sql.compile.ResultColumnList  (id=317)	&lt;br/&gt;
                     v	java.util.Vector&amp;lt;E&amp;gt;  (id=2084)	&lt;br/&gt;
                        elementCount	1	&lt;br/&gt;
                        elementData	java.lang.Object&lt;span class=&quot;error&quot;&gt;&amp;#91;10&amp;#93;&lt;/span&gt;  (id=2089)	&lt;br/&gt;
                           &lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;	org.apache.derby.impl.sql.compile.ResultColumn  (id=218)	&lt;br/&gt;
   restriction	org.apache.derby.impl.sql.compile.AndNode  (id=98)	&lt;br/&gt;
      leftOperand	org.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode  (id=85)	&lt;br/&gt;
         rightOperand	org.apache.derby.impl.sql.compile.SubqueryNode  (id=93)	&lt;br/&gt;
            resultSet	org.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=135)	&lt;br/&gt;
               childResult	org.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=121)	&lt;br/&gt;
                  childResult	org.apache.derby.impl.sql.compile.IndexToBaseRowNode  (id=193)	&lt;br/&gt;
                     source	org.apache.derby.impl.sql.compile.FromBaseTable  (id=195)	&lt;br/&gt;
                        restrictionList	org.apache.derby.impl.sql.compile.PredicateList  (id=196)	&lt;br/&gt;
                           v	java.util.Vector&amp;lt;E&amp;gt;  (id=198)	&lt;br/&gt;
                              elementCount	1	&lt;br/&gt;
                              elementData	java.lang.Object&lt;span class=&quot;error&quot;&gt;&amp;#91;10&amp;#93;&lt;/span&gt;  (id=200)	&lt;br/&gt;
                                 &lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;	org.apache.derby.impl.sql.compile.Predicate  (id=212)	&lt;br/&gt;
                                    andNode	org.apache.derby.impl.sql.compile.AndNode  (id=120)	&lt;br/&gt;
                                       leftOperand	org.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode  (id=89)	&lt;br/&gt;
                                          rightOperand	org.apache.derby.impl.sql.compile.ColumnReference  (id=124)	&lt;br/&gt;
                                             columnName	&quot;DEPTNO&quot;	&lt;br/&gt;
                                             source	org.apache.derby.impl.sql.compile.ResultColumn  (id=218)		&lt;/p&gt;

&lt;p&gt;In the object association above, if you search for string id=218, you will find that ResultColumn object with id=218 is hanging off the SubqueryNode as well as the JoinNode. I think this is the cause of the problem. &lt;/p&gt;</comment>
                            <comment id="12637563" author="bryanpendleton" created="Tue, 7 Oct 2008 18:47:35 +0100"  >&lt;p&gt;&amp;gt; the ResultColumn associated with the HAVING clause is the same object that is associated with the join node&lt;/p&gt;

&lt;p&gt;Excellent work! I think this is a great theory, and makes a lot of sense.&lt;/p&gt;</comment>
                            <comment id="12637586" author="mamtas" created="Tue, 7 Oct 2008 19:27:36 +0100"  >&lt;p&gt;Following is where we end up generating the code for HAVING clause which uses RSN 3 for the DEPTNO column&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended)	&lt;br/&gt;
	ColumnReference.generateExpression(ExpressionClassBuilder, MethodBuilder) line: 920	&lt;br/&gt;
	BinaryRelationalOperatorNode.generateExpressionOperand(Optimizable, int, ExpressionClassBuilder, MethodBuilder) line: 496	&lt;br/&gt;
	Predicate.generateExpressionOperand(Optimizable, int, ExpressionClassBuilder, MethodBuilder) line: 670	&lt;br/&gt;
	PredicateList.generateSetColumn(ExpressionClassBuilder, MethodBuilder, int, Predicate, Optimizable, LocalField, boolean) line: 3524	&lt;br/&gt;
	PredicateList.generateStartKey(ExpressionClassBuilderInterface, MethodBuilder, Optimizable) line: 3348	&lt;br/&gt;
	NestedLoopJoinStrategy(BaseJoinStrategy).fillInScanArgs1(TransactionController, MethodBuilder, Optimizable, OptimizablePredicateList, ExpressionClassBuilderInterface, MethodBuilder) line: 109	&lt;br/&gt;
	NestedLoopJoinStrategy.getScanArgs(TransactionController, MethodBuilder, Optimizable, OptimizablePredicateList, OptimizablePredicateList, ExpressionClassBuilderInterface, int, MethodBuilder, int, int, int, boolean, int, int, boolean) line: 248	&lt;br/&gt;
	FromBaseTable.getScanArguments(ExpressionClassBuilder, MethodBuilder) line: 3448	&lt;br/&gt;
	FromBaseTable.generateResultSet(ExpressionClassBuilder, MethodBuilder) line: 3138	&lt;br/&gt;
	FromBaseTable.generate(ActivationClassBuilder, MethodBuilder) line: 3065	&lt;br/&gt;
	IndexToBaseRowNode.generate(ActivationClassBuilder, MethodBuilder) line: 234	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1385	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1472	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336	&lt;br/&gt;
	SubqueryNode.generateExpression(ExpressionClassBuilder, MethodBuilder) line: 1879	&lt;br/&gt;
	BinaryRelationalOperatorNode(BinaryOperatorNode).generateExpression(ExpressionClassBuilder, MethodBuilder) line: 590	&lt;br/&gt;
	AndNode(BinaryLogicalOperatorNode).generateExpression(ExpressionClassBuilder, MethodBuilder) line: 157	&lt;br/&gt;
	ProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1516	&lt;br/&gt;
	ProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336	&lt;br/&gt;
	ScrollInsensitiveResultSetNode.generate(ActivationClassBuilder, MethodBuilder) line: 109	&lt;br/&gt;
	CursorNode.generate(ActivationClassBuilder, MethodBuilder) line: 564	&lt;br/&gt;
	CursorNode(StatementNode).generate(ByteArray) line: 347	&lt;br/&gt;
	GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 447	&lt;br/&gt;
	GenericStatement.prepare(LanguageConnectionContext, boolean) line: 88	&lt;br/&gt;
	GenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 796	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 606	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String) line: 555	&lt;br/&gt;
	ij.executeImmediate(String) line: 329	&lt;br/&gt;
	utilMain.doCatch(String) line: 508	&lt;br/&gt;
	utilMain.runScriptGuts() line: 350	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput, Properties) line: 215	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 181	&lt;br/&gt;
	Main.main(String[]) line: 73	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;</comment>
                            <comment id="12638026" author="mamtas" created="Wed, 8 Oct 2008 19:41:26 +0100"  >&lt;p&gt;Just wanted to summarize in brief my findings on this jira entry.&lt;/p&gt;

&lt;p&gt;The main thing to notice about the query below is that derby engine identifies it to be the kind which can fall into sort avoidance code. &lt;br/&gt;
connect &apos;jdbc:derby:c:/dellater/db1;create=true&apos;;&lt;br/&gt;
select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; HAVING 1 = &lt;br/&gt;
  ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ); &lt;/p&gt;

&lt;p&gt;This query is internally dealt in two parts, First one is the&lt;br/&gt;
select q1.&quot;DEPTNO&quot; from DEPTTAB q1, EMPTAB q2 &amp;#8211; DERBY-PROPERTIES joinStrategy = HASH &lt;br/&gt;
where ( q2.&quot;DEPT_DEPTNO&quot; = q1.&quot;DEPTNO&quot;) &lt;br/&gt;
GROUP BY q1.&quot;DEPTNO&quot; &lt;br/&gt;
and the second part is&lt;br/&gt;
HAVING 1 = &lt;br/&gt;
  ( select q3.&quot;SALARY&quot; from EMPTAB q3 where ( q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) ); &lt;/p&gt;

&lt;p&gt;Since the query qualifies for sort avoidance, Derby scans through the rows in the DEPTTAB and EMPTAB to do our own sorting and this leaves us with current row for DEPTTAB and EMPTAB to be nulls. Once we find the row for the first part of the query, Derby enforces the HAVING clause of the query as a restriction on the row returned from the first query. During the application of the restriction, q1.&quot;DEPTNO&quot; in HAVING clause has Derby look at the current row for DEPTTAB but since it is null, we end up getting null pointer exception. If I comment out the sort avoidance detection in the compile phase of the query, we do not run into NPE.&lt;/p&gt;

&lt;p&gt;Hope this summary is useful in understanding why we are running into NPE. I have to say that I do not have lot of ideas at this point as to how to solve the NPE. I will keep poking into the code but if anyone has any pointers/ideas, I can definitely use them.&lt;/p&gt;</comment>
                            <comment id="12638190" author="army" created="Thu, 9 Oct 2008 06:55:57 +0100"  >&lt;p&gt;&amp;gt; Just wanted to summarize in brief my findings on this jira entry. &lt;/p&gt;

&lt;p&gt;Thanks for all of the &lt;b&gt;great&lt;/b&gt; information on this one, Mamta!  I spent some time looking at this and your detailed comments were extremely useful in helping me get up to speed.&lt;/p&gt;

&lt;p&gt;&amp;gt; if anyone has any pointers/ideas, I can definitely use them.&lt;/p&gt;

&lt;p&gt;I did some tracing based on your earlier observation that &quot;the ResultColumn associated with the HAVING clause is the same object that is associated with the join node&quot;.  When comparing a successful query with an unsuccessful one, I noticed that in &lt;b&gt;both&lt;/b&gt; cases the HAVING clause includes a pointer to a ResultColumn that is also referenced by the JoinNode. So that in itself is not necessarily a problem.&lt;/p&gt;

&lt;p&gt;However, it turns out that for the successful query, the ResultColumn reference in question is &lt;b&gt;buried&lt;/b&gt; beneath a chain of VirtualColumn-to-ResultColumn nodes that exist on the right side of the equality (q3.&quot;EMPID&quot; = q1.&quot;DEPTNO&quot;) in the HAVING subquery.  In the failing query, though, the ResultColumn reference is the immediate child of a ColumnReference that is the right side of the equality--there are no intervening VirtualColumn nodes nor any other ResultColumns.&lt;/p&gt;

&lt;p&gt;I think what this means is that, in the failing query, when we set the result set number for the ResultColumns associated with the JoinNode, that result set number inadvertently gets picked up by the equality in the HAVING subquery, which ultimately leads to the NPE, as you discovered.  For the successful query, though, the intervening VirtualColumnNodes and ResultColumns have their &lt;b&gt;own&lt;/b&gt; (correct) result set numbers, and those effectively &quot;hide&quot; the result set number that was set from the JoinNode.&lt;/p&gt;

&lt;p&gt;That said, I did some tracing to try to find out where the intervening VirtualColumnNodes come from in the successful query.  It turns out that GroupByNode.addUnAggColumns() creates the nodes, and then it uses a Visitor implementation to &quot;substitute&quot; those nodes into the query tree at the right place(s).  For a successful query the Visitor performs the substitution in the base table, as it should; but for the failing query, the substitution never happens.  Upon further investigation I noticed that the failing query includes an IndexToBaseRowNode whose child is a FromBaseTable, while the successful query simply includes a FromBaseTable directly.  With that difference in mind I set a breakpoint in the &quot;addUnAggColumns()&quot; method at the line:&lt;/p&gt;

&lt;p&gt;%    havingClause.accept(&lt;br/&gt;
%        (SubstituteExpressionVisitor)havingRefsToSubstitute.get(r));&lt;/p&gt;

&lt;p&gt;and traced from there.  One thing I quickly noticed was that the IndexToBaseRowNode class does &lt;b&gt;not&lt;/b&gt; define an &quot;accept()&quot; method, which means it defaults to the &quot;accept()&quot; method of ResultSetNode.  That&apos;s a problem because ResultSetNode does not know about the FromBaseTable child that exists beneath IndexToBaseRowNode--so ResultSetNode.accept() correctly visits the IndexToBaseRowNode itself, but does &lt;b&gt;NOT&lt;/b&gt; visit the underlying FromBaseTable.  As luck would have it, the substitution that the code in addUnAggColumns() is trying to make is intended for the FromBaseTable (and esp. for the &quot;restriction&quot; predicate that is contained within it), but since that node is never visited, the substitution never happens.&lt;/p&gt;

&lt;p&gt;As an experiment I added an &quot;accept()&quot; method to IndexToBaseRowNode.java that was almost identical to the method as it exists today in SingleChildResultSetNode--I just changed &quot;childResult&quot; to &quot;source&quot; and that was it.  When I did that, I could see the substitution in addUnAggColumns() start to take effect for the failing query, which led to insertion of what appear to be the proper VirtualColumn nodes beneath the HAVING subquery&apos;s predicate, and in the end, the query ran to completion with no error.&lt;/p&gt;

&lt;p&gt;I didn&apos;t do &lt;b&gt;any&lt;/b&gt; other testing of any sort, nor have I looked at the possible side effects of adding an accept() method to IndexToBaseRowNode (I can&apos;t think of any offhand).  But at first glance it seems like the &quot;right&quot; thing to do, and it made the repro for this issue run without error, so if you&apos;re looking for a &quot;what next&quot; step, you could perhaps investigate that angle a bit more...?&lt;/p&gt;

&lt;p&gt;Thanks again for your work continued efforts on this issue!&lt;/p&gt;</comment>
                            <comment id="12638354" author="bryanpendleton" created="Thu, 9 Oct 2008 19:22:40 +0100"  >&lt;p&gt;Army, your analysis makes a lot of sense to me. Having a breakage&lt;br/&gt;
in the addUnAggColumns visitor processing seems like it explains&lt;br/&gt;
the failure very nicely, and is the right way to fix it. Based on your&lt;br/&gt;
description, I constructed the attached &apos;armysFix.diff&apos; and I&lt;br/&gt;
successfully ran a complete set of regression tests without any errors.&lt;/p&gt;

&lt;p&gt;So the change appears at least to do no harm (and, as I said above,&lt;br/&gt;
feels like a proper fix to me). It seems worth pursuing this fix as&lt;br/&gt;
a potential solution to the problem (with regression tests, etc.)&lt;/p&gt;</comment>
                            <comment id="12638677" author="army" created="Sat, 11 Oct 2008 00:19:15 +0100"  >&lt;p&gt;&amp;gt; I constructed the attached &apos;armysFix.diff&apos; and I successfully ran a&lt;br/&gt;
&amp;gt; complete set of regression tests without any errors.&lt;/p&gt;

&lt;p&gt;Thanks much for verifying, Bryan!&lt;/p&gt;</comment>
                            <comment id="12639125" author="mamtas" created="Mon, 13 Oct 2008 18:27:06 +0100"  >&lt;p&gt;Sorry, I was out towards the end of last week and so couldn&apos;t respond sooner. Thanks a bunch Army and Bryan. Seems like we have definitely found a solution. I will apply the patch armysFix.diff and run all the junit and derbyall tests on my machine and commit the patch in next couple days. Thanks again for all your help.&lt;/p&gt;</comment>
                            <comment id="12639146" author="bryanpendleton" created="Mon, 13 Oct 2008 19:14:33 +0100"  >&lt;p&gt;If you have time, I think it would be nice to improve the patch by including&lt;br/&gt;
some regression tests based on the repro scripts that you and Kathey isolated. &lt;/p&gt;</comment>
                            <comment id="12639154" author="mamtas" created="Mon, 13 Oct 2008 19:26:43 +0100"  >&lt;p&gt;Yes, I will plan on incorporating the test case into the patch. Thanks.&lt;/p&gt;</comment>
                            <comment id="12639959" author="mamtas" created="Wed, 15 Oct 2008 21:46:27 +0100"  >&lt;p&gt;Committed the fix for this jira entry into trunk with revision 705037 with following commit comments.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3872&quot; title=&quot;NullPoinerException thrown when INTEGER function used as a predicate in a WHERE clause of a SELECT .. GROUP BY ..  HAVING statement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3872&quot;&gt;&lt;del&gt;DERBY-3872&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The NPE in this jira entry was caused by the missing overwrite of accept() method in IndexToBaseRowNode.&lt;br/&gt;
Because of the missing code, the additional layer of VirtualColumn node over ResultColumn was not &lt;br/&gt;
happening for the where clause in HAVING. Once the accept method was added to IndexToBaseRowNode, the&lt;br/&gt;
VirtualColumn on top of the ResultColumn got the correct resultset number associated with it and at the&lt;br/&gt;
code generation time, we start referencing the correct resultset rather than the one associated with&lt;br/&gt;
the JOIN clause. Thanks a ton to Army and Bryan on this jira entry for their help.&lt;/p&gt;

&lt;p&gt;I have added a test case for this in lang/GroupByTest.java&lt;/p&gt;</comment>
                            <comment id="12640558" author="mamtas" created="Fri, 17 Oct 2008 17:14:13 +0100"  >&lt;p&gt;Merged 705037 into 10.3 codeline. The changes went into 10.3 codeline as part of revision 705660. Will work on merging them into 10.4 codeline next.&lt;/p&gt;</comment>
                            <comment id="12643123" author="mamtas" created="Tue, 28 Oct 2008 04:25:41 +0000"  >&lt;p&gt;Merged 705037 into 10.4 codeline. The changes went into 10.4 codeline as part of revision 708426. &lt;/p&gt;

&lt;p&gt;Will close this jira entry now that the changes are in all the codelines since the bug was introduced.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12325311">DERBY-681</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12389777" name="NPE_Reproduction.sql" size="2917" author="stan" created="Tue, 9 Sep 2008 21:58:42 +0100"/>
                            <attachment id="12389953" name="QueryWithTruePred.out" size="10851" author="kmarsden" created="Thu, 11 Sep 2008 19:43:18 +0100"/>
                            <attachment id="12389952" name="QueryWithoutTruePred.out" size="4775" author="kmarsden" created="Thu, 11 Sep 2008 19:43:18 +0100"/>
                            <attachment id="12391837" name="armysFix.diff" size="1235" author="bryanpendleton" created="Thu, 9 Oct 2008 19:22:40 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 10 Sep 2008 02:49:13 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23891</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0lan:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37268</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>