<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:17:40 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3788/DERBY-3788.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3788] Provide a zero-admin way of updating the statisitcs of an index</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3788</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-269&quot; title=&quot;Provide some way to update index cardinality statistics (e.g. reimplement update statistics)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-269&quot;&gt;&lt;del&gt;DERBY-269&lt;/del&gt;&lt;/a&gt; provided a manual way of updating the statistics using the new system stored procedure SYSCS_UTIL.SYSCS_UPDATE_STATISTICS. It will be good for Derby to provide an automatic way of updating the statistics without requiring to run the stored procedure manually. There was some discussion on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-269&quot; title=&quot;Provide some way to update index cardinality statistics (e.g. reimplement update statistics)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-269&quot;&gt;&lt;del&gt;DERBY-269&lt;/del&gt;&lt;/a&gt; about providing the 0-admin way. I have copied it here for reference.&lt;/p&gt;

&lt;p&gt;*********************&lt;br/&gt;
Kathey Marsden - 22/May/05 03:53 PM &lt;br/&gt;
Some sort of zero admin solution for updating statistics would be prefferable to the manual &apos;update statistics&apos; &lt;br/&gt;
*********************&lt;/p&gt;


&lt;p&gt;*********************&lt;br/&gt;
Mike Matrigali - 11/Jun/08 12:37 PM &lt;br/&gt;
I have not seen any other suggestions, how about the following zero admin solution? It is not perfect - suggestions welcome. &lt;/p&gt;

&lt;p&gt;Along with the statistics storing, save how many rows were in the table when exact statistics were calculated. This number is 0 if none have been calculated because index creation happened on an empty table. At query compile time when we look up statistics we automatically recalculate the statistics at certain threshholds - say something like row count growing past next threshhold : 10, 100, 1000, 100000 - with upper limit being somewhere around how many rows we can process in some small amount of time - like 1 second on a modern laptop. If we are worried about response time, maybe we background queue the stat gathering rather than waiting with maybe some quick load if no stat has ever been gathered. The background gathering could be optimized to not interfere with locks by using read uncommitted. &lt;/p&gt;

&lt;p&gt;I think it would be useful to also have the manual call just to make it easy to support customers and debug issues in the field. There is proably always some dynamic data distribution change that in some case won&apos;t be picked up by the automatic algorithm. Also just very useful for those who have complete control of the create ddl, load data, run stats, deliver application process. &lt;br/&gt;
*********************&lt;/p&gt;</description>
                <environment></environment>
        <key id="12400682">DERBY-3788</key>
            <summary>Provide a zero-admin way of updating the statisitcs of an index</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="mamtas">Mamta A. Satoor</reporter>
                        <labels>
                    </labels>
                <created>Mon, 21 Jul 2008 19:43:19 +0100</created>
                <updated>Mon, 17 Jun 2013 10:19:51 +0100</updated>
                            <resolved>Sun, 6 Mar 2011 11:42:23 +0000</resolved>
                                    <version>10.5.1.1</version>
                                    <fixVersion>10.8.1.2</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12618394" author="mamtas" created="Wed, 30 Jul 2008 16:42:13 +0100"  >&lt;p&gt;Added a new test case with revision 681085 which shows that updating the statistics will make a query pickup better index compare to prior to statistics availability&lt;/p&gt;</comment>
                            <comment id="12618461" author="mamtas" created="Wed, 30 Jul 2008 19:36:28 +0100"  >&lt;p&gt;I am looking at creating the statistics automatically if they are found to be absent when needed. As a next step later, we can look at updating the statistics automatically under certain threshold if they appear to be out of sync.&lt;/p&gt;</comment>
                            <comment id="12618494" author="mamtas" created="Wed, 30 Jul 2008 21:19:25 +0100"  >&lt;p&gt;Currently, iapi.sql.dictionary.TableDescriptor has a method called statisticsExist which checks for the passed conglomerate if there is statistics availble or not. This method gets called &lt;br/&gt;
1)during the optimization phase of a query by impl.sql.compile.FromBaseTable.estimateCost&lt;br/&gt;
2)during the optimization phase of a query by impl.sql.compile.PredicateList.selectivity&lt;br/&gt;
3)by impl.sql.execute.AlterTableConstantAction to determine if the statistics already exist and if yes, then drop and recreate it. This happens during the compress table request(not sure if anything other than compress table in AlterTableConstantAction calls it but we do not need to worry about it because we only want to create the statistics if they don&apos;t already exist during the compile phase of a sql query)&lt;/p&gt;

&lt;p&gt;What I am considering doing is adding another method to TableDescriptor called say createStatistics which will be called during the optimization phase of a query by the 2 classes impl.sql.compile.FromBaseTable and impl.sql.compile.PredicateList. The only awkward thing I am finding is the code required to update the statistics need many objects like LanguageConnectionContext, DataDictionary, TransactionController, etc (there may be more) and they are not available to TableDescriptor class so I will have to pass these objects when a call is made to the new method in TableDescriptor from impl.sql.compile. Does this sound like not a smooth way of getting the objects? Maybe this new method should be defined in DataDictionary rather than TableDescriptor. I will work more on what is the right place for the new method. In the mean time, if anyone has any thoughts, please post them here.&lt;/p&gt;

&lt;p&gt;Once we have this new method to create the statistics, we can hopefully remove the redudant code that already exists to create the statistics in 3 different classes, namely, AlterTableConstantAction, CreateIndexConstantAction and InsetResultSet.&lt;/p&gt;</comment>
                            <comment id="12621910" author="mamtas" created="Tue, 12 Aug 2008 19:09:20 +0100"  >&lt;p&gt;I am looking to see if the statistics do not exist for an index during a query compile phase, then try to create them while compiling the query. But trying to create statistics during query compilation throw following exception. &lt;br/&gt;
ERROR XCL21: You are trying to execute a Data Definition statement (CREATE, DROP, or ALTER) while preparing a different statement. This is not allowed. It can happen if you execute a Data Definition statement from within a static initializer of a Java class that is being used from within a SQL statement.&lt;/p&gt;

&lt;p&gt;The exception is being thrown from DataDictionaryImpl.startWriting(LanguageConnectionContext) through following piece of code&lt;br/&gt;
/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Don&apos;t allow DDL if we&apos;re binding a SQL statement.&lt;br/&gt;
*/&lt;br/&gt;
if (lcc.getBindCount() != 0)
{
throw StandardException.newException(SQLState.LANG_DDL_IN_BIND);
}&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My question is can we disable this say when statistics are getting updated while a query is getting executed? Is there any other way of achieving creating statistics on fly when we know that we are going to need them during the execution of the current query? Appreciate any feedack.&lt;/p&gt;</comment>
                            <comment id="12621933" author="mikem" created="Tue, 12 Aug 2008 20:03:10 +0100"  >&lt;p&gt;I don&apos;t know if any of these are good ideas but maybe someone with knowledge of code can discuss.  They are &lt;br/&gt;
options that came to mind:&lt;br/&gt;
1) explore why the error is happening and see if updating stats can be special cased.  It is different than a &lt;br/&gt;
     &quot;real&quot; ddl that might cause havoc changing during a comple.&lt;br/&gt;
2) rather than update the stat, just inline calculate and use that for current compile and schedule a later task after&lt;br/&gt;
    compile to do the update.&lt;br/&gt;
3) give up on updating during compile and just use default, but schedule update after compile and somehow mark query to be recompiled again the next time (this might automatically happen if update of statistic already causes dependency to change on compiled query - i don&apos;t know.&lt;br/&gt;
4) when you find missing stat, give up on current compile, update stat, and then retry the compile.&lt;/p&gt;

&lt;p&gt;As I understood it, you were looking at inline update of stats as a incremental dev step - maybe it is not worth it&lt;br/&gt;
given the problems and you should jump to long term strategy of delaying update.  &lt;/p&gt;</comment>
                            <comment id="12626236" author="mamtas" created="Wed, 27 Aug 2008 19:39:34 +0100"  >&lt;p&gt;Based on the feedback from Mike, I am thinking of pursuing option 3)&quot;give up on updating during compile and just use default, but schedule update after compile and somehow mark query to be recompiled again the next time (this might automatically happen if update of statistic already causes dependency to change on compiled query - i don&apos;t know. &quot;&lt;/p&gt;

&lt;p&gt;I will concentrate on the first part of option 3 which is to schedule update statistics after query compile if the query compile finds that the required statistics are not available. As recommended by Dan on Derby dev list (&lt;a href=&quot;http://www.nabble.com/higher-level-background-work-in-the-derby-server,-where-should-it-go--td18950929.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/higher-level-background-work-in-the-derby-server,-where-should-it-go--td18950929.html&lt;/a&gt;), I am trying to use classes in java.util.concurrent rather than some home-built background jobs mechanism.&lt;/p&gt;

&lt;p&gt;To break option 3) first part further into mini-steps, I have written a &quot;Hello World&quot; program using the java.util.concurrent package. This is totally out of the Derby code, just stand alone JAVA program. There are 2 physical java files(attached to this jira entry for reference). One(DERBY_3788_Mgr) creates the ThreadPoolExecutor and then adds 30 Hello World background tasks (DERBY_3788_Repro). In order to execute this, use following&lt;br/&gt;
java org.apache.derbyTesting.functionTests.tests.jdbc4.DERBY_3788_Mgr&lt;/p&gt;

&lt;p&gt;One thing to note is that java.util.concurrent.ThreadPoolExecutor was introduced in jdk1.5 and hence need to run with jdk1.5 or higher version to run this program. We will have to discuss what do we want to do for jdks prior to 1.5&lt;/p&gt;

&lt;p&gt;As the next mini-step, I am going to see how I can put this ThreadPoolExecutor framework in our codeline when we detect that statistics are not available. At this step, I will just do some sort of println in the background thread for update statistics requirement. Once that is in place, I will try to see how I can actually fire update statistics code from the background threads.&lt;/p&gt;

&lt;p&gt;Any comments/feedback on what I have so far or what the plan is?&lt;/p&gt;</comment>
                            <comment id="12626713" author="mamtas" created="Thu, 28 Aug 2008 20:39:05 +0100"  >&lt;p&gt;As per my comment on this jira entry yesterday, I am trying to use ThreadPoolExecutor in Derby codeline so it can be used to fire the update statistics tasks in the background. ThreadPoolExecutor was added as part of jdk1.5 When I include the import of this class into DataDictionary.java(I will refer to it as DD), I ofcourse need to make sure that the DD.java gets compiled with 1.5 and higher. But at run time, requiring the user to have 1.5 or higher is not going to work. &lt;/p&gt;

&lt;p&gt;At this point, I am thinking of addressing this by having a subclass of DD, called say DD5 which will be loaded by the monitor code if we know that we are dealing with jdk 1.5 or higher. For the earlier versions, &lt;b&gt;for now&lt;/b&gt;, trying to schedule update statistics tasks in the background will be a no-op. This way, I will be able to have the new code run(rather do no-op for jdk1.4 and lower) in all supported versions of jdks. If anyone has any feedback on my approach, please let me know.&lt;/p&gt;

&lt;p&gt;Some background information : iapi.sql.dictionary.TableDescriptor has an existing method called statisticsExist which will return true if the statistics exist. This method gets called by the query optimization phase along with AlterTableConstantAction. For the query optimization phase, we want to be able to schedule update statistics tasks in the background if TableDescriptor.statisticsExist () returns false. Following is the pseudo-code I have in mind:&lt;/p&gt;

&lt;p&gt;during the query optimization &lt;br/&gt;
    if (TableDescriptor.statisticsExist == false) &lt;/p&gt;
{
        TableDescriptor.createStatisticsInBackGround(schemaname, tablename, indexname) &amp;lt;----- new method in TableDescriptor
    }

&lt;p&gt;TableDescriptor with new method&lt;br/&gt;
    createStatisticsInBackGround(.....) &lt;/p&gt;
{
          DD.scheduleUpdateStatisticstask(...) &amp;lt;------ new method in DD. 
     }

&lt;p&gt;DD5 will do the real work of scheduling the taks in background. In DD(ie when running with jdk1.4 and lower), this method will be no-op.&lt;/p&gt;

&lt;p&gt;DD5 with new method (for jdk1.5 and higher)&lt;br/&gt;
    scheduleUpdateStatisticstask(...) &lt;/p&gt;
{
           create ThreadPoolExecutor if does not already exist
           queue update statistics task on the ThreadPoolExecutor
    }

&lt;p&gt;DD with new method (for jdk1.4 and lower)&lt;br/&gt;
    scheduleUpdateStatisticstask(...) &lt;/p&gt;
{
            no-op
    }</comment>
                            <comment id="12629192" author="mamtas" created="Mon, 8 Sep 2008 17:25:38 +0100"  >&lt;p&gt;I now do have the basic framework of using the ThreadPoolExecutor in new extended class DataDictionary5(DD5). I have called the method in DD5 as updateStatisticsInBackGround rather than scheduleUpdateStatisticstask. This method in DD5 right now just queues println tasks everytime an update statistics request is sent its ways. This is what the method code in DD5 looks like right now&lt;/p&gt;

&lt;p&gt;	public void updateStatisticsInBackGround(String schemaName,&lt;br/&gt;
			String tableName, String indexName) {&lt;br/&gt;
		System.out.println(&quot;came to jdk 1.5 implementation&quot;);&lt;br/&gt;
		if (executorForUpdateStatistics==null)&lt;/p&gt;
		{
			executorForUpdateStatistics = new ThreadPoolExecutor(5,5,0L,
					TimeUnit.MILLISECONDS,
					new LinkedBlockingQueue(5));
			executorForUpdateStatistics.setRejectedExecutionHandler(
					new ThreadPoolExecutor.CallerRunsPolicy());			
		}
&lt;p&gt;		executorForUpdateStatistics.execute(new &lt;br/&gt;
				BackgroundUpdateStatisticTask (schemaName,&lt;br/&gt;
						tableName, indexName));&lt;br/&gt;
		return;&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;The new class BackgroundUpdateStatisticTask right now just does println as shown below&lt;br/&gt;
class BackgroundUpdateStatisticTask implements Runnable{&lt;br/&gt;
	private String schemaName;&lt;br/&gt;
	private String tableName;&lt;br/&gt;
	private String indexName;&lt;/p&gt;

&lt;p&gt;	public BackgroundUpdateStatisticTask(String schemaName,&lt;br/&gt;
			String tableName, String indexName) &lt;/p&gt;
{
		this.schemaName=schemaName;
		this.tableName=tableName;
		this.indexName=indexName;
	}
&lt;p&gt;	public void run()&lt;/p&gt;
	{
		System.out.println(&quot;Hello World : Updating statistics for &quot;
				+ schemaName + &quot;:&quot; + tableName + &quot;:&quot; + indexName);
	}
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;As the next step, I now want to actually do update statistics in BackgroundUpdateStatisticTask rather than just println. I thought I would be able to do something like following in the run method in BackgroundUpdateStatisticTask &lt;br/&gt;
	public void run()&lt;br/&gt;
	{&lt;br/&gt;
		System.out.println(&quot;Hello World : Updating statistics for &quot;&lt;br/&gt;
				+ schemaName + &quot;:&quot; + tableName + &quot;:&quot; + indexName);&lt;br/&gt;
		try &lt;/p&gt;
{
			SystemProcedures.SYSCS_UPDATE_STATISTICS(schemaName, tableName,
					indexName);
		}
&lt;p&gt; catch (SQLException e)&lt;/p&gt;
		{
				System.out.println(&quot;got exception&quot;);
				e.printStackTrace();
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;But a call to SystemProcedures.SYSCS_UPDATE_STATISTICS inside of the run method results in &lt;/p&gt;

&lt;p&gt;java.sql.SQLException: No current connection.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:87)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:103)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.noCurrentConnection(Util.java:207)&lt;br/&gt;
        at org.apache.derby.catalog.SystemProcedures.getDefaultConn(SystemProcedures.java:185)&lt;br/&gt;
        at org.apache.derby.catalog.SystemProcedures.SYSCS_UPDATE_STATISTICS(SystemProcedures.java:737)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.BackgroundUpdateStatisticTask.run(DataDictionaryImpl5.java:90)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:595)&lt;/p&gt;

&lt;p&gt;So, it appears that I do not have the context setting done correctly in order to run the stored procedure implementation in SystemProcedures.SYSCS_UPDATE_STATISTICS. I am currently trying to see how we do the required setup when a JDBC connection is made but at this point, I am not clear on how might be able to use some of that code from JDBC connection time into BackgroundUpdateStatisticTask.run method. I will appreciate any help I can get to do the context setting so I can run the update statistics. thanks.&lt;/p&gt;</comment>
                            <comment id="12645357" author="mamtas" created="Wed, 5 Nov 2008 23:09:17 +0000"  >&lt;p&gt;First of all, let me start out by saying that this patch may not be ready for commit yet depending on what the community thinks about the approach taken to establish a Connection in a background thread to fire update statisitcs jobs. &lt;/p&gt;

&lt;p&gt;Background information&lt;br/&gt;
There can be situations in Derby where the statistics might not exist for some of the indexes. The absence of statistics will hamper optimizer for picking up the best available path for query execution. We have added a manual way of updating the statistics through &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-269&quot; title=&quot;Provide some way to update index cardinality statistics (e.g. reimplement update statistics)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-269&quot;&gt;&lt;del&gt;DERBY-269&lt;/del&gt;&lt;/a&gt;. But this is a manual process rather than zero-admin way of mainting statistics. I am attempting to have Derby fire the update statistics job in the background when it finds that statistics are not available for an index. Derby can detect the unavailability of statistics during query optimization phase where it queries SYSSTATISTICS table to see if statistics are available for an index. With my patch, if the statistics are missing, then we will schedule a background task to have the statistics available for next time around when optimizer needs to look at them. To schedule these tasks, rather than inventing our own way of managaing threads, I have relied on new classes available in jdk1.5 This means that the zero-admin way of maintaining statistics will be available in jdk 1.5 and higher versions. In order to make the update statistics funtionality available in jdk1.5 and higher, I had to subclass a new version of DataDictionaryImpl called DataDictionaryImpl5 and that class will be used only for jdk1.5 and higher. The background task creates an EmbedConnection of it&apos;s own and executes following sql on the JDBC Statement obtained from the EmbedConnection.&lt;br/&gt;
CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(schemaName, tableName, indexName);&lt;/p&gt;

&lt;p&gt;This is where I would appreciate if the Derby community can see if my approach is the best way to execute update statistics ie by creating an EmbedConnection. What&apos;s even trickier is the way I get the correct instance of InternalDriver, the url and properties that were used to make the original JDBC connection which required us to fire this update statistics task. The code may not look very clean in how get these objects which are required to make an EmbedConnection. I tried looking through existing Derby code to see if we are required to execute our own sql in an independent thread but I didn&apos;t find any luck with that. So, please let me know if you agree with the approach or have ideas on how to achieve this in a different way, I will really appreciate it. The work of getting the required objects to create an EmbedConnection happens in DataDictionaryImpl5.&lt;/p&gt;

&lt;p&gt;Please let me know if I can provide more information to make the patch more clear. I haven&apos;t put much comments in the new code in the patch because I wanted to sure that we as a community agree on the approach taken to do the actual work of update statistics by creating EmbedConnection object.&lt;/p&gt;

&lt;p&gt;I did try running the existing junit tests with my patch and found handful of tests to fail. I analyzed few of those failures and I think they are locking failures. I have a feeling that when we try to update the statistics, we hold the locks which conflict with what the test might be doing at the same time that statistics are getting updated in a different thread. I wonder what should we do about these failures.&lt;/p&gt;</comment>
                            <comment id="12646924" author="mamtas" created="Wed, 12 Nov 2008 15:12:08 +0000"  >&lt;p&gt;I was wondering if anyone got a chance to look at the patch and have any comments about how I am getting an EmbedConnection in the background thread to update the statistics. Thanks.&lt;/p&gt;</comment>
                            <comment id="12647253" author="knutanders" created="Thu, 13 Nov 2008 10:44:06 +0000"  >&lt;p&gt;Hi Mamta,&lt;/p&gt;

&lt;p&gt;Sorry for posting the comments so late. I don&apos;t see the DataDictionaryImpl5 class in the patch. Did you forget to do svn add?&lt;/p&gt;

&lt;p&gt;Which isolation level does the background thread use when it updates the statistics? I see that Mike has suggested read uncommitted in order to minimize the impact on locking.&lt;/p&gt;</comment>
                            <comment id="12647633" author="mamtas" created="Fri, 14 Nov 2008 15:27:27 +0000"  >&lt;p&gt;Knut, thanks for taking the time to review the patch. I took the day off yesterday so couldn&apos;t reply sooner. I have added a new patch which includes DataDictionaryImpl5.java Please let me know what do you think of the code, especially, the part where I create a EmbedConnection using different objects collected earlier before the background thread was fired.&lt;/p&gt;

&lt;p&gt;As for locking, I am no using any special isolation level for the update statistics when fired through the background thread. The background update statistics thread is using the same isolation that currently is used by update statistics when a user manually fires update statistics through CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS(..,..,..)&lt;/p&gt;</comment>
                            <comment id="12648558" author="knutanders" created="Tue, 18 Nov 2008 10:04:37 +0000"  >&lt;p&gt;Thanks for the updated patch, Mamta.&lt;/p&gt;

&lt;p&gt;I&apos;m afraid I cannot offer very much guidance, but I have some&lt;br/&gt;
questions and comments:&lt;/p&gt;

&lt;p&gt;1) This patch addresses the problem with non-existing statistics, not&lt;br/&gt;
the problem with outdated statistics. In which situations don&apos;t the&lt;br/&gt;
statistics exist? If it doesn&apos;t happen very often, it might be fine to&lt;br/&gt;
update the statistics in the same thread.&lt;/p&gt;

&lt;p&gt;2) Are the calls to EmbedConnection30.setupContextStack() and&lt;br/&gt;
restoreContextStack() needed around the call to execute()? I thought&lt;br/&gt;
execute() would call setup/restoreContextStack() itself.&lt;/p&gt;

&lt;p&gt;3) Creating an EmbedConnection30 object directly breaks the&lt;br/&gt;
modularity. Unless the calls to the internal methods are necessary, it&lt;br/&gt;
may be better to use InternalDriver.activeDriver().connect(url, info)&lt;br/&gt;
instead.&lt;/p&gt;

&lt;p&gt;4) I think that the creation of a new connection will reboot the&lt;br/&gt;
database if it has been shut down in the user thread, which may lead&lt;br/&gt;
to unpredictable behaviour. It also seems like it will preserve all&lt;br/&gt;
connection attributes, like attributes to reencrypt the database or to&lt;br/&gt;
start replication master.&lt;/p&gt;

&lt;p&gt;5) There&apos;s a comment in DDImpl5.updateStatisticsInBackGround() saying&lt;br/&gt;
that &quot;cm is null the very first time, and whenever we aren&apos;t actually&lt;br/&gt;
nested.&quot; I&apos;m not sure I understand that comment. Why is it null the&lt;br/&gt;
first time? And isn&apos;t the method always called in a nested context?&lt;br/&gt;
And if it is null, wouldn&apos;t that cause a NullPointerException in&lt;br/&gt;
EmbedConnection&apos;s constructor when url=null is passed in?&lt;/p&gt;

&lt;p&gt;6) DDImpl5.updateStatisticsInBackGround() updates the shared variable&lt;br/&gt;
executorForUpdateStatistics if it is null. But it is not protected by&lt;br/&gt;
synchronization, so race conditions are possible.&lt;/p&gt;

&lt;p&gt;7) DDImpl5.stop() should call super.stop().&lt;/p&gt;

&lt;p&gt;8) In BackgroundUpdateStatisticsTask, using a prepared statement with&lt;br/&gt;
the table name and the index name parametrized would be better because&lt;br/&gt;
it would handle quoting special characters correctly (not handled in&lt;br/&gt;
the current patch) and it would reduce the number of entries in the&lt;br/&gt;
statement cache.&lt;/p&gt;

&lt;p&gt;9) As to the locking issues, I would have tried to call&lt;br/&gt;
Connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED)&lt;br/&gt;
in the background thread to see if that solved/reduced the issues.&lt;/p&gt;</comment>
                            <comment id="12649820" author="mamtas" created="Fri, 21 Nov 2008 21:59:04 +0000"  >&lt;p&gt;Thanks again for your time, Knut. I will try to address some of the questions in this comment. I am planning on taking next week as vacation so will get back on this task after that.&lt;br/&gt;
1)In this jira entry, missing statisitcs will be detected when the user executes a select. I had originally just for the sake of trying attempted to create the statistics in the select thread when I find that the statistics are missing. But executing an update inside of a select processing caused problem because data dictionary was not in write mode. Because of that, I couldn&apos;t update the statistics during the select processing. One very simple example where one will find missing statistics is as follows&lt;br/&gt;
create table t1 (c11 int, c12 char);&lt;br/&gt;
create index i1 on t1(c11);&lt;br/&gt;
insert into t1 values (1,&apos;1&apos;),(2,&apos;2&apos;),(3,&apos;3&apos;);&lt;br/&gt;
select * from sys.sysstatistics;&lt;/p&gt;

&lt;p&gt;My goal is to fire the statistics in background when user executes say following sql&lt;br/&gt;
select * from t1 where c11=1;&lt;/p&gt;

&lt;p&gt;2)As for the calls to setting the context and unsetting, I think you are right. I will remove them and see how it goes.&lt;/p&gt;</comment>
                            <comment id="12649882" author="dagw" created="Sat, 22 Nov 2008 01:40:34 +0000"  >&lt;p&gt;Would a solution to this issue solve &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3892&quot; title=&quot;Query execution hangs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3892&quot;&gt;&lt;del&gt;DERBY-3892&lt;/del&gt;&lt;/a&gt;? If so, it might be good to say so there and link it to this issue.&lt;/p&gt;</comment>
                            <comment id="12652114" author="mamtas" created="Mon, 1 Dec 2008 19:34:43 +0000"  >&lt;p&gt;My understanding of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3892&quot; title=&quot;Query execution hangs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3892&quot;&gt;&lt;del&gt;DERBY-3892&lt;/del&gt;&lt;/a&gt; is as follows&lt;br/&gt;
1)A query is exectued and the best plan for it is picked up based on the current data in the database&lt;br/&gt;
2)The data changes quite a bit which makes the plan chosen for the query not an optimal plan but during the next execution of the query, we continue to use the plan chosen in step 1). &lt;/p&gt;

&lt;p&gt;Based on the above understanding of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3892&quot; title=&quot;Query execution hangs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3892&quot;&gt;&lt;del&gt;DERBY-3892&lt;/del&gt;&lt;/a&gt;, the current work going on for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3788&quot; title=&quot;Provide a zero-admin way of updating the statisitcs of an index&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3788&quot;&gt;&lt;del&gt;DERBY-3788&lt;/del&gt;&lt;/a&gt; is not going to fix &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3892&quot; title=&quot;Query execution hangs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3892&quot;&gt;&lt;del&gt;DERBY-3892&lt;/del&gt;&lt;/a&gt;. This jira entry will go and build the statistics if during the query compilation it is found that the required statistics do not exist. Hope this answers your question about &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3892&quot; title=&quot;Query execution hangs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3892&quot;&gt;&lt;del&gt;DERBY-3892&lt;/del&gt;&lt;/a&gt;, Dag.&lt;/p&gt;</comment>
                            <comment id="12652427" author="mamtas" created="Tue, 2 Dec 2008 17:18:15 +0000"  >&lt;p&gt;Knut, couple more responses to some of your comments.&lt;br/&gt;
3) Creating an EmbedConnection30 object directly breaks the &lt;br/&gt;
modularity. Unless the calls to the internal methods are necessary, it &lt;br/&gt;
may be better to use InternalDriver.activeDriver().connect(url, info) &lt;br/&gt;
instead. &lt;br/&gt;
There was no specific need to be directly creating EmbedConnection30 object, so I have used your recommendation to get the Connection object.&lt;/p&gt;

&lt;p&gt;5) There&apos;s a comment in DDImpl5.updateStatisticsInBackGround() saying &lt;br/&gt;
that &quot;cm is null the very first time, and whenever we aren&apos;t actually &lt;br/&gt;
nested.&quot; I&apos;m not sure I understand that comment. Why is it null the &lt;br/&gt;
first time? And isn&apos;t the method always called in a nested context? &lt;br/&gt;
And if it is null, wouldn&apos;t that cause a NullPointerException in &lt;br/&gt;
EmbedConnection&apos;s constructor when url=null is passed in? &lt;br/&gt;
I used the current model to get the ContextManager similar to how we get it in jdbc,InternalDriver:getConnectionContext and there we do a check for null ContextManager. Looking at that code, I thought there might be a case where ContextManager could be null. To address the NullPointerException that may result because of url being null in case of null ContextManager, I have changed the code in DDImpl5.updateStatisticsInBackGround() to fire the background update statistics only if ContextManager is not null. So the new code looks as follows&lt;br/&gt;
	public void updateStatisticsInBackGround(String schemaName,&lt;br/&gt;
			String tableName, String indexName) throws StandardException{&lt;br/&gt;
		String url = null;&lt;br/&gt;
		Properties info = null;&lt;br/&gt;
		if (executorForUpdateStatistics==null)&lt;/p&gt;
		{
			executorForUpdateStatistics = new ThreadPoolExecutor(5,5,0L,
					TimeUnit.MILLISECONDS,
		              new LinkedBlockingQueue(5));
			executorForUpdateStatistics.setRejectedExecutionHandler(
					new ThreadPoolExecutor.CallerRunsPolicy());	
		}
&lt;p&gt;		ContextService csf = ContextService.getFactory();&lt;/p&gt;

&lt;p&gt;		ContextManager cm = csf.getCurrentContextManager();&lt;br/&gt;
		ConnectionContext localCC = null;&lt;/p&gt;

&lt;p&gt;		/*&lt;br/&gt;
			cm is null the very first time, and whenever&lt;br/&gt;
			we aren&apos;t actually nested.&lt;br/&gt;
		 */&lt;br/&gt;
		if (cm != null) &lt;/p&gt;
{
			localCC = (ConnectionContext)
				(cm.getContext(ConnectionContext.CONTEXT_ID));
			TransactionResourceImpl tr = localCC.getTR();
			url = tr.getUrl();
			info = tr.getInfo();
			executorForUpdateStatistics.execute(new 
					BackgroundUpdateStatisticTask (schemaName,
							tableName, indexName, url, info));
		}

&lt;p&gt;		return;&lt;br/&gt;
	}&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;Will work on addressing the remaining comments. &lt;/p&gt;</comment>
                            <comment id="12653385" author="mamtas" created="Thu, 4 Dec 2008 17:54:26 +0000"  >&lt;p&gt;I am attaching a new patch which incorporates following comments from Knut.&lt;br/&gt;
2)Are the calls to EmbedConnection30.setupContextStack() and restoreContextStack() needed around the call to execute()? I thought execute() would call setup/restoreContextStack() itself. &lt;br/&gt;
I removed the calls to setup and restore the stack since as Knut pointed out, they are unnecessary.&lt;br/&gt;
3)Creating an EmbedConnection30 object directly breaks the modularity. Unless the calls to the internal methods are necessary, it may be better to use InternalDriver.activeDriver().connect(url, info) instead. &lt;br/&gt;
I removed the direct creation of EmbedConnection30 and instead use InternalDriver.activeDriver().connect(url, info) &lt;br/&gt;
5)There&apos;s a comment in DDImpl5.updateStatisticsInBackGround() saying that &quot;cm is null the very first time, and whenever we aren&apos;t actually nested.&quot; I&apos;m not sure I understand that comment. Why is it null the first time? And isn&apos;t the method always called in a nested context? And if it is null, wouldn&apos;t that cause a NullPointerException in EmbedConnection&apos;s constructor when url=null is passed in? &lt;br/&gt;
In the case that ContextManager may be null, I do not fire statistics creation in background because that will cause NPE later on because url is null.&lt;br/&gt;
6) DDImpl5.updateStatisticsInBackGround() updates the shared variable executorForUpdateStatistics if it is null. But it is not protected by synchronization, so race conditions are possible. &lt;br/&gt;
I now have synchronization code around the code that can result in race conditions.&lt;br/&gt;
7) DDImpl5.stop() should call super.stop(). &lt;br/&gt;
Did this.&lt;br/&gt;
8) In BackgroundUpdateStatisticsTask, using a prepared statement with the table name and the index name parametrized would be better because it would handle quoting special characters correctly (not handled in &lt;br/&gt;
the current patch) and it would reduce the number of entries in the statement cache. &lt;br/&gt;
Now using PreparedStatement rather than Statement.&lt;/p&gt;

&lt;p&gt;The 2 comments from Knut that are not addressed in this patch are as follows&lt;br/&gt;
4) I think that the creation of a new connection will reboot the database if it has been shut down in the user thread, which may lead to unpredictable behaviour. It also seems like it will preserve all connection attributes, like attributes to reencrypt the database or to start replication master. &lt;br/&gt;
I think there might be an issue as raised by Knut&apos;s comment 4). I still have to trace down completely why some of the junit test failures with my patch say Database &quot;Failed to start(/create) database&quot;. It might be because of the properties that are used to create the new Connection object to run the statistics in background. I am not sure yet if it happens during every run of the test jdbcapi.DriverMgrAuthenticationTest but I have seen that test to be one of the tests that fails with Failed to create database. I will work on trying to figure out at what point does the test fail with these errors. If anyone has any ideas on the failures or how we should create the new Connection object,&lt;br/&gt;
I will highly appreciate that.&lt;br/&gt;
9) As to the locking issues, I would have tried to call Connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED) in the background thread to see if that solved/reduced the issues. &lt;br/&gt;
I am not 100% about this but I this using isolation Connection.TRANSACTION_READ_UNCOMMITTED had slowed down test runs on my machine. I would like to address number 4 first so that at least the test failures go down and then I can focus on usage of isolation level &lt;br/&gt;
Connection.TRANSACTION_READ_UNCOMMITTED. There ARE few tests that fail because of lock time out and may be using the isolation level recommended by Knut will help.&lt;/p&gt;

&lt;p&gt;So, at this point, I will focus on 4) to try to narrow down where are the failures coming from. In the mean time, if community has time to run the junit tests to see if they notice noticeable performance problems with my patch, I will appreciate that feedback. Thanks&lt;/p&gt;</comment>
                            <comment id="12671349" author="mamtas" created="Fri, 6 Feb 2009 21:59:07 +0000"  >&lt;p&gt;Currently, I am pursuing running the missing statistics inline in the compile phase of a SELECT query. The compile phase code is driven by GenericStatement.prepMinion. &lt;/p&gt;

&lt;p&gt;My first attempt was to run the update statistics inline in the optimize phase of a SELECT sql (because in the optimize phase of a query, we look for statistics for determining the query plan for execution and that is when we know that the statistics are missing) but there I ran into data dictionary being in read-only mode. In GenericStatement.prepMinion method, at line 307, we mark the data dictionary(DD) as read-only for the duration of bind and optimize phase and hence statistics can&apos;t be updated because DD has been marked readonly at this time. &lt;/p&gt;

&lt;p&gt;At line 422, after the optimize phase, we mark the DD as done reading and hence DD is not in read-only mode during the generate phase. Based on this, I tried running the statistics inline in the generate phase of SELECT query to establish the fact that the statistics can indeed be run in-;ine. I ran into only one coding issues &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4048&quot; title=&quot;Update Statistics code in AlterTableConstantAction should use execute transaction rather than compile transaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4048&quot;&gt;&lt;del&gt;DERBY-4048&lt;/del&gt;&lt;/a&gt; (about AlterTableConstantAction not using execute transaction for updating the statistics). After resolving &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4048&quot; title=&quot;Update Statistics code in AlterTableConstantAction should use execute transaction rather than compile transaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4048&quot;&gt;&lt;del&gt;DERBY-4048&lt;/del&gt;&lt;/a&gt;, I am able to run the update statistics inline in the generate phase of a SELECT query for a simple test case as shown below&lt;br/&gt;
create table t1 (c11 int, c12 char);&lt;br/&gt;
create index i1 on t1(c11);&lt;br/&gt;
insert into t1 values (1,&apos;1&apos;),(2,&apos;2&apos;),(3,&apos;3&apos;);&lt;br/&gt;
&amp;#8211; no statistics will be found for t1.i1 because table was empty when index i1 was created&lt;br/&gt;
select * from sys.sysstatistics;&lt;br/&gt;
&amp;#8211; during the generate phase of following query, we will run update statistics inline for t1.i1&lt;br/&gt;
select * from t1 where c11=1;&lt;br/&gt;
&amp;#8211; this time, there will be statistics for t1.i1&lt;br/&gt;
select * from sys.sysstatistics;&lt;/p&gt;

&lt;p&gt;Note, that there were no locking issues/privilege issues involved in the simple test case above. But when update statistics runs into some problem, the question is how do we just revert back the update statistics work and let the original SELECT query proceed with execution. When I ran junit, towards the very beginning, I saw lot of problems related to not having enough privileges, context stack issue etc because of update statistics.&lt;/p&gt;

&lt;p&gt;I think the right approach would be to start with the compile phase of SELECT query and during optimization, when we find that the statistics are missing, then quit the compilation of SELECT query there, run the update statistics and refire the compilation of the SELECT query. This way, update statistics will not run into any locking issues with SELECT query. I am going to try to spend some time working on this approach and see how it goes. Would appreicate if anyone has any feedback.&lt;/p&gt;</comment>
                            <comment id="12680212" author="mamtas" created="Mon, 9 Mar 2009 17:44:29 +0000"  >&lt;p&gt;I have an intermediate patch ready for review. The goal of the patch is to detect early on in the compile phase of a SELECT query if there are tables involved with missing statistics. If yes, then abandon the SELECT query compilation, create the missing statistics and then try to compile the original SELECT query again. This logic gets driven inside the GenericStatement.prepMinion code. GenericStatement.prepMinion is responsible for compile phase of a SQL. If the SQL involved is a SELECT statement, then we may go through the compile process of the SELECT query twice. If the  SQL involved is non-SELECT, we will finish SQL compilation in the first pass. The details about the code flow for SELECT statement compilation is as follows.&lt;/p&gt;

&lt;p&gt;For a SELECT statement, we may have to go through the query compilation phase twice. Whether we go through one cycle or 2 cycles of compilation phase depends on wheter there are any tables involved in the query who have their statistics missing. During the first attempt of query compile, we will make a list of all the tables involved in the query during the bind phase of compile. After the bind phase, during the first pass through the SELECT query compilation, we will check if the query involved has any tables whose statistics are missing. If yes, then we will quit from the SELECT compile phase by throwing missing statistics exception. We will handle the missing stats exception by trying to update the missing statistics. After that, we will go through the second pass of original query compilation. During this second pass, we will not worry if the statistics are missing or not. We will just work with whatever statistics are available (one example where the statistics may still be missing after trying to create them is say a user who only has select privileges on a table finds the missing stats. But the statistics creation will fail because the user does not have sufficient privileges to create the statistics. There can be other reasons for statistics creation failure too. Another instance would be that we can&apos;t get the necessary locks to update the stats. In such a case, we will just quit out of updating the stats and move on to the second pass of the original query compilation. &lt;/p&gt;

&lt;p&gt;One of the issues with this patch I need to work on and will appreicate if anyone has any feedback on. The update statistics is happening in the user transaction. What that means is that any locks required to update statistics will stay in place until the user transaction has been committed/rolled back. This behavior can be an issue with user applications (since these are the locks the user was not expecting to get as part of a SELECT query execution). This behavior definitely causes problems with our tests where quite a handful of tests run into locking issues because of the additional locks acquired before of a SELECT query. I think one way to fix this would be to somehow run the statistics in a nested transaction which can be committed after the statistics are created. If we run into locking issues in the nested transaction then go ahead and run the statistic in the user transaction. This is what we do for GENERATED columns in InsertResultSet.getSetAutoincrementValue. One of the problems that I need to address before I can use nested transaction is to change the code that is written to fire statistics during SELECT compilation. Currently, in my patch, I am executing the stored procedure SYSCS_UTIL.SYSCS_UPDATE_STATISTICS which internally executes ALTER TABLE.. to update the statistics. I am at too high a level to be able to use nested transaction for updating the statistics (let me know if I am wrong here. May be there is a way to use nested transaction while firing the SYSCS_UTIL.SYSCS_UPDATE_STATISTICS that I am unaware of). I think I need to get to update statistics code in AlterTableConstantAction directly somehow without going through the stored procedure-&amp;gt;ALTER TABLE.. sql path. I think if I can directly call the update statistics in AlterTableConstantAction, then I can try using the nested yransaction and if that does not succeed then user the user transaction.&lt;/p&gt;

&lt;p&gt;I will appreciate any input you might have on my overall approach to this jira entry and then how to address the locking issue.&lt;/p&gt;</comment>
                            <comment id="12680349" author="bryanpendleton" created="Tue, 10 Mar 2009 01:08:01 +0000"  >&lt;p&gt;Seems like the nested transactions can have locking problems, too; if the nested transaction&apos;s&lt;br/&gt;
lock requests block, you can get an un-detected deadlock, I believe. I think we recently&lt;br/&gt;
had to change some code which took locks in a nested transaction to take those locks&lt;br/&gt;
&quot;nowait&quot;, and if they couldn&apos;t be immediately satisfied, to retry the locks in the user transaction.&lt;br/&gt;
Unfortunately I don&apos;t recall exactly which issue had this multi-step lock retry behavior.&lt;/p&gt;</comment>
                            <comment id="12680478" author="mamtas" created="Tue, 10 Mar 2009 14:37:18 +0000"  >&lt;p&gt;Bryan, thanks for taking the time for this jira entry. Yes, I was planning on using nowait so that we do not wait and eventually possibly locking issues with parent. This is exactly what we do in InsertResultSet.getSetAutoincrementValue as shown below&lt;br/&gt;
try &lt;/p&gt;
{
	/* If tcToUse == tc, then we are using parent xaction-- this
	   can happen if for some reason we couldn&apos;t start a nested
	   transaction
	   */
	newValue = dd.getSetAutoincrementValue(
		   constants.autoincRowLocation[index],
		   tcToUse, true, aiCache[index], (tcToUse == tc));
}
&lt;p&gt;catch (StandardException se)&lt;br/&gt;
{&lt;br/&gt;
	if (tcToUse == tc)&lt;/p&gt;
	{
		/* we&apos;ve using the parent xaction and we&apos;ve timed out; just
		   throw an error and exit.
		*/
		throw se;
	}
&lt;p&gt;	if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))&lt;/p&gt;
	{
		// if we couldn&apos;t do this with a nested xaction, retry with
		// parent-- we need to wait this time!
		newValue = dd.getSetAutoincrementValue(
			constants.autoincRowLocation[index],
			tc, true, aiCache[index], true);
	}</comment>
                            <comment id="12680484" author="bryanpendleton" created="Tue, 10 Mar 2009 14:44:00 +0000"  >&lt;p&gt;Yes, that&apos;s the technique I remembered. Thanks for tracking it down! That seems fine to me.&lt;/p&gt;</comment>
                            <comment id="12892343" author="mamtas" created="Mon, 26 Jul 2010 17:17:55 +0100"  >&lt;p&gt;Just wanted to summarize what has been tried for this jira so far and a proposal for a possible solution worth trying&lt;br/&gt;
1)First I tried to see if the missing stats could be created inline when the SELECT query compilation finds that missing but that failed because SELECT query compilation marked the data dictionary in read only mode where as update statistics needs to update the data dictionary(this marking of read only for data dictionary happens in GenericStatement.prepMinion). Because of this read-only marking, we can&apos;t create the statistics inline of the compilation phase of the SELECT query. &lt;br/&gt;
2)Second approach was during the SELECT compile phase, if we come across missing stats, then schedule a task for later to update the stats. Finish the SELECT compilation and execution after the update stat task is scheduled on the queue (the scheduling mechanism used is only available with jdk 1.5 and higher). When the scheduled task was later fired, it would run no current connection exception. The reason for that was that there was no context set for update statistics to run. Tried resolving this by creating a connection context through following call InternalDriver.activeDriver().connect(url, info) I had the SELECT compilation pass the needed information to the background task so I can create the connection. This is pretty crude way of getting a connection to update the statistics. Along with the fact that the code to create the connection context was not very modular, some of the existing tests failed with this changes because of locking issues. This probably is because the locks held by the background thread for update stats interfered with locks required by the rest of the test. &lt;br/&gt;
3)The third approach I tried was when the SELECT query detects missing stats, abort the query compilation, (thus removing the data dictionary from read-only mode), create the stats and then restart the original SELECT query compilation and execution. The hope with this approach was that it will avoid running into locking issues. If we decide to pursue this approach more, we need to make sure that we look at the possibility of stats still missing when the original query is compile the 2nd time. This can happen say because the user does not have privileges to update the stats, the update stat ran into locking issues. If we won&apos;t account for possibility of missing stats during the 2nd time through the original query, we can end up in an infinite loop. Another problem with this approach was that update stats were happening in the same transaction as the original SELECT query. Which means that the locks acquired by the update stat will not be released until the transaction is committed. Came across locking issues with this when I ran the existing junit and derbyall tests. One way to fix this could be to start a nested user transaction and do the update stat in that transaction and commit that transaction(I think something like this is done for identity columns. If yes, then we might find pointers there to use for update stats in nested user transaction). Thus any locks acquired by the update stat work will be released. And after that, go back to the original query again for compilation and execution. &lt;br/&gt;
4)With any approach we take, we should detect the case where the table is empty and hence the stats might be missing. For such a case, we should not try to fire stats creation task. to rephrase, during the compile phase of the SELECT query, when we look for statistics, first check if the table is empty and if yes then skip the code for collecting stats. From what I recall, one can check if the table is empty by issuing open scan controller and asking it for the number of rows in the table. If we do not check for empty table, then we will end up in infinite loop. &lt;br/&gt;
5)For read-only db we should detect that we are readonly and don&apos;t try to do update statistics &lt;br/&gt;
6)Also, we probably want to create statistics only for user tables? Haven&apos;t thought enough about it. &lt;br/&gt;
7)What if the user executing the query is not the owner of the table. should statistics still be created? I think if the user does not have enough privileges, then skip the step of creating stats since it&apos;s going to fail anyways. &lt;br/&gt;
8)Once statistics are created, notify tabledescriptor about it because tabledescriptor  cahces available statistics and it will never know of the new statistics since tabledescriptor holds on to that cache. &lt;br/&gt;
9)Once we have update stats working, another improvement could be to identify the cached compiled queries that may benefit from updated stats and have those queries recompile when they are executed next time. In other words, the relevant queries should be invalidated as part of the statistics collection task. &lt;br/&gt;
10)Look at other scenarios(in addition to step 7) above) where we know that update stats might fail. For those cases, don&apos;t spend time trying to create the stats. Instead just let the optimizer work with the information it has at the moment to come up with the query plan. &lt;/p&gt;</comment>
                            <comment id="12898234" author="kristwaa" created="Fri, 13 Aug 2010 14:34:09 +0100"  >&lt;p&gt;Thanks for the writeup, Mamta &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I logged &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4771&quot; title=&quot;Continue investigation of automatic creation/update of index statistics&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4771&quot;&gt;&lt;del&gt;DERBY-4771&lt;/del&gt;&lt;/a&gt; to track some work I did on the same problem.&lt;/p&gt;</comment>
                            <comment id="12907193" author="kristwaa" created="Wed, 8 Sep 2010 13:40:26 +0100"  >&lt;p&gt;Clearing patch available flag, as it is my impression that there are no patches that are ready for commit.&lt;/p&gt;</comment>
                            <comment id="12968998" author="kristwaa" created="Tue, 7 Dec 2010 21:26:00 +0000"  >&lt;p&gt;There hasn&apos;t been work on this issue for a while. I&apos;m adding a link to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4934&quot; title=&quot;Provide automatic update and creation of index cardinality statistics (istat)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4934&quot;&gt;&lt;del&gt;DERBY-4934&lt;/del&gt;&lt;/a&gt;, which supersedes this issue.&lt;br/&gt;
Investigation and exploration was done under &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4771&quot; title=&quot;Continue investigation of automatic creation/update of index statistics&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4771&quot;&gt;&lt;del&gt;DERBY-4771&lt;/del&gt;&lt;/a&gt;, whereas &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4934&quot; title=&quot;Provide automatic update and creation of index cardinality statistics (istat)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4934&quot;&gt;&lt;del&gt;DERBY-4934&lt;/del&gt;&lt;/a&gt; tracks the actual addition of the feature (called istat during development for brevity).&lt;/p&gt;</comment>
                            <comment id="13003132" author="kristwaa" created="Sun, 6 Mar 2011 11:42:23 +0000"  >&lt;p&gt;Resolving as duplicate (see comment above for the relevant JIRAs).&lt;/p&gt;</comment>
                            <comment id="13685377" author="knutanders" created="Mon, 17 Jun 2013 10:19:51 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12446719">DERBY-4526</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12471534">DERBY-4771</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310051">
                    <name>Supercedes</name>
                                                                <inwardlinks description="is superceded by">
                                        <issuelink>
            <issuekey id="12492655">DERBY-4934</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12393407" name="DERBY3788_patch1_diff.txt" size="14445" author="mamtas" created="Wed, 5 Nov 2008 23:09:17 +0000"/>
                            <attachment id="12393408" name="DERBY3788_patch1_stat.txt" size="1019" author="mamtas" created="Wed, 5 Nov 2008 23:09:17 +0000"/>
                            <attachment id="12393941" name="DERBY3788_patch2_diff.txt" size="19905" author="mamtas" created="Fri, 14 Nov 2008 15:27:27 +0000"/>
                            <attachment id="12393942" name="DERBY3788_patch2_stat.txt" size="1098" author="mamtas" created="Fri, 14 Nov 2008 15:27:27 +0000"/>
                            <attachment id="12395306" name="DERBY3788_patch3_diff.txt" size="17781" author="mamtas" created="Thu, 4 Dec 2008 17:54:26 +0000"/>
                            <attachment id="12395307" name="DERBY3788_patch3_stat.txt" size="1030" author="mamtas" created="Thu, 4 Dec 2008 17:54:26 +0000"/>
                            <attachment id="12401768" name="DERBY3788_update_all_missing_stats_after_bind_patch4_diff.txt" size="20725" author="mamtas" created="Mon, 9 Mar 2009 17:44:29 +0000"/>
                            <attachment id="12401767" name="DERBY3788_update_all_missing_stats_after_bind_patch4_stat.txt" size="532" author="mamtas" created="Mon, 9 Mar 2009 17:44:29 +0000"/>
                            <attachment id="12389025" name="DERBY_3788_Mgr.java" size="858" author="mamtas" created="Wed, 27 Aug 2008 19:39:34 +0100"/>
                            <attachment id="12389026" name="DERBY_3788_Repro.java" size="292" author="mamtas" created="Wed, 27 Aug 2008 19:39:34 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 12 Aug 2008 19:03:10 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30999</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0gfr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36481</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>