<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:38:01 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-5407/DERBY-5407.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-5407] When run across the network, dblook produces unusable DDL for VARCHAR FOR BIT DATA columns.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-5407</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;In private correspondence, Mani Afschar Yazdi reports that dblook omits the length specification for VARCHAR FOR BIT DATA columns when run across the network. Embedded dblook runs fine. I can reproduce this problem as follows:&lt;/p&gt;

&lt;p&gt;1) Bring up a server (here I am using port 8246).&lt;/p&gt;

&lt;p&gt;2) Create a database with the following ij script:&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby://localhost:8246/memory:db;create=true&apos;;&lt;/p&gt;

&lt;p&gt;create table t( a varchar( 20 ) for bit data );&lt;/p&gt;

&lt;p&gt;3) Now run dblook across the network:&lt;/p&gt;

&lt;p&gt;java -org.apache.derby.tools.dblook -d &quot;jdbc:derby://localhost:8246/memory:db&quot;&lt;/p&gt;

&lt;p&gt;This produces the following DDL for the table:&lt;/p&gt;

&lt;p&gt;CREATE TABLE &quot;APP&quot;.&quot;T&quot; (&quot;A&quot; VARCHAR () FOR BIT DATA);&lt;/p&gt;

&lt;p&gt;A similar experiment using an embedded database produces usable DDL which includes a length specification for the VARCHAR FOR BIT DATA column.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12522741">DERBY-5407</key>
            <summary>When run across the network, dblook produces unusable DDL for VARCHAR FOR BIT DATA columns.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="rhillegas">Rick Hillegas</reporter>
                        <labels>
                            <label>derby_backport_reject_10_5</label>
                    </labels>
                <created>Mon, 12 Sep 2011 14:50:38 +0100</created>
                <updated>Fri, 14 Jun 2013 18:22:18 +0100</updated>
                            <resolved>Wed, 25 Jul 2012 19:30:35 +0100</resolved>
                                    <version>10.8.1.2</version>
                                    <fixVersion>10.6.2.4</fixVersion>
                    <fixVersion>10.7.1.4</fixVersion>
                    <fixVersion>10.8.3.0</fixVersion>
                    <fixVersion>10.9.2.2</fixVersion>
                    <fixVersion>10.10.1.1</fixVersion>
                                    <component>Tools</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13405585" author="mamtas" created="Tue, 3 Jul 2012 04:33:33 +0100"  >&lt;p&gt;I debugged the code and found that to extract column types, we use following query in DB_Table.doTables&lt;br/&gt;
getColumnTypeStmt = &lt;br/&gt;
	conn.prepareStatement(&quot;SELECT COLUMNDATATYPE, COLUMNDEFAULT FROM SYS.SYSCOLUMNS &quot; +&lt;br/&gt;
	&quot;WHERE REFERENCEID = ? AND COLUMNNAME = ?&quot;);&lt;/p&gt;

&lt;p&gt;But for a network server configuration, we do not return the column length whereas it works fine in embedded mode.&lt;/p&gt;</comment>
                            <comment id="13410469" author="mamtas" created="Tue, 10 Jul 2012 17:12:40 +0100"  >&lt;p&gt;dblook uses following sql to determine the column types and default&lt;br/&gt;
SELECT COLUMNDATATYPE, COLUMNDEFAULT FROM SYS.SYSCOLUMNS WHERE REFERENCEID = ? AND COLUMNNAME = ?&quot;&lt;/p&gt;

&lt;p&gt;I used similar sql directly in ij(bypassing dblook) and saw the same errorneous results for network server configuration. Embedded returns the length for VARCHAR FOR BIT DATA but network server doesn&apos;t. I am debugging currently to find the reason behind the difference in behavior.&lt;/p&gt;</comment>
                            <comment id="13410513" author="mamtas" created="Tue, 10 Jul 2012 17:45:21 +0100"  >&lt;p&gt;With my testing so far, the problem with missing length does not happen for varchar datatype in network server. So, if a table has 2 columns, as follows&lt;br/&gt;
create table t2( a1 varchar( 30 ) for bit data, a2 varchar(25) ); &lt;br/&gt;
then, following query in ij returns VARCHAR(25) for column a2, but it returns VARCHAR () FOR BIT DATA for column a1.&lt;br/&gt;
 SELECT COLUMNDATATYPE FROM SYS.SYSCOLUMNS;&lt;/p&gt;

&lt;p&gt;Also, if I take the network server database to embedded, following query in ij returns correct information for both columns a1 and a2, ie  VARCHAR(25) for column a2 and VARCHAR (30) FOR BIT DATA for column a1.&lt;br/&gt;
 SELECT COLUMNDATATYPE FROM SYS.SYSCOLUMNS&lt;/p&gt;

&lt;p&gt;So, it looks like there is nothing wrong with the information stored in the underlying database. Could it be something to do with DRDA? I will debug this further but wanted to share what I have found so far in case if it rings a bell to someone.&lt;/p&gt;</comment>
                            <comment id="13410584" author="kmarsden" created="Tue, 10 Jul 2012 18:33:41 +0100"  >&lt;p&gt;One thing to note is that ColumnDataType is a UDT. &lt;a href=&quot;http://db.apache.org/derby/docs/10.9/ref/rrefsistabs22441.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.9/ref/rrefsistabs22441.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I would think though that you would still get the same toString()  representation for the object on the client side and if this works ok for varchar it should also be resonable for varchar for bit data.&lt;/p&gt;

&lt;p&gt;Worst case, you could normalize the behavior by  casting the result to long varchar in the query, per the release note at:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4688&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-4688&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Doing so for all dblook queries that access UDT&apos;s would mean that dblook might be usable from client without having derby.jar in the classpath  which would  be a nice thing, but I am very curious why the client side object has a different toString output. It seems like there is a bug there.&lt;/p&gt;


</comment>
                            <comment id="13410603" author="rhillegas" created="Tue, 10 Jul 2012 18:41:46 +0100"  >&lt;p&gt;Hi Mamta,&lt;/p&gt;

&lt;p&gt;Thanks for looking at this issue. The column datatype is a TypeDescriptorImpl. My first suspicion would be that this object is not serializing itself properly across the network. I think that different logic is used to (de)serialize datatypes to the catalogs and into the byte arrays which are sent across the network. The network serialization relies on the writeExternal() and readExternal()  methods of java.io.Serializable. The metadata serialization is trickier. If you want to pursue this theory, a next step would be to try (de)serializing a TypeDescriptorImpl to a byte array. See for instance DDMWriter.writeUDT() and DRDAConnThread.readUDT(). Hope this helps.&lt;/p&gt;</comment>
                            <comment id="13410686" author="kmarsden" created="Tue, 10 Jul 2012 19:39:46 +0100"  >&lt;p&gt;linking &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5852&quot; title=&quot;dblook fails with client if derby.jar is not in classpath with java.sql.SQLException: Error marshalling or unmarshalling a user defined type&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5852&quot;&gt;DERBY-5852&lt;/a&gt; for dblook failing with client if derby.jar is not in the classpath. The suggested  solution for that issue,  casting column to long varchar, would likely fix this dblook issue as well, but if you take that approach,  a separate issue should be filed for the marshalling issue with the existing query.&lt;/p&gt;</comment>
                            <comment id="13415463" author="mamtas" created="Mon, 16 Jul 2012 19:05:05 +0100"  >&lt;p&gt;I have added a new test fixture testColumnDatatypesOfAllDataTypesInSystemCatalogs to SystemCatalogTest.java This new fixture creates a table with all the datatypes and check syscolumns.columndatatype to make sure that we get the correct datatype back for those columns in both network server and embedded modes. As expected, because of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5407&quot; title=&quot;When run across the network, dblook produces unusable DDL for VARCHAR FOR BIT DATA columns.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5407&quot;&gt;&lt;del&gt;DERBY-5407&lt;/del&gt;&lt;/a&gt;, the datatypes returned for VARCHAR FOR BIT DATA is not the same for the 2 modes. Additionally, CAHR FOR BIT DATA also does not match for the 2 modes. Once we fix the underlying issue, we should be able to check in this test with the fix for the issue.&lt;/p&gt;</comment>
                            <comment id="13415510" author="mamtas" created="Mon, 16 Jul 2012 19:47:39 +0100"  >&lt;p&gt;I did further debugging of this issue and I found that we are sending the correct information over the wire for the network server.&lt;br/&gt;
This is where we write the column data on the server side&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_11&amp;#93;&lt;/span&gt; (Suspended)	&lt;br/&gt;
	TypeDescriptorImpl.writeExternal(ObjectOutput) line: 549	&lt;br/&gt;
	ObjectOutputStream.writeExternalData(Externalizable) line: 1449	&lt;br/&gt;
	ObjectOutputStream.writeOrdinaryObject(Object, ObjectStreamClass, boolean) line: 1418	&lt;br/&gt;
	ObjectOutputStream.writeObject0(Object, boolean) line: 1178	&lt;br/&gt;
	ObjectOutputStream.writeObject(Object) line: 347	&lt;br/&gt;
	DDMWriter.writeUDT(Object, int) line: 1181	&lt;br/&gt;
	DRDAConnThread.writeFdocaVal(int, Object, int, int, int, boolean, DRDAStatement, boolean) line: 8072	&lt;br/&gt;
	DRDAConnThread.writeFDODTA(DRDAStatement) line: 7256	&lt;br/&gt;
	DRDAConnThread.writeQRYDTA(DRDAStatement) line: 6990	&lt;br/&gt;
	DRDAConnThread.processCommands() line: 910	&lt;br/&gt;
	DRDAConnThread.run() line: 295	&lt;/p&gt;

&lt;p&gt;And this is where we read the column data on the client side&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended)	&lt;br/&gt;
	BaseTypeIdImpl.getTypeFormatId() line: 258	&lt;br/&gt;
	BaseTypeIdImpl.toParsableString(TypeDescriptor) line: 178	&lt;br/&gt;
	TypeDescriptorImpl.getSQLstring() line: 441	&lt;br/&gt;
	TypeDescriptorImpl.toString() line: 446	&lt;br/&gt;
	NetCursor(Cursor).getString(int) line: 1061	&lt;br/&gt;
	NetResultSet40(ResultSet).getString(int) line: 1069	&lt;br/&gt;
	JDBCDisplayUtil.DisplayRow(PrintWriter, ResultSet, ResultSetMetaData, int, Vector, Connection, int, int[], int[]) line: 693	&lt;br/&gt;
	JDBCDisplayUtil.indent_DisplayResults(PrintWriter, List, Connection, int, int[], int[]) line: 385	&lt;br/&gt;
	JDBCDisplayUtil.indent_DisplayResults(PrintWriter, ResultSet, Connection, int, int[], int[]) line: 338	&lt;br/&gt;
	JDBCDisplayUtil.indent_DisplayResults(PrintWriter, Statement, Connection, int, int[], int[]) line: 241	&lt;br/&gt;
	JDBCDisplayUtil.DisplayResults(PrintWriter, Statement, Connection) line: 229	&lt;br/&gt;
	utilMain.displayResult(LocalizedOutput, ijResult, Connection) line: 454	&lt;br/&gt;
	utilMain.doCatch(String) line: 528	&lt;br/&gt;
	utilMain.runScriptGuts() line: 369	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput) line: 245	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput) line: 229	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 184	&lt;br/&gt;
	Main.main(String[]) line: 75	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;

&lt;p&gt;I think I should know in a day or two as to what is happening.&lt;/p&gt;</comment>
                            <comment id="13416837" author="mamtas" created="Wed, 18 Jul 2012 04:10:55 +0100"  >&lt;p&gt;Attaching a patch which has a fix for the issue and a new junit test fixture.&lt;/p&gt;

&lt;p&gt;After debugging the issue, I have found that the serialization of object on the wire from the network server end happens&lt;br/&gt;
correctly. The same serialized data is received by the client but when we try to instantiate the TypeDescriptor based&lt;br/&gt;
on this serialized data, we get confused between &quot;VARCHAR () FOR BIT DATA&quot; and &quot;VARCHAR FOR BIT DATA&quot;.&lt;/p&gt;

&lt;p&gt;Following is a brief explanation of the current logic and problem area.&lt;/p&gt;

&lt;p&gt;Let&apos;s say, there is a database with following table&lt;br/&gt;
create table t2( a1 varchar( 30 ) for bit data, a2 varchar(25) ); &lt;/p&gt;

&lt;p&gt;When query below is run on top of the trunk in network server mode against the databse above, we get following results&lt;br/&gt;
select columndatatype from sys.systables, sys.syscolumns where tablename=&apos;T2&apos; and tableid=referenceid;&lt;br/&gt;
COLUMNDATATYPE&lt;br/&gt;
---------------&lt;br/&gt;
VARCHAR () FOR&amp;amp;&lt;br/&gt;
VARCHAR(25)&lt;/p&gt;

&lt;p&gt;Notice the length of the column &quot;A1&quot; is missing in syscolumns.COLUMNDATATYPE&lt;/p&gt;


&lt;p&gt;syscolumns.columndatatype is a UDT. On the server side, the TypeDescriptor associated with it gets initialized as shown below&lt;br/&gt;
          case StoredFormatIds.VARBIT_TYPE_ID_IMPL:&lt;br/&gt;
              schemaName = null;&lt;br/&gt;
              unqualifiedName = TypeId.VARBIT_NAME;&lt;br/&gt;
              JDBCTypeId = Types.VARBINARY;&lt;br/&gt;
              break;&lt;br/&gt;
Note, that unqualifiedName has gotten &quot;VARCHAR () FOR BIT DATA&quot; assigned to it. Later on in the server code, we associate&lt;br/&gt;
column width 30 with this TypeDescriptor for our specific example. So, the TypeDescriptor has the correct information which will then be sent on the wire to the client.&lt;/p&gt;

&lt;p&gt;Following stack trace shows were we write this &quot;VARCHAR () FOR BIT DATA&quot; onto the wire.&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_2&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 323 in BaseTypeIdImpl))	&lt;br/&gt;
	BaseTypeIdImpl.writeExternal(ObjectOutput) line: 323	&lt;br/&gt;
	ObjectOutputStream.writeExternalData(Externalizable) line: 1449	&lt;br/&gt;
	ObjectOutputStream.writeOrdinaryObject(Object, ObjectStreamClass, boolean) line: 1418	&lt;br/&gt;
	ObjectOutputStream.writeObject0(Object, boolean) line: 1178	&lt;br/&gt;
	ObjectOutputStream.writeObject(Object) line: 347	&lt;br/&gt;
	TypeDescriptorImpl.writeExternal(ObjectOutput) line: 549	&lt;br/&gt;
	ObjectOutputStream.writeExternalData(Externalizable) line: 1449	&lt;br/&gt;
	ObjectOutputStream.writeOrdinaryObject(Object, ObjectStreamClass, boolean) line: 1418	&lt;br/&gt;
	ObjectOutputStream.writeObject0(Object, boolean) line: 1178	&lt;br/&gt;
	ObjectOutputStream.writeObject(Object) line: 347	&lt;br/&gt;
	DDMWriter.writeUDT(Object, int) line: 1181	&lt;br/&gt;
	DRDAConnThread.writeFdocaVal(int, Object, int, int, int, boolean, DRDAStatement, boolean) line: 8053	&lt;br/&gt;
	DRDAConnThread.writeFDODTA(DRDAStatement) line: 7236	&lt;br/&gt;
	DRDAConnThread.writeQRYDTA(DRDAStatement) line: 6970	&lt;br/&gt;
	DRDAConnThread.processCommands() line: 894	&lt;br/&gt;
	DRDAConnThread.run() line: 288	&lt;br/&gt;
Subsequently, we also write the width 30 for the VARCHAR () FOR BIT DATA on the wire for our example case.&lt;/p&gt;

&lt;p&gt;Client goes through the deserialization of the UDT and during deserialization, it finds VARCHAR () FOR BIT DATA and the width &lt;br/&gt;
30 for it. So far, client is reading what server has sent and things are in sync. We use this information to construct a&lt;br/&gt;
TypeDescriptor. This happens through BaseTypeIdImpl.getTypeFormatId(). Here, we look at the string representation of the type descriptor that we received on the wire and choose the appropriate format id based on that string. The problem is in this BaseTypeIdImpl.getTypeFormatId() code, because the code looks for VARCHAR FOR BIT DATA rather than VARCHAR () FOR BIT DATA &lt;br/&gt;
(notice the missing parentheses) as shown below.&lt;br/&gt;
            else if ( &quot;VARCHAR FOR BIT DATA&quot;.equals( unqualifiedName ) ) &lt;/p&gt;
{ return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }&lt;br/&gt;
Since VARCHAR FOR BIT DATA and VARCHAR () FOR BIT DATA do not match, we do not use format id VARBIT_TYPE_ID_IMPL&lt;br/&gt;
Later, we go through the following switch statement based on format id in BaseTypeIdlImpl.toParsableString(TypeDescriptor)&lt;br/&gt;
        switch (getTypeFormatId())&lt;br/&gt;
        {
          case StoredFormatIds.BIT_TYPE_ID_IMPL:
          case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
			  int rparen = retval.indexOf(&apos;)&apos;);
			  String lead = retval.substring(0, rparen);
			  retval = lead + td.getMaximumWidth() + retval.substring(rparen);
			  break;

          case StoredFormatIds.CHAR_TYPE_ID_IMPL:
          case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
          case StoredFormatIds.BLOB_TYPE_ID_IMPL:
          case StoredFormatIds.CLOB_TYPE_ID_IMPL:
                retval += &quot;(&quot; + td.getMaximumWidth() + &quot;)&quot;;
                break;

          case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
                retval += &quot;(&quot; + td.getPrecision() + &quot;,&quot; + td.getScale() + &quot;)&quot;;
                break;
        }&lt;br/&gt;
In the switch statement above, we are supposed to stuff in the width of the varchar for bit data into the parentheses&lt;br/&gt;
ie VARCHAR () FOR BIT DATA should get converted into VARCHAR (30) FOR BIT DATA for our specific example but we don&apos;t do it because of getTypeFormatd() code above..&lt;br/&gt;
&lt;br/&gt;
To solve this, I have found that if I change code in BaseTypeIdImpl.getTypeFormatId() to look for VARCHAR () FOR BIT DATA, as &lt;br/&gt;
follows&lt;br/&gt;
            else if ( &quot;VARCHAR () FOR BIT DATA&quot;.equals( unqualifiedName ) ) { return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
&lt;p&gt;the problem gets fixed. I have not yet run derbyall and junit suite to see if that change can cause any problems. &lt;/p&gt;

&lt;p&gt;If there might be dependencies on the original &quot;VARCHAR FOR BIT DATA&quot; check, then we can add additional check for &lt;br/&gt;
VARCHAR () FOR BIT DATA along with existing check for &quot;VARCHAR FOR BIT DATA&quot; as shown below&lt;br/&gt;
            else if ( &quot;VARCHAR FOR BIT DATA&quot;.equals( unqualifiedName ) ) &lt;/p&gt;
{ return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }&lt;br/&gt;
            else if ( &quot;VARCHAR () FOR BIT DATA&quot;.equals( unqualifiedName ) ) { return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
&lt;p&gt;We will need to do similar thing for CHAR FOR BIT DATA. This will fix the jira issue and it will also not break any dependencies&lt;br/&gt;
that might exist on &quot;VARCHAR FOR BIT DATA&quot; check.&lt;/p&gt;

&lt;p&gt;The test that I have attached to the jira runs fine with my suggested changes. Next, I will run derbyall and junit suite.&lt;br/&gt;
Please let me know if there is any feedback on the suggested fix.&lt;/p&gt;</comment>
                            <comment id="13416938" author="knutanders" created="Wed, 18 Jul 2012 09:26:21 +0100"  >&lt;p&gt;Maybe BaseTypeIdImpl.getTypeFormatId() could use the constants in TypeId (like TypeId.VARBIT_NAME)? That might make it more robust against typos like the ones that caused this bug.&lt;/p&gt;

&lt;p&gt;I would think that it&apos;s OK to remove the tests for &quot;VARCHAR FOR BIT DATA&quot; and &quot;CHAR FOR BIT DATA&quot;, as they&apos;re likely just typos. But I don&apos;t see much harm in keeping them just in case. Perhaps move those two checks to the end of the method, and add a comment saying that they&apos;re most likely not needed?&lt;/p&gt;

&lt;p&gt;It&apos;s great that you added test cases for all the data types. According to the code coverage results for BaseTypeIdImpl.getTypeFormatId(), none of the types were covered by existing tests, so it&apos;s good to get all of them tested.&lt;/p&gt;</comment>
                            <comment id="13417088" author="rhillegas" created="Wed, 18 Jul 2012 14:47:09 +0100"  >&lt;p&gt;Thanks, Mamta. This looks like the right fix to me.&lt;/p&gt;</comment>
                            <comment id="13417265" author="mikem" created="Wed, 18 Jul 2012 18:16:11 +0100"  >&lt;p&gt;fix looks good to me.  Is this bug a regression, if so any idea what version/change caused it?&lt;/p&gt;</comment>
                            <comment id="13417274" author="kmarsden" created="Wed, 18 Jul 2012 18:23:38 +0100"  >&lt;p&gt;My guess would be 10.6 with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4491&quot; title=&quot;The network client changes UDTs into Strings and returns their type as LONGVARBINARY.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4491&quot;&gt;&lt;del&gt;DERBY-4491&lt;/del&gt;&lt;/a&gt;, but should be verified.&lt;/p&gt;</comment>
                            <comment id="13417291" author="rhillegas" created="Wed, 18 Jul 2012 18:35:30 +0100"  >&lt;p&gt;The code which Mamta fixed was added in revision 899733 by derby-4491-01-ad-networkTransport .diff. My guess would be 10.6.1 too.&lt;/p&gt;</comment>
                            <comment id="13420761" author="mamtas" created="Mon, 23 Jul 2012 17:32:40 +0100"  >&lt;p&gt;I have committed the changes to top fo the trunk. Will migrate it to earlier releases(sounds like upto 10.6 but I will verify while migrating it.)&lt;/p&gt;</comment>
                            <comment id="13422483" author="mamtas" created="Wed, 25 Jul 2012 19:30:35 +0100"  >&lt;p&gt;The fix has been backported all the way upto 10.6. The sample test works fine on 10.5 and hence we do not need to do any backporting to 10.5&lt;/p&gt;</comment>
                            <comment id="13422505" author="mamtas" created="Wed, 25 Jul 2012 19:58:29 +0100"  >&lt;p&gt;Actually, I backported the test to 10.5 codeline with following commit comments&lt;br/&gt;
**************************&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5407&quot; title=&quot;When run across the network, dblook produces unusable DDL for VARCHAR FOR BIT DATA columns.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5407&quot;&gt;&lt;del&gt;DERBY-5407&lt;/del&gt;&lt;/a&gt; When run across the network, dblook produces unusable DDL for VARCHAR FOR BIT DATA columns.&lt;/p&gt;

&lt;p&gt;Backporting only the test from 10.6 to 10.5. The bug doesn&apos;t exist in 10.5 but there is no test code coverage for SYSCOLUMNS.COLUMNDATATYPE in 10.5 and hence putting the test in 10.5&lt;br/&gt;
**************************&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12598238">DERBY-5852</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12536947" name="DERBY5407_patch1_diff.txt" size="5990" author="mamtas" created="Wed, 18 Jul 2012 04:10:55 +0100"/>
                            <attachment id="12536680" name="SystemCatalogTest.java" size="33079" author="mamtas" created="Mon, 16 Jul 2012 19:05:05 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10363"><![CDATA[Embedded/Client difference]]></customfieldvalue>
    <customfieldvalue key="10421"><![CDATA[Seen in production]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 3 Jul 2012 03:33:33 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24823</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0a4n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35459</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>