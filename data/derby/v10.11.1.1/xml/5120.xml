<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:28:13 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-5120/DERBY-5120.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-5120] Row from SYSDEPENDS gets deleted when a table has update triggers defined on it and an upate is made to the table</title>
                <link>https://issues.apache.org/jira/browse/DERBY-5120</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I have an ij script below which shows that the number of rows in SYSDEPENDS go down by 1 for the following test case after an update is made to a table with update triggers defined on it. Am not sure what kind of problems the missing dependnecy might cause.&lt;/p&gt;


&lt;p&gt;connect &apos;jdbc:derby:c:/dellater/db1;create=true&apos;;&lt;br/&gt;
CREATE TABLE ATDC_13_TAB1(c11 int, c12 int);&lt;br/&gt;
insert into ATDC_13_TAB1 values (1,11);&lt;/p&gt;

&lt;p&gt;create table ATDC_13_TAB2(c21 int, c22 int);&lt;br/&gt;
insert into ATDC_13_TAB2 values (1,11);&lt;/p&gt;

&lt;p&gt;create table ATDC_13_TAB3(c31 int, c32 int);&lt;br/&gt;
insert into ATDC_13_TAB3 values (1,11);&lt;/p&gt;

&lt;p&gt;create table ATDC_13_TAB1_backup(c11 int, c12 int);&lt;br/&gt;
insert into ATDC_13_TAB1_backup values (1,11);&lt;/p&gt;

&lt;p&gt;                create trigger ATDC_13_TAB1_trigger_1 after update &lt;br/&gt;
                on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
                INSERT INTO ATDC_13_TAB1_BACKUP(C11) &lt;br/&gt;
                SELECT C21 from ATDC_13_TAB2;&lt;/p&gt;

&lt;p&gt;                 create trigger ATDC_13_TAB1_trigger_2 after update &lt;br/&gt;
                on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
                INSERT INTO ATDC_13_TAB1_BACKUP &lt;br/&gt;
                 SELECT C31, C32 from ATDC_13_TAB3;&lt;/p&gt;

&lt;p&gt;&amp;#8211; following shows 14 rows&lt;br/&gt;
select * from sys.sysdepends;&lt;br/&gt;
update ATDC_13_TAB1 set c12=11;&lt;br/&gt;
&amp;#8211; following shows only 13 rows&lt;/p&gt;

&lt;p&gt;I tried this on 10.2 and 10.8 and saw the same behavior on both. It seems like the dependency that gets dropped is between the stored prepared statement and a table. Have not spent enough time to find out more details but I thought it is worth pointing out the behavior&lt;br/&gt;
select * from sys.sysdepends;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12500942">DERBY-5120</key>
            <summary>Row from SYSDEPENDS gets deleted when a table has update triggers defined on it and an upate is made to the table</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="mamtas">Mamta A. Satoor</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 Mar 2011 20:41:02 +0000</created>
                <updated>Wed, 6 Aug 2014 01:21:29 +0100</updated>
                            <resolved>Tue, 2 Aug 2011 20:20:06 +0100</resolved>
                                    <version>10.2.2.0</version>
                    <version>10.8.1.2</version>
                                    <fixVersion>10.8.2.2</fixVersion>
                    <fixVersion>10.9.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="13058688" author="mamtas" created="Fri, 1 Jul 2011 19:17:55 +0100"  >&lt;p&gt;I much simpler test case for this jira is as follows&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:db1_2;create=true&apos;; &lt;br/&gt;
CREATE TABLE ATDC_13_TAB1(c11 int, c12 int); &lt;br/&gt;
insert into ATDC_13_TAB1 values (1,11); &lt;/p&gt;

&lt;p&gt;create trigger ATDC_13_TAB1_trigger_1 after update &lt;br/&gt;
         on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
          values(1);&lt;/p&gt;

&lt;p&gt;create trigger ATDC_13_TAB1_trigger_2 after update &lt;br/&gt;
         on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
         values(1,2);&lt;/p&gt;

&lt;p&gt;&amp;#8211; following shows 6 rows &lt;br/&gt;
select * from sys.sysdepends; &lt;br/&gt;
update ATDC_13_TAB1 set c12=11; &lt;br/&gt;
&amp;#8211; following shows only 5 rows &lt;br/&gt;
select * from sys.sysdepends; &lt;/p&gt;</comment>
                            <comment id="13059308" author="mamtas" created="Mon, 4 Jul 2011 02:26:27 +0100"  >&lt;p&gt;A typical CREATE TRIGGER goes through following steps as far as adding/deleting rows from SYSDEPENDS tale&lt;br/&gt;
1)Any time a trigger is created, CreateTriggerConstantAction.executeConstantAction() sends CREATE_TRIGGER invalidation to the trigger table as shown below(The list of objects getting invalidated will include existing triggers defined on the trigger table).&lt;br/&gt;
		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Send an invalidate on the table from which&lt;/li&gt;
		&lt;li&gt;the triggering event emanates.  This it&lt;/li&gt;
		&lt;li&gt;to make sure that DML statements on this table&lt;/li&gt;
		&lt;li&gt;will be recompiled.  Do this before we create&lt;/li&gt;
		&lt;li&gt;our trigger spses lest we invalidate them just&lt;/li&gt;
		&lt;li&gt;after creating them.&lt;br/&gt;
		*/&lt;br/&gt;
		dm.invalidateFor(triggerTable, DependencyManager.CREATE_TRIGGER, lcc);&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2)Next, CreateTriggerConstantAction.executeConstantAction() does the trigger action sps generation&lt;br/&gt;
		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Create the trigger action&lt;br/&gt;
		*/&lt;br/&gt;
		actionspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,&lt;br/&gt;
						actionSPSId, spsCompSchemaId, actionText, false, triggerTable);&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3) During trigger action sps generation, SPSDescriptor.compileStatement removes the existing dependencies of trigger action sps in sysdepends as shown below&lt;br/&gt;
(for a trigger getting created the first time, there will be no SPS dependencies for the trigger action SPS. The same code is called when a trigger is found invalid, in that case, there will be existing trigger action SPS dependencies which will get dropped here) 	&lt;br/&gt;
		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Clear out all the dependencies that exist&lt;/li&gt;
		&lt;li&gt;before we recreate them so we don&apos;t grow&lt;/li&gt;
		&lt;li&gt;SYS.SYSDEPENDS forever.&lt;br/&gt;
		*/&lt;br/&gt;
		dm.clearDependencies(lcc, this, tc);&lt;br/&gt;
4)After clearing out existing dependencies, it adds the dependencies that it finds during this compile SPSDescriptor.compileStatement()&lt;br/&gt;
			/*&lt;/li&gt;
		&lt;li&gt;Copy over all the dependencies to me&lt;br/&gt;
			*/&lt;br/&gt;
			dm.copyDependencies(preparedStatement, 	// from&lt;br/&gt;
					this, 	// to&lt;br/&gt;
					false,	// persistent only&lt;br/&gt;
					cm,&lt;br/&gt;
					tc);&lt;br/&gt;
5)After finishing with trigger action SPS generation, CreateTriggerConstantAction.executeConstantAction adds the depdencies for the trigger descriptor on trigger action sps and on trigger table. Additionally, it adds depedency on trigger action sps on trigger table(this is the dependency which later gets dropped when a compile of trigger action sps had cleared existing trigger action sps dependencies before regenerating the trigger action sps. The trigger action sps regeneration&lt;br/&gt;
does not add the dependency between trigger action sps and trigger table&lt;br/&gt;
		dm.addDependency(triggerd, actionspsd, lcc.getContextManager());&lt;br/&gt;
		dm.addDependency(triggerd, triggerTable, lcc.getContextManager());&lt;br/&gt;
		dm.addDependency(actionspsd, triggerTable, lcc.getContextManager());&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Following the steps above (to find what rows get added into SYSDEPENDS)for the first trigger in the simpler example that I posted on 01/Jul/11&lt;br/&gt;
create trigger ATDC_13_TAB1_trigger_1 after update &lt;br/&gt;
         on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
          values(1); &lt;br/&gt;
Step 4) will not find any dependencies for trigger action values(1); &lt;br/&gt;
Step 5) will add three rows into SYSDEPENDS, namely &lt;br/&gt;
a)dependency between triiger descriptor for ATDC_13_TAB1_trigger_1 and triiger action SPS &lt;br/&gt;
b)dependency between trigger descriptor for ATDC_13_TAB1_trigger_1 and triiger table ATDC_13_TAB1 &lt;br/&gt;
3)dependency between triiger action SPS and triiger table ATDC_13_TAB1 &lt;/p&gt;

&lt;p&gt;This is how, we end up with three rows for the first trigger ATDC_13_TAB1_trigger_1 &lt;/p&gt;

&lt;p&gt;When the 2nd trigger(ATDC_13_TAB1_trigger_2) is created, it also results into adding 3 rows into SYSDEPENDS but additionally in step 1), it invalidates the existing trigger ATDC_13_TAB1_trigger_1&lt;/p&gt;</comment>
                            <comment id="13060566" author="dagw" created="Wed, 6 Jul 2011 14:21:06 +0100"  >&lt;p&gt;Hi Mamta, I am confused by this code to be honest. For example, the&lt;br/&gt;
following fragment:&lt;/p&gt;

&lt;p&gt;/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Make underlying spses dependent on the trigger.&lt;br/&gt;
 */&lt;br/&gt;
if (whenspsd != null)
{
    dm.addDependency(triggerd, whenspsd, lcc.getContextManager());
}
&lt;p&gt;dm.addDependency(triggerd, actionspsd, lcc.getContextManager());&lt;br/&gt;
dm.addDependency(triggerd, triggerTable, lcc.getContextManager());&lt;br/&gt;
dm.addDependency(actionspsd, triggerTable, lcc.getContextManager());&lt;/p&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As far as I understand, the first addDependency makes &quot;triggerd&quot;&lt;br/&gt;
dependent on &quot;whenspsd&quot;, but the comment says its the other way&lt;br/&gt;
around.&lt;/p&gt;

&lt;p&gt;Similarly, the second add makes &quot;triggerd&quot; dependent on&lt;br/&gt;
&quot;actionspsd&quot;. I would have throught it should be the other way around?&lt;br/&gt;
That the stored sps should dependent on the trigger definition as as&lt;br/&gt;
to get recompiled when the trigger definition changed.. &lt;/p&gt;

&lt;p&gt;The third and the fourth adds make sense to me: when the table&lt;br/&gt;
changes, the trigger definition would need recompilation and when the&lt;br/&gt;
triggerTable changed the actionspsd would need recompilation.&lt;/p&gt;

&lt;p&gt;But I may be missing something here... &lt;/p&gt;</comment>
                            <comment id="13060723" author="mamtas" created="Wed, 6 Jul 2011 18:57:54 +0100"  >&lt;p&gt;Dag, I tend to agree with your comments. The cooment in the code does not seem to agree with the kinds of dependencies added by first 2 addDepency statements. I tried looking through the history of this code and it appears that we have this code from the very beginning.&lt;/p&gt;

&lt;p&gt;But, I debugged further to find out why one of the rows added during CREATE TRIGGER time gets dropped later on. The issue seems to be around trigger action sps getting invalidated and later getting recompiled when it gets fired next time around. Going back to the example test case provided earlier&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:db1_2;create=true&apos;; &lt;br/&gt;
CREATE TABLE ATDC_13_TAB1(c11 int, c12 int); &lt;br/&gt;
insert into ATDC_13_TAB1 values (1,11); &lt;/p&gt;

&lt;p&gt;create trigger ATDC_13_TAB1_trigger_1 after update &lt;br/&gt;
         on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
          values(1); &lt;/p&gt;

&lt;p&gt;create trigger ATDC_13_TAB1_trigger_2 after update &lt;br/&gt;
         on ATDC_13_TAB1 for each row mode db2sql &lt;br/&gt;
         values(1,2); &lt;/p&gt;

&lt;p&gt;&amp;#8211; following shows 6 rows &lt;br/&gt;
select * from sys.sysdepends; &lt;br/&gt;
update ATDC_13_TAB1 set c12=11; &lt;br/&gt;
&amp;#8211; following shows only 5 rows &lt;br/&gt;
select * from sys.sysdepends; &lt;/p&gt;

&lt;p&gt;When the 2nd trigger(ATDC_13_TAB1_trigger_2) gets created, CreateTriggerConstantAction sends CREATE_TRIGGER invalidation to the trigger table as shown below(This sends invalidation code to the first trigger ATDC_13_TAB1_trigger_1)&lt;br/&gt;
		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Send an invalidate on the table from which&lt;/li&gt;
		&lt;li&gt;the triggering event emanates.  This it&lt;/li&gt;
		&lt;li&gt;to make sure that DML statements on this table&lt;/li&gt;
		&lt;li&gt;will be recompiled.  Do this before we create&lt;/li&gt;
		&lt;li&gt;our trigger spses lest we invalidate them just&lt;/li&gt;
		&lt;li&gt;after creating them.&lt;br/&gt;
		*/&lt;br/&gt;
		dm.invalidateFor(triggerTable, DependencyManager.CREATE_TRIGGER, lcc);&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Later when, &quot;update ATDC_13_TAB1 set c12=11&quot; statement is executed, it fires both the triggers. The first trigger&lt;br/&gt;
(ATDC_13_TAB1_trigger_1) during it&apos;s execution finds that it is invalid. During recompilation, SPSDescriptor.compileStatement &lt;br/&gt;
removes the existing dependencies recorded in SYSDEPENDS table for the trigger action sps as shown below.This step ends up&lt;br/&gt;
removing the dependency recorded between the trigger action sps and trigger table(added by CreateTriggerConstantAction at the time trigger creation) and that is where we can one row short.&lt;br/&gt;
	/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Clear out all the dependencies that exist&lt;/li&gt;
		&lt;li&gt;before we recreate them so we don&apos;t grow&lt;/li&gt;
		&lt;li&gt;SYS.SYSDEPENDS forever.&lt;br/&gt;
	*/&lt;br/&gt;
	dm.clearDependencies(lcc, this, tc);&lt;br/&gt;
After clearing out existing dependencies for invalid trigger action sps, the trigger action sps regeneration process adds the dependencies that it finds during this recompile SPSDescriptor.compileStatement()&lt;br/&gt;
	/*&lt;/li&gt;
		&lt;li&gt;Copy over all the dependencies to me&lt;br/&gt;
	*/&lt;br/&gt;
	dm.copyDependencies(preparedStatement, 	// from&lt;br/&gt;
		this, 	// to&lt;br/&gt;
		false,	// persistent only&lt;br/&gt;
		cm,&lt;br/&gt;
		tc);&lt;br/&gt;
But the dependency between trigger action SPSD and trigger table never gets added back during the recompilation and that is where we loose a row from SYSDEPENDS.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13060783" author="dagw" created="Wed, 6 Jul 2011 20:31:50 +0100"  >&lt;p&gt;I guess the trigger action statement here (&quot;values(1)&quot;) isn&apos;t really dependent on either the table or the trigger definition for that matter? So maybe it doesn&apos;t matter. Maybe it was gratuitous in the first place? Maybe the table dependency should always (only) be added by the compilation step of the SPS..? The comment (&quot;SIDE EFFECTS&quot;) in SPSDescriptor#prepareAndRelease seems to indicate it would happen there..&lt;/p&gt;

&lt;p&gt;It seems weird that adding a second trigger should invalidate the first trigger&apos;s SPS, though, but as far as I can see it&apos;s a side effect of forcing DML statements to be recompiled when adding the second trigger. It would seems this could set of a ping-pong of invalidation between triggers, but I guess it doesn&apos;t, since on invalidation of the first trigger&apos;s SPS we just recompile and do not re-execute the code in CreateTriggerConstantAction (which would otherwise set off the CREATE_TRIGGER invalidation on the trigger table and hence recompile of the second etc)...&lt;/p&gt;

&lt;p&gt;The whole idea of invalidation is to keep things up to date, maybe we should revisit what dependencies are really needed for triggers, right now it&apos;s not clear to me..&lt;/p&gt;</comment>
                            <comment id="13061458" author="mamtas" created="Thu, 7 Jul 2011 18:45:17 +0100"  >&lt;p&gt;I have a test case(with comments in the script below) that shows how missing row in SYSDEPENDS does not catch a trigger getting invalid.&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:db1;create=true&apos;;&lt;br/&gt;
create table t1(c11 int, c12 int);&lt;br/&gt;
insert into t1 values(1,1);&lt;br/&gt;
create table t1_bkup1(c111 int, c112 int);&lt;br/&gt;
create table t1_bkup2(c211 int, c212 int);&lt;/p&gt;

&lt;p&gt;&amp;#8211; for following trigger, 5 rows will be added to sysdepends&lt;br/&gt;
create trigger tr1 after update of c11 on t1 referencing&lt;br/&gt;
 old_table as old for each statement insert into&lt;br/&gt;
 t1_bkup1 select * from old;&lt;/p&gt;

&lt;p&gt;&amp;#8211; for following trigger, 5 rows will be added to sysdepends&lt;br/&gt;
&amp;#8211; This trigger creation will also invalidate the trigger tr1 &lt;br/&gt;
create trigger tr2 after update of c11 on t1 referencing&lt;br/&gt;
 old as oldrow for each row insert into&lt;br/&gt;
 t1_bkup2(c211) values (oldrow.c11);&lt;br/&gt;
select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from sys.sysdepends;&lt;/p&gt;

&lt;p&gt;&amp;#8211; following update will cause tr1 to recompile because it has been marked invalid&lt;br/&gt;
&amp;#8211; But as part of recompile, trigger action sps&apos;s dependency on trigger table will&lt;br/&gt;
&amp;#8211;  be lost bringing down the total number of rows in sysdepends from 10 to 9&lt;br/&gt;
update t1 set c11=2;&lt;br/&gt;
select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from sys.sysdepends;&lt;/p&gt;

&lt;p&gt;&amp;#8211; Because the dependency between trigger tr1&apos;s trigger action sps and trigger table&lt;br/&gt;
&amp;#8211;   is lost, following alter table on trigger table will not be noticed by tr1&lt;br/&gt;
alter table t1 add column c113 int;&lt;br/&gt;
&amp;#8211; following update will not fail for trigger tr1 even though it is not correct anymore(tr1&lt;br/&gt;
&amp;#8211;  is inserting into t1_bkup1 but after the alter table the number of columns in &lt;br/&gt;
&amp;#8211;  trigger table do not match the number of columns in t1_bkup1 but this is never &lt;br/&gt;
&amp;#8211;  caught because of the missing dependency.)&lt;br/&gt;
update t1 set c11=3;&lt;/p&gt;

&lt;p&gt;&amp;#8211; We can prove that trigger tr1 is incorrect after alter table because if we tried &lt;br/&gt;
&amp;#8211;  creating another trigger with same definition as tr1, it will fail&lt;br/&gt;
create trigger tr3 after update of c11 on t1 referencing&lt;br/&gt;
 old_table as old for each statement insert into&lt;br/&gt;
 t1_bkup1 select * from old;&lt;/p&gt;</comment>
                            <comment id="13061488" author="dagw" created="Thu, 7 Jul 2011 19:56:33 +0100"  >&lt;p&gt;Interesting. Why isn&apos;t the dependency on the trigger table (bound as old, oldrow) added during (re)prepare of the action statement I wonder? If it were, the dependency would be added back&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13061500" author="dagw" created="Thu, 7 Jul 2011 20:03:08 +0100"  >&lt;p&gt;What would be the correct behavior here? Obviously, tr1 is no longer valid after the alter table: should tr1 be silently dropped or should the alter table fail? We don&apos;t have a CASCADE/RESTRICT specification for ADD COLUMN, perhaps this proves we need it?&lt;/p&gt;</comment>
                            <comment id="13061524" author="mamtas" created="Thu, 7 Jul 2011 20:32:11 +0100"  >&lt;p&gt;If the dependency between trigger action sps and trigger table wasn&apos;t dropped, I think then update sql would fail because of trigger tr1 finding out during recompile that the it is not valid anymore.&lt;/p&gt;

&lt;p&gt;As for ALTER TABLE drop column catching the dependency, there are couple jiras open for catching cases like this I think.&lt;/p&gt;

&lt;p&gt;I am looking at how the dependency between trigger action sps and trigger table can be maintained during the recompile of trigger action.&lt;/p&gt;</comment>
                            <comment id="13061570" author="rhillegas" created="Thu, 7 Jul 2011 21:26:49 +0100"  >&lt;p&gt;The following theory and example may help people reason about how to fix the problem described by this JIRA.&lt;/p&gt;

&lt;p&gt;-------------- THEORY ---------------------&lt;/p&gt;

&lt;p&gt;The following discussion relies on these definitions and assumptions:&lt;/p&gt;

&lt;p&gt;i) Invaliding events - These include &quot;object dropped&quot; and &quot;object modified&quot;.&lt;/p&gt;

&lt;p&gt;ii)  &quot;A -&amp;gt; B&quot; -  This is a dependency arc. It is shorthand for &quot;A  depends on B&quot;. Invalidating events travel backward along the  dependency arcs, allowing each object to decide how to respond to the event. Possible responses include: &quot;raise an exception because RESTRICT semantics are violated&quot; and &quot;recompile me&quot;.&lt;/p&gt;

&lt;p&gt;iii) Dependency Graph - This is a graph of all dependency arcs needed by Derby. The nodes in this graph are the persistent objects plus PreparedStatements. There is an arrow from A to B iff &quot;A -&amp;gt; B&quot;.&lt;/p&gt;

&lt;p&gt;iv) Transitivity - The Dependency Graph obeys the following rule:&lt;/p&gt;

&lt;p&gt;  if &quot;A -&amp;gt; B&quot; and &quot;B -&amp;gt; C&quot;, then &quot;A -&amp;gt; C&quot;&lt;/p&gt;

&lt;p&gt;v) SYSDEPENDS contains dependency arcs between persistent objects.&lt;/p&gt;

&lt;p&gt;vi) Sufficient - SYSDEPENDS is said to be sufficient if it contains enough dependency arcs to reconstruct the entire Dependency Graph. Note that SYSDEPENDS is not the only input to constructing the Dependency Graph. Some arcs are implicitly described by other catalogs. Transitivity can be used to construct further arcs.&lt;/p&gt;

&lt;p&gt;vii) Minimal - SYSDEPENDS is said to be minimal if it contains the smallest number of arcs needed to reconstruct the entire Dependency Graph. For instance, if SYSDEPENDS contains the arcs &quot;A -&amp;gt; B&quot; and &quot;B -&amp;gt; C&quot; then SYSDEPENDS does not need to contain the &quot;A -&amp;gt; C&quot; arc because Derby can reconstruct that arc from the Transitivity rule.&lt;/p&gt;

&lt;p&gt;viii) Fuzzy - SYSDEPENDS is said to be fuzzy if it contains arcs that are not in the Dependency Graph.&lt;/p&gt;

&lt;p&gt;I would venture the following:&lt;/p&gt;

&lt;p&gt;I) SYSDEPENDS should be Sufficient and not Fuzzy.&lt;/p&gt;

&lt;p&gt;II) Even if SYSDEPENDS is Sufficient, Derby may have a bug which prevents it from constructing the complete Dependency Graph. For instance, Derby may be ignoring relevant information in other catalogs.&lt;/p&gt;

&lt;p&gt;III) I do not believe that SYSDEPENDS is Minimal. When DDL creates new arcs in the Dependency Graph, Derby does not recompute the contents of SYSDEPENDS just to guarantee a Minimal representation.&lt;/p&gt;


&lt;p&gt;------------- EXAMPLE ------------------&lt;/p&gt;

&lt;p&gt;Let&apos;s apply this to a trigger example.&lt;/p&gt;

&lt;p&gt;  INSERTs into table T1 fire a trigger which INSERTs into table T2&lt;/p&gt;

&lt;p&gt;This example gives rise to the following persistent objects:&lt;/p&gt;

&lt;p&gt;  Tables T1 and T2&lt;br/&gt;
  Corresponding conglomerates C1 and C2&lt;br/&gt;
  Trigger TR&lt;br/&gt;
  Action statement A&lt;/p&gt;

&lt;p&gt;The following would be a Minimal representation in SYSDEPENDS:&lt;/p&gt;

&lt;p&gt;  TR -&amp;gt; T1&lt;br/&gt;
  A -&amp;gt; T2&lt;/p&gt;

&lt;p&gt;Note that the following additional arcs do not need to be modelled in SYSDEPENDS, but can be constructed by Derby from information in other catalogs:&lt;/p&gt;

&lt;p&gt;  T1 -&amp;gt; C1&lt;br/&gt;
  C1 -&amp;gt; T1&lt;br/&gt;
  T2 -&amp;gt; C2&lt;br/&gt;
  C2 -&amp;gt; T2&lt;br/&gt;
  TR -&amp;gt; A&lt;br/&gt;
  A -&amp;gt; TR&lt;/p&gt;

&lt;p&gt;Other arcs arise via the Transitive rule.&lt;/p&gt;

&lt;p&gt;What we actually see in SYSDEPENDS is the following Sufficient, non-Minimal representation:&lt;/p&gt;

&lt;p&gt;  TR -&amp;gt; T1&lt;br/&gt;
  TR -&amp;gt; A (non-Minimal, could be constructed from SYSTRIGGERS)&lt;br/&gt;
  A -&amp;gt; T1 (non-Minimal, could be constructed by Transitivity)&lt;br/&gt;
  A -&amp;gt; T2&lt;br/&gt;
  A -&amp;gt; C2  (non-Minimal, could be constructed by Transitivity)&lt;/p&gt;

&lt;p&gt;Here is a script which shows this example:&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:memory:db;create=true&apos;; &lt;/p&gt;

&lt;p&gt;create table t1( a int );&lt;br/&gt;
create table t2( a int );&lt;br/&gt;
create trigger trig after insert on t1 for each statement insert into t2( a ) values( 1 );&lt;/p&gt;

&lt;p&gt;select * from sys.sysdepends order by dependentid, providerid;&lt;br/&gt;
select tablename, tableid from sys.systables where tablename like &apos;T%&apos;;&lt;br/&gt;
select t.tablename, c.conglomerateid&lt;br/&gt;
from sys.systables t, sys.sysconglomerates c&lt;br/&gt;
where tablename like &apos;T%&apos;&lt;br/&gt;
and t.tableid = c.tableid;&lt;br/&gt;
select triggerid from sys.systriggers;&lt;/p&gt;</comment>
                            <comment id="13061645" author="mamtas" created="Thu, 7 Jul 2011 23:55:53 +0100"  >&lt;p&gt;Thanks Rick and Dag on all the time you have put in this jira. I really appreciate that. &lt;/p&gt;

&lt;p&gt;As part of this jira though, I will like to focus on how to keep the dependency between trigger action sps and trigger table intact during recompile(which currently gets dropped during the recompile phase). As for the bigger picture of having only the necessary dependencies for triggers and checking if Derby is keeping only the required depdendencies, I will create a new jira for that. I will put Dag&apos;s and Rick&apos;s comments in this jira and will also link that new jira to the current jira. &lt;/p&gt;</comment>
                            <comment id="13061713" author="dagw" created="Fri, 8 Jul 2011 02:38:08 +0100"  >&lt;p&gt;Yes Mamta, I can see that the update statement would be the one failing with the current implementation (if the dependency of the action on the trigger table had not been dropped, as you point out). I think the behavior may be wrong, though, the time to fail or drop the trigger should probably at ALTER TABLE time. But that&apos;s another issue as you say. Meanwhile, I&apos;m still curious why the dependency wouldn&apos;t/coudln&apos;t be added back when we reprepare, though, since the trigger action does contain reference to the trigger table, albeit in the form of the &quot;old&quot;/&quot;oldrow&quot; aliases (in your second example repro).&lt;/p&gt;

&lt;p&gt;Rick, in your explanation of extended (data) dependencies, some dependencies are bi-directional, mirroring a one-to-one relationhip. When would such bidirectional dependencies ever be required in SYSDEPENDS? I think in some cases we only register unidirectional ones? Is this &quot;pragmatic&quot;, in the sense that we register deps in SYSDEPENDS (or in memory only) only in the (inverse) direction we want to invalidate?&lt;/p&gt;</comment>
                            <comment id="13061940" author="rhillegas" created="Fri, 8 Jul 2011 14:00:09 +0100"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;I think that SYSDEPENDS exists in order to make it fast to reconstruct the Dependency Graph. It doesn&apos;t need to contain arcs representing the relationship between tables and conglomerates because those can be figured out quickly by looking at other catalogs. But the arc backward from a triggering table to its trigger is hard to reconstruct, so that arc is put into SYSDEPENDS.&lt;/p&gt;

&lt;p&gt;The issue of bidirectional arcs (cycles) is interesting. I don&apos;t know if there are any examples of this in SYSDEPENDS. However, the cycles should exist in the Dependency Graph I think. The example of tables and conglomerates comes to mind:&lt;/p&gt;

&lt;p&gt;  T1 -&amp;gt; C1 models the fact that dropping the conglomerate (e.g. by bulk import) should invalidate the table.&lt;/p&gt;

&lt;p&gt;  C1 -&amp;gt; T1 models the fact that dropping the table should also drop the conglomerate.&lt;/p&gt;

&lt;p&gt;I don&apos;t think that Derby systematically implements the Dependency Graph I have described. My impression is that dependency management is a hodge-podge today. Some of the relationships are managed by the dependency subsystem. Other relationships are managed by little winks and nods in other parts of the SQL interpreter. In my opinion this hodge-podge makes dependency management brittle and hard to reason about.&lt;/p&gt;

&lt;p&gt;Hi Mamta,&lt;/p&gt;

&lt;p&gt;I may not be following your analysis. But it sounds to me as though the following arc has vanished from SYSDEPENDS:&lt;/p&gt;

&lt;p&gt;  A -&amp;gt; triggeringTable&lt;/p&gt;

&lt;p&gt;I am suggesting that this is a non-Minimal arc and doesn&apos;t need to be in SYSDEPENDS. Derby should be able to construct this arc on the fly via Transitivity from the following arcs:&lt;/p&gt;

&lt;p&gt; A -&amp;gt; TR (this is known from SYSTRIGGERS)&lt;br/&gt;
 TR -&amp;gt; triggeringTable (this is still in SYSDEPENDS if I understand correctly)&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13062102" author="mamtas" created="Fri, 8 Jul 2011 19:34:06 +0100"  >&lt;p&gt;Created a new jira to see if dependency info in SYSDEPENDS can be cleaned up a little with all the great info provided by Rick. &lt;/p&gt;

&lt;p&gt;The new jira number is &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5323&quot; title=&quot;SYSDEPENDS may be keeping redundant dependency info. Specific information for trigger case in this jira but there might be other cases as well&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5323&quot;&gt;DERBY-5323&lt;/a&gt; SYSDEPENDS may be keeping redundant dependency info. Specific informatio&#8203;n for trigger case in this jira but there might be other cases as well.&lt;/p&gt;

&lt;p&gt;I have connected the 2 jiras.&lt;/p&gt;</comment>
                            <comment id="13062104" author="mamtas" created="Fri, 8 Jul 2011 19:40:06 +0100"  >&lt;p&gt;Rick, I was planning to keep my focus on just maintaining the dependency that was originally intended for trigger. At the create trigger time, we add the dependency between trigger action and trigger table. We loose that during trigger recompile. I think this fix will be real easy by having SPSDescriptor add this dependency info rather than create trigger do it. This will take care of both create trigger and trigger action recompile because of invalidity. Let me know if you, Dag or anyone else have any feedback on moving the trigger action -&amp;gt; trigger table dependency to SPSDescriptor from Create Trigger. Thanks&lt;/p&gt;

&lt;p&gt;I agree that some of these dependencies can probably be established programmatically rather than SYSDEPENDS having to carry it. But I will like that work to go as part of the new jira &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5323&quot; title=&quot;SYSDEPENDS may be keeping redundant dependency info. Specific information for trigger case in this jira but there might be other cases as well&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5323&quot;&gt;DERBY-5323&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13062118" author="rhillegas" created="Fri, 8 Jul 2011 20:11:13 +0100"  >&lt;p&gt;Hi Mamta,&lt;/p&gt;

&lt;p&gt;Your plan sounds good to me. Thanks.&lt;/p&gt;</comment>
                            <comment id="13063608" author="mamtas" created="Tue, 12 Jul 2011 00:34:05 +0100"  >&lt;p&gt;I am attaching a patch which moves recording to trigger action sps&apos;s dependency on trigger table from create trigger constant action to SPSDescriptor. This should take care of both create trigger time and sps regeneration time. I am seeing couple failures with this patch. I hope to have those tests fixed by tomorrow. &lt;/p&gt;</comment>
                            <comment id="13064007" author="mamtas" created="Tue, 12 Jul 2011 18:08:49 +0100"  >&lt;p&gt;I am attaching another patch which has two test problems resolved which I saw seeing with the earlier patch. The two tests that were failing with patch 1 were 1)AlterTableTest,testDropColumn This was failing because  the number of rows in sysdepends were not as expected by the test. I found the problem was that AlterTableConstantAction does a drop and recreate trigger and it was adding the dependency between trigger action sps and trigger table. It does not need to add that dependency anymore because it is taken care of by SPSDescriptor. Removing the dependency add code from AlterTableConstantAction resolved the problem.&lt;br/&gt;
2)triggerGeneral.sql was failing because a trigger action was using select * from trigger table to insert into another table. Later an alter table was performed to add one more column to the trigger table. With missing dependency before, trigger action was not getting regenerated and hence trigger didn&apos;t detect that it is not valid anymore. After I have made the changes for the dependency, trigger action gets invalidated when a new column is added to trigger table and this will cause the trigger to fail.I have fixed the test to not do select * in trigger action so add column will not impact it. The test in triggerGeneral has been written for a specific purpose and that is why I didn&apos;t want the test to fail with select *. I will add another test which will catch a case like insert into select * in trigger action and it getting invalid with add column.&lt;/p&gt;

&lt;p&gt;The only tasks left on this jira is to add the test I mentioned. Additionally, I plan to add an upgrade test.&lt;/p&gt;

&lt;p&gt;If anyone has any feedback, please let me know.&lt;/p&gt;</comment>
                            <comment id="13064297" author="mamtas" created="Wed, 13 Jul 2011 03:25:32 +0100"  >&lt;p&gt;Adding a new patch which now has a test for the changes.Next,will work on an upgrade test&lt;/p&gt;</comment>
                            <comment id="13064760" author="mamtas" created="Wed, 13 Jul 2011 19:45:00 +0100"  >&lt;p&gt;Attaching patch DERBY5120_patch4_diff.txt which now also has an upgrade test. The upgrade test&apos;s intention is to verify that sysdepedns row that may have been dropped of in earlier releases will be restored during the various phases of upgrade. In other words, when a pre-10.9 db is soft/hard upgraded to trunk, the missing row will be added back into sysdepends. But after the soft-upgrade, if the db is taken back to it&apos;s original release, the row will be lost again.I am verifying this by looking at the count of number of rows in sysdepends. &lt;/p&gt;

&lt;p&gt;I am running into one issue with this test though. There are few releases where the rows in sysdepends do not match with what the test expects them to. I am doing more debugging to find what might be the issue.&lt;/p&gt;</comment>
                            <comment id="13064903" author="mamtas" created="Wed, 13 Jul 2011 23:01:32 +0100"  >&lt;p&gt;I have found that the new upgrade test added in patch 4 fails for 10.5.1.1, 10.5.3.0, 10.6.1.0 and 10.6.2.1 releases. I do not believe the problem is with my changes, I am debugging further to find out why the test fails only with these 4 releases. The test is failing for those 4 releases because the number of rows expected by the test do not match with what&apos;s actually found in the database.&lt;/p&gt;</comment>
                            <comment id="13065353" author="mamtas" created="Thu, 14 Jul 2011 17:06:31 +0100"  >&lt;p&gt;Attaching final patch which is ready for commit. The reason newly added upgrade test(from patch 4) is failing with 10.5.1.1, 10.5.3.0, 10.6.1.0 and 10.6.2.1 releases is that those releases have &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4835&quot; title=&quot;Trigger plan does not recompile with upgrade from 10.5.3.0 to 10.6.1.0 causing  java.lang.NoSuchMethodError&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4835&quot;&gt;&lt;del&gt;DERBY-4835&lt;/del&gt;&lt;/a&gt; fix missing from them.&lt;/p&gt;

&lt;p&gt;        During the upgrade time, the clearing of stored statements(including trigger action spses) happened conditionally before &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4835&quot; title=&quot;Trigger plan does not recompile with upgrade from 10.5.3.0 to 10.6.1.0 causing  java.lang.NoSuchMethodError&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4835&quot;&gt;&lt;del&gt;DERBY-4835&lt;/del&gt;&lt;/a&gt; was fixed. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4835&quot; title=&quot;Trigger plan does not recompile with upgrade from 10.5.3.0 to 10.6.1.0 causing  java.lang.NoSuchMethodError&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4835&quot;&gt;&lt;del&gt;DERBY-4835&lt;/del&gt;&lt;/a&gt; made changes so that the stored statements get marked invalid unconditionally during the upgrade phase. But these changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4835&quot; title=&quot;Trigger plan does not recompile with upgrade from 10.5.3.0 to 10.6.1.0 causing  java.lang.NoSuchMethodError&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4835&quot;&gt;&lt;del&gt;DERBY-4835&lt;/del&gt;&lt;/a&gt; did not make into 10.5.1.1, 10.5.3.0, 10.6.1.0 and 10.6.2.1. Because of this missing fix, trigger action spses do not get marked invalid when the database is taken after soft upgrade back to the original db release(if the original db release is one of the releases mentioned above). The newly added upgrade test relies on trigger action spses getting invalid during upgrade phase and getting recompiled when they are fired next time around thus altering the number of rows in sysdepends. Because of this, I have disabled the upgrade test for those 4 releases.&lt;/p&gt;

&lt;p&gt;I will go ahead and commit this patch&lt;/p&gt;</comment>
                            <comment id="13065354" author="mamtas" created="Thu, 14 Jul 2011 17:08:19 +0100"  >&lt;p&gt;BTW, when I run the junite suite with patch number 5, I see only known intermittent failures as shown below. derbyall ran fine with no errors.&lt;br/&gt;
1) testBootLock(org.apache.derbyTesting.functionTests.tests.store.BootLockTest)java.lang.InterruptedException&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.store.BootLockTest.testBootLock(BootLockTest.java:158)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:112)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
2) ManagementMBeanTest:clientjava.lang.InterruptedException&lt;br/&gt;
	at org.apache.derbyTesting.junit.SpawnedProcess.complete(SpawnedProcess.java:182)&lt;br/&gt;
	at org.apache.derbyTesting.junit.NetworkServerTestSetup.tearDown(NetworkServerTestSetup.java:394)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:20)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:51)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
There were 3 failures:&lt;br/&gt;
1) testPingWithWrongHost(org.apache.derbyTesting.functionTests.tests.derbynet.NetworkServerControlClientCommandTest)junit.framework.AssertionFailedError: Could not find expectedString:Unable to find host in output:Wed Jul 13 19:37:36 PDT 2011 : Could not connect to Derby Network Server on host nothere, port 1527: Connection timed out: connect&lt;/p&gt;

&lt;p&gt;	at org.apache.derbyTesting.junit.BaseTestCase.assertExecJavaCmdAsExpected(BaseTestCase.java:516)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.derbynet.NetworkServerControlClientCommandTest.assertFailedPing(NetworkServerControlClientCommandTest.java:147)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.derbynet.NetworkServerControlClientCommandTest.testPingWithWrongHost(NetworkServerControlClientCommandTest.java:112)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:112)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
2) testInvalidLDAPServerConnectionError(org.apache.derbyTesting.functionTests.tests.jdbcapi.InvalidLDAPServerAuthenticationTest)junit.framework.AssertionFailedError&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.InvalidLDAPServerAuthenticationTest.testInvalidLDAPServerConnectionError(InvalidLDAPServerAuthenticationTest.java:122)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:112)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
3) testInvalidLDAPServerConnectionErrorjunit.framework.AssertionFailedError: Failed to delete 8 files (root=C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48: C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\db.lck (isDir=false, canRead=true, canWrite=true, size=38), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\log\log1.dat (isDir=false, canRead=true, canWrite=true, size=1048576), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\log (isDir=true, canRead=true, canWrite=true, size=0), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\seg0\c10.dat (isDir=false, canRead=true, canWrite=true, size=8192), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\seg0\cc0.dat (isDir=false, canRead=true, canWrite=true, size=8192), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\seg0\cd1.dat (isDir=false, canRead=true, canWrite=true, size=8192), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48\seg0 (isDir=true, canRead=true, canWrite=true, size=0), C:\p4clients\svnmain\client7\trunk\systest\dellater\system\singleUse\oneuse48 (isDir=true, canRead=true, canWrite=true, size=0)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseJDBCTestCase.assertDirectoryDeleted(BaseJDBCTestCase.java:1526)&lt;br/&gt;
	at org.apache.derbyTesting.junit.DropDatabaseSetup.removeDir(DropDatabaseSetup.java:119)&lt;br/&gt;
	at org.apache.derbyTesting.junit.DropDatabaseSetup.access$000(DropDatabaseSetup.java:35)&lt;br/&gt;
	at org.apache.derbyTesting.junit.DropDatabaseSetup$1.run(DropDatabaseSetup.java:105)&lt;br/&gt;
	at java.security.AccessController.doPrivileged(AccessController.java:202)&lt;br/&gt;
	at org.apache.derbyTesting.junit.DropDatabaseSetup.removeDirectory(DropDatabaseSetup.java:102)&lt;br/&gt;
	at org.apache.derbyTesting.junit.DropDatabaseSetup.removeDirectory(DropDatabaseSetup.java:98)&lt;br/&gt;
	at org.apache.derbyTesting.junit.DropDatabaseSetup.removeDatabase(DropDatabaseSetup.java:91)&lt;br/&gt;
	at org.apache.derbyTesting.junit.TestConfiguration$4.tearDown(TestConfiguration.java:747)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:20)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:16)&lt;/p&gt;</comment>
                            <comment id="13065596" author="mamtas" created="Thu, 14 Jul 2011 23:59:33 +0100"  >&lt;p&gt;I haved committed changes for this jira as revision 1146915. The changes committed look like patch 5 except that I have changed the upgrade test to not rely on number of rows in sysdepends. Instead the upgrade test does the testing of this jira by issuing the UPDATE sql after a sql which should cause trigger invalidation and showing how UPDATE does not fail in pre-10.9 releases but it does fail correctly after soft/hard upgrade to 10.9&lt;/p&gt;</comment>
                            <comment id="13685375" author="knutanders" created="Mon, 17 Jun 2013 10:19:51 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12731721">DERBY-6684</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12513295">DERBY-5323</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12486120" name="DERBY5120_patch1_diff.txt" size="1415" author="mamtas" created="Tue, 12 Jul 2011 00:34:05 +0100"/>
                            <attachment id="12486121" name="DERBY5120_patch1_stat.txt" size="165" author="mamtas" created="Tue, 12 Jul 2011 00:34:05 +0100"/>
                            <attachment id="12486205" name="DERBY5120_patch2_diff.txt" size="2885" author="mamtas" created="Tue, 12 Jul 2011 18:08:48 +0100"/>
                            <attachment id="12486206" name="DERBY5120_patch2_stat.txt" size="340" author="mamtas" created="Tue, 12 Jul 2011 18:08:48 +0100"/>
                            <attachment id="12486258" name="DERBY5120_patch3_diff.txt" size="7577" author="mamtas" created="Wed, 13 Jul 2011 03:25:32 +0100"/>
                            <attachment id="12486259" name="DERBY5120_patch3_stat.txt" size="431" author="mamtas" created="Wed, 13 Jul 2011 03:25:32 +0100"/>
                            <attachment id="12486345" name="DERBY5120_patch4_diff.txt" size="14115" author="mamtas" created="Wed, 13 Jul 2011 19:45:00 +0100"/>
                            <attachment id="12486346" name="DERBY5120_patch4_stat.txt" size="526" author="mamtas" created="Wed, 13 Jul 2011 19:45:00 +0100"/>
                            <attachment id="12486462" name="DERBY5120_patch5_diff.txt" size="15187" author="mamtas" created="Thu, 14 Jul 2011 17:06:31 +0100"/>
                            <attachment id="12486463" name="DERBY5120_patch5_stat.txt" size="526" author="mamtas" created="Thu, 14 Jul 2011 17:06:31 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 6 Jul 2011 13:21:06 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31507</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0e7b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36119</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>