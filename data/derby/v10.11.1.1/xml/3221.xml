<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:14:45 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3221/DERBY-3221.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3221] &quot;java.sql.SQLException: The conglomerate (-5) requested does not exist.&quot; from Derby 10.3.1.4 embedded within Eclipse 3.3 and RAD 7.0</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3221</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;We are getting an SQLException when several prepared statement deletes are done upon an existing database.  As far as we can tell this exception should never occur unless (evil) things like deleting the database or editing files occurs.  This is using the embedded driver within a plug-in inside RAD 7.0 (and Eclipse 3.3).&lt;/p&gt;

&lt;p&gt;I&apos;m not sure what else to submit that might be helpful.&lt;/p&gt;

&lt;p&gt;java.sql.SQLException: The conglomerate (-5) requested does not exist.&lt;br/&gt;
 at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(Unknown Source)&lt;br/&gt;
 at sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)&lt;br/&gt;
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)&lt;br/&gt;
 at java.lang.reflect.Method.invoke(Unknown Source)&lt;br/&gt;
 at com.surelogic.sierra.jdbc.LazyPreparedStatementConnection$LazyPreparedStatement.invoke(Unknown Source)&lt;br/&gt;
 at $Proxy1.execute(Unknown Source)&lt;br/&gt;
 at com.surelogic.sierra.jdbc.finding.FindingManager.delete(Unknown Source)&lt;br/&gt;
 at com.surelogic.sierra.jdbc.finding.ClientFindingManager.updateLocalFindings(Unknown Source)&lt;br/&gt;
 at com.surelogic.sierra.jdbc.project.ClientProjectManager.synchronizeProject(Unknown Source)&lt;br/&gt;
 at com.surelogic.sierra.client.eclipse.jobs.SynchronizeJob.synchronize(Unknown Source)&lt;br/&gt;
 at com.surelogic.sierra.client.eclipse.jobs.SynchronizeJob.run(Unknown Source)&lt;br/&gt;
 at org.eclipse.core.internal.jobs.Worker.run(Unknown Source)&lt;br/&gt;
Caused by: ERROR XSAI2: The conglomerate (-5) requested does not exist.&lt;br/&gt;
 at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.execute.IndexChanger.finish(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.execute.IndexSetChanger.finish(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.execute.RowChangerImpl.finish(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.execute.UpdateResultSet.open(Unknown Source)&lt;br/&gt;
 at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
 ... 14 more&lt;/p&gt;</description>
                <environment>Windows Vista Ubuntu Linux on IBM&amp;#39;s VM (RAD 7.0)</environment>
        <key id="12383008">DERBY-3221</key>
            <summary>&quot;java.sql.SQLException: The conglomerate (-5) requested does not exist.&quot; from Derby 10.3.1.4 embedded within Eclipse 3.3 and RAD 7.0</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dyret">Dyre Tjeldvoll</assignee>
                                    <reporter username="hallorant">Tim Halloran</reporter>
                        <labels>
                    </labels>
                <created>Wed, 21 Nov 2007 20:23:15 +0000</created>
                <updated>Fri, 21 Jan 2011 17:51:08 +0000</updated>
                            <resolved>Fri, 18 Jan 2008 09:54:57 +0000</resolved>
                                    <version>10.3.1.4</version>
                    <version>10.3.2.1</version>
                                    <fixVersion>10.3.3.0</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12545206" author="knutanders" created="Sat, 24 Nov 2007 18:57:10 +0000"  >&lt;p&gt;Is the problem reproducible, and if so, is it possible to post code that demonstrates the problem or a step-by-step description of how to reproduce it?&lt;/p&gt;</comment>
                            <comment id="12550545" author="northshorefiend" created="Tue, 11 Dec 2007 15:54:14 +0000"  >&lt;p&gt;Me too.&lt;/p&gt;

&lt;p&gt;I have a &apos;database create&apos; script that un-surprisingly creates tables and populates them.&lt;/p&gt;

&lt;p&gt;Running on 10.3.1.4 I get an&lt;/p&gt;

&lt;p&gt;ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;/p&gt;

&lt;p&gt;Caused by: ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;/p&gt;

&lt;p&gt;Running on 10.2.2.0 everything is fine.&lt;/p&gt;

&lt;p&gt;Spooky.&lt;/p&gt;

&lt;p&gt;The environment is just using the corresponding version of the embedded driver with all the jars on the classpath, starting with an empty derby.home directory (except for derby.properties turning up logging).&lt;/p&gt;

&lt;p&gt;There&apos;s a few posts on the net about this error having something to do with corrupted files. Clearly this doesn&apos;t apply in this case, except that 10.3.1.4 may be having it&apos;s own nervous breakdown.&lt;/p&gt;

&lt;p&gt;100% repeatable. Would I get anything by connecting a debugger? With all this (Unknown Source) I doubt it. I don&apos;t rate my chances of getting a good test case quickly.&lt;/p&gt;

&lt;p&gt;oh and:&lt;/p&gt;

&lt;p&gt;~ $ java -version; uname -primo&lt;br/&gt;
java version &quot;1.6.0_03&quot;&lt;br/&gt;
Java(TM) SE Runtime Environment (build 1.6.0_03-b05)&lt;br/&gt;
Java HotSpot(TM) 64-Bit Server VM (build 1.6.0_03-b05, mixed mode)&lt;br/&gt;
2.6.23-gentoo-r3-6 x86_64 Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz GenuineIntel GNU/Linux&lt;/p&gt;

&lt;p&gt;For the sake of it I tested using:&lt;/p&gt;

&lt;p&gt;java version &quot;1.6.0_03&quot;&lt;br/&gt;
Java(TM) SE Runtime Environment (build 1.6.0_03-b05)&lt;br/&gt;
Java HotSpot(TM) Server VM (build 1.6.0_03-b05, mixed mode)&lt;/p&gt;

&lt;p&gt;with 10.3.1.4 and still get the above error.&lt;/p&gt;</comment>
                            <comment id="12550666" author="mikem" created="Tue, 11 Dec 2007 18:25:13 +0000"  >&lt;p&gt;Negative conglomerate numbers are used for temporary files.  Are you doing anything special with temporary&lt;br/&gt;
files in your environment - ie. possibly setting derby option to relocate them?  Any chance some other process&lt;br/&gt;
is going after temporary files while your app is still working?  From minimal info available it looks like we are&lt;br/&gt;
somehow losing the temporary file associated with a deferred update, but I could be reading the incomplete&lt;br/&gt;
stack wrong.&lt;/p&gt;

&lt;p&gt;Best chance for someone to fix this is if you can post a reproducible case that a developer could run in their&lt;br/&gt;
own environment.&lt;/p&gt;

&lt;p&gt;Since you have a 100% reproducible case, if you can&apos;t do that can you do the following to give a clue what is&lt;br/&gt;
going on when the error is encountered:&lt;/p&gt;

&lt;p&gt;o start with a new database&lt;br/&gt;
o set option so that we never lose anything from the error log file: derby.infolog.append=true &lt;br/&gt;
    &lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/rtunproper13217.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/rtunproper13217.html&lt;/a&gt;&lt;br/&gt;
o set option to log the sql that you are doing to derby.log:  derby.language.logStatementText=true&lt;br/&gt;
   &lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/rtunproper43517.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/rtunproper43517.html&lt;/a&gt;&lt;br/&gt;
reproduce bug and post COMPLETE derby.log from test run.&lt;/p&gt;</comment>
                            <comment id="12550981" author="northshorefiend" created="Wed, 12 Dec 2007 14:33:06 +0000"  >&lt;p&gt;Well, of course, I switch back to 10.3.1.4 today, and no bug!!! So as I thought, test case; not so much.&lt;/p&gt;

&lt;p&gt;BUT, with the wonder that is the Eclipse local history, and the mystery that is svn, once again the error arises.&lt;/p&gt;

&lt;p&gt;I can&apos;t publish the full log (956k) as it contains a year&apos;s work that hasn&apos;t been paid for yet &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I realise that this might not go back far enough, it&apos;s the best I can do, apologies. Still, at least anyone that comes across such things will know that they aren&apos;t delusional.&lt;/p&gt;

&lt;p&gt;I did try &apos;sync &amp;amp;&amp;amp; sync&apos; before firing up the java code, but it made no difference. The filesystem all this is happening on has recently changed to being a linux software raid, but other than that everything else is pretty vanilla ext3 with nothing else accessing the dir.&lt;/p&gt;

&lt;p&gt;derby.properties now reads:&lt;br/&gt;
-----&lt;del&gt;8&amp;lt;&lt;/del&gt;----------&lt;br/&gt;
derby.stream.error.logSeverityLevel=0&lt;br/&gt;
derby.language.logStatementText=true&lt;br/&gt;
derby.infolog.append=true &lt;br/&gt;
-----&lt;del&gt;8&amp;lt;&lt;/del&gt;----------&lt;/p&gt;

&lt;p&gt;So, we are in a stored proc fired by a trigger. (names may have been changed to pretext the innocent)&lt;/p&gt;



&lt;p&gt;2007-12-12 13:22:40.326 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DRDAID = null), Executing prepared statement: INSERT INTO SubTTTXX ( nShapeID , nSubShapeID , nColorID , nHelp ) SELECT DISTINCT X.nColorID&lt;br/&gt;
, DSO.nSubShapeID , X.nColorID , (SELECT INTEGER(MAX(nHelp)+1) FROM SubTTTXX) FROM SubTTTXX X JOIN DirectSubTTT DSO ON X.nHelp &amp;gt; 0 AND DSO.nShapeID = X.nSubShapeID LEFT JOIN SubTTT SO ON SO.nShapeID = X.nShapeID AND SO.nSubShapeID = DSO.nSu&lt;br/&gt;
bShapeID WHERE X.nShapeID &amp;lt;&amp;gt; DSO.nSubShapeID AND SO.nShapeID IS NULL :End prepared statement&lt;br/&gt;
2007-12-12 13:22:40.330 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DRDAID = null), Cleanup action starting&lt;br/&gt;
2007-12-12 13:22:40.330 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DRDAID = null), Failed Statement is: INSERT INTO SubTTTXX ( nShapeID , nSubShapeID , nColorID , nHelp ) SELECT DISTINCT X.nShapeID , DSO&lt;br/&gt;
.nSubShapeID , X.nColorID , (SELECT INTEGER(MAX(nHelp)+1) FROM SubTTTXX) FROM SubTTTXX X JOIN DirectSubTTT DSO ON X.nHelp &amp;gt; 0 AND DSO.nShapeID = X.nSubShapeID LEFT JOIN SubTTT SO ON SO.nShapeID = X.nShapeID AND SO.nSubShapeID = DSO.nSubShapeID WHE&lt;br/&gt;
RE X.nShapeID &amp;lt;&amp;gt; DSO.nSubShapeID AND SO.nShapeID IS NULL&lt;br/&gt;
ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:79)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:43)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.Template.getResult(Template.java:80)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT.insert(SubTTT.java:107)&lt;br/&gt;
        at org.apache.derby.exe.ac12564092x0116xce84xf62dx000055b50d0421.g0(Unknown Source)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.ReflectMethod.invoke(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.CallStatementResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.StatementTriggerExecutor.fireTrigger(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate$2.doInPreparedStatement(JdbcTemplate.java:745)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:538)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:739)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:797)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:801)&lt;br/&gt;
        at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:218)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.importFromLegacyTables(DbOOOFactory.java:383)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.access$1500(DbOOOFactory.java:94)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO$2.doInTransactionWithoutResult(DbOOOFactory.java:352)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionCallbackWithoutResult.doInTransaction(TransactionCallbackWithoutResult.java:33)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:134)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.add(DbOOOFactory.java:339)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.reload(MetaJJJ.java:44)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.startup(MetaJJJ.java:57)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startupZzz(Start.java:208)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startup(Start.java:160)&lt;br/&gt;
        at com.xxx.start.Starter.startup(Starter.java:264)&lt;br/&gt;
        at com.xxx.start.Main.startup(Main.java:270)&lt;br/&gt;
        at com.xxx.start.Main.main(Main.java:199)&lt;br/&gt;
Cleanup action completed&lt;br/&gt;
2007-12-12 13:22:40.490 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DRDAID = null), Cleanup action starting&lt;br/&gt;
2007-12-12 13:22:40.490 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DRDAID = null), Failed Statement is:  INSERT INTO SubTTT ( nShapeID , nSubShapeID , nColorID ) SELECT DISTINCT C.nRCID , S.nRCID , (S&lt;br/&gt;
ELECT nColorID FROM Colorition WHERE nIsCCC = 1) FROM LegacySubCCC SC JOIN LegacyCCC C ON SC.nRunID = ? AND C.nRunID = ? AND C.nICCCID = SC.nICCCID JOIN LegacyCCC S ON S.nRunID = ? AND S.nICCCID = SC.nISubCCCID LEF&lt;br/&gt;
T JOIN SubTTT SO ON SO.nShapeID = C.nRCID AND SO.nSubShapeID = S.nRCID WHERE SO.nShapeID IS NULL with 3 parameters begin parameter #1: 1 :end parameter begin parameter #2: 1 :end parameter begin parameter #3: 1 :end parameter &lt;br/&gt;
ERROR 38000: The exception &apos;java.sql.SQLException: The conglomerate (-15) requested does not exist.&apos; was thrown while evaluating an expression.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.unexpectedUserException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.ReflectMethod.invoke(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.CallStatementResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.StatementTriggerExecutor.fireTrigger(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate$2.doInPreparedStatement(JdbcTemplate.java:745)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:538)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:739)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:797)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:801)&lt;br/&gt;
        at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:218)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.importFromLegacyTables(DbOOOFactory.java:383)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.access$1500(DbOOOFactory.java:94)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO$2.doInTransactionWithoutResult(DbOOOFactory.java:352)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionCallbackWithoutResult.doInTransaction(TransactionCallbackWithoutResult.java:33)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:134)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.add(DbOOOFactory.java:339)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.reload(MetaJJJ.java:44)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.startup(MetaJJJ.java:57)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startupZzz(Start.java:208)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startup(Start.java:160)&lt;br/&gt;
        at com.xxx.start.Starter.startup(Starter.java:264)&lt;br/&gt;
        at com.xxx.start.Main.startup(Main.java:270)&lt;br/&gt;
        at com.xxx.start.Main.main(Main.java:199)&lt;br/&gt;
Caused by: java.sql.SQLException: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:79)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:43)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.Template.getResult(Template.java:80)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT.insert(SubTTT.java:107)&lt;br/&gt;
        at org.apache.derby.exe.ac12564092x0116xce84xf62dx000055b50d0421.g0(Unknown Source)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
        ... 32 more&lt;br/&gt;
Caused by: java.sql.SQLException: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)&lt;br/&gt;
        ... 50 more&lt;br/&gt;
Caused by: ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        ... 44 more&lt;br/&gt;
============= begin nested exception, level (1) ===========&lt;br/&gt;
java.sql.SQLException: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:79)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:43)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.Template.getResult(Template.java:80)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT.insert(SubTTT.java:107)&lt;br/&gt;
        at org.apache.derby.exe.ac12564092x0116xce84xf62dx000055b50d0421.g0(Unknown Source)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.ReflectMethod.invoke(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.CallStatementResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.StatementTriggerExecutor.fireTrigger(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate$2.doInPreparedStatement(JdbcTemplate.java:745)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:538)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:739)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:797)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:801)&lt;br/&gt;
        at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:218)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.importFromLegacyTables(DbOOOFactory.java:383)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.access$1500(DbOOOFactory.java:94)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO$2.doInTransactionWithoutResult(DbOOOFactory.java:352)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionCallbackWithoutResult.doInTransaction(TransactionCallbackWithoutResult.java:33)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:134)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.add(DbOOOFactory.java:339)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.reload(MetaJJJ.java:44)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.startup(MetaJJJ.java:57)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startupZzz(Start.java:208)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startup(Start.java:160)&lt;br/&gt;
        at com.xxx.start.Starter.startup(Starter.java:264)&lt;br/&gt;
        at com.xxx.start.Main.startup(Main.java:270)&lt;br/&gt;
        at com.xxx.start.Main.main(Main.java:199)&lt;br/&gt;
Caused by: java.sql.SQLException: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)&lt;br/&gt;
        ... 50 more&lt;br/&gt;
Caused by: ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        ... 44 more&lt;br/&gt;
============= end nested exception, level (1) ===========&lt;br/&gt;
============= begin nested exception, level (2) ===========&lt;br/&gt;
java.sql.SQLException: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:79)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:43)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.Template.getResult(Template.java:80)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT.insert(SubTTT.java:107)&lt;br/&gt;
        at org.apache.derby.exe.ac12564092x0116xce84xf62dx000055b50d0421.g0(Unknown Source)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.ReflectMethod.invoke(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.CallStatementResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.StatementTriggerExecutor.fireTrigger(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate$2.doInPreparedStatement(JdbcTemplate.java:745)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:538)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:739)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:797)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:801)&lt;br/&gt;
        at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:218)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.importFromLegacyTables(DbOOOFactory.java:383)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.access$1500(DbOOOFactory.java:94)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO$2.doInTransactionWithoutResult(DbOOOFactory.java:352)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionCallbackWithoutResult.doInTransaction(TransactionCallbackWithoutResult.java:33)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:134)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.add(DbOOOFactory.java:339)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.reload(MetaJJJ.java:44)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.startup(MetaJJJ.java:57)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startupZzz(Start.java:208)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startup(Start.java:160)&lt;br/&gt;
        at com.xxx.start.Starter.startup(Starter.java:264)&lt;br/&gt;
        at com.xxx.start.Main.startup(Main.java:270)&lt;br/&gt;
        at com.xxx.start.Main.main(Main.java:199)&lt;br/&gt;
Caused by: ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        ... 44 more&lt;br/&gt;
============= end nested exception, level (2) ===========&lt;br/&gt;
============= begin nested exception, level (3) ===========&lt;br/&gt;
ERROR XSAI2: The conglomerate (-15) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.openScan(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet.getNextRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:79)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:43)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.Template.getResult(Template.java:80)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT.insert(SubTTT.java:107)&lt;br/&gt;
        at org.apache.derby.exe.ac12564092x0116xce84xf62dx000055b50d0421.g0(Unknown Source)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
        at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.ReflectMethod.invoke(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.CallStatementResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.StatementTriggerExecutor.fireTrigger(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at org.apache.commons.dbcp.DelegatingPreparedStatement.executeUpdate(DelegatingPreparedStatement.java:101)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate$2.doInPreparedStatement(JdbcTemplate.java:745)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:538)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:739)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:797)&lt;br/&gt;
        at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:801)&lt;br/&gt;
        at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:218)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.importFromLegacyTables(DbOOOFactory.java:383)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.access$1500(DbOOOFactory.java:94)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO$2.doInTransactionWithoutResult(DbOOOFactory.java:352)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionCallbackWithoutResult.doInTransaction(TransactionCallbackWithoutResult.java:33)&lt;br/&gt;
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:134)&lt;br/&gt;
        at com.xxx.yyy.DbOOOFactory$DBOOO.add(DbOOOFactory.java:339)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.reload(MetaJJJ.java:44)&lt;br/&gt;
        at com.xxx.zzz.kkk.MetaJJJ.startup(MetaJJJ.java:57)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startupZzz(Start.java:208)&lt;br/&gt;
        at com.xxx.zzz.kkk.Start.startup(Start.java:160)&lt;br/&gt;
        at com.xxx.start.Starter.startup(Starter.java:264)&lt;br/&gt;
        at com.xxx.start.Main.startup(Main.java:270)&lt;br/&gt;
        at com.xxx.start.Main.main(Main.java:199)&lt;br/&gt;
============= end nested exception, level (3) ===========&lt;br/&gt;
Cleanup action completed&lt;br/&gt;
2007-12-12 13:22:40.524 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DATABASE = directory:shape), (DRDAID = null), Rolling back&lt;br/&gt;
2007-12-12 13:22:40.885 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Main,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DRDAID = null), Committing&lt;br/&gt;
2007-12-12 13:22:40.893 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;xxx-start ShutdownHook,5,main&amp;#93;&lt;/span&gt; (XID = 1452), (SESSIONID = 2), (DATABASE = directory:shape), (DATABASE = directory:shape), (DRDAID = null), Rolling back&lt;/p&gt;

&lt;p&gt;2007-12-12 13:22:43.104 GMT:&lt;br/&gt;
Shutting down instance c013800d-0116-ce84-f62d-000055b50d04&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;(note2self: I have a patch against r192 that reproduces this, and a full copy of the derby.log)&lt;/p&gt;</comment>
                            <comment id="12551077" author="mikem" created="Wed, 12 Dec 2007 19:03:13 +0000"  >&lt;p&gt;What is the last error, if any in derby.log which precedes the error you posted.&lt;/p&gt;

&lt;p&gt;Also I see that this is session 2.  Is your app multi-threaded?  Is it using multiple connections?  &lt;/p&gt;</comment>
                            <comment id="12551079" author="mikem" created="Wed, 12 Dec 2007 19:04:57 +0000"  >&lt;p&gt;in the case where you can reproduce this.  Is it always the same statement at the same point in the app that fails?  Is the error always exactly the same (ie. is the conglomerate number always -15)?&lt;/p&gt;</comment>
                            <comment id="12551086" author="mikem" created="Wed, 12 Dec 2007 19:15:31 +0000"  >&lt;p&gt;looking at your recent posting I think the error is actually while executing code as part of a trigger.  &lt;br/&gt;
Unfortunately I don&apos;t think are error logging handles this nesting of execution very well.  The error is happening&lt;br/&gt;
as part of executing code as part of a trigger - but I don&apos;t think we are logging the query in the trigger that is &lt;br/&gt;
causing the problem.&lt;/p&gt;

&lt;p&gt;Would it be possible to post the query that is executing in your java code.  :&lt;br/&gt;
    at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:79)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT$1.work(SubTTT.java:43)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.Template.getResult(Template.java:80)&lt;br/&gt;
        at com.xxx.zzz.kkk.sp.SubTTT.insert(SubTTT.java:107) &lt;/p&gt;

&lt;p&gt;Is it possible that code has changed somewhat and that could be what affects whether the bug reproduces or not?&lt;/p&gt;</comment>
                            <comment id="12551117" author="northshorefiend" created="Wed, 12 Dec 2007 21:35:46 +0000"  >&lt;p&gt;Yes it&apos;s pretty deep in a trigger.&lt;/p&gt;

&lt;p&gt;I think the statement that kicks everything off, that you request is&lt;/p&gt;

&lt;p&gt;INSERT INTO SubTTT ( nShapeID , nSubShapeID , nColorID ) SELECT DISTINCT C.nRCID , S.nRCID , (S&lt;br/&gt;
ELECT nColorID FROM Colorition WHERE nIsCCC = 1) FROM LegacySubCCC SC JOIN LegacyCCC C ON SC.nRunID = ? AND C.nRunID = ? AND C.nICCCID = SC.nICCCID JOIN LegacyCCC S ON S.nRunID = ? AND S.nICCCID = SC.nISubCCCID LEF&lt;br/&gt;
T JOIN SubTTT SO ON SO.nShapeID = C.nRCID AND SO.nSubShapeID = S.nRCID WHERE SO.nShapeID IS NULL&lt;/p&gt;

&lt;p&gt;which is logged up there somewhere.&lt;/p&gt;

&lt;p&gt;There are no errors before what I have posted, but the execution of the above statement is several pages back in the log.&lt;/p&gt;

&lt;p&gt;As you say, changing the code a bit stops the bug. Interestingly, if I select out of a different Legacy* table then I don&apos;t get the bug.&lt;/p&gt;

&lt;p&gt;Even more interestingly, if I shove the data in a Temporary table, then select out of that, I get the bug still! And the conglomerate number changes.&lt;/p&gt;

&lt;p&gt;Absolutely 100% the same each time I run the whole shebang.&lt;/p&gt;

&lt;p&gt;Not really multi-threaded, there is an ij session on stdout/in so that I can take a peek in the embedded database while debugging. However, I don&apos;t think this  connects before the bug bites. The java app does try to connect to an existing database, and if this fails, connect again with ;create=true, and runs the create script. Actually, initially, there may be another connection opened adn closed that just finds out what version of derby is running etc, but this closes straight after having a look around.&lt;/p&gt;

&lt;p&gt;I&apos;m just trying to run with fewer rows in the table that gets selected from, for the hell of it, as the bug arises with the largest row count Legacy table.&lt;br/&gt;
Initial results seem to show that fewer rows (we&apos;re only talking 4 being few, 100 being many) doesn&apos;t trigger the bug. I&apos;m gonna check that this still exercises the same code path.&lt;/p&gt;</comment>
                            <comment id="12551161" author="northshorefiend" created="Wed, 12 Dec 2007 23:50:45 +0000"  >&lt;p&gt;I can narrow it down to the inclusion of five rows in the selected set - these rows don&apos;t seem to cause any different logic to be followed, but they possibly cause a loop that executes SQL in the proc to be run a few extra times.&lt;/p&gt;

&lt;p&gt;For now, I&apos;m going back to 10.2.2.0. Everything works there.&lt;/p&gt;

&lt;p&gt;May be in the future a stupid mistake in the script will show itself.&lt;/p&gt;

&lt;p&gt;Last thought: would a shorter transaction make such a conglomerate error less likely? Though from a business logic point of view this isn&apos;t an option.&lt;/p&gt;</comment>
                            <comment id="12551165" author="army" created="Thu, 13 Dec 2007 00:11:12 +0000"  >&lt;p&gt;&amp;gt; I can narrow it down to the inclusion of five rows in the selected set - these rows don&apos;t seem to&lt;br/&gt;
&amp;gt; cause any different logic to be followed&lt;/p&gt;

&lt;p&gt;I haven&apos;t been following this very closely, but the fact that 5 rows is the magic number and that Mike mentioned temporary files made me think of impl/sql/execute/TemporaryRowHolderImpl.java, where we have:&lt;/p&gt;

&lt;p&gt;public static final int DEFAULT_OVERFLOWTHRESHOLD = 5;&lt;/p&gt;

&lt;p&gt;Examination of the code shows that this will be the size of &quot;rowArray&quot; for the TemporaryRowHolder, and once we reach 5 rows we&apos;ll create a temporary conglomerate to store the extra rows.  I can&apos;t be certain, but I &lt;b&gt;think&lt;/b&gt; that one of the ways in which we use TemporaryRowHolders is when we update a unique index column, in which case we put the new row into a temporary row holder, delete the old row, then insert from the temporary row holder.  This indirection allows correct processing of scenarios when the new (updated) value of one row matches the old value of another row (by deleting the old row first and &lt;b&gt;then&lt;/b&gt; inserting new row, we avoid throwing a duplicate key violation).&lt;/p&gt;

&lt;p&gt;Maybe that&apos;s related, maybe not.  Just thought I&apos;d mention it since I saw the number 5...&lt;/p&gt;
</comment>
                            <comment id="12551168" author="army" created="Thu, 13 Dec 2007 00:20:53 +0000"  >&lt;p&gt;Ah, never mind, I see Mike already covered what I just wrote:&lt;/p&gt;

&lt;p&gt;  &quot;...looks like we are somehow losing the temporary file associated with a deferred update&quot;&lt;/p&gt;

&lt;p&gt;Sorry for the noise (oops).&lt;/p&gt;</comment>
                            <comment id="12551496" author="northshorefiend" created="Thu, 13 Dec 2007 12:50:54 +0000"  >&lt;p&gt;ooh, 10.3.2.1 is out:&lt;/p&gt;

&lt;p&gt;Bug still present &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12551931" author="northshorefiend" created="Fri, 14 Dec 2007 20:23:27 +0000"  >&lt;p&gt;I&apos;m going in....&lt;/p&gt;

&lt;p&gt;rolling my own 10.3.2.1...&lt;/p&gt;

&lt;p&gt;Opening impl/sql/execute/TemporaryRowHolderImpl.java....&lt;/p&gt;

&lt;p&gt;public static final int DEFAULT_OVERFLOWTHRESHOLD = 100; &lt;/p&gt;

&lt;p&gt;squashes the bug - well, probably just chases it into the undergrowth.&lt;/p&gt;




&lt;p&gt;I&apos;ll probably fiddle the test data that&apos;s used on Monday to avoid the bug &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;


</comment>
                            <comment id="12552433" author="northshorefiend" created="Mon, 17 Dec 2007 15:09:04 +0000"  >&lt;p&gt;Tried with different test data and still hit the bug, so here&apos;s a test case.&lt;/p&gt;

&lt;p&gt;Includes a stored proc, create script, data, etc.&lt;/p&gt;

&lt;p&gt;With derby on the CLASSPATH should reproduce just fine with 10.3.2.1 and not fail with 10.2.2.0&lt;/p&gt;

&lt;p&gt;I have reduced things as far as I could. Don&apos;t even have constraints now. Only 3 tables with 2 cols each.&lt;/p&gt;

&lt;p&gt;It seems the &apos;insert.first&apos; query in SubShape.properties is necessary to reproduce the bug, so may be it has something to do with updating a table you have already updated in the same tran?&lt;/p&gt;

&lt;p&gt;And it seems to be when the sp is called for the second time? but I&apos;m pretty sure there is no recursion problem there. Anyhoo, it works fine on 10.2.2.0, so I don&apos;t &lt;b&gt;think&lt;/b&gt; the trigger/sp is doing anything too strange.&lt;/p&gt;</comment>
                            <comment id="12554994" author="northshorefiend" created="Sun, 30 Dec 2007 11:44:29 +0000"  >&lt;p&gt;If I don&apos;t reuse the prepared statement, then the bug is avoided.&lt;/p&gt;

&lt;p&gt;SubShape.java:&lt;/p&gt;

&lt;p&gt;					for (long i = r.getLong(1); i &amp;gt;= 0; i--) {&lt;br/&gt;
						if (conn.prepareStatement(sql&lt;br/&gt;
								.getProperty(&quot;insert.test&quot;)).executeUpdate() &amp;lt; 1)&lt;br/&gt;
							break;&lt;/p&gt;

&lt;p&gt;So, I guess this bug is caused by something not being cleared when reusing the PreparedStatement.&lt;/p&gt;

&lt;p&gt;A work around is basically to not use the PreparedStatement again, which obviously defeats the purpose &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12555324" author="knutanders" created="Wed, 2 Jan 2008 15:13:49 +0000"  >&lt;p&gt;When I run the test case with a sane build (trunk), I get an assert failure:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; INSERT INTO SubShape (nID, nSubID) SELECT nID, nSubID FROM Test;&lt;br/&gt;
java.sql.SQLException: Java exception: &apos;ASSERT FAILED col1.getClass() (class org.apache.derby.iapi.types.SQLInteger) expected to be the same as col2.getClass() (class org.apache.derby.iapi.types.SQLLongint): org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:88)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:245)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:1666)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1324)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1650)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(EmbedPreparedStatement.java:299)&lt;br/&gt;
	at SubShape.insert(SubShape.java:37)&lt;br/&gt;
	at org.apache.derby.exe.ac12564092x0117x3b06x55cfx0000003a57281.g0(Unknown Source)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.ReflectMethod.invoke(ReflectMethod.java:46)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.CallStatementResultSet.open(CallStatementResultSet.java:74)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(GenericTriggerExecutor.java:159)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.StatementTriggerExecutor.fireTrigger(StatementTriggerExecutor.java:80)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(TriggerEventActivator.java:269)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(InsertResultSet.java:1150)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:487)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1234)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:624)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:556)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:330)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:508)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:350)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Main.java:215)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:181)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.main(Main.java:73)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(ij.java:59)&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;ASSERT FAILED col1.getClass() (class org.apache.derby.iapi.types.SQLInteger) expected to be the same as col2.getClass() (class org.apache.derby.iapi.types.SQLLongint): org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:135)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	... 35 more&lt;br/&gt;
Caused by: org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED col1.getClass() (class org.apache.derby.iapi.types.SQLInteger) expected to be the same as col2.getClass() (class org.apache.derby.iapi.types.SQLLongint)&lt;br/&gt;
	at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:162)&lt;br/&gt;
	at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:147)&lt;br/&gt;
	at org.apache.derby.impl.store.access.sort.MergeSort.checkColumnTypes(MergeSort.java:472)&lt;br/&gt;
	at org.apache.derby.impl.store.access.sort.MergeInserter.insert(MergeInserter.java:98)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.loadSorter(SortResultSet.java:317)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.openCore(SortResultSet.java:268)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.openCore(NormalizeResultSet.java:147)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:407)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1234)&lt;br/&gt;
	... 28 more&lt;br/&gt;
ERROR XJ001: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;/p&gt;</comment>
                            <comment id="12555896" author="dyret" created="Fri, 4 Jan 2008 11:28:48 +0000"  >&lt;p&gt;Could this be another followup error from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt;? Seems like the problem COULD be that SortResultSet.sortTemplateRow is not reset/recomputed when SortResultSet is closed (nothing is done to it in SortResultSet.close()). It seems like the sanity check which compares sortTemplateRow to the row being fed to the sorter fails, which I guess could happen if the template left over from the previous execution doesn&apos;t match the new one.&lt;/p&gt;

&lt;p&gt;I&apos;ll try out the repro and see if the theory holds.&lt;/p&gt;</comment>
                            <comment id="12555945" author="dyret" created="Fri, 4 Jan 2008 15:38:37 +0000"  >&lt;p&gt;My theory does NOT hold &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; The failure still happens when sortTemplateRow is re-initialized in each call to openCore. Could this be a conversion thing? That is; should it be possible to promote an SQLInteger to an SQLLongint? If I read the code correctly, it seems like col2 is the sort template (SQLLongint) and col1 is from the current row. Also, where does the last NPE come from? Is that just a consequence, or is it significant? &lt;/p&gt;</comment>
                            <comment id="12555967" author="dyret" created="Fri, 4 Jan 2008 16:18:50 +0000"  >&lt;p&gt;Looking more closely at the repro, I see that all columns are of type BIGINT. So it seems reasonable that the sort template has type SQLLongint, but why is it given a row where the 3rd (the failure is is reported for the third (colid=2) column) column has type SQLInteger?&lt;/p&gt;</comment>
                            <comment id="12555977" author="bryanpendleton" created="Fri, 4 Jan 2008 16:43:15 +0000"  >&lt;p&gt;Hi Dyre, thanks for looking at this! You might find it useful to capture the generated&lt;br/&gt;
code and decompile it, then look at that together with a close look at the query plan.&lt;br/&gt;
Presumably the sort is due to a GROUP BY or ORDER BY clause in the query, or&lt;br/&gt;
perhaps due to a DISTINCT? When I was looking at some datatype mismatch&lt;br/&gt;
problems in ORDER BY processing (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2352&quot; title=&quot;Assertion Failure with order by and group by expression&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2352&quot;&gt;&lt;del&gt;DERBY-2352&lt;/del&gt;&lt;/a&gt;), I saw that the code generation&lt;br/&gt;
logic for these areas involves objects like the ResultColumn and the OrderByList.&lt;br/&gt;
Hopefully this is helpful, let me know and I can try to offer some more ideas.&lt;/p&gt;</comment>
                            <comment id="12556519" author="knutanders" created="Mon, 7 Jan 2008 09:20:04 +0000"  >&lt;p&gt;Dyre, I think you are right that this is a regression caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt;. I&apos;m not able to reproduce the error on revision 540920, but it is reproducible on revision 540921, which introduced the reuse of result sets.&lt;/p&gt;</comment>
                            <comment id="12556565" author="dyret" created="Mon, 7 Jan 2008 13:49:47 +0000"  >&lt;p&gt;Thanks for your feedback, Bryan and Knut. So it is indeed a consequence of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Hmm, the strange part is that according to the call stack posted by Knut the error happens at SubShape.insert(SubShape.java:37):&lt;/p&gt;

&lt;p&gt;                                 // if nothing is new, then nothing to do&lt;br/&gt;
                                if (ps.executeUpdate() &amp;gt; 0) {&lt;/p&gt;

&lt;p&gt;                                        // do pre stuff&lt;br/&gt;
                                        for (String stmt : sql.getProperty(&quot;pre&quot;&lt;br/&gt;
).split(&quot;;&quot;)) &lt;/p&gt;
{
                                                ps = conn.prepareStatement(stmt)
;
                                                ps.executeUpdate();  // &amp;lt;--- line 37
                                        }

&lt;p&gt;So this particular statement is AFAICT never re-executed. So, in theory, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt; should not make a dfference here, and if I read James&apos; comment correctly, it is the prepared statement being re-executed at line 57 that seems to be the culprit. Meaning that preparing it prior to each execute removes the symptom...&lt;/p&gt;

&lt;p&gt;So we have to assume then, that some cruft left in the internal result set tree of this prepared statement SOMEHOW causes the newly prepared statement at line 37 to fail. Right now, I cannot imagine how that could happen... &lt;/p&gt;</comment>
                            <comment id="12556605" author="dyret" created="Mon, 7 Jan 2008 16:03:41 +0000"  >&lt;p&gt;The ASSERT reported in a debug build is really a red herring and&lt;br/&gt;
not related to the original problem. I think the ASSERT simply is&lt;br/&gt;
too strict as it does not allow what would be legal&lt;br/&gt;
conversion. Simply modifying the queries so that they explicitly&lt;br/&gt;
CAST all INTEGER values to BIGINT seems to remove that&lt;br/&gt;
problem (see attached modified_SubShape.properties), and exposes the&lt;br/&gt;
original problem with the missing temporary conglomerate. And&lt;br/&gt;
that problem is only reported by the prepared statement that is&lt;br/&gt;
actually re-executed, so that fits nicely with the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
hypothesis.&lt;/p&gt;

&lt;p&gt;The new call-stack from the line 57 (insert.test) statement shows&lt;br/&gt;
that the missing conglomerate error comes from (re-)using&lt;br/&gt;
InsertResultSet.rowHolder. At first I thought the problem was&lt;br/&gt;
that close() isn&apos;t called on this object in&lt;br/&gt;
InsertResultSet.close(), but then I noticed that&lt;br/&gt;
normalInsertCore() calls close() on it:&lt;/p&gt;

&lt;p&gt;		if (rowHolder != null)&lt;/p&gt;
		{
			rowHolder.close();
			// rowHolder kept across opens
		} 

&lt;p&gt;The comment doesn&apos;t really make sense since rowHolder, in fact,&lt;br/&gt;
is closed. Anyway, the real problem is that code in the beginning&lt;br/&gt;
of normalInsertCore() assumes that the comment is true, and only&lt;br/&gt;
initializes rowHolder on the first execute:&lt;/p&gt;

&lt;p&gt;		if (firstExecute &amp;amp;&amp;amp; constants.deferred)&lt;/p&gt;
		{
			Properties properties = new Properties();

			// Get the properties on the old heap
			rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);

			/*
			** If deferred we save a copy of the entire row.
			*/
			rowHolder = new TemporaryRowHolderImpl(activation, properties);
			rowChanger.setRowHolder(rowHolder);
		}

&lt;p&gt;Simply commenting out firstExecute in the if-test (see attached&lt;br/&gt;
derby-3221.prelim.diff) makes the repro run without problems. I&lt;br/&gt;
have not run any other tests with this change, nor do I know if&lt;br/&gt;
this is the right approach. But at least it points to what causes&lt;br/&gt;
the problem, and explains why it was introduced by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12556852" author="dyret" created="Tue, 8 Jan 2008 09:23:27 +0000"  >&lt;p&gt;Minor update: Knut suggested that I could try to comment out the call to rowHolder.close() rather than the firstExecute test to make the code match the comment. Unfortunately, when I tried it, I got the missing conglomerate error again, so it seems that keeping the rowHolder open is not enough to prevent the temp conglomerate from disappearing.&lt;/p&gt;</comment>
                            <comment id="12557261" author="dyret" created="Wed, 9 Jan 2008 13:24:29 +0000"  >&lt;p&gt;I did some more digging, and I now think I know how it should be fixed, (creating a new TemporaryRowHolderImpl object in each execution works, but is overkill). I noticed that the problem did not occur EVERY time a prepared statement was re-executed. Sometimes it would not fail until the 9th execution. &lt;/p&gt;

&lt;p&gt;It turns out that the problem was a lack of communication between TemporaryRowHolderImpl and  TemporaryRowHolderResultSet. When rows are inserted into the RowHolder it will fill as many rows as it can into its internal rowArray, before creating, and &quot;spilling over&quot; into a temporary conglomerate. &lt;/p&gt;

&lt;p&gt;The RowHolderResultSet  is used to read the rows back out, so it starts by returning the rows from the rowArray, and then proceeds with rows from the temporary conglomerate. Unfortunately, the RowHolder doesn&apos;t provide a proper API for checking if a temporary conglomerate has actually been created. To get around this RowHolderResultSet checks if  RowHolder.CID (the conglomerate id of the temporary conglomerate) is 0. If it is, RowHolderResultSet assumes that no temporary conglomerate has been created.&lt;/p&gt;

&lt;p&gt;This scheme worked well when internal result sets were not reused because then each execution started with a newly created RowHolder which had its CID member initialized to 0. But when results sets are reused this fact cannot be relied upon since CID it NOT set back to 0 by RowHolder.close(). &lt;/p&gt;

&lt;p&gt;So the error will ONLY surface when a prepared statement has caused the rowHolder to spill into a temporary conglomerate (thereby assigning a value != 0 to CID), and some subsequent execution does NOT spill over. Then when the latter execution tries to read from the RowHolderResultSet it will incorrectly look for a temporary conglomerate that was never created in the insert-phase.&lt;/p&gt;

&lt;p&gt;I&apos;m currently running tests on a patch that provides an api for testing if the conglomerate has been created (and also sets CID to 0 in close()). I plan to upload it if the tests pass.&lt;/p&gt;

&lt;p&gt;(There should probably be a regression test for this, but James&apos; repro does not have ASF license so I guess we can&apos;t just convert that to JUnit).&lt;/p&gt;</comment>
                            <comment id="12557269" author="dyret" created="Wed, 9 Jan 2008 13:40:13 +0000"  >&lt;p&gt;All tests pass (except jdbc4/ResultSetTest as reported in the Tinderbox test).&lt;/p&gt;</comment>
                            <comment id="12557287" author="knutanders" created="Wed, 9 Jan 2008 14:53:11 +0000"  >&lt;p&gt;I think the fix looks good, but I&apos;m not completely convinced that (holder.CID == 0) is equivalent to (!holder.isConglomCreated()). In TemporaryRowHolderImpl.truncate(), conglomCreated is set to false, but CID is left untouched, so they may get out of sync. (But since truncate() first calls close(), which will drop the conglomerate, I don&apos;t think that this code will ever be executed. Perhaps it&apos;s better to remove it?) Similarly, TemporaryRowHolderResultSet.reStartScan() sets CID and leaves conglomCreated untouched. Do you think this can cause any problems?&lt;/p&gt;</comment>
                            <comment id="12557291" author="dyret" created="Wed, 9 Jan 2008 15:22:27 +0000"  >&lt;p&gt;Sigh... you are probably right. I guess that the safest thing to do is to stick with the CID==0 test, and set it to 0 whenever the temporary conglomerate is removed. But I think that a more explicit and intuitive predicate would have made the code easier to read. Come to think of it, I really loathe such &quot;cooperating classes&quot; where correct behavior depends on a shared state that&apos;s manipulated by both... but in this case I guess a smaller, less intrusive, change is preferable.&lt;/p&gt;

&lt;p&gt;Wrt. reStartScan(): I would assume that when you restart a scan must already have a CID from when the scan was first started (and so presumably conglomCreated is true), but I have not verified this, so yes it might be a problem.&lt;/p&gt;</comment>
                            <comment id="12557355" author="bryanpendleton" created="Wed, 9 Jan 2008 17:45:13 +0000"  >&lt;p&gt;&amp;gt; I really loathe such &quot;cooperating classes&quot; where correct behavior depends &lt;br/&gt;
&amp;gt; on a shared state that&apos;s manipulated by both&lt;/p&gt;

&lt;p&gt;I think you are right to criticize this implementation. Perhaps a reasonable&lt;br/&gt;
approach is to first make and verify the small fix, then later, separately,&lt;br/&gt;
re-design this interaction as you suggest, with an explicit API for tracking&lt;br/&gt;
whether or not the temporary row holder overflowed to an explicit conglomerate or not.&lt;/p&gt;</comment>
                            <comment id="12557979" author="northshorefiend" created="Fri, 11 Jan 2008 13:10:29 +0000"  >&lt;p&gt;FYI: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-39&quot; title=&quot;Strange error in JOIN ON clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-39&quot;&gt;&lt;del&gt;DERBY-39&lt;/del&gt;&lt;/a&gt; may be connected?&lt;/p&gt;

&lt;p&gt;I can&apos;t see how, but I can use almost the same test case as above to reproduce &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-39&quot; title=&quot;Strange error in JOIN ON clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-39&quot;&gt;&lt;del&gt;DERBY-39&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12558015" author="dyret" created="Fri, 11 Jan 2008 16:10:11 +0000"  >&lt;p&gt;Thanks James,&lt;br/&gt;
I took your &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-39&quot; title=&quot;Strange error in JOIN ON clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-39&quot;&gt;&lt;del&gt;DERBY-39&lt;/del&gt;&lt;/a&gt; repro for a spin, but unfortunately I keep hitting &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3310&quot; title=&quot;ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3310&quot;&gt;&lt;del&gt;DERBY-3310&lt;/del&gt;&lt;/a&gt; and this time I don&apos;t seem to be able to work around it with a cast, so I need to manually disable the ASSERT, I think.&lt;/p&gt;

&lt;p&gt;I&apos;m currently running tests for a new version of my patch, where I&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;revert back to testing the presence of a temp conglom with CID==0&lt;/li&gt;
	&lt;li&gt;make CID private&lt;/li&gt;
	&lt;li&gt;make clients (TemporaryRowHolderResultSet) use the existing accessor (getTemporaryConglomId())&lt;/li&gt;
	&lt;li&gt;always set CID to 0, when conglomCreated is set to false and the conglomerate is removed&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Right now I&apos;m providing a mutator for CID that reStartScan can use, but I cannot see what purpose this really serves. Changing the CID behind the owning class&apos; back like that seems like it has the potential to introduce both leaks and inconsistencies. I&apos;m trying to flag any situation where a conglomerate could be leaked, or the holder left in an inconsistent state, and see if this actually happens in the tests. &lt;/p&gt;</comment>
                            <comment id="12558609" author="dyret" created="Mon, 14 Jan 2008 14:10:57 +0000"  >&lt;p&gt;I looked into the use of&lt;br/&gt;
TemporaryRowHolderResultSet.reStartScan(long, long) some more, and&lt;br/&gt;
it turns out that it is only used a couple of places in&lt;br/&gt;
DependentResultSet. In all of those cases the two arguments are&lt;br/&gt;
obtained from the very same TemporaryRowHolderImpl object&lt;br/&gt;
which this TemporaryRowHolderResultSet refers to. So those&lt;br/&gt;
parameters are unnecessary, and the temporary conglomerate id is&lt;br/&gt;
never actually modified by reStartScan().&lt;/p&gt;

&lt;p&gt;I&apos;m currently testing a new patch which does include a mutator for the CID&lt;br/&gt;
variable, but which also has an ASSERT which verifies that the&lt;br/&gt;
new and old values are identical.&lt;/p&gt;

&lt;p&gt;As suggested by Bryan, I defer a more thorough cleanup to a later patch.&lt;/p&gt;</comment>
                            <comment id="12558663" author="dyret" created="Mon, 14 Jan 2008 16:41:52 +0000"  >&lt;p&gt;New patch (v2) (described in previous comments).&lt;/p&gt;</comment>
                            <comment id="12559410" author="knutanders" created="Wed, 16 Jan 2008 09:31:30 +0000"  >&lt;p&gt;Patch v2 looks good. Adding a getter and a setter for CID and making it private was a good move. +1 to commit.&lt;/p&gt;

&lt;p&gt;Two small issues that you may want to address:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The patch adds some whitespace in TemporaryRowHolderImpl.java right above makeIndexProperties()&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It looks a bit odd to have an assert inside the mutator to ensure that it doesn&apos;t mutate the field. It also makes the method useless for others who may have a perfectly legitimate reason to mutate the field. Perhaps it&apos;s better to move the assert to the caller, since that&apos;s the context where the assert is meaningful.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12559977" author="dyret" created="Thu, 17 Jan 2008 16:22:42 +0000"  >&lt;p&gt;Attaching v3 to address Knut&apos;s latest comments. I was about to say that he just has to live with the white space diff since that&apos;s what Netbeans does, but then I softened up and edited the file in emacs... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12560319" author="dyret" created="Fri, 18 Jan 2008 09:54:57 +0000"  >&lt;p&gt;Committed revision 613116.&lt;/p&gt;</comment>
                            <comment id="12562122" author="kmarsden" created="Thu, 24 Jan 2008 16:28:09 +0000"  >&lt;p&gt;Would it make sense to port this to 10.3?&lt;/p&gt;</comment>
                            <comment id="12562138" author="dyret" created="Thu, 24 Jan 2008 17:30:27 +0000"  >&lt;p&gt;I would think so. I can try to do that tomorrow. I probably need to practice my merging skills...  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12562585" author="dyret" created="Fri, 25 Jan 2008 17:16:28 +0000"  >&lt;p&gt;Merged to 10.3 with revision 615273&lt;/p&gt;</comment>
                            <comment id="12562614" author="hallorant" created="Fri, 25 Jan 2008 18:30:38 +0000"  >&lt;p&gt;Any idea when 10.3.2.2 will be released?  I couldn&apos;t find a download for it yet on the site.  Best regards&lt;/p&gt;</comment>
                            <comment id="12562850" author="dyret" created="Sat, 26 Jan 2008 12:32:11 +0000"  >&lt;p&gt;Hi Tim, &lt;/p&gt;

&lt;p&gt;my understanding is that there are no specific plans to make another 10.3 release, (such a release would be numbered 10.3.3.x for some x which depends on the number of release candidates needed). Check out Kathey Marsden&apos;s reply to my related question about this on derby-dev:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nabble.com/Confused-about-merging-and-fix-versions-to15092390.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Confused-about-merging-and-fix-versions-to15092390.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As the release manager for 10.4 (which definitely will have this fix) I guess it is my job to convince you to switch to that &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Anyway, you can read about it here (please note that as this is open-source the dates on this page are goals, not definite promises):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.apache.org/db-derby/DerbyTenFourRelease&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/DerbyTenFourRelease&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12563232" author="army" created="Mon, 28 Jan 2008 18:29:02 +0000"  >&lt;p&gt;dyre&amp;gt; my understanding is that there are no specific plans to make another 10.3 release&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth, I think that in &lt;b&gt;theory&lt;/b&gt; it should be safe to use a &quot;personal&quot; build off the 10.3 branch in a production environment.  At least, that is one of the goals of a stable branch, so far as I understand it.  Note the following line from the Apache Derby home page:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://db.apache.org/derby/dev/derby_source.html#Branches&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/dev/derby_source.html#Branches&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  &quot;Production use of Derby should use official Derby releases or snapshot builds off&lt;br/&gt;
    the branches (or self built jars off the branches with bug fixes).&quot;&lt;/p&gt;

&lt;p&gt;The parenthetical at the end is what I&apos;m referring to.  So Tim, you could in theory build your own jars off the 10.3 branch and use that in production, if waiting for 10.4 is not an option...&lt;/p&gt;

&lt;p&gt;Unless of course the above-quoted page is wrong, in which case I hope someone a) corrects me rather quickly, and b) updates the page accordingly...&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12385890">DERBY-3310</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12327853">DERBY-827</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12372633" name="SubShape.properties" size="2762" author="dyret" created="Mon, 7 Jan 2008 16:03:41 +0000"/>
                            <attachment id="12371803" name="conlomerate.tar.gz" size="8235" author="northshorefiend" created="Mon, 17 Dec 2007 15:09:04 +0000"/>
                            <attachment id="12372634" name="derby-3221.prelim.diff" size="493" author="dyret" created="Mon, 7 Jan 2008 16:03:41 +0000"/>
                            <attachment id="12372798" name="derby-3221.v1.diff" size="1785" author="dyret" created="Wed, 9 Jan 2008 13:40:12 +0000"/>
                            <attachment id="12373101" name="derby-3221.v2.diff" size="5420" author="dyret" created="Mon, 14 Jan 2008 16:41:51 +0000"/>
                            <attachment id="12373408" name="derby-3221.v3.diff" size="4672" author="dyret" created="Thu, 17 Jan 2008 16:22:41 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 24 Nov 2007 18:57:10 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23502</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0lw7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37365</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>