<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:22:15 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1007/DERBY-1007.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1007] Optimizer can return incorrect &quot;best cost&quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1007</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When optimizing a query that has nested subqueries in it, it&apos;s possible that the optimizer for the subqueries will return cost estimates that are lower than what they were actually calculated to be.  The result is that the outer query can pick an access plan that is sub-optimal.&lt;/p&gt;

&lt;p&gt;Filing this jira issue based on the thread &quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;OPTIMIZER&amp;#93;&lt;/span&gt; OptimizerImpl &quot;best plans&quot; for subqueries?&quot; from derby-dev.  Description that follows is pasted from that email:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/14836&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/14836&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Following example of what I saw when tracing through the code demonstrates the problem.&lt;/p&gt;

&lt;p&gt;select x1.j, x2.b from&lt;br/&gt;
  (select distinct i,j from t1) x1,&lt;br/&gt;
  (select distinct a,b from t3) x2&lt;br/&gt;
where x1.i = x2.a;&lt;/p&gt;

&lt;p&gt;During optimization of this query we will create three instancesof OptimizerImpl:&lt;/p&gt;

&lt;p&gt;   OI_0: For &quot;select x1.j, x2.b from x1, x2 where x1.i = x2.a&quot;&lt;br/&gt;
   OI_1: For &quot;select distinct i,j from t1&quot;&lt;br/&gt;
   OI_2: For &quot;select distinct a,b from t3&quot;&lt;/p&gt;

&lt;p&gt;Query ran against a clean codeline when T1 had 1 row and T3 had 50,000.&lt;/p&gt;

&lt;p&gt;   &amp;#8211; Top-level call is made to the optimize() method of the&lt;br/&gt;
     outermost SelectNode, which creates OI_0.&lt;/p&gt;

&lt;p&gt;   &amp;#8211; OI_0: picks join order &lt;/p&gt;
{X1, X2}
&lt;p&gt; and calls X1.optimizeIt()&lt;br/&gt;
   &amp;#8211; X1: &lt;b&gt;creates&lt;/b&gt; OI_1 and makes calls to optimize it.&lt;br/&gt;
   &amp;#8211; OI_1: picks join order &lt;/p&gt;
{T1} and calls T1.optimizeIt()&lt;br/&gt;
   &amp;#8211; T1: returns a cost of 20.&lt;br/&gt;
   &amp;#8211; OI_1: saves 20 as new best cost and tells T1 to save it.&lt;br/&gt;
   &amp;#8211; X1: calls OI_1.getOptimizedCost(), which returns 20.  X1&lt;br/&gt;
     then returns 20 to OI_0.&lt;br/&gt;
   &amp;#8211; OI_0: calls X2.optimizeIt()&lt;br/&gt;
   &amp;#8211; X2: &lt;b&gt;creates&lt;/b&gt; OI_2 and makes calls to optimize it.&lt;br/&gt;
   &amp;#8211; OI_2: picks join order {T3} and calls T3.optimizeIt()&lt;br/&gt;
   &amp;#8211; T3: returns a cost of 64700.&lt;br/&gt;
   &amp;#8211; OI_2: saves 64700 as new best cost and tells T3 to save it.&lt;br/&gt;
   &amp;#8211; X2: calls OI_2.getOptimizedCost(), which returns 64700. X2&lt;br/&gt;
     then returns 64700 to OI_0.&lt;br/&gt;
   &amp;#8211; OI_0: saves 20 + 64700 = 64720 as new best cost and tells&lt;br/&gt;
     X1 to save 20 and X2 to save 64700.&lt;br/&gt;
&lt;br/&gt;
   &amp;#8211; OI_0: picks join order {X2, X1} and calls X2.optimizeIt()&lt;br/&gt;
   &amp;#8211; X2: &lt;b&gt;fetches&lt;/b&gt; OI_2 and makes calls to optimize it.&lt;br/&gt;
   &amp;#8211; OI_2: picks join order {T3} and calls T3.optimizeIt()&lt;br/&gt;
   &amp;#8211; T3: returns a cost of 10783.&lt;br/&gt;
   &amp;#8211; OI_2: saves 10783 as new best cost and tells T3 to save it.&lt;br/&gt;
   &amp;#8211; X2: calls OI_2.getOptimizedCost(), which returns 10783.  X2&lt;br/&gt;
     then returns 10783 to OI_0.&lt;br/&gt;
   &amp;#8211; OI_0: calls X1.optimizeIt()&lt;br/&gt;
   &amp;#8211; X1: &lt;b&gt;fetches&lt;/b&gt; OI_1 and makes calls to optimize it.&lt;br/&gt;
   &amp;#8211; OI_1: picks join order {T1}
&lt;p&gt; and calls T1.optimizeIt()&lt;br/&gt;
   &amp;#8211; T1: returns a cost of &lt;b&gt;1 MILLION!&lt;/b&gt;.&lt;br/&gt;
   &amp;#8211; OI_1: rejects new cost (1 mil &amp;gt; 20) and does nothing.&lt;br/&gt;
   &amp;#8211; X1: calls OI_1.getOptimizedCost(), which returns &lt;b&gt;20&lt;/b&gt;.  X1&lt;br/&gt;
     then returns 20 to OI_0...this seems WRONG!&lt;br/&gt;
   &amp;#8211; OI_0: saves 10783 + 20 = 10803 as new best cost and tells&lt;br/&gt;
     X2 to save 10783 and X1 to save 20.&lt;/p&gt;

&lt;p&gt;So in the end, the outer-most OptimizerImpl chooses join order &lt;/p&gt;
{X2, X1}
&lt;p&gt; because it thought the cost of this join order was only 10783, which is better than  64720.  However, the &lt;em&gt;actual&lt;/em&gt; cost of the join order was really estimated at 1 million--so the outer OptimizerImpl chose (and will generate) a plan that, according to the estimates, was (hugely) sub-optimal.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12329148">DERBY-1007</key>
            <summary>Optimizer can return incorrect &quot;best cost&quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="army">A B</reporter>
                        <labels>
                    </labels>
                <created>Sat, 18 Feb 2006 10:22:12 +0000</created>
                <updated>Mon, 29 Jun 2009 15:36:41 +0100</updated>
                            <resolved>Fri, 26 May 2006 05:22:00 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.1.3.1</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12368201" author="army" created="Wed, 1 Mar 2006 11:25:15 +0000"  >&lt;p&gt;Attaching a patch, d1007_v1.patch, to resolve this issue.  The changes are summarized as follows:&lt;/p&gt;

&lt;p&gt;1. Added the &quot;prepForNextRound()&quot; method that was part of OptimizerImpl to the Optimizer interface since that seems like an appropriate place for it.&lt;/p&gt;

&lt;p&gt;2. Added a single line to OptimizerImpl.prepForNextRound() to reset the &quot;bestCost&quot; for the current round of optimization.  Note that I do &lt;em&gt;not&lt;/em&gt; reset the &quot;foundABestPlan&quot; variable nor the &quot;bestJoinOrder&quot; array.  This is because it&apos;s possible that a &quot;best join order&quot; may not exist for the current round, in which case the optimizer must know whether or not it found a best join order in a previous round (foundABestPlan) and if so what the corresponding join order was (bestJoinOrder).  That information is required so that a valid query plan can be generated after optimization is complete.&lt;/p&gt;

&lt;p&gt;3. After making the above changes, I noticed that the optimizer cost estimates were not always showing up when logQueryPlan was set to true-&lt;del&gt;they were sometimes being printed as question marks to represent &quot;Infinity&quot;.  The reason for this was that most of the code in the &quot;modifyAccessPaths&quot; phase of query compilation uses the estimates as they sit in the ResultSetNode.costEstimate field&lt;/del&gt;-which, for nodes above subqueries, will hold the &quot;bestCost&quot; estimates for the most recent plan chosen by the OptimizerImpl for the subquery.  Since I am now (with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt;) resetting the &quot;bestCost&quot; variable at the start of every round, it&apos;s possible that &quot;bestCost&quot; will hold an estimate that has been &quot;reset&quot; to Double.MAX_VALUE.  This can happen if it was reset (in prepForNextRound()) and then no valid join order was found for the current round (ex. if no valid join order exists or if there was an optimizer &quot;timeout&quot;).  That in turn meant that the &quot;costEstimate&quot; field for nodes above the OptimizerImpl would have been &quot;reset&quot; as well, and hence the &quot;infinity&quot; value (i.e. question mark) was showing up in the logged query plan.   So I had to find all nodes that use &quot;costEstimate&quot; during modifyAccessPaths() and update them to use the final, best cost estimate for that node (instead of just using the most recent value of &quot;costEstimate&quot;).  This touched several of ResultSetNode&apos;s subclasses, but the diff in most cases is just a few lines.  The exceptions are FromTable, SelectNode, UnionNode, IntersectOrExceptNode, and JoinNode, where I added new &quot;getFinalCostEstimate&quot; methods to correctly figure out the final cost estimate based on the final estimates for child nodes, as appropriate.&lt;/p&gt;

&lt;p&gt;4. The current optimizer &quot;timeout&quot; mechanism is based on the value in OptimizerImpl.bestCost.  Since I&apos;m now resetting that value at the start of every round, the timeout mechanism had to be changed in order to preserve its current functionality while removing the dependency on bestCost.  So I&apos;ve added a new variable, timeLimit, to OptimizerImpl that plays the same role w.r.t optimizer &quot;timeout&quot; that the old bestCost value did.&lt;/p&gt;

&lt;p&gt;5. Updated master/derived.out to match new behavior.  There&apos;s one query in derived.sql that is affected by this issue.  Before these changes the optimizer thought one join order B was cheaper than another join order A and so it chose to generate join order B.  With these changes, though, it now (correctly) sees that join order A and join order B are equivalent, so it just goes with join order A.  This difference manifests itself in the ordering of two rows in the result set for that query--so I&apos;ve updated the masters accordingly.&lt;/p&gt;

&lt;p&gt;6. Added a new, simple test case specific to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; to lang/subquery.sql, and updated the master file accordingly.  The test case is the same one mentioned in the description for this issue.&lt;/p&gt;

&lt;p&gt;I ran derbyall on Red Hat Linux using IBM 1.4.2 with my changes and saw no failures.  I would very much appreciate any comments/feedback from any available reviewers/ committers out there...&lt;/p&gt;

&lt;p&gt;Note to committers: The changes in d1007_v1.patch depend on code changes made as part of d805_phase1_v3.patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;.  Since that patch was only recently committed, you&apos;ll have to be sure to sync up before trying to apply d1007_v1.patch....&lt;/p&gt;</comment>
                            <comment id="12369235" author="bandaram" created="Tue, 7 Mar 2006 22:23:21 +0000"  >&lt;p&gt;Patch submitted to trunk.&lt;/p&gt;</comment>
                            <comment id="12376647" author="army" created="Thu, 27 Apr 2006 14:24:25 +0100"  >&lt;p&gt;In a word, the fix for this issue ensures that, in the case of subqueries, the optimizer will correctly propagate the estimated costs for subqueries up to the parent subquery(&lt;del&gt;ies), thus allowing the parent query to make a better decision about which join order is ultimately the best.  As seen in the example scenario included above, the correct estimates are higher&lt;/del&gt;&lt;del&gt;sometimes much higher&lt;/del&gt;-than what the optimizer was returning prior to this change: in the example, the optimizer was returning an incorrect cost estimate of 10783  before the patch, and a correct estimate of 1 million after the patch (where &quot;correct&quot; means that it&apos;s the value calculated by the optimizer and thus the value that should be returned; I&apos;m not saying anything about the accuracy of the estimate here).&lt;/p&gt;

&lt;p&gt;One side effect of this is that, for very deeply nested queries and/or queries with a high number of FROM tables/expressions, the higher cost estimates can be multiplied-&lt;del&gt;sometimes many times over&lt;/del&gt;-throughout the optimization process, which means that the overall query estimate can climb to a much larger number much more quickly.  If the query is big enough, this can actually cause the optimizer to reach an estimated cost of INFINITY.&lt;/p&gt;

&lt;p&gt;That said, the current optimizer logic for choosing a plan does not expect to see an estimate of infinity for its plans.  As a result the optimizer does comparisons of, and arithmetic with, cost estimates and row counts that, when applied to Infinity, give unexpected results.&lt;/p&gt;

&lt;p&gt;I have filed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1259&quot; title=&quot;Optimizer plan consideration doesn&amp;#39;t account for infinite cost estimates and can therefore choose plans requiring excessive memory.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1259&quot;&gt;DERBY-1259&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1260&quot; title=&quot;Investigate impact of infinite cost estimates on arithmetic operations/comparisons in the optimizer.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1260&quot;&gt;DERBY-1260&lt;/a&gt; to address the &quot;infinity problem&quot; in more detail, but am attaching here a follow-up patch that takes some basic steps toward making the optimizer more robust in the face of infinite cost estimates, which are now more likely to occur given the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; changes.  In particular, the d1007_followup_v1.patch does the following:&lt;/p&gt;

&lt;p&gt;1) Fixes a couple of small problems with the handling of estimates for FromBaseTables, to ensure that a FromBaseTable&apos;s estimate is correctly propagated to (and handled by) the ProjectRestrictNode that sits above it.  This parallels the original &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; work but is a much simpler &quot;follow-up&quot; task as it deals only with base tables instead of subqueries, and thus the changes are fairly minor.&lt;/p&gt;

&lt;p&gt;2) There are several places in OptimizerImpl where the optimizer will only choose to accept a plan&apos;s cost if the cost is less than the current &quot;bestCost&quot;.  If no best cost has been found yet, bestCost is set to an uninitialized value of Double.MAX_VALUE with the assumption that the first valid plan will have a cost less than Double.MAX_VALUE and thus will be chosen as the best so far.  However, since a plan&apos;s cost estimate can actually end up being Double.POSITIVE_INFINITY, which is greater than Double.MAX_VALUE, it&apos;s possible that the optimizer will reject a valid join order because its cost is infinity, and then end up completing without ever finding a valid plan-&lt;del&gt;which is wrong.  What we want is for the optimizer to accept the first valid plan that it finds, regardless of what the cost is.  Then if it later finds a better plan, it can use that.  So in several places the d1007_followup_v1.patch adds a check to see if bestCost is uninitialized and, if so, we&apos;ll always accept the first valid join order we find, regardless of what its cost is&lt;/del&gt;&lt;del&gt;even if it&apos;s infinity&lt;/del&gt;-because that&apos;s better than no plan at all.&lt;/p&gt;

&lt;p&gt;3) Modifies the &quot;compare&quot; method in CostEstimateImpl.java to try to account for comparisons between two plans that both have infinite costs.  If this happens, we don&apos;t have much choice but to guess as to which plan is actually better.  So the changes for followup_v1 make that guess based on a comparison of row counts for the two plans.  And if the row counts themselves are infinity, then we&apos;ll guess based on the single scan row counts.  And finally, if those values are both infinity, as well, then we&apos;re out of luck and we just say that the two costs are &quot;equal&quot; for lack of better alternative.&lt;/p&gt;

&lt;p&gt;4) And finally, due to unexpected behavior that results from arithmetic using infinity (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1259&quot; title=&quot;Optimizer plan consideration doesn&amp;#39;t account for infinite cost estimates and can therefore choose plans requiring excessive memory.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1259&quot;&gt;DERBY-1259&lt;/a&gt;), it is currently possible (though rather rare) for the optimizer to decide to do a hash join that has a cost estimate of Infinity.  An example of a query for which this could happen can be found in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1205&quot; title=&quot;Unexpectedly very slow performance compared to DB2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1205&quot;&gt;&lt;del&gt;DERBY-1205&lt;/del&gt;&lt;/a&gt;, query #1.  That said, the BackingStoreHashtable that is used for carrying out a hash join currently creates a Java Hashtable instance with a capacity that matches the optimizer&apos;s estimated row count.  So if the row count is infinity we&apos;ll try to create a Hashtable with some impossibly large capacity and, as a result, we&apos;ll end up with an OutOfMemory error.  So the d1007_followup_v1.patch adds some code to handle this kind of situation in a more graceful manner.&lt;/p&gt;

&lt;p&gt;I ran derbyall with these changes on Linux Red Hat using ibm142 and saw no new failures.&lt;/p&gt;

&lt;p&gt;So if anyone has time to review/commit, I&apos;d appreciate it.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="12376783" author="mikem" created="Fri, 28 Apr 2006 03:14:19 +0100"  >&lt;p&gt;I have reviewed the BackingStoreHashtable.java changes, and they look ok to me.  As the comments mention it is &lt;br/&gt;
wierd to compare row count and memory size, but the issue is well documented in the change - and addresses&lt;br/&gt;
the problem.  I have added some comments to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1259&quot; title=&quot;Optimizer plan consideration doesn&amp;#39;t account for infinite cost estimates and can therefore choose plans requiring excessive memory.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1259&quot;&gt;DERBY-1259&lt;/a&gt;, with regard to fixing the issue that this change addresses in the caller - but  it still seems reasonable to &quot;bulletproof&quot; this routine even if in a running system we don&apos;t expect the case.  Better to have the routine work than fail a query.  I will leave the commit/review of the optimizer part to those with expertise in that area.&lt;/p&gt;</comment>
                            <comment id="12376837" author="army" created="Fri, 28 Apr 2006 07:00:10 +0100"  >&lt;p&gt;While waiting for the followup patch to be committed to 10.2 (trunk), I&apos;ve also included the patch to port these changes (the original plus the followup) to 10.1--the patch for doing so is attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; and also posted here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/19330&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/19330&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12413306" author="army" created="Fri, 26 May 2006 05:22:00 +0100"  >&lt;p&gt;Follow-up patch checked into trunk with svn 397675; both patches (original and followup) checked into 10.1 with svn 397682.  So I&apos;m marking this issue as resolved.  Thanks for the commits, Satheesh.&lt;/p&gt;</comment>
                            <comment id="12420383" author="army" created="Wed, 12 Jul 2006 02:01:30 +0100"  >&lt;p&gt;Changes have been in 10.1 and 10.2 codelines for over a month now, so I&apos;m marking the issue as closed.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12325937" name="d1007_followup_v1.patch" size="14294" author="army" created="Thu, 27 Apr 2006 14:24:25 +0100"/>
                            <attachment id="12323532" name="d1007_v1.patch" size="34942" author="army" created="Wed, 1 Mar 2006 11:25:15 +0000"/>
                            <attachment id="12323533" name="d1007_v1.stat" size="1638" author="army" created="Wed, 1 Mar 2006 11:25:15 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 7 Mar 2006 22:23:21 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22259</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0whr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39082</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>