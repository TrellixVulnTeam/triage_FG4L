<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:52:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2191/DERBY-2191.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2191] Cleanup of FormatableBitSet</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2191</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The implementation of FormatableBitSet could be streamlined. Dead code can be removed and the implementation of some methods can be simplified.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12358907">DERBY-2191</key>
            <summary>Cleanup of FormatableBitSet</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.png">Trivial</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dyret">Dyre Tjeldvoll</assignee>
                                    <reporter username="dyret">Dyre Tjeldvoll</reporter>
                        <labels>
                    </labels>
                <created>Mon, 18 Dec 2006 13:17:33 +0000</created>
                <updated>Mon, 29 Jun 2009 15:19:35 +0100</updated>
                            <resolved>Wed, 25 Apr 2007 08:12:17 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Miscellaneous</component>
                    <component>Services</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12459399" author="dyret" created="Mon, 18 Dec 2006 16:31:14 +0000"  >&lt;p&gt;Added a patch that removes some dead code. Reviews are appreciated.&lt;/p&gt;</comment>
                            <comment id="12459576" author="dyret" created="Tue, 19 Dec 2006 09:22:20 +0000"  >&lt;p&gt;Removed an unnecessary cast to FormatableBitSet as well.&lt;/p&gt;</comment>
                            <comment id="12459900" author="knutanders" created="Wed, 20 Dec 2006 11:29:20 +0000"  >&lt;p&gt;Thanks Dyre. The patch looks good. Committed revision 489053.&lt;/p&gt;</comment>
                            <comment id="12462523" author="dyret" created="Fri, 5 Jan 2007 16:31:56 +0000"  >&lt;p&gt;While looking at this class I noticed that some methods and parts of methods never get executed (according to the code coverage listing on the Wiki). I thought it would be good to have a unit test for the class before making bigger changes to it, so I have attached a junit-test proposal (FormatableBitSetTest.java).&lt;/p&gt;

&lt;p&gt;Currently I have placed the test in the unitTest directory, but since there is no junit infrastructure there or in the directory above, this may not be  the best option. Suggestions?&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="12463039" author="dyret" created="Mon, 8 Jan 2007 13:51:21 +0000"  >&lt;p&gt;Here is a brief list of bugs/issues that was found while writing FormatableBitSetTest.java:&lt;/p&gt;

&lt;p&gt;1) The two-arg constructor fails if given a size arg that is smaller than the size of the byte array arg&lt;/p&gt;

&lt;p&gt;2) When the copy constructor is used to copy an empty bitset with a null byte array, the resulting copy has a non-null byte array&lt;/p&gt;

&lt;p&gt;3) It is legal to call grow(int) with an arg that is smaller that the bitset&apos;s current size, but the size of the bitset remains the same.&lt;/p&gt;

&lt;p&gt;4) It is legal to call grow(int) with a negative argument, but the size of the bitset remains the same.&lt;/p&gt;

&lt;p&gt;5) Shrinking an empty bitset to size 0 causes an AssertFailure&lt;/p&gt;

&lt;p&gt;6) It is legal to call shrink(int) with an arg that is larger that the bitset&apos;s current size, but the size of the bitset remains the same.&lt;/p&gt;

&lt;p&gt;7) Shrinking an ordinary  bitset to size 0 causes an AssertFailure&lt;/p&gt;

&lt;p&gt;8) The return value of compare doesn&apos;t match what is stated in the javadoc for the method&lt;/p&gt;

&lt;p&gt;9) The concatenate method does not work. Concatenation of two 18 bit bitsets yields a bitset that is still 18 bits.&lt;/p&gt;

&lt;p&gt;10) The method isSet(-1) gives an NPE for an empty bitset, but returns false for a non-empty set.&lt;/p&gt;

&lt;p&gt;11) The method set(-1) gives an NPE for an empty bitset, but does nothing for a non-empty set.&lt;/p&gt;

&lt;p&gt;12) The method clear(-1) gives an NPE for an empty bitset, but does nothing for a non-empty set.&lt;/p&gt;

&lt;p&gt;13) The method anySetBit() gives an NPE for an empty bitset, -1 would be more reasonable&lt;/p&gt;

&lt;p&gt;14) The method anySetBit(-1) is equivalent to anySetBit(), but smaller args (-2, -3) do not throw an exception, but also do not necessarily return the same value as -1&lt;/p&gt;

&lt;p&gt;15) The method or(FormatableBitSet) accepts null as an argument and treats it as if it represents an empty bitset. and(FormatableBitSet) will throw an AssertFailure, but xor(FormatableBitSet) throws an NPE&lt;/p&gt;

&lt;p&gt;16) The methods or(FormatableBitSet) and  and(FormatableBitSet) can be used with args that are smaller or larger. xor() requires the arg to have the same size as &quot;this&quot;&lt;/p&gt;

&lt;p&gt;17) readExternalFromArray does not appear to have a write counterpart. Using it on something that is wtitten with writeExternal does not seem to work&lt;/p&gt;</comment>
                            <comment id="12463156" author="knutanders" created="Mon, 8 Jan 2007 23:07:30 +0000"  >&lt;p&gt;Hi Dyre,&lt;/p&gt;

&lt;p&gt;Thanks for writing the test and posting the issues!&lt;/p&gt;

&lt;p&gt;Some comments/questions to the results from your test:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I think some of the methods that have issues/bugs are not used&lt;br/&gt;
  (seems to be the case for concatenate and two-arg constructor, at&lt;br/&gt;
  least). Would it be better to remove the dead/broken code than to&lt;br/&gt;
  fix it?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Some of the issues/inconsistencies are caused by the handling of&lt;br/&gt;
  (value == null). In the code coverage report, it seems like the code&lt;br/&gt;
  paths for null handling are rarely (never?) exercised. Is it&lt;br/&gt;
  possible to make (value != null) invariant (for instance by checking&lt;br/&gt;
  in the constructor)? Then we could remove most of the null checks. I&lt;br/&gt;
  think that would make the code cleaner (and it would increase the&lt;br/&gt;
  code coverage percentage).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I would expect and(), or() and xor() to handle arguments (null,&lt;br/&gt;
  differing length, etc) the same way. Since FormatableBitSet is a&lt;br/&gt;
  library class in the services.io package, I think it is strange if&lt;br/&gt;
  its methods throw assert error for special cases or boundary&lt;br/&gt;
  conditions. In my opinion, such asserts belong at a higher level&lt;br/&gt;
  where one can tell from the context that it&apos;s a bad state.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In addition to the issue you noticed, I think isSet() might hide&lt;br/&gt;
  some errors because it catches ArrayIndexOutOfBoundsException and&lt;br/&gt;
  returns false (in insane mode). Do you think it would be safe to&lt;br/&gt;
  remove the try/catch? To me, it sounds more correct to propagate the&lt;br/&gt;
  exception than to silently ignore it.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12463216" author="dyret" created="Tue, 9 Jan 2007 08:56:44 +0000"  >&lt;p&gt;Thank you for looking at the results &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Some answers to your questions:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Yes, I would prefer to remove code that isn&apos;t used. (Only caveat is that the two-arg constructor is really useful when writing tests. Particularly if you want to create a bitset that doesn&apos;t have a multiple of 8 number of bytes)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Yes, I would prefer to have value!=null be an ivariant as well (Possible caveat; can you assign to value in the ctor used when doing de-serialization?)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;No, I don&apos;t like the way asserts are used either. Apart from what you mention it also makes it hard(er) to write tests that will work both in sane and insane mode.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Yes, would prefer that isSet didn&apos;t catch ArrayIndexOutOfBoundsException, or always checked the validity of its arguments. If you want all access to invalid bit indices to be handled the same way, I think you will have to check the argument manually since you are not guaranteed that access to a bit index larger than the bitset&apos;s max index  will trigger an ArrayIndexOutOfBoundsException.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12464134" author="dyret" created="Fri, 12 Jan 2007 09:29:17 +0000"  >&lt;p&gt;I&apos;ve attached a patch (fbstst.v1) that adds (a modified) FormatableBitSetTest.java as a JUnit unit test. The patch creates a new junit package under the unitTests package with a corresponding _Suite class, as discussed on derby-dev. No new JUnit harness was created at the top-level, but the unitTests.junit._Suite was added to the functionTests.allPackages suite.&lt;/p&gt;

&lt;p&gt;suites.All ran successfully in both sane and insane mode.&lt;/p&gt;

&lt;p&gt;Note! Patch contains one new directory and two new files. See attached svn stat output for details.&lt;/p&gt;

&lt;p&gt;Please review.&lt;/p&gt;</comment>
                            <comment id="12464306" author="dyret" created="Fri, 12 Jan 2007 19:03:33 +0000"  >&lt;p&gt;I can confirm that the following methods aren&apos;t used and can be removed:&lt;/p&gt;

&lt;p&gt;public FormatableBitSet(byte[] newValue, int numBits)&lt;br/&gt;
public FormatableBitSet concatenate(FormatableBitSet other)&lt;br/&gt;
private static byte hexCharToByte(char hexChar)&lt;br/&gt;
private static char[] decodeArray = &lt;/p&gt;
{&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;,
								&apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;}
&lt;p&gt;;&lt;br/&gt;
public void readExternalFromArray(ArrayInputStream in) throws IOException&lt;/p&gt;

&lt;p&gt;I plan to submit a patch for this when the JUnit test has been committed (since removing these method will require changes to the test)&lt;/p&gt;</comment>
                            <comment id="12464807" author="knutanders" created="Mon, 15 Jan 2007 13:53:46 +0000"  >&lt;p&gt;I have committed fbstst.v1.diff to trunk with revision 496312. I made one minor change before committing: Some of the test cases used assertEquals(double, double, double) to compare two integers. Changed them to assertEquals(int, int) instead.&lt;/p&gt;</comment>
                            <comment id="12464835" author="dyret" created="Mon, 15 Jan 2007 15:52:45 +0000"  >&lt;p&gt;committed by KAH&lt;/p&gt;</comment>
                            <comment id="12465101" author="dyret" created="Tue, 16 Jan 2007 10:11:30 +0000"  >&lt;p&gt;I&apos;ve attached a patch (valuenotnull.v1) which ensures that the &apos;value&apos; byte array never is null, and removes the now redundant null-checks. The default constructor initializes &apos;value&apos; to a shared zero-length array instance taken from ReuseFactory Pleas review.&lt;/p&gt;</comment>
                            <comment id="12465174" author="knutanders" created="Tue, 16 Jan 2007 15:01:53 +0000"  >&lt;p&gt;Verified that there is no way to set value to null. All tests ran cleanly.&lt;br/&gt;
Committed revision 496719.&lt;/p&gt;</comment>
                            <comment id="12465197" author="dyret" created="Tue, 16 Jan 2007 16:30:28 +0000"  >&lt;p&gt;I&apos;m looking at how boundary checking could be improved in this class, but I&apos;m a bit unsure about what the best approach is. Right now I have a patch in my sandbox that introduces a private checkPosition() method that is used in all accessors (isSet(), set(), clear()), which throws IllegalArgumentException if the position is negative or larger than the largest legal bit position. This gives a clean interface where all illegal positions are handled uniformly and the test looks cleaner. But I&apos;m a bit uncomfortable with all this extra checking for an internal interface that only developers will use. &lt;/p&gt;

&lt;p&gt;If we accept that using a negative bit doesn&apos;t result in the same exception being thrown we could cut down on the testing since a negative bit index always  will result in an exception. If we can accept that access to illegal bit positions in the last byte go undetected we could drop the extra check altogether... (there is, of course, the issue of what set(illegalIndex) should do. Nothing?)&lt;/p&gt;

&lt;p&gt;Another more radical solution is to require bitset sizes to be a multiple of 8. Then one would not need to track the number of bits used. This would only be possible if we remove concatenate() (which is unused).&lt;/p&gt;</comment>
                            <comment id="12465266" author="knutanders" created="Tue, 16 Jan 2007 19:42:51 +0000"  >&lt;p&gt;If we have a check for the position, I think we should test both whether it is too big and whether it is too small. None of those cases should happen, and I don&apos;t think bugs causing negative positions are less likely or less severe than bugs causing too big positions. If negative positions always caused other exceptions, it would probably be OK to skip the test, but I&apos;m not sure they always do. At least, it doesn&apos;t seem like isSet(), set() and clear() always throw exceptions when the position is negative. I think it must be &lt;em&gt;sufficiently&lt;/em&gt; negative compared to the size of the bit set before an exception is thrown. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; In FormatableBitSetTest, set(-1) and clear(-1) fail when the set is empty, but don&apos;t fail otherwise. isSet(-1) doesn&apos;t fail in any case.&lt;/p&gt;</comment>
                            <comment id="12465418" author="knutanders" created="Wed, 17 Jan 2007 11:01:55 +0000"  >&lt;p&gt;When I looked at the previous patches, I noticed some other minor issues that could be fixed in FormatableBitSet. The proposed changes are attached as cleanup2191.diff:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Remove unused import java.io.InputStream.&lt;/li&gt;
	&lt;li&gt;numBytesFromBits() is unnecessarily complex. Currently, it returns (bits == 0) ? 0 : ((bits - 1) / 8) + 1, but for non-negative values of bits, (bits + 7) &amp;gt;&amp;gt; 3 gives the same results (and bits should never be negative).&lt;/li&gt;
	&lt;li&gt;Remove unused variables in toString().&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12465425" author="dyret" created="Wed, 17 Jan 2007 11:43:35 +0000"  >&lt;p&gt;I have looked at Knut&apos;s patch and I think those changes are good and should be committed.&lt;/p&gt;

&lt;p&gt;Knut&apos;s observation that small negative bit indexes will not trigger an ArrayIndexOutOfBoundsException is absolutely correct, so I think I&apos;ll submit my patch for this.&lt;/p&gt;

&lt;p&gt;I just uploaded a patch (unusedmethods.v1) which removes unused methods. derbyall and suites.All pass.&lt;/p&gt;</comment>
                            <comment id="12465449" author="dyret" created="Wed, 17 Jan 2007 17:09:03 +0000"  >&lt;p&gt;I&apos;ve attached boundarycheck.v1 which adds argument checking to isSet, set and clear. Please review.&lt;/p&gt;</comment>
                            <comment id="12465726" author="knutanders" created="Thu, 18 Jan 2007 11:13:58 +0000"  >&lt;p&gt;Committed cleanup2191.diff with revision 497003.&lt;br/&gt;
Committed unusedmethods.v1.diff with revision 497396.&lt;br/&gt;
Committed boundarycheck.v1.diff revision 497398.&lt;/p&gt;</comment>
                            <comment id="12466007" author="dyret" created="Fri, 19 Jan 2007 10:41:13 +0000"  >&lt;p&gt;Attached another patch (bitops.v1) which changes the bitset operator methods or(), and() and xor() so that they follow the same pattern. That is; they all accept null as an argument and treats that as an empty bitset, and they all allow operands of all sizes and handles them the same way. All are now performing the operation bytewise, and there is no special handling of the last partial byte. The patch also adds a method called invariantHolds() that checks if the class&apos; invariant is maintained (for use in the unit test). &lt;/p&gt;</comment>
                            <comment id="12466020" author="knutanders" created="Fri, 19 Jan 2007 11:00:09 +0000"  >&lt;p&gt;This sounds like a very good change. Would it be good to call have an assert in or/and/xor which tested invariantHolds()? Now that they perform the operations bytewise, they require that the extra bits are unset, and I think that&apos;s worth testing in sane builds.&lt;/p&gt;</comment>
                            <comment id="12466044" author="dyret" created="Fri, 19 Jan 2007 13:24:13 +0000"  >&lt;p&gt;Actually I did run derbyall and suites.All with such ASSERTS in my sandbox yesterday, without seeing any failures. But I removed them before creating the patch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But, sure I could put them back.  When I think about it, I don&apos;t think should matter what the state of the unused bits is, at least as long as all other operations respect the lengthAsBits member (I haven&apos;t verified that this is in fact the case, but seems to be the intention), and that grow() does the proper initialization. But I still think it is good to maintain this as an invariant because it makes it easier to detect errors.&lt;/p&gt;</comment>
                            <comment id="12466056" author="dyret" created="Fri, 19 Jan 2007 14:13:18 +0000"  >&lt;p&gt;bitops.v2 adds the requested ASSERT.&lt;/p&gt;</comment>
                            <comment id="12466057" author="knutanders" created="Fri, 19 Jan 2007 14:15:50 +0000"  >&lt;p&gt;&amp;gt; When I think about it, I don&apos;t think should matter what the state of the unused bits is, at least as long as all other operations respect the lengthAsBits member&lt;/p&gt;

&lt;p&gt;That&apos;s a good point. However, if we knew for sure that the unused bits are always unset, it would also be possible to perform bytewise operations in getNumBitsSet().&lt;/p&gt;</comment>
                            <comment id="12466413" author="knutanders" created="Mon, 22 Jan 2007 08:20:02 +0000"  >&lt;p&gt;Thanks Dyre, bitops.v2 looks good! I only have one tiny comment: The patch copies this pattern (not introduced by you) from or() to and() and xor():&lt;/p&gt;

&lt;p&gt;		if (otherBit == null || otherBit.getLength() == 0)&lt;br/&gt;
			return;&lt;/p&gt;

&lt;p&gt;		int otherLength = otherBit.getLength();&lt;/p&gt;

&lt;p&gt;For non-empty bitsets (which I expect is the normal case) otherBit.getLength() is called twice. It seems like all three methods will handle empty bitsets correctly without the check for getLength()==0, so perhaps it would be better to remove it.&lt;/p&gt;</comment>
                            <comment id="12466476" author="dyret" created="Mon, 22 Jan 2007 15:11:20 +0000"  >&lt;p&gt;Attached bitops.v3 which removes the unnecessary check for getLength()==0&lt;/p&gt;</comment>
                            <comment id="12466545" author="knutanders" created="Mon, 22 Jan 2007 20:07:01 +0000"  >&lt;p&gt;bitops.v3 looks good the tests passed. Fixed a copy/paste error in xor&apos;s javadoc (AND -&amp;gt; XOR) and committed revision 498772.&lt;/p&gt;</comment>
                            <comment id="12467013" author="dyret" created="Wed, 24 Jan 2007 11:59:03 +0000"  >&lt;p&gt;Attaching bitopt.v1 which introduces the unsigned arithmetic optimization discussed on derby-dev earlier. The optimization has been isolated in static utility methods. derbyall and suites.All pass.  &lt;/p&gt;</comment>
                            <comment id="12467385" author="knutanders" created="Thu, 25 Jan 2007 14:05:03 +0000"  >&lt;p&gt;I think the rewrite of numBitsInLastByte() made the code clearer. The error checks in the constructor and shrink() also seem useful. Two comments:&lt;br/&gt;
  1) umul8() doesn&apos;t seem to be used.&lt;br/&gt;
  2) I think isSet(), set() and clear() became more difficult to read. I think it would be better if they kept the old style where the byte number and bit position were calculated separately and put into variables with meaningful names (they can still use the new methods).&lt;/p&gt;</comment>
                            <comment id="12467404" author="dyret" created="Thu, 25 Jan 2007 15:12:41 +0000"  >&lt;p&gt;Attaching bitopt.v2 to address the review comments.&lt;/p&gt;</comment>
                            <comment id="12467750" author="knutanders" created="Fri, 26 Jan 2007 08:16:12 +0000"  >&lt;p&gt;Thank you for addressing my comments! bitopt.v2 looks good. Committed revision 500177.&lt;/p&gt;</comment>
                            <comment id="12467778" author="dyret" created="Fri, 26 Jan 2007 10:50:56 +0000"  >&lt;p&gt;Attaching anysetbit.v1 which re-writes anySetBit and anySetBit(int beyondBit) to use a single loop and removes special handling of the last byte. Tests pass. Please review.&lt;/p&gt;</comment>
                            <comment id="12468204" author="dyret" created="Mon, 29 Jan 2007 09:19:32 +0000"  >&lt;p&gt;Attaching numbitsset.v1 which re-writes the method getNumBitsSet() to do a byte-by-byte calculation. Tests pass. Please review.&lt;/p&gt;</comment>
                            <comment id="12468230" author="knutanders" created="Mon, 29 Jan 2007 11:03:49 +0000"  >&lt;p&gt;I have looked at anysetbit.v1 and numbitsset.v1. I think the changes look very good. And thank you for documenting the algorithm used in getNumBitsSet() so thoroughly!&lt;/p&gt;

&lt;p&gt;Some small comments:&lt;br/&gt;
  1) In anySetBits(), perhaps &quot;return (umul8&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;|firstSet(v));&quot; would be clearer if it used plus instead of or?&lt;br/&gt;
  2) Since anySetBits() and getNumBitsSet() now use all bits in the last byte, maybe they should start with &quot;ASSERT(invariantHolds())&quot;?&lt;br/&gt;
  3) I think it would be good if firstSet() had a short comment explaining what it&apos;s supposed to do.&lt;br/&gt;
  4) Would it be better if the return statements in firstSet() didn&apos;t use hex format? Since the returned values are positions and not bit patterns, I mean.&lt;/p&gt;</comment>
                            <comment id="12468242" author="oysteing" created="Mon, 29 Jan 2007 11:30:04 +0000"  >&lt;p&gt;The javadoc for anySetBit says that it will &quot;return the bit number of&lt;br/&gt;
a bit that is set&quot;.  If I understand the implementation correctly, it&lt;br/&gt;
will always return the first bit that is set.  Looking at some of the&lt;br/&gt;
usages of anySetBit, it seems like this behavior is also assumed.  For&lt;br/&gt;
example, it seems to be used to iterate over all set bits of the bit&lt;br/&gt;
set (e.g., BasicNoPutResultSetImpl.getCompactRow()).&lt;/p&gt;

&lt;p&gt;It think it would be a good idea to give this function a more&lt;br/&gt;
descriptive name or at least change the javadoc to reflect the assumed&lt;br/&gt;
and implemented behavior.&lt;/p&gt;

&lt;p&gt;I also seems that at least for one usage of anySetBit(), returning the&lt;br/&gt;
first set bit, is the least optimal (see&lt;br/&gt;
ResultColumnList.generateHolderMethod(), which tries to find the&lt;br/&gt;
maximum column number for which the corresponding bit is set).&lt;/p&gt;

&lt;p&gt;For firstSet(), you can reduce the average number of comparisons by&lt;br/&gt;
doing binary search, something like:&lt;/p&gt;

&lt;p&gt;        if ((v &amp;amp; 0xf0) != 0) {&lt;br/&gt;
            if ((v &amp;amp; 0xc0) != 0) {&lt;br/&gt;
                if ((v &amp;amp; 0x80) != 0) &lt;/p&gt;
{
                    return 0;
                }
&lt;p&gt; else &lt;/p&gt;
{
                    return 0x1;
                }
&lt;p&gt;            } else {&lt;br/&gt;
                if ((v &amp;amp; 0x20) != 0) &lt;/p&gt;
{
                    return 0x2;
                }
&lt;p&gt;                else &lt;/p&gt;
{
                    return 0x3;
                }
&lt;p&gt;            }&lt;br/&gt;
        else {&lt;br/&gt;
            if ((v &amp;amp; 0xc) != 0) {&lt;br/&gt;
        ...&lt;/p&gt;


&lt;p&gt;However, I cannot guarantee that a smaller number of comparisons will&lt;br/&gt;
give better performance.  I have no idea what impact this has with&lt;br/&gt;
respect to how the processsor does instruction preloading etc.&lt;/p&gt;</comment>
                            <comment id="12468263" author="dyret" created="Mon, 29 Jan 2007 13:03:38 +0000"  >&lt;p&gt;I agree that the javadoc comment for anySetBit should be improved, and will include this in the next version of the patch.&lt;/p&gt;

&lt;p&gt;I&apos;ll take a look at ResultColumnList.generateHolderMethod() and see if anything can be done.&lt;/p&gt;

&lt;p&gt;Wrt. firstSet(): I did consider your approach, but that will always result in 4 comparisons. The current approach will give an average of 4 comparisons if the set bits are uniformly distributed in the byte. If you look at how firstSet is used in anySetBit(int) you&apos;ll see that the argument is frequently shifted a number of bits to the left. So the bits are not uniformly distributed, but rather clustered in the beginning of the byte.&lt;/p&gt;</comment>
                            <comment id="12468266" author="dyret" created="Mon, 29 Jan 2007 13:16:05 +0000"  >&lt;p&gt;New patch which addresses the review comments.&lt;/p&gt;</comment>
                            <comment id="12468277" author="oysteing" created="Mon, 29 Jan 2007 13:41:47 +0000"  >
&lt;p&gt;&amp;gt; Dyre Tjeldvoll commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2191&quot; title=&quot;Cleanup of FormatableBitSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2191&quot;&gt;&lt;del&gt;DERBY-2191&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; ---------------------------------------&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I agree that the javadoc comment for anySetBit should be improved,&lt;br/&gt;
&amp;gt; and will include this in the next version of the patch.&lt;/p&gt;

&lt;p&gt;Good.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;ll take a look at ResultColumnList.generateHolderMethod() and see&lt;br/&gt;
&amp;gt; if anything can be done.&lt;/p&gt;

&lt;p&gt;Before putting too much effort into that, I think you should consider&lt;br/&gt;
whether this is a time critical function.  Since its seem to be used&lt;br/&gt;
during compilation, it might not be that critical.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Wrt. firstSet(): I did consider your approach, but that will always&lt;br/&gt;
&amp;gt; result in 4 comparisons. The current approach will give an average&lt;br/&gt;
&amp;gt; of 4 comparisons if the set bits are uniformly distributed in the&lt;br/&gt;
&amp;gt; byte. If you look at how firstSet is used in anySetBit(int) you&apos;ll&lt;br/&gt;
&amp;gt; see that the argument is frequently shifted a number of bits to the&lt;br/&gt;
&amp;gt; left. So the bits are not uniformly distributed, but rather&lt;br/&gt;
&amp;gt; clustered in the beginning of the byte.&lt;/p&gt;

&lt;p&gt;Good point, and thinking a bit more about this, even if my suggestion&lt;br/&gt;
will always give 3 (not 4!)  comparisons, I think your way is probably&lt;br/&gt;
better also when you do not take the shifting into account.  If all&lt;br/&gt;
bit combinations are equally likely, 50% of the cases will only need&lt;br/&gt;
one comparison, and the average number of comparisons will be just&lt;br/&gt;
below 2.  (I think your numbers assume that only one bit is set at a&lt;br/&gt;
time.)&lt;/p&gt;
</comment>
                            <comment id="12468279" author="dyret" created="Mon, 29 Jan 2007 13:48:27 +0000"  >&lt;p&gt;New patch which addresses the review comments.&lt;/p&gt;</comment>
                            <comment id="12468335" author="knutanders" created="Mon, 29 Jan 2007 16:37:23 +0000"  >&lt;p&gt;anysetbit.v2 looks good and the tests passed. Committed revision 501095.&lt;/p&gt;</comment>
                            <comment id="12468528" author="knutanders" created="Tue, 30 Jan 2007 08:14:35 +0000"  >&lt;p&gt;numbitsset.v2 also looks good. I verified that the algorithm that calculated the number of bits in a byte returned the same value as Integer.bitCount(0xff &amp;amp; b) which is included in jdk&amp;gt;=1.5.&lt;/p&gt;

&lt;p&gt;Committed revision 501334.&lt;/p&gt;</comment>
                            <comment id="12468567" author="knutanders" created="Tue, 30 Jan 2007 10:56:50 +0000"  >&lt;p&gt;numbitstest.diff adds the tests I ran to verify that getNumBitsSet() returns the same number of bits as Integer.bitCount(). The test cases test all byte values from Byte.MIN_VALUE to Byte.MAX_VALUE for a one-byte bit set and a two-byte bit set.&lt;/p&gt;</comment>
                            <comment id="12468573" author="knutanders" created="Tue, 30 Jan 2007 11:08:59 +0000"  >&lt;p&gt;Committed numbitstest.diff with revision 501368.&lt;/p&gt;</comment>
                            <comment id="12468650" author="dyret" created="Tue, 30 Jan 2007 15:42:59 +0000"  >&lt;p&gt;Attaching shrink.v1 which tries get rid of some of the unexpected behavior when growing and shrinking bitsets (commented in the unit test). The goal was that both grow(int) and shrink(int) should disallow negative arguments and grow(int) should only to accept arguments larger than the current bitset size, and by symmetry shrink(int) should only allow arguments smaller than the current size. Unfortunately, that is currently not possible since the existing usage requires grow(int n) where n is smaller than the current size to be a noop. So in the patch there is an asymmetry between grow(int) and shrink(int) where shrink(int) will not accept n larger than the current size.&lt;/p&gt;

&lt;p&gt;The patch also changes the order of the asserts in the tests so that the assert on the length of the byte array always is the last assert. This is necessary since getByteArray() trims away any unused bytes of the byte array making any later invariant checks etc. worthless. &lt;/p&gt;

&lt;p&gt;The patch fixes a bug in shrink(int). Without this patch shrink(int) will not clear any bytes beyond the new last byte. E.g. if a bitset is shrunk from 18 to 9 bits, the now unused bits in the second byte will be cleared, but NOT the bits in the third byte. This error was not caught by any tests because they called getByteArray() before checking the invariant.&lt;/p&gt;</comment>
                            <comment id="12468708" author="bryanpendleton" created="Tue, 30 Jan 2007 17:44:44 +0000"  >&lt;p&gt;&amp;gt; there is an asymmetry between grow(int) and shrink(int)&lt;/p&gt;

&lt;p&gt;Would it make sense to collapse grow() and shrink() into a single method,&lt;br/&gt;
perhaps called something like &quot;setBitSize()&quot; or &quot;setCapacity&quot;? It might make&lt;br/&gt;
it more clear at the caller&apos;s level that it doesn&apos;t matter whether you are&lt;br/&gt;
making the bitset larger or smaller; you just need to specify the new size.&lt;/p&gt;</comment>
                            <comment id="12469012" author="dyret" created="Wed, 31 Jan 2007 12:23:33 +0000"  >&lt;p&gt;I think a single method makes a lot of sense, and I would seriously consider it if it wasn&apos;t for the large number of files that would have to be changed. (Which is also why I didn&apos;t rename anySetBit() to something more meaningful. e.g. firstSetBit()).&lt;/p&gt;</comment>
                            <comment id="12469059" author="knutanders" created="Wed, 31 Jan 2007 14:39:09 +0000"  >&lt;p&gt;A couple of tiny comments to shrink.v1:&lt;/p&gt;

&lt;p&gt;1) Javadoc for grow() says &quot;Negative n are not allowed.&quot; Probably better (grammatically) with &quot;neg. values of n are&quot; or &quot;neg. n&apos;s are&quot;.&lt;br/&gt;
2) shrink() defines lastByteNum as numBytesFromBits&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; - 1, but later we have to add one to use it. Would it be (slightly) better to call it firstUnusedByte and not subtract one until we need the last byte?&lt;br/&gt;
3) testGrowSmaller() and testGrow0() have lines without indentation.&lt;/p&gt;</comment>
                            <comment id="12469110" author="dyret" created="Wed, 31 Jan 2007 17:13:29 +0000"  >&lt;p&gt;shrink.v2 addresses the review comments.&lt;/p&gt;</comment>
                            <comment id="12469402" author="knutanders" created="Thu, 1 Feb 2007 10:45:49 +0000"  >&lt;p&gt;Thanks Dyre! Committed shrink.v2 with revision 502185.&lt;/p&gt;</comment>
                            <comment id="12469718" author="knutanders" created="Fri, 2 Feb 2007 11:12:10 +0000"  >&lt;p&gt;It seems to me that grow() is unnecessarily complex. It has some extra logic to handle the case where there are enough free bits in the last byte, but that does not seem any different from the case where the byte array contains enough free space. Also, it loops through the previously unused bytes and clears them, which should be unnecessary because the unused bytes should always be 0 (part of the invariant).&lt;/p&gt;

&lt;p&gt;grow.diff removes the unneeded special case and the clearing of the unused bytes. It also adds a call to ASSERT(invariantHolds()) in grow() and shrink(). Derbyall and the JUnit tests passed.&lt;/p&gt;</comment>
                            <comment id="12470538" author="dyret" created="Tue, 6 Feb 2007 12:09:14 +0000"  >&lt;p&gt;I think grow.diff should be committed.&lt;/p&gt;</comment>
                            <comment id="12470850" author="knutanders" created="Wed, 7 Feb 2007 08:40:12 +0000"  >&lt;p&gt;Committed grow.diff with revision 504460.&lt;/p&gt;</comment>
                            <comment id="12491477" author="mikem" created="Tue, 24 Apr 2007 23:35:12 +0100"  >&lt;p&gt;Is this one done?  just checking to see if we can close some 10.3 targeted issues.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12348372" name="FormatableBitSetTest.java" size="17406" author="dyret" created="Fri, 5 Jan 2007 16:19:44 +0000"/>
                            <attachment id="12349672" name="anysetbit.v1.diff" size="6379" author="dyret" created="Fri, 26 Jan 2007 10:50:55 +0000"/>
                            <attachment id="12349673" name="anysetbit.v1.stat" size="317" author="dyret" created="Fri, 26 Jan 2007 10:50:56 +0000"/>
                            <attachment id="12349801" name="anysetbit.v2.diff" size="7149" author="dyret" created="Mon, 29 Jan 2007 13:16:05 +0000"/>
                            <attachment id="12349246" name="bitops.v1.diff" size="19135" author="dyret" created="Fri, 19 Jan 2007 10:30:54 +0000"/>
                            <attachment id="12349247" name="bitops.v1.stat" size="356" author="dyret" created="Fri, 19 Jan 2007 10:30:54 +0000"/>
                            <attachment id="12349260" name="bitops.v2.diff" size="19449" author="dyret" created="Fri, 19 Jan 2007 14:12:33 +0000"/>
                            <attachment id="12349261" name="bitops.v2.stat" size="400" author="dyret" created="Fri, 19 Jan 2007 14:12:33 +0000"/>
                            <attachment id="12349379" name="bitops.v3.diff" size="19362" author="dyret" created="Mon, 22 Jan 2007 15:09:45 +0000"/>
                            <attachment id="12349519" name="bitopt.v1.diff" size="4599" author="dyret" created="Wed, 24 Jan 2007 11:59:03 +0000"/>
                            <attachment id="12349520" name="bitopt.v1.stat" size="349" author="dyret" created="Wed, 24 Jan 2007 11:59:03 +0000"/>
                            <attachment id="12349606" name="bitopt.v2.diff" size="4759" author="dyret" created="Thu, 25 Jan 2007 15:12:41 +0000"/>
                            <attachment id="12349092" name="boundarycheck.v1.diff" size="8309" author="dyret" created="Wed, 17 Jan 2007 17:06:16 +0000"/>
                            <attachment id="12349093" name="boundarycheck.v1.stat" size="327" author="dyret" created="Wed, 17 Jan 2007 17:06:16 +0000"/>
                            <attachment id="12349077" name="cleanup2191.diff" size="2078" author="knutanders" created="Wed, 17 Jan 2007 10:47:58 +0000"/>
                            <attachment id="12349078" name="cleanup2191.stat" size="161" author="knutanders" created="Wed, 17 Jan 2007 10:47:58 +0000"/>
                            <attachment id="12347426" name="deadcode.v1.diff" size="1401" author="" created="Mon, 18 Dec 2006 16:29:57 +0000"/>
                            <attachment id="12347470" name="deadcode.v2.diff" size="1360" author="dyret" created="Tue, 19 Dec 2006 09:22:20 +0000"/>
                            <attachment id="12348797" name="fbstst.v1.diff" size="26682" author="dyret" created="Fri, 12 Jan 2007 09:20:58 +0000"/>
                            <attachment id="12348798" name="fbstst.v1.stat" size="649" author="dyret" created="Fri, 12 Jan 2007 09:20:58 +0000"/>
                            <attachment id="12350202" name="grow.diff" size="1869" author="knutanders" created="Fri, 2 Feb 2007 11:12:10 +0000"/>
                            <attachment id="12349779" name="numbitsset.v1.diff" size="1603" author="dyret" created="Mon, 29 Jan 2007 09:19:31 +0000"/>
                            <attachment id="12349780" name="numbitsset.v1.stat" size="233" author="dyret" created="Mon, 29 Jan 2007 09:19:32 +0000"/>
                            <attachment id="12349808" name="numbitsset.v2.diff" size="1701" author="dyret" created="Mon, 29 Jan 2007 13:48:27 +0000"/>
                            <attachment id="12349899" name="numbitstest.diff" size="3207" author="knutanders" created="Tue, 30 Jan 2007 10:56:49 +0000"/>
                            <attachment id="12349932" name="shrink.v1.diff" size="17502" author="dyret" created="Tue, 30 Jan 2007 15:42:59 +0000"/>
                            <attachment id="12349933" name="shrink.v1.stat" size="334" author="dyret" created="Tue, 30 Jan 2007 15:42:59 +0000"/>
                            <attachment id="12350048" name="shrink.v2.diff" size="17383" author="dyret" created="Wed, 31 Jan 2007 17:13:29 +0000"/>
                            <attachment id="12349081" name="unusedmethods.v1.diff" size="9318" author="dyret" created="Wed, 17 Jan 2007 11:36:28 +0000"/>
                            <attachment id="12349082" name="unusedmethods.v1.stat" size="708" author="dyret" created="Wed, 17 Jan 2007 11:36:28 +0000"/>
                            <attachment id="12348999" name="valuenotnull.v1.diff" size="8481" author="dyret" created="Tue, 16 Jan 2007 10:04:54 +0000"/>
                            <attachment id="12349000" name="valuenotnull.v1.stat" size="485" author="dyret" created="Tue, 16 Jan 2007 10:04:54 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 20 Dec 2006 11:29:20 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30312</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0wn3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39106</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>