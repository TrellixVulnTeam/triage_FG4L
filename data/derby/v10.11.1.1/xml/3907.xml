<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:22:58 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3907/DERBY-3907.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3907] Save useful length information for Clobs in store</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3907</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The store should save useful length information for Clobs. This allows the length to be found without decoding the whole data stream.&lt;br/&gt;
The following thread raised the issue on what information to store, and also contains some background information: &lt;a href=&quot;http://www.nabble.com/Storing-length-information-for-CLOB-on-disk-tp19197535p19197535.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Storing-length-information-for-CLOB-on-disk-tp19197535p19197535.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The information to store, and the exact format of it, is still to be discussed/determined.&lt;br/&gt;
Currently two bytes are set aside for length information, which is inadequate.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12406169">DERBY-3907</key>
            <summary>Save useful length information for Clobs in store</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kristwaa">Kristian Waagan</assignee>
                                    <reporter username="kristwaa">Kristian Waagan</reporter>
                        <labels>
                    </labels>
                <created>Fri, 10 Oct 2008 12:56:09 +0100</created>
                <updated>Wed, 12 May 2010 17:26:34 +0100</updated>
                            <resolved>Wed, 18 Mar 2009 16:47:54 +0000</resolved>
                                    <version>10.5.1.1</version>
                                    <fixVersion>10.5.1.1</fixVersion>
                                    <component>JDBC</component>
                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12638538" author="kristwaa" created="Fri, 10 Oct 2008 13:14:46 +0100"  >&lt;p&gt;A few starting points for discussion follows (all about the meta-information for Clobs).&lt;br/&gt;
I have assumed the following prerequisites:&lt;br/&gt;
 1) Clob modifications are done on a copy (i.e. TemporaryClob).&lt;br/&gt;
 2) The meta-information is of fixed length and at the start of the data stream (first page), so that it can be updated after the data has been streamed to store.&lt;/p&gt;

&lt;p&gt;a) Format specification byte&lt;br/&gt;
    Shall we use a format specification (&quot;magic number&quot;) byte?&lt;/p&gt;

&lt;p&gt;b) Maximum Clob length (in characters)&lt;br/&gt;
    How many bits shall we use for the Clob length?&lt;br/&gt;
    Is representing todays maximum (2G-1) enough, or should we make some headroom?&lt;/p&gt;

&lt;p&gt;c) Storing byte length&lt;br/&gt;
    I mentioned storing the byte length as well, but haven&apos;t found any strong use cases.&lt;br/&gt;
    Opinions?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Optimizations&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;d) Bytes per character information&lt;br/&gt;
    Use a few bits to save byte per character information, which can be used to optimize positioning.&lt;br/&gt;
    If the value is different than 0, one can calculate the byte position from the char position without decoding the stream.&lt;br/&gt;
    This information must be obtained by looking at all the bytes in the Clob, typically when inserting it.&lt;br/&gt;
    Example with 2 bits:&lt;br/&gt;
      0 = unknown/mixed&lt;br/&gt;
      1 = one byte per char&lt;br/&gt;
      2 = two bytes per char&lt;br/&gt;
      3 = three bytes per char&lt;/p&gt;

&lt;p&gt;e) Save &quot;key positions&quot; for the Clob&lt;br/&gt;
    For instance save the char/byte positions for 25%, 50% and 75% of the Clob.&lt;br/&gt;
    This increases space overhead, but reduces the decoding/positioning costs for large Clobs.&lt;br/&gt;
    Also adds some complexity to the positioning logic in upper layer code (i.e. above store).&lt;/p&gt;


&lt;p&gt;Please comment on these issues.&lt;br/&gt;
Information about the upgrade issue is also appreciated.&lt;/p&gt;</comment>
                            <comment id="12638589" author="mikem" created="Fri, 10 Oct 2008 18:02:07 +0100"  >&lt;p&gt;upgrade comments:&lt;br/&gt;
o In keeping with the current Derby goals I believe any change of format should continue to support&lt;br/&gt;
   the hard/soft upgrade paradigm.  Given that any change will need to have code that supports both&lt;br/&gt;
   the old and new format.&lt;/p&gt;

&lt;p&gt;o So then the decision is when to use the new format.  At high level (though not sure all are feasible)&lt;br/&gt;
   are:&lt;br/&gt;
   1) every different clob in existing table&lt;br/&gt;
   2) only new tables support new format, in hard upgraded db&apos;s support new format&lt;br/&gt;
   3) only newly created DB&apos;s support new format.&lt;/p&gt;

&lt;p&gt;1) Off hand I don&apos;t think we have enough per data value information to figure out an olf format clob&lt;br/&gt;
     vs. a new format clob - but maybe someone else can come up with a magic sequence of initial&lt;br/&gt;
     bytes.  It would be nice if the new format made it so in the future other possible optimizations &lt;br/&gt;
     could be handled on a per row basis - with some sort of format byte.&lt;br/&gt;
2) This option seems the most flexible and readily implemented.  By creating a new format id for&lt;br/&gt;
     the new type of clob then the code can be made to easily know the difference between a table&lt;br/&gt;
     of old clobs and new clobs.  If someone really wants to data upgrade an old db then an offline&lt;br/&gt;
     compress in a hard upgraded db should automatically do it, with the added benefit of defraging&lt;br/&gt;
     and compressing the tables.&lt;br/&gt;
3) I think this is sort of like #2 and is not really any less code.  &lt;/p&gt;

&lt;p&gt;o Also there is a decision on what to do at hard upgrade time.  Either the newly hard upgrade db supports both formats or one had to do a per row data upgrade.  No Derby release has done this&lt;br/&gt;
(and it was never done before the code was donated to apache either).  My opinion would be to &lt;br/&gt;
continue to support both formats.&lt;/p&gt;</comment>
                            <comment id="12638592" author="mikem" created="Fri, 10 Oct 2008 18:10:54 +0100"  >&lt;p&gt;I will post some more comments on your proposal, but need some clarification.&lt;/p&gt;

&lt;p&gt;What does the following mean?  Will the changes apply to all sql which inserts clobs, or to only particular jdbc interfaces?&lt;br/&gt;
1) Clob modifications are done on a copy (i.e. TemporaryClob).&lt;/p&gt;

&lt;p&gt;What is the expected call sequence to store, and what is the goal performance characteristic?  ie.&lt;br/&gt;
for an insert of non-lengthed clob is it something like:&lt;br/&gt;
insert unlength clob into store, calculating length along the way&lt;br/&gt;
update clob in store changing N leading bytes&lt;/p&gt;
</comment>
                            <comment id="12639080" author="kristwaa" created="Mon, 13 Oct 2008 16:34:42 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Upgrade issues&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Thanks for the information on the upgrade issue, Mike.&lt;br/&gt;
I think it sounds smart to follow existing patterns. Having never written this type of code, I&apos;ll need some more time and more pieces of advice when I start working on it.&lt;/p&gt;

&lt;p&gt;So to sum it up (correct me if I got this wrong):&lt;br/&gt;
 a) Support hard/soft upgrade&lt;br/&gt;
 b) Use new format in new tables (in newly created databases and in hard upgraded databases)&lt;br/&gt;
 c) Leave data as it is at hard upgrade and support both formats for the &quot;stream header&quot;&lt;/p&gt;

&lt;p&gt;Is the format id stored per table only, or per row?&lt;/p&gt;

&lt;p&gt;Besides from the lower level format id code, I see that changes must be done in various other classes (i.e. ReaderToUTF8Stream and SQLClob).&lt;br/&gt;
I&apos;m not sure, but I think some of the newly added classes (10.3 and later) must be reviewed too, as they reset the stream to do positioning. Currently a reset means to position the UTF-8 stream from store at position 2 to skip the two length bytes.&lt;/p&gt;</comment>
                            <comment id="12639082" author="kristwaa" created="Mon, 13 Oct 2008 16:45:11 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Header format&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Mike wrote:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;What does the following mean? Will the changes apply to all sql which inserts clobs, or to only particular jdbc interfaces?&lt;br/&gt;
1) Clob modifications are done on a copy (i.e. TemporaryClob).&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;With Clob modifications I mean updates of parts of an existing Clob. To get into this state, one must first do a select to get the Clob that has already been stored in the database. I think updating parts of the Clob can only be done through the Clob interface. Is that correct?&lt;/p&gt;

&lt;p&gt;The ResultSet.updateXXX-methods can be seen as inserting a new Clob.&lt;br/&gt;
My current hope is that all insertion will go through ReaderToUTF8Stream, which seems like a good place to count characters (and bytes) and obtain bytes per char statistics.&lt;/p&gt;

&lt;p&gt;There might be a slight complication as we allow using setString on Clob columns.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;What is the expected call sequence to store, and what is the goal performance characteristic?&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The expected call sequence is exactly as you describe it (see Mike&apos;s comment from 10/Oct/08 10:10 AM).&lt;br/&gt;
Depending on the information we need to obtain, the header can be written at once or as the last step of insertion. Even if we only store length information, we need to support the latter due to the lengthless JDBC methods.&lt;/p&gt;

&lt;p&gt;The goal performance characteristic for the length operation is that getting the length for the largest storable Clob should be as fast as for the shortest one (read first page and decode stream header bytes). This is not the case today, because the Clob data must be decoded to find the length. Besides from Clob.getLength, this is hurting us where other methods do argument checking using the Clob length.&lt;/p&gt;

&lt;p&gt;Positioning can be expressed with costs like this:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;reset stream&amp;#93;&lt;/span&gt; + decode_chars + skip_bytes  &lt;br/&gt;
In certain cases, we can remove the decoding costs by knowing that all chars are represented by one, two or three bytes. In these cases, the positioning cost should be as for Blob. This is the motivation for the bytes per char information.&lt;/p&gt;</comment>
                            <comment id="12644985" author="kristwaa" created="Tue, 4 Nov 2008 15:50:37 +0000"  >&lt;p&gt;I&apos;m a bit unsure how to handle the format id issue.&lt;/p&gt;

&lt;p&gt;It is not clear to me what the differences between the various clob fields in StoredFormatIds are:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CLOB_TYPE_ID&lt;/li&gt;
	&lt;li&gt;CLOB_COMPILATION_TYPE_ID&lt;/li&gt;
	&lt;li&gt;CLOB_TYPE_ID_IMPL&lt;/li&gt;
	&lt;li&gt;SQL_CLOB_ID&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In the current implementation, I think I need to access this information up to the JDBC level, i.e. in classes like StoreStreamClob, SQLClob and possibly a ResultSet class.&lt;br/&gt;
To me it seems I need two versions of the SQL_CLOB_ID, but I&apos;m not sure.&lt;br/&gt;
Can anyone with more knowledge about the type system guide me?&lt;/p&gt;

&lt;p&gt;I do think we need a new format id, because the current format  (two bytes that can have any values) makes it hard to add another stream header format.&lt;/p&gt;</comment>
                            <comment id="12645269" author="mikem" created="Wed, 5 Nov 2008 17:50:31 +0000"  >&lt;p&gt;&amp;gt; I&apos;m a bit unsure how to handle the format id issue.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; It is not clear to me what the differences between the various clob fields in&lt;br/&gt;
StoredFormatIds are:&lt;br/&gt;
&amp;gt; - CLOB_TYPE_ID&lt;br/&gt;
&amp;gt; - CLOB_COMPILATION_TYPE_ID&lt;br/&gt;
&amp;gt; - CLOB_TYPE_ID_IMPL&lt;br/&gt;
&amp;gt; - SQL_CLOB_ID&lt;br/&gt;
For the reading and writing of the data to disk the SQL_CLOB_ID is the one.&lt;br/&gt;
It is associated with the SQLClob class.&lt;/p&gt;

&lt;p&gt;The SQL layer when it creates a table gives the format id of each of the&lt;br/&gt;
collumns.  This format id is used by store to tell what object it should&lt;br/&gt;
create to interpret the bytes on disk.  So say you create a SQL_CLOB_VER2_ID,&lt;br/&gt;
and associated it with SQLClob2, and work the code such that new db&apos;s and/or&lt;br/&gt;
hard upgraded db&apos;s always use the new class/id when creating new tables.&lt;br/&gt;
Then Store will use SQLClob2 to read data into, and count on&lt;br/&gt;
SQLClob2.readExternal&lt;br/&gt;
SQLClob2.readExternalFromArray&lt;br/&gt;
SQLClob2.writeExternal&lt;/p&gt;

&lt;p&gt;to read and write your new format.&lt;/p&gt;

&lt;p&gt;Note that for current SQLClob these are all inherited from SQLChar currently.&lt;/p&gt;

&lt;p&gt;In general what has been done in the pase is to switch the format ids in the&lt;br/&gt;
new code such that the &quot;current&quot; version has the existing name, and that&lt;br/&gt;
the old version has the new name.  So SQLClob would get the new version id,&lt;br/&gt;
and a new class would get the old version id, something like SQLClob_10_4.java.&lt;/p&gt;

&lt;p&gt;For an example check out:&lt;br/&gt;
java/engine/org/apache/derby/impl/store/access/btree/index/B2I.java&lt;br/&gt;
java/engine/org/apache/derby/impl/store/access/btree/index/B2I_10_3.java&lt;br/&gt;
java/engine/org/apache/derby/impl/store/access/btree/index/B2I_v10_2.java&lt;/p&gt;


&lt;p&gt;Again this is only talking about the issue of reading/writing disk at store&lt;br/&gt;
level.  There may be other code with stream dependencies that thinks it&lt;br/&gt;
&quot;knows&quot; the format of the stream.  The way this kind of thing has been handled&lt;br/&gt;
in the past is to make the runtime version of the object always look like the&lt;br/&gt;
&quot;current&quot; format.  For past upgrades this has been easy as it usually is just&lt;br/&gt;
another field in the object that one can pick a default for if it is an old&lt;br/&gt;
version.  In this way it isolates the upgrade code to just the to/from&lt;br/&gt;
disk part of the code.  With streams this may be more challenging.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt; In the current implementation, I think I need to access this information up to&lt;br/&gt;
 the JDBC level, i.e. in classes like StoreStreamClob, SQLClob and possibly a Re&lt;br/&gt;
sultSet class.&lt;br/&gt;
&amp;gt; To me it seems I need two versions of the SQL_CLOB_ID, but I&apos;m not sure.&lt;br/&gt;
&amp;gt; Can anyone with more knowledge about the type system guide me?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I do think we need a new format id, because the current format (two bytes that&lt;br/&gt;
 can have any values) makes it hard to add another stream header format.&lt;/p&gt;</comment>
                            <comment id="12645278" author="mikem" created="Wed, 5 Nov 2008 18:08:55 +0000"  >&lt;p&gt;The updating discussion has been a bit confusing.   I am concentrating on the store interface to update an object on disk.  I realize there are a number of in memory clob update paths, but that is a different issue.  Currently there is no way to update &quot;part&quot; of the object in the store&lt;br/&gt;
interface, only the whole object.&lt;/p&gt;

&lt;p&gt;So without store changes your normal use case for the lengthless updates would require the entire clob to be rewritten to disk.  &lt;/p&gt;

&lt;p&gt;I think easiest would be to support a new store interface that allowed the update of first initial n bytes by an exact same number of bytes.  Currently for long clobs the usual case would be that we used all the bytes on the 1st page for the fist piece of the linked list, so expanding by any number of bytes would be a worst case.  We would log at least the entire &quot;old&quot; portion of the row.  If the lengths don&apos;t exactly match there is more logging complication.  So my guess at ease of implementation from easiest to hardest supporting some subset of bytes update:&lt;br/&gt;
o exact leading number of bytes&lt;br/&gt;
o shrinking leading number of bytes&lt;br/&gt;
o expanding leading number of bytes&lt;br/&gt;
o arbitrary positioned number of bytes&lt;/p&gt;

&lt;p&gt;This probably would mean a new log record, and thus need to be careful again about hard/softupgrade.  We have done log record updates (or new ones) in derby so an example&lt;br/&gt;
exists.&lt;/p&gt;</comment>
                            <comment id="12645298" author="kristwaa" created="Wed, 5 Nov 2008 19:18:36 +0000"  >&lt;p&gt;Thanks a lot, Mike!&lt;/p&gt;

&lt;p&gt;I think I know enough to start working on some code now. The first patch(es) will be far from complete, but hopefully it can take the issue forwards.&lt;br/&gt;
My initial plan is to create two subtasks:&lt;br/&gt;
 o add a new version of SQLClob.&lt;br/&gt;
 o add capability to update parts of an object to store&lt;/p&gt;

&lt;p&gt;The first part hopefully allows me to create tables with the new Clob format, without actually storing length information. I`ll just use the existing EOF marker and skip the header bytes. As a side effect, running the test suite should help me detect the places where the JDBC layer thinks it knows the store format.&lt;br/&gt;
Maybe I can limit the knowledge about the exact format in the new version of SQLClob?&lt;/p&gt;

&lt;p&gt;Regarding the second part, I need to look at the example. I think replacing a fixed number of bytes should suffice, as Clobs are intended for large objects and therefore the header bytes overhead is acceptable. This means the header (which is part of the data stream) will take up just as many bytes for a 2 GB Clob as for a ~32K one.&lt;br/&gt;
I have no intention to provide functionality to replace arbitrary positioned bytes, as this &quot;conflicts&quot; with the current LOB implementation and is a large undertaking (design and implementation).&lt;/p&gt;

&lt;p&gt;Hopefully we can use the functionality added in the second part to improve the situation for &quot;lenghtless Blobs&quot; as well, at least in some cases.&lt;/p&gt;</comment>
                            <comment id="12650988" author="kristwaa" created="Wed, 26 Nov 2008 13:05:49 +0000"  >&lt;p&gt;I got stuck trying to implement the original solution, so I tried an alternative approach.&lt;/p&gt;

&lt;p&gt;It is a lot simpler, but people might not like it. Note however, that it follows roughly the same pattern as Blob.&lt;br/&gt;
Note the patch is a quick mash-up, and I want some feedback from the community.&lt;/p&gt;

&lt;p&gt;The alternative approach is to make all classes writing and reading data from store able to peek at it and determine which format it has to use to read/write the data.&lt;br/&gt;
Including my second format, we have these two byte formats:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;current: D1_D2_DATA&lt;/li&gt;
	&lt;li&gt;new: D4_D3_M_D2_D1_DATA&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;M is a magic byte, and is used to detect the new format. It is a illegal UTF-8 encoding, so it should not be possible to interpret it incorrectly as the first format and data.&lt;br/&gt;
I have set M to F0 (11110000), but I&apos;m masking out the last four bits when looking for the magic byte. This makes it possible to have arbitrary many formats, should that be necessary, the main point is to keep the four highest bits set.&lt;br/&gt;
With respect to data corruption (i.e. one bit getting flipped), is this approach safe enough?&lt;/p&gt;

&lt;p&gt;So if we need to be able to store huge Clobs in the future, we could change M and use another format:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;future: D6_D5_M_D4_D3_D2_D1_DATA&lt;br/&gt;
The same approach could be used to store other meta information.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The patch &apos;derby-3907-alternative_approach.diff&apos; only changes behavior for small Clobs. To enable a new format for a larger Clob, the streaming classes have to be changed (ReaderToUTF8Stream, UTF8Reader).&lt;br/&gt;
It should be noted that these classes are used to write other character types (CHAR, VARCHAR) as well, and I do not intend to change how they are represented. This means that I have to include enough information to be able to do the correct thing.&lt;/p&gt;

&lt;p&gt;While the format can be detected on read, an informed decision must be made on write. Now I&apos;m consulting the data dictionary to check the database version, and if it is less than 10.5 I use th e old format. Is there a better way?&lt;/p&gt;


&lt;p&gt;Regarding the original approach, I got stuck because the upper layers of Derby are sending down NULL values of the data types into store. The upper layer don&apos;t have any context information, and is unable to choose the correct implementation. The system doesn&apos;t seem to be set up for having multiple implementations of a single data type at this level.&lt;br/&gt;
I ended up with a series of hacks, for instance having store override the Clob implementation type, but it just didn&apos;t work very well. At one point I had normal, soft- and hard-upgraded working, but compress table failed. I&apos;m sure this isn&apos;t the only path that will fail.&lt;/p&gt;

&lt;p&gt;I might pick up the work again later, but right now I want to wait for a while and work on other issues.&lt;/p&gt;</comment>
                            <comment id="12650990" author="kristwaa" created="Wed, 26 Nov 2008 13:07:09 +0000"  >&lt;p&gt;Attached the wrong file. Adding the correct one.&lt;/p&gt;</comment>
                            <comment id="12651080" author="knutanders" created="Wed, 26 Nov 2008 18:03:00 +0000"  >&lt;p&gt;I think the magic byte sounds like an elegant solution to the problem. The invalid values for the first byte in the UTF-8-encoded sequence are used almost as if we had half a byte extra in the header reserved for future use. I think you are right that this will make the backwards-compatibility issues much easier to handle. As to your question about picking the right format when writing, I think your approach of checking the version of the data dictionary is the way it&apos;s normally done.&lt;/p&gt;</comment>
                            <comment id="12660766" author="kristwaa" created="Mon, 5 Jan 2009 14:08:45 +0000"  >&lt;p&gt;&apos;derby-3907-2b-header_write_preparation.diff&apos; is a preparation patch to lay the foundation for writing the new stream header format. Essentially, the behavior should be the same before and after the patch.&lt;/p&gt;

&lt;p&gt;The patch adds a new method to the interface StringDataValue, since the header format will only apply for string data types. The method generateStreamHdr creates the stream header based on the version of the dictionary and the character length information, and also determines if the stream have to be ended with a Derby-specific end-of-stream marker.&lt;br/&gt;
The current implementation simply returns unknown length and instructs to terminate the value with a Derby EOF marker. This is because Derby pre 10.5 expects a byte count, not a char count. At this level, the byte count is generally unknown. The method generateStreamHdr will be overridden in SQLClob, and the new header format will be used there, unless we are running in soft-upgrade mode where the old format will be used.&lt;br/&gt;
The goal is that the knowledge about the exact format of the headers is contained in the DVD(s).&lt;/p&gt;

&lt;p&gt;In ReaderToUTF8Stream I removed the instance variable maximumLength, because it is only needed in the constructor. Further, I added setHeader to allow the header to be overridden after the reader is instantiated. If the header isn&apos;t overridden, the reader should behave as before.&lt;/p&gt;

&lt;p&gt;Note that things &lt;b&gt;may&lt;/b&gt; have to be changed a bit if support for updating the header only is added (i.e. the lenghtless scenario).&lt;/p&gt;

&lt;p&gt;Patch 2b ready for review.&lt;/p&gt;

&lt;p&gt;FYI, patch 2a is almost identical, except that it doesn&apos;t use a utility/holder class for the header. I think using the utility class is cleaner, but it does of course introduce yet another class.&lt;/p&gt;</comment>
                            <comment id="12661083" author="kristwaa" created="Tue, 6 Jan 2009 09:06:46 +0000"  >&lt;p&gt;Regression tests for patch 2b ran without failures with Java SE 6 on Solaris.&lt;/p&gt;</comment>
                            <comment id="12661153" author="knutanders" created="Tue, 6 Jan 2009 14:32:59 +0000"  >&lt;p&gt;I looked at the 2b patch, and it looks good to me. Please see some&lt;br/&gt;
minor comments below:&lt;/p&gt;

&lt;p&gt;It seems like we always call ReaderToUTF8Stream.setHeader() right&lt;br/&gt;
after we have created a ReaderToUTF8Stream object, and we never create&lt;br/&gt;
a ReaderToUTF8Stream object without calling setHeader(). Would it be&lt;br/&gt;
cleaner to do add an extra parameter to the constructor instead of&lt;br/&gt;
requiring code that uses ReaderToUTF8Stream to call setHeader()? With&lt;br/&gt;
the current patch, it seems like headerOverridden will always be&lt;br/&gt;
true. Is that going to change? If not, the code would be simpler if&lt;br/&gt;
headerOverridden was removed.&lt;/p&gt;

&lt;p&gt;I think StringDataValue.generateStreamHdr() should be renamed to&lt;br/&gt;
generateStreamHeader() since it&apos;s a public method and a clear name is&lt;br/&gt;
more important than saving three characters.&lt;/p&gt;

&lt;p&gt;EmbedResultSet.updateCharacterStreamInternal: Since the value returned&lt;br/&gt;
by getDVDforColumnToBeUpdated() is now used twice, it is stored in a&lt;br/&gt;
local variable, which is good. But since the method is quite long,&lt;br/&gt;
perhaps it would be clearer to have the declaration of the variable&lt;br/&gt;
closer to the end of the method where it&apos;s used?&lt;/p&gt;</comment>
                            <comment id="12661224" author="kristwaa" created="Tue, 6 Jan 2009 17:45:52 +0000"  >&lt;p&gt;I agree ReaderToUTF8Stream can be simplified quite a bit, and I&apos;ll take a look at it.&lt;/p&gt;

&lt;p&gt;By adding the StreamHeaderHolder to the constructor, I think we&apos;ll loose one feature. The current implementation has the ability to go back and fill in the header if the value fits into the buffer (32768 - minus header size). The value written to the header is the byte count, and it is used as a hint for sizing the character array used when materializing the string value (CHAR, VARCHAR, LONG VARCHAR).&lt;br/&gt;
This functionality can continue to exist, but I&apos;m unsure how to do it. Some quick proposals:&lt;br/&gt;
 a) Duplicate header generation code in ReaderToUTF8Stream (trying to avoid this)&lt;br/&gt;
 b) Pass around a header generation object instead of a &quot;pre-generated&quot; header.&lt;br/&gt;
 c) Pass around reference to the StringDataValue/DVD object&lt;br/&gt;
 d) Special handling for all non-Clob data values (requires data type information)&lt;br/&gt;
 e) Simply check header length, if two bytes long then update header (hacky?)&lt;/p&gt;

&lt;p&gt;I&apos;m not sure how much performance will be affected by removing the feature, but options (d) and (e) seem pretty simple to implement. There are also some alternative &quot;sizing heuristics&quot;, but I don&apos;t know how effective they are (I&apos;ve seen InputStream.available() and the start-stop index on the page being used). When resizing, CHAR grows by 64 bytes, VARCHAR by 4 KB. Also note that the problem is only affecting values inserted with a stream/reader.&lt;/p&gt;

&lt;p&gt;Also, since we are already spending two bytes per string value to store meta information, it would be nice to actually use them optimally.  I&apos;m tempted to start using those two bytes for the character count, instead of the byte count. That way, the sizing hint would be exact for almost all CHAR, VARCHAR and LONG VARCHAR values (exceptions are those values inserted with a stream through the &quot;lengthless overrides&quot; where the byte representation exceeds ~32k bytes).&lt;br/&gt;
The downsides of this are that some decoding loops must be modified and probably that the hint has to be ignored when reading old databases (pre 10.5). I also need to do a more thorough search for places where this information is used.&lt;/p&gt;

&lt;p&gt;I think using the new header format for all string types is a bad idea, as it will add an extra 3 bytes of overhead. Further, two of those bytes will never be used due to the maximum allowed length of the non-Clob data types.&lt;/p&gt;


&lt;p&gt;BTW, I have added a static variable for the unknown length stream header holder. A new patch will be uploaded later.&lt;/p&gt;</comment>
                            <comment id="12661263" author="kristwaa" created="Tue, 6 Jan 2009 19:16:25 +0000"  >&lt;p&gt;Forget my rambling about the constructor, which has nothing to do with the issue at all. But the rest of the comment should have some substance &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
It&apos;s time to get home...&lt;/p&gt;</comment>
                            <comment id="12661569" author="kristwaa" created="Wed, 7 Jan 2009 13:45:09 +0000"  >&lt;p&gt;Patch 3a cleans up ReaderToUTF8Stream and changes the behavior in way one.&lt;br/&gt;
It will now try to truncate CHAR and VARCHAR as well as CLOB. Only spaces are accepted as truncatable characters.&lt;br/&gt;
Truncation is disallowed for LONG VARCHAR.&lt;/p&gt;

&lt;p&gt;In addition, I added some substance to the error message when truncation fails. I decided to not print the stream content, as it is not easily accessible and it may be very large.&lt;br/&gt;
I also added quite a bit of JavaDoc/comments, removed the instance variable maximumLength and simplified the constructors.&lt;br/&gt;
Since the type name is used to determine if truncation is allowed or not, I added a debug block verifying the name. As a consequence of this, I had to modify UTF8UtilTest.&lt;/p&gt;

&lt;p&gt;Regression tests ran with two failures (stressmulti and replication), and due to some changes I&apos;m re-running the tests.&lt;br/&gt;
Patch ready for review.&lt;/p&gt;</comment>
                            <comment id="12661573" author="kristwaa" created="Wed, 7 Jan 2009 13:50:56 +0000"  >&lt;p&gt;Wrong diff file... Reattaching 3a.&lt;/p&gt;</comment>
                            <comment id="12661928" author="kristwaa" created="Thu, 8 Jan 2009 10:28:55 +0000"  >&lt;p&gt;Attaching patch 3b.&lt;br/&gt;
I had to pull parts of the patch out. The error reporting for truncation failure during insert from a stream isn&apos;t adequate, and requires additional work. I filed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4005&quot; title=&quot;Make DerbyIOException useful for error messages requiring arguments to be constructed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4005&quot;&gt;DERBY-4005&lt;/a&gt; for some of it, but I expect there will be another Jira as well.&lt;/p&gt;

&lt;p&gt;The patch now changes ReaderToUTF8Stream and UTF8UtilTest only. See commit message for more detailed description of changes.&lt;/p&gt;

&lt;p&gt;Committed 3b to trunk with revision 732676.&lt;/p&gt;</comment>
                            <comment id="12661929" author="knutanders" created="Thu, 8 Jan 2009 10:33:59 +0000"  >&lt;p&gt;Does the 3b patch also change the behaviour with regards to truncation of CHAR and VARCHAR? Are these changes observable by users?&lt;/p&gt;</comment>
                            <comment id="12661963" author="kristwaa" created="Thu, 8 Jan 2009 13:10:16 +0000"  >&lt;p&gt;Patch 3b does change the behavior with regards to truncation of CHAR in one scenario, only possible through JDBC 4.0:&lt;br/&gt;
Inserting a stream that is too long (longer than the specified maximum width of the CHAR column) with a lengthless override. With a lengthless override, I mean a JDBC method taking a stream, but where the length of the stream is not specified.&lt;br/&gt;
Before the change the user would get SQLState 22001, after the change the SQLState would be XJ001. A follow-up patch should revert this change of behavior (Jira not yet logged, is dependent on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4005&quot; title=&quot;Make DerbyIOException useful for error messages requiring arguments to be constructed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4005&quot;&gt;DERBY-4005&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Further, I added CHAR to the list of allowed data types in ReaderToUTF8Stream.canTruncate, but the code using ReaderToUTF8Stream sets the number of characters to truncate to zero for all string data types except CLOB.&lt;br/&gt;
The code changing the behavior described above is what I pulled out from patch 3a (see some related info in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4005&quot; title=&quot;Make DerbyIOException useful for error messages requiring arguments to be constructed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4005&quot;&gt;DERBY-4005&lt;/a&gt;).&lt;br/&gt;
Since the functionality is already in place, I think it makes sense to allow for truncation in the stream instead of materializing the data value and try to truncate it later.&lt;br/&gt;
That said, the number of applicable use cases are limited so it wouldn&apos;t be a disaster to leave it as it is.&lt;/p&gt;

&lt;p&gt;Regarding the error reporting issue, it is still valid also if we drop the &quot;extended truncation support&quot;.&lt;/p&gt;</comment>
                            <comment id="12661966" author="kristwaa" created="Thu, 8 Jan 2009 13:32:47 +0000"  >&lt;p&gt;Refreshed patch 2b, as the old one don&apos;t apply any more due to other changes.&lt;br/&gt;
It has a few changes from the original version. The remaining comments from Knut Anders will be addressed in revision 2c.&lt;/p&gt;</comment>
                            <comment id="12662386" author="kristwaa" created="Fri, 9 Jan 2009 14:49:01 +0000"  >&lt;p&gt;Attached &apos;derby-3907-2c-header_write_preparation-PREVIEW.diff&apos;.&lt;br/&gt;
This is an early version of revision 2c. In general, Derby should behave as before, but it should now have the framework it needs to handle multiple header formats for the streams coming in.&lt;br/&gt;
This is a partial solution only, Derby must also learn how to handle multiple header formats for non-streaming situations. I expect most of these changes will come in SQLChar and SQLClob.&lt;br/&gt;
Finally, the new header format must be added.&lt;/p&gt;

&lt;p&gt;I&apos;m thinking about making StreamHeaderHolder immutable again, because the holder for a 10.4 header for a stream with unknown length will be used a lot. That way we can keep an instance in SQLChar that can be shared. I&apos;ll look some more at it an comment further.&lt;/p&gt;

&lt;p&gt;Feel free to have a look and give me some early feedback &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12662952" author="kristwaa" created="Mon, 12 Jan 2009 13:27:58 +0000"  >&lt;p&gt;Patch &apos;derby-3907-2c-header_write_preparation.diff&apos; is ready for review.&lt;/p&gt;

&lt;p&gt;A description of the changes:&lt;br/&gt;
 o EmbedResultSet and EmbedPreparedStatement&lt;br/&gt;
   Started using the new ReaderToUTF8Stream constructor, where the stream header is passed in. Also started to treat the DataValueDescriptor as a StringDataValue, which should always be the case at this point in the code.&lt;/p&gt;

&lt;p&gt; o ReaderToUTF8Stream&lt;br/&gt;
   Added field &apos;header&apos;, which holds a StreamHeaderHolder coming from a StringDataValue object. Updated the constructors with a new argument.  The first execution of fillBuffer now uses the header holder to obtain the header length, and the header holder object is consulted when checking if the header can be updated with the length after the application stream has been drained. Note that updating the header with a character count is not yet supported. This will be added in another patch together with the handling of the new header format.&lt;/p&gt;

&lt;p&gt; o StringDataValue&lt;br/&gt;
   Added new method generateStreamHeader.&lt;/p&gt;

&lt;p&gt; o SQLChar&lt;br/&gt;
   Implemented generateStreamHeader, which always return a header for a stream with unknown length (see the constant). In most cases, the header will be updated after the stream has been drained. The exception is when the data values for VARCHAR and LONG VARCHAR are too long to be held in the byte buffer in ReaderToUTF8Reader, which can only happen when the string contains characters that require a two or three byte representation.&lt;/p&gt;

&lt;p&gt; o SQLClob&lt;br/&gt;
   Added a constant for a 10.5 stream header holder representing a stream with unknown character length. Also updated the use of the ReaderToUTF8Stream constructor.&lt;/p&gt;

&lt;p&gt; o StreamHeaderHolder&lt;br/&gt;
   Holder object for a stream header, containing the header itself and the following additional information; &quot;instructions&quot; on how to update the header with a new length, if the length is expected to be in number of bytes or characters, and if an EOF marker is expected to be appended to the stream. The object is considered immutable, but it is not copying the byte arrays passed in to the constructor. I found this unnecessary because this code is being called by internal code only, but should it still do defensive copying?&lt;/p&gt;

&lt;p&gt; o UTF8UTilTest&lt;br/&gt;
   Updated usage of the ReaderToUTF8Stream constructor, and replaced the hardcode byte count to skip with a call to the header holder object.&lt;/p&gt;

&lt;p&gt; o ClobTest (jdbc4)&lt;br/&gt;
   Added some simple tests inserting and fetching Clobs to test the basics of stream header handling.&lt;/p&gt;

&lt;p&gt; o StreamTruncationTest&lt;br/&gt;
   New test testing truncation of string data values when they are inserted as streams. Note the not-so-elegant error reporting (see catch clause in insertSmall)...&lt;/p&gt;</comment>
                            <comment id="12663086" author="kristwaa" created="Mon, 12 Jan 2009 20:42:33 +0000"  >&lt;p&gt;Updated a new version of patch 2c. The only change is in ReaderToUTF8Stream.checkSufficientData, where I had used the wrong header holder to determine if an EOF marker was to be written to the stream.&lt;/p&gt;

&lt;p&gt;With the exception of one failure in UTF8UtilTest, the regression tests ran successfully with JDK 1.6 on Solaris.&lt;br/&gt;
In rerunning with the updated patch.&lt;/p&gt;</comment>
                            <comment id="12663261" author="kristwaa" created="Tue, 13 Jan 2009 08:02:58 +0000"  >&lt;p&gt;Committed patch 2c to trunk with revision 734065.&lt;/p&gt;</comment>
                            <comment id="12663331" author="kristwaa" created="Tue, 13 Jan 2009 13:53:44 +0000"  >&lt;p&gt;Patch &apos;derby-3907-4a-add_getStreamWithDescriptor.diff&apos; adds the method getStringWithDescriptor to StringDataValue.&lt;/p&gt;

&lt;p&gt;It it intended to be used when getting a stream from a StringDataValue to be used with a Clob object, or with streaming of string data values in general. The DVD is responsible for returning a correct descriptor for the raw stream. The descriptor is in turn used by other classes to correctly configure themselves with respect to data offsets, buffering, repositioning and so on.&lt;br/&gt;
This patch was part of a bigger patch, but I decided to split it into two to make it easier to review.&lt;/p&gt;

&lt;p&gt;Patch description:&lt;br/&gt;
 o CharacterStreamDescriptor&lt;br/&gt;
   Added a toString method and more verbose assert-messages.&lt;/p&gt;

&lt;p&gt; o StringDataValue&lt;br/&gt;
   Added method &apos;CharacterStreamDescriptor getStreamWithDescriptor()&apos;.&lt;/p&gt;

&lt;p&gt; o SQLChar&lt;br/&gt;
   Made setStream non-final so it can be overridden in SQLClob.&lt;br/&gt;
   Added default implementation of getStreamWithDescriptor that always returns null. This means that all non-Clob string data types will be handled as strings instead of streams in situations where a stream is requested through getStreamWithDescriptor. I&apos;ll look into the performance implications of this a little later, when more of the final code is in place.&lt;br/&gt;
   Made throwStreamingIOException protected to access it from SQLClob.&lt;/p&gt;

&lt;p&gt; o SQLClob&lt;br/&gt;
   Implemented getStreamWithDescriptor, handling the old 2-byte format only.&lt;br/&gt;
   Overrid setStream to discard the stream descriptor when a new stream is set for the DVD.&lt;/p&gt;

&lt;p&gt;Patch ready for review.&lt;br/&gt;
I will commit this shortly, but since the code isn&apos;t used yet it should be harmless. That shouldn&apos;t stop any reviewers though!&lt;br/&gt;
I&apos;ll also post the next patch shortly.&lt;/p&gt;</comment>
                            <comment id="12663349" author="kristwaa" created="Tue, 13 Jan 2009 14:54:31 +0000"  >&lt;p&gt;Committed patch 4a to trunk with revision 734148.&lt;/p&gt;</comment>
                            <comment id="12663360" author="kristwaa" created="Tue, 13 Jan 2009 15:43:53 +0000"  >&lt;p&gt;Patch &apos;derby-3907-5a-use_getStreamWithDescriptor.diff&apos; takes the new StringDataValue.getStreamWithDescriptor() into use.&lt;/p&gt;

&lt;p&gt;Description of changes:&lt;br/&gt;
 o EmbedClob&lt;br/&gt;
   Changed constructor to take a StringDataValue instead of a DataValueDescriptor.&lt;br/&gt;
   Updated call to the StoreStreamClob constructor.&lt;/p&gt;

&lt;p&gt; o EmbedResultSet&lt;br/&gt;
   Started using the getStreamWithDescriptor method and updated invocations of the UTF8Reader constructor.&lt;/p&gt;

&lt;p&gt; o StoreStreamClob&lt;br/&gt;
   Added a CharacterStreamDescriptor, and made the constructor take one as an argument.&lt;br/&gt;
   Adapted the class to use a CSD.&lt;/p&gt;

&lt;p&gt; o UTF8Reader&lt;br/&gt;
   Updated some comments.&lt;br/&gt;
   Fixed bug where the header length wasn&apos;t added to the byte length of the stream, and updated the class appropriately (adjusted utfCount, fixed the reset routine).&lt;br/&gt;
   Made sure the header bytes are skipped (either by skipping them in the constructor or by adjusting the position to on the next reposition).&lt;/p&gt;

&lt;p&gt; o ResultSetStreamTest&lt;br/&gt;
   Added a test for maxFieldSize, where truncation have to happen.&lt;/p&gt;

&lt;p&gt; o Various tests&lt;br/&gt;
   Adjusted tests to run with the new implementation.&lt;/p&gt;

&lt;p&gt;Patch ready for review.&lt;br/&gt;
Regression tests ran cleanly, but due to a last minute change I have to rerun them again. I will post the results tomorrow.&lt;/p&gt;</comment>
                            <comment id="12663444" author="kristwaa" created="Tue, 13 Jan 2009 19:53:47 +0000"  >&lt;p&gt;Rerun of the regression tests (derbyall and suites.All)  successful, no errors/failures.&lt;/p&gt;</comment>
                            <comment id="12664048" author="kristwaa" created="Thu, 15 Jan 2009 08:57:44 +0000"  >&lt;p&gt;Committed patch 5a to trunk with revision 734630.&lt;/p&gt;

&lt;p&gt;A quick comment on the following piece of code from EmbedResultSet.getCharacterStream:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;    CharacterStreamDescriptor csd = dvd.getStreamWithDescriptor();&lt;/p&gt;

&lt;p&gt;    if (csd == null) {&lt;/p&gt;

&lt;p&gt;        String val = dvd.getString();&lt;br/&gt;
        if (lmfs &amp;gt; 0) &lt;/p&gt;
{
            if (val.length() &amp;gt; lmfs)
                val = val.substring(0, lmfs);
        }
&lt;p&gt;        java.io.Reader ret = new java.io.StringReader(val);&lt;br/&gt;
        currentStream = ret;&lt;br/&gt;
        return ret;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;    // See if we have to enforce a max field size.&lt;br/&gt;
    if (lmfs &amp;gt; 0) &lt;/p&gt;
{
        csd = new CharacterStreamDescriptor.Builder().copyState(csd).
                maxCharLength(lmfs).build();
    }
&lt;p&gt;    java.io.Reader ret = new UTF8Reader(csd, this, syncLock);&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;The last &quot;if (lmfs &amp;gt; 0)&quot; statement will never be run as long as SQLChar.getStreamWithDescriptor() returns null, because then the value will be materialized (SQLChar.getString()).&lt;br/&gt;
We can allow non-Clob values to be treated as streams as well, but I&apos;m not sure it is worth it due to the limited size (max 32700 chars).&lt;br/&gt;
Opinons?&lt;/p&gt;</comment>
                            <comment id="12664171" author="kristwaa" created="Thu, 15 Jan 2009 17:07:23 +0000"  >&lt;p&gt;Attached a bug fix (6a)  for a problem where the stream could get out of sync with the descriptor.&lt;/p&gt;

&lt;p&gt;Committed to trunk with revision 734758.&lt;/p&gt;</comment>
                            <comment id="12664531" author="kristwaa" created="Fri, 16 Jan 2009 14:44:47 +0000"  >&lt;p&gt;Patch &apos;derby-3907-7a-write_new_header_format-PREVIEW.diff&apos; enables the new header format.&lt;/p&gt;

&lt;p&gt;I ran into some problems with obtaining the version of the database being written into, so I had to change where the header is generated. To be able to use the context service to gain access to the data dictionary, there must be context. The context is not pushed in for instance EmbedPreparedStatement.setCharacterStream. To solve this, I added the requirement that StringDataValue.generateStreamHeader has to be invoked when a context is set up.&lt;/p&gt;

&lt;p&gt;The new approach is to generate the header when the store is asking for the data (during execute), which happens in ReaderToUTF8Stream.fillBuffer. The downside of the approach, is that ReaderToUTF8Stream now takes StringDataValue as an argument in the constructor. This makes a lot more code available in the reader, and it also makes the reader harder to test.&lt;/p&gt;

&lt;p&gt;I also considered adding a method to tell the DVD the version of the database, but I think it will be hard to make Derby invoke this method in all valid use-cases, and it breaks with the pattern used in the existing classes.&lt;br/&gt;
A second option is to add a stream header generation object, which can be passed in to ReaderToUTF8Stream. I think this can be done by modifying/replacing the StreamHeaderHolder, and I think it can be done easily. The difference is that the header generation will be postponed.&lt;/p&gt;

&lt;p&gt;I&apos;ll continue the work on Monday, and I will most likely post another patch implementing the approach with a separate class generating the header.&lt;/p&gt;

&lt;p&gt;Please comment if you think I&apos;m heading down the wrong road.&lt;/p&gt;</comment>
                            <comment id="12665834" author="kristwaa" created="Wed, 21 Jan 2009 14:27:32 +0000"  >&lt;p&gt;The patch &apos;derby-3907-7a-write_new_header_format.diff&apos; is the second attempt at implementing the handling of the new stream header format.&lt;/p&gt;

&lt;p&gt;Hopefully, the performance of reading/writing CHAR, VARCHAR and LONG VARCHAR hasn&apos;t suffered, but I&apos;ll run some performance tests to confirm it. The performance for reading the old header format for Clobs (i.e. accessing old databases) may suffer a little bit, because in some situations too many bytes are read and the stream has to be reset before reading it again. I need to test this as well.&lt;/p&gt;

&lt;p&gt;Description of the changes:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;EmbedResultSet&lt;br/&gt;
   Adjusted the usage of the ReaderToUTF8Stream constructor. Note the usage of &apos;setSoftUpgradeMode&apos;, which is required because the stream can be read and written when the context stack hasn&apos;t been set up. This is true for updatable result sets. When there is no context, the context service fails to obtain the DatabaseContext used by the generator to get to the data dictionary.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;EmbedPreparedStatement&lt;br/&gt;
   Adjusted the usage of the ReaderToUTF8Stream constructor.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ArrayInputStream&lt;br/&gt;
   Added an argument to &apos;readDerbyUTF&apos;. The stream header is now read outside of this method.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;StreamHeaderGenerator&lt;br/&gt;
   Added an interface for generating stream headers.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;CharStreamHeaderGenerator&lt;br/&gt;
   New class generating old-style headers (two bytes long). Always used for CHAR, VARCHAR and LONG VARCHAR. In addition, it is also used for CLOB in pre 10.5 databases (i.e. soft upgrade mode).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ClobStreamHeaderGenerator&lt;br/&gt;
   New class generating new-style headers (five bytes long). Used only for CLOBs written into a 10.5 database. If a old-style header is needed, the work is delegated to CharStreamHeaderGenerator.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ReaderToUTF8Stream&lt;br/&gt;
   Added  a StreamHeaderGenerator to the constructors, and updated the header writing logic to use it. Also added a constant to distinguish the first invocation of &apos;fillBuffer&apos;. The header is generated on the first invocation, and possibly updated again in &apos;checkSufficientData&apos;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;StringDataValue&lt;br/&gt;
   Replaced method &apos;generateStreamHeader(long)&apos; with &apos;getStreamHeaderGenerator()&apos;. Added method &apos;setSoftUpgradeMode&apos;. The latter is used in situations where the generator itself is unable to determine of the database being written into is in soft upgrade mode.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SQLChar&lt;br/&gt;
   Factored out code to write the modified UTF-8 format (see &apos;writeUTF&apos;). Updated &apos;writeExternal&apos;, which will now only be invoked for non-CLOB data values. Added method &apos;writeClobUTF&apos;, which is used to write CLOB data values. It is kept in SQLChar to avoid having to make more of the internal state available to the subclasses. Added a second version of &apos;readExternal&apos;, which is the one doing the actual work. It takes both a byte count and a char count, where both can can by unknown. Implemented the new method in StringDataValue.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SQLClob&lt;br/&gt;
   Added variable &apos;inSoftUpgradeMode&apos;, which tells if the DVD is used in a database being in soft upgrade mode or not. This must be known to generate the correct header format.  Note that this may be unknown, in which case the header generator itself will try to determine the mode. Implemented &apos;getLength&apos;, which will obtain the length from the stream header, delegate the work to &apos;SQLChar.getLength&apos; if the value is not a stream, or decode the stream data if the length is not stored in the header. The data value is not materialized. Added support to read both stream header formats in &apos;getStreamWithDescriptor&apos;. Implemented &apos;investigateStream&apos; to decode the header.  Added &apos;writeExternal&apos;, &apos;readExternal&apos; and &apos;readExternalFromArray&apos;. In general, some preparation steps are taken and then the work is delegated to SQLChar. Added utility class HeaderInfo.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;StreamHeaderHolder&lt;br/&gt;
   Deleted the class.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;UTF8UtilTest&lt;br/&gt;
   Updated code to use the new generator class.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Patch ready for review.&lt;br/&gt;
I have run the regression tests without failures, but due to a small last minute change I will run them again tonight.&lt;br/&gt;
I have also tried reading and writing Clob from a 10.4 database manually, both in soft and hard upgrade mode.&lt;/p&gt;

&lt;p&gt;Based on Mike&apos;s suggestion, I was hoping that a table compress would update the old headers to the new header format after a hard upgrade. This is in principle correct, but the new header is written with &quot;unknown length&quot; encoded. I haven&apos;t investigated how to best solve this problem.&lt;/p&gt;</comment>
                            <comment id="12665847" author="kristwaa" created="Wed, 21 Jan 2009 15:02:21 +0000"  >&lt;p&gt;Replaced patch 7a (removed two lines of debugging code).&lt;/p&gt;</comment>
                            <comment id="12666125" author="kristwaa" created="Thu, 22 Jan 2009 11:50:11 +0000"  >&lt;p&gt;I decided to split up patch 7a due to its size.&lt;br/&gt;
Patch 7a1 adds the new stream header generator classes (one interface, two implementations).&lt;/p&gt;

&lt;p&gt;Committed to trunk with revision 736612.&lt;/p&gt;</comment>
                            <comment id="12666140" author="kristwaa" created="Thu, 22 Jan 2009 13:31:53 +0000"  >&lt;p&gt;Patch &apos;derby-3907-7a2-use_new_framework.diff&apos; is the second part of 7a.&lt;br/&gt;
It prepares the code to deal with multiple stream header formats, but doesn&apos;t change the current behavior regarding stream headers.&lt;/p&gt;

&lt;p&gt;Committed to trunk with revision 736636.&lt;/p&gt;

&lt;p&gt;I will upload the next patch, but will wait a few days before I commit it to see if any problems are detected with patch 7a2.&lt;/p&gt;</comment>
                            <comment id="12666458" author="kristwaa" created="Fri, 23 Jan 2009 09:47:54 +0000"  >&lt;p&gt;Patch 7a3 is the patch that enables the new header format.&lt;br/&gt;
I plan to commit this Tuesday or Wednesday next week.&lt;/p&gt;

&lt;p&gt;Patch ready for review.&lt;/p&gt;

&lt;p&gt;Remaining work:&lt;br/&gt;
 o Determine if the database version should be kept in the Database object.&lt;br/&gt;
    It all depends on how expensive it is to consult the data dictionary about the version.&lt;br/&gt;
 o Investigate upgrade further to understand whether long columns can easily be upgraded with a new header or not.&lt;br/&gt;
 o (stretch task) Investigate how to add the functionality to update only the first few bytes of a data value.&lt;/p&gt;

&lt;p&gt;NOTE: After this patch has been committed, databases containing CLOBs written with a Derby revision after the commit cannot be read with a Derby revision before the commit.&lt;/p&gt;</comment>
                            <comment id="12667971" author="kristwaa" created="Wed, 28 Jan 2009 09:06:25 +0000"  >&lt;p&gt;Committed patch 7a3 to trunk with revision 738408.&lt;/p&gt;

&lt;p&gt;I think some code in SQLChar can be removed now, but I&apos;ll wait a little while before I start looking at it.&lt;br/&gt;
As noted earlier, databases created with revision 738408 or later containing Clobs cannot be used with earlier revisions any more.&lt;/p&gt;</comment>
                            <comment id="12682896" author="myrna" created="Wed, 18 Mar 2009 03:26:56 +0000"  >&lt;p&gt;It looks like most of the work for this issue has been completed for 10.5.&lt;br/&gt;
Is it possible to log a new issue for the remaining tasks?&lt;br/&gt;
Does this require a release note?&lt;/p&gt;</comment>
                            <comment id="12683071" author="kristwaa" created="Wed, 18 Mar 2009 16:47:54 +0000"  >&lt;p&gt;I&apos;ll log at least one new issue, tracking the final piece of the functionality required to insert the required meta data for Clobs inserted with one of the JDBC 4.0 &quot;length-less overrides&quot;.&lt;/p&gt;

&lt;p&gt;I don&apos;t think this issue requires a release note, but I&apos;ll comment on a few things before I close the issue.&lt;/p&gt;</comment>
                            <comment id="12866616" author="kristwaa" created="Wed, 12 May 2010 17:26:01 +0100"  >&lt;p&gt;See &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4652&quot; title=&quot;Provide mean to save length information when inserting CLOBs using the JDBC 4.0 &amp;quot;length less overrides&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4652&quot;&gt;DERBY-4652&lt;/a&gt; for a possible improvement (dealing with JDBC 4.0 &quot;length less overrides&quot;).&lt;/p&gt;</comment>
                            <comment id="12866618" author="kristwaa" created="Wed, 12 May 2010 17:26:34 +0100"  >&lt;p&gt;Closing.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12464326">DERBY-4652</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12394740" name="derby-3907-1a-alternative_approach.diff" size="12416" author="kristwaa" created="Wed, 26 Nov 2008 13:07:09 +0000"/>
                            <attachment id="12397419" name="derby-3907-2b-header_write_preparation.diff" size="14557" author="kristwaa" created="Thu, 8 Jan 2009 13:32:47 +0000"/>
                            <attachment id="12397124" name="derby-3907-2b-header_write_preparation.diff" size="14986" author="kristwaa" created="Mon, 5 Jan 2009 14:08:45 +0000"/>
                            <attachment id="12397125" name="derby-3907-2b-header_write_preparation.stat" size="470" author="kristwaa" created="Mon, 5 Jan 2009 14:08:45 +0000"/>
                            <attachment id="12397521" name="derby-3907-2c-header_write_preparation-PREVIEW.diff" size="38962" author="kristwaa" created="Fri, 9 Jan 2009 14:49:01 +0000"/>
                            <attachment id="12397522" name="derby-3907-2c-header_write_preparation-PREVIEW.stat" size="728" author="kristwaa" created="Fri, 9 Jan 2009 14:49:01 +0000"/>
                            <attachment id="12397716" name="derby-3907-2c-header_write_preparation.diff" size="49433" author="kristwaa" created="Mon, 12 Jan 2009 20:42:33 +0000"/>
                            <attachment id="12397687" name="derby-3907-2c-header_write_preparation.diff" size="48857" author="kristwaa" created="Mon, 12 Jan 2009 13:27:58 +0000"/>
                            <attachment id="12397688" name="derby-3907-2c-header_write_preparation.stat" size="728" author="kristwaa" created="Mon, 12 Jan 2009 13:27:58 +0000"/>
                            <attachment id="12397298" name="derby-3907-3a-readertoutf8stream_cleanup.diff" size="18248" author="kristwaa" created="Wed, 7 Jan 2009 13:50:56 +0000"/>
                            <attachment id="12397296" name="derby-3907-3a-readertoutf8stream_cleanup.diff" size="18249" author="kristwaa" created="Wed, 7 Jan 2009 13:45:09 +0000"/>
                            <attachment id="12397297" name="derby-3907-3a-readertoutf8stream_cleanup.stat" size="289" author="kristwaa" created="Wed, 7 Jan 2009 13:45:09 +0000"/>
                            <attachment id="12397408" name="derby-3907-3b-readertoutf8stream_cleanup.diff" size="14961" author="kristwaa" created="Thu, 8 Jan 2009 10:28:54 +0000"/>
                            <attachment id="12397777" name="derby-3907-4a-add_getStreamWithDescriptor.diff" size="12930" author="kristwaa" created="Tue, 13 Jan 2009 13:53:44 +0000"/>
                            <attachment id="12397776" name="derby-3907-4a-add_getStreamWithDescriptor.stat" size="265" author="kristwaa" created="Tue, 13 Jan 2009 13:53:44 +0000"/>
                            <attachment id="12397793" name="derby-3907-5a-use_getStreamWithDescriptor.diff" size="31075" author="kristwaa" created="Tue, 13 Jan 2009 15:43:53 +0000"/>
                            <attachment id="12397792" name="derby-3907-5a-use_getStreamWithDescriptor.stat" size="795" author="kristwaa" created="Tue, 13 Jan 2009 15:43:53 +0000"/>
                            <attachment id="12397981" name="derby-3907-6a-SQLClob_stream_descriptor_sync.diff" size="1237" author="kristwaa" created="Thu, 15 Jan 2009 17:07:23 +0000"/>
                            <attachment id="12398073" name="derby-3907-7a-write_new_header_format-PREVIEW.diff" size="44728" author="kristwaa" created="Fri, 16 Jan 2009 14:44:47 +0000"/>
                            <attachment id="12398405" name="derby-3907-7a-write_new_header_format.diff" size="77382" author="kristwaa" created="Wed, 21 Jan 2009 15:02:21 +0000"/>
                            <attachment id="12398399" name="derby-3907-7a-write_new_header_format.diff" size="77548" author="kristwaa" created="Wed, 21 Jan 2009 14:27:32 +0000"/>
                            <attachment id="12398400" name="derby-3907-7a-write_new_header_format.stat" size="853" author="kristwaa" created="Wed, 21 Jan 2009 14:27:32 +0000"/>
                            <attachment id="12398464" name="derby-3907-7a1-write_new_header_format.diff" size="20794" author="kristwaa" created="Thu, 22 Jan 2009 11:50:11 +0000"/>
                            <attachment id="12398466" name="derby-3907-7a2-use_new_framework.diff" size="29706" author="kristwaa" created="Thu, 22 Jan 2009 13:31:53 +0000"/>
                            <attachment id="12398467" name="derby-3907-7a2-use_new_framework.stat" size="552" author="kristwaa" created="Thu, 22 Jan 2009 13:31:53 +0000"/>
                            <attachment id="12398538" name="derby-3907-7a3-use_new_header_format.diff" size="28152" author="kristwaa" created="Fri, 23 Jan 2009 09:47:54 +0000"/>
                            <attachment id="12398539" name="derby-3907-7a3-use_new_header_format.stat" size="269" author="kristwaa" created="Fri, 23 Jan 2009 09:47:54 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 10 Oct 2008 17:02:07 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31051</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0qbj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38082</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>