<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:29:09 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-634/DERBY-634.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-634] Subquery materialization can cause stack overflow</title>
                <link>https://issues.apache.org/jira/browse/DERBY-634</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;A performance optimization in subquery processing can cause a stack overflow.&lt;/p&gt;

&lt;p&gt;The optimization materializes a subquery ResultSet in memory where it thinks the rows will fit in memory. The materialization is done as a  set of  nested unions of constant rows (UnionResultSets and RowResultSets). If there are a lot of rows this can cause a stack overflow when fetching a row.&lt;/p&gt;

&lt;p&gt;The obvious fix is to make it use an iterative technique rather than a recursive one for storing and returning the rows. See the method BaseActivation.materializeResultSetIfPossible() in the language execution code.&lt;/p&gt;

&lt;p&gt;There are some other issues with this performance optimization that should be looked at:&lt;/p&gt;

&lt;p&gt;1) The optimization can backfire, making the query run much slower. For example, in the query:&lt;/p&gt;

&lt;p&gt;    select * from one_row_table where column1 not in&lt;br/&gt;
        (select column2 from million_row_table)&lt;/p&gt;

&lt;p&gt;reading million_row_table into memory is an expensive operation. If there is an index on million_row_table.column2, the query should return a result very quickly despite the large size of million_row_table by doing a single probe into million_row_table via the index.&lt;/p&gt;

&lt;p&gt;Since in-memory materialization can be an expensive operation, the decision about whether to do it should be made based on query optimizer cost estimates. See SubqueryNode.generateExpression().&lt;/p&gt;

&lt;p&gt;2) It may not be wise to cache partial query results in memory at all. Although this can help performance in some cases, it also chews up memory. This is different from a limited-size cache with a backing store (like what the store uses for page caching). The language has no way to limit the total amount of memory used in this type of processing. Note that hash joins originally used in-memory hash tables with no backing store, and that a backing store was added later.&lt;/p&gt;

&lt;p&gt;3) The implementation of this optimization has some problems. The decision to materialize the subquery results in memory is made during code generation - all such decisions should be made during the compilation phase. It&apos;s not clear to me why materializeResultSetIfPossible() is in BaseActivation - I would expect the of materialization to be done by a type of ResultSet, not by a method in BaseActivation. Also, this method calls getMaxMemoryPerTable() in the OptimizerFactory - nothing in the execution code should refer to anything in the compilation code (perhaps getMaxMemoryPerTable() should be moved somewhere else).&lt;/p&gt;</description>
                <environment></environment>
        <key id="12318179">DERBY-634</key>
            <summary>Subquery materialization can cause stack overflow</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="bandaram">Satheesh Bandaram</assignee>
                                    <reporter username="jeff_lichtman">Jeff Lichtman</reporter>
                        <labels>
                    </labels>
                <created>Fri, 21 Oct 2005 06:16:23 +0100</created>
                <updated>Sun, 20 Aug 2006 03:22:56 +0100</updated>
                            <resolved>Sun, 20 Aug 2006 03:22:44 +0100</resolved>
                                    <version>10.1.2.1</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12332711" author="rhillegas" created="Sat, 22 Oct 2005 00:22:24 +0100"  >&lt;p&gt;Satheesh adds this explanation:&lt;/p&gt;

&lt;p&gt;Thanks Jeff, great analysis... It seems to me it was originally intended&lt;br/&gt;
to cache a small number of subquery result rows, but the code didn&apos;t&lt;br/&gt;
seem to implement it that way. Implementing the &quot;optimization&quot; at&lt;br/&gt;
runtime was probably chosen to make sure only small number of rows are&lt;br/&gt;
returned by the subquery. Like you said, using nested unions seems like&lt;br/&gt;
a bad idea too.&lt;/p&gt;

&lt;p&gt;Any ideas on how to unoptimize without loosing performance gain some&lt;br/&gt;
queries might be getting now? It seems the &quot;optimization&quot; was done for a&lt;br/&gt;
specific customer query that is supposedly improved performance by 100&lt;br/&gt;
times...&lt;/p&gt;

&lt;p&gt;Satheesh&lt;/p&gt;</comment>
                            <comment id="12332880" author="jeff_lichtman" created="Sun, 23 Oct 2005 08:00:44 +0100"  >&lt;p&gt;In response to Sateesh&apos;s question: it&apos;s hard to know how to fix this problem without causing a performance regression without seeing the customer&apos;s original query.&lt;/p&gt;

&lt;p&gt;One thing I find perplexing about this problem is that, by the time the compiler gets to code generation (where the decision is made to materialize the subquery), the NOT IN subquery should have been converted to a correlated subquery, and the optimization disallowed. That is:&lt;/p&gt;

&lt;p&gt;   select  path from filesystemfiles where path not in&lt;br/&gt;
        (select path from existingfiles)&lt;/p&gt;

&lt;p&gt;should have been converted to a query tree equivalent to something like this:&lt;/p&gt;

&lt;p&gt;    select path from filesystemfiles where not exists&lt;br/&gt;
        (select * from existingfiles where existingfiles.path = filesystemfiles.path)&lt;/p&gt;

&lt;p&gt;Thus the subquery should not be materialized in this case.&lt;/p&gt;

&lt;p&gt;The rewritten query (as above) was suggested to the user who originally reported this problem. The stack overflow didn&apos;t happen when he used this version of the query.&lt;/p&gt;

&lt;p&gt;Another interesting thing is that there is other logic in SubqueryNode having to do with materializing subqueries that seems to handle different cases than the one here.&lt;/p&gt;</comment>
                            <comment id="12424249" author="kmarsden" created="Sat, 29 Jul 2006 02:00:22 +0100"  >&lt;p&gt;This is not a regression for Derby but is  a serious bug from an old fix before Derby became Derby,  so certainly would be good to see fixed for 10.2&lt;/p&gt;</comment>
                            <comment id="12427670" author="bandaram" created="Sat, 12 Aug 2006 02:21:46 +0100"  >&lt;p&gt;I propose twhere Table2.x=Table3.x and y &amp;gt; 100)&lt;br/&gt;
o address this issue in phases. Here is my current thinking:&lt;/p&gt;

&lt;p&gt;Background information:&lt;br/&gt;
-----------------------&lt;/p&gt;

&lt;p&gt;A performance optimization was introduced in Cloudscape before open sourcing as Apache Derby.&lt;br/&gt;
Before this optimization was introduced, a query like:&lt;/p&gt;

&lt;p&gt;Select a, b, c from Table1 where a&amp;gt; 5 and b in &lt;br/&gt;
               (select x from Table2, Table3 &lt;br/&gt;
would take longer time time to execute than needed. This becomes worse as the complexity of the&lt;br/&gt;
subquery increases. Basic problem was that for every qualified value of &apos;b&apos;, the subquery was&lt;br/&gt;
getting executed, recreating the results multiple times. Cloudscape, at that time, had the ability&lt;br/&gt;
to materialize results of a subquery only if a single row is returned from the subquery.&lt;br/&gt;
(where subquery is of the form select max&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from Table2)&lt;/p&gt;

&lt;p&gt;A performance optimization was introduced that allowed for some &quot;small number&quot; of rows greater than&lt;br/&gt;
1 to be cached dynamically at runtime. As the subquery was executed first time, results of the&lt;br/&gt;
subquery were cached until MAX_MEMORY_PER_TABLE is reached, which was 1MG by default. If the results&lt;br/&gt;
of the subquery could be fit into memory less than this configurable size, a nested union resultset&lt;br/&gt;
would be built to cache the results.&lt;/p&gt;

&lt;p&gt;Future invocations of the subquery would simply return results from this subquery cache without&lt;br/&gt;
actually evaluating subquery. This resulted in performance boost for a customer query from 10 minutes&lt;br/&gt;
to a few seconds.&lt;/p&gt;

&lt;p&gt;Side effect of this optimization:&lt;br/&gt;
---------------------------------&lt;/p&gt;

&lt;p&gt;While the optimization worked well for the customer query, it is causing issues for the query in&lt;br/&gt;
question here. If the subquery were returning just an integer, the optimization could attempt to cache&lt;br/&gt;
1MG/4, about 250,000 rows in nested union resultsets. Nesting of this deep would cause stack overflow.&lt;/p&gt;

&lt;p&gt;Jeff Lichman also identified several other issues mentioned in the description of this entry.&lt;/p&gt;

&lt;p&gt;Proposed Fix:&lt;br/&gt;
-------------&lt;/p&gt;

&lt;p&gt;First, I think it is important to fix regression caused by this optimization. The optimization was&lt;br/&gt;
intended to cache small number of subquery results. Instead of caching single row result of a subquery,&lt;br/&gt;
this optimization could be adjusted to cache a small number of results.&lt;/p&gt;

&lt;p&gt;Second, caching results of subquery in nested union resultsets is not needed. This can be rewritten to&lt;br/&gt;
generate a linear resultset, which would save runtime stack growth.&lt;/p&gt;

&lt;p&gt;Third, as Jeff pointed out, a global subquery optimization that is performed during optimization is&lt;br/&gt;
the best approach. He pointed out subquery materialization based on hash joins decided during&lt;br/&gt;
optimization phase is the ideal solution. Fortunately, Army&apos;s optimizer enhancements introduced&lt;br/&gt;
recently builds a subquery materialization capability to Derby and this could be extended to handle&lt;br/&gt;
this case as well.&lt;/p&gt;

&lt;p&gt;I propose to address the regression first by caching only small number of rows dynamically. If number&lt;br/&gt;
of subquery results could cross 512, I think this optimization should be dynamically disabled.&lt;/p&gt;

&lt;p&gt;I will also file another Improvement that would suggest reworking the original optimization to be&lt;br/&gt;
built on Army&apos;s subquery materialization framework. My current impression is that Army&apos;s subquery&lt;br/&gt;
work needs to be more generalized and stabilized before extending to cover other cases.&lt;/p&gt;

&lt;p&gt;Let me know if anyone has any comments.&lt;/p&gt;</comment>
                            <comment id="12427671" author="bandaram" created="Sat, 12 Aug 2006 02:23:13 +0100"  >&lt;p&gt;Oops... my previous comment got little garbled. Here it is again.&lt;/p&gt;

&lt;p&gt;I propose to address this issue in phases. Here is my current thinking:&lt;/p&gt;

&lt;p&gt;Background information:&lt;br/&gt;
-----------------------&lt;/p&gt;

&lt;p&gt;A performance optimization was introduced in Cloudscape before open sourcing as Apache Derby.&lt;br/&gt;
Before this optimization was introduced, a query like:&lt;/p&gt;

&lt;p&gt;Select a, b, c from Table1 where a&amp;gt; 5 and b in &lt;br/&gt;
               (select x from Table2, Table3 where Table2.x=Table3.x and y &amp;gt; 100)&lt;/p&gt;

&lt;p&gt;would take longer time time to execute than needed. This becomes worse as the complexity of the&lt;br/&gt;
subquery increases. Basic problem was that for every qualified value of &apos;b&apos;, the subquery was&lt;br/&gt;
getting executed, recreating the results multiple times. Cloudscape, at that time, had the ability&lt;br/&gt;
to materialize results of a subquery only if a single row is returned from the subquery.&lt;br/&gt;
(where subquery is of the form select max&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from Table2)&lt;/p&gt;

&lt;p&gt;A performance optimization was introduced that allowed for some &quot;small number&quot; of rows greater than&lt;br/&gt;
1 to be cached dynamically at runtime. As the subquery was executed first time, results of the&lt;br/&gt;
subquery were cached until MAX_MEMORY_PER_TABLE is reached, which was 1MG by default. If the results&lt;br/&gt;
of the subquery could be fit into memory less than this configurable size, a nested union resultset&lt;br/&gt;
would be built to cache the results.&lt;/p&gt;

&lt;p&gt;Future invocations of the subquery would simply return results from this subquery cache without&lt;br/&gt;
actually evaluating subquery. This resulted in performance boost for a customer query from 10 minutes&lt;br/&gt;
to a few seconds.&lt;/p&gt;

&lt;p&gt;Side effect of this optimization:&lt;br/&gt;
---------------------------------&lt;/p&gt;

&lt;p&gt;While the optimization worked well for the customer query, it is causing issues for the query in&lt;br/&gt;
question here. If the subquery were returning just an integer, the optimization could attempt to cache&lt;br/&gt;
1MG/4, about 250,000 rows in nested union resultsets. Nesting of this deep would cause stack overflow.&lt;/p&gt;

&lt;p&gt;Jeff Lichman also identified several other issues mentioned in the description of this entry.&lt;/p&gt;

&lt;p&gt;Proposed Fix:&lt;br/&gt;
-------------&lt;/p&gt;

&lt;p&gt;First, I think it is important to fix regression caused by this optimization. The optimization was&lt;br/&gt;
intended to cache small number of subquery results. Instead of caching single row result of a subquery,&lt;br/&gt;
this optimization could be adjusted to cache a small number of results.&lt;/p&gt;

&lt;p&gt;Second, caching results of subquery in nested union resultsets is not needed. This can be rewritten to&lt;br/&gt;
generate a linear resultset, which would save runtime stack growth.&lt;/p&gt;

&lt;p&gt;Third, as Jeff pointed out, a global subquery optimization that is performed during optimization is&lt;br/&gt;
the best approach. He pointed out subquery materialization based on hash joins decided during&lt;br/&gt;
optimization phase is the ideal solution. Fortunately, Army&apos;s optimizer enhancements introduced&lt;br/&gt;
recently builds a subquery materialization capability to Derby and this could be extended to handle&lt;br/&gt;
this case as well.&lt;/p&gt;

&lt;p&gt;I propose to address the regression first by caching only small number of rows dynamically. If number&lt;br/&gt;
of subquery results could cross 512, I think this optimization should be dynamically disabled.&lt;/p&gt;

&lt;p&gt;I will also file another Improvement that would suggest reworking the original optimization to be&lt;br/&gt;
built on Army&apos;s subquery materialization framework. My current impression is that Army&apos;s subquery&lt;br/&gt;
work needs to be more generalized and stabilized before extending to cover other cases.&lt;/p&gt;

&lt;p&gt;Let me know if anyone has any comments.&lt;/p&gt;</comment>
                            <comment id="12427719" author="bandaram" created="Sat, 12 Aug 2006 20:34:26 +0100"  >&lt;p&gt;This patch addresses stack overflow by preventing bad cases of subquery optimization. However, extending subquery materialization work to cover these cases during optimization phase could benifit more queries. In general, Derby&apos;s subquery handling could be improved.&lt;/p&gt;
</comment>
                            <comment id="12428385" author="kmarsden" created="Wed, 16 Aug 2006 13:42:03 +0100"  >&lt;p&gt;Thanks Satheesh for the fix and for filing the follow up issue.  I wanted to clarify a couple of things for a user tracking this issue.&lt;/p&gt;

&lt;p&gt;The patch description says:&lt;/p&gt;

&lt;p&gt;&quot;This patch addresses stack overflow by preventing bad cases of subquery optimization. However, extending subquery materialization work to cover these cases during optimization phase could benifit more queries.&quot;&lt;/p&gt;

&lt;p&gt;1) Might there still  be other queries that could encounter stack overflow due to this issue?&lt;/p&gt;

&lt;p&gt;2) For a user tracking &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-634&quot; title=&quot;Subquery materialization can cause stack overflow&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-634&quot;&gt;&lt;del&gt;DERBY-634&lt;/del&gt;&lt;/a&gt;, can they consider this patch a comprehensive fix for the issue, or should they track the new issue as well?&lt;/p&gt;

&lt;p&gt;Thanks again for the fix and for helping me understand what is fixed and needs to be fixed moving forward.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;
</comment>
                            <comment id="12428436" author="bandaram" created="Wed, 16 Aug 2006 17:55:15 +0100"  >&lt;p&gt;Kathey, here are some answers...&lt;/p&gt;

&lt;p&gt;1) No... There was a specific bug in the original optimization that could cause stack overflow. That bug has been correctly fixed. There should be no cases of stack overflow now.&lt;br/&gt;
2) This is a comprehensive fix to the stack overflow problem. I was only saying generalizing the optimization that was implemented long time ago to be based on new subquery materialization framework would improve performance for more classes of queries. This would be an improvement request, like we already have several optimizer/preprocess improvements. Army and myself compiled about 10 known optimizations that could be implemented in Derby. You can say this would be another.. But this has nothing to do with stack overflow problem itself.&lt;/p&gt;

&lt;p&gt;If this is not clear, let me know. I can provide more info.&lt;/p&gt;</comment>
                            <comment id="12429225" author="bandaram" created="Sat, 19 Aug 2006 22:15:39 +0100"  >&lt;p&gt;I would like this fix backported to 10.2 release as soon as possible. Have a customer that is waiting for this fix for a long time.&lt;/p&gt;</comment>
                            <comment id="12429226" author="bandaram" created="Sat, 19 Aug 2006 22:16:52 +0100"  >&lt;p&gt;I am closing this issue as I am not doing any further work. But I would appreciate if someone can port this fix to 10.2 beta and then reopen this task to mark as such.&lt;/p&gt;</comment>
                            <comment id="12429239" author="fuzzylogic" created="Sun, 20 Aug 2006 03:22:01 +0100"  >&lt;p&gt;reopening to change Fix In version.&lt;/p&gt;</comment>
                            <comment id="12429240" author="fuzzylogic" created="Sun, 20 Aug 2006 03:22:44 +0100"  >&lt;p&gt;Merged to 10.2 with revision 432715.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12348281">DERBY-1733</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12338751" name="DERBY-634.diff" size="8163" author="bandaram" created="Sat, 12 Aug 2006 20:34:26 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 21 Oct 2005 23:22:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22062</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy14uf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40435</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>