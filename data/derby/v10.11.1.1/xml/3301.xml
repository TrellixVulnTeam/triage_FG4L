<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:23:28 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3301/DERBY-3301.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3301] Incorrect result from query with nested EXIST</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3301</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Derby returns unexpected results from a query with embedded EXIST clauses. The query SQL is generated by the JPOX jdo implementation and is supposed to return all of the PERSONS and PROJECTS where there is an entry in the join table. This query works as expected when using MySQL.&lt;/p&gt;

&lt;p&gt;Here&apos;s the query:&lt;/p&gt;

&lt;p&gt;SELECT UNBOUND_E.PERSONID, UNBOUND_P.PROJID &lt;br/&gt;
FROM applicationidentity0.DEPARTMENTS THIS, &lt;br/&gt;
     applicationidentity0.PERSONS UNBOUND_E, &lt;br/&gt;
     applicationidentity0.PROJECTS UNBOUND_P &lt;br/&gt;
WHERE EXISTS ( &lt;br/&gt;
    SELECT 1 FROM applicationidentity0.PERSONS THIS_EMPLOYEES_E &lt;br/&gt;
    WHERE EXISTS ( &lt;br/&gt;
        SELECT 1 FROM applicationidentity0.PROJECT_MEMBER THIS_EMPLOYEES_E_PROJECTS_P &lt;br/&gt;
        WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;MEMBER&quot; = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
        AND THIS_EMPLOYEES_E_PROJECTS_P.&quot;MEMBER&quot; = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
        AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID &lt;br/&gt;
        AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID &lt;br/&gt;
        AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID &lt;br/&gt;
        AND UNBOUND_E.PERSONID = THIS_EMPLOYEES_E.PERSONID) &lt;br/&gt;
    );&lt;br/&gt;
PERSONID   |PROJID     &lt;br/&gt;
-----------------------&lt;br/&gt;
3          |1          &lt;br/&gt;
5          |3          &lt;br/&gt;
4          |3          &lt;br/&gt;
2          |1          &lt;br/&gt;
1          |1          &lt;br/&gt;
5 rows selected&lt;/p&gt;

&lt;p&gt;I&apos;m expecting 7 rows to be returned here, one row for each row in the join table. &lt;/p&gt;

&lt;p&gt;Here&apos;s the schema:&lt;br/&gt;
CREATE TABLE departments (&lt;br/&gt;
    ID INTEGER NOT NULL,&lt;br/&gt;
    NAME VARCHAR(32) NOT NULL,&lt;br/&gt;
    EMP_OF_THE_MONTH INTEGER,&lt;br/&gt;
    COMPANYID INTEGER,&lt;br/&gt;
    DISCRIMINATOR VARCHAR(255),&lt;br/&gt;
    CONSTRAINT DEPTS_COMP_FK FOREIGN KEY (COMPANYID) REFERENCES companies,&lt;br/&gt;
    CONSTRAINT DEPTS_PK PRIMARY KEY (ID)&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;CREATE TABLE persons (&lt;br/&gt;
    PERSONID INTEGER NOT NULL,&lt;br/&gt;
    FIRSTNAME VARCHAR(32) NOT NULL,&lt;br/&gt;
    LASTNAME VARCHAR(32) NOT NULL,&lt;br/&gt;
    MIDDLENAME VARCHAR(32),&lt;br/&gt;
    BIRTHDATE TIMESTAMP NOT NULL,&lt;br/&gt;
    ADDRID INTEGER,&lt;br/&gt;
    STREET VARCHAR(64),&lt;br/&gt;
    CITY VARCHAR(64),&lt;br/&gt;
    STATE CHAR(2),&lt;br/&gt;
    ZIPCODE CHAR(5),&lt;br/&gt;
    COUNTRY VARCHAR(64),&lt;br/&gt;
    HIREDATE TIMESTAMP,&lt;br/&gt;
    WEEKLYHOURS REAL,&lt;br/&gt;
    DEPARTMENT INTEGER,&lt;br/&gt;
    FUNDINGDEPT INTEGER,&lt;br/&gt;
    MANAGER INTEGER,&lt;br/&gt;
    MENTOR INTEGER,&lt;br/&gt;
    HRADVISOR INTEGER,&lt;br/&gt;
    SALARY REAL,&lt;br/&gt;
    WAGE REAL,&lt;br/&gt;
    DISCRIMINATOR varchar(255) NOT NULL,&lt;br/&gt;
    CONSTRAINT PERS_DEPT_FK FOREIGN KEY (DEPARTMENT) REFERENCES departments,&lt;br/&gt;
    CONSTRAINT PERS_FUNDDEPT_FK FOREIGN KEY (FUNDINGDEPT) REFERENCES departments,&lt;br/&gt;
    CONSTRAINT PERS_MANAGER_FK FOREIGN KEY (MANAGER) REFERENCES persons,&lt;br/&gt;
    CONSTRAINT PERS_MENTOR_FK FOREIGN KEY (MENTOR) REFERENCES persons,&lt;br/&gt;
    CONSTRAINT PERS_HRADVISOR_FK FOREIGN KEY (HRADVISOR) REFERENCES persons,&lt;br/&gt;
    CONSTRAINT EMPS_PK PRIMARY KEY (PERSONID)&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;CREATE TABLE projects (&lt;br/&gt;
    PROJID INTEGER NOT NULL,&lt;br/&gt;
    NAME VARCHAR(32) NOT NULL,&lt;br/&gt;
    BUDGET DECIMAL(11,2) NOT NULL,&lt;br/&gt;
    DISCRIMINATOR VARCHAR(255),&lt;br/&gt;
    CONSTRAINT PROJS_PK PRIMARY KEY (PROJID)&lt;br/&gt;
);&lt;br/&gt;
CREATE TABLE project_member (&lt;br/&gt;
    PROJID INTEGER REFERENCES projects NOT NULL,&lt;br/&gt;
    MEMBER INTEGER REFERENCES persons NOT NULL&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;ij&amp;gt; connect &apos;jdbc:derby:/Users/clr/apache/jdo/trunk/tck2/target/database/derby/jdotckdb&apos;;&lt;br/&gt;
ij&amp;gt; set schema applicationidentity0;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from persons;&lt;br/&gt;
PERSONID   |FIRSTNAME                       |LASTNAME                        |MIDDLENAME                      |BIRTHDATE                 |ADDRID     |STREET                                                          |CITY                                                            |STA&amp;amp;|ZIPC&amp;amp;|COUNTRY                                                         |HIREDATE                  |WEEKLYHOURS  |DEPARTMENT |FUNDINGDEPT|MANAGER    |MENTOR     |HRADVISOR  |SALARY       |WAGE         |DISCRIMINATOR                                                                                                                   &lt;br/&gt;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
1          |emp1First                       |emp1Last                        |emp1Middle                      |1970-06-09 21:00:00.0     |NULL       |NULL                                                            |NULL                                                            |NULL|NULL |NULL                                                            |1998-12-31 21:00:00.0     |40.0         |NULL       |NULL       |NULL       |NULL       |NULL       |20000.0      |NULL         |org.apache.jdo.tck.pc.company.FullTimeEmployee                                                                                  &lt;br/&gt;
2          |emp2First                       |emp2Last                        |emp2Middle                      |1975-12-21 21:00:00.0     |NULL       |NULL                                                            |NULL                                                            |NULL|NULL |NULL                                                            |2003-06-30 21:00:00.0     |40.0         |NULL       |NULL       |NULL       |NULL       |NULL       |10000.0      |NULL         |org.apache.jdo.tck.pc.company.FullTimeEmployee                                                                                  &lt;br/&gt;
3          |emp3First                       |emp3Last                        |emp3Middle                      |1972-09-04 21:00:00.0     |NULL       |NULL                                                            |NULL                                                            |NULL|NULL |NULL                                                            |2002-08-14 21:00:00.0     |19.0         |NULL       |NULL       |NULL       |NULL       |NULL       |NULL         |15.0         |org.apache.jdo.tck.pc.company.PartTimeEmployee                                                                                  &lt;br/&gt;
4          |emp4First                       |emp4Last                        |emp4Middle                      |1973-09-05 21:00:00.0     |NULL       |NULL                                                            |NULL                                                            |NULL|NULL |NULL                                                            |2001-04-14 21:00:00.0     |0.0          |NULL       |NULL       |NULL       |NULL       |NULL       |NULL         |13.0         |org.apache.jdo.tck.pc.company.PartTimeEmployee                                                                                  &lt;br/&gt;
5          |emp5First                       |emp5Last                        |emp5Middle                      |1962-07-04 21:00:00.0     |NULL       |NULL                                                            |NULL                                                            |NULL|NULL |NULL                                                            |1998-08-14 21:00:00.0     |0.0          |NULL       |NULL       |NULL       |NULL       |NULL       |45000.0      |NULL         |org.apache.jdo.tck.pc.company.FullTimeEmployee                                                                                  &lt;/p&gt;

&lt;p&gt;5 rows selected&lt;br/&gt;
ij&amp;gt; select * from projects;&lt;br/&gt;
PROJID     |NAME                            |BUDGET       |DISCRIMINATOR                                                                                                                   &lt;br/&gt;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
1          |orange                          |2500000.99   |org.apache.jdo.tck.pc.company.Project                                                                                           &lt;br/&gt;
2          |blue                            |50000.00     |org.apache.jdo.tck.pc.company.Project                                                                                           &lt;br/&gt;
3          |green                           |2000.99      |org.apache.jdo.tck.pc.company.Project                                                                                           &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;br/&gt;
ij&amp;gt; select * from project_member;&lt;br/&gt;
PROJID     |MEMBER     &lt;br/&gt;
-----------------------&lt;br/&gt;
2          |3          &lt;br/&gt;
1          |3          &lt;br/&gt;
2          |2          &lt;br/&gt;
3          |5          &lt;br/&gt;
3          |4          &lt;br/&gt;
1          |2          &lt;br/&gt;
1          |1          &lt;/p&gt;

&lt;p&gt;7 rows selected&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12385521">DERBY-3301</key>
            <summary>Incorrect result from query with nested EXIST</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="thomanie">Thomas Nielsen</assignee>
                                    <reporter username="clr">Craig L Russell</reporter>
                        <labels>
                    </labels>
                <created>Thu, 3 Jan 2008 18:51:53 +0000</created>
                <updated>Thu, 2 May 2013 03:29:11 +0100</updated>
                            <resolved>Fri, 15 Feb 2008 08:23:01 +0000</resolved>
                                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                    <version>10.3.2.1</version>
                                    <fixVersion>10.3.3.0</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12555725" author="clr" created="Fri, 4 Jan 2008 00:02:13 +0000"  >&lt;p&gt;I just tried this with 10.3.2.1 and the same error occurs.&lt;/p&gt;

&lt;p&gt;I changed the fix version from 10.2.1.6 to unknown (oops).&lt;/p&gt;</comment>
                            <comment id="12555739" author="army" created="Fri, 4 Jan 2008 00:29:23 +0000"  >&lt;p&gt;Any chance you could a) post a fully reproducing script or Java program, and/or b) try it out&lt;br/&gt;
with the 10.1.3.1 release?  I&apos;m wondering if this might be the same underlying issue as&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3288&quot; title=&quot;wrong query result in presence of a unique index&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3288&quot;&gt;&lt;del&gt;DERBY-3288&lt;/del&gt;&lt;/a&gt;--if it is, then it should work with 10.1.3.1.  Trying it out there might help&lt;br/&gt;
determine when the problem was introduced...(esp. is it a regression?)&lt;/p&gt;</comment>
                            <comment id="12555985" author="clr" created="Fri, 4 Jan 2008 17:03:16 +0000"  >&lt;p&gt;Reproduced also on 10.1.3.1. There is a slight difference in behavior (of a similar query) that I will have to check into, and update this report.&lt;/p&gt;</comment>
                            <comment id="12556033" author="clr" created="Fri, 4 Jan 2008 19:42:29 +0000"  >&lt;p&gt;There is a similar query that sometimes returns the expected result and sometimes returns a single row.&lt;/p&gt;

&lt;p&gt;The difference in the query is that there is an extra clause in the WHERE clause: &lt;br/&gt;
AND UNBOUND_P.NAME = &apos;orange&apos;&lt;/p&gt;

&lt;p&gt;This query is expected to return three rows&lt;br/&gt;
PERSONID |PROJID &lt;br/&gt;
----------------------- &lt;br/&gt;
3 |1 &lt;br/&gt;
2 |1 &lt;br/&gt;
1 |1 &lt;br/&gt;
3 rows selected&lt;/p&gt;

&lt;p&gt;but sometimes only one row is returned&lt;br/&gt;
PERSONID |PROJID &lt;br/&gt;
----------------------- &lt;br/&gt;
1 |1 &lt;br/&gt;
1 rows selected&lt;/p&gt;
</comment>
                            <comment id="12556637" author="clr" created="Mon, 7 Jan 2008 17:51:03 +0000"  >&lt;p&gt;The attached patch demonstrates the problem.&lt;/p&gt;

&lt;p&gt;The expected result of the last query in the file is the 7 rows corresponding to the rows in the join table.&lt;/p&gt;

&lt;p&gt;To duplicate the problem, run ij &amp;lt; derby-3301.sql&lt;/p&gt;

&lt;p&gt;Any suggestions are welcome.&lt;/p&gt;</comment>
                            <comment id="12560280" author="jorgenlo" created="Fri, 18 Jan 2008 08:06:42 +0000"  >&lt;p&gt;Linking issue to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3321&quot; title=&quot;NullPointerException for &amp;#39;NOT EXISTS&amp;#39; with nested subquery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3321&quot;&gt;&lt;del&gt;DERBY-3321&lt;/del&gt;&lt;/a&gt;: NPE if &apos;exists&apos; is followed by a nested subquery.&lt;/p&gt;</comment>
                            <comment id="12560326" author="thomanie" created="Fri, 18 Jan 2008 10:14:41 +0000"  >&lt;p&gt;Took the liberty to generate and attach the queryplan for the reproscript.&lt;/p&gt;</comment>
                            <comment id="12560330" author="thomanie" created="Fri, 18 Jan 2008 10:34:59 +0000"  >&lt;p&gt;I&apos;m not very familiar with tracking down these bugs, but it seems to me that the RH side of the &lt;br/&gt;
&quot;Hash Exists Join ResultSet&quot;, a &quot;Hash Scan ResultSet&quot; for PROJECT_EMPLOYEES see (returns) only 3 rows, &lt;br/&gt;
even though the underlying scan produces 7 rows?&lt;/p&gt;

&lt;p&gt;&amp;#8212; snip &amp;#8211;&lt;br/&gt;
                                        Rows seen = 3&lt;br/&gt;
                                        Rows filtered = 0&lt;/p&gt;

&lt;p&gt;...&lt;br/&gt;
                                        scan information:&lt;br/&gt;
                                                Bit set of columns fetched=All&lt;br/&gt;
                                                Number of columns fetched=2&lt;br/&gt;
                                                Number of pages visited=1&lt;br/&gt;
                                                Number of rows qualified=7&lt;br/&gt;
                                                Number of rows visited=7&lt;br/&gt;
&amp;#8212; snip &amp;#8212;&lt;/p&gt;

&lt;p&gt;Hopefully this will help the well versed to track this one down &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12560414" author="thomanie" created="Fri, 18 Jan 2008 14:47:25 +0000"  >&lt;p&gt;A little further investigation shows that HashScanResultSet.getNextRowCore() is acutally doing what it is supposed to do.&lt;/p&gt;

&lt;p&gt;The underlying ResultSets build a HashMap based on a key, and puts all rows matching this key into the map with that key.&lt;br/&gt;
For the repro this means a HashMap with 3 keys with 3, 2 and 3 rows for the map entries respectively as seen in the debugger.&lt;/p&gt;

&lt;p&gt;In getNextRow() we pick the first element for a given key from the map, then move on to the next key, even though &lt;br/&gt;
there are unfetched entries left in the map. This is where the code is flawed at the moment.&lt;/p&gt;

&lt;p&gt;For each invocation of getNextRowCore(), a call is done to reopenCore() as well. This looks suspicious. reopenCore() is a good citizen &lt;br/&gt;
and resets any reference variables with a call to resetProbeVariables(). This call resets the indexing we use in getNextRowCore() to &lt;br/&gt;
keep track of the index into the map entries, and force us to move on to the next key in the HashMap instead of the next entry in the HashMap. &lt;/p&gt;

&lt;p&gt;It&apos;s right there in the queryplan as well with &quot;Number of opens = 3&quot; for the lower HashScanResultSet &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
There&apos;s the reason for the three, and not seven, rows.&lt;/p&gt;

&lt;p&gt;The big question right now is who calls, and why is, reopenCore() called twice? &lt;/p&gt;

&lt;p&gt;I probably won&apos;t have time to investigate until Monday. If someone else feels like fixing this, please go ahead.&lt;/p&gt;</comment>
                            <comment id="12560462" author="bryanpendleton" created="Fri, 18 Jan 2008 16:59:46 +0000"  >&lt;p&gt;Hi Thomas, thanks for having a look at this.&lt;/p&gt;

&lt;p&gt;I agree with your analysis of that portion of the query plan: there are&lt;br/&gt;
7 total rows that are seen in the project_employees table, but they&lt;br/&gt;
are being organized into 3 hash buckets based on the projid field.&lt;br/&gt;
The rows in the table have projid values 101, 102, and 103, so this seems ok.&lt;/p&gt;

&lt;p&gt;What seems to be happening to me is that we are &quot;collapsing&quot; the&lt;br/&gt;
results. The actual values that the query returns (with the current trunk) are:&lt;/p&gt;

&lt;p&gt;EMPID      |PROJID&lt;br/&gt;
-----------------------&lt;br/&gt;
13         |101&lt;br/&gt;
13         |102&lt;br/&gt;
15         |103&lt;/p&gt;

&lt;p&gt;Note that we are getting &lt;b&gt;one&lt;/b&gt; of the employees for &lt;b&gt;each&lt;/b&gt; of the 3 projects,&lt;br/&gt;
whereas I think Craig expects us to be fetching &lt;b&gt;all&lt;/b&gt; of the employees for&lt;br/&gt;
&lt;b&gt;each&lt;/b&gt; of the projects.&lt;/p&gt;

&lt;p&gt;I suspect this means that the flattening of the exists queries was performed&lt;br/&gt;
incorrectly, but beyond that I don&apos;t have anything brilliant to say. I looked at&lt;br/&gt;
some of this logic when I was studying &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3033&quot; title=&quot;select query results in nullpointer exception in skipScan()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3033&quot;&gt;&lt;del&gt;DERBY-3033&lt;/del&gt;&lt;/a&gt;, but I don&apos;t think that&lt;br/&gt;
issue is extremely relevant to this issue.&lt;/p&gt;

&lt;p&gt;Still, you might spend some time stepping through FromList.preprocess()&lt;br/&gt;
and FromList.flattenFromTables() for the query in question, and see if&lt;br/&gt;
you notice any logic that seems particularly relevant for this query.&lt;/p&gt;</comment>
                            <comment id="12560582" author="thomanie" created="Fri, 18 Jan 2008 22:49:40 +0000"  >&lt;p&gt;Thanks for the pointers Bryan.&lt;/p&gt;

&lt;p&gt;Above the HashScanResultSet, there is a NestedLoopJoinResultSet pulling rows from both left and right childs in getNextRowCore().&lt;br/&gt;
NesteLoopJoinResultSet.getNextRowCore() will stop pulling rows if its member oneRowRightSide is true. oneRowRightSide is supplied to the constructor, so it&apos;s set at ResultSet generation time.&lt;/p&gt;

&lt;p&gt;NestedLoopJoinResultSet is generated by GenericResultSetFactory.getNestedLoopJoinResult(), which again is only called from JoinNode.generate().&lt;br/&gt;
To see this you first have to find the getter to the NestedLoopJoinResultSet in GenericResultSetFactory, then do a text&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/warning.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; search for use of the getter method. In this case it&apos;s only used once - in &lt;br/&gt;
NesteLoopJoinStrategy.joinResultSetMethodName(), which again is only used in JoinNode.generate.&lt;/p&gt;

&lt;p&gt;So why is it setting oneRowRightSide to true?&lt;/p&gt;

&lt;p&gt;The arguments to the NestedLoopJoinResultSet constructor is pushed to the stack by JoinNode.getJoinArguments(), where one calls JoinNode.oneRowRightSide().&lt;br/&gt;
oneRowRightSide() simply pushes rightResultSet.isOneRowResultSet() to the stack and continues along merrily (JoinNode.java @ 1691)&lt;/p&gt;

&lt;p&gt;In the debugger we see that the first hit of a breakpoint in JoinNode.java @1691 is the interesting one.&lt;br/&gt;
rightResultSet is a ProjectRestrictNode over a FromBaseTable. That is the select we want to look at.&lt;/p&gt;

&lt;p&gt;ProjectRestrictNode.isOneRowResult() simply calls its childResult.isOneRowResult(), so we end up in FromBaseTable.isOneRowResult().&lt;/p&gt;

&lt;p&gt;FromBaseTable.isOneRowResult() start off with this comment and code: &lt;br/&gt;
   // EXISTS FBT will only return a single row&lt;br/&gt;
   if (existsBaseTable)&lt;/p&gt;
   {
       return true;
    }

&lt;p&gt;existsBaseTable is true in the failing query.&lt;/p&gt;

&lt;p&gt;existsBaseTable is only set in FromBaseTable.setExistsBaseTable(), and this method is only called form FromList.genExistsBaseTables()&lt;br/&gt;
where it is explicitly set to true.&lt;/p&gt;

&lt;p&gt;It seems to me that the assumption made in FromBaseTable.isOneRowResultI() is wrong?&lt;br/&gt;
It&apos;s been there ever since derby code was donated. That&apos;s most likely the reason for all previous versions showing identical behaviour.&lt;/p&gt;

&lt;p&gt;With those 4 lines making the single row assumption for exists commented out, and letting the rest of the isOneRowResult() logic make the decision, &lt;br/&gt;
it returns false as expected in this case. The query returns 7 rows as Craig expects.&lt;/p&gt;

&lt;p&gt;EMPID      |PROJID     &lt;br/&gt;
-----------------------&lt;br/&gt;
13         |101        &lt;br/&gt;
12         |101        &lt;br/&gt;
11         |101        &lt;br/&gt;
13         |102        &lt;br/&gt;
12         |102        &lt;br/&gt;
15         |103        &lt;br/&gt;
14         |103        &lt;/p&gt;

&lt;p&gt;Any one care to comment on my analysis and especially on the exists assumption made?&lt;/p&gt;

&lt;p&gt;If this is correct, any query involving and EXISTS &lt;b&gt;potentially&lt;/b&gt; will produce wrong results, and this could be the root cause for a couple of the other EXISTS issues?&lt;/p&gt;</comment>
                            <comment id="12560592" author="thomanie" created="Fri, 18 Jan 2008 23:09:08 +0000"  >&lt;p&gt;Too late to keep working - EXIST should return only one row.&lt;/p&gt;</comment>
                            <comment id="12560732" author="dyret" created="Sat, 19 Jan 2008 21:38:13 +0000"  >&lt;p&gt;Hi Thomas, looks like you&apos;ve been busy (even though it is the weekend). &lt;br/&gt;
Are you saying that the query behaves correctly? &lt;/p&gt;

&lt;p&gt;SELECT &amp;lt;something&amp;gt; FROM &amp;lt;tables&amp;gt; WHERE EXISTS &amp;lt;subquery&amp;gt;&lt;/p&gt;

&lt;p&gt;must still evaluate subquery for all rows, right? And just return those for which the subquery produces at least one row? Or am I totally mis-understanding?&lt;/p&gt;</comment>
                            <comment id="12560902" author="clr" created="Sun, 20 Jan 2008 23:44:20 +0000"  >&lt;p&gt;&amp;gt; Too late to keep working - EXIST should return only one row.&lt;br/&gt;
There are many ways to evaluate the query, depending on the strategy. Yes, each of the EXISTS clauses should return either zero or one row, depending on whether the EXISTS condition is true for the specific row of the outermost FROM clause.&lt;/p&gt;

&lt;p&gt;For each row of the outer product of the outermost FROM clause (DEPARTMENTS, EMPLOYEES, PROJECTS), the middle WHERE EXISTS should return true when there is a match between the EMPLOYEES and PROJECTS in the join table. As an optimization, you could invert the scan and look at all of the rows of the join table. It&apos;s hard to tell from the analysis here whether Derby is inverting the scan.&lt;/p&gt;</comment>
                            <comment id="12560953" author="thomanie" created="Mon, 21 Jan 2008 08:35:09 +0000"  >&lt;p&gt;Dyre&amp;gt; Are you saying that the query behaves correctly?&lt;br/&gt;
No, it does not on the current trunk. And your understanding of how this should be evaluated is correct I believe. Also see Craigs comment above.&lt;/p&gt;

&lt;p&gt;Craig&amp;gt; As an optimization, you could invert the scan and look at all of the rows of the join table. &lt;br/&gt;
Looking at the queryplan I think this is what Derby does, and during this optimization something goes wrong.&lt;/p&gt;

&lt;p&gt;As Bryan suggests, flattening of the exists query could be what goes wrong. I didn&apos;t see any obvious errors in the methods he suggested though.&lt;/p&gt;

&lt;p&gt;The problem appears since the NestedLoopJoinResultSet above the HashScanResultSet that returns 3 out of 7 rows, incorrectly has its right side &lt;br/&gt;
&quot;optimized&quot; to expect a single row since it&apos;s flagged as an EXISTS query. This causes NestedLoopJoinResultSet to retrieve 1 row, then close and reopen the &lt;br/&gt;
HashScanResultSet subquery which then returns from the next hash bucket like it&apos;s supposed to. This way we continue through the 3 hash buckets returning 3 out of 7 rows.&lt;/p&gt;

&lt;p&gt;As I stated in my last comment (the long one), if the NestedLoopJoinResultSet has it&apos;s right child (correctly) flagged as &lt;b&gt;not&lt;/b&gt; being an EXISTS query &lt;br/&gt;
and expected to return a single row, the query returns the expected 7 rows. So we need to figure out the root cause of why the NesteLoopJoinResultSet &lt;br/&gt;
thinks its right child will return only one row.&lt;/p&gt;</comment>
                            <comment id="12561036" author="bryanpendleton" created="Mon, 21 Jan 2008 15:26:24 +0000"  >&lt;p&gt;Perhaps there are some clues in this section of the manual:&lt;br/&gt;
&lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform13699.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform13699.html&lt;/a&gt;&lt;br/&gt;
In particular, this section:&lt;br/&gt;
&lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform36368.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform36368.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I find it interesting that there are two levels of subquery flattening&lt;br/&gt;
going on here; that is, we have a subquery in the where clause of&lt;br/&gt;
a subquery which is itself in the where clause of the top-level query.&lt;br/&gt;
Perhaps the flattening logic is evaluating the correctness rules properly&lt;br/&gt;
for a single level of flattening but isn&apos;t handling flattening-within-flattening?&lt;/p&gt;</comment>
                            <comment id="12561037" author="bryanpendleton" created="Mon, 21 Jan 2008 15:39:58 +0000"  >&lt;p&gt;This slight variation of the query seems to return the correct 7 rows. The&lt;br/&gt;
change is that I removed the extra join of this_employees_e, and just&lt;br/&gt;
used unbound_e throughout:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select unbound_e.empid, unbound_p.projid&lt;br/&gt;
from departments this,&lt;br/&gt;
     employees unbound_e,&lt;br/&gt;
     projects unbound_p&lt;br/&gt;
    where exists (&lt;br/&gt;
        select 1 from project_employees this_employees_e_projects_p&lt;br/&gt;
        where this_employees_e_projects_p.empid = unbound_e.empid&lt;br/&gt;
        and unbound_e.department = this.id&lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid&lt;br/&gt;
        and unbound_e.empid = unbound_e.empid) ;&lt;/p&gt;

&lt;p&gt;EMPID      |PROJID&lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101&lt;br/&gt;
12         |101&lt;br/&gt;
12         |102&lt;br/&gt;
13         |101&lt;br/&gt;
13         |102&lt;br/&gt;
14         |103&lt;br/&gt;
15         |103&lt;/p&gt;

&lt;p&gt;7 rows selected&lt;/p&gt;</comment>
                            <comment id="12561054" author="clr" created="Mon, 21 Jan 2008 16:41:10 +0000"  >&lt;p&gt;Bryan&amp;gt; This slight variation of the query seems to return the correct 7 rows. &lt;/p&gt;

&lt;p&gt;So the intermediate flattening of the query is probably causing the problem. Note that for more complex mappings from JDOQL to SQL, there will be even more intermediate EXISTS expressions.&lt;/p&gt;

&lt;p&gt;I also found &lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&lt;/a&gt; that goes into some detail of the EXISTS join flattening.&lt;/p&gt;</comment>
                            <comment id="12561073" author="army" created="Mon, 21 Jan 2008 17:21:53 +0000"  >&lt;p&gt;bryan&amp;gt; Perhaps the flattening logic is evaluating the correctness rules properly&lt;br/&gt;
bryan&amp;gt; for a single level of flattening but isn&apos;t handling flattening-within-flattening? &lt;/p&gt;

&lt;p&gt;Without having done any explicit tracing myself, this is what I would guess is the &lt;br/&gt;
problem.  Perhaps the inner-most EXISTS subquery can be considered an &quot;exists &lt;br/&gt;
base table&quot; (and thus only returns a single row) w.r.t. it&apos;s parent query, but if it is then &lt;br/&gt;
flattened &lt;em&gt;again&lt;/em&gt; to the outer-most query, maybe it should no longer be marked as &lt;br/&gt;
an &quot;exists base table&quot;?  I don&apos;t if that&apos;s actually true, I&apos;m just speculating.&lt;/p&gt;

&lt;p&gt;craig&amp;gt; I also found &lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&lt;/a&gt; that&lt;br/&gt;
craig&amp;gt; goes into some detail of the EXISTS join flattening&lt;/p&gt;

&lt;p&gt;Something from that page which stands out to me is the following condition:&lt;/p&gt;

&lt;p&gt;  &quot;None of the predicates in the subquery, including the additional one formed&lt;br/&gt;
  between the left side of the subquery operator and the column in the subquery&apos;s&lt;br/&gt;
  SELECT list (for IN or ANY subqueries), include any subqueries, method calls,&lt;br/&gt;
  or field accesses.&quot;&lt;/p&gt;

&lt;p&gt;If an EXISTS clause is considered a &quot;predicate&quot;, then the query &lt;/p&gt;

&lt;p&gt;  select &amp;lt;...&amp;gt;  from &amp;lt;...&amp;gt;&lt;br/&gt;
  where exists (&lt;br/&gt;
    select 1 from &amp;lt;...&amp;gt;&lt;br/&gt;
    where exists (&lt;br/&gt;
        select 1 from &amp;lt;...&amp;gt;&lt;br/&gt;
          ...&lt;/p&gt;

&lt;p&gt;seems to violate the condition quoted above from the documentation.  That is, the&lt;br/&gt;
subquery for the first EXISTS has a predicate (in this case another EXISTS query) &lt;br/&gt;
which includes another subquery (&quot;select 1 from ...&quot;), and therefore the first &lt;br/&gt;
subquery should not be flattened.  If this is the correct reading then the bug would &lt;br/&gt;
appear to be in the logic that checks for the aforementioned condition--presumably &lt;br/&gt;
because that check occurs after the inner-most subquery has itself been flattened?  &lt;br/&gt;
Again, I&apos;m just guessing, I haven&apos;t done much examination of the actual codepath...&lt;/p&gt;</comment>
                            <comment id="12561138" author="thomanie" created="Mon, 21 Jan 2008 21:54:18 +0000"  >&lt;p&gt;Thanks a lot for all the pointers folks. I think both Army and Bryan nailed it on where/why this query fails on the trunk.&lt;/p&gt;

&lt;p&gt;To check the hypothesis, I tried marking any subquery in the wherePredicates as such and skip flattening if this is a subquery in a whereClause. &lt;br/&gt;
The happens to be exactly what Kathey did in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3257&quot; title=&quot;SELECT with HAVING clause containing OR conditional incorrectly return 1 row - should return 2 rows - works correctly with 10.2 DB&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3257&quot;&gt;&lt;del&gt;DERBY-3257&lt;/del&gt;&lt;/a&gt; for havingSubqueries. With the mark-and-skip fix the correct 7 rows are returned as the flattening is skipped.&lt;/p&gt;

&lt;p&gt;My approach is possibly too brute, and might be relaxed, but I&apos;ll post a proper patch tomorrow morning.&lt;/p&gt;</comment>
                            <comment id="12561141" author="clr" created="Mon, 21 Jan 2008 21:58:07 +0000"  >&lt;p&gt;Great! I&apos;m looking forward to trying the patch.&lt;/p&gt;</comment>
                            <comment id="12561262" author="thomanie" created="Tue, 22 Jan 2008 08:48:35 +0000"  >&lt;p&gt;The attached diff &apos;derby-3301-1.diff&apos; works in similar fashion as Katheys diff for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3257&quot; title=&quot;SELECT with HAVING clause containing OR conditional incorrectly return 1 row - should return 2 rows - works correctly with 10.2 DB&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3257&quot;&gt;&lt;del&gt;DERBY-3257&lt;/del&gt;&lt;/a&gt; by&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;marking any subquery in a WHERE clause as such&lt;/li&gt;
	&lt;li&gt;skip flattening of the subquery on the where subquery condition&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This diff produces the correct results:&lt;br/&gt;
---- snip &amp;#8212;&lt;br/&gt;
ij(CONNECTION1)&amp;gt; select unbound_e.empid, unbound_p.projid &lt;br/&gt;
from departments this, &lt;br/&gt;
     employees unbound_e, &lt;br/&gt;
     projects unbound_p &lt;br/&gt;
where exists ( &lt;br/&gt;
    select 1 from employees this_employees_e &lt;br/&gt;
    where exists ( &lt;br/&gt;
        select 1 from project_employees this_employees_e_projects_p &lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid &lt;br/&gt;
        and this_employees_e.department = this.id &lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid &lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid) &lt;br/&gt;
    );&lt;br/&gt;
EMPID      |PROJID     &lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101        &lt;br/&gt;
12         |101        &lt;br/&gt;
13         |101        &lt;br/&gt;
12         |102        &lt;br/&gt;
13         |102        &lt;br/&gt;
14         |103        &lt;br/&gt;
15         |103        &lt;/p&gt;

&lt;p&gt;7 rows selected&lt;br/&gt;
---- snip &amp;#8212;&lt;/p&gt;

&lt;p&gt;Even though the diff works, the condition for skipping flattening should be relaxed to only apply to EXISTS subqueries in a WHERE clause, not &lt;b&gt;all&lt;/b&gt; subqueries in a where clause as is done in &apos;derby-3301-1.diff&apos;.&lt;/p&gt;</comment>
                            <comment id="12561383" author="army" created="Tue, 22 Jan 2008 17:20:55 +0000"  >&lt;p&gt;&amp;gt; Even though the diff works, the condition for skipping flattening should be relaxed&lt;br/&gt;
&amp;gt; to only apply to EXISTS subqueries in a WHERE clause&lt;/p&gt;

&lt;p&gt;I think the condition may need to be narrowed down even further: EXISTS&lt;br/&gt;
subqueries &lt;em&gt;are&lt;/em&gt; allowed to be flattened from a WHERE clause &lt;em&gt;if&lt;/em&gt; that &lt;br/&gt;
subquery&apos;s WHERE clause does not itself contain another subquery.  As an &lt;br/&gt;
example, take a look at the last query on the doc page mentioned above,&lt;br/&gt;
namely:&lt;/p&gt;

&lt;p&gt;  SELECT t1.* FROM t1, t2&lt;br/&gt;
  WHERE EXISTS (SELECT * FROM t3 WHERE t1.c1 = t3.c1)&lt;/p&gt;

&lt;p&gt;    gets flattened into&lt;/p&gt;

&lt;p&gt;  SELECT t1.* FROM t1, t2, t3 WHERE t1.c1 = t3.c1&lt;/p&gt;

&lt;p&gt;If changes are made to completely avoid flattening of EXISTS subqueries in &lt;br/&gt;
WHERE clauses, then the above query will &lt;b&gt;not&lt;/b&gt; be flattened into an exists join,&lt;br/&gt;
even though it&apos;s perfectly valid to perform flattening in that case.  With the approach &lt;br/&gt;
that you&apos;ve outlined the exists join optimization as a whole will be disabled (I think?).  &lt;br/&gt;
I think that has the potential to cause a performance regression for users whose &lt;br/&gt;
queries benefit from the EXISTS join optimization today.&lt;/p&gt;

&lt;p&gt;A similar discussion was held for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3231&quot; title=&quot;Sorting on COUNT with OR and GROUP BY delivers wrong results.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3231&quot;&gt;&lt;del&gt;DERBY-3231&lt;/del&gt;&lt;/a&gt; and in that case a decision was &lt;br/&gt;
made to deliberately remove an optimization for the sake of correctness.  But the &lt;br/&gt;
use cases affected by that particular optimization were (most likely) few and far&lt;br/&gt;
between.  With this issue, though, I think removing EXISTS subquery flattening &lt;br/&gt;
across the board will affect far more users, so I worry about committing such a fix.&lt;/p&gt;

&lt;p&gt;The patch as posted does not apply to the current trunk, but from what I can tell, if &lt;br/&gt;
you run a query like the one mentioned in the documentation, ex.:&lt;/p&gt;

&lt;p&gt;create table t1 (c1 int, c2 int, c3 int);&lt;br/&gt;
create table t2 (i int, j int);&lt;br/&gt;
create table t3 (c1 int, vc varchar(10));&lt;/p&gt;

&lt;p&gt;insert into t1 values (1, -1, 1), (3, -3, 9), (2, -2, 4);&lt;br/&gt;
insert into t2 values (2, 4);&lt;br/&gt;
insert into t3 values (1, &apos;one&apos;), (3, &apos;three&apos;);&lt;/p&gt;

&lt;p&gt;select t1.* from t1, t2 where exists (select * from t3 where t1.c1 = t3.c1);&lt;/p&gt;

&lt;p&gt;I think derby-3301-1.diff will cause the SELECT to skip flattening of the EXISTS&lt;br/&gt;
subquery.  Is that correct?&lt;/p&gt;

&lt;p&gt;The core problem for this issue appears to be the specific case where we have a&lt;br/&gt;
subquery SQ1 that appears in the whereClause of &lt;b&gt;another&lt;/b&gt; subquery SQ0.  In that&lt;br/&gt;
case disabling the flattening of SQ0 would be appropriate--as the documentation&lt;br/&gt;
states.  But if subquery SQ1 appears in the whereClause of an &lt;b&gt;OUTER&lt;/b&gt; query--as&lt;br/&gt;
shown above--I don&apos;t think we should disable flattening altogether.&lt;/p&gt;

&lt;p&gt;If at all possible, I think it&apos;d be better to fix the flattening condition for the specific&lt;br/&gt;
situation of nested subqueries than to completely disable WHERE clause flattening&lt;br/&gt;
for EXISTS subqueries.&lt;/p&gt;

&lt;p&gt;Or put differently: if the documentation is correct, the &lt;em&gt;intent&lt;/em&gt; is to skip flattening of&lt;br/&gt;
an EXISTS subquery that has predicates which in turn contain other subqueries.&lt;br/&gt;
But the current code does not correctly implement that intent.  So I think it&apos;d be&lt;br/&gt;
good to figure out &lt;em&gt;why&lt;/em&gt; the current code is wrong for the case of nested &lt;br/&gt;
subqueries, and then try to make a change that addresses that specific problem.&lt;/p&gt;

&lt;p&gt;On a slightly different note, have you had a chance to run the regression suites&lt;br/&gt;
with this change?  I&apos;m curious to know if any of the existing tests actually test&lt;br/&gt;
for EXISTS join flattening--and if so, do those tests still pass with the proposed&lt;br/&gt;
change?&lt;/p&gt;</comment>
                            <comment id="12561614" author="thomanie" created="Wed, 23 Jan 2008 09:13:27 +0000"  >&lt;p&gt;Attaching updated patch &apos;derby-3301-2.diff&apos;.&lt;/p&gt;

&lt;p&gt;The condition for skipping flattening should be even more specific than what is implemented in &apos;derby-3301-2.diff&apos; as per the discussion, so I&apos;m still not marking this with patch available. This updated patch will skip flattening if the WHERE EXISTS subquery is a select with a where subquery. &lt;/p&gt;

&lt;p&gt;The issue I&apos;m facing is that flatteing of the lower/child WHERE EXISTS removes it from the whereSubquerys as it&apos;s supposed to. When we later preprocess the upper/parent WHERE EXISTS we lack information about what the lower whereSubquery originally was. It seems a similar issue was once seen for a normal whereClause as a copy of the original clause is kept in the SelectNode.originalWhereClause member.&lt;/p&gt;</comment>
                            <comment id="12561634" author="thomanie" created="Wed, 23 Jan 2008 11:08:18 +0000"  >&lt;p&gt;Running the query on a faster, dual-core machine actually produce the correct results &lt;b&gt;without&lt;/b&gt; running down the path provided by the last patch.&lt;br/&gt;
The queryplan looks totally different on the faster machine. Need to verify it still runs the problematic path with a slower machine.&lt;br/&gt;
Either different statistics cause the change in queryplan, or (more likely as we still are in preprocessing) something else has changed on trunk as well.&lt;/p&gt;</comment>
                            <comment id="12561811" author="thomanie" created="Wed, 23 Jan 2008 20:34:33 +0000"  >&lt;p&gt;Attaching updated patch with correct condition checks for skipping flattening of WHERE EXISTS subquerys with nested WHERE EXISTS subqueries.&lt;br/&gt;
&apos;derby-3301-3.diff&apos; also takes SubqueryNodes in the where clause, not only where subqueries into consideration.&lt;/p&gt;

&lt;p&gt;Will run derbyAll and suites.All on this patch and report the results.&lt;/p&gt;

&lt;p&gt;Checking patch available, and assigning it to me.&lt;/p&gt;</comment>
                            <comment id="12561813" author="thomanie" created="Wed, 23 Jan 2008 20:37:24 +0000"  >&lt;p&gt;I should probably add that I got it reproduced on the faster box as well. Environmental issue caused breakpoints to not trigger.&lt;/p&gt;</comment>
                            <comment id="12561825" author="thomanie" created="Wed, 23 Jan 2008 21:32:19 +0000"  >&lt;p&gt;&apos;derby-3301-3b.diff&apos; fixes NPE seen in suites.All with the last patch.&lt;/p&gt;</comment>
                            <comment id="12561998" author="thomanie" created="Thu, 24 Jan 2008 10:06:58 +0000"  >&lt;p&gt;suites.All and derbyall passes with &apos;derby-3301-3b.diff&apos;&lt;/p&gt;</comment>
                            <comment id="12562021" author="thomanie" created="Thu, 24 Jan 2008 11:52:27 +0000"  >&lt;p&gt;Created &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt; for improved testing for nested WHERE EXISTS clauses&lt;/p&gt;</comment>
                            <comment id="12562029" author="dyret" created="Thu, 24 Jan 2008 12:10:53 +0000"  >&lt;p&gt;I would like commit this fairly soon, but given the complexity of the issue, I would feel more at ease if someone else could also look at the 3b patch.&lt;/p&gt;</comment>
                            <comment id="12562090" author="bryanpendleton" created="Thu, 24 Jan 2008 15:06:01 +0000"  >&lt;p&gt;Does the 3b patch contain new regression tests?&lt;/p&gt;</comment>
                            <comment id="12562095" author="thomanie" created="Thu, 24 Jan 2008 15:20:52 +0000"  >&lt;p&gt;No, 3b does not include any new regression tests or extentions.&lt;/p&gt;

&lt;p&gt;An email comment from Army on derby-dev suggested I create a separate jira flagging the need for testing this issue. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt; was filed for this.&lt;br/&gt;
Maybe I misinterpreted his comment?&lt;/p&gt;</comment>
                            <comment id="12562097" author="bryanpendleton" created="Thu, 24 Jan 2008 15:25:29 +0000"  >&lt;p&gt;I think that we should at least include the basic repro script&lt;br/&gt;
as a regression test in this patch, then as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
we could construct additional tests in this area.&lt;/p&gt;

&lt;p&gt;Craig, you mentioned that your O/R tool generates lots of&lt;br/&gt;
queries like this; is it possible for you to contribute some&lt;br/&gt;
additional test cases, so that we can explore some other&lt;br/&gt;
varieties of flattenable and non-flattenable subqueries?&lt;/p&gt;</comment>
                            <comment id="12562106" author="thomanie" created="Thu, 24 Jan 2008 15:44:40 +0000"  >&lt;p&gt;I can make the attached repro into a junit test that can be extended by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt; later. &lt;br/&gt;
Or is there an existing junit test the repro should go into?&lt;/p&gt;</comment>
                            <comment id="12562121" author="army" created="Thu, 24 Jan 2008 16:26:23 +0000"  >&lt;p&gt;&amp;gt; Maybe I misinterpreted his comment?&lt;/p&gt;

&lt;p&gt;Yes, I think so.  But probably more my fault than anything.&lt;/p&gt;

&lt;p&gt;What I meant to say was that I expect any patch which completely disables EXISTS&lt;br/&gt;
subquery flattening to theoretically cause at least one test in the regression suite&lt;br/&gt;
to fail.  If that&apos;s not true-&lt;del&gt;i.e. if all tests pass with such a patch&lt;/del&gt;-then it means that&lt;br/&gt;
there are no existing test cases to verify that EXISTS subquery flattening is actually&lt;br/&gt;
occuring, and that would warrant a separate (testing) issue.&lt;/p&gt;

&lt;p&gt;But for your 3b patch, you are &lt;b&gt;NOT&lt;/b&gt; disabling EXISTS subquery flattening altogether (as&lt;br/&gt;
discussed earlier), so it&apos;s not surprising that existing tests run without error.  That said,&lt;br/&gt;
I do think it would be good to add a new regression test to correspond to the specific&lt;br/&gt;
patch that you&apos;ve posted--ex. a new test case based on the attached repro would be&lt;br/&gt;
good.&lt;/p&gt;

&lt;p&gt;If that&apos;s still unclear, then the short version is &quot;Yes, I think a new test case (or set of&lt;br/&gt;
test cases) should be added for this issue&quot;.  A JUnit test based on the repro would be&lt;br/&gt;
ideal.&lt;/p&gt;

&lt;p&gt;Apologies for any confusion cause by my earlier comment.&lt;/p&gt;</comment>
                            <comment id="12562135" author="thomanie" created="Thu, 24 Jan 2008 17:14:39 +0000"  >&lt;p&gt;Attaching &apos;derby-3301-test-1.diff&apos;, a junit version of Craigs original &apos;derby-3301.sql&apos; reproscript.&lt;br/&gt;
The new regression test called WhereExistsTest.java can be used as a starting point for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
The test-1 patch also adds the new test to functionTests/tests/lang/_Suite.java.&lt;/p&gt;

&lt;p&gt;The test-1 patch runs successfully with the 3b patch applied, both as a single test and when run through the lang-suite.&lt;/p&gt;
</comment>
                            <comment id="12562169" author="army" created="Thu, 24 Jan 2008 18:58:58 +0000"  >&lt;p&gt;Two comments on the 3b patch.&lt;/p&gt;

&lt;p&gt;1) The additional comments in SubqueryNode that describe the new condition for a flattenable&lt;br/&gt;
subquery seem like they might be slightly inverted.  The comments say:&lt;/p&gt;

&lt;p&gt;   /* Values subquery is flattenable if:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;...&lt;/li&gt;
	&lt;li&gt;o It is not a nested WHERE EXISTS subquery in a WHERE EXISTS clause (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3301&quot; title=&quot;Incorrect result from query with nested EXIST&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3301&quot;&gt;&lt;del&gt;DERBY-3301&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Ignoring the conditions which were already there, I read this as:&lt;/p&gt;

&lt;p&gt;  &quot;A subquery SQ1 is flattenable if it is not a nested WHERE EXISTS subquery in the WHERE&lt;br/&gt;
  EXISTS clause of another subquery, SQ2&quot;.&lt;/p&gt;

&lt;p&gt;Is that a correct reading?  If so, I think that if SQ1 &lt;b&gt;is&lt;/b&gt; a nested WHERE EXISTS subquery in&lt;br/&gt;
the WHERE EXISTS clause of SQ2, then it&apos;s technically &lt;em&gt;SQ2&lt;/em&gt; that is not flattenable, not SQ1.&lt;br/&gt;
That said, the actual code changes in the new &quot;hasNestedWhereExistsClause()&quot; look correct,&lt;br/&gt;
so I think this is just a comment issue, not a code one.  Maybe a better condition would be:&lt;/p&gt;

&lt;p&gt;  o Either a) it (the subquery) does not appear within a WHERE clause, or b) it appears within&lt;br/&gt;
    a WHERE clause but does not itself contain a WHERE clause with other subqueries in it.&lt;/p&gt;

&lt;p&gt;This definition is quite a bit more wordy, but it matches the documentation and it also matches&lt;br/&gt;
the code in hasNestedWhereExistsClause a bit more closely--though not exactly.  See #2&lt;br/&gt;
comment below...&lt;/p&gt;

&lt;p&gt;2) The logic that exists in hasNestedWhereExistsClause() does exactly what its name implies,&lt;br/&gt;
i.e. it checks specifically for &quot;nested WHERE EXISTS clauses&quot;.  That in itself is good since it&lt;br/&gt;
addresses the issue reported.  But I did notice that the documentation for EXISTS join flattening&lt;br/&gt;
suggests a slightly more general condition:&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Namely, it seems like a more complete approach would be check to see if the subquery&apos;s&lt;br/&gt;
WHERE clause &quot;includes &lt;em&gt;any&lt;/em&gt; subqueries&quot;--not just WHERE EXISTS subqueries.  For&lt;br/&gt;
example: if the inner-most WHERE EXISTS query was replaced with a WHERE IN or WHERE&lt;br/&gt;
ANY clause, would we still get the correct results?&lt;/p&gt;

&lt;p&gt;As an example, I re-wrote the inner-most WHERE EXISTS subquery from derby-3301.sql to use a&lt;br/&gt;
WHERE IN clause that effectively duplicates one of the (already-existing) equality predicate, and&lt;br/&gt;
so should in theory return the same results...I think? (I could be wrong here):&lt;/p&gt;

&lt;p&gt;select unbound_e.empid, unbound_p.projid&lt;br/&gt;
from departments this,&lt;br/&gt;
     employees unbound_e,&lt;br/&gt;
     projects unbound_p&lt;br/&gt;
where exists (&lt;br/&gt;
    select 1 from employees this_employees_e&lt;br/&gt;
    where this_employees_e.empid in (                           &amp;#8211; *** Army changed this&lt;br/&gt;
        select this_employees_e_projects_p.empid        &amp;#8211; *** Army changed this&lt;br/&gt;
        from project_employees this_employees_e_projects_p&lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid&lt;br/&gt;
        and this_employees_e.department = this.id&lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid&lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid)&lt;/p&gt;

&lt;p&gt;This returns three rows:&lt;/p&gt;

&lt;p&gt;EMPID      |PROJID&lt;br/&gt;
-----------------------&lt;br/&gt;
13         |101&lt;br/&gt;
13         |102&lt;br/&gt;
15         |103&lt;/p&gt;

&lt;p&gt;Is that correct?  Or should that query be returning 7 rows, as well?  What about if&lt;br/&gt;
the first WHERE EXISTS query is changed to a &quot;WHERE IN&quot; query, as well--will&lt;br/&gt;
that behave correctly?&lt;/p&gt;

&lt;p&gt;If it should return seven rows, as well, then perhaps the new method in SubqueryNode&lt;br/&gt;
could be expanded to check for the existence of &lt;em&gt;any&lt;/em&gt; subquery, not just a WHERE&lt;br/&gt;
EXISTS subquery?&lt;/p&gt;

&lt;p&gt;One way to do that might be to use a CollectNodesVisitor to collect all instances of&lt;br/&gt;
SubqueryNode.class that appear in &quot;sn.originalWhereSubquerys&quot; and/or in&lt;br/&gt;
&quot;sn.originalWhereClause()&quot;--and if that visitor returns any matches, then the method&lt;br/&gt;
returns &quot;false&quot;.  I&apos;m not entirely sure that will work, but it seems like it could...?&lt;/p&gt;</comment>
                            <comment id="12562427" author="thomanie" created="Fri, 25 Jan 2008 10:34:15 +0000"  >&lt;p&gt;Thanks for the input Army.&lt;/p&gt;

&lt;p&gt;Ad 1)&lt;br/&gt;
I agree, the 3b comments miss the point slightly, and may be seen as &apos;inverted&apos;.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I think that if SQ1 &lt;b&gt;is&lt;/b&gt; a nested WHERE EXISTS subquery in the WHERE EXISTS clause of SQ2, then it&apos;s technically &lt;em&gt;SQ2&lt;/em&gt; that is not flattenable, not SQ1.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
This is correct, to my understanding. Your comment suggestion is a lot better, even if it is more elaborate.&lt;/p&gt;

&lt;p&gt;Ad 2)&lt;br/&gt;
True, 3b only takes the actual problem reported into consideration.&lt;br/&gt;
I reread the last bullet on the flattening criteria list (&lt;a href=&quot;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.3/tuning/ctuntransform25868.html&lt;/a&gt;) again. You are once again correct Army. &lt;br/&gt;
If SQ2 a has &lt;b&gt;any&lt;/b&gt; subquery SQ1 in its WHERE EXISTS clause, flattening of SQ2 should be skipped. Not flattening in the case where SQ2 is an ANY or IN query&lt;br/&gt;
is already handled in the existing code.&lt;/p&gt;

&lt;p&gt;I&apos;ll look into CollectNodesVisitor and post an updated patch.&lt;/p&gt;</comment>
                            <comment id="12562492" author="thomanie" created="Fri, 25 Jan 2008 13:35:32 +0000"  >&lt;p&gt;Attaching &apos;derby-3301-4.diff&apos; &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;comments changed&lt;/li&gt;
	&lt;li&gt;condition for flattening changed to exclude all where subquerys in a WHERE EXISTS subquery from flattening and renamed the helper method accordingly.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I have not touched flattening of IN at all with derby-3301-4.diff.&lt;/p&gt;

&lt;p&gt;suites.All and derbyall pass &lt;/p&gt;
</comment>
                            <comment id="12562582" author="army" created="Fri, 25 Jan 2008 17:11:10 +0000"  >&lt;p&gt;Thank you for your continued work on this, Thomas, and for your patience with my feedback.&lt;br/&gt;
A couple of follow-up comments...&lt;/p&gt;

&lt;p&gt;&amp;#8211; 1 &amp;#8211;&lt;/p&gt;

&lt;p&gt;&amp;gt; Not flattening in the case where SQ2 is an ANY or IN query&lt;br/&gt;
&amp;gt; is already handled in the existing code.&lt;/p&gt;

&lt;p&gt;Can you point me to the place in the code where this check currently occurs?  Note how if I replace&lt;br/&gt;
all occurrences of &quot;WHERE EXISTS&quot; from derby-3301.sql with &quot;WHERE ... IN&quot;, the query returns 5 rows&lt;br/&gt;
after applying your patch--but I think it should return 7 like the others?  So it seems the existing&lt;br/&gt;
code to handle ANY or IN queries may be incorrect, as well...&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select unbound_e.empid, unbound_p.projid&lt;br/&gt;
from departments this,&lt;br/&gt;
     employees unbound_e,&lt;br/&gt;
     projects unbound_p&lt;br/&gt;
where this.id in (&lt;br/&gt;
    select this_employees_e.department from employees this_employees_e&lt;br/&gt;
    where this_employees_e.empid in (&lt;br/&gt;
        select this_employees_e_projects_p.empid&lt;br/&gt;
          from project_employees this_employees_e_projects_p&lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid&lt;br/&gt;
        and this_employees_e.department = this.id&lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid&lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid)&lt;br/&gt;
    );&lt;/p&gt;

&lt;p&gt;EMPID      |PROJID&lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101&lt;br/&gt;
12         |102&lt;br/&gt;
13         |102&lt;br/&gt;
14         |103&lt;br/&gt;
15         |103&lt;/p&gt;

&lt;p&gt;5 rows selected&lt;/p&gt;

&lt;p&gt;If I make the following change w.r.t your patch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if ( isWhereSubquery() &amp;amp;&amp;amp; isEXISTS() ) {&lt;br/&gt;
+        if ( isWhereSubquery() &amp;amp;&amp;amp; (isEXISTS() || isANY() || isIN()) ) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;then the above query returns 7 rows, as I think it should.&lt;/p&gt;

&lt;p&gt;&amp;#8211; 2 &amp;#8211;&lt;/p&gt;

&lt;p&gt;With respect to derby-3301-4.diff, I noticed that we still check for an EXISTS WHERE subquery for the&lt;br/&gt;
second if statement, i.e.: at line 2382 (with your patch applied):&lt;/p&gt;

&lt;p&gt;                if (sn.originalWhereClause != null &amp;amp;&amp;amp;&lt;br/&gt;
                    sn.originalWhereClause instanceof SubqueryNode){&lt;br/&gt;
                        SubqueryNode tmp = (SubqueryNode) sn.originalWhereClause;&lt;br/&gt;
                        if ( tmp.isWhereSubquery() &amp;amp;&amp;amp; tmp.isEXISTS() ) { &amp;#8211; *** Note the &quot;isExists()&quot; check...&lt;/p&gt;

&lt;p&gt;Is there any reason not to remove &quot;tmp.isEXISTS()&quot; from inner &quot;if&quot; statement, similar to what you&lt;br/&gt;
did in the first half of this method?    Note how the query I posted yesterday with &quot;WHERE ... IN&quot; still&lt;br/&gt;
looks to return incorrect results (3 rows, when I think it should return 7?)--but if I remove the&lt;br/&gt;
&quot;tmp.isEXISTS()&quot; check from the &quot;if&quot; statement, that query returns 7 rows.  I.e.&lt;/p&gt;

&lt;p&gt;                        SubqueryNode tmp = (SubqueryNode) sn.originalWhereClause;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if ( tmp.isWhereSubquery() &amp;amp;&amp;amp; tmp.isEXISTS() ) {&lt;br/&gt;
+                       if ( tmp.isWhereSubquery() ) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Yields:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select unbound_e.empid, unbound_p.projid&lt;br/&gt;
from departments this,&lt;br/&gt;
     employees unbound_e,&lt;br/&gt;
     projects unbound_p&lt;br/&gt;
where exists (&lt;br/&gt;
    select 1 from employees this_employees_e&lt;br/&gt;
    where this_employees_e.empid in (&lt;br/&gt;
        select this_employees_e_projects_p.empid&lt;br/&gt;
          from project_employees this_employees_e_projects_p&lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid&lt;br/&gt;
        and this_employees_e.department = this.id&lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid&lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid)&lt;br/&gt;
    );&lt;/p&gt;

&lt;p&gt;EMPID      |PROJID&lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101&lt;br/&gt;
12         |101&lt;br/&gt;
13         |101&lt;br/&gt;
12         |102&lt;br/&gt;
13         |102&lt;br/&gt;
14         |103&lt;br/&gt;
15         |103&lt;/p&gt;

&lt;p&gt;7 rows selected&lt;/p&gt;

&lt;p&gt;From what I can tell, the two modifications to your patch mentioned above make the method&lt;br/&gt;
agree fully with the documentation, and appear to make all of the queries in question return&lt;br/&gt;
the correct number of rows.  Do they seem like reasonable modifications to you?&lt;/p&gt;

&lt;p&gt;Of course this entire comment is based on the assumption that the two queries I wrote above&lt;br/&gt;
with &quot;WHERE ... IN&quot; are in fact supposed to return 7 rows.  If that&apos;s not true, then you can pretty&lt;br/&gt;
much ignore everything in this particular comment...&lt;/p&gt;</comment>
                            <comment id="12562907" author="thomanie" created="Sat, 26 Jan 2008 19:05:05 +0000"  >&lt;p&gt;I&apos;m the one to thank for your continued comments Army &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Ad 1) &lt;br/&gt;
The IN variant of the query should return 7 rows as well I think. To verify I checked with another opensource database, and it does indeed return 7 rows too.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; Not flattening in the case where SQ2 is an ANY or IN query&lt;br/&gt;
&amp;gt;&amp;gt; is already handled in the existing code.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Can you point me to the place in the code where this check currently occurs?&lt;/p&gt;

&lt;p&gt;There are checks in SubqueryNode @698, @757 that I at writing thought would handle this - obviously not so.&lt;/p&gt;

&lt;p&gt;Ad 2)&lt;br/&gt;
The inner most tmp.isEXISTS() was not intentional :/ Thanks for spotting that.&lt;/p&gt;</comment>
                            <comment id="12562909" author="thomanie" created="Sat, 26 Jan 2008 19:20:40 +0000"  >&lt;p&gt;Attaching &apos;derby-3301-4b.diff&apos; based on Armys latest comments.&lt;br/&gt;
I renamed the helper function to better describe what it checks.&lt;/p&gt;

&lt;p&gt;Attaching &apos;derby-3301-test-2.diff&apos; which includes the IN variant of the query.&lt;/p&gt;

&lt;p&gt;derbyall passes. &lt;br/&gt;
suites.All has 7 errors off todays head of trunk, but they seem unrelated (StringIndexOutOfBounds in SecureServerTest). I&apos;ll look into it on monday.&lt;br/&gt;
The new WhereExistsTest pass with 4b applied.&lt;/p&gt;</comment>
                            <comment id="12563214" author="army" created="Mon, 28 Jan 2008 17:29:51 +0000"  >&lt;p&gt;Thank you for the 4b patch, Thomas.&lt;/p&gt;

&lt;p&gt;From what I can tell, the changes now look functionally good to me--thank you for incorporating&lt;br/&gt;
my feedback.&lt;/p&gt;

&lt;p&gt;I did notice that some of the code comments still reference &quot;WHERE EXISTS&quot; predicates only,&lt;br/&gt;
when in fact the new method (now) coveres IN and ANY predicates, as well.  But that&apos;s just a&lt;br/&gt;
nit--it shouldn&apos;t block commit of the patch.&lt;/p&gt;

&lt;p&gt;My only remaining minor comment is that I think it would be good to add test cases for&lt;br/&gt;
the various IN, ANY, and EXISTS combinations that are not currently tested.  As an example,&lt;br/&gt;
the query I posted previously that replaces &lt;em&gt;both&lt;/em&gt; instances of &quot;EXISTS&quot; with &quot;IN&quot; would be a&lt;br/&gt;
good test case to add.  I see that you added a new test case for &quot;EXISTS ... IN&quot;, which was&lt;br/&gt;
great--thanks for doing that.  I think a minimal list of combinations to check should be:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;WHERE EXISTS ... WHERE EXISTS (done with test-1.diff &amp;#8211; thanks!)&lt;/li&gt;
	&lt;li&gt;WHERE EXISTS ... WHERE IN (done with test-2.diff &amp;#8211; thanks!)&lt;/li&gt;
	&lt;li&gt;WHERE EXISTS .. WHERE ANY&lt;/li&gt;
	&lt;li&gt;WHERE IN ... WHERE IN (I posted an example in my previous post, but it&apos;s not included in the tests)&lt;/li&gt;
	&lt;li&gt;WHERE ANY ... WHERE ANY&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But again, the additional test cases could come as a separate patch later, or perhaps even&lt;br/&gt;
as a patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt;.  I.e. I don&apos;t think this should block commit of the 4b patch nor the&lt;br/&gt;
test-2 patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; suites.All has 7 errors off todays head of trunk&lt;/p&gt;

&lt;p&gt;I haven&apos;t seen these errors in the tinderbox runs.  Do you see them in a clean codeline?  And&lt;br/&gt;
if so, were you able to track down the cause?&lt;/p&gt;

&lt;p&gt;Thank you for all of your work on this, Thomas!&lt;/p&gt;</comment>
                            <comment id="12563227" author="thomanie" created="Mon, 28 Jan 2008 18:19:38 +0000"  >&lt;p&gt;I agree that all the listed combinations should be tested, but let&apos;s leave the test extension to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3349&quot; title=&quot;Nested WHERE EXISTS queries need improved testing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3349&quot;&gt;&lt;del&gt;DERBY-3349&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Reran suites.All with the 4b and test-2 patches on two different machines, and it passed on both. Most likely the failure was caused by test folder that wasn&apos;t clean before starting the test.&lt;/p&gt;

&lt;p&gt;Attaching derby-3301-4c with updated comments in SubqueryNode.isWhereExistsAnyInWithWhereSubquery() according to Armys commnets.&lt;/p&gt;</comment>
                            <comment id="12563231" author="thomanie" created="Mon, 28 Jan 2008 18:28:03 +0000"  >&lt;p&gt;Would it be a good idea to rename the new test in test-2 from WhereExistsTest.java to something like WhereExistsAnyInTest.java?&lt;/p&gt;</comment>
                            <comment id="12563241" author="army" created="Mon, 28 Jan 2008 18:46:22 +0000"  >&lt;p&gt;&amp;gt; Would it be a good idea to rename the new test in test-2 from&lt;br/&gt;
&amp;gt; WhereExistsTest.java to something like WhereExistsAnyInTest.java?&lt;/p&gt;

&lt;p&gt;Or maybe NestedWhereSubqueryTest.java would be a more general but still appropriate name?&lt;/p&gt;

&lt;p&gt;Dyre, if you&apos;re still looking to commit the changes for this issue, I have no further comments&lt;br/&gt;
to make on the 4c nor the test-2 patch.  Many thanks again to Thomas for his persistence on&lt;br/&gt;
this one...&lt;/p&gt;</comment>
                            <comment id="12563254" author="thomanie" created="Mon, 28 Jan 2008 19:22:50 +0000"  >&lt;p&gt;Attaching &apos;derby-3301-test-3.diff&apos; with renamed test.&lt;/p&gt;

&lt;p&gt;Test passes when run standalone, and is running as part of the lang suite now.&lt;/p&gt;</comment>
                            <comment id="12563266" author="thomanie" created="Mon, 28 Jan 2008 19:56:55 +0000"  >&lt;p&gt;test-3 passed as part of the suite as well.&lt;/p&gt;

&lt;p&gt;Thanks a lot for all your guidance Army!&lt;/p&gt;</comment>
                            <comment id="12563280" author="thomanie" created="Mon, 28 Jan 2008 20:37:54 +0000"  >&lt;p&gt;Reattaching derby-3301-test-3.diff&lt;/p&gt;</comment>
                            <comment id="12563476" author="dyret" created="Tue, 29 Jan 2008 11:46:08 +0000"  >&lt;p&gt;AB&amp;gt; Dyre, if you&apos;re still looking to commit the changes for this issue,&lt;/p&gt;

&lt;p&gt;Anyone should feel free to commit it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But yes, I do think it is an important and complex fix which will benefit from being run in the nightly regression tests for a while before the next release. &lt;br/&gt;
I have applied the patches successfully and I&apos;m running the tests. I plan to commit them later this afternoon. &lt;/p&gt;

&lt;p&gt;On a related note; this is not a regression, but would it still make sense to merge it to 10.3. ?&lt;/p&gt;</comment>
                            <comment id="12563566" author="dyret" created="Tue, 29 Jan 2008 16:30:19 +0000"  >&lt;p&gt;With the two patches I get a failure in lang/subqueryFlattening.sql. &lt;br/&gt;
From a quick look at the diff it seems like the test dumps a query plan that is different with the patch. I guessing that the master file needs to be updated, &lt;br/&gt;
but it would be nice if someone could confirm it.&lt;/p&gt;</comment>
                            <comment id="12563575" author="clr" created="Tue, 29 Jan 2008 17:10:09 +0000"  >&lt;p&gt;I&apos;d like to summarize my understanding of the patch.&lt;/p&gt;

&lt;p&gt;If you have an EXISTS nested inside an EXISTS, the optimized inversion of the query execution plan does not occur. Instead, the natural execution plan is performed. That is, the outer tables are iterated and for each candidate tuple of the joined tables, the EXISTS is performed. &lt;/p&gt;

&lt;p&gt;For each EXISTS check, the scans are reinitialized and there might not be any clues as to exactly where in the outer scan the EXISTS is being invoked. This might yield sub-optimal performance compared to an optimized inverted scan.&lt;/p&gt;

&lt;p&gt;Also, I&apos;m trying to get some more test cases by putting additional criteria into the EXISTS and running the query in debug mode and filtering the output. It&apos;s slower than I expected but I&apos;ll continue if it will help.&lt;/p&gt;</comment>
                            <comment id="12563581" author="army" created="Tue, 29 Jan 2008 17:26:30 +0000"  >&lt;p&gt;&amp;gt; With the two patches I get a failure in lang/subqueryFlattening.sql. &lt;/p&gt;

&lt;p&gt;Good catch, Dyre.  I was operating on the assumption that derbyall ran cleanly with&lt;br/&gt;
the 4c patch; I hadn&apos;t run it myself.&lt;/p&gt;

&lt;p&gt;&amp;gt; From a quick look at the diff it seems like the test dumps a query plan that is different&lt;br/&gt;
&amp;gt; with the patch&lt;/p&gt;

&lt;p&gt;I confirmed that there is one query for which the query plan is different--and for that specific query,&lt;br/&gt;
I think the difference is correct.  Namely, the query has nested WHERE EXISTS subqueries and so,&lt;br/&gt;
according to the findings for this issue, cannot be safely flattened.  So that part seems okay.&lt;/p&gt;

&lt;p&gt;I then noticed that another query further down in the test &lt;em&gt;also&lt;/em&gt; has nested WHERE EXISTS&lt;br/&gt;
subqueries, but that query &lt;em&gt;is&lt;/em&gt; in fact flattened into an exists join--which runs counter to the&lt;br/&gt;
findings so far for this issue (i.e. it shouldn&apos;t be flattened into an EXISTS due to the nested&lt;br/&gt;
EXISTS subqueries).  The fact that the query in subqueryFlattening still returns correct rows&lt;br/&gt;
suggests that maybe there are cases where flattening of EXISTS subqueries is &quot;safe&quot;--but&lt;br/&gt;
that seems beyond the scope of this issue.&lt;/p&gt;

&lt;p&gt;I played around with the repro for this issue and was able to write the following query:&lt;/p&gt;

&lt;p&gt;select unbound_e.empid, unbound_p.projid&lt;br/&gt;
from departments this,&lt;br/&gt;
     employees unbound_e,&lt;br/&gt;
     projects unbound_p&lt;br/&gt;
where exists (&lt;br/&gt;
    select 1 from employees this_employees_e&lt;br/&gt;
    where 1 = 1 and exists (&lt;br/&gt;
        select 1 from project_employees this_employees_e_projects_p&lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid&lt;br/&gt;
        and this_employees_e.department = this.id&lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid&lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid)&lt;br/&gt;
    );&lt;/p&gt;

&lt;p&gt;The only difference between this query and the one in derby-3301.sql is that I&apos;ve&lt;br/&gt;
added a (no-op) predicate &quot;1 = 1&quot; alongside the inner-most EXISTS clause.&lt;br/&gt;
Since this creates an AndNode whose left operand is a relational op (&quot;1 = 1&quot;) and&lt;br/&gt;
whose right operand is a SubqueryNode, the code in the 4c patch that checks&lt;br/&gt;
specifically for a SubqueryNode will not detect it:&lt;/p&gt;

&lt;p&gt;+               if (sn.originalWhereClause != null &amp;amp;&amp;amp;&lt;br/&gt;
+                   sn.originalWhereClause instanceof SubqueryNode)  {&lt;br/&gt;
+                       ...&lt;/p&gt;

&lt;p&gt;Since whereClause here is actually an AndNode, not a SubqueryNode, the &quot;if&quot; statement&lt;br/&gt;
above is not triggered, thus the query is incorrectly flattened into an EXISTS joins.  The&lt;br/&gt;
end result is that the query only returns 5 rows when it should return 7 (the extra &quot;1 = 1&quot;&lt;br/&gt;
predicate shouldn&apos;t affect the results).&lt;/p&gt;

&lt;p&gt;I think I mentioned a few comments ago that it might be possible to use a CollectNodesVisitor&lt;br/&gt;
to search the whereClause for any SubqueryNodes.  The above example demonstrates why&lt;br/&gt;
such a visitor would be helpful, as opposed to just checking directly for a SubqueryNode...&lt;/p&gt;

&lt;p&gt;So to answer Dyre&apos;s question, yes, I think a master update will be needed.  But further&lt;br/&gt;
inspection of subqueryFlattening.sql shows that the 4c patch may need a few more&lt;br/&gt;
tweaks, after all...&lt;/p&gt;</comment>
                            <comment id="12563660" author="clr" created="Tue, 29 Jan 2008 20:50:42 +0000"  >&lt;p&gt;Here are more queries, just slightly modified from the original queries. I&apos;ve done little editing of the queries to avoid introducing copy/paste errors. &lt;/p&gt;

&lt;p&gt;This one works:&lt;br/&gt;
SELECT UNBOUND_E.PERSONID FROM applicationidentity0.DEPARTMENTS THIS , applicationidentity0.PERSONS UNBOUND_E &lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM applicationidentity0.PERSONS THIS_EMPLOYEES_E &lt;br/&gt;
      WHERE THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID AND UNBOUND_E.PERSONID = THIS_EMPLOYEES_E.PERSONID AND THIS.ID = &amp;lt;2&amp;gt;)&lt;/p&gt;

&lt;p&gt;This fails, returns 5 rows where 7 are expected. The difference between this and the original query is that THIS.ID is also returned in the outer select:&lt;br/&gt;
SELECT THIS.ID,UNBOUND_E.PERSONID,UNBOUND_P.PROJID FROM applicationidentity0.DEPARTMENTS THIS , applicationidentity0.PERSONS UNBOUND_E , applicationidentity0.PROJECTS UNBOUND_P &lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM applicationidentity0.PERSONS THIS_EMPLOYEES_E &lt;br/&gt;
      WHERE EXISTS (&lt;br/&gt;
        SELECT 1 FROM applicationidentity0.PROJECT_MEMBER THIS_EMPLOYEES_E_PROJECTS_P &lt;br/&gt;
         WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;MEMBER&quot; = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
           AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID &lt;br/&gt;
           AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID &lt;br/&gt;
           AND UNBOUND_E.PERSONID = THIS_EMPLOYEES_E.PERSONID&lt;br/&gt;
))&lt;/p&gt;

&lt;p&gt;This fails, returns 3 rows where 5 are expected. &lt;br/&gt;
SELECT UNBOUND_E.PERSONID,UNBOUND_P.PROJID FROM applicationidentity0.DEPARTMENTS THIS , applicationidentity0.PERSONS UNBOUND_E , applicationidentity0.PROJECTS UNBOUND_P &lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM applicationidentity0.PERSONS THIS_EMPLOYEES_E &lt;br/&gt;
      WHERE EXISTS (&lt;br/&gt;
        SELECT 1 FROM applicationidentity0.PROJECT_MEMBER THIS_EMPLOYEES_E_PROJECTS_P &lt;br/&gt;
          WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;MEMBER&quot; = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
          AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID &lt;br/&gt;
          AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID &lt;br/&gt;
          AND UNBOUND_E.PERSONID = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
          AND THIS.ID = &amp;lt;1&amp;gt;))&lt;/p&gt;

&lt;p&gt;This fails, returning 5 rows where 7 are expected.&lt;br/&gt;
SELECT UNBOUND_E.PERSONID,UNBOUND_P.PROJID FROM applicationidentity0.DEPARTMENTS THIS , applicationidentity0.PERSONS UNBOUND_E , applicationidentity0.PROJECTS UNBOUND_P &lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM applicationidentity0.PERSONS THIS_EMPLOYEES_E &lt;br/&gt;
      WHERE EXISTS (&lt;br/&gt;
        SELECT 1 FROM applicationidentity0.PROJECT_MEMBER THIS_EMPLOYEES_E_PROJECTS_P &lt;br/&gt;
          WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;MEMBER&quot; = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
          AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID &lt;br/&gt;
          AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID &lt;br/&gt;
          AND UNBOUND_E.PERSONID = THIS_EMPLOYEES_E.PERSONID &lt;br/&gt;
          AND THIS.COMPANYID = &amp;lt;1&amp;gt;))&lt;/p&gt;
</comment>
                            <comment id="12563914" author="dyret" created="Wed, 30 Jan 2008 09:12:20 +0000"  >&lt;p&gt;AB&amp;gt; I was operating on the assumption that derbyall ran cleanly with the 4c patch; I hadn&apos;t run it myself.&lt;/p&gt;

&lt;p&gt;I talked to Thomas offline yesterday and he was adamant that he HAD run derbyall with 0 failed tests. Which was true, except that when he looked closer at derbyall_report.txt it turned out that&lt;br/&gt;
an environment problem also had caused 0 tests to be run...&lt;/p&gt;</comment>
                            <comment id="12564157" author="thomanie" created="Wed, 30 Jan 2008 19:57:21 +0000"  >&lt;p&gt;Very sorry for the derbyall hickup :|&lt;/p&gt;

&lt;p&gt;Attaching &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;updated patch &apos;derby-3301-5.diff&apos;  which uses a CollectNodesVisitor to find all lower SubqueryNodes as pointed out by Army.&lt;/li&gt;
	&lt;li&gt;extra sql script in &apos;derby-3301-extra.sql&apos; containig Craigs additional queries modified to work with the original repro script schema sql&apos;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With the 5 patch applied both the original query and the additional queries Craig posted return as expected. See output below.&lt;br/&gt;
I still need to &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;have another look at Armys latest variant, as it doesn&apos;t seem to end up with a similar querytree to the others (i.e no SubqueryNodes in the WHERE clause).&lt;/li&gt;
	&lt;li&gt;modify the master output for lang/subqueryFlattening.sql.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ij&amp;gt; &lt;br/&gt;
select unbound_e.empid, unbound_p.projid &lt;br/&gt;
from departments this, &lt;br/&gt;
     employees unbound_e, &lt;br/&gt;
     projects unbound_p &lt;br/&gt;
where exists ( &lt;br/&gt;
    select 1 from employees this_employees_e &lt;br/&gt;
    where exists ( &lt;br/&gt;
        select 1 from project_employees this_employees_e_projects_p &lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid &lt;br/&gt;
        and this_employees_e.department = this.id &lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid &lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid) &lt;br/&gt;
    ); &lt;/p&gt;

&lt;p&gt;EMPID      |PROJID     &lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101        &lt;br/&gt;
12         |101        &lt;br/&gt;
13         |101        &lt;br/&gt;
12         |102        &lt;br/&gt;
13         |102        &lt;br/&gt;
14         |103        &lt;br/&gt;
15         |103        &lt;/p&gt;

&lt;p&gt;7 rows selected&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;Craigs additional queries:&lt;br/&gt;
ij&amp;gt;&lt;br/&gt;
SELECT UNBOUND_E.empid FROM DEPARTMENTS THIS , employees UNBOUND_E&lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM employees THIS_EMPLOYEES_E&lt;br/&gt;
      WHERE THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID AND UNBOUND_E.empid = THIS_EMPLOYEES_E.empid AND THIS.ID = 2);&lt;br/&gt;
EMPID      &lt;br/&gt;
-----------&lt;br/&gt;
14         &lt;br/&gt;
15         &lt;/p&gt;

&lt;p&gt;2 rows selected &lt;br/&gt;
ij&amp;gt; &lt;br/&gt;
SELECT THIS.ID,UNBOUND_E.empid,UNBOUND_P.PROJID FROM DEPARTMENTS THIS , employees UNBOUND_E , projects UNBOUND_P&lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM employees THIS_EMPLOYEES_E&lt;br/&gt;
      WHERE EXISTS (&lt;br/&gt;
        SELECT 1 FROM project_employees THIS_EMPLOYEES_E_PROJECTS_P&lt;br/&gt;
         WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;EMPID&quot; = THIS_EMPLOYEES_E.empid&lt;br/&gt;
           AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID&lt;br/&gt;
           AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID&lt;br/&gt;
           AND UNBOUND_E.empid = THIS_EMPLOYEES_E.empid&lt;br/&gt;
));&lt;br/&gt;
ID         |EMPID      |PROJID     &lt;br/&gt;
-----------------------------------&lt;br/&gt;
1          |11         |101        &lt;br/&gt;
1          |12         |101        &lt;br/&gt;
1          |13         |101        &lt;br/&gt;
1          |12         |102        &lt;br/&gt;
1          |13         |102        &lt;br/&gt;
2          |14         |103        &lt;br/&gt;
2          |15         |103        &lt;/p&gt;

&lt;p&gt;7 rows selected&lt;br/&gt;
ij&amp;gt; &lt;br/&gt;
SELECT UNBOUND_E.empid,UNBOUND_P.PROJID FROM DEPARTMENTS THIS , employees UNBOUND_E , PROJECTS UNBOUND_P&lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM employees THIS_EMPLOYEES_E&lt;br/&gt;
      WHERE EXISTS (&lt;br/&gt;
        SELECT 1 FROM project_employees THIS_EMPLOYEES_E_PROJECTS_P&lt;br/&gt;
          WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;EMPID&quot; = THIS_EMPLOYEES_E.empid&lt;br/&gt;
          AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID&lt;br/&gt;
          AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID&lt;br/&gt;
          AND UNBOUND_E.empid = THIS_EMPLOYEES_E.empid&lt;br/&gt;
          AND THIS.ID = 1));&lt;br/&gt;
EMPID      |PROJID     &lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101        &lt;br/&gt;
12         |101        &lt;br/&gt;
13         |101        &lt;br/&gt;
12         |102        &lt;br/&gt;
13         |102        &lt;/p&gt;

&lt;p&gt;5 rows selected&lt;br/&gt;
ij&amp;gt;&lt;br/&gt;
SELECT UNBOUND_E.empid,UNBOUND_P.PROJID FROM DEPARTMENTS THIS , employees UNBOUND_E , PROJECTS UNBOUND_P&lt;br/&gt;
  WHERE EXISTS (&lt;br/&gt;
    SELECT 1 FROM employees THIS_EMPLOYEES_E&lt;br/&gt;
      WHERE EXISTS (&lt;br/&gt;
        SELECT 1 FROM project_employees THIS_EMPLOYEES_E_PROJECTS_P&lt;br/&gt;
          WHERE THIS_EMPLOYEES_E_PROJECTS_P.&quot;EMPID&quot; = THIS_EMPLOYEES_E.empid&lt;br/&gt;
          AND UNBOUND_P.PROJID = THIS_EMPLOYEES_E_PROJECTS_P.PROJID&lt;br/&gt;
          AND THIS_EMPLOYEES_E.DEPARTMENT = THIS.ID&lt;br/&gt;
          AND UNBOUND_E.empid = THIS_EMPLOYEES_E.empid&lt;br/&gt;
          AND THIS.COMPANYID = 1));&lt;br/&gt;
EMPID      |PROJID     &lt;br/&gt;
-----------------------&lt;br/&gt;
11         |101        &lt;br/&gt;
12         |101        &lt;br/&gt;
13         |101        &lt;br/&gt;
12         |102        &lt;br/&gt;
13         |102        &lt;br/&gt;
14         |103        &lt;br/&gt;
15         |103        &lt;/p&gt;

&lt;p&gt;7 rows selected&lt;br/&gt;
ij&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12564176" author="thomanie" created="Wed, 30 Jan 2008 21:31:26 +0000"  >&lt;p&gt;Attaching updated master file for lang/subqueryFlattening. Diffs only in qyeryplans, so the changes in patch 5 produce identical results for the tested queries. &lt;br/&gt;
When run standalone the updated lang/subqueryFlattening test pass.&lt;/p&gt;</comment>
                            <comment id="12564224" author="army" created="Wed, 30 Jan 2008 23:42:49 +0000"  >&lt;p&gt;&amp;gt; I still need to have another look at Armys latest variant, as it doesn&apos;t seem to end&lt;br/&gt;
&amp;gt; up with a similar querytree to the others&lt;/p&gt;

&lt;p&gt;Actually, I think the query does fit the general shape. In your v5 patch you iterate through each of&lt;br/&gt;
the SubqueryNode&apos;s that are found by CollectNodesVisitor and check to see if any of them was&lt;br/&gt;
marked as a &quot;whereSubquery()&quot;. For some reason that check fails in the query that I posted--i.e.&lt;br/&gt;
the one where I include the &quot;1 = 1&quot; predicate. While I don&apos;t know why the call to whereSubquery()&lt;br/&gt;
returns false, I also don&apos;t think that it&apos;s necessary at this particular point.&lt;/p&gt;

&lt;p&gt;The code that calls CollectNodesVisitor is this line:&lt;/p&gt;

&lt;p&gt;          sn.originalWhereClause.accept(cnv);&lt;/p&gt;

&lt;p&gt;Since we&apos;re visiting the original WHERE clause, any SubqueryNodes that we find are necessarily&lt;br/&gt;
going to be &quot;WHERE subqueries&quot; because we found them in a WHERE clause. So it seems like&lt;br/&gt;
we shouldn&apos;t have to call &quot;isWhereSubquery()&quot; on any of them--we just need to check to see if the&lt;br/&gt;
CollectNodesVisitor found at least one, and if so, we&apos;re done. I changed your version 5 patch to&lt;br/&gt;
look like this:&lt;/p&gt;

&lt;p&gt;  ....&lt;br/&gt;
                if (sn.originalWhereClause != null)&lt;/p&gt;
                {
                    /* Second instance of SubqueryNode.class effectively means &quot;don&apos;t bother
                     * searching beneath SubqueryNodes since if we found one, we&apos;re done.&quot;
                     */
                    CollectNodesVisitor cnv =
                        new CollectNodesVisitor(
                            SubqueryNode.class, SubqueryNode.class);

                    sn.originalWhereClause.accept(cnv);
                    return cnv.getList().isEmpty();
                }
&lt;p&gt;  ....&lt;/p&gt;

&lt;p&gt;and with that change (everything else the same), the query with &quot;1 = 1&quot; returns 7 rows, as it should. The&lt;br/&gt;
other queries mentioned by Craig also return the correct results (assuming the first one is supposed to&lt;br/&gt;
return 2 rows, which I assume it is...?)&lt;/p&gt;

&lt;p&gt;So it looks like the use of CollectNodesVisitor does help. As for the issue of why the SubqueryNode&apos;s&lt;br/&gt;
found in originalWhereClause return false for &quot;isWhereSubquery()&quot;, I haven&apos;t looked at that.&lt;/p&gt;</comment>
                            <comment id="12564225" author="army" created="Wed, 30 Jan 2008 23:46:03 +0000"  >&lt;p&gt;On a complete unrelated note, I think the preference for Derby codeline is to keep lines&lt;br/&gt;
shorter than 80 characters (where possible).  Some of the lines in the latest patch look&lt;br/&gt;
to exceed that.  Not a big deal, but thought I&apos;d mention it.&lt;/p&gt;</comment>
                            <comment id="12564256" author="clr" created="Thu, 31 Jan 2008 01:19:06 +0000"  >&lt;p&gt;&amp;gt; and with that change (everything else the same), the query with &quot;1 = 1&quot; returns 7 rows, as it should. The other queries mentioned by Craig also return the correct results (assuming the first one is supposed to return 2 rows, which I assume it is...?) &lt;/p&gt;

&lt;p&gt;Yes, it is supposed to return 2 rows. It&apos;s not a particularly interesting query since it works with or without the patch, but I included it because it also uses the EXISTS pattern.&lt;/p&gt;

&lt;p&gt;And let me say again I appreciate all the effort you all are putting into this.&lt;/p&gt;

&lt;p&gt;Craig&lt;/p&gt;</comment>
                            <comment id="12564312" author="clr" created="Thu, 31 Jan 2008 06:11:40 +0000"  >&lt;p&gt;I&apos;ve applied the patch derby-3301-5.diff and rebuilt the derby and derbytools jars.&lt;/p&gt;

&lt;p&gt;The JDO TCK tests that fail on the released jars now pass with the patch applied.&lt;/p&gt;

&lt;p&gt;Thanks so much for getting this bug resolved to this point. This is no longer a blocker for me, assuming that the changes can be committed to the code line and a patch release made in due course.&lt;/p&gt;

&lt;p&gt;Craig&lt;/p&gt;
</comment>
                            <comment id="12564337" author="thomanie" created="Thu, 31 Jan 2008 08:32:22 +0000"  >&lt;p&gt;Reattaching the derby-3301-extra.sql script with Armys 1=1 variant included as well.&lt;/p&gt;

&lt;p&gt;Attaching derby-3301-6.diff with Armys latest comments&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fixed length of some lines&lt;/li&gt;
	&lt;li&gt;CollectNodesVisitor stops when finding the first SubqueryNode.&lt;/li&gt;
	&lt;li&gt;no need to check for isWhereSubquery() when using the CNV on the original where clause, we already know it is&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All reported queries work as expected with the 6 patch.&lt;/p&gt;

&lt;p&gt;suites.All and derbyall are running.&lt;/p&gt;

&lt;p&gt;Thanks for all your help Army, and to Craig for the positive feedback!&lt;/p&gt;</comment>
                            <comment id="12564441" author="army" created="Thu, 31 Jan 2008 18:14:03 +0000"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;I really hate to keep bringing up more issues, but as I was about to sign off on patch 6, the&lt;br/&gt;
following caught my eye:&lt;/p&gt;

&lt;p&gt;                   /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This WHERE EXISTS | ANY | IN subquery has another&lt;/li&gt;
	&lt;li&gt;subquery in its own WHERE &lt;b&gt;clause&lt;/b&gt; if the CNV is not&lt;/li&gt;
	&lt;li&gt;empty.&lt;br/&gt;
                    */&lt;br/&gt;
                   return cnv.getList().isEmpty();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Note how the code comments don&apos;t match the code--there&apos;s a missing &quot;!&quot; operator in the&lt;br/&gt;
actual code.  This is how I wrote it in my previous comment, but that was wrong.  The&lt;br/&gt;
method is supposed to return &quot;true&quot; if the SubqueryNode has a WHERE clause with&lt;br/&gt;
another subquery in it--which will be true if cnv.getList() is NOT empty.  So I missed&lt;br/&gt;
the negation (sorry).&lt;/p&gt;

&lt;p&gt;With this fix in place all of Craigs queries still run correctly--but the queries with&lt;br/&gt;
&quot;1 = 1&quot; in them start failing again.  In tracing it turns out that, for those cases,&lt;br/&gt;
the CollectNodesVisitor does not find the SubqueryNodes in &quot;sn.originalWhereClause&quot;.&lt;br/&gt;
I think it comes down to something you mentioned earlier, namely:&lt;/p&gt;

&lt;p&gt;&amp;gt; I still need to have another look at &lt;span class=&quot;error&quot;&gt;&amp;#91;the &amp;quot;1 = 1&amp;quot;&amp;#93;&lt;/span&gt; variant, as it doesn&apos;t seem&lt;br/&gt;
&amp;gt; to end up with a similar querytree to the others&lt;/p&gt;

&lt;p&gt;Upon further inspection, I think you are right about this.&lt;/p&gt;

&lt;p&gt;For reference, this is the query in question.  Note the tags on the right for&lt;br/&gt;
the sake of discussion, where &quot;SN&quot; implies &quot;SelectNode&quot;:&lt;/p&gt;

&lt;p&gt;select unbound_e.empid, unbound_p.projid                             &amp;#8211; SN_OUTER&lt;br/&gt;
from departments this,&lt;br/&gt;
     employees unbound_e,&lt;br/&gt;
     projects unbound_p&lt;br/&gt;
where exists (&lt;br/&gt;
    select 1 from employees this_employees_e                         &amp;#8211; SN_INNER_1&lt;br/&gt;
    where 1 = 1 and exists (&lt;br/&gt;
        select 1 from project_employees this_employees_e_projects_p  &amp;#8211; SN_INNER_2&lt;br/&gt;
        where this_employees_e_projects_p.empid = this_employees_e.empid&lt;br/&gt;
        and this_employees_e.department = this.id&lt;br/&gt;
        and unbound_p.projid = this_employees_e_projects_p.projid&lt;br/&gt;
        and unbound_e.empid = this_employees_e.empid)&lt;br/&gt;
    );&lt;/p&gt;

&lt;p&gt;By the time we reach SubqueryNode.isWhereExistsAnyInWithWhereSubquery() for the&lt;br/&gt;
SubqueryNode wrapping SN_INNER_1, the clause:&lt;/p&gt;

&lt;p&gt;  where 1 = 1 and exists ( ... )&lt;/p&gt;

&lt;p&gt;ends up as an AndNode whose left operand is &quot;1 = 1&quot; but whose right operand is the&lt;br/&gt;
constant literal TRUE--which is not what we expect.  We expect the AndNode&apos;s right&lt;br/&gt;
operand to be the SubqueryNode corresponding to SN_INNER_2.  That is, if &quot;sn&quot; is the&lt;br/&gt;
SelectNode for SN_INNER_1 then sn.originalWhereClause should include the SubqueryNode&lt;br/&gt;
that wraps SN_INNER_2.  That is true when we first set sn.originalWhereClause in the&lt;br/&gt;
init() method of SelectNode--but by the time we get to preprocessing for the SubqueryNode&lt;br/&gt;
wrapping SN_INNER_1, the SubqueryNode for SN_INNER_2 is no longer in SN_INNER_1&apos;s&lt;br/&gt;
originalWhereClause.&lt;/p&gt;

&lt;p&gt;From what I can tell, this is because sn.originalWhereClause for SN_INNER_1 points to&lt;br/&gt;
the same object as sn.whereClause.  So when sn.whereClause is itself transformed due to&lt;br/&gt;
flattening of the subquery SN_INNER_2 (which is legal), sn.originalWhereClause() sees&lt;br/&gt;
the same transformation.  Thus the SubqueryNode wrapping SN_INNER_2 disappears from&lt;br/&gt;
sn.whereClause, which is good--but it also disappears from sn.originalWhereClause(),&lt;br/&gt;
which is bad.  The fact that it disappears means that CollectNodesVisitor for SN_INNER_1&lt;br/&gt;
will not find it, and thus SN_INNER_1 will be flattened, which is not legal.&lt;/p&gt;

&lt;p&gt;With the negation operator gone (as in patch 6), the fact that we can&apos;t find the SubqueryNode&lt;br/&gt;
for SN_INNER_2 causes the method to incorrectly return &quot;true&quot; (because CNV&apos;s list is empty),&lt;br/&gt;
which is then negated by the caller and thus flattening of SN_INNER_1 is accidentally (but&lt;br/&gt;
correctly) avoided.  I think it&apos;s clear that the negation operator should be there, though.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure what the best way to address that would be--but before you go there,&lt;br/&gt;
can you double-check these findings to see if you agree?  Maybe I&apos;m just missing&lt;br/&gt;
something obvious...&lt;/p&gt;

&lt;p&gt;Apologies for the negation slip-up to begin with.&lt;/p&gt;</comment>
                            <comment id="12564465" author="thomanie" created="Thu, 31 Jan 2008 19:21:46 +0000"  >&lt;p&gt;Another excellent catch Army! I&apos;m very glad you&apos;re helping out, so do not feel bad about bringing these things up!&lt;/p&gt;

&lt;p&gt;I didn&apos;t report back on the testing of the 6 patch - due to fact that my updated derbyall test failed. It fails for that exact reason - missing negation on &lt;br/&gt;
   return cnv.getList().isEmpty();&lt;/p&gt;

&lt;p&gt;Fixed the missing negation in derby-3301-7.diff.&lt;/p&gt;

&lt;p&gt;With the 7 patch&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;all of Craigs queries work as expected&lt;/li&gt;
	&lt;li&gt;updated lang/subqueryFlattening.sql (part of derbyall) pass&lt;/li&gt;
	&lt;li&gt;new NestedWhereSubqueryTest (part of suites.All)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ll rerun derbyall and suites.All with the 7 patch to verify nothing else broke.&lt;/p&gt;

&lt;p&gt;With the 7 patch the 1=1 variant returns only 3 rows, and I&apos;ll need to have a further look into this. From what I found at last glance, I think you are onto it with your explaination. If I remember correctly I had the &lt;br/&gt;
AndNode in the whereClause with the 1=1 as its left node and a TRUE as its right node (as you describe). The where subqueries had ended up in the wherePredicates list. But this needs a more thorough look.&lt;/p&gt;

&lt;p&gt;Given Craigs urgency with getting this fixed, do you think we can commit the 7 patch, and leave the 1=1 for a later commit?&lt;/p&gt;</comment>
                            <comment id="12564474" author="army" created="Thu, 31 Jan 2008 19:45:01 +0000"  >&lt;p&gt;&amp;gt; With the 7 patch the 1=1 variant returns only 3 rows, and I&apos;ll need to have a further&lt;br/&gt;
&amp;gt; look into this. &lt;/p&gt;

&lt;p&gt;One thing that occurred me: would it be possible to replace the originalWhereSubquerys field&lt;br/&gt;
in SelectNode with a simple boolean, something like origWhereClauseHadSubqueries.  Then&lt;br/&gt;
in the init() method of SelectNode you could invoke the CollectNodeVisitor on whereClause&lt;br/&gt;
and set the boolean to true if you find any SubqueryNodes.  That way the boolean would not&lt;br/&gt;
be affected by subsequent binding/preprocessing transformations.  If you do that, then the code&lt;br/&gt;
in SubqueryNode.isWhereExistsAnyInWithWhereSubquery() could theoretically replace the&lt;br/&gt;
sn.origWhereClause and sn.origWhereSubquerys processing with a simple check of&lt;br/&gt;
sn.origWhereClauseHadSubqueries.  I haven&apos;t actually tried it, but I wonder if that might be&lt;br/&gt;
a simple way to get things working...&lt;/p&gt;

&lt;p&gt;&amp;gt; With the 7 patch&lt;br/&gt;
&amp;gt; - updated lang/subqueryFlattening.sql (part of derbyall) pass&lt;br/&gt;
&amp;gt; - new NestedWhereSubqueryTest (part of suites.All) &lt;/p&gt;

&lt;p&gt;Are these intended to be part of the 7 patch, or are these going to be attached separately?&lt;/p&gt;

&lt;p&gt;&amp;gt; Given Craigs urgency with getting this fixed, do you think we can commit the 7 patch, and&lt;br/&gt;
&amp;gt; leave the 1=1 for a later commit?&lt;/p&gt;

&lt;p&gt;If the 7 patch passes the regression tests, and if you understand all of the updates that were necessary&lt;br/&gt;
for subqueryFlattening.sql, then yes, I think this would be fine.  Incremental development is a good thing &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12564481" author="thomanie" created="Thu, 31 Jan 2008 20:11:27 +0000"  >&lt;p&gt;That sounds like a doable approach Army - I&apos;ll give it a go and let you know how it works out.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; - updated lang/subqueryFlattening.sql (part of derbyall) pass&lt;br/&gt;
&amp;gt;&amp;gt; - new NestedWhereSubqueryTest (part of suites.All)&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Are these intended to be part of the 7 patch, or are these going to be attached separately?&lt;/p&gt;

&lt;p&gt;They are already attached derby-3301-master.diff and derby-3301-test-4.diff respectively &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I agree the names of the test patches could be a lot better...&lt;/p&gt;</comment>
                            <comment id="12564509" author="thomanie" created="Thu, 31 Jan 2008 21:32:02 +0000"  >&lt;p&gt;Armys suggestion of flagging the SelectNode as having subqueries in its where clause in init() using a ColletNodesVisitor seems to work like a charm &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Attaching &apos;derby-3301-8.diff&apos; which implements this change to the 7 diff.&lt;/p&gt;

&lt;p&gt;Had to revisit my subqueryFlattening.sql master diff with this change though, so I&apos;m attaching an updated master in &apos;derby-3301-test-master-2.diff. The changes to the master are correct to my knowledge - replace some of the PRNs and Hash Exists Joins with subqueries and Index Scan nodes. Just what we want &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The 8 patch works for&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;all reported queries, including the 1=1 variant.&lt;/li&gt;
	&lt;li&gt;new NestedWhereSubqueryTest with test-4 patch applied&lt;/li&gt;
	&lt;li&gt;lang/subqueryFlattening.sql with test-master-2 patch applied&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ll rerun derbyall and suites.All on the 8 patch.&lt;/p&gt;</comment>
                            <comment id="12564722" author="thomanie" created="Fri, 1 Feb 2008 11:02:01 +0000"  >&lt;p&gt;Updated derbyall pass and lang._Suite runs successfully with the 8 code patch, and the master-2 and test-4 test patches applied.&lt;/p&gt;

&lt;p&gt;I still get some unrelated errors in SecureServerTest in suites.All on Windows, but not on Solaris - I believe it&apos;s an environment issue and has nothing to do with the code patch.&lt;/p&gt;

&lt;p&gt;Patches should hopefully be ready for final review, and commit &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12564885" author="dyret" created="Fri, 1 Feb 2008 19:10:45 +0000"  >&lt;p&gt;Hi Thomas, thank you for your continued hard work on this. &lt;br/&gt;
Just to clarify: In your last comment you mention a test-4 patch, but there is no test-4 patch, only a test-3 patch (dated 28. Jan). I can apply the test-3 patch, but it results&lt;br/&gt;
in compilation errors:&lt;/p&gt;

&lt;p&gt;compilet1:&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; Compiling 95 source files to /export/home/tmp/derby/derby-scratch/classes&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; /export/home/tmp/derby/derby-scratch/java/testing/org/apache/derbyTesting/functionTests/tests/lang/NestedWhereSubqueryTest.java:229: class or interface expected&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; package org.apache.derbyTesting.functionTests.tests.lang;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; ^&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; /export/home/tmp/derby/derby-scratch/java/testing/org/apache/derbyTesting/functionTests/tests/lang/NestedWhereSubqueryTest.java:231: class or interface expected&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; import java.sql.ResultSet;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;javac&amp;#93;&lt;/span&gt; ^&lt;/p&gt;

&lt;p&gt;...&lt;/p&gt;

</comment>
                            <comment id="12564955" author="thomanie" created="Fri, 1 Feb 2008 22:08:24 +0000"  >&lt;p&gt;Oh dear... test-4 is a typo, it should say test-3 in my latest comments.&lt;/p&gt;

&lt;p&gt;The new test in test-3 is only 209 lines long, and your build error happens at 229.&lt;br/&gt;
I think your environment managed to duplicate the contents of the new file? NB 6.0 seems to do that if you apply a diff with a newly created file twice btw.&lt;/p&gt;</comment>
                            <comment id="12565419" author="army" created="Mon, 4 Feb 2008 16:50:35 +0000"  >&lt;p&gt;I applied patch 8 and verified that the reported queries return correct results.&lt;/p&gt;

&lt;p&gt;I haven&apos;t applied the test/master patches, nor have I run the regression tests, but based on&lt;br/&gt;
inspection, I think it might be nice to update the comments preceding the affected query plans&lt;br/&gt;
in derby-3301-test-master-2.diff so that they agree with the new results--i.e. indicate which parts&lt;br/&gt;
of the query should/should not be flattened, and explain why.  But that can come as cleanup,&lt;br/&gt;
it doesn&apos;t need to block commit of the current patches.&lt;/p&gt;

&lt;p&gt;No other comments to make; thanks again, Thomas!&lt;/p&gt;</comment>
                            <comment id="12565671" author="dyret" created="Tue, 5 Feb 2008 09:32:30 +0000"  >&lt;p&gt;Committed revision 618586.&lt;/p&gt;

&lt;p&gt;Yes Thomas, the test-3 patch compiled cleanly when i manually deleted the old version of that file. (svn revert will not delete added files). All tests passed too.&lt;/p&gt;</comment>
                            <comment id="12565805" author="clr" created="Tue, 5 Feb 2008 16:49:05 +0000"  >&lt;p&gt;Hooray. Thanks everyone for your efforts on this.&lt;/p&gt;

&lt;p&gt;Craig&lt;/p&gt;</comment>
                            <comment id="12566742" author="thomanie" created="Thu, 7 Feb 2008 18:54:35 +0000"  >&lt;p&gt;Army&amp;gt; I think it might be nice to update the comments preceding the affected query plans&lt;br/&gt;
Army&amp;gt; in derby-3301-test-master-2.diff so that they agree with the new results&lt;/p&gt;

&lt;p&gt;Attaching derby-3301-test-master-3.diff with updates to the two comments preceeding the changed queryplans.&lt;br/&gt;
The updated test pass.&lt;/p&gt;

&lt;p&gt;Craig, can you confirm the current trunk works for you, and if so can we close the issue once the last comment patch has been comitted?&lt;/p&gt;</comment>
                            <comment id="12566747" author="army" created="Thu, 7 Feb 2008 19:13:39 +0000"  >&lt;p&gt;&amp;gt; Attaching derby-3301-test-master-3.diff with updates to the two comments preceeding&lt;br/&gt;
&amp;gt; the changed queryplans.&lt;/p&gt;

&lt;p&gt;Thanks, Thomas.&lt;/p&gt;</comment>
                            <comment id="12566752" author="army" created="Thu, 7 Feb 2008 19:35:52 +0000"  >&lt;p&gt;Committed derby-3301-test-master-3.diff with svn # 619591.&lt;/p&gt;</comment>
                            <comment id="12566805" author="thomanie" created="Thu, 7 Feb 2008 21:27:43 +0000"  >&lt;p&gt;Thanks for committing, Army.&lt;/p&gt;</comment>
                            <comment id="12569203" author="thomanie" created="Fri, 15 Feb 2008 08:23:01 +0000"  >&lt;p&gt;Marking as resolved for 10.4.0.0.&lt;/p&gt;

&lt;p&gt;This fix should probably be merged to 10.3 too?&lt;/p&gt;</comment>
                            <comment id="12569506" author="clr" created="Sat, 16 Feb 2008 03:57:05 +0000"  >&lt;p&gt;I&apos;m convinced that this issue is resolved. I think it should stay open until a release containing the fix is made. Is that correct?&lt;/p&gt;</comment>
                            <comment id="12569508" author="narayanan" created="Sat, 16 Feb 2008 04:07:40 +0000"  >&lt;p&gt;I think you can find more information about what to do here&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.apache.org/db-derby/DerbyCommitProcess&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/DerbyCommitProcess&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12569559" author="dyret" created="Sat, 16 Feb 2008 13:33:33 +0000"  >&lt;p&gt;Thanks for confirming Craig. I&apos;m planning to merge it to 10.3. I just need to run the tests before I can commit the merge. After that I think it is OK to close it.&lt;/p&gt;</comment>
                            <comment id="12569820" author="dyret" created="Mon, 18 Feb 2008 09:26:54 +0000"  >&lt;p&gt;Merged main fix to 10.3 in revision 628661.&lt;/p&gt;</comment>
                            <comment id="12569825" author="dyret" created="Mon, 18 Feb 2008 09:43:46 +0000"  >&lt;p&gt;Merged the subqueryFlattening fix to 10.3 with revision 628669.&lt;/p&gt;</comment>
                            <comment id="12569829" author="thomanie" created="Mon, 18 Feb 2008 09:51:34 +0000"  >&lt;p&gt;Thanks Dyre&lt;/p&gt;</comment>
                            <comment id="12580135" author="dyret" created="Tue, 18 Mar 2008 22:13:20 +0000"  >&lt;p&gt;This issue has fix version 10.4 and is marked with either &apos;Release note needed&apos; or &apos;Existing application impact&apos;, but does not have a releaseNote.html attached to it. Should it?&lt;/p&gt;</comment>
                            <comment id="12580146" author="mcaisse" created="Tue, 18 Mar 2008 22:33:24 +0000"  >&lt;p&gt;I&apos;m not sure. I forwarded the question to Craig. I was not following the &lt;br/&gt;
implication of this issue beyond the fact that if caused a JDO TCK test &lt;br/&gt;
to fail.&lt;/p&gt;

&lt;p&gt;&amp;#8211; Michelle&lt;/p&gt;

</comment>
                            <comment id="12580155" author="clr" created="Tue, 18 Mar 2008 22:46:20 +0000"  >&lt;p&gt;Seems like a release note might be appropriate. I could try to put together a description from the body of this JIRA if someone can give me a clue as to the format of a releaseNote.html attachment.&lt;/p&gt;</comment>
                            <comment id="12580514" author="dyret" created="Wed, 19 Mar 2008 19:40:45 +0000"  >&lt;p&gt;The following Wiki page &lt;br/&gt;
&lt;a href=&quot;http://wiki.apache.org/db-derby/ReleaseNoteProcess&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/ReleaseNoteProcess&lt;/a&gt;&lt;br/&gt;
has some info about how to format releaseNote.html&lt;/p&gt;</comment>
                            <comment id="12580572" author="clr" created="Wed, 19 Mar 2008 21:36:01 +0000"  >&lt;p&gt;I&apos;ve tried to summarize the issue with the attached release note.&lt;/p&gt;</comment>
                            <comment id="12580576" author="djd" created="Wed, 19 Mar 2008 21:44:27 +0000"  >&lt;p&gt;I think the release note has its sections or tenses mixed up:&lt;/p&gt;

&lt;p&gt;&amp;gt; Applications that execute SQL statements containing nested EXISTS clauses can see fewer rows than satisfy the query.&lt;/p&gt;

&lt;p&gt;Hopefully Derby returns the correct results, not fewer rows than the query is meant to return.&lt;/p&gt;</comment>
                            <comment id="12580578" author="kmarsden" created="Wed, 19 Mar 2008 21:53:23 +0000"  >&lt;p&gt;I think also the file needs to be called releaseNote.html for it to work with the&lt;br/&gt;
release note generator.&lt;/p&gt;</comment>
                            <comment id="12580580" author="clr" created="Wed, 19 Mar 2008 21:58:44 +0000"  >&lt;p&gt;I&apos;ve changed the description to address the tense issue, and changed the name of the file.&lt;/p&gt;</comment>
                            <comment id="12580586" author="djd" created="Wed, 19 Mar 2008 22:14:26 +0000"  >&lt;p&gt;Looks better, I think the &quot;Summary of the Change&quot; section is incorrect:&lt;/p&gt;

&lt;p&gt;&amp;gt; Derby can return fewer rows than expected.&lt;/p&gt;

&lt;p&gt;That describes the old bug not a change, well it doesn&apos;t really describe anything since it&apos;s so vague. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Is the summary more along the lines of:&lt;/p&gt;

&lt;p&gt;Queries with nested EXIST clauses now return correct results.&lt;/p&gt;

&lt;p&gt;???&lt;/p&gt;

&lt;p&gt;Maybe someone more familiar with the issue could come up with the correct wording?&lt;/p&gt;

&lt;p&gt;I&apos;m not really sure that such changes require release notes, looking at this:&lt;/p&gt;

&lt;p&gt;&amp;gt; Applications that depended on the previous incorrect behavior will need to be updated.&lt;/p&gt;

&lt;p&gt;what does that really mean? How would such an application be updated?&lt;/p&gt;

&lt;p&gt;Maybe a release note is good, but not suggesting application changes. More along the&lt;br/&gt;
lines of:&lt;/p&gt;

&lt;p&gt; &amp;gt; Applications using nested EXISTS may have previously returned incorrect results.&lt;/p&gt;

&lt;p&gt;which is what the Symptoms section is for (and says) so maybe these two sections are&lt;br/&gt;
not required for wrong result fixes:&lt;/p&gt;

&lt;p&gt;Incompatibilities with Previous Release&lt;br/&gt;
Application Changes Required&lt;/p&gt;

&lt;p&gt;To reduce to a simple case, if the expression x + 2 actually returned x + 3 for any x, then would it make sense&lt;br/&gt;
to have a release note that effectively said &quot;applications that depended on the incorrect addition of 2 need to be updated&quot;?? &lt;/p&gt;</comment>
                            <comment id="12581854" author="thomanie" created="Tue, 25 Mar 2008 09:45:37 +0000"  >&lt;p&gt;Thanks for having a go at the RN Craig &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Taking the liberty to attach an updated version of the releaseNotes.html based on my knowledge of the issue.&lt;/p&gt;</comment>
                            <comment id="12581994" author="clr" created="Tue, 25 Mar 2008 16:03:21 +0000"  >&lt;p&gt;Thanks for the update, Thomas. I could feel death by a thousand cuts coming...&lt;/p&gt;</comment>
                            <comment id="12584454" author="dyret" created="Wed, 2 Apr 2008 09:28:26 +0100"  >&lt;p&gt;Checking &apos;release note needed&apos; so the release note filter can pick it up.&lt;/p&gt;</comment>
                            <comment id="12592422" author="kmarsden" created="Fri, 25 Apr 2008 17:13:12 +0100"  >&lt;p&gt;updating fix version to include 10.3.2.2 as this fix was ported to the 10.3 branch.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12354628">DERBY-2034</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12387028">DERBY-3349</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12459261">DERBY-4585</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12386370">DERBY-3321</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12353092">JDO-435</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12378272" name="Derby-3301.html" size="3851" author="clr" created="Wed, 19 Mar 2008 21:36:01 +0000"/>
                            <attachment id="12373496" name="d3301-queryplan.log" size="8073" author="thomanie" created="Fri, 18 Jan 2008 10:14:41 +0000"/>
                            <attachment id="12373726" name="derby-3301-1.diff" size="3830" author="thomanie" created="Tue, 22 Jan 2008 08:48:35 +0000"/>
                            <attachment id="12373727" name="derby-3301-1.stat" size="211" author="thomanie" created="Tue, 22 Jan 2008 08:48:35 +0000"/>
                            <attachment id="12373812" name="derby-3301-2.diff" size="5607" author="thomanie" created="Wed, 23 Jan 2008 09:13:27 +0000"/>
                            <attachment id="12373869" name="derby-3301-3.diff" size="6530" author="thomanie" created="Wed, 23 Jan 2008 20:34:33 +0000"/>
                            <attachment id="12373872" name="derby-3301-3b.diff" size="6590" author="thomanie" created="Wed, 23 Jan 2008 21:32:19 +0000"/>
                            <attachment id="12374037" name="derby-3301-4.diff" size="6945" author="thomanie" created="Fri, 25 Jan 2008 13:35:32 +0000"/>
                            <attachment id="12374127" name="derby-3301-4b.diff" size="6997" author="thomanie" created="Sat, 26 Jan 2008 19:20:40 +0000"/>
                            <attachment id="12374128" name="derby-3301-4b.stat" size="212" author="thomanie" created="Sat, 26 Jan 2008 19:20:40 +0000"/>
                            <attachment id="12374199" name="derby-3301-4c.diff" size="7041" author="thomanie" created="Mon, 28 Jan 2008 18:19:38 +0000"/>
                            <attachment id="12374404" name="derby-3301-5.diff" size="7564" author="thomanie" created="Wed, 30 Jan 2008 19:57:21 +0000"/>
                            <attachment id="12374449" name="derby-3301-6.diff" size="7539" author="thomanie" created="Thu, 31 Jan 2008 08:32:22 +0000"/>
                            <attachment id="12374491" name="derby-3301-7.diff" size="7537" author="thomanie" created="Thu, 31 Jan 2008 19:22:26 +0000"/>
                            <attachment id="12374504" name="derby-3301-8.diff" size="7140" author="thomanie" created="Thu, 31 Jan 2008 21:32:02 +0000"/>
                            <attachment id="12374448" name="derby-3301-extra.sql" size="2508" author="thomanie" created="Thu, 31 Jan 2008 08:32:22 +0000"/>
                            <attachment id="12373943" name="derby-3301-test-1.diff" size="7824" author="thomanie" created="Thu, 24 Jan 2008 17:14:39 +0000"/>
                            <attachment id="12373942" name="derby-3301-test-1.stat" size="171" author="thomanie" created="Thu, 24 Jan 2008 17:14:38 +0000"/>
                            <attachment id="12374129" name="derby-3301-test-2.diff" size="9082" author="thomanie" created="Sat, 26 Jan 2008 19:20:40 +0000"/>
                            <attachment id="12374216" name="derby-3301-test-3.diff" size="9193" author="thomanie" created="Mon, 28 Jan 2008 20:37:54 +0000"/>
                            <attachment id="12374208" name="derby-3301-test-3.stat" size="181" author="thomanie" created="Mon, 28 Jan 2008 19:22:50 +0000"/>
                            <attachment id="12374505" name="derby-3301-test-master-2.diff" size="14212" author="thomanie" created="Thu, 31 Jan 2008 21:32:02 +0000"/>
                            <attachment id="12375010" name="derby-3301-test-master-3.diff" size="3114" author="thomanie" created="Thu, 7 Feb 2008 18:54:34 +0000"/>
                            <attachment id="12375011" name="derby-3301-test-master-3.stat" size="180" author="thomanie" created="Thu, 7 Feb 2008 18:54:35 +0000"/>
                            <attachment id="12374412" name="derby-3301-test-master.diff" size="7332" author="thomanie" created="Wed, 30 Jan 2008 21:31:26 +0000"/>
                            <attachment id="12374413" name="derby-3301-test-master.stat" size="89" author="thomanie" created="Wed, 30 Jan 2008 21:31:26 +0000"/>
                            <attachment id="12372638" name="derby-3301.sql" size="2262" author="clr" created="Mon, 7 Jan 2008 17:51:03 +0000"/>
                            <attachment id="12378552" name="releaseNote.html" size="3855" author="thomanie" created="Tue, 25 Mar 2008 09:45:37 +0000"/>
                            <attachment id="12378274" name="releaseNote.html" size="3888" author="clr" created="Wed, 19 Mar 2008 21:58:44 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 4 Jan 2008 00:29:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23556</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ltz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37355</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10051"><![CDATA[Urgent]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>