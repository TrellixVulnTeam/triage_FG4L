<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:25:40 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1219/DERBY-1219.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1219] jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1219</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The tests checkDataSource.java and checkDataSource30.java &lt;br/&gt;
hang intermittently especially with jdk 1.5.&lt;/p&gt;

&lt;p&gt;Attached is the test run output and traces when the server is started separately.&lt;/p&gt;

&lt;p&gt;1) Enable checkDataSource30.java by taking it out of functionTests/suites/DerbyNetClient.exclude.&lt;/p&gt;

&lt;p&gt;2) Run the test with client.&lt;br/&gt;
java -Dij.exceptionTrace=true -Dkeepfiles=true -Dframework=DerbyNetClient org.apache.derbyTesting.functionTests.harness.RunTest jdbcapi/checkDataSource30.java&lt;/p&gt;

&lt;p&gt;Attachements:&lt;br/&gt;
 testfiles_after_hang.zip - Test directory.&lt;/p&gt;

&lt;p&gt; traces_on_hang.txt  - Server side traces obtained by starting the server separately before running the test.&lt;/p&gt;

&lt;p&gt;I wish I had time to work on this right now as I would really like to see this valuable test in the suite, but hopefully someone else will pick it up.&lt;/p&gt;

</description>
                <environment>More often on jdk 1.5 or jdk 1.6 but hangs on jdk 1.4.2 as well</environment>
        <key id="12332120">DERBY-1219</key>
            <summary>jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="deepa">Deepa Remesh</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                    </labels>
                <created>Fri, 14 Apr 2006 11:11:22 +0100</created>
                <updated>Wed, 1 Jul 2009 01:13:01 +0100</updated>
                            <resolved>Tue, 16 May 2006 07:36:41 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>Network Client</component>
                    <component>Network Server</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12374454" author="kmarsden" created="Fri, 14 Apr 2006 11:12:37 +0100"  >&lt;p&gt;test output after hang.&lt;/p&gt;</comment>
                            <comment id="12374456" author="kmarsden" created="Fri, 14 Apr 2006 11:15:27 +0100"  >&lt;p&gt;server side stack traces on hang.&lt;/p&gt;</comment>
                            <comment id="12376347" author="deepa" created="Wed, 26 Apr 2006 05:55:54 +0100"  >&lt;p&gt;For &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1148&quot; title=&quot;Client XA getTransactionIsolation()   does not return the correct isolation level when rejoining a global transaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1148&quot;&gt;&lt;del&gt;DERBY-1148&lt;/del&gt;&lt;/a&gt;, I was trying to run checkDataSource test with client to repro the issue. I am getting the hang reported by Kathey almost all the time. So I looked into the hang and narrowed it down to this - The hang is occuring in ClientDataSource.getConnection method at this line: return ClientDriver.getFactory().newNetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false); &lt;br/&gt;
It looks like it is hanging in the method NetConnection.flowServerAttributesAndKeyExchange. I tried to capture server traces but running few times with trace on did not produce the hang for me. I&apos;ll be working with this test some more and will update if I get any info. If anyone else gets any clues as to what could be wrong, please post it.&lt;/p&gt;
</comment>
                            <comment id="12377616" author="deepa" created="Thu, 4 May 2006 03:41:33 +0100"  >&lt;p&gt;I talked to Kathey about this issue on IRC and she suggested trying this test outside the harness. I could repro it outside the harness too and I am attaching the stack traces from the client and the server (client_stack_trace_050306.txt, server_stack_trace_050306.txt) . From the trace and from the debugging I did with a few print statements, I think this is what is happening in the test:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;For getting a new connection, client sends EXCSAT and ACCSEC to the server. Then, client waits for the response from the server for these commands. In all the test runs, I found the hang always happens in this request from the client sent as part of getConnection method.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;At the server, it tries to read the data from the client and does not get any data in DDMReader.fill. So the server thinks the client has disconnected and ends the connection thread.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Client does not get back any response as server has ended the connection thread. Thus the client is blocked trying to read the input stream.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I have not yet figured out the reason for this miscommunication between server and client. I would appreciate if someone can also go through the traces and confirm my analysis is correct.&lt;/p&gt;</comment>
                            <comment id="12377671" author="bryanpendleton" created="Thu, 4 May 2006 09:05:01 +0100"  >&lt;p&gt;Hi Deepa,&lt;/p&gt;

&lt;p&gt;Can you get the DRDA trace files for the hang? I.e., set traceDirectory on the client and derby.drda.traceAll on the server, as described in the Protocol Tracing section of  &lt;a href=&quot;http://wiki.apache.org/db-derby/ProtocolDebuggingTips&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/ProtocolDebuggingTips&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12377814" author="deepa" created="Thu, 4 May 2006 22:49:20 +0100"  >&lt;p&gt;Thanks Bryan. I am glad that you are looking at this issue. Hopefully we can narrow this down quickly with your DRDA expertise. I am attaching the client and server DRDA traces that I had captured previously when I ran the test inside the harness. You may find some traces which start with &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1219&quot; title=&quot;jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1219&quot;&gt;&lt;del&gt;DERBY-1219&lt;/del&gt;&lt;/a&gt;&quot; which I had added for some debugging. Please ignore these. If needed, I can try to capture fresh traces and upload them.&lt;/p&gt;

&lt;p&gt;I had let the test run for a long time. At the end of the test I killed network server and this accounts for the last DisconnectException seen in client_trace.txt_sds_1. To me, it looked like the client was hanging after sending EXCSAT and ACCSEC whereas network server was idle. &lt;/p&gt;


</comment>
                            <comment id="12378038" author="bryanpendleton" created="Fri, 5 May 2006 22:03:16 +0100"  >&lt;p&gt;Hi Deepa, nothing obvious has jumped out at me yet, but I will keep looking. Three questions:&lt;/p&gt;

&lt;p&gt;1) You said you were able to reproduce this outside the harness; can you post a brief description of the steps, so that I can experiment with the code in my environment?&lt;br/&gt;
2) Were you running with sane=true, or sane=false? If sane=false, can you try sane=true?&lt;br/&gt;
3) You mentioned that the server does not get any data in DDMReader.fill, and thinks the client has disconnected. Can you expand on how you came to that conclusion? Were you able to see an IOException being thrown? Can you get a dump of that exception? After the exception has been thrown (i.e., during the hang), does netstat think that there is still an active TCP/IP connection between the client and the server?&lt;/p&gt;

&lt;p&gt;thanks, bryan&lt;/p&gt;</comment>
                            <comment id="12378079" author="deepa" created="Sat, 6 May 2006 01:34:24 +0100"  >&lt;p&gt;Hi Bryan,&lt;/p&gt;

&lt;p&gt;Here are the answers to your questions:&lt;/p&gt;

&lt;p&gt;1) You said you were able to reproduce this outside the harness; can you post a brief description of the steps, so that I can experiment with the code in my environment?&lt;/p&gt;

&lt;p&gt;To run the test jdbcapi/checkDataSource.java without using the test harness, I started network server and then used the following command to run the test:  &lt;br/&gt;
java -Dderby.system.home=C:\deepa\Derby\derby_testing\nwserver -Dframework=DerbyNetClient -Dij.database=jdbc:derby://localhost:1527/wombat;create=true org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource&lt;/p&gt;

&lt;p&gt;The test hangs intermittently and the place where the test hangs is in one of the getConnection methods. The hang location varies in different runs but is always in the getConnection method. I can repro it quite easily (~ 1 out of 5 runs hang) on my machine. I hope you are able to repro it too.&lt;/p&gt;

&lt;p&gt;2) Were you running with sane=true, or sane=false? If sane=false, can you try sane=true?&lt;/p&gt;

&lt;p&gt;I was running with sane=true. The debug output can be seen in the derby.log in the attached zip file (drda_traces_050206.zip)&lt;/p&gt;

&lt;p&gt;3) You mentioned that the server does not get any data in DDMReader.fill, and thinks the client has disconnected. Can you expand on how you came to that conclusion? Were you able to see an IOException being thrown? Can you get a dump of that exception? After the exception has been thrown (i.e., during the hang), does netstat think that there is still an active TCP/IP connection between the client and the server? &lt;/p&gt;

&lt;p&gt;I was looking at the server debug trace from a normal run (without hang) and when the test hangs. On comparing both and also looking at the client and server traces, I found the following from the trace files:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Client trace stops with send of EXCSAT and ACCSEC (client_trace.txt_sds_1)&lt;/li&gt;
	&lt;li&gt;At the server side, I can see an empty trace file is created but cannot see the EXCSAT and ACCSEC as the last entries in any trace file (Server10.trace, Server9.trace)&lt;/li&gt;
	&lt;li&gt;In the debug trace of server, the last trace is &quot;Ending connection thread&quot;. I added few other traces in DDMReader.fill and DRDAConnThread.run  and found that server is actually reaching the end of the input stream (actualBytesRead == -1) without reading any data (totalBytesRead is 0) and hence calls &quot;agent.markCommunicationsFailure (&quot;DDMReader.fill()&quot;, &quot;InputStream.read()&quot;, &quot;insufficient data&quot;, &quot;*&quot;);&quot; The connection thread catches this disconnect exception and exits normally thinking the client has disconnected. The debug traces from a successful run show  that network server starts a new connection thread at this point.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;From the above, I thought of following possibilities:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;server is not getting a set of data from the client. data is lost. this looks unlikely&lt;/li&gt;
	&lt;li&gt;server thread is reading a wrong stream (from an already closed connection) and thinking the client does not have more data and that it has disconnected.&lt;/li&gt;
	&lt;li&gt;session state associated with the server thread is wrong. Instead of starting new session, server is thinking it has an active session and tries to process commands for the active session&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I am just throwing in some ideas which come to me and could be totally off here. I plan to look at this some more and will post if I find something else.&lt;/p&gt;

&lt;p&gt;There are no IOExceptions at server or client. The IO exception seen in the client trace file (client_trace.txt_sds_1) is because I killed network server after the test was hanging for a long time. This was just to reconfirm where the client is hanging. &lt;/p&gt;

&lt;p&gt;In netstat output, I can see listening and established statuses for both client and server process during the hang. &lt;/p&gt;

&lt;p&gt;Ouput of runtimeinfo command: &lt;br/&gt;
&amp;#8212; Derby Network Server Runtime Information &amp;#8212;&lt;br/&gt;
---------- Session Information ---------------&lt;br/&gt;
Session # :10&lt;/p&gt;


&lt;p&gt;-------------------------------------------------------------&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Connection Threads : 2&lt;/li&gt;
	&lt;li&gt;Active Sessions : 1&lt;/li&gt;
	&lt;li&gt;Waiting  Sessions : 0&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Total Memory : 3694592  Free Memory : 2649768&lt;/p&gt;

&lt;p&gt;Hope this helps.&lt;/p&gt;</comment>
                            <comment id="12378175" author="deepa" created="Sat, 6 May 2006 08:13:32 +0100"  >&lt;p&gt;I forgot to mention that when I set the tracing for client, I was getting a NPE if I did not set all the ClientDataSource properties. Other option was to make a small change in client&apos;s LogWriter.java. I have opened &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1298&quot; title=&quot;Tracing client data source gives NPE if all data source properties are not set&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1298&quot;&gt;&lt;del&gt;DERBY-1298&lt;/del&gt;&lt;/a&gt; for this. Just mentioning in case someone else hits the same problem when tracing the client.&lt;/p&gt;</comment>
                            <comment id="12378228" author="bryanpendleton" created="Sun, 7 May 2006 00:03:21 +0100"  >&lt;p&gt;Hi Deepa. Thank you for the good notes. As you say:&lt;/p&gt;

&lt;p&gt;&amp;gt; The test hangs intermittently and the place where the test hangs is in one of the getConnection&lt;br/&gt;
&amp;gt;   methods. The hang location varies in different runs but is always in the getConnection method. &lt;br/&gt;
&amp;gt;   I can repro it quite easily&lt;/p&gt;

&lt;p&gt;I appear to be able to reproduce it quite easily, too. So that is good.&lt;/p&gt;

&lt;p&gt;I think that an interesting aspect of this test is that it creates and tears down a lot of connections&lt;br/&gt;
in very rapid succession, and I am wondering whether there is a race condition somewhere&lt;br/&gt;
that is causing the code to lose track of which connection is which.&lt;/p&gt;

&lt;p&gt;I think that your analysis of the (actualBytesRead == -1) case is good, but is perhaps a red&lt;br/&gt;
herring. I believe that this is the normal way that the server cleans up when a client&lt;br/&gt;
connection disconnects and goes away. So I don&apos;t think this is &lt;b&gt;directly&lt;/b&gt; the place where things&lt;br/&gt;
are going wrong; it&apos;s just evidence that the server is seeing a lot of connections come and go.&lt;/p&gt;

&lt;p&gt;It seems like, at least in the cases I&apos;ve seen so far, the bottom line is this:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the client believes it&apos;s initiated a new connection with the server&lt;/li&gt;
	&lt;li&gt;the server, however, has no record of that connection, and believes it&apos;s cleaned up all&lt;br/&gt;
   its connections and is idle&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So I think something is going wrong in the connection management code on one side or&lt;br/&gt;
the other.&lt;/p&gt;

&lt;p&gt;Thanks for the great test case and set of notes; I&apos;ll continue to study this one some more and&lt;br/&gt;
let you know if I figure anything out.&lt;/p&gt;</comment>
                            <comment id="12378300" author="bryanpendleton" created="Sun, 7 May 2006 23:31:54 +0100"  >&lt;p&gt;Attached are &quot;skipThreads.diff&quot; and &quot;interrupt.diff&quot;, but before&lt;br/&gt;
reading the diffs, please read these notes.&lt;/p&gt;

&lt;p&gt;I think I understand what is causing the hangs, and I can even make&lt;br/&gt;
the hangs go away. However, I don&apos;t think I yet understand how to&lt;br/&gt;
really &lt;b&gt;fix&lt;/b&gt; the problem, so I&apos;m sure we&apos;ll want to talk about this&lt;br/&gt;
for a while, to see if some of the reviewers can come up with a&lt;br/&gt;
proper solution or at least some techniques to pursue.&lt;/p&gt;

&lt;p&gt;Here&apos;s what I see, and what I think it means:&lt;/p&gt;

&lt;p&gt;1) One, or maybe several, times in the test, checkDataSource causes a &lt;br/&gt;
shutdown of the server. It has several different variants on the shutdown&lt;br/&gt;
processing, but at least one of them causes the server to go through&lt;br/&gt;
NetworkServerControlImpl.startNetworkServer() to perform a server restart.&lt;/p&gt;

&lt;p&gt;2) During the server restart processing, the Network Server restart &lt;br/&gt;
code iterates through all the DRDAConnThread instances and closes them. &lt;br/&gt;
This close() call is supposed to cause the DRDAConnThread to terminate itself.&lt;/p&gt;

&lt;p&gt;3) However, all the close() call actually does is mark the thread&apos;s&lt;br/&gt;
&quot;close&quot; variable as true, and depending on when the thread checks that&lt;br/&gt;
variable, it may or may not immediately exit. In my test runs, it is&lt;br/&gt;
often the case that at least one of the DRDAConnThread instances is, at this&lt;br/&gt;
point, sitting blocked in NetworkServerControlImpl.getNextSession().&lt;br/&gt;
Calling close() on this thread marks it as closed, but doesn&apos;t cause&lt;br/&gt;
it to exit the getNextSession() wait.&lt;/p&gt;

&lt;p&gt;4) A little bit later, the test program makes some new connections&lt;br/&gt;
to the server, and one of those connections is given to the thread&lt;br/&gt;
which was blocked in the getNextSession() call. The thread picks&lt;br/&gt;
up the session and returns to the DRDAConnThread.run() main loop.&lt;/p&gt;

&lt;p&gt;5) At this point, the thread notices that it has been closed, and it&lt;br/&gt;
exits, without sending any response back to the client, and without&lt;br/&gt;
closing the connection to the client. This causes the hang.&lt;/p&gt;

&lt;p&gt;Because this problem involves multi-threading, and thread scheduling,&lt;br/&gt;
there is a bunch of non-determinate behavior, which I believe is why&lt;br/&gt;
others have been experiencing varied results during their tests. The&lt;br/&gt;
behavior of the threads is definitely unpredictable for me.&lt;/p&gt;

&lt;p&gt;There are several aspects to this scenario that puzzle me, but let&lt;br/&gt;
me describe what I&apos;ve been experimenting with as a patch. I&apos;ve changed&lt;br/&gt;
the NetworkServerControlImpl restart logic so that, instead of&lt;br/&gt;
closing the DRDAConnThreads, it just leaves the threads alone.&lt;br/&gt;
This change is in &quot;skipThreads.diff&quot;, and it seems to make the hangs&lt;br/&gt;
go away. &lt;/p&gt;

&lt;p&gt;The &quot;skipThreads.diff&quot; diff also contains some hacks to the test so&lt;br/&gt;
that I could run it multiple times in a row outside of the harness&lt;br/&gt;
without destroying and re-creating the database each time.&lt;br/&gt;
Those changes don&apos;t really belong with this diff, but I didn&apos;t bother&lt;br/&gt;
to edit them out.&lt;/p&gt;

&lt;p&gt;I also experimented with a change which tried to close the threads,&lt;br/&gt;
but also, after closing, interrupts the threads, which&lt;br/&gt;
caused them to be blown out of the getNextSession loop and back to&lt;br/&gt;
the main run() loop, at which point the threads shut themselves down,&lt;br/&gt;
which seems like the right behavior for Network Server restart. &lt;/p&gt;

&lt;p&gt;I was hoping that this was the &quot;right&quot; fix, but unfortunately this&lt;br/&gt;
change fixed &lt;b&gt;some&lt;/b&gt;, but not &lt;b&gt;all&lt;/b&gt;, of the hangs, which was too bad.&lt;br/&gt;
And I&apos;m nervous about adding the call to Thread.interrupt(), which is&lt;br/&gt;
an extremely powerful call and not to be used lightly. For reviewers&lt;br/&gt;
who want to experiment with this change and see how it works for them,&lt;br/&gt;
I&apos;ve also attached &quot;interrupt.diff&quot;&lt;/p&gt;

&lt;p&gt;I&apos;m still disturbed by the fact that when the main run() method&lt;br/&gt;
in DRDAConnThread noticed that it was closed, it just exited without&lt;br/&gt;
apparently sending any response back to the server or closing the&lt;br/&gt;
socket.&lt;/p&gt;

&lt;p&gt;And, although my change makes the hangs go away, it does not make the&lt;br/&gt;
checkDataSource and checkDataSource30 tests pass. Instead, they run&lt;br/&gt;
to completion, and get a bunch of diffs, and I&apos;m not sure whether my&lt;br/&gt;
changes caused these diffs or not.&lt;/p&gt;

&lt;p&gt;But at this point, before I work on this much more, I&apos;d like to get&lt;br/&gt;
some feedback from the reviewers about the analysis up to this point,&lt;br/&gt;
and the effects of this patch in their environment:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;does this patch cause the hangs to disappear for you?&lt;/li&gt;
	&lt;li&gt;if so, do the checkDataSource and checkDataSource30 tests pass for you?&lt;/li&gt;
	&lt;li&gt;if they fail, do the failures make sense to you?&lt;/li&gt;
	&lt;li&gt;what should we be doing with the background connection threads during&lt;br/&gt;
   a Network Server restart?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="12378481" author="deepa" created="Tue, 9 May 2006 02:01:32 +0100"  >&lt;p&gt;I ran the standalone repro with both your patches. I was not able to reproduce the hang on my machine after 25 runs with each patch.&lt;/p&gt;

&lt;p&gt;Thanks for the detailed explanation of the problem. I think I was reading some overlapping traces and was misled. After reading your description, I added more traces and confirmed that the run method breaks out because it finds that the thread has been marked closed. As you said, it seems not quite okay to just break out without informing the client. Maybe, it is expected that this code can reached only after client is already informed after an exception or at end of a session. A quick look at places where close method is called seems to indicate this. &lt;/p&gt;

&lt;p&gt;Both your solutions seem to work on my machine but I am not very clear about them. About solution 1 (skipThreads.diff) , it does not seem quite right to remove the cleanup code (code to close existing threads and clear threadList). If it is okay to reuse the same threads after a restart, then it should be okay to remove this cleanup code. Even then, I think the real cause of this problem could be somewhere else. I have not looked at solution 2 as you mentioned it does not work in all cases.&lt;/p&gt;

&lt;p&gt;Just sharing another thought which occurred to me after reading your descriptions. It looks like the new thread which was opened to serve the new connection gets added to threadList before the list is going to be cleaned up during restart. This causes the new thread to be closed unexpectedly when the server is restarted. I do not want to lead you down the wrong path. So I am looking at how/where threadList is accessed and if there could me some missing synchronizations here. I will post if I find something.&lt;/p&gt;</comment>
                            <comment id="12378734" author="bryanpendleton" created="Wed, 10 May 2006 04:33:23 +0100"  >&lt;p&gt;One strategy that occurred to me is that, rather than clearing and re-using the RunQueue and the ThreadList, &lt;br/&gt;
we could have the restart processing set up a new RunQueue and ThreadList, and that way make a clean&lt;br/&gt;
distinction between old sessions and threads, versus new sessions and threads. That is, try to avoid the&lt;br/&gt;
problem of &quot;a new session comes in, but gets handled by an old thread which is being closed&quot;, by teaching&lt;br/&gt;
the code how to tell the difference between old and new threads and sessions.&lt;/p&gt;

&lt;p&gt;Some sort of restart algorithm like:&lt;/p&gt;

&lt;p&gt;  oldRunQueue = RunQueue&lt;br/&gt;
  oldThreadList = ThreadList&lt;br/&gt;
  create new RunQueue and new ThreadList&lt;br/&gt;
  go through the old RunQueue and thread list and close and clean them up&lt;/p&gt;

&lt;p&gt;The idea being that, once we reach a certain point in Network Server restart processing, all new&lt;br/&gt;
threads go onto the new thread list, and all new sessions go onto the new run queue, and it&lt;br/&gt;
should be easier to tell the difference between old threads &amp;amp; sessions, which have been closed&lt;br/&gt;
and should now die, and new threads and sessions, which are allowed to start doing new work.&lt;/p&gt;

&lt;p&gt;A similar, but not identical, idea would be to establish some sort of &quot;generation&quot; counter, which&lt;br/&gt;
is incremented by one each time the Network Server restarts within a process, and instead&lt;br/&gt;
of using the &quot;close&quot; API to shut down sessions and threads, use the idea of generations, so&lt;br/&gt;
that a session or thread which is in an older generation is treated as dead and gets cleaned up,&lt;br/&gt;
while new generation threads can start processing new generation sessions, and if a thread&lt;br/&gt;
and a session ever found that their generations didn&apos;t match, they would know that something&lt;br/&gt;
horrible had occurred and they could trigger a sanity check or assertion.&lt;/p&gt;

&lt;p&gt;Anyway, just some thoughts to keep the discussion going. &lt;/p&gt;</comment>
                            <comment id="12378767" author="deepa" created="Wed, 10 May 2006 06:31:38 +0100"  >&lt;p&gt;I am thinking along slightly different lines. The restart processing is doing some cleanup and reloading the driver. Should&apos;nt we wait for the reload to happen before we start working on the new session which comes in? In that case, we will need some logic to check if a restart is in progress before we add a new thread/session to the lists.&lt;/p&gt;

&lt;p&gt;Or do we expect the driver to be reloaded by the time the new thread/session gets ready to do the real work? &lt;/p&gt;

</comment>
                            <comment id="12378772" author="bryanpendleton" created="Wed, 10 May 2006 07:00:29 +0100"  >&lt;p&gt;I think that waiting for the reload to complete is fine, but we&apos;ll need to figure out a way to have a&lt;br/&gt;
positive confirmation that the threads have received their notification and shut themselves down,&lt;br/&gt;
since, from a certain point of view, the essence of this bug is that calling DRDAConnThread.close()&lt;br/&gt;
simply asks a thread to shut itself down, but does not wait for that shutdown to actually occur.&lt;/p&gt;

&lt;p&gt;Such an algorithm would look something like:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;call close on each thread&lt;/li&gt;
	&lt;li&gt;call interrupt on each thread&lt;/li&gt;
	&lt;li&gt;while the threadlist is not empty&lt;br/&gt;
        wait for a while&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m always nervous about algorithms like this because of the need for an open-ended wait:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;how do we know how long to wait?&lt;/li&gt;
	&lt;li&gt;what happens if we&apos;ve waited a long time and the threads still haven&apos;t shut themselves down?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The algorithms that I was proposing in my previous comment basically replace this&lt;br/&gt;
open-ended wait logic with a potential resource leak in the scenario where the old&lt;br/&gt;
threads for some reason don&apos;t respond to the request to shut themselves down.&lt;br/&gt;
That is, either we accept the risk of leaking away old threads, or we accept the risk&lt;br/&gt;
of waiting indefinitely for old threads, (or, I suppose, we figure out some way to be&lt;br/&gt;
VERY confident that we can shut the old threads down in a reasonable amount of time).&lt;/p&gt;
</comment>
                            <comment id="12378794" author="deepa" created="Wed, 10 May 2006 09:07:56 +0100"  >&lt;p&gt;Hi Bryan, &lt;br/&gt;
We seem to be thinking of the problem differently. I am just thinking aloud to explain how I understood the scenario:&lt;/p&gt;

&lt;p&gt;I think the scenario is: &lt;/p&gt;

&lt;p&gt;One of the threads have asked to restart the server and this &quot;restart&quot; includes:&lt;br/&gt;
1. a) close all sessions in runQueue b) clear runQueue&lt;br/&gt;
2. a) close all threads in threadList b) clear threadList &lt;br/&gt;
3. reload the embedded driver&lt;/p&gt;

&lt;p&gt;(Note: 1a and 2a are not single steps)&lt;/p&gt;

&lt;p&gt;This restart is in progress and we get a &quot;new connection&quot; from the client. We can do two things:&lt;br/&gt;
1. queue it by adding to the runQueue list&lt;br/&gt;
OR&lt;br/&gt;
2. a) create a new thread for the connection b) add it to threadList c) start the new connection thread&lt;/p&gt;

&lt;p&gt;In addition to this, we can also have other connection threads which are running.&lt;/p&gt;

&lt;p&gt;Some cases I can think of which can cause hang are if we have actions overlapped as follows:&lt;br/&gt;
case1: restart_1a, restart_1b, new_conn_2a, new_conn_2b, restart_2a, new_conn_2c&lt;br/&gt;
case2: new_conn_1, restart 1a, restart 1b ...&lt;/p&gt;

&lt;p&gt;In case 1, after we have added a new connection thread to the threadList, threadList is cleared by restart thread and all threads including the new thread are marked closed. We then start the new thread (new_conn_2c) and it exits because it finds it was marked closed.&lt;/p&gt;

&lt;p&gt;In case 2, we queue up the connection request, runQueue is cleared during restart. So we miss the request.&lt;/p&gt;

&lt;p&gt;To me, the problem seems to be that we access the lists runQueue and threadList when a restart is in progress. &lt;/p&gt;

&lt;p&gt;In case of thread shutdown, I think the way it currently works is that we mark the thread as closed (set close = true). And next time, this thread is used, it checks if it was closed and if so it ends itself without doing anything. As the thread will not do anything else once it is marked closed, I am thinking it is okay to consider it as closed and not wait for it to actually terminate.  To me, the culprits seem to be the lists maintained by the server.&lt;/p&gt;

&lt;p&gt;Any thoughts/comments?&lt;/p&gt;</comment>
                            <comment id="12378821" author="bryanpendleton" created="Wed, 10 May 2006 12:30:51 +0100"  >&lt;p&gt;Hi Deepa,&lt;br/&gt;
I think that your scenarios are excellent, and they definitely demonstrate the problems in this area. &lt;br/&gt;
I think that the fun thing about a bug like this, is that there are many possible scenarios. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The one I was concentrating on is a bit different from yours, so let me try to diagram it as follows:&lt;/p&gt;

&lt;p&gt;1) Some thread is idling, blocked in NetworkServerControlImpl.getNextSession() as called by&lt;br/&gt;
   DRDAConnThread.run(). I think this is the standard place for a thread to block when it is idle.&lt;/p&gt;

&lt;p&gt;2) Server restart occurs, and runs straight through to completion. This results in calling close()&lt;br/&gt;
   on the thread from point (1), and also removing that thread from the ThreadList. *But the thread&lt;br/&gt;
   does not terminate.*&lt;/p&gt;

&lt;p&gt;3) Some time later, some new connections start coming in. The first new connection, as you&lt;br/&gt;
   point out, will create a new thread to handle the session. The next new conection, however, will&lt;br/&gt;
   find that a thread already exists, and so it will simply put the session onto the RunQueue list.&lt;/p&gt;

&lt;p&gt;4) The original thread then wakes up, grabs the session, notices that the thread has been&lt;br/&gt;
   closed, and exits.&lt;/p&gt;

&lt;p&gt;The point I&apos;m trying to make here is that no overlapping of actions is required, and the connection &lt;br/&gt;
does not have to arrive during the restart. &lt;/p&gt;

&lt;p&gt;It seems to me that, once a restart happens while 1 or more threads happen to be sitting idle,&lt;br/&gt;
blocked in their getNextSession() calls, then those threads are &quot;poisoned&quot;, and there is&lt;br/&gt;
now a ticking time bomb in the server. At some point in the future, a session will get added&lt;br/&gt;
to the RunQueue, and one of these &quot;poisoned&quot; (closed) threads will grab the session, and&lt;br/&gt;
will then terminate prematurely without processing the session.&lt;/p&gt;

&lt;p&gt;So the only place where I differ with your analysis, I believe, is that I think it is &lt;b&gt;not&lt;/b&gt; okay to&lt;br/&gt;
leave these threads out there, marked as closed, because at some point in the future the&lt;br/&gt;
threads will grab sessions off the run queue and fail to process them.&lt;/p&gt;

&lt;p&gt;So I think one crucial thing to ensure is that, once a thread is marked as closed, it will no &lt;br/&gt;
longer pick up a new session to process.&lt;/p&gt;

&lt;p&gt;With that in mind, I&apos;ve experimented with yet another patch, called &quot;no-sessions-for-closed-threads.diff&quot;,&lt;br/&gt;
which attempts to prevent threads marked as closed from fetching sessions to process.&lt;/p&gt;

&lt;p&gt;It seems to resolve the hang for me, but I haven&apos;t exhaustively tested it. Still, I thought it&lt;br/&gt;
showed enough promise to attach for you to examine.&lt;/p&gt;</comment>
                            <comment id="12378938" author="deepa" created="Wed, 10 May 2006 23:34:25 +0100"  >&lt;p&gt;Hi Bryan,&lt;br/&gt;
I applied your new patch &apos;no-sessions-for-closed-threads.diff&apos; and ran the checkDataSource repro. However, I still get the hang intermittently on my machine. Though the hang has not gone away, I think the scenario you explain is a probable one. And as you said, the bug is quite interesting as it can have many possible scenarios.&lt;/p&gt;

</comment>
                            <comment id="12378954" author="deepa" created="Thu, 11 May 2006 01:32:53 +0100"  >&lt;p&gt;Posting my observation with the patch &apos;no-sessions-for-closed-threads.diff&apos;: I think this patch solves the problem of &quot;poisoned&quot; threads partially. It makes sure that a thread which has been marked closed does not get a session to work on. However, the session which came in is still hanging because there are no new threads which can pick it up. When the session came in, server had queued it so that a free thread picks it up. But the thread which picked it up was a &quot;poisoned&quot; (closed) thread. So the session is still waiting for another thread. &lt;/p&gt;

&lt;p&gt;To test that the hang will go away when a new thread gets created, I opened another connection using ij. This made the hang go away and the repro ran to the end. When the connection from ij came in, the newly created thread was able to work on the waiting session and resolve the hang.&lt;/p&gt;

&lt;p&gt;Bryan, I am looking at your trial patch &quot;interrupt.diff&quot; which looks like a good solution to me too. This patch made the hang go away on my machine. But you had said that it did not resolve all hangs for you. Can you please post your observations with this patch?&lt;/p&gt;</comment>
                            <comment id="12378971" author="bryanpendleton" created="Thu, 11 May 2006 04:19:56 +0100"  >&lt;p&gt;I will gladly work on interrupt.diff some more, and try to provide more testing details.&lt;br/&gt;
But I won&apos;t get to it until at least this weekend, sorry. Thanks very much for continuing&lt;br/&gt;
to work on this with me; I think we&apos;re making some real progress here!&lt;/p&gt;</comment>
                            <comment id="12383400" author="bryanpendleton" created="Sun, 14 May 2006 01:29:08 +0100"  >&lt;p&gt;I&apos;ve been trying to run this test in one of my alternate environments, and I&apos;d like to be able to run the server on a port other than 1527. Unfortunately, when I change the value of ij.database so that it specifies a different port number, the test runs partway, then fails with:&lt;/p&gt;

&lt;p&gt;java.sql.SQLException: java.security.PrivilegedActionException : Error connecting to server localhost on port 1,527 with message Connection refused.&lt;br/&gt;
        at org.apache.derby.client.am.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:342)&lt;br/&gt;
        at org.apache.derby.jdbc.ClientDataSource.getConnection(ClientDataSource.java:191)&lt;br/&gt;
        at org.apache.derby.jdbc.ClientDataSource.getConnection(ClientDataSource.java:162)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource.runTest(checkDataSource.java:190)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource.main(checkDataSource.java:132)&lt;/p&gt;

&lt;p&gt;Line 190 of checkDataSource.java is the last line of the following snippet:&lt;/p&gt;

&lt;p&gt;                DataSource dscs = TestUtil.getDataSource(attrs);&lt;/p&gt;

&lt;p&gt;                if (testConnectionToString)&lt;br/&gt;
                                checkToString(dscs);&lt;/p&gt;

&lt;p&gt;                DataSource ds = dscs;&lt;/p&gt;

&lt;p&gt;                checkConnection(&quot;DataSource&quot;, ds.getConnection());&lt;/p&gt;

&lt;p&gt;Is it possible to configure this test to run on a port other than 1527?&lt;/p&gt;</comment>
                            <comment id="12383402" author="bryanpendleton" created="Sun, 14 May 2006 01:47:53 +0100"  >&lt;p&gt;I think the interrupt.diff patch is very close to being good, but I think there are some &lt;br/&gt;
synchronization issues to resolve. The interrupt.diff patch is very reliable on my&lt;br/&gt;
Windows environment; that is, I cannot reproduce the hang with that diff in place.&lt;/p&gt;

&lt;p&gt;In my Linux environment, however, the test still hangs with that patch. However, if&lt;br/&gt;
I introduce even very small timing changes into the test; for example if I put a&lt;br/&gt;
println statement into a critical section of the getNextSession() logic, then the&lt;br/&gt;
hang disappears.&lt;/p&gt;

&lt;p&gt;So I think that the interrupt.diff patch can perhaps be combined with some&lt;br/&gt;
additional synchronization as Deepa suggested earlier, to solve some of the&lt;br/&gt;
races between the Network Server restart, the DRDAConnThreads calling&lt;br/&gt;
getNextSession, and the ClientThread logic involving creating a new session&lt;br/&gt;
and conditionally creating a new thread.&lt;/p&gt;

&lt;p&gt;I&apos;ll continue to fiddle with the configuration that I have in which I can still provoke&lt;br/&gt;
a hang, and see what I can do to understand it better.&lt;/p&gt;</comment>
                            <comment id="12402243" author="bryanpendleton" created="Mon, 15 May 2006 06:58:05 +0100"  >&lt;p&gt;Well, I ran a lot of experiments, but I don&apos;t have anything conclusive to offer. I believe that:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the issue is intricately linked to the handling of threads and sessions during restart&lt;/li&gt;
	&lt;li&gt;the hangs are because closed threads are given sessions to run, but then abandon&lt;br/&gt;
   those sessions without running them when they discover they&apos;ve been closed&lt;/li&gt;
	&lt;li&gt;the interrupt() call makes things better, but does not totally fix the problem. I can still&lt;br/&gt;
   reproduce the problem on my RedHat Linux/ Sun JDK 1.4.2 environment.&lt;/li&gt;
	&lt;li&gt;but my various attempts to try to improve on the interrupt() fix with additional changes,&lt;br/&gt;
   only made things worse.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Unfortunately, I&apos;m not going to have much more time to work on this right away, so I&apos;m&lt;br/&gt;
unassigning myself in the hopes that somebody else can work on it.&lt;/p&gt;</comment>
                            <comment id="12402353" author="deepa" created="Tue, 16 May 2006 01:04:55 +0100"  >&lt;p&gt;Thanks Bryan for helping to identify the cause of the hang. &lt;/p&gt;

&lt;p&gt;Since we now know what is causing the intermittent hang, I think we can break the issue as follows: &lt;/p&gt;

&lt;p&gt;1) Open a separate code bug against network server component to solve the real hang problem and link to the details in this test issue.&lt;/p&gt;

&lt;p&gt;2) Enable the test to run with client by removing the code which shutdowns the system when we run the test using client framework. This is the code which causes the intermediate hang and it seems this code is not required to check the scenarios meant to be covered by the test.  I disabled the following shutdown code using a boolean and ran the checkDataSource tests with the client and did not get the hang so far:&lt;/p&gt;

&lt;p&gt;          // DERBY -???? - link to new bug opened for 1) above&lt;br/&gt;
          private static boolean hangAfterSystemShutdown = TestUtil.isDerbyNetClientFramework();&lt;br/&gt;
                        .&lt;br/&gt;
                        .&lt;br/&gt;
                        .&lt;br/&gt;
          // Shutdown the system only if we are not running in client framework&lt;br/&gt;
          if(! hangAfterSystemShutdown) {&lt;br/&gt;
			try &lt;/p&gt;
{
				TestUtil.getConnection(&quot;&quot;,&quot;shutdown=true&quot;);
			}
&lt;p&gt; catch (SQLException sqle) &lt;/p&gt;
{
				JDBCDisplayUtil.ShowSQLException(System.out, sqle);
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;The test has some existing diffs because of some intermediate check-ins which changed the messages/behaviour. I will look at these diffs and submit a patch to enable the checkDataSource tests to run with client. I think it would be good to get the test running with client so that we can keep the masters up to date and also be able to catch any regressions in this area.&lt;/p&gt;

&lt;p&gt;Please provide any comments/feedback.&lt;/p&gt;</comment>
                            <comment id="12402400" author="deepa" created="Tue, 16 May 2006 03:56:56 +0100"  >&lt;p&gt;The two categories of diffs seen  when running the checkDataSource test with client are: &lt;/p&gt;

&lt;p&gt;&amp;lt; DriverManager  &amp;lt;closedstmt&amp;gt;.execute() null - Invalid operation: statement closed&lt;br/&gt;
11a11&lt;br/&gt;
&amp;gt; DriverManager  &amp;lt;closedstmt&amp;gt;.execute() 08003 - No current connection&lt;/p&gt;

&lt;p&gt;AND&lt;/p&gt;

&lt;p&gt;&amp;lt; autocommitxastart expected &apos;ResultSet&apos; already closed.&lt;br/&gt;
460a459&lt;br/&gt;
&amp;gt; autocommitxastart expected ResultSet not open.  Verify that autocommit is OFF.&lt;/p&gt;

&lt;p&gt;These diffs are message changes done as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-843&quot; title=&quot;Internationalize messages in SectionManager to XaException in org.apache.derby.client.am&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-843&quot;&gt;&lt;del&gt;DERBY-843&lt;/del&gt;&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-842&quot; title=&quot;Internationalize messages in PreparedStatement to Section in org.apache.derby.client.am&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-842&quot;&gt;&lt;del&gt;DERBY-842&lt;/del&gt;&lt;/a&gt;. However, in the case of first diff, I see a difference in the behaviour of client and embedded driver.&lt;/p&gt;

&lt;p&gt;In case of client driver, Statement.execute method first checks if the connection associated with the statement is closed before it checks if the statement itself was closed or not. In case of embedded driver, the check for statement closed is done before the check for connection closed. I would like to clarify if the order of the checks matter and if it does which is the correct behaviour.&lt;/p&gt;</comment>
                            <comment id="12402409" author="kmarsden" created="Tue, 16 May 2006 04:17:45 +0100"  >&lt;p&gt;Deepa said ...&lt;br/&gt;
&amp;gt;(The shutdown)  is the code which causes the intermediate hang and it seems this code is not required &amp;gt;to check the scenarios meant to be covered by the test.  &lt;/p&gt;

&lt;p&gt;I agree that the conditional  is a good solution for getting the test running with client, but would like to clarify that I think the shutdown is a valuable part of the test because we verify that the global transaction state is valid even aver the database has been shutdown and restarted.  Once the hang has been resolved it would be good to reenable this part of the test for client.&lt;/p&gt;



</comment>
                            <comment id="12402429" author="kmarsden" created="Tue, 16 May 2006 05:51:40 +0100"  >&lt;p&gt;Deepa asked about these diffs:&lt;br/&gt;
&amp;gt;DriverManager &amp;lt;closedstmt&amp;gt;.execute() null - Invalid operation: statement closed&lt;br/&gt;
11a11&lt;br/&gt;
&amp;gt; DriverManager &amp;lt;closedstmt&amp;gt;.execute() 08003 - No current connection&lt;/p&gt;

&lt;p&gt;AND&lt;/p&gt;

&lt;p&gt;&amp;lt; autocommitxastart expected &apos;ResultSet&apos; already closed.&lt;br/&gt;
460a459&lt;br/&gt;
&amp;gt; autocommitxastart expected ResultSet not open. Verify that autocommit is OFF.&lt;/p&gt;

&lt;p&gt;related to the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-843&quot; title=&quot;Internationalize messages in SectionManager to XaException in org.apache.derby.client.am&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-843&quot;&gt;&lt;del&gt;DERBY-843&lt;/del&gt;&lt;/a&gt; change.  I posted a question about this to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-843&quot; title=&quot;Internationalize messages in SectionManager to XaException in org.apache.derby.client.am&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-843&quot;&gt;&lt;del&gt;DERBY-843&lt;/del&gt;&lt;/a&gt;, but I think it makes sense to go ahead and update the master and get the test running while that issue is being resolved.&lt;/p&gt;</comment>
                            <comment id="12402442" author="deepa" created="Tue, 16 May 2006 06:44:09 +0100"  >&lt;p&gt;Attaching a patch &apos;derby-1219-enable-tests.diff&apos; which enables the tests jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java to run with client.&lt;/p&gt;

&lt;p&gt;Patch adds a condition to exclude a system shutdown when running with client framework. This condition has to be removed once the hang (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1326&quot; title=&quot;Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1326&quot;&gt;&lt;del&gt;DERBY-1326&lt;/del&gt;&lt;/a&gt;) is resolved. Thanks Kathey for mentioning the use of shutdown in this test.&lt;/p&gt;

&lt;p&gt;With this patch, I ran the 2 tests using embedded and client driver with Sun jdk1.4.2 on Windows XP. I ran the tests multiple times with client driver to check that the hang does not occur. I would appreciate if someone can take a look at this patch.&lt;/p&gt;


</comment>
                            <comment id="12402450" author="bryanpendleton" created="Tue, 16 May 2006 07:08:48 +0100"  >&lt;p&gt;I ran both tests multiple times on my Linux JDK 1.4.2 environment with no hangs, and tests passed&lt;br/&gt;
each time. This particular machine was very reliable in reproducing the hang before, so I think that&apos;s&lt;br/&gt;
a good result, and it confirms your result.&lt;/p&gt;

&lt;p&gt;I would be glad to commit this patch. Do you think there are any other details we should check first?&lt;/p&gt;
</comment>
                            <comment id="12402454" author="deepa" created="Tue, 16 May 2006 07:26:00 +0100"  >&lt;p&gt;Were you asking if we need to run more tests? I think this patch changes only tests and I have run the tests with embedded and client driver. The tests are excluded with jcc driver. We also confirmed that the hang does not occur with the changed test.&lt;/p&gt;</comment>
                            <comment id="12402458" author="bryanpendleton" created="Tue, 16 May 2006 07:36:41 +0100"  >&lt;p&gt;I committed patch derby-1219-enable-tests.diff to subversion as revision 406776:&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewcvs?rev=406776&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=406776&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It will be nice to have this test running regularly in the client framework.&lt;/p&gt;</comment>
                            <comment id="12413008" author="kmarsden" created="Wed, 24 May 2006 05:50:17 +0100"  >&lt;p&gt;Cannot reproduce hang. Thanks Deepa&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12326213" name="client_stack_trace_050306.txt" size="3956" author="deepa" created="Thu, 4 May 2006 03:41:33 +0100"/>
                            <attachment id="12331939" name="derby-1219-enable-tests.diff" size="22498" author="deepa" created="Tue, 16 May 2006 06:44:09 +0100"/>
                            <attachment id="12331940" name="derby-1219-enable-tests.status" size="483" author="deepa" created="Tue, 16 May 2006 06:44:09 +0100"/>
                            <attachment id="12326249" name="drda_traces_050206.zip" size="91563" author="deepa" created="Thu, 4 May 2006 22:49:20 +0100"/>
                            <attachment id="12326360" name="interrupt.diff" size="1394" author="bryanpendleton" created="Sun, 7 May 2006 23:31:54 +0100"/>
                            <attachment id="12326498" name="no-sessions-for-closed-threads.diff" size="1642" author="bryanpendleton" created="Wed, 10 May 2006 12:30:51 +0100"/>
                            <attachment id="12326214" name="server_stack_trace_050306.txt" size="4726" author="deepa" created="Thu, 4 May 2006 03:41:33 +0100"/>
                            <attachment id="12326359" name="skipThreads.diff" size="4115" author="bryanpendleton" created="Sun, 7 May 2006 23:31:54 +0100"/>
                            <attachment id="12325329" name="testfiles_afterhang.zip" size="68903" author="kmarsden" created="Fri, 14 Apr 2006 11:12:37 +0100"/>
                            <attachment id="12325330" name="traces_on_hang.txt" size="14079" author="kmarsden" created="Fri, 14 Apr 2006 11:15:27 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 26 Apr 2006 04:55:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22380</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0t9b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38558</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>