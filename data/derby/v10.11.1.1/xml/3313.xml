<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:25:19 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3313/DERBY-3313.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3313] JDBC client driver statement cache</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3313</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;A statement cache in the JDBC client driver will help increase performance in certain scenarios, for instance some multi-tier systems using connection pooling.&lt;br/&gt;
Please consult the comments and documents attached to this issue for more information.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12385979">DERBY-3313</key>
            <summary>JDBC client driver statement cache</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kristwaa">Kristian Waagan</assignee>
                                    <reporter username="kristwaa">Kristian Waagan</reporter>
                        <labels>
                    </labels>
                <created>Thu, 10 Jan 2008 16:22:28 +0000</created>
                <updated>Thu, 2 May 2013 03:29:11 +0100</updated>
                            <resolved>Thu, 10 Jul 2008 12:08:27 +0100</resolved>
                                    <version>10.4.1.3</version>
                                    <fixVersion>10.4.2.0</fixVersion>
                                    <component>JDBC</component>
                    <component>Network Client</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                            <comments>
                            <comment id="12557688" author="kristwaa" created="Thu, 10 Jan 2008 16:25:29 +0000"  >&lt;p&gt;&apos;JDBCClientStatementCacheOverview.txt&apos; (revision 1.0) gives a high level overview for a client side statement cache in Derby.&lt;br/&gt;
I do plan to get this done for 10.4.&lt;/p&gt;

&lt;p&gt;Comments for the overview document is appreciated.&lt;/p&gt;</comment>
                            <comment id="12557731" author="djd" created="Thu, 10 Jan 2008 18:02:43 +0000"  >&lt;p&gt;Just to be clear, the overview says the embedded driver already has a statement cache, but I think it&apos;s a different type of cache. The embedded driver caches statement plans (not JDBC statement objects) that can be shared across multiple connections, I think you are planning to cache JDBC statement objects for a specific connection. If you are planning the latter then you may want to think about the fact that this would also be useful in an embedded environment, thus maybe the code could be made to work for both? Not a requirement, but something to think about.&lt;/p&gt;</comment>
                            <comment id="12557827" author="kristwaa" created="Thu, 10 Jan 2008 22:38:10 +0000"  >&lt;p&gt;Thanks for giving feedback on the overview Dan.&lt;/p&gt;

&lt;p&gt;I was not aware of what you state about the cache in the embedded driver, and this was useful information. I will clarify the wording in the overview, and also think about the possibility to share code between both drivers.&lt;/p&gt;

&lt;p&gt;Just out of curiosity, how much work do you think is saved/avoided by the current scheme when it comes to re-preparing a statement in the embedded driver?&lt;br/&gt;
Are we talking about less then 10%, something like 50% or more than that?&lt;br/&gt;
I&apos;m just looking for an indication of how much can be gained from caching JDBC statement objects in the embedded driver.&lt;/p&gt;

&lt;p&gt;Right now I&apos;m not convinced the code can be shared directly and easily. From what I have seen previously, entering the realm of code sharing between the two drivers can result in quite a lot more work. I will keep it in the back of my head though, and try to make the right choices happen if sharing seems feasible.&lt;/p&gt;</comment>
                            <comment id="12559030" author="kristwaa" created="Tue, 15 Jan 2008 12:05:04 +0000"  >&lt;p&gt;I have made a prototype of a client side statement cache. A description&lt;br/&gt;
of the changes made follows below, and I would like feedback on the&lt;br/&gt;
suggested approach. Note that this is a very early version, and there&lt;br/&gt;
are probably several things that haven&apos;t received the attention they&lt;br/&gt;
should. I also need to &quot;forward&quot; all calls in the logical prepared&lt;br/&gt;
statement before it can be used. Currently it only supports executeQuery&lt;br/&gt;
and close. There is also some JDBC 40 specific classes missing.&lt;br/&gt;
I also know there are some synchronization issues I have to work on,&lt;br/&gt;
in some places JavaDoc is missing and &lt;br/&gt;
DatabaseMetaData.supportsStatementPooling must return true for the&lt;br/&gt;
client.&lt;/p&gt;

&lt;p&gt;All changes are currently restricted to the client packages, and the&lt;br/&gt;
prefix &apos;org.apache.derby.client&apos; is omitted for conciseness.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;org.apache.derby.client&lt;br/&gt;
  ClientPooledConnection: Added a statement cache and logic for&lt;br/&gt;
    instantiating it if &apos;maxStatements&apos; is bigger than zero. Also added&lt;br/&gt;
    logic for creating either LogicalConnection (if no caching) or a&lt;br/&gt;
    CachingLogicalConnection. If caching is disabled, things will be&lt;br/&gt;
    exactly as before after a call to getConnection.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;am&lt;br/&gt;
  ClientJDBCObjectFactory: Extended the interface with methods for&lt;br/&gt;
    creating a CachingLogicalCreation and a LogiclPreparedStatement&lt;br/&gt;
    (both new classes).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  CachingLogicalConnection: A new logical connection class that caches&lt;br/&gt;
    prepared statement objects and creates logical prepared statements.&lt;/p&gt;

&lt;p&gt;  LogicalPreparedStatement/-40: Logical prepared statement with special&lt;br/&gt;
    close logic. Physical prepared statement is added to the statement&lt;br/&gt;
    cache on close if there is no other matching query already in there.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;am.stmtcache&lt;br/&gt;
I&apos;m wondering if we could put this in the shared package, or are we not&lt;br/&gt;
there yet on code sharing between the two drivers?&lt;br/&gt;
The cache is intended to hold only a single &quot;instance&quot; of each&lt;br/&gt;
statement, and all statements in the cache are free. If a statement is&lt;br/&gt;
in use, it will not be in use. Whether a statement goes into the cache&lt;br/&gt;
or not, is determined when LogicalPreparedStatement.close is called.&lt;br/&gt;
Added three things;&lt;br/&gt;
  JDBCStatementCache: The cache itself. Holds PreparedStatement objects.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Statement keys: An interface for the keys (StatementKey) and 5&lt;br/&gt;
    different keys. Only the interface is public, the implementations&lt;br/&gt;
    are hidden inside the package. I&apos;m sure there are other design&lt;br/&gt;
    possibilities here. Must write equality tests and verify hash codes.&lt;/p&gt;

&lt;p&gt;  StatementKeyFactory: A factory generating the appropriate keys based&lt;br/&gt;
    on the input information. Note that it recognizes default settings&lt;br/&gt;
    for some properties and generates a simplified key in some cases.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;jdbc&lt;br/&gt;
Have modified two data source classes here. I&apos;m not 100% sure about the&lt;br/&gt;
existing data source hierarchy, but making my things fit in there didn&apos;t&lt;br/&gt;
require many changes. Changed files:&lt;br/&gt;
  ClientBaseDataSource: Added variable &apos;maxStatements&apos; and a getter&lt;br/&gt;
    method. This property doesn&apos;t make sense for a basic data source,&lt;br/&gt;
    but this class is what is being passed around when data sources are&lt;br/&gt;
    created. Another option is to cast the object, but that requires&lt;br/&gt;
    instanceof checks.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  ClientConnectionPoolDataSource: Added a setter for maximum number of&lt;br/&gt;
    statements.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;net&lt;br/&gt;
Added implementations of the factory methods for creating caching&lt;br/&gt;
connections and logical prepared statements, according to changes in the&lt;br/&gt;
interface (see interface am.ClientJDBCObjectFactory).&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;The caching work across multiple logical connections. Prepared&lt;br/&gt;
statements are not shared across physical connections.&lt;br/&gt;
Going forward I will incorporate suggestions and feedback from the&lt;br/&gt;
community, write tests and continue finishing the implementation.&lt;br/&gt;
I also plan to run the implementation in an application server&lt;br/&gt;
environment for some early-on testing. I&apos;m also playing with the idea of&lt;br/&gt;
running suites.All with statement pooling, but I&apos;m not sure how well&lt;br/&gt;
that will work...&lt;/p&gt;

&lt;p&gt;When things are ready for proper review and commit, I will split the&lt;br/&gt;
changes into smaller parts and submit several more or less independent&lt;br/&gt;
patches.&lt;/p&gt;


&lt;p&gt;Diff stats for prototype patch &apos;derby-3313-1a-early_prototype.diff&apos;:&lt;br/&gt;
 client/ClientPooledConnection.java            |   25 +&lt;br/&gt;
 client/am/CachingLogicalConnection.java       |  160 ++++++++++&lt;br/&gt;
 client/am/ClientJDBCObjectFactory.java        |   24 +&lt;br/&gt;
 client/am/LogicalPreparedStatement.java       |  393 ++++++++++++++++++++++++++&lt;br/&gt;
 client/am/LogicalPreparedStatement40.java     |  136 ++++++++&lt;br/&gt;
 client/am/stmtcache/AutoGeneratedKeysKey.java |   51 +++&lt;br/&gt;
 client/am/stmtcache/BasicKey.java             |   65 ++++&lt;br/&gt;
 client/am/stmtcache/ColumnIndexesKey.java     |   69 ++++&lt;br/&gt;
 client/am/stmtcache/ColumnNamesKey.java       |   68 ++++&lt;br/&gt;
 client/am/stmtcache/JDBCStatementCache.java   |  137 +++++++++&lt;br/&gt;
 client/am/stmtcache/QueryKey.java             |   58 +++&lt;br/&gt;
 client/am/stmtcache/StatementKey.java         |   56 +++&lt;br/&gt;
 client/am/stmtcache/StatementKeyFactory.java  |  115 +++++++&lt;br/&gt;
 client/net/ClientJDBCObjectFactoryImpl.java   |   32 ++&lt;br/&gt;
 client/net/ClientJDBCObjectFactoryImpl40.java |   32 ++&lt;br/&gt;
 jdbc/ClientBaseDataSource.java                |   22 +&lt;br/&gt;
 jdbc/ClientConnectionPoolDataSource.java      |    9&lt;br/&gt;
 17 files changed, 1451 insertions&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, 1 deletion&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/forbidden.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;


&lt;p&gt;All kinds of feedback are welcome &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12559157" author="bryanpendleton" created="Tue, 15 Jan 2008 18:15:12 +0000"  >&lt;p&gt;Can you expand on the difference between a Prepared Statement and&lt;br/&gt;
a Logical Prepared Statement? And also on the difference between a&lt;br/&gt;
Connection and a Logical Connection? Are these already-existing&lt;br/&gt;
concepts in the client? Or did you introduce these concepts? Thanks!&lt;/p&gt;</comment>
                            <comment id="12559182" author="kristwaa" created="Tue, 15 Jan 2008 19:15:03 +0000"  >&lt;p&gt;Thank you for your interest in this issue Bryan!&lt;/p&gt;

&lt;p&gt;A logical entity is a wrapper around a &quot;physical&quot; entity. It is a mechanism to avoid closing the physical entity when a user asks to close the object he/she has a reference to. You also need to make sure that the user can&apos;t obtain a reference to the physical entity after the logical entity has been closed. In many scenarios this can be fatal, for instance that different worker threads in an application server get in each others way.&lt;/p&gt;

&lt;p&gt;The logical entity concept already exists in the driver, for instance for connections (used when connections are pooled). I have however introduced it for prepared statements. Oversimplified, the only thing it needs to do is forward all calls to the physical prepared statement and possibly execute some special logic on close. In this case, it is putting the physical prepared statement into the cache if appropriate. The logical entity will also release/nullify any references to its physical entity.&lt;/p&gt;

&lt;p&gt;One physical entity will typically do work for several logical entities during its lifespan, but at different times (non-overlapping). Further, a logical entity is typically a lot cheaper to instantiate than a physical entity.&lt;br/&gt;
An illustration of this is the statement cache in the client driver. Instead of going over the network to the server and re-prepare a statement there, you can simply wrap the existing (physical) prepared statement in the client driver. You save time spent in the network and time/work on the server. The actual benefit from such a cache is of course highly dependent on the application&apos;s usage of prepared statements.&lt;/p&gt;


&lt;p&gt;Hope this made sense, if not, ask again!&lt;/p&gt;</comment>
                            <comment id="12559231" author="bryanpendleton" created="Tue, 15 Jan 2008 21:01:25 +0000"  >&lt;p&gt;Thanks Kristian! Are the following statements true?&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for each physical PreparedStatement, there will be exactly 1 logical PreparedStatement&lt;/li&gt;
	&lt;li&gt;for each logical PreparedStatement, there will be exactly 1 physical PreparedStatement&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Or, is there ever a case where two different logical PreparedStatements point to the&lt;br/&gt;
same physical PreparedStatement?&lt;/p&gt;</comment>
                            <comment id="12559388" author="kristwaa" created="Wed, 16 Jan 2008 08:25:01 +0000"  >&lt;p&gt;Bryan wrote:&lt;br/&gt;
&amp;gt; Thanks Kristian! Are the following statements true?&lt;br/&gt;
&amp;gt;  - for each physical PreparedStatement, there will be exactly 1 logical PreparedStatement&lt;br/&gt;
I think this should be rephrased as &quot;for each physical PreparedStatement, there will be exactly 1 active logical PreparedStatement&quot;.&lt;br/&gt;
A logical prepared statement is activated when it is preprared (Connection.prepareStatement) and is no longer active when close has been called.&lt;br/&gt;
There might be error situations causing the statement to be closed as well.&lt;/p&gt;

&lt;p&gt;Over time, one physical PreparedStatement can serve a number of logical PreparedStatements.&lt;/p&gt;

&lt;p&gt;&amp;gt;  - for each logical PreparedStatement, there will be exactly 1 physical PreparedStatement&lt;br/&gt;
Yes, this is true.&lt;br/&gt;
If a logical prepared statement has a reference to a physical prepared statement, it is the only one with such a reference.&lt;br/&gt;
Note that after a close, a logical prepared statement does not refer any physical prepared statement and is eligible for garbage collection when the client no longer references it.&lt;/p&gt;

&lt;p&gt;&amp;gt; Or, is there ever a case where two different logical PreparedStatements point to the&lt;br/&gt;
&amp;gt; same physical PreparedStatement?&lt;br/&gt;
No.&lt;/p&gt;</comment>
                            <comment id="12559542" author="kristwaa" created="Wed, 16 Jan 2008 15:42:55 +0000"  >&lt;p&gt;At the moment I&apos;m looking into handling of a statement&apos;s resources when closing a logical prepared statement.&lt;br/&gt;
I think this issue will require some changes to existing code (one or more of new methods, refactoring or changes to existing methods).&lt;br/&gt;
Note that these issues are not handled &lt;b&gt;at all&lt;/b&gt; in the current prototype. For instance, the statement&apos;s result sets are left open in the prototype.&lt;/p&gt;</comment>
                            <comment id="12559574" author="bryanpendleton" created="Wed, 16 Jan 2008 16:44:09 +0000"  >&lt;p&gt;Hi Kristian, thanks for the clarifications. I think I&apos;m understanding the idea better now.&lt;/p&gt;

&lt;p&gt;Did I understand correctly that pooled connections may have prepared statement&lt;br/&gt;
caches, but non-pooled connections will not?&lt;/p&gt;

&lt;p&gt;Does each pooled connection have its own cache? If I do something like:&lt;br/&gt;
  Connection c = getPooledConnection();&lt;br/&gt;
  c.prepareStatement(&quot;select * from employee&quot;);&lt;br/&gt;
then will the behavior depend on whether or not this pooled connection has&lt;br/&gt;
previously prepared this statement?&lt;/p&gt;

&lt;p&gt;What replacement policy does the statement cache use when it becomes full?&lt;/p&gt;

&lt;p&gt;Thanks again for being patient with my questions.&lt;/p&gt;</comment>
                            <comment id="12559609" author="kristwaa" created="Wed, 16 Jan 2008 17:49:41 +0000"  >&lt;p&gt;Bryan wrote:&lt;br/&gt;
&amp;gt; Did I understand correctly that pooled connections may have prepared statement&lt;br/&gt;
&amp;gt; caches, but non-pooled connections will not?&lt;br/&gt;
Yes, this is correct. Whether a pooled connection will have a cache or not is controlled by the method setMaxStatements of the data source. A value of zero disables statement pooling. The size of the cache/pool is determined at connection creation time only.&lt;br/&gt;
I need to clarify the situation for XA connections.&lt;/p&gt;

&lt;p&gt;&amp;gt; Does each pooled connection have its own cache? If I do something like:&lt;br/&gt;
&amp;gt;   Connection c = getPooledConnection();&lt;br/&gt;
&amp;gt;  c.prepareStatement(&quot;select * from employee&quot;);&lt;br/&gt;
&amp;gt; then will the behavior depend on whether or not this pooled connection has&lt;br/&gt;
&amp;gt; previously prepared this statement?&lt;br/&gt;
Yes, each pooled connection will have its own cache.&lt;br/&gt;
There is no caching across pooled connections. A pooled connection is, or is a wrapper for, a physical connection.&lt;/p&gt;

&lt;p&gt;Nitpick:&lt;br/&gt;
The illustrative code can be a tad misleading. What happens in a connection pool, is more like this:&lt;br/&gt;
ConnectionPoolDataSource cpDs = new ClientConnectionPoolDataSource();&lt;br/&gt;
PooledConnection pooledCon = cpDs.getPooledConnection();&lt;br/&gt;
Connection clientCon = pooledCon.getConnection();&lt;br/&gt;
// Client uses this connection and eventually closes it.&lt;br/&gt;
Connection nextClientCon = pooledCon.getConnection();&lt;br/&gt;
// Next client does its things.&lt;br/&gt;
// and so on...&lt;br/&gt;
pooledCon.getConnection() returns a logical connection. In my current approach, this will return an instance of either LogicalConnection (no statement cache) or CachingLogicalConnection (with statement caching).&lt;/p&gt;


&lt;p&gt;&amp;gt; What replacement policy does the statement cache use when it becomes full?&lt;br/&gt;
I have planned to throw out the oldest statement of the cache. The approach is to take statements out of the cache when it is used. If the statement is put into the cache again, it will be inserted as the newest element. The oldest element will thus also be the least frequently used element.&lt;/p&gt;

&lt;p&gt;Implementation wise, I plan to use a LinkedHashMap. This has support for both insertion-based and access-based ordering, and it has a mechanism that is very easy to use for throwing out elements (override method removeEldestElement).&lt;/p&gt;</comment>
                            <comment id="12559978" author="kristwaa" created="Thu, 17 Jan 2008 16:30:05 +0000"  >&lt;p&gt;I have spent some time looking into code sharing and have come to the conclusion that I will not deal with it at this time.&lt;br/&gt;
There was lots of discussion a while ago, but no viable/acceptable solution for enabling &quot;proper&quot; code sharing was found.&lt;br/&gt;
My decision is based on the limited time until feature freeze, and on my impression that code sharing can be a hard nut to crack.&lt;/p&gt;

&lt;p&gt;I do however still believe parts of the code can be shared between the embedded and the client driver, specifically the implementation of the cache itself (currently located in the &quot;am.stmtcache&quot; package).&lt;/p&gt;</comment>
                            <comment id="12560007" author="kristwaa" created="Thu, 17 Jan 2008 17:29:06 +0000"  >&lt;p&gt;I created sub-tasks for what I believe will be the various parts of the statement pooling feature implementation.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3326&quot; title=&quot;Introduce a caching logical connection and logical prepared statement in the client driver&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3326&quot;&gt;&lt;del&gt;DERBY-3326&lt;/del&gt;&lt;/a&gt; is expected to be the one requiring most work, and it is here the issues regarding correctness, proper behavior and edge-cases will be handled.&lt;/p&gt;

&lt;p&gt;Basic testing will be handled in each sub-task, and there might a separate patch in the end with more complex tests.&lt;br/&gt;
I expect to provide patches for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3324&quot; title=&quot;JDBC statement cache implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3324&quot;&gt;&lt;del&gt;DERBY-3324&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3325&quot; title=&quot;Add &amp;#39;maxStatements&amp;#39; property to ClientConnectionPoolDataSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3325&quot;&gt;&lt;del&gt;DERBY-3325&lt;/del&gt;&lt;/a&gt; first.&lt;/p&gt;</comment>
                            <comment id="12561992" author="kristwaa" created="Thu, 24 Jan 2008 09:55:20 +0000"  >&lt;p&gt;Updated &apos;JDBCClientStatementCacheOverview.txt&apos; based on comments, and also added a little more information.&lt;/p&gt;</comment>
                            <comment id="12602241" author="kristwaa" created="Wed, 4 Jun 2008 11:56:37 +0100"  >&lt;p&gt;Linking to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3596&quot; title=&quot;Creation of logical connections from a pooled connection causes resource leak on the server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3596&quot;&gt;&lt;del&gt;DERBY-3596&lt;/del&gt;&lt;/a&gt;, as that issue has severe consequences for performance and stability of the JDBC statement pooling feature.&lt;br/&gt;
This means that the use of statement pooling in the client driver should be delayed till the next update release for 10.4 or the next feature release.&lt;br/&gt;
I believe this has been mentioned in the release notes for 10.4.&lt;/p&gt;</comment>
                            <comment id="12608817" author="kristwaa" created="Fri, 27 Jun 2008 17:05:16 +0100"  >&lt;p&gt;&apos;bank_transaction_stmtcache_16c.png&apos; shows a graph for the performance of Derby running the bank transaction performance client (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3619&quot; title=&quot;Implement more load types for org.apache.derbyTesting.perf.clients.Runner&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3619&quot;&gt;&lt;del&gt;DERBY-3619&lt;/del&gt;&lt;/a&gt;) in three different configurations;&lt;br/&gt;
 a) Reuse of a single prepared statement for each query (original client code)&lt;br/&gt;
 b) Reprepare the statement every time with JDBC statement caching enabled&lt;br/&gt;
 c) Reprepare the statement every time with JDBC statement caching disabled&lt;/p&gt;

&lt;p&gt;I modified the original performance client to achieve b and c.&lt;br/&gt;
The Derby network server was started with a page cache size of 10 000 and a max heap of 512 M, and the JDBC statement cache size was set to 15.&lt;br/&gt;
The client was invoked with the following arguments:&lt;br/&gt;
-driver org.apache.derby.jdbc.ClientDriver -url &quot;jdbc:derby://myHost/tpcbDB;create=true&quot; -load bank_tx -threads 16 -load_opts &quot;branches=16,accountsPerBranch=6250&quot; &lt;span class=&quot;error&quot;&gt;&amp;#91;-init&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;As the graph shows, the performance hit from repreparing statements with the JDBC client side statement cache is almost negligible with this load profile. The extra work is performed on the client, and in this case there was plenty of free CPU resourced on the client machine. The fact that there are many clients makes the difference even smaller.&lt;/p&gt;

&lt;p&gt;I&apos;m also running with only one client, and the results seem to suggest a small performance overhead for the JDBC statement cache. This is to be expected, as more work has to be done than when reusing a single prepared statement. I&apos;ll post the results later when the run is finished.&lt;/p&gt;

&lt;p&gt;If I get some free cycles, I might run a read-only test too.&lt;/p&gt;</comment>
                            <comment id="12611135" author="kristwaa" created="Mon, 7 Jul 2008 13:29:37 +0100"  >&lt;p&gt;&apos;package.html&apos; is the first revision of a simple package level description of the JDBC statement cache.&lt;/p&gt;

&lt;p&gt;It would be nice if someone could read through it and comment on two things:&lt;br/&gt;
 1) Language errors&lt;br/&gt;
 2) Missing or poor information about the cache.&lt;/p&gt;

&lt;p&gt;For instance, more information regarding the implementation could be added.&lt;/p&gt;</comment>
                            <comment id="12611477" author="knutanders" created="Tue, 8 Jul 2008 08:09:35 +0100"  >&lt;p&gt;The description looks very good to me. It would be good if some of this information could also be put into one of the manuals. I think most of it could be copied directly.&lt;/p&gt;</comment>
                            <comment id="12612431" author="kristwaa" created="Thu, 10 Jul 2008 12:07:50 +0100"  >&lt;p&gt;Knut Anders, thanks for looking at the documentation in package.html.&lt;br/&gt;
I committed a slightly modified version (attached, removed first header due to JavaDoc tool conventions and added links to implementation classes at the bottom) to trunk with revision 675508 and merged to 10.4 with revision 675510.&lt;/p&gt;

&lt;p&gt;Further changes to the package description can be done later.&lt;/p&gt;</comment>
                            <comment id="12612432" author="kristwaa" created="Thu, 10 Jul 2008 12:08:27 +0100"  >&lt;p&gt;No more work currently planned for the feature.&lt;/p&gt;</comment>
                            <comment id="12619706" author="rhillegas" created="Mon, 4 Aug 2008 22:12:23 +0100"  >&lt;p&gt;Marking Fix Version as 10.4.2 because the work has been ported to 10.4.&lt;/p&gt;</comment>
                            <comment id="12630222" author="kristwaa" created="Thu, 11 Sep 2008 16:20:36 +0100"  >&lt;p&gt;Closing the issue, as there is no more work planned.&lt;br/&gt;
The feature has gone through initial testing (code inspection, Derby regression tests and an enterprise level benchmark) and documentation has been added.&lt;/p&gt;</comment>
                            <comment id="12782366" author="brettw" created="Wed, 25 Nov 2009 10:54:09 +0000"  >&lt;p&gt;I would like to re-open this issue.  Prepared statement caching is still needed on XA connections.&lt;/p&gt;</comment>
                            <comment id="12782376" author="kristwaa" created="Wed, 25 Nov 2009 11:22:11 +0000"  >&lt;p&gt;Hi Brett,&lt;/p&gt;

&lt;p&gt;Are you in a position where you can test out a build that has caching enabled for XA connections?&lt;br/&gt;
I&apos;d need to have a look at the code again, but enabling caching for XA connections is very easy. However, the XA code has some special logic here and there, and I would have to check if any of these interferes with the cache.&lt;/p&gt;

&lt;p&gt;I&apos;d prefer if you create a separate issue for tracking the work on prepared statement caching for XA connections (mostly due to the amount of comments on this one), but feel free to reopen this issue and link to the new one.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12393122">DERBY-3596</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12399999">DERBY-3779</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12382122">DERBY-3192</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12373914" name="JDBCClientStatementCacheOverview.txt" size="2920" author="kristwaa" created="Thu, 24 Jan 2008 09:55:20 +0000"/>
                            <attachment id="12372916" name="JDBCClientStatementCacheOverview.txt" size="2302" author="kristwaa" created="Thu, 10 Jan 2008 16:25:29 +0000"/>
                            <attachment id="12384842" name="bank_transaction_stmtcache_16c.png" size="4191" author="kristwaa" created="Fri, 27 Jun 2008 17:05:16 +0100"/>
                            <attachment id="12373162" name="derby-3313-1a-early_prototype.diff" size="67422" author="kristwaa" created="Tue, 15 Jan 2008 12:05:04 +0000"/>
                            <attachment id="12373163" name="derby-3313-1a-early_prototype.stat" size="1349" author="kristwaa" created="Tue, 15 Jan 2008 12:05:04 +0000"/>
                            <attachment id="12385733" name="package.html" size="6229" author="kristwaa" created="Thu, 10 Jul 2008 12:07:49 +0100"/>
                            <attachment id="12385390" name="package.html" size="5787" author="kristwaa" created="Mon, 7 Jul 2008 13:29:37 +0100"/>
                    </attachments>
                <subtasks>
                            <subtask id="12386514">DERBY-3324</subtask>
                            <subtask id="12386515">DERBY-3325</subtask>
                            <subtask id="12386516">DERBY-3326</subtask>
                            <subtask id="12386520">DERBY-3328</subtask>
                            <subtask id="12389136">DERBY-3440</subtask>
                            <subtask id="12389137">DERBY-3441</subtask>
                            <subtask id="12386521">DERBY-3329</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 10 Jan 2008 18:02:43 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30803</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0rjb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38279</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>