<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:15:26 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2998/DERBY-2998.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2998] Add support for ROW_NUMBER() window function</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2998</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;As part of implementing the overall OLAP Operations features of SQL (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-581&quot; title=&quot;Modify SQL to skip N rows of the result and return the next M rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-581&quot;&gt;&lt;del&gt;DERBY-581&lt;/del&gt;&lt;/a&gt;), implement the ROW_NUMBER() window function.&lt;/p&gt;

&lt;p&gt;More information about this feature is available at &lt;a href=&quot;http://wiki.apache.org/db-derby/OLAPRowNumber&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/OLAPRowNumber&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2998&quot; title=&quot;Add support for ROW_NUMBER() window function&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2998&quot;&gt;&lt;del&gt;DERBY-2998&lt;/del&gt;&lt;/a&gt; implements &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;framework code for windows and window function result columns.&lt;/li&gt;
	&lt;li&gt;the ROW_NUMBER() window function according to SQL2003&lt;br/&gt;
but the implementation is limited by&lt;/li&gt;
	&lt;li&gt;only supporting an empty, unnamed, inline window definition (i.e the full, unordered resultset)&lt;/li&gt;
	&lt;li&gt;not being fully optimized&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12375659">DERBY-2998</key>
            <summary>Add support for ROW_NUMBER() window function</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12317141">DERBY-581</parent>
                                    <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="thomanie">Thomas Nielsen</assignee>
                                    <reporter username="thomanie">Thomas Nielsen</reporter>
                        <labels>
                    </labels>
                <created>Thu, 9 Aug 2007 09:10:49 +0100</created>
                <updated>Fri, 21 Jan 2011 18:17:00 +0000</updated>
                            <resolved>Fri, 7 Mar 2008 09:55:25 +0000</resolved>
                                                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>5</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12523179" author="thomanie" created="Tue, 28 Aug 2007 08:39:52 +0100"  >&lt;p&gt;First off, we will need support for unnamed windows for this jira to be completed&lt;/p&gt;

&lt;p&gt;I&apos;m off on the deep end of the pool, and could use some help and/or input on completing the prototype patch... &lt;/p&gt;

&lt;p&gt;I have extended the grammar, handling the row_number() function as an option in selectSubList(). Might not be the ideal place for all olap functions, but let&apos;s leave it there for the prototype patch.&lt;/p&gt;

&lt;p&gt;The basic idea is that bytecode is  generated for the extended QueryTreeNode classes in the nodetree, and the bytecode will be run when the statement is actually executed after optimization. First I tried using the count aggregate as a &quot;template&quot; for row_number(). I learned a lot about how aggregates work in derby, but it weered off in the wrong direction.&lt;/p&gt;

&lt;p&gt;Second attempt introduce a new RowNumberColumNode that extends ConstantNode, hoping to assign an incremental number when building the ResultSet. ResultSetList.generateCore() seems to be the place where this should be done? Is there some existing machinery that I should/can hook into for doing the incrementation, like the autoincrement functionality for insert? Would it be better to extend from VirtualColumnNode instead of ConstantNode since the column isn&apos;t actually stored?&lt;/p&gt;

&lt;p&gt;My knowledge of the inner workings of derby are still fairly limited, and there isn&apos;t really a lot on the wiki on this except the header, so your help is greatly appreciated.&lt;/p&gt;</comment>
                            <comment id="12523273" author="bryanpendleton" created="Tue, 28 Aug 2007 17:35:04 +0100"  >&lt;p&gt;Thomas, thanks for posting your findings so far. Knowing what doesn&apos;t work can&lt;br/&gt;
be very useful, and is certainly worth recording. We will all be doing a lot of learning&lt;br/&gt;
about Derby; that&apos;s the fun of open source!&lt;/p&gt;

&lt;p&gt;Here&apos;s a suggestion: perhaps you could investigate how &quot;expressions&quot; are computed,&lt;br/&gt;
by tracing through the compilation and execution of statements such as:&lt;/p&gt;

&lt;p&gt;  select substring(last_name from 1 for 10) from employee&lt;/p&gt;

&lt;p&gt;  select case when age &amp;lt; 21 then &apos;minor&apos; else &apos;adult&apos; end from dependents&lt;/p&gt;

&lt;p&gt;  select cost + cost * 0.0825 as cost_including_taxes from sales_history&lt;/p&gt;

&lt;p&gt;Can&lt;br/&gt;
  select row_number(), last_name, emp_id from employee&lt;br/&gt;
be modeled in the same fashion?&lt;/p&gt;

&lt;p&gt;I agree that eventually we will have to consider the &quot;window&quot; concept to have a true&lt;br/&gt;
implementation of this feature, but perhaps to start we can just build a simple&lt;br/&gt;
scalar function that has reasonable behavior for its particular result set, and see&lt;br/&gt;
what we can learn from that prototype implementation.&lt;/p&gt;
</comment>
                            <comment id="12523537" author="thomanie" created="Wed, 29 Aug 2007 12:05:27 +0100"  >&lt;p&gt;Thanks for chiming in Bryan!&lt;/p&gt;

&lt;p&gt;My plan for the prototype patch was, like you propose, to disregard the windowing entirely and enable simple queries like&lt;br/&gt;
   select row_number(), ...  from t&lt;br/&gt;
and treat row_number() is a simple scalar function.&lt;/p&gt;

&lt;p&gt;After having another look at how &apos;select a+b from t&apos;  works, I&apos;m finally getting somewhere &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Currently at the point where I get one generated value per row returned in the ResultSet, although they are all the default value, they do come from my RowNumberColumnNode class. Now I need to find a way to do the incrementation.&lt;/p&gt;</comment>
                            <comment id="12525072" author="thomanie" created="Wed, 5 Sep 2007 13:27:47 +0100"  >&lt;p&gt;In ResultSetList.generateCore() - the method that actually does the work - I now handle the case of a RownumberColumnNode instance, and attempt to invoke the incrementor function in RowNumberAggregator over in exec. RowNumberAggregator extends SystemAggregator as of now. &lt;/p&gt;

&lt;p&gt;When execution gets to GenericPreparedStatement.getActivation() my &quot;select row_number() from t;&quot; fails with:&lt;/p&gt;

&lt;p&gt;ERROR XBCM2: Cannot create an instance of generated class org.apache.derby.exe.ac601a400fx0114xd591xad7axffffe275b2700.&lt;br/&gt;
ERROR XJ001: Java exception: &apos;(class: org/apache/derby/exe/ac601a400fx0114xd591xad7axffffe275b2700, method: e1 signature: ()Ljava/lang/Object&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Incompatible object argument for function call: java.lang.VerifyError&apos;.&lt;/p&gt;

&lt;p&gt;From what I can tell this means I&apos;m either missing a generated class, or I&apos;m passing the wrong type of argument to my RowNumberAggregator incrementor method?&lt;/p&gt;

&lt;p&gt;It would probably be good idea move the handling from ResultSetList.generateCore()  to RowNumberColumnNode.generateExpression()? &lt;br/&gt;
And the incrementor would perhaps be better placed in BaseAcitvation instead?&lt;/p&gt;

&lt;p&gt;Right now I feel like pounding nails with a shovel - you just know there&apos;s a better tool available for the job, you just have to find it...&lt;/p&gt;</comment>
                            <comment id="12525117" author="knutanders" created="Wed, 5 Sep 2007 15:43:26 +0100"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;It would probably be easier for people to tell what&apos;s wrong and give advice if you posted a patch which shows what you have tried so far. I would guess the VerifyError is thrown because you&apos;re passing the wrong argument type. I think the error message would look different if you were missing a class.&lt;/p&gt;

&lt;p&gt;By the way, don&apos;t aggregators normally return one value for all rows within a group? Does that match what you&apos;re trying to achieve with row numbers?&lt;/p&gt;</comment>
                            <comment id="12525634" author="thomanie" created="Fri, 7 Sep 2007 09:00:55 +0100"  >&lt;p&gt;Knut,&lt;/p&gt;

&lt;p&gt;You are right - sorry for rambling on like that. Anyway, After taking two steps back and having anohter look I now have the row number prototype working, and I&apos;ll post the prototype patch once I can get around to it.&lt;br/&gt;
It works for the very basic stuff, but there&apos;s some things I know don&apos;t work.&lt;/p&gt;
</comment>
                            <comment id="12526103" author="thomanie" created="Mon, 10 Sep 2007 10:13:21 +0100"  >&lt;p&gt;I have attached my prototype for the row_number() implementation. It&apos;s not intended for commit.&lt;/p&gt;

&lt;p&gt;With a simple testtable t you can now do:&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
ij&amp;gt; select row_number(),a,b from t;&lt;br/&gt;
row_number()        |A          |B          &lt;br/&gt;
--------------------------------------------&lt;br/&gt;
1                   |1          |9          &lt;br/&gt;
2                   |2          |8          &lt;br/&gt;
3                   |3          |7     &lt;/p&gt;

&lt;p&gt;AS clause is also functioning for this query.&lt;/p&gt;

&lt;p&gt;However,&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
ij&amp;gt; select row_number() as r from t where r &amp;gt;= 2;&lt;br/&gt;
ERROR 42X04: Column &apos;R&apos; is either not in any table in the FROM list or appears within a join specification and is outside the scope of the join specification or appears in a HAVING clause and is not in the GROUP BY list. If this is a CREATE or ALTER TABLE  statement then &apos;R&apos; is not a column in the target table.&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
This seems to be due to a limitation in derby. I get the same error with &apos;select a+b as r ...&apos;. This can be rewritten using a nested select statement&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
ij&amp;gt; select * from (select row_number() as r from t) as t(r) where r &amp;gt;= 2;&lt;br/&gt;
R                   &lt;br/&gt;
--------------------&lt;br/&gt;
2                   &lt;br/&gt;
3         &lt;br/&gt;
&amp;#8212;&lt;/p&gt;

&lt;p&gt;The patch works along these lines:&lt;br/&gt;
I added a new class RowNumberColumnNode that is added to the querytree at compiletime. On invokation of ResultSetList.generateCore() we generate code to call new method BaseActivation.getSetRowNumber() that does the actual incrementing during execution.&lt;br/&gt;
Diff and .stat files are attached.&lt;/p&gt;

&lt;p&gt;There is one issue I shortcut - the setup of the rnCache array in BaseActivation. To get it working I just created a 10 element array to hold the row_number() values from invocation to invocation. This should be either number of actual row_number() columns, or total number of columns in the resultset we are building.&lt;/p&gt;

&lt;p&gt;Your comments are greatly appreciated &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12526227" author="bryanpendleton" created="Mon, 10 Sep 2007 20:17:13 +0100"  >&lt;p&gt;Hi Thomas, thanks for posting the patch! I&apos;ll try to have a look at the code soon.&lt;/p&gt;

&lt;p&gt;Perhaps we could treat the inability to reference the &quot;AS R&quot; renamed column in the WHERE clause as a separate issue since, as you observe, it is a problem with all column expressions, not just row_number() expressions. The most commonly-requested use of row_number() is probably going to be for limiting the number of rows retried, as in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-581&quot; title=&quot;Modify SQL to skip N rows of the result and return the next M rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-581&quot;&gt;&lt;del&gt;DERBY-581&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you use the nested select form, to limit the results:&lt;/p&gt;

&lt;p&gt;  select * from (select row_number() as rownum, * from t) where runum &amp;lt;= 10&lt;/p&gt;

&lt;p&gt;then does the execution logic actually short-circuit the evaluation properly after the first 10 rows have been read? Or does the execution of this query run through the entire table and then later end up discarding all the rows beyond the first 10?&lt;/p&gt;

&lt;p&gt;Since one of the primary goals of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-581&quot; title=&quot;Modify SQL to skip N rows of the result and return the next M rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-581&quot;&gt;&lt;del&gt;DERBY-581&lt;/del&gt;&lt;/a&gt; is to efficiently limit the processing to only a small subset of the rows, we want to make sure that we achieve that result if possible.&lt;/p&gt;</comment>
                            <comment id="12526372" author="thomanie" created="Tue, 11 Sep 2007 08:18:00 +0100"  >&lt;p&gt;Bryan,&lt;/p&gt;

&lt;p&gt;I agree, lets treat the &quot;AS R ... WHERE&quot; problem in a separate JIRA. There are some similar constructs that doesn&apos;t work either. Looks like it has to do with the WHERE clause working with the data before projection, and row_number(), for one, is added at projection. I haven&apos;t verified this though.&lt;/p&gt;

&lt;p&gt;If you do the nested select, I think you actually need to project the inner select into a temporary table to enable the outer SELECT ... WHERE to complete without a problem:&lt;br/&gt;
ij&amp;gt; select * from (select row_number() as r, a, b from t) as t(r,a,b) where r &amp;gt; 2;&lt;br/&gt;
R                   |A          |B          &lt;br/&gt;
--------------------------------------------&lt;br/&gt;
3                   |3          |7         &lt;/p&gt;

&lt;p&gt;This means there is no short-cut in the execution logic to only project the N first/next rows (as of now).&lt;/p&gt;

&lt;p&gt;The exact query you posted, does not actually seem to work though:&lt;br/&gt;
ij&amp;gt; select * from (select row_number() as r, * from t) as t(r,*) where r&amp;gt;2;&lt;br/&gt;
ERROR 42X01: Syntax error: Encountered &quot;*&quot; at line 1, column 42.&lt;/p&gt;

&lt;p&gt;Wildcard column specifier is not allowed in a comma separated list with column specifiers or expressions. &lt;/p&gt;

&lt;p&gt;However using &apos;t.*&apos; (kinda) works:&lt;br/&gt;
ij&amp;gt; select * from (select row_number() as r, t.* from t) as t(r,*) where r&amp;gt;2;&lt;br/&gt;
ERROR 42X01: Syntax error: Encountered &quot;where&quot; at line 1, column 55.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from (select row_number() as r, a, b from t) where r &amp;gt;=2;&lt;br/&gt;
ERROR 42X01: Syntax error: Encountered &quot;where&quot; at line 1, column 55.&lt;/p&gt;

&lt;p&gt;The two last ones are valid queries AFAIK, and accepting WHERE here is possibly worthy of its own JIRA?&lt;/p&gt;</comment>
                            <comment id="12526382" author="thomanie" created="Tue, 11 Sep 2007 08:55:28 +0100"  >&lt;p&gt;The &quot;AS R ... WHERE&quot; problem filed as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3066&quot; title=&quot;WHERE clause not accepted on derived expression columns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3066&quot;&gt;&lt;del&gt;DERBY-3066&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12526878" author="bryanpendleton" created="Wed, 12 Sep 2007 19:29:49 +0100"  >&lt;p&gt;Hi Thomas, regarding the syntax for the nested select, do these formulations work?&lt;/p&gt;

&lt;p&gt;  select * from (select row_number() as r, t.* from t) as t_with_rownum where r &amp;lt; 10&lt;/p&gt;

&lt;p&gt;  select * from (select row_number() as r, a, b from t) as t_with_rownum where r &amp;lt; 10&lt;/p&gt;

&lt;p&gt;That is, if we specify the &quot;as &amp;lt;aliasname&amp;gt;&quot; clause for the nested select, is the where clause recognized properly?&lt;/p&gt;</comment>
                            <comment id="12527412" author="thomanie" created="Fri, 14 Sep 2007 09:51:35 +0100"  >&lt;p&gt;Yes Bryan, aliasing the nested select results in the where clause being properly recognized:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from (select row_number() as r, t.* from t) as t_with_rownum where r &amp;lt; 2;&lt;br/&gt;
R                   |A          |B          &lt;br/&gt;
--------------------------------------------&lt;br/&gt;
1                   |1          |9   &lt;/p&gt;</comment>
                            <comment id="12527419" author="thomanie" created="Fri, 14 Sep 2007 10:06:01 +0100"  >&lt;p&gt;Updated the prototype patch to use number of actual columns in resultset to size the rownumber cache array.&lt;br/&gt;
Patch is still not intended for commit.&lt;/p&gt;</comment>
                            <comment id="12527589" author="thomanie" created="Fri, 14 Sep 2007 19:11:03 +0100"  >&lt;p&gt;When I step through the code executing the aliased nested selects above there is (currently) no between the inner SELECT and the outer WHERE. This makes the inner ROW_NUMBER() to be computed for &lt;b&gt;all&lt;/b&gt; rows in the table, and then the first N rows are selected in the WHERE clause. As previously stated there is no short-cut in the execution. Not a very effective idea if you have a million-and-one rows in the table and only want the first few.&lt;/p&gt;

&lt;p&gt;It would be strange if all subqueries are executed like this in derby - so on with the investigation...&lt;/p&gt;</comment>
                            <comment id="12528142" author="knutanders" created="Mon, 17 Sep 2007 21:18:50 +0100"  >&lt;p&gt;Perhaps you need to update ResultSetNode.isOrderedOn() or some of its overrides?&lt;/p&gt;</comment>
                            <comment id="12528705" author="thomanie" created="Wed, 19 Sep 2007 10:19:55 +0100"  >&lt;p&gt;You have a valid point Knut.&lt;/p&gt;

&lt;p&gt;Further investigation shows that the inner row_number() is executed once for every outer execution - which is the way one would like to do this. The following output from a test table with 3 rows illustrate this. Never mind the bug not distinguishing between the two row_number()s for now, but it clearly shows the order in which this is executed:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select row_number(),r,a,b from (select row_number() as r, t.* from t) as tr where r &amp;lt;=3;&lt;br/&gt;
row_number()        |R                   |A          |B          &lt;br/&gt;
-----------------------------------------------------------------&lt;br/&gt;
2                   |1                   |1          |9          &lt;br/&gt;
4                   |3                   |2          |8          &lt;/p&gt;

&lt;p&gt;2 rows selected&lt;/p&gt;

&lt;p&gt;If the inner resultset was flagged as ordered on R the outer might use that info to determine when to stop.&lt;/p&gt;</comment>
                            <comment id="12529112" author="thomanie" created="Thu, 20 Sep 2007 15:01:29 +0100"  >&lt;p&gt;Updated the patch to distinguish differnet row_number() instances based on which ResultSet they are in.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select row_number(), r, b from (select row_number() as r, t.* from t) as tr where r &amp;gt;= 2;&lt;br/&gt;
row_number()        |R                   |B          &lt;br/&gt;
-----------------------------------------------------&lt;br/&gt;
1                   |2                   |8          &lt;br/&gt;
2                   |3                   |7          &lt;/p&gt;

&lt;p&gt;2 rows selected&lt;/p&gt;

&lt;p&gt;Patch still not intended for commit.&lt;/p&gt;</comment>
                            <comment id="12529848" author="thomanie" created="Mon, 24 Sep 2007 14:01:51 +0100"  >&lt;p&gt;Marking the row_number() result columns using ResultColumn.markAsGroupingColumn() while in ResultColumnList.generateCore() is not enough to stop the execution of the inner row_number() with a WHILE clause at least...  Investigation still ongoing. Any other hints or tips appreaciated.&lt;/p&gt;</comment>
                            <comment id="12532976" author="thomanie" created="Sun, 7 Oct 2007 17:00:13 +0100"  >&lt;p&gt;Just to rule it out I applied the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt; (optimizer subquery cost way too high), and it didn&apos;t make a difference.&lt;br/&gt;
So it&apos;s something I&apos;m not doing that&apos;s not causing the optimizer to push the WHERE clause into the subquery to make it stop...&lt;/p&gt;</comment>
                            <comment id="12533104" author="thomanie" created="Mon, 8 Oct 2007 12:44:54 +0100"  >&lt;p&gt;Working my way through the optimization of the simple query:&lt;br/&gt;
   select * from (select row_number() as r, t.* from t) as tr where r &amp;lt; 2;&lt;br/&gt;
I see that during preprocessing the WHERE clause is converted to a PredicateList. The predicate BinaryOperatorNode (my &apos;&amp;lt;&apos; lessThan) is successfully categorize()&apos;d as pushable, which is a good thing!&lt;br/&gt;
However, ProjectRestrictNode.pushExpressionsIntoSelect() in PRN.pushExpressions() does not do anything. I would have thought this was where the predicate would be pushed into the select subquery.&lt;br/&gt;
As a side note &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt; seems to have fixed a similar issue by pushing predicates into UnionNodes. Investigation ongoing.&lt;/p&gt;</comment>
                            <comment id="12534838" author="thomanie" created="Mon, 15 Oct 2007 13:27:44 +0100"  >&lt;p&gt;My problem at this stage is very basic - whenever the restriction is fulfilled, stop the execution - but actually doing it in code is a little worse it seems.&lt;br/&gt;
I&apos;ve been looking at the optimizer and generation of ProjectRestictNodes, but got nowhere. &lt;/p&gt;

&lt;p&gt;After an offline chat with Knut, I started looking at how a table scan is stopped for indexes. Luckily it seems like IndexToBaseRowNode does something similar to what I want to accomplish in it&apos;s generate() method.&lt;/p&gt;</comment>
                            <comment id="12536621" author="thomanie" created="Mon, 22 Oct 2007 11:21:44 +0100"  >&lt;p&gt;After Dags work on ROLEs, I needed a slight tweak to this patch. Nothing else new.&lt;/p&gt;</comment>
                            <comment id="12536670" author="thomanie" created="Mon, 22 Oct 2007 14:42:41 +0100"  >&lt;p&gt;Here&apos;s how it seems to work for indexes for the following simple query on table t where column a is the primary key.&lt;/p&gt;

&lt;p&gt;   select * from t where a &amp;lt;= 2;&lt;/p&gt;

&lt;p&gt;During parsing we add a CursorNode and an IndexToBaseRowNode to the QueryTree since we have an index on &apos;a&apos;.&lt;br/&gt;
Based on the IndexToBaseRowNode we create the accompanying IndexRowToBaseRowResultSet and feed any restrictions to its constructor. &lt;br/&gt;
In my case the restriction is generated code for &apos;&amp;lt;=&apos;.&lt;/p&gt;

&lt;p&gt;On opening the IndexRowToBaseRowResultSet we also call its &quot;source&quot; .openCore() method BulkTableScanResultSet.openCore().&lt;br/&gt;
BulkTableScanResultSet does just that, it reads a base table or an index in bulk (chunks) from Store.&lt;/p&gt;

&lt;p&gt;The execution then does a do-while loop that calls .getNextRowCore(). For each pass it invokes the restriction code it got in its constructor by restriction.invoke(). In my case this ends up invoking SQLInteger.lessOrEqual(). The do-while loop exits once the restriction is met.&lt;/p&gt;

&lt;p&gt;The key seems to be the three calls to openCore(), getNextRowCore() and closeCore(), and overrides of these in the ResultSet subclasses.&lt;/p&gt;</comment>
                            <comment id="12536986" author="thomanie" created="Tue, 23 Oct 2007 13:49:07 +0100"  >&lt;p&gt;When I execute the &quot;normal&quot; query on a table without an index&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from (select row_number() as r, t.* from t) as tr where r &amp;lt; 2; &lt;/p&gt;

&lt;p&gt;With this query I get a BasicNoPutResultSet, that in turn uses the same BulkTableScanResultSet for fetching the rows as the index query above.  However, BasicNoPutResultSet does not take any restrictions into consideration at all. The execution is not stopped but continues on with the full table scan. The restriction for the resultset is enforced at a higher level.&lt;/p&gt;

&lt;p&gt;Two options stand out for moving this ahead:&lt;br/&gt;
1)&lt;br/&gt;
extend the current BasicNoPutResultSet to take the restrictions (if any) into consideration.&lt;br/&gt;
2)&lt;br/&gt;
A better approach might be to create a new NoPutResultSet subclass (&quot;OLAPResultSet&quot;?) that will use the getNextRowCore() approach of IndexRowFromBaseRowResultSet. I have a hunch there will be other scenarios where one would need an &quot;OLAPResultSet&quot; when we proceed with other subtasks of the OLAP functionallity (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-581&quot; title=&quot;Modify SQL to skip N rows of the result and return the next M rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-581&quot;&gt;&lt;del&gt;DERBY-581&lt;/del&gt;&lt;/a&gt;), and this would probably give the lesser amount of clutter to the existing ResultSet classes?&lt;/p&gt;</comment>
                            <comment id="12539052" author="thomanie" created="Wed, 31 Oct 2007 11:29:11 +0000"  >&lt;p&gt;Where would the best place be to insert/use/introduce the OLAPResultSet?&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in sqlgrammar.jj, when we add the RowNumberColumnNode we could also add an &quot;umbrella&quot; OLAPResultSetNode to the resultset?&lt;/li&gt;
	&lt;li&gt;in ProjectRestrictNode.modifyAccessPath(), once the optimizer selects the best access path to the data?&lt;/li&gt;
	&lt;li&gt;any other place I&apos;ve missed?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Index based queries run the second option and will insert an IndexToBaseRowNode in the querytree during optimization if an index is present and will be used for accessing the rows. This ends up  generating the IndexRowToBaseRowResultSet bytecode.&lt;br/&gt;
Ordering queries use the first option (if I&apos;m not mistaken), and insert a OrderByNode during querytree generation, ending up in the proper flagging of the existing resultset as ordered.&lt;/p&gt;

&lt;p&gt;I know upfront that I will need a OLAPResultSet, so it might be appropriate to just add one in sqlgrammar.jj? But then again it might be irrelvant so I should add it at optimizing?&lt;/p&gt;

&lt;p&gt;Any input appreciated!&lt;/p&gt;</comment>
                            <comment id="12543840" author="thomanie" created="Tue, 20 Nov 2007 10:12:36 +0000"  >&lt;p&gt;Attaching a new, working, but still not properly optimized, patch for the ROW_NUMBER() implementation.&lt;/p&gt;

&lt;p&gt;This patch inserts a OLAPNode in the QueryTree, and generates an OLAPResultSet fetching rows from any given source ResultSet. The implementation of OLAPNode and OLAPResultSet is based on IndexToBaseRowNode and IndexRowToBaseRowResultSet respectively.&lt;/p&gt;

&lt;p&gt;The missing optimization is due to the restriction (whereClause) not being properly recognized or passed to the inner select in the ROW_NUMBER() construct:&lt;br/&gt;
   select * from (select row_number() as r, t.* from t) as tr where r &amp;lt;= N;&lt;/p&gt;

&lt;p&gt;The code in OLAPResultSet will check the restriction for all rows it sees, if defined.&lt;/p&gt;

&lt;p&gt;As of now, the whereClause is changed to wherePredicates before passing them to the inner Select. But for the inner select each Predicate in the wherePredicates have (Prediacte.)scoped=false.&lt;/p&gt;

&lt;p&gt;Patch still not intended for commit...&lt;/p&gt;</comment>
                            <comment id="12544466" author="thomanie" created="Wed, 21 Nov 2007 13:46:58 +0000"  >&lt;p&gt;My last patch works, it&apos;s just not optimized. If someone wants to have a look and comment on it I&apos;m all ears &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Still investigating why the restriction given in the outer select isn&apos;t passed on to the inner select. &lt;br/&gt;
At the moment it seems like the restriction is skipped in ProjectRestrictNode.pushExpressions(). Here, the restriction has become a member in a  PredicateList, on which we call predicateList.pushExpressionsIntoSelect() which checks ColumnRefereces and decides wether to push the predicate or not. It would seem this check somehow fails for the RowNumberColumn.&lt;/p&gt;</comment>
                            <comment id="12544484" author="thomanie" created="Wed, 21 Nov 2007 14:49:45 +0000"  >&lt;p&gt;After changing predicateList.pushExpressionsIntoSelect to not ditch any RowNumberColumnNode expressions, the query seems to be properly optimized and stopped as expected after the restriction is fulfilled.&lt;/p&gt;

&lt;p&gt;I&apos;ll post an updated patch very very soon &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12544497" author="thomanie" created="Wed, 21 Nov 2007 15:23:41 +0000"  >&lt;p&gt;Attaching &apos;d2998-4.diff&apos; and &apos;d2998-4.stat&apos; which includes optimization as well. It&apos;s still a little rough around the edges, but seems to work for this query:&lt;br/&gt;
   select * from (select row_number() as r, t.* from t) as tr where r &amp;lt;= 2;&lt;/p&gt;

&lt;p&gt;Comments are very welcome.&lt;/p&gt;

&lt;p&gt;Tip: Uncomment the (crude) System.out.println() in BaseActivation see the computation.&lt;/p&gt;</comment>
                            <comment id="12545348" author="thomanie" created="Mon, 26 Nov 2007 07:35:50 +0000"  >&lt;p&gt;After pushing the restriction down (PredicateList.java @ 1468), it seems queries with &amp;lt; and &amp;lt;= restrictions are executed nicely. But &amp;gt; and &amp;gt;= are not.  Materialization of the row_number() column happens too late, so even if you get the correct base table rows, they are still numbered starting from 1 it seems.&lt;/p&gt;</comment>
                            <comment id="12545401" author="knutanders" created="Mon, 26 Nov 2007 10:54:02 +0000"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;It seems like the predicates are pushed too far down in some cases for &amp;lt; as well. Try for instance a join where the first rows of one the tables are not part of the result:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t1 (x int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table t2 (y int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t1 values 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20;&lt;br/&gt;
20 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t2 values 19,20,21,22,23,24,25,26,27,28,29,30;&lt;br/&gt;
12 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select row_number(),x from t1,t2 where x=y;&lt;br/&gt;
row_number()        |X          &lt;br/&gt;
--------------------------------&lt;br/&gt;
1                   |19         &lt;br/&gt;
2                   |20         &lt;/p&gt;

&lt;p&gt;2 rows selected&lt;br/&gt;
ij&amp;gt; select * from (select row_number(),x from t1,t2 where x=y) s(r,x) where r &amp;lt; 3;&lt;br/&gt;
R                   |X          &lt;br/&gt;
--------------------------------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;/p&gt;</comment>
                            <comment id="12545834" author="thomanie" created="Tue, 27 Nov 2007 13:39:42 +0000"  >&lt;p&gt;&apos;2998-5.diff&apos; removes the faulty predicate push, and is a tidy, working, but not optimized implementation of &lt;br/&gt;
.. ROW_NUMBER() OVER () ...&lt;/p&gt;</comment>
                            <comment id="12546185" author="thomanie" created="Wed, 28 Nov 2007 09:54:30 +0000"  >&lt;p&gt;I started comparing&lt;br/&gt;
   select * from (select row_number() as r, t.* from t) as tr where r &amp;lt; 4;&lt;br/&gt;
to&lt;br/&gt;
   select * from (select a*b as r, t.* from t) as tr where r &amp;lt; 4;&lt;/p&gt;

&lt;p&gt;i.e change row_number() for a*b as the expression in the inner select.&lt;/p&gt;

&lt;p&gt;In both these cases the top of the QueryTree looks like&lt;/p&gt;

&lt;p&gt;  SELECT&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;  PRN&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;  SELECT&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;  PRN &lt;br/&gt;
  ...&lt;/p&gt;

&lt;p&gt;where the SelectNode fromList point to the below ProjectRestrictNode (PRN), and the PRNs childResult point to the second SelectNode and so on.&lt;/p&gt;

&lt;p&gt;Even in the a*b scenario, the wherePredicate in the top SelectNode is not pushed below the first PRN, since it is referencing an expression. This means as of now the inner &apos;select a*b as r ...&apos; results in a full table scan, returning all rows to the outer select, and the restriction is checked at the outer select which in the end return only a few rows.&lt;/p&gt;

&lt;p&gt;It would seem like a reasonable/good/necessary optimization to push the where predicate down into the second select?&lt;br/&gt;
I can&apos;t remember seeing any jiras relating to this off the top of my head. In the general case one could possibly argue that it does not really matter where it is restricted as long as it&apos;s done in the engine, but in the row_number() case and possibly with indexes and sorted inner results, you will take a (potentially severe) performance hit?&lt;/p&gt;</comment>
                            <comment id="12548203" author="thomanie" created="Tue, 4 Dec 2007 10:25:47 +0000"  >&lt;p&gt;Attaching a minimal junit test for row_number()&lt;/p&gt;</comment>
                            <comment id="12548334" author="dyret" created="Tue, 4 Dec 2007 18:19:44 +0000"  >&lt;p&gt;I committed the minimal junit test for row_number(). I expect that this is &quot;work in progress&quot; as the test was not added to a suite (reasonable since the functionality being tested isn&apos;t available yet &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;One comment: I see the JUnit gurus advocating the use of the harness utility function createStatement() because Statement objects then will be closed automatically. You may want to consider this for the final version.&lt;/p&gt;</comment>
                            <comment id="12548363" author="knutanders" created="Tue, 4 Dec 2007 19:16:30 +0000"  >&lt;p&gt;It would also be good to document why the lock timeouts need to be lowered. It&apos;s not obvious to me, as a single connection shouldn&apos;t cause any lock conflicts.&lt;/p&gt;</comment>
                            <comment id="12548598" author="thomanie" created="Wed, 5 Dec 2007 09:11:23 +0000"  >&lt;p&gt;Thanks Dyre. &lt;br/&gt;
Yes, it&apos;s still work in progress. I&apos;ll look into the createStatement() harness utility function.&lt;/p&gt;

&lt;p&gt;Knut:&lt;br/&gt;
That&apos;s a copy-paste error on my part. I based the new test on SimpleTest. There should be no need to lower the lock timeouts.&lt;/p&gt;</comment>
                            <comment id="12548616" author="thomanie" created="Wed, 5 Dec 2007 10:06:56 +0000"  >&lt;p&gt;&apos;d2998-test2.diff&apos; is a patch for the committed test fixing the comments from Dyre and Knut on createStatement() and lock settings.&lt;/p&gt;</comment>
                            <comment id="12548648" author="knutanders" created="Wed, 5 Dec 2007 12:17:59 +0000"  >&lt;p&gt;Thanks Thomas. Committed revision 601309. I made a small change before committing: Since TestConfiguration.defaultSuite() wraps the suite in a CleanDatabaseTestSetup internally, I removed the explicit wrapping in the suite() method.&lt;/p&gt;</comment>
                            <comment id="12548661" author="thomanie" created="Wed, 5 Dec 2007 13:12:49 +0000"  >&lt;p&gt;Thanks Knut - also for spotting that one...&lt;/p&gt;</comment>
                            <comment id="12550029" author="thomanie" created="Mon, 10 Dec 2007 12:05:46 +0000"  >&lt;p&gt;&apos;d2998-6.diff&apos; has the following updates:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;adds statistics for queryplan dumps (-Dderby.language.logQueryPlan=true)&lt;/li&gt;
	&lt;li&gt;refactors newly introduced class OLAPResultSetImpl to OLAPResultSet to align with similar classes.&lt;/li&gt;
	&lt;li&gt;fixes a few issues with the patch due to other recent changes&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12550401" author="thomanie" created="Tue, 11 Dec 2007 11:32:09 +0000"  >&lt;p&gt;An email discussion with A B on derby-dev indicates that the conditional pushing I originally did in PredicateList was correct after all &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
So I need to sort out how I can get the failing join Knut reported to work, and also why the less than works, but greater than doesn&apos;t.&lt;/p&gt;

&lt;p&gt;I started looking at triggerig materializing the OLAPResultSet by returning true from OLAPNode.performMaterialization() as one option.&lt;/p&gt;

&lt;p&gt;I might need to move the generation of calls to increment code from ResultColumnList.generateCore() and down into RowNumberColumnNode.generateCore(). I&apos;m also wondering wether the call shouldn&apos;t be made into BaseActivation like in d2998-6.diff.&lt;/p&gt;

&lt;p&gt;I&apos;ll keep digging...&lt;/p&gt;</comment>
                            <comment id="12551121" author="djd" created="Wed, 12 Dec 2007 21:59:01 +0000"  >&lt;p&gt;Is there a write-up on what this issue is planning to produce?&lt;br/&gt;
The linked to wiki page clearly shows the syntax but most of the current examples in the test (and in most comments in this issue) do not follow that syntax.&lt;/p&gt;

&lt;p&gt;E.g.  select row_number(), t1.* from t1&lt;/p&gt;

&lt;p&gt;I understand that it&apos;s a work in progress, but is the final aim to support more than&lt;/p&gt;

&lt;p&gt;  ROW_NUMBER() OVER &amp;lt;window name or specification&amp;gt;&lt;/p&gt;

&lt;p&gt;and hence have non-standard expressions? Or are the non-standard examples just a interim development step that will be removed before any release?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.apache.org/db-derby/OLAPRowNumber&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/OLAPRowNumber&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12551241" author="thomanie" created="Thu, 13 Dec 2007 07:09:47 +0000"  >&lt;p&gt;Dan, &lt;/p&gt;

&lt;p&gt;Yes, this is still a work in progress and a lot of the comments reflect this. I dove off the deep end to get my feet wet with derby, and I&apos;m still trying to learn how to swim &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;That linked wikipage is, or at least was intended to be, the writeup of what this issue should end as. &lt;/p&gt;

&lt;p&gt;The future goal is for derby to support window functions over both named and unnamed windows, but that needs to be done in multiple jiras IMHO as it&apos;s a large task. This jira will only implement the ROW_NUMBER() function, and not the window specification (OVER &amp;lt;window name or specification&amp;gt;). As long as the window specification remains unsupported, the syntax will be deviating from the standard. It&apos;s not about introducing non-standard expressions, but a step towards having standard window functions in derby.&lt;/p&gt;

&lt;p&gt;In attached patch &apos;d2998-6&apos;, I accept &apos;OVER ()&apos; silently in sqlgrammar.jj. That should change to accepting &apos;OVER &amp;lt;window name or spec&amp;gt;&apos;. At the same time it may be a good idea to throw an unsupported type exception if the user attempts using a window name or specification?&lt;/p&gt;

&lt;p&gt;Not having support for &amp;lt;window name or specification&amp;gt; is the reason for the test not using the window name or specification as of now.&lt;/p&gt;</comment>
                            <comment id="12551535" author="bryanpendleton" created="Thu, 13 Dec 2007 15:32:00 +0000"  >&lt;p&gt;Perhaps, for this phase of the implementation, we should require OVER (),&lt;br/&gt;
and the test cases should all use this format.&lt;/p&gt;</comment>
                            <comment id="12551544" author="djd" created="Thu, 13 Dec 2007 16:00:18 +0000"  >&lt;p&gt;Thanks Thomas, I agree that the implementation path you are on is good approach, but at some point someone will want to produce a release that is branched off the trunk, we just need to ensure that non-standard use of ROW_NUMBER is not supported. That would either mean disabling ROW_NUMBER in the branch (e.g. 10.4) or not supporting non-standard use in the trunk at any time.&lt;br/&gt;
Probably any decision can be deferred until closer to the next release, which is due in Feb.&lt;br/&gt;
Note that the 10.4 wiki page does indicate that ROW_NUMBER() is to be supported in 10.4, from the comments in this issue it seems unlikely a conformant ROW_NUMBER will be finished by then??&lt;/p&gt;</comment>
                            <comment id="12551548" author="bryanpendleton" created="Thu, 13 Dec 2007 16:33:26 +0000"  >&lt;p&gt;Dan, do you believe that ROW_NUMBER OVER () is a non-standard use of ROW_NUMBER?&lt;/p&gt;</comment>
                            <comment id="12551555" author="mamtas" created="Thu, 13 Dec 2007 16:51:04 +0000"  >&lt;p&gt;I thought I would chime in here and say that ROW_NUMBER OVER ()  is SQL standards compliant. &lt;/p&gt;

&lt;p&gt;SQL spec has following (Section 7.11 &amp;lt;window clause&amp;gt;)&lt;br/&gt;
&amp;lt;window specification&amp;gt; ::=&lt;br/&gt;
&amp;lt;left paren&amp;gt; &amp;lt;window specification details&amp;gt; &amp;lt;right paren&amp;gt;&lt;br/&gt;
&amp;lt;window specification details&amp;gt; ::=&lt;br/&gt;
[ &amp;lt;existing window name&amp;gt; ]&lt;br/&gt;
[ &amp;lt;window partition clause&amp;gt; ]&lt;br/&gt;
[ &amp;lt;window order clause&amp;gt; ]&lt;br/&gt;
[ &amp;lt;window frame clause&amp;gt; ]&lt;/p&gt;

&lt;p&gt;This indicates that window specificatoin details are optional.&lt;/p&gt;</comment>
                            <comment id="12551568" author="djd" created="Thu, 13 Dec 2007 18:18:55 +0000"  >&lt;p&gt;&amp;gt; do you believe that ROW_NUMBER OVER () is a non-standard use of ROW_NUMBER?&lt;/p&gt;

&lt;p&gt;No idea, Mamta points out that the syntax grammar allows it. I haven&apos;t gone through all the syntax and general rules in 6.10 &amp;amp; 7.11 to see if there are additional conditions that would lead an empty window specification to be invalid.&lt;/p&gt;

&lt;p&gt;(e.g. the syntax grammar for routine creation allows multiple LANGUAGE clauses, but the rules specify &quot;at most one&quot; language clause, so the syntax grammar is not the final say on if a statement is valid or not)&lt;/p&gt;</comment>
                            <comment id="12551729" author="thomanie" created="Fri, 14 Dec 2007 08:37:43 +0000"  >&lt;p&gt;Thanks for taking the time to all of you. Confirmation that I&apos;m on the right path is also very good to get.&lt;/p&gt;

&lt;p&gt;I was under the impression that&lt;br/&gt;
   ROW_NUMBER() OVER ()&lt;br/&gt;
was compliant and meaning over the unsorted resultset. This construct was indeed what I was hoping to have ready for 10.4. I&apos;ll have another look at the spec, but would appreciate if someone else could have a look as well. It&apos;s not an easy read.&lt;/p&gt;

&lt;p&gt;Based on your comments I&apos;ve attached &apos;d2998.7.diff&apos; which requires the OVER () window specfication in sqlgrammar.jj, and a patch for the test with the necessary changes.&lt;/p&gt;</comment>
                            <comment id="12551730" author="thomanie" created="Fri, 14 Dec 2007 08:38:30 +0000"  >&lt;p&gt;Test patch for d2998-7.diff which requires OVER () &lt;/p&gt;</comment>
                            <comment id="12551840" author="djd" created="Fri, 14 Dec 2007 16:04:15 +0000"  >&lt;p&gt;Looking at the spec I think ROW_NUMBER() OVER () is compliant.&lt;/p&gt;

&lt;p&gt;Section 6.10 SR 6) covers ROW_NUMBER and rank function and there is explicit text (SR 6a) that says:&lt;br/&gt;
       &amp;gt;&amp;gt;&amp;gt;&amp;gt; If RANK or DENSE_RANK is specified, then the window ordering clause WOC of WDX shall be present.&lt;/p&gt;

&lt;p&gt;I can&apos;t see any such restrictions for ROW_NUMBER in SR 6.&lt;/p&gt;

&lt;p&gt;Also from googling I saw that IBM&apos;s RedBrick supports ROW_NUMBER() OVER ().&lt;/p&gt;</comment>
                            <comment id="12551843" author="djd" created="Fri, 14 Dec 2007 16:11:51 +0000"  >&lt;p&gt;&amp;gt; ROW_NUMBER() OVER ()&lt;br/&gt;
&amp;gt;  This construct was indeed what I was hoping to have ready for 10.4. &lt;/p&gt;

&lt;p&gt;Sounds great, and I think a sub-set of standard behaviour is fine for any release. Since this is open source no one can say you must implement all of a standard feature (e.g. T611), only be thankful for any progress towards its completion.&lt;/p&gt;</comment>
                            <comment id="12552313" author="xiangzhouwang@gmail.com" created="Mon, 17 Dec 2007 02:40:33 +0000"  >&lt;p&gt;I really need it!&lt;/p&gt;</comment>
                            <comment id="12552346" author="thomanie" created="Mon, 17 Dec 2007 08:44:18 +0000"  >&lt;p&gt;It seems we all agree on ROW_NUMBER() OVER () being compliant - good &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The materialization path puts me in somewhat of a corner when I try to do connect-the-dots. I get a two column ExecRow from the materialized resultset, that is put into a three column ExecRow returned from OLAPResultSet.getNextRowCore(). That results in an NPE at a later stage. I had a look at  HashJoins and ProjectRestrictNode which ought to do more or less the same, as well as the javadocs for various descriptors available in OLAPResultSet.getNextRowCore(), but it&apos;s not obvious (yet) how I&apos;d go about adding a column to the materialized ExecRow.&lt;/p&gt;

&lt;p&gt;I hope to attach a doc patch later today.&lt;/p&gt;</comment>
                            <comment id="12552384" author="thomanie" created="Mon, 17 Dec 2007 12:09:47 +0000"  >&lt;p&gt;Attached is a Reference manual doc update for ROW_NUMBER.&lt;/p&gt;

&lt;p&gt;I included info on the LIMIT syntax used in other databases, and added LIMIT as a dita keyword so those searching will find ROW_NUMBER() in the ref manual.&lt;/p&gt;

&lt;p&gt;Please do &lt;b&gt;not&lt;/b&gt; commit until code patch is ready &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12552756" author="thomanie" created="Tue, 18 Dec 2007 13:46:57 +0000"  >&lt;p&gt;Note to self: RowUtil seems to have the kind of functions I need to extend the ExecRow. Need to figure out the column order for the extention, though.&lt;/p&gt;</comment>
                            <comment id="12559894" author="thomanie" created="Thu, 17 Jan 2008 10:35:10 +0000"  >&lt;p&gt;I have reworked my patch.&lt;/p&gt;

&lt;p&gt;Attaching &apos;d2998-8.diff&apos; and &apos;d2998-8.stat&apos;.&lt;/p&gt;

&lt;p&gt;During parsing (sqlgrammar.jj) we introduce the new RowNumberColumnNode and a WindowNode holding the specification of the window in the AST. The WindowNode does not do much as of today, but is there for future window functions and/or window specification to use.&lt;/p&gt;

&lt;p&gt;Once the best plan has been found during optimization, the last step in the current trunk code is to swap SelectNodes with ProjectRestrictNodes, and top the PRNs off with GroupByNode, DistinctNode, and a OrderByNode if required. &lt;/p&gt;

&lt;p&gt;At the generate PRN stage, and with the current &apos;d2998-8&apos; patch, we pull the WindowNode up from under the window function node, and place it on top of the existing (sub)tree, ending up with the following tree for code generation:&lt;/p&gt;

&lt;p&gt;PRN&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;WindowNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;OrderByNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;DistictNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;GroupByNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&amp;lt;PRN on top of anything below us, restricted on any where, and projected&amp;gt;&lt;/p&gt;

&lt;p&gt;This ensures the WindowNodeResultSet is generated to pull rows and evaluate the window function over the correct lower restricted, projected,  grouped and ordered ResultSets.&lt;/p&gt;

&lt;p&gt;The attached patch &apos;d2998-8.diff&apos; work for selects and nested selects, and Knuts join posted further up.&lt;/p&gt;

&lt;p&gt;The attached patch does not, however, work with group by, ditinct and/or order by. &lt;/p&gt;

&lt;p&gt;The reason is that the ResultColumn object for the window function column is added at execution time by WindowResultSet. The PRN topping off the SelectNode from list (typically a PRN on top of a FromBaseTable for a simple select) currently has a &apos;null&apos; (no object) for the window function ResultColumn. This in turn cause the sorters to object and thorw exceptions, as they find a null ResultColumn.&lt;/p&gt;

&lt;p&gt;Any suggestions as to how to solve this are very welcome! &lt;/p&gt;

&lt;p&gt;At the moment I see three solutions:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;introduce an non-null but &quot;empty&quot; or &quot;phantom&quot; ResultColumn object in the bottom PRN, and replace it with the correct value once we get to the WindowResultSet?&lt;/li&gt;
	&lt;li&gt;adjust the bottom PRN, and the orderby, groupby and having ResultColumns to only have the ResultColumns of the underlying ResultSet? Today they contain a reference to, and thereby sort on, all ResultColumns, including any window function ResultColumns.&lt;/li&gt;
	&lt;li&gt;adjust the sorters to allow null values?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Changing the sorters sounds dangerous . I don&apos;t feel truly comfortable with introducing phantom values either, even for a very short while. So maybe the second option is the best?&lt;/p&gt;</comment>
                            <comment id="12559904" author="thomanie" created="Thu, 17 Jan 2008 12:06:50 +0000"  >&lt;p&gt;Reattached &apos;d2998-8.diff&apos;&lt;/p&gt;</comment>
                            <comment id="12560547" author="rhillegas" created="Fri, 18 Jan 2008 21:16:38 +0000"  >&lt;p&gt;Thanks for the explanation of the problem, Thomas. I am still a bit puzzled, however. You have sketched the shape of the BestPlan produced by the optimizer, as seen before generate() is run on the plan. Could you show us the ExecutablePlan as well?&lt;/p&gt;

&lt;p&gt;Off the top of my head, at execution time, the sort ought to be happening beneath the WindowResultSet in the ExecutablePlan. It, however, sounds as though the row_number column has been pushed down into the ResultSet that the sorter is operating on. That sounds wrong to me. The row_number column should only appear in the top ResultSet generated from the top level PRN in the plan you sketched.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12563481" author="thomanie" created="Tue, 29 Jan 2008 12:02:36 +0000"  >&lt;p&gt;Attaching minor updates according to Ricks comment in d2998-9.diff.&lt;/p&gt;

&lt;p&gt;The query/executable plan is attached in d2998-9-derby.log, with d2998-9.diff applied, executing:&lt;br/&gt;
   select * from (select row_number() over () as r, t.* from t) as tr;&lt;/p&gt;

&lt;p&gt;The 9 patch attached does not evaluate WHERE clauses on expression columns in the materialized subquery resultset correctly.&lt;/p&gt;</comment>
                            <comment id="12563497" author="thomanie" created="Tue, 29 Jan 2008 12:45:55 +0000"  >&lt;p&gt;&amp;gt; The 9 patch attached does not evaluate WHERE clauses on expression columns in the materialized subquery resultset correctly.&lt;/p&gt;

&lt;p&gt;The predicate of the outer select is flagged as pushable, and ends up being pushed into the subquery for evaluation. This is wrong for window functions, and possibly also for any where clause over a materialized resultset.&lt;/p&gt;</comment>
                            <comment id="12563671" author="rhillegas" created="Tue, 29 Jan 2008 21:15:47 +0000"  >&lt;p&gt;Hi Thomas,&lt;/p&gt;

&lt;p&gt;Thanks for the latest patch. I have applied it and can see that the following query runs correctly:&lt;/p&gt;

&lt;p&gt;select *&lt;br/&gt;
from&lt;br/&gt;
(&lt;br/&gt;
  select row_number() over () as r, t.* from t&lt;br/&gt;
) tout&lt;br/&gt;
order by r;&lt;/p&gt;

&lt;p&gt;but the following query generates an error:&lt;/p&gt;

&lt;p&gt;select *&lt;br/&gt;
from&lt;br/&gt;
(&lt;br/&gt;
  select row_number() over () as r, t.* from t&lt;br/&gt;
) tout&lt;br/&gt;
where r &amp;gt; 2;&lt;br/&gt;
ERROR XJ001: Java exception: &apos;ASSERT FAILED sourceResultSetNumber expected to be &amp;gt;= 0 for null.R: org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;/p&gt;

&lt;p&gt;But, of course, you already know this. What kind of feedback do you want on this patch? Thanks.&lt;/p&gt;</comment>
                            <comment id="12565493" author="army" created="Mon, 4 Feb 2008 19:46:57 +0000"  >&lt;p&gt;Is there any kind of detailed write-up or functional spec for the approach that is being pursued in the patches thus far (esp. d2998-9.diff)?  I took a look at:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://wiki.apache.org/db-derby/OLAPRowNumber&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/OLAPRowNumber&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;but the &quot;proposed changes&quot; section on that page is rather abbreviated.  In particular, a description of how the query tree will look at various points during compilation (esp. 1) when created, 2) after preprocessing, and 3) after &quot;modification of access paths&quot;-&lt;del&gt;i.e. just before code generation) might be useful in trying to a) evaluate the approach, and b) offer feedback/suggestions on the various issues that are occurring.  Also useful would be a simple example of the intended compilation&lt;/del&gt; and execution-time processing that should occur when ROW_NUMBER() is in play.&lt;/p&gt;

&lt;p&gt;Apologies if the write-up already exists and I just missed it...&lt;/p&gt;

&lt;p&gt;One quick comment from scanning d2998-9.diff: Can you explain the purpose of the following change in SelectNode.java?&lt;/p&gt;

&lt;p&gt;       /* Intentionally hide this.resultColumns */&lt;br/&gt;
       ResultColumnList    resultColumns = this.resultColumns.copyListAndObjects();&lt;/p&gt;

&lt;p&gt;It appears to cause any RCL expression referenced by an outer query to fail with the same error as what Rick reported for ROW_ORDER(), ex:&lt;/p&gt;

&lt;p&gt;  ij&amp;gt; select * from (select i+j as x from hmm) a&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; where x &amp;gt; 0;&lt;br/&gt;
  ERROR XJ001: Java exception: &apos;ASSERT FAILED sourceResultSetNumber&lt;br/&gt;
  expected to be &amp;gt;= 0 for null.X&lt;/p&gt;

&lt;p&gt;But that same statement succeeds if you remove the above lines.  Of course, if you remove those lines then the simple ROW_ORDER() queries that work with d2998-9.diff applied stop working, so something is amiss somewhere.  A writeup of what the intended behavior/query tree structure is meant to be here might help...&lt;/p&gt;</comment>
                            <comment id="12565553" author="thomanie" created="Mon, 4 Feb 2008 21:47:09 +0000"  >&lt;p&gt;No, you didn&apos;t miss the writeup Army. The wikipage is all there is, and I haven&apos;t kept it up to date :/ Mostly because I&apos;ve been feeling my way forward with this while trying to understand the inner workings of Derby. I&apos;ll try to make up for it now and do a proper writeup for the proposed changes.&lt;/p&gt;

&lt;p&gt;Attached is an updated patch d2998-10.diff. &lt;br/&gt;
Still have some ordering issues, but where clauses and multiple row_number() columns are evaluated properly:&lt;br/&gt;
ij&amp;gt; &lt;br/&gt;
select * from t;&lt;br/&gt;
A          |B          &lt;br/&gt;
-----------------------&lt;br/&gt;
10         |100        &lt;br/&gt;
20         |200        &lt;br/&gt;
30         |300        &lt;br/&gt;
40         |400        &lt;br/&gt;
50         |500        &lt;/p&gt;

&lt;p&gt;5 rows selected&lt;br/&gt;
ij&amp;gt;  &lt;br/&gt;
select row_number() over (), tr.* from (select row_number() over () as r, t.* from t) as tr where r &amp;gt; 2;&lt;br/&gt;
row_number()        |R                   |A          |B          &lt;br/&gt;
-----------------------------------------------------------------&lt;br/&gt;
1                   |3                   |30         |300        &lt;br/&gt;
2                   |4                   |40         |400        &lt;br/&gt;
3                   |5                   |50         |500        &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;br/&gt;
ij&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12565717" author="thomanie" created="Tue, 5 Feb 2008 12:05:32 +0000"  >&lt;p&gt;I&apos;ve updated the wikipage with a more thorough writeup. It includes visual examples of the AST and queryplan, as well as some details on the path from SQL parsing to code execution.&lt;/p&gt;</comment>
                            <comment id="12565897" author="thomanie" created="Tue, 5 Feb 2008 21:31:58 +0000"  >&lt;p&gt;Fixed the issue with the sorter and ORDER BY clauses in d2998-11.diff. The patch still needs some polishing, but it works for most basic queries now.&lt;/p&gt;</comment>
                            <comment id="12565963" author="army" created="Tue, 5 Feb 2008 23:44:34 +0000"  >&lt;p&gt;Thank you for updating the wiki page with more details, Thomas.  A couple of comments that come to mind from a quick read of that page (without having examined the code changes themselves in detail):&lt;/p&gt;

&lt;p&gt; 1. Near the top of the wiki page there is a sentence saying:&lt;/p&gt;

&lt;p&gt;     &quot;In this example the ROW_NUMBER function is used to limit the&lt;br/&gt;
      query as soon as the first N rows have been determined&quot;.&lt;/p&gt;

&lt;p&gt;    But in the details that you&apos;ve added to the wiki, you note the following:&lt;/p&gt;

&lt;p&gt;     &quot;For the nested select query above we materialize the subquery&lt;br/&gt;
      select result, and have the outer SELECT pull rows from the&lt;br/&gt;
      materialized result&quot;.&lt;/p&gt;

&lt;p&gt;    From a quick reading of your writeup, it seems like materialization&lt;br/&gt;
    of the subquery might be counter-productive?  That is, if I have the&lt;br/&gt;
    following query:&lt;/p&gt;

&lt;p&gt;        SELECT * FROM (&lt;br/&gt;
          SELECT row_number() over () as r, t.* FROM T&lt;br/&gt;
        ) AS tmp WHERE r &amp;lt;= 3;&lt;/p&gt;

&lt;p&gt;    and table T has a thousand rows in it, the ideal would be to use the&lt;br/&gt;
    ROW_NUMBER() function to limit the scan on T so that we only fetch&lt;br/&gt;
    the first 3 rows from disk.  But if we materialize the subquery, I&lt;br/&gt;
    think that means the nested SELECT will issue a full scan on table T,&lt;br/&gt;
    returning all 1000 rows, and we&apos;ll &quot;materialize&quot; those into memory.&lt;br/&gt;
    Then the ROW_NUMBER() function will simply extract out the first 3&lt;br/&gt;
    rows from the materialized result set.  Is that an accurate description&lt;br/&gt;
    of what you mean by &quot;materialized result&quot;, or am I misreading?  If&lt;br/&gt;
    this is in fact what you are proposing, then can you explain a bit more&lt;br/&gt;
    about what the benefit of such materialization is?  Am I right in&lt;br/&gt;
    thinking that this could negate potential performance gains that might&lt;br/&gt;
    otherwise come from ROW_NUMBER() as a &quot;limiting&quot; predicate?&lt;/p&gt;

&lt;p&gt;    The wiki page does say:&lt;/p&gt;

&lt;p&gt;      &quot;window function results that span multiple rows, like a moving&lt;br/&gt;
       average, will benefit from materialization...&quot;&lt;/p&gt;

&lt;p&gt;    which may be true.  But it seems like there may be better ways to&lt;br/&gt;
    deal with such functions than full materialization of the result set.&lt;br/&gt;
    In particular, the idea of a &quot;sort observer&quot;, similar to what is used&lt;br/&gt;
    for GroupedAggregateResultSet, seems like it could potentially be&lt;br/&gt;
    useful for such a function?  Which brings me to my next comment...&lt;/p&gt;

&lt;p&gt; 2. Did you by chance look at GroupedAggregateResultSet and its surrounding&lt;br/&gt;
    code to see if the OLAP functions might extend that class?  It&apos;s perhaps&lt;br/&gt;
    overkill for a ROW_NUMBER() function that only supports empty, unnamed&lt;br/&gt;
    windows.  But the OLAP window specification in general seems to share some&lt;br/&gt;
    common concepts with GROUP BY processing, so I wonder if it&apos;d be possible&lt;br/&gt;
    to put building blocks in place based on that similarity--ex. to create&lt;br/&gt;
    some kind of &quot;WindowFunctionValue&quot; class that extends GroupedAggregated-&lt;br/&gt;
    ResultSet, and then have the various OLAP functions in turn extend&lt;br/&gt;
    WindowFunctionValue as needed.&lt;/p&gt;

&lt;p&gt;    I have no idea if/how that would actually work, but I thought I&apos;d mention&lt;br/&gt;
    it to see if you&apos;ve had an opportunity to look at that option?  Maybe&lt;br/&gt;
    it&apos;s not worth it for the simple ROW_NUMBER() function that you&apos;re currently&lt;br/&gt;
    working on--feel free to say so &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3. Under &quot;modification of access paths&quot; there is the following:&lt;/p&gt;

&lt;p&gt;    &quot;We add one WindowNode for each window function column, and they are&lt;br/&gt;
     evaluated left to right in the result column list, with the right most column &lt;br/&gt;
     being the top WindowNode in the query plan.&quot;&lt;/p&gt;

&lt;p&gt;    So if I have:&lt;/p&gt;

&lt;p&gt;        SELECT&lt;br/&gt;
            row_number() over () as r1,&lt;br/&gt;
            row_number() over () as r2,&lt;br/&gt;
            t.col1&lt;br/&gt;
        FROM T&lt;/p&gt;

&lt;p&gt;    Is it correct to say that my query tree will end up as:&lt;/p&gt;

&lt;p&gt;      ProjectRestrictNode&lt;br/&gt;
        ==&amp;gt; WindowNode (r2)&lt;br/&gt;
            ==&amp;gt; WindowNode (r1)&lt;br/&gt;
                ==&amp;gt; ProjectRestrictNode&lt;br/&gt;
                    ==&amp;gt; FromBaseTable&lt;/p&gt;

&lt;p&gt;    and my execution tree will look like:&lt;/p&gt;

&lt;p&gt;      ProjectRestrictResultSet&lt;br/&gt;
        ==&amp;gt; WindowResultSet (r2)&lt;br/&gt;
            ==&amp;gt; WindowResultSet (r1)&lt;br/&gt;
                ==&amp;gt; ProjectRestrictResultSet&lt;br/&gt;
                    ==&amp;gt; TableScanResultSet&lt;/p&gt;

&lt;p&gt;    I guess this isn&apos;t really a comment, just a quick check to make&lt;br/&gt;
    sure I&apos;m understanding what is supposed to happen &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12566164" author="thomanie" created="Wed, 6 Feb 2008 15:49:12 +0000"  >&lt;p&gt;Thanks for pitching in Army.&lt;/p&gt;

&lt;p&gt;Ad 1)&lt;br/&gt;
Good question. This probably needs a little more explaining &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The MaterializedResultSet does not materialize the complete lower result before pulling rows from it to the upper result. A row is generated, stored (i.e materialized), and then passed up the chain. Then the next row is materialized, and so on. This means you have only materialized those rows you have actually visited, so the optimization we seek will still happen. The query, and with that the row materialization, is stopped once the condition is met. The more involved your subquery is, the better effect materialization (or caching) will give.&lt;/p&gt;

&lt;p&gt;With that said I don&apos;t really see the need for materializing subqueries for ROW_NUMBER(). I have turned off materialization in the latest patches. But for other functions it may be valid, so materialization or not should probably become dependant on what function is evaluated.&lt;/p&gt;

&lt;p&gt;Ad 2)&lt;br/&gt;
I did have a look at the GroupedAggregateResultSet at a very early stage, but I should probably revisit that now.&lt;/p&gt;

&lt;p&gt;Ad 3)&lt;br/&gt;
Yes, that is basically how the trees will look like. &lt;/p&gt;

&lt;p&gt;It might be worth looking into generating all window functions belonging to a given RCL in the same WindowNode and/or WindowResultSet, but I won&apos;t dive into that now. Doing that is still only valid if the functions operate on the exact same window definition - however (un)likely that is, and adding handling of multiple window definitions to WindowNode and/or WindowResultSet will probably introduce some unnecessary complexity. The extra cost of passing the row through an additional ResultSet in the chain is pretty small, so I&apos;m not yet convinced it&apos;s worth doing. &lt;/p&gt;</comment>
                            <comment id="12566285" author="army" created="Wed, 6 Feb 2008 19:20:42 +0000"  >&lt;p&gt;Thank you for the quick replies, Thomas.&lt;/p&gt;

&lt;p&gt;&amp;gt; The MaterializedResultSet does not materialize the complete lower result before&lt;br/&gt;
&amp;gt; pulling rows from it to the upper result. &lt;/p&gt;

&lt;p&gt;Okay, thanks for setting me straight on that.  I scanned the code in MaterializedResultSet and confirmed what you said, i.e. that rows are fetched one at a time and stored into a temporary conglomerate.  It is only when (if) the scan is RE-opened again later that the temporary conglomerate is then used for subsequent scanning.&lt;/p&gt;

&lt;p&gt;&amp;gt; It might be worth looking into generating all window functions belonging to a given RCL in the&lt;br/&gt;
&amp;gt; same WindowNode and/or WindowResultSet&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth, I tend to like that approach better, as it seems (to me) to be a more intuitive way to handle multiple window functions in the same RCL.&lt;/p&gt;

&lt;p&gt;&amp;gt; Doing that is still only valid if the functions operate on the exact same window definition&lt;/p&gt;

&lt;p&gt;Would this be a requirement or just a preference?  If you define some kind of WindowFunctionResult that takes &quot;source&quot; rows and orders/groups/filters them according to its own window definition, then would it not be possible for each instance of WindowFunctionResult to take the same &quot;source&quot; row and deal with it as necessary?  I.e. the WindowResultSet would read the source row and then pass it down to each of its WindowFunctionResult columns, letting the latter handle the row as needed (discard it, sort it, group it, etc.).  Not sure exactly how that might work, but it seems feasible...&lt;/p&gt;

&lt;p&gt;&amp;gt; adding handling of multiple window definitions to WindowNode and/or WindowResultSet will&lt;br/&gt;
&amp;gt; probably introduce some unnecessary complexity&lt;/p&gt;

&lt;p&gt;It would certainly require more work to get your current code to support that, but from a high-level view, would it result in a more complex overall design/implementation?  I don&apos;t know one way or the other, I&apos;m just asking the question.  And &quot;I don&apos;t know because I haven&apos;t tried&quot; would be a perfectly valid answer &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12568346" author="army" created="Tue, 12 Feb 2008 22:44:56 +0000"  >&lt;p&gt;&amp;gt; d2998-11.diff. The patch still needs some polishing, but it works for most basic queries now.&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth, I applied the patch and played around with some queries that include multiple ROW_NUMBER() functions in the same RCL.  In doing so I noticed that the following queries all return incorrect results for the third column:&lt;/p&gt;

&lt;p&gt;create table t1 (i int, j int);&lt;br/&gt;
insert into t1 values (1, 0), (1, -1), (2, -2), (3, -3), (4, -4);&lt;/p&gt;

&lt;p&gt;select row_number() over(), row_number() over(), i from t1;&lt;br/&gt;
select row_number() over(), row_number() over(), 2*i from t1;&lt;br/&gt;
select row_number() over(), row_number() over(), j from t1;&lt;br/&gt;
select row_number() over(), row_number() over(), &apos;HMM&apos; from t1;&lt;/p&gt;

&lt;p&gt;In all cases the third column returns the same valus as the ROW_NUMBER() columns--i.e. the results are:&lt;/p&gt;

&lt;p&gt;row_number()        |row_number()        |3&lt;br/&gt;
---------------------------------------------&lt;br/&gt;
1                   |1                   |1&lt;br/&gt;
2                   |2                   |2&lt;br/&gt;
3                   |3                   |3&lt;br/&gt;
4                   |4                   |4&lt;br/&gt;
5                   |5                   |5&lt;/p&gt;

&lt;p&gt;5 rows selected&lt;/p&gt;

&lt;p&gt;So it looks like the third column is being ignored and/or replaced by a row_number() column.&lt;/p&gt;

&lt;p&gt;I also noticed that the following query fails with an ArrayIndexOutOfBoundsException:&lt;/p&gt;

&lt;p&gt; select row_number() over (), i from t1 order by j desc;&lt;/p&gt;

&lt;p&gt;while this one passes (order by &quot;i&quot; instead of &quot;j&quot;):&lt;/p&gt;

&lt;p&gt; select row_number() over (), i from t1 order by i desc;&lt;/p&gt;

&lt;p&gt;And the following fails with an ASSERT failure (this might just be &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3310&quot; title=&quot;ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3310&quot;&gt;&lt;del&gt;DERBY-3310&lt;/del&gt;&lt;/a&gt;, but I thought I&apos;d mention it):&lt;/p&gt;

&lt;p&gt;  select * from&lt;br/&gt;
    (select row_number() over(), j from t1) x(a,b) where a &amp;gt; 2 order by a desc;&lt;/p&gt;

&lt;p&gt;Are these kind of issues ones about which you already know?  If so, then I think I&apos;ll echo Rick&apos;s comment from a short while back: namely, what kind of feedback would you like on this patch?&lt;/p&gt;</comment>
                            <comment id="12568462" author="thomanie" created="Wed, 13 Feb 2008 08:13:24 +0000"  >&lt;p&gt;These are indeed the issues I&apos;m looking into now. &lt;/p&gt;

&lt;p&gt;The incorrect results are caused by the source column mapping being messed up. I&apos;m aware of the assert from the &quot;where ... order by&quot; query, but haven&apos;t had a chance to look closely at it yet. It&apos;s related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3310&quot; title=&quot;ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3310&quot;&gt;&lt;del&gt;DERBY-3310&lt;/del&gt;&lt;/a&gt;, but rather (again) column mapping being off is causing us to map either an SQLInteger into a SQLLongint column or the other way around.&lt;/p&gt;

&lt;p&gt;I&apos;ve uploaded the patches mainly so others can have a look if they&apos;re interested. I&apos;m not really looking for any specific feedback - but any feedback is still appreciated. Thanks for taking the time &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12568541" author="thomanie" created="Wed, 13 Feb 2008 13:21:31 +0000"  >&lt;p&gt;Attaching updates to the OLAPTest in &apos;d2998-test4.diff&apos;. This is a collection of the different queries that have been reported to fail, as well as a couple of other verification queries.&lt;/p&gt;

&lt;p&gt;The test4 patch makes OLAPTest contain 13 queries expected to pass, and 3 expected to fail.&lt;/p&gt;</comment>
                            <comment id="12568546" author="thomanie" created="Wed, 13 Feb 2008 13:38:54 +0000"  >&lt;p&gt;Attaching &apos;d2998-12.diff&apos; patch that fixes the problems also seen by Army.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;queries ordered on a column left out of the projection&lt;/li&gt;
	&lt;li&gt;incorrect results due to incorrect column mapping&lt;/li&gt;
	&lt;li&gt;the assert due to incorrect column mapping&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The 16 queries in my previously attached test4 patch run successfully, and the lang/_Suite runs without failures.&lt;/p&gt;

&lt;p&gt;There&apos;s still a problem with the column mapping if you do multiple window functions in a single RCL. &lt;br/&gt;
If you happen to play with this and see failing queries, please let me know.&lt;/p&gt;</comment>
                            <comment id="12568908" author="thomanie" created="Thu, 14 Feb 2008 12:21:45 +0000"  >&lt;p&gt;Attaching patch d2998-13 that fixes multiple windowfunctions in a single RCL.&lt;br/&gt;
Added 3 test queries with multiple window function columns to the test in d2998-test6.&lt;/p&gt;

&lt;p&gt;The extended test pass, and the lang/_Suite test is still running. I don&apos;t expect any problems there from the last increment to the patch.&lt;/p&gt;

&lt;p&gt;Before checking patch available I want to add an abstract superclass WindowFunctionColumnNode to RowNumberColumnNode.&lt;/p&gt;</comment>
                            <comment id="12568929" author="thomanie" created="Thu, 14 Feb 2008 13:43:52 +0000"  >&lt;p&gt;Tested more queries and it turns out the last patch I posted produces an assert from one of Armys queries above. Looking into this now.&lt;/p&gt;</comment>
                            <comment id="12569995" author="thomanie" created="Mon, 18 Feb 2008 19:47:41 +0000"  >&lt;p&gt;The problem with the latest patch is due to the new code that changes the ResultColumnList column references into virtual column references.&lt;/p&gt;

&lt;p&gt;With this issue fixed I get incorrect results whenever there is a subquery involved. This again is because of how preprocessing is done. The outer SelectNodes FromList contains a FromSubquery with the inner SelectNode. The FromSubquery is rewritten during preprocessing to a ProjectRestictNode. This PRN gets the original ResultColumns (i.e before we optimize and modify the access paths and pull the WindowNodes into the tree and ResultColumList) In the original RCL the virtual column ids are not what the lower levels PRNs end up with after optimization:&lt;/p&gt;

&lt;p&gt;So, before preprocessing:&lt;br/&gt;
SelectNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;FromSubquery&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;SelectNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;During preprocessing this is rewritten to:&lt;br/&gt;
SelectNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;PRN &amp;lt;-- This PRN has original RCL&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;SelectNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;After optimization we have something like:&lt;br/&gt;
PRN&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;PRN &amp;lt;-- This PRN has original RCL, which now has wrong VirtualColumnID references&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;PRN &amp;lt;-- This has correct RCL after optimization and pulling WindowNodes up&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;WindowNode&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;PRN&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;....&lt;/p&gt;

&lt;p&gt;Just need to figure out how to solve this. Might be possible to collapse the PRN as it seems to be a no-op, or pull the RCL up from the lower PRN after/during optimization if there are window columns involved?&lt;/p&gt;</comment>
                            <comment id="12571168" author="thomanie" created="Thu, 21 Feb 2008 20:15:37 +0000"  >&lt;p&gt;Attached patches (d2998-14 and test7) fixes the virtual column ids mentioned in my previous comment. &lt;/p&gt;

&lt;p&gt;Turned out the middle PRN (initially FromSubquery) and the lower SelectNode were actually using the same instance of the RCL, so when the lower SelectNode (its PRN to be precise) was updating its RCL the changes were also reflected in the upper PRN. This has been fixed in the 14 patch.&lt;/p&gt;

&lt;p&gt;The optimization now works as expected, but some of the resultset numbers are now missing in the middle PRNs RCL, and this cause code generation to complain for the last query in test7. Any input on how to solve this will be very welcome. &lt;/p&gt;

&lt;p&gt;Test7 reorders the queries in the test so that the two failing queries are run last. The other 19 or so runs fine.&lt;/p&gt;</comment>
                            <comment id="12572040" author="thomanie" created="Mon, 25 Feb 2008 10:03:11 +0000"  >&lt;p&gt;d2998-15 changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;adds abstract class WindowFunctionColumnNode, which RowNumberColumnNode subclasses. This makes any instanceof-checks in other parts of code generic. Common code moved from RNCN to WFCN.&lt;/li&gt;
	&lt;li&gt;simplified pulling WindowNodes into the querytree in SelectNode.genProjectRestrictNode.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The 15 patch still has the resultset numbering problem in the RCLof the PRN that was originally a FromSubquery.&lt;/p&gt;</comment>
                            <comment id="12572151" author="army" created="Mon, 25 Feb 2008 18:29:25 +0000"  >&lt;p&gt;&amp;gt; some of the resultset numbers are now missing in the middle PRNs RCL, and this&lt;br/&gt;
&amp;gt; cause code generation to complain for the last query in test7. Any input on how to&lt;br/&gt;
&amp;gt; solve this will be very welcome.&lt;/p&gt;

&lt;p&gt;I think the file &quot;test7.diff&quot; as attached is a &quot;stat&quot; file instead of a &quot;diff&quot; file...can you re-attach it?&lt;/p&gt;</comment>
                            <comment id="12572227" author="thomanie" created="Mon, 25 Feb 2008 20:52:25 +0000"  >&lt;p&gt;Reattaching d2998-test7.diff. Sorry about that :|&lt;/p&gt;</comment>
                            <comment id="12572260" author="army" created="Mon, 25 Feb 2008 21:51:15 +0000"  >&lt;p&gt;Hi Thomas, thanks for your continued work on this.&lt;/p&gt;

&lt;p&gt;&amp;gt; Sorry about that :|&lt;/p&gt;

&lt;p&gt;Not a problem &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I haven&apos;t had a chance to look at the failing queries that you refer to in test7, but I did take a look at patch 15.  Some comments/questions after my first run through are below.&lt;/p&gt;

&lt;p&gt;1)  There are a lot of places with logic similar to the following:&lt;/p&gt;

&lt;p&gt;  ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);&lt;br/&gt;
  if (rc.getExpression() instanceof WindowFunctionColumnNode)&lt;/p&gt;
  {
    ...
  }

&lt;p&gt;Since WindowFunctionColumnNode extends ResultColumn, I wonder if it would be worth it to add a new &quot;isWindowColumn()&quot; method (or something like that) to ResultColumn.java and let that method contain all of the necessary logic for finding a WindowFunctionColumnNode.  If that was done then the above type of &quot;if&quot; expression becomes simply:&lt;/p&gt;

&lt;p&gt;  ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);&lt;br/&gt;
  if (rc.isWindowColumn())&lt;/p&gt;
  {
     ...
  }

&lt;p&gt;which makes it easier to extend the check for &quot;window columns&quot; in the future if needed.  For example, would it ever be necessary to walk further down the ResultColumn&apos;s expression chain to look for a RowNumber column?  That is, could we ever have:&lt;/p&gt;

&lt;p&gt;   ResultColumn&lt;br/&gt;
     -&amp;gt; VirtualColumnNode&lt;br/&gt;
        -&amp;gt; ResultColumn&lt;br/&gt;
          -&amp;gt; ...&lt;br/&gt;
            -&amp;gt; RowNumberColumnNode&lt;/p&gt;

&lt;p&gt;If so, then the &quot;isWindowColumn()&quot; as defined in ResultColumn.java could include the necessary logic to walk the chain, which would simplify the calling code.  See, for example, comments #5 and #6 below.&lt;/p&gt;

&lt;p&gt;2)&lt;/p&gt;

&lt;p&gt;In WindowNode.bind() there is the following:&lt;/p&gt;

&lt;p&gt;  /* At this stage there is hopefully a PRN below us as the fromList */&lt;br/&gt;
  return this;&lt;/p&gt;

&lt;p&gt;It might be good to add an ASSERT here to make sure that the &apos;hopefully&apos; condition is satisified...&lt;/p&gt;

&lt;p&gt;3)&lt;/p&gt;

&lt;p&gt;Many of the fields in WindowNode (and other new classes added by this patch) are &quot;public&quot;, but some of them are never referenced outside of WindowNode. Unless a &quot;public&quot; declaration is functionally necessary, it seems like it would be safer to make them private and then supply the necessary getter/setter methods where needed, to avoid accidental modification.&lt;/p&gt;

&lt;p&gt;4)&lt;/p&gt;

&lt;p&gt;In WindowNode.java there is a field &quot;level&quot; which is initialized to -1 and then is set from SelectNode.java.  But as far as I can tell there are no comments explaining what that field does.  I think I was able to figure it out from the code, but it&apos;d be nice to have explanatory comments within WindowNode itself.  And per comment #3 above, I think it&apos;d be nice to use a setter method in SelectNode instead of direct assignment to the public field.&lt;/p&gt;

&lt;p&gt;5)&lt;/p&gt;

&lt;p&gt;In ColumnReference.java there are two different kinds of checks to see if the ColumnReference is pointing to a WindowColumnNode.  The first is via the method &quot;pointsToWindowFunction()&quot;, which does an instanceof check on the source ResultColumn&apos;s expression and returns true if it is a WindowFunctionColumnNode.  The second is in the categorize() method, where the logic only evaluates to true if the source ResultColumn&apos;s expression is a &lt;b&gt;VirtualColumnNode&lt;/b&gt; whose source ResultColumn&apos;s expression is a WindowFunctionColumnNode.  So the checks do not appear to be equivalent.  Is that intentional?  If so, then explanatory comments might be good here.  Also, I believe this is a good example of the kind of code that might benefit from an &quot;isWindowColumn()&quot; function on ResultColumn, per comment #1 above.&lt;/p&gt;

&lt;p&gt;6)&lt;/p&gt;

&lt;p&gt;In ResultColumnList.java, there is the following:&lt;/p&gt;

&lt;p&gt;    /* Window function columns are added by the WindowResultSet */&lt;br/&gt;
    if (sourceExpr instanceof WindowFunctionColumnNode ||&lt;br/&gt;
        (sourceExpr instanceof VirtualColumnNode &amp;amp;&amp;amp;&lt;br/&gt;
        (sourceExpr.getSourceResultColumn().getExpression()&lt;br/&gt;
            instanceof WindowFunctionCumnNode)))&lt;/p&gt;
    {
        continue;
    }

&lt;p&gt;See comment #1 above for an alternate (cleaner?) approach...&lt;/p&gt;

&lt;p&gt;7)&lt;/p&gt;

&lt;p&gt;The result set statistics node for WindowResultSet does not currently print out the name of the result set...(I don&apos;t think).  This is pretty minor, but I was briefly confused when I saw the RealWindowResultSetStatistics class and yet the query plans weren&apos;t showing anything &quot;window&quot; releated.&lt;/p&gt;

&lt;p&gt;8)&lt;/p&gt;

&lt;p&gt;If I&apos;m understanding correctly, the execution-time logic for WindowResultSet operates in a fashion similar to ProjectRestrictResultSet.  That is, it iterates through all of its source&apos;s rows and, for each one, it applies a restriction.  If the row fails the restriction, then the iteration moves on to the next source row, and so on.  This agrees with the following comments, pulled from the getNextRowCore() method of WindowResultSet:&lt;/p&gt;

&lt;p&gt;   /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Loop until we get a row from the source that qualifies, or there are&lt;/li&gt;
	&lt;li&gt;no more rows to qualify. For each iteration fetch a row from the&lt;/li&gt;
	&lt;li&gt;source, and evaluate against the restriction if any.&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If this is correct, then I&apos;m not entirely sure we&apos;ll get the performance boost that one might perhaps expect from a query like:&lt;/p&gt;

&lt;p&gt;    SELECT * FROM (&lt;br/&gt;
      SELECT row_number() over () as r, t.* FROM T&lt;br/&gt;
    ) AS tmp WHERE r &amp;lt;= 3;&lt;/p&gt;

&lt;p&gt;I made a similar comment on Februrary 5th that was based on materialization of the source result set, and that comment ended up being wrong because I misunderstood materialization.  But in looking at this query again, I think something might still be slightly sub-optimal here.&lt;/p&gt;

&lt;p&gt;If we take the approach of &quot;loop until we get a row that qualifies&quot;, then we will loop through &lt;em&gt;all&lt;/em&gt; of the rows in table T, even though only the first 3 satisfy the restriction.  In the end we will correctly return the first 3 rows (and only the first 3 rows) but not before we&apos;ve read all of the others from disk and applied the &quot;&amp;lt;= 3&quot; restriction to each one.  This can be observed by either a) adding debug printouts to WindowResultSet.getNextRowCore() for every call to &quot;source.getNextRowCore()&quot;, or b) looking at the query plan.  For the above query, the plan shows the following for the top-most ProjectRestrictResultSet:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;
					&lt;ul&gt;
						&lt;li&gt;
						&lt;ul&gt;
							&lt;li&gt;Project-Restrict ResultSet (1):&lt;br/&gt;
  Number of opens = 1&lt;br/&gt;
  Rows seen = 1280&lt;br/&gt;
  Rows filtered = 1277&lt;br/&gt;
  restriction = true&lt;/li&gt;
						&lt;/ul&gt;
						&lt;/li&gt;
					&lt;/ul&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So we actually read all 1280 rows from disk, then filtered 1277 of them out so that, in the end, we only returned 3 rows.  Thus from a performance perspective the ROW_NUMBER() function does not appear to improve things.  Is that a known limitation of the current development (which, for the record, would be perfectly acceptable)?&lt;/p&gt;

&lt;p&gt;Having said that, there is absolutely &lt;em&gt;NO&lt;/em&gt; need for you to boost performance before committing the changes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Incremental development is good and it&apos;s great to have the functionality working.  Performance improvements can always be addressed later, if you (or anyone else) so chooses.  I&apos;m just raising the issue to make sure that I understand how things are working.&lt;/p&gt;

&lt;p&gt;9)&lt;/p&gt;

&lt;p&gt;For the query mentioned in comment #8 above, the query plan shows:&lt;/p&gt;

&lt;p&gt;  ProjectRestrictResultSet (sees ALL rows, restricts down to 3)&lt;br/&gt;
    -&amp;gt; ProjectRestrictResultSet (sees ALL rows)&lt;br/&gt;
      -&amp;gt; WindowResultSet (sees ALL rows)&lt;/p&gt;

&lt;p&gt;I intuitively expected the restriction to appear at the level of the WindowResultSet, as opposed to appearing at the level of the top-most PRN.  The plan as shown above makes it look like the restriction is not being enforced by the Window ResultSet, but is instead being enforced by the ProjectRestrict. Is that correct?  Or is this just a case where the query plan fails to capture what is really happening with the WindowResultSet?  I&apos;m guessing the latter, but am not sure...&lt;/p&gt;</comment>
                            <comment id="12572439" author="thomanie" created="Tue, 26 Feb 2008 11:55:36 +0000"  >&lt;p&gt;Thanks again for having a look Army!&lt;/p&gt;

&lt;p&gt;Attaching patch d2998-16.diff that fixes most of Army comments, plus a few other very minor issues. Testwise I get the same result with patch 16.&lt;/p&gt;

&lt;p&gt;&amp;gt; 1)  ....  I wonder if it would be worth it to add a new &quot;isWindowColumn()&quot; method&lt;/p&gt;

&lt;p&gt;Agree - makes the code more easily readable. Fixed in patch 16.&lt;/p&gt;

&lt;p&gt;Also added RC.isVirtualWindowColumn() for checking for a VirtualColumnNode pointing to a WindowFunctionColumnNode.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2)&lt;br/&gt;
&amp;gt; It might be good to add an ASSERT here to make sure that the &apos;hopefully&apos; condition is satisified...&lt;/p&gt;

&lt;p&gt;The comment is not correct and should be removed. Fixed in patch 16 by rephrasing to reflect actual conditions.&lt;/p&gt;

&lt;p&gt;&amp;gt; 3)&lt;br/&gt;
&amp;gt; Many of the fields in WindowNode (and other new classes added by this patch) are &lt;br/&gt;
&amp;gt; &quot;public&quot;, ...&lt;/p&gt;

&lt;p&gt;Fixed in patch 16&lt;/p&gt;

&lt;p&gt;&amp;gt; 4)&lt;br/&gt;
&amp;gt; In WindowNode.java there is a field &quot;level&quot; which is initialized to -1 and then is set from&lt;br/&gt;
&amp;gt; SelectNode.java.  &lt;/p&gt;

&lt;p&gt;Patch 16 adds getters and setters, as well as comments on use of &apos;level&apos;.&lt;/p&gt;

&lt;p&gt;I&apos;m not too satisfied with the variable name &apos;level&apos; but it was the best &lt;br/&gt;
I could think of...&lt;/p&gt;

&lt;p&gt;&amp;gt; 5)&lt;br/&gt;
&amp;gt; In ColumnReference.java there are two different kinds of checks to see if the &lt;br/&gt;
&amp;gt; ColumnReference is pointing to a WindowColumnNode.  ...&lt;/p&gt;

&lt;p&gt;Yes, the two different approaches are intentional. See updated comment for CR.pointsToWindowFunction().&lt;br/&gt;
Fixed to use isWindowFunction() and isVirtualWindowFunction() in patch 16.&lt;/p&gt;

&lt;p&gt;&amp;gt; 6)&lt;br/&gt;
&amp;gt; See comment #1 above for an alternate (cleaner?) approach...&lt;/p&gt;

&lt;p&gt;Patch 16 now uses isWindowFunction() and new isVirtualWindowFunction() for &lt;br/&gt;
this if().&lt;/p&gt;

&lt;p&gt;&amp;gt; 7)&lt;br/&gt;
&amp;gt; The result set statistics node for WindowResultSet does not currently print out the &lt;br/&gt;
&amp;gt; name of the result set...(I don&apos;t think). &lt;/p&gt;

&lt;p&gt;I&apos;ll need to look into this.&lt;/p&gt;

&lt;p&gt;&amp;gt; 8)&lt;br/&gt;
&amp;gt; If I&apos;m understanding correctly, the execution-time logic for WindowResultSet operates &lt;br/&gt;
&amp;gt; in a fashion similar to ProjectRestrictResultSet.&lt;/p&gt;

&lt;p&gt;True, but more like the &apos;inverse&apos; of PRRS. The PRRS gets many columns &lt;br/&gt;
from its child resultset, and projects a few of these. The WRS projects &lt;br/&gt;
a few columns into the many destination columns, along with its &lt;br/&gt;
windowfunction result.&lt;/p&gt;

&lt;p&gt;&amp;gt;  That is, it iterates through all of its source&apos;s rows and, for each one, it applies a &lt;br/&gt;
&amp;gt; restriction.  If the row fails the restriction, then the iteration moves on to the next source&lt;br/&gt;
&amp;gt; row, and so on.  This agrees with the following comments, pulled from the &lt;br/&gt;
&amp;gt; getNextRowCore() method of WindowResultSet:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    /*&lt;br/&gt;
&amp;gt;     * Loop until we get a row from the source that qualifies, or there are&lt;br/&gt;
&amp;gt;     * no more rows to qualify. For each iteration fetch a row from the&lt;br/&gt;
&amp;gt;     * source, and evaluate against the restriction if any.&lt;br/&gt;
&amp;gt;     */&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;What should happen is that the outer selects(S1) PRN calls getNextRow() &lt;br/&gt;
that again calls into the child/subquerys(S2) PRN getNextRowCore(). That &lt;br/&gt;
again calls into the chain of WindowResultSets and PRNs, and eventually &lt;br/&gt;
ends up in a a BulkTableScanResultSet.getNextRowCore() or similar to &lt;br/&gt;
actually fetch &lt;b&gt;one&lt;/b&gt; row. This single row is then pulled up the &lt;br/&gt;
resultset chain, and the restriction is evaluated at the level it&apos;s been &lt;br/&gt;
pushed down to.&lt;/p&gt;

&lt;p&gt;In your example S1 evaluates the restriction. It&apos;s not &lt;br/&gt;
pushed from S1 into S2 for evaluation as it&apos;s a restriction on a window function &lt;br/&gt;
column of S1s subquery/child resultset.&lt;br/&gt;
S1 knows that column r is a row number column and that it &lt;br/&gt;
is ascending, so we should stop pulling rows from below once we reach &lt;br/&gt;
the condition.&lt;/p&gt;

&lt;p&gt;See reply to #9 too.&lt;/p&gt;

&lt;p&gt;&amp;gt; If this is correct, then I&apos;m not entirely sure we&apos;ll get the performance boost that one might perhaps expect from a query like:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     SELECT * FROM (&lt;br/&gt;
&amp;gt;       SELECT row_number() over () as r, t.* FROM T&lt;br/&gt;
&amp;gt;     ) AS tmp WHERE r &amp;lt;= 3;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; .... For the above query, the plan shows the following for the top-most &lt;br/&gt;
&amp;gt; ProjectRestrictResultSet:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   ******* Project-Restrict ResultSet (1):&lt;br/&gt;
&amp;gt;   Number of opens = 1&lt;br/&gt;
&amp;gt;   Rows seen = 1280&lt;br/&gt;
&amp;gt;   Rows filtered = 1277&lt;br/&gt;
&amp;gt;   restriction = true&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;This looks wrong given my above explaination.&lt;br/&gt;
It seems we don&apos;t take the fact that we know we have an ascending column &lt;br/&gt;
into consideration any more (we used to). I&apos;ll have to have another look at this.&lt;/p&gt;

&lt;p&gt;I haven&apos;t focused on the store layer at all. But based on how many rows &lt;br/&gt;
there are in your table the store layer may load either all or parts of &lt;br/&gt;
your data from disk into its cache. But they should not be pulled up the &lt;br/&gt;
resultset chain to either S2 or S1.&lt;/p&gt;

&lt;p&gt;&amp;gt; 9)&lt;br/&gt;
&amp;gt; For the query mentioned in comment #8 above, the query plan shows:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   ProjectRestrictResultSet (sees ALL rows, restricts down to 3)&lt;br/&gt;
&amp;gt;     -&amp;gt; ProjectRestrictResultSet (sees ALL rows)&lt;br/&gt;
&amp;gt;       -&amp;gt; WindowResultSet (sees ALL rows)&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I intuitively expected the restriction to appear at the level of the WindowResultSet, as &lt;br/&gt;
&amp;gt; opposed to appearing at the level of the top-most PRN.  The plan as shown above &lt;br/&gt;
&amp;gt; makes it look like the restriction is not being enforced by the Window ResultSet, but is &lt;br/&gt;
&amp;gt; instead being enforced by the ProjectRestrict. Is that correct?  Or is this just a case &lt;br/&gt;
&amp;gt; where the query plan fails to capture what is really happening with the &lt;br/&gt;
&amp;gt; WindowResultSet?  I&apos;m guessing the latter, but am not sure...&lt;/p&gt;

&lt;p&gt;This is (more or less) correct.&lt;/p&gt;

&lt;p&gt;As explained above, the top PRN must do the restriction, but it should &lt;br/&gt;
never &lt;b&gt;fetch&lt;/b&gt; all the rows.&lt;/p&gt;

&lt;p&gt;I briefly tried pushing the restriction down to the WindowResultSet some time ago, but the expression generation/execution code does not &lt;br/&gt;
currently want to work with the window function columns.&lt;br/&gt;
I did not pursue this further, but agree it should be looked at for a &lt;br/&gt;
future optimization.&lt;/p&gt;

&lt;p&gt;However, the code needed to do restriction at the WindowResultSet level &lt;br/&gt;
have been kept in its getNextRowCore(). This is the reason for the loop &lt;br/&gt;
and comment mentioned in reply to #8.&lt;/p&gt;</comment>
                            <comment id="12572498" author="thomanie" created="Tue, 26 Feb 2008 14:36:52 +0000"  >&lt;p&gt;The resultset number problem is a little strange. The following query runs fine:&lt;br/&gt;
   select * from (select row_number() over (), t.a from t) as tr;&lt;/p&gt;

&lt;p&gt;but flip the column order, and it fails:&lt;br/&gt;
   select * from (select t.a, row_number() over () from t) as tr;&lt;/p&gt;

&lt;p&gt;With both queries we run fine until we eventually end up in ResultColumnList.generateCore() in a call from ProjectRestrictNode.generateMinion() for the PRN that once was the FromSubquery (mentioned earlier). At this stage the RCL for &lt;b&gt;both&lt;/b&gt; queries look like:&lt;/p&gt;

&lt;p&gt;RC (resultset# = 3)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  .expression=&lt;br/&gt;
VCN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  .sourceColumn =&lt;br/&gt;
RC (resultset# = -1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;CR &lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;...  (into base table)&lt;/p&gt;

&lt;p&gt;However &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in the working query, the correlate flag is false for the base table columns&lt;/li&gt;
	&lt;li&gt;in the failing query, the correlate flag is true for the base table columns&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This was the only obvious difference I could see, and the correlate flag is what causes the logic in RCL.generateCore() to stray off on its &quot;wild path&quot;. &lt;br/&gt;
Looks like I need to investigate why the correlation flag differs between the two.&lt;/p&gt;</comment>
                            <comment id="12572531" author="thomanie" created="Tue, 26 Feb 2008 16:04:46 +0000"  >&lt;p&gt;The culprit turned out to be ResultColumnList.allExpressionsAreColumns().&lt;/p&gt;

&lt;p&gt;After adding an explict check for any window functions here, we avoid massing up the correlation flag and every thing seems to be working as expected. All 20-ish queries in the test7 patch returns the expected rows.&lt;/p&gt;

&lt;p&gt;I should probably add that I want to clean up a couple of issues with patch 17 before I check &apos;patch available&apos;, but I wanted to post the working code so you can play with it, and maybe give some additional feedback.&lt;/p&gt;</comment>
                            <comment id="12572556" author="army" created="Tue, 26 Feb 2008 16:49:08 +0000"  >&lt;p&gt;I have not had a chance to look at patch 17 yet, but I just had some follow-up feedback based on your recent comments:&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m not too satisfied with the variable name &apos;level&apos; but it was the best I could think of...&lt;/p&gt;

&lt;p&gt;I think even something naive like &quot;windowFunctionLevel&quot; would be fine for now.  I&apos;d rather avoid the generic name &quot;level&quot; since there is already a &quot;level&quot; field that exists in FromTable.java, of which WindowNode is an indirect subclass (so if you&apos;re debugging, two different &quot;level&quot; fields show up).&lt;/p&gt;

&lt;p&gt;&amp;gt; That again calls into the chain of WindowResultSets and PRNs, and eventually&lt;br/&gt;
&amp;gt; ends up in a a BulkTableScanResultSet.getNextRowCore() or similar to&lt;br/&gt;
&amp;gt; actually fetch &lt;b&gt;one&lt;/b&gt; row.&lt;/p&gt;

&lt;p&gt;If the intent is to fetch exactly &lt;b&gt;one&lt;/b&gt; row, then would it be beneficial  to disable bulk fetching on the base table?  Otherwise, WindowResultSet may only want to fetch a single a row but, due to bulk fetching, we could end up with 16 (or whatever the bulk size is).  Not a huge problem by any means, but a potential point for improvement if you haven&apos;t already dealt with it (maybe you have and I just missed it).&lt;/p&gt;

&lt;p&gt;&amp;gt; It seems we don&apos;t take the fact that we know we have an ascending column&lt;br/&gt;
&amp;gt; into consideration any more (we used to). I&apos;ll have to have another look at this.&lt;/p&gt;

&lt;p&gt;Is this something that has been fixed with patch 17?  Or is it still work in progress? (I haven&apos;t tried it out yet).&lt;/p&gt;</comment>
                            <comment id="12572580" author="army" created="Tue, 26 Feb 2008 18:01:08 +0000"  >&lt;p&gt;&amp;gt; Is this something that has been fixed with patch 17? Or is it still work in progress?&lt;/p&gt;

&lt;p&gt;Okay, I ran the same queries with patch 17 and can see for myself that this particular change has not yet been made.&lt;/p&gt;

&lt;p&gt;On patch 17 itself I have a few more comments:&lt;/p&gt;

&lt;p&gt;1) The patch adds the following to ResultColumnList:&lt;/p&gt;

&lt;p&gt;   /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;To avoid messing up the correlation flags we should determine if any&lt;/li&gt;
	&lt;li&gt;of this RCLs columns are either:&lt;/li&gt;
	&lt;li&gt;- A windowfunction column&lt;/li&gt;
	&lt;li&gt;- A virtual column node pointing to window function column&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think it would be nice to expand a bit on &lt;b&gt;why&lt;/b&gt; this code is necessary. The comments indicate that without the code we could &quot;mess up the correlation flags&quot;, but it doesn&apos;t say how. At a minimum it would be good to have a pointer to the correlation code that is affected by this.&lt;/p&gt;

&lt;p&gt;2) Code in WindowNode.generate(...) ends with a check and a comment about positioned updates and deletes. Are there test cases to ensure all is okay with such operations?&lt;/p&gt;

&lt;p&gt;3) On more a general level, and especially with respect to comment # 5 in my Feb 25th post, it seems like the changes for this issue rely heavily on the expected appearance of a WindowFunctionColumnNode in the query tree. Namely, the fact that&lt;/p&gt;

&lt;p&gt;  ResultColumn -&amp;gt; WindowFunctionColumn&lt;/p&gt;

&lt;p&gt;is expected in some places and&lt;/p&gt;

&lt;p&gt;  ResultColumn -&amp;gt; VirtualColumnNode -&amp;gt; WindowFunctionColumn&lt;/p&gt;

&lt;p&gt;is expected in others makes me nervous. My experience with optimization/compilation is that VirtualColumnNodes, ResultColumns, and ColumnReferences are often stacked on top of each other in rather gratuitous fashion. Code which accesses these types of nodes is usually (or at least, often) written with the expectation that it could be dealing with VCN, ResultColumn, and/or ColRef chains of arbitrary length, and so must walk the chain when retrieving certain information.&lt;/p&gt;

&lt;p&gt;But the changes for ROW_NUMBER() take a different approach, one in which the assumption is that we will always have either 1) a ResultColumn whose child is a WindowFunctionColumn, or 2) a ResultColumn whose child is a VirtualColumnNode whose child is a WindowFunctionColumn. But how confident are we that this will &lt;em&gt;always&lt;/em&gt; be the case?&lt;/p&gt;

&lt;p&gt;With this thought in my head I can&apos;t help but feel that queries which involve ROW_NUMBER() and which are larger or more complex are at a high risk for column &quot;mis-information&quot;, which could cause issues. I applied patch 17 and tried writing some more complicated queries that use ROW_NUMBER(), and it wasn&apos;t long before I hit the ASSERT failure that we&apos;ve seen before. Esp:&lt;/p&gt;

&lt;p&gt;&amp;#8211; OK&lt;br/&gt;
select row_number() over () from t1 union all select row_number() over () from t1;&lt;br/&gt;
select 2 * r from (select row_number() over () from t1) x(r);&lt;/p&gt;

&lt;p&gt;&amp;#8211; Fail.&lt;br/&gt;
select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from (select row_number() over() from t1) x;&lt;br/&gt;
select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from (select row_number() over () as r from t1) as t(r) where r &amp;lt;=3;&lt;/p&gt;

&lt;p&gt;&amp;#8211; OK&lt;br/&gt;
select c3, c1, c2 from&lt;br/&gt;
  (select i, j, row_number() over() as r from t1) x1 (c1, c2, r1),&lt;br/&gt;
  (select row_number() over() as r, j, i from t1) x2 (r2, c3, c4);&lt;/p&gt;

&lt;p&gt;&amp;#8211; OK&lt;br/&gt;
select c3, c1, c2 from&lt;br/&gt;
  (select i, j, row_number() over() as r from t1) x1 (c1, c2, r1),&lt;br/&gt;
  (select row_number() over() as r, j, i from t1) x2 (r2, c3, c4),&lt;br/&gt;
  t1;&lt;/p&gt;

&lt;p&gt;&amp;#8211; OK&lt;br/&gt;
select c3, c1, c2 from&lt;br/&gt;
  (select i, j, row_number() over() as r from t1) x1 (c1, c2, r1),&lt;br/&gt;
  (select row_number() over() as r, j, i from t1) x2 (r2, c3, c4),&lt;br/&gt;
  t1&lt;br/&gt;
 where x1.r1 = 2 * x2.r2;&lt;/p&gt;

&lt;p&gt;&amp;#8211; Fails&lt;br/&gt;
select c3, c1, c2 from&lt;br/&gt;
  (select i, j, row_number() over() as r from t1) x1 (c1, c2, r1),&lt;br/&gt;
  (select row_number() over() as r, j, i from t1) x2 (r2, c3, c4),&lt;br/&gt;
  t1&lt;br/&gt;
 where x2.c4 = t1.i;&lt;/p&gt;

&lt;p&gt;&amp;#8211; Fails&lt;br/&gt;
select c3, c1, c2 from&lt;br/&gt;
  (select i, j, row_number() over() as r from t1) x1 (c1, c2, r1),&lt;br/&gt;
  (select row_number() over() as r, j, i from t1) x2 (r2, c3, c4),&lt;br/&gt;
  t1&lt;br/&gt;
 where x1.r1 = 2 * x2.r2 and x2.c4 = t1.i;&lt;/p&gt;

&lt;p&gt;Perhaps these failures have nothing to do with my &quot;fear&quot; outlined above--in which case I apologize of the misdirection. But in any event, there are still some failures that I see with patch 17. I&apos;m not sure to what extent these need to be resolved before code can be committed, as they (appear to) only occur when ROW_NUMBER() is in use and thus shouldn&apos;t affect existing apps. But I&apos;m not the one to say for sure one way or the other...&lt;/p&gt;</comment>
                            <comment id="12572781" author="djd" created="Wed, 27 Feb 2008 04:25:51 +0000"  >&lt;p&gt;AB&amp;gt; ... with patch 17. I&apos;m not sure to what extent these need to be resolved before code can be committed, as they (appear to) only occur when ROW_NUMBER() is in use and thus shouldn&apos;t affect existing apps. But I&apos;m not the one to say for sure one way or the other...&lt;/p&gt;

&lt;p&gt;On the contrary, you &lt;b&gt;are&lt;/b&gt; one of the ones to say if the patch should be committed. There is no one authority, just a set of committers. If any committer has confidence in the patch then she can commit it (and any other committer can veto it with a valid technical reason if she thinks it should not be committed).&lt;/p&gt;

&lt;p&gt;With a patch reaching its 17th iteration I think one has to consider if it should be committed before too much of the effort is spent keeping the patch up to date with a moving codeline.&lt;/p&gt;

&lt;p&gt;Is it better to keep trying to get a perfect patch (noting that the Derby project has ~450 open bugs so the base code is not perfect)?&lt;/p&gt;

&lt;p&gt;Or is it better to get the code committed in some basic working state (has tests, doesn&apos;t cause existing tests to fail) so that others can try it out &lt;b&gt;and&lt;/b&gt; ongoing changes don&apos;t cause regressions in the functionality.&lt;/p&gt;

&lt;p&gt;And of course it&apos;s all done through svn, so reverting any patch is always an option.&lt;/p&gt;</comment>
                            <comment id="12572946" author="thomanie" created="Wed, 27 Feb 2008 15:46:48 +0000"  >&lt;p&gt;Attaching patch 18 and test8.&lt;/p&gt;

&lt;p&gt;To Armys comments:&lt;br/&gt;
#1 - Patch 18 fixes the comment in allExpressionsAreColumns()&lt;br/&gt;
#2 - No, there are no tests that check this. This is a relic from cloning IndexToBaseRowNode. It should probably be removed?&lt;br/&gt;
#3 - Patch 18 relaxes the expectancy of finding RCL-&amp;gt;WindowFunction, as well as generalizing the conditions throughout. This fixes the failing count() queries.&lt;/p&gt;

&lt;p&gt;The test8 patch add all additional queries pointed to by army to the OLAPTest. All but the two last queries posted by Army pass, but I haven&apos;t had a chance to look at why yet. It is most likely connected to comment #3 though.&lt;/p&gt;

&lt;p&gt;Army&amp;gt; My experience with optimization/compilation is that VirtualColumnNodes, ResultColumns, and &lt;br/&gt;
Army&amp;gt; ColumnReferences are often stacked on top of each other in rather gratuitous fashion.&lt;/p&gt;

&lt;p&gt;That&apos;s something I&apos;ve obviously not taken well enough into consideration. Do you think that the approach I&apos;ve taken is fundamentally flawed, or is it just being too restrictive?&lt;/p&gt;</comment>
                            <comment id="12573011" author="army" created="Wed, 27 Feb 2008 18:26:34 +0000"  >&lt;p&gt;&amp;gt; Do you think that the approach I&apos;ve taken is fundamentally flawed, or is it just being too restrictive?&lt;/p&gt;

&lt;p&gt;No, I do not think it&apos;s flawed.  And I can&apos;t say with any certainty that it&apos;s too restrictive, either, as I haven&apos;t actually found any cases which prove that.  Maybe the failing queries I posted above fall into that category, maybe not--I haven&apos;t done any detailed tracing.  I thought I&apos;d mention it as something which made me uneasy, but it could very well be fine as it is.&lt;/p&gt;

&lt;p&gt;&amp;gt; #3 - Patch 18 relaxes the expectancy of finding RCL-&amp;gt;WindowFunction, as well as generalizing&lt;br/&gt;
&amp;gt; the conditions throughout. This fixes the failing count() queries.&lt;/p&gt;

&lt;p&gt;I like the additional methods to distinguish between how/where to look for the WindowFunctionColumnNode. Now the trick is to figure out which methods to call where &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; My suggestion is that whenever you call any of these methods, try to determine if a comment indicating why you chose the method you did would be useful to the reader.  And that&apos;s especially true if you find yourself switching from one method to another at any point...&lt;/p&gt;

&lt;p&gt;Side note: looks like the new &quot;isReferenceToOrWindowFunction()&quot; for patch 18 is never actually called anywhere. Was that intentional?&lt;/p&gt;</comment>
                            <comment id="12573018" author="thomanie" created="Wed, 27 Feb 2008 18:44:16 +0000"  >&lt;p&gt;Thanks Army. Good to hear it&apos;s not all wrong &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; Side note: looks like the new &quot;isReferenceToOrWindowFunction()&quot; for patch 18 is never actually called anywhere. Was that intentional?&lt;br/&gt;
Yes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12573083" author="thomanie" created="Wed, 27 Feb 2008 22:10:06 +0000"  >&lt;p&gt;I&apos;ve started looking at why the last two queries fail, and they both run down a code path I haven&apos;t been down before - involving a couple of JoinNodes and some &quot;trickery&quot; with the RCL. The predicate t1.a is pulled into the RCL, like we do for PRNs under certain conditions with a where predicate, and this somehow cause problems during code generation. I&apos;ll investigate more tomorrow, but as of now it doesn&apos;t look like its yet another RCL-&amp;gt;WindowFunction assumption gone bad. It&apos;s probably related though - if I exchange the WindowFunction for a constant it works fine.&lt;/p&gt;</comment>
                            <comment id="12573457" author="thomanie" created="Thu, 28 Feb 2008 21:14:21 +0000"  >&lt;p&gt;It seems from a debugging session that the two last join queries Army posted both fail due to failure to classify some of the PRNs as noops.&lt;/p&gt;

&lt;p&gt;If a PRN is classified a noop, the RCL nodes are maked as redundant, and during code generation we walk further down the RC-tree to lay out the code at a lower level. If not marked as redundant we pull the value from the current level result set. If I understand this correctly the last two queries end up trying to get the values from the current level when it should really look even further down. Manually changing the isRedundant flag in the debugger actually produces what seems to be the correct results.&lt;/p&gt;</comment>
                            <comment id="12573520" author="army" created="Thu, 28 Feb 2008 23:42:15 +0000"  >&lt;p&gt;&amp;gt; the two last join queries both fail due to failure to classify some of the PRNs as noops.&lt;/p&gt;

&lt;p&gt;The code to check for &quot;no-op&quot; ProjectRestrictNodes depends, among other things, on object equality between two ResultColumn nodes.  See ResultColumnList.nopProjection().  I think the manipulation that is done in SelectNode.genProjectRestrict() re-arranges the tree and creates new nodes such that the object equality fails.  And even if the object equality wasn&apos;t an issue, I think re-arragement of the tree would cause the method to return false anyway.  Which corresponds with your findings on &quot;redundant&quot; result column lists.&lt;/p&gt;

&lt;p&gt;I did some tracing for the queries that are still failing with patch 18.  The failure occurs during code generation, when we try to generate the predicate &quot;x2.c4 = t1.i&quot; as a qualifier on table T1.  When it comes time to generate the left operand, which points to a table that is BENEATH the WindowNode that was generated for the ROW_NUMBER(), we can&apos;t find the target result set number for the operand &quot;X2.C4&quot;.  In looking at the predicate contents at the point of failure, I could see that the target result set number was buried down inside of a ResultColumn-to-VirtualColumn chain rooted at X2.C4.  Again, this matches your findings regarding &quot;redundant&quot; result columns.&lt;/p&gt;

&lt;p&gt;I then replaced ROW_NUMBER() with a simple expression (&quot;i+j&quot;) and stopped at the same point; in this case the target result set number is readily available (i.e. it&apos;s not buried) and the query passes.&lt;/p&gt;

&lt;p&gt;On a whim, I then removed the following code from SelectNode:&lt;/p&gt;

&lt;p&gt;  Code fragment &quot;A&quot;:&lt;/p&gt;

&lt;p&gt;   /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The this.resultColumns object is shared with any PRNs above this&lt;/li&gt;
	&lt;li&gt;SelectNode in case this is a subquery. The following RCL&lt;/li&gt;
	&lt;li&gt;modifications cause problems in the column mapping of the upper&lt;/li&gt;
	&lt;li&gt;PRN unless we start off by making a copy for ourselves.&lt;br/&gt;
    */&lt;br/&gt;
    setResultColumns(resultColumns.copyListAndObjects());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;When I took that out, the target result set number became readily available for the join queries and the queries executed without error, which was good.  Of course, the queries returned the wrong results, and several other ROW_NUMBER() queries which used to work started failing again.  So I tried to figure out why the code was added in the first place, as the comments didn&apos;t quite make it clear for me.&lt;/p&gt;

&lt;p&gt;As far as I can tell, the scenario that prompted the addition of the above code is something like:&lt;/p&gt;

&lt;p&gt;  select * from&lt;br/&gt;
    (select row_number() over(), &apos;HMM&apos; from t1) x(a,c)&lt;br/&gt;
  where a &amp;gt; 2&lt;/p&gt;

&lt;p&gt;which leads to a (simplified) tree that looks like:&lt;/p&gt;

&lt;p&gt;  ... PRN0(a,c) -&amp;gt; SELECT(row_number(), &apos;HMM&apos;) -&amp;gt; ...&lt;/p&gt;

&lt;p&gt;In this tree, PRN0&apos;s RCL is a different object than SELECT&apos;s RCL, and the columns in PRN0&apos;s RCL have VirtualColumnNodes that do not appear in SELECT&apos;s RCL. But underneath it all, both RCLs ultimately point to the same underlying ResultColumn objects.  Thus any changes we make to the underlying ResultColumns in SELECT&apos;s RCL will be &quot;shared&quot; by PRN0, meaning that the ResultColumns beneath PRN0&apos;s RCL will see the changes, as well.&lt;/p&gt;

&lt;p&gt;From what I can gather, the changes that we are talking about here deal with virtual column ids.  During SelectNode.genProjectRestrict() we remove the WindowFunctionColumns from SELECT&apos;s ResultColumnList and then adjust the virtual column id&apos;s accordingly.  So we get:&lt;/p&gt;

&lt;p&gt;  ... PRN0(a,c) -&amp;gt; SELECT(&apos;HMM&apos;) -&amp;gt; ...&lt;/p&gt;

&lt;p&gt;In the absence of code fragment &quot;A&quot;, the result column for &quot;HMM&quot; now has a virtual column id of &quot;1&quot; (instead of &quot;2&quot;).  The fact that we changed the virtual column id from &quot;2&quot; to &quot;1&quot; means that the result column beneath &quot;C&quot; in PRN0&apos;s ResultColumnList &lt;b&gt;also&lt;/b&gt; now has a virtual column id of &quot;1&quot;.  That indicates that &quot;C&quot; should pull its value from the 1st column in its child&apos;s RCL. This is where things start to go wrong...&lt;/p&gt;

&lt;p&gt;When we finish with SelectNode.genProjectRestrict(), our simplified tree looks like:&lt;/p&gt;

&lt;p&gt;  PRN0(a,c)&lt;br/&gt;
    -&amp;gt; PRNDUMMY(row_number(), &apos;HMM&apos;)&lt;br/&gt;
      -&amp;gt; WindowNode(row_number(), &apos;HMM&apos;)&lt;br/&gt;
        -&amp;gt; PRN1(&apos;HMM&apos;) // this now has virtual column id of &quot;1&quot;&lt;br/&gt;
          -&amp;gt; ...&lt;/p&gt;

&lt;p&gt;Note that PRNDUMMY will be a &quot;no-op&quot; project restrict and thus will not actually be generated.  So PRN0&apos;s child will end up being WindowNode, which has TWO columns.  But PRN0.C still has a virtual column id of &quot;1&quot;, meaning that it should pull its value from the first column of PRN0&apos;s child.  PRN0&apos;s child is WindowNode, and the first column in WindowNode is row_number()--not &apos;HMM&apos;.  So &quot;C&quot; is now pointing to the wrong place.&lt;/p&gt;

&lt;p&gt;At code generation time, when we try to generate the projection columns for PRN0, we&apos;ll take a look at it&apos;s virtual column ids and generate the project &quot;mapping&quot; array from those.  In ProjectRestrictNode we find the following within &quot;generateMinion()&quot;:&lt;/p&gt;

&lt;p&gt;        // Map the result columns to the source columns&lt;br/&gt;
        int[] mapArray = resultColumns.mapSourceColumns();&lt;/p&gt;

&lt;p&gt;The method &quot;mapSourceColumns()&quot; simply walks through the RCL and plugs in the virtual column ids for each of the columns.  For PRN0, since &quot;A&quot; and &quot;C&quot; both have a virtual column id of &quot;1&quot;, we&apos;ll get back an array whose contents are &quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;1, 1&amp;#93;&lt;/span&gt;&quot;.&lt;/p&gt;

&lt;p&gt;That array is then passed to the execution-time ProjectRestrictResultSet and is used for extracting columns from the underlying result set, which will be a WindowResultSet in this case.  So we&apos;ll get rows from WindowResultSet that have the values (1, &apos;HMM&apos;), (2, &apos;HMM&apos;), etc. That part is fine.  But then the ProjectRestrictResultSet for PRN0 will use the &quot;mapping&quot; array to pull columns out of each row from WindowResultSet.  Since &lt;em&gt;both&lt;/em&gt; elements in the array are &quot;1&quot;, we extract out the 1st column and put it into &lt;em&gt;both&lt;/em&gt; places.  So the final rows will end up as (1, 1), (2, 2), etc. which is wrong.&lt;/p&gt;

&lt;p&gt;All of that said, code fragment &quot;A&quot; resolved this problem by cloning SELECT&apos;s result column list and making all modifications on the clone.  So when the virtual column id for &quot;HMM&quot; changes from &quot;2&quot; to &quot;1&quot;, PRN0 doesn&apos;t see the change and therefore code generation and execution run fine.&lt;/p&gt;

&lt;p&gt;But as I mentioned at the start of this comment, the cloning leads to other problems--such as the queries that are still failing with patch 18.  To make a long story short, I tried various &quot;tweaks&quot; (or perhaps &quot;hacks&quot; is a better word) to get the virtual column ids for PRN0 to remain correct without having to clone SELECT&apos;s columns. In the end I couldn&apos;t find a clean way to do so.&lt;/p&gt;

&lt;p&gt;But I did find that if I made the following changes, things started working:&lt;/p&gt;

&lt;p&gt;1) REMOVE code fragment &quot;A&quot; from SelectNode, as mentioned above.&lt;br/&gt;
2) REMOVE the following from SelectNode.java:&lt;/p&gt;

&lt;p&gt;    for (int index = 0; index &amp;lt; size; index++) {&lt;br/&gt;
        ResultColumn rc = (ResultColumn) originalRCL.elementAt(index);&lt;br/&gt;
        /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;NOTE: We only care about window function columns that appear&lt;/li&gt;
	&lt;li&gt;here, and not about references into subquerys or similar.&lt;br/&gt;
         */&lt;br/&gt;
         if (!rc.expressionIsWindowFunction()) 
{
             windowFunctionRCL.setElementAt(
                prnRSN.getResultColumns().elementAt(srcindex), index);
             srcindex++;
         }
&lt;p&gt;    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3) REMOVE the following from ResultColumnList:&lt;/p&gt;

&lt;p&gt;    /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;All expressions are not columns if this RCL contains&lt;/li&gt;
	&lt;li&gt;- A windowfunction column&lt;/li&gt;
	&lt;li&gt;- A virtual column node pointing to window function column&lt;/li&gt;
	&lt;li&gt;This check is done as a separate loop to avoid incorrectly start&lt;/li&gt;
	&lt;li&gt;marking any/parts of the base table columns as correlated columns.&lt;/li&gt;
	&lt;li&gt;Marking a VCN pointing into a WindowResultSet as correlated cause&lt;/li&gt;
	&lt;li&gt;resultset reference errors during code generation.&lt;br/&gt;
     */&lt;br/&gt;
    for (int index = 0; index &amp;lt; size; index++) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {       ResultColumn rc = (ResultColumn) elementAt(index);       if (rc.isWindowFunction()){
           return false;
        }    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;4) Change ProjectRestrictNode.java as follows:&lt;/p&gt;

&lt;p&gt; // Map the result columns to the source columns&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int[] mapArray = resultColumns.mapSourceColumns();&lt;br/&gt;
+ int[] mapArray =&lt;br/&gt;
    resultColumns.containsWindowFunctionResultColumn()&lt;br/&gt;
        ? childResult.getResultColumns().mapSourceColumns()&lt;br/&gt;
        : resultColumns.mapSourceColumns();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I &lt;b&gt;think&lt;/b&gt; this change has the effect of saying &quot;ignore PRN0&apos;s RCL if it points to a WindowNode, because PRN0&apos;s RCL may not be correct--esp. it may have incorrect virtual column ids&quot;.  Thus instead of using &quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;1,1&amp;#93;&lt;/span&gt;&quot; for the projection mapping, PRN0 will create its mapping from PRNDUMMY, which has correct virtual column ids of &quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;1,2&amp;#93;&lt;/span&gt;&quot;, so everything ends up okay.  At the same time, we did &lt;b&gt;not&lt;/b&gt; have to clone the SELECT&apos;s ResultColumnList objects, and that appears to make the join queries run correctly.&lt;/p&gt;

&lt;p&gt;With these changes, OLAP tests runs without error and the two join queries I posted previously also execute without error.  And from the brief looking that I did it seems like the results are correct, though it wouldn&apos;t hurt to double-check that.&lt;/p&gt;

&lt;p&gt;All in all, though, I&apos;d have to say this seems pretty hackish, so it may not be a proper solution.  But it does cause all of the queries posted so far to pass, and it simplifies the changes by removing the chunks of code mentioned above.  So I figured I&apos;d post my findings anyways.  I&apos;ll leave it up to you to determine if any of it is useful or worth pursing further...&lt;/p&gt;</comment>
                            <comment id="12573639" author="thomanie" created="Fri, 29 Feb 2008 08:56:41 +0000"  >&lt;p&gt;I obviously have a lot to learn when it comes to writing my explainations in jira... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Your initial analysis is identical to what I&apos;ve found, and explained in an exceptional manner.&lt;/p&gt;

&lt;p&gt;&amp;gt; To make a long story short, I tried various &quot;tweaks&quot; (or perhaps &quot;hacks&quot; is a better word) to get the virtual column ids for PRN0 to remain correct without &amp;gt; having to clone SELECT&apos;s columns. In the end I couldn&apos;t find a clean way to do so.&lt;/p&gt;

&lt;p&gt;The cloning of the RCL in PRN.genProjectRestrictNode (fragment A) was the only way out I could find, and that again resulted in the changes 2) and 3).&lt;/p&gt;

&lt;p&gt;I really like the fact that your &quot;proposal&quot; doesn&apos;t need cloning the RCL (fragment A) - makes it all a lot cleaner.&lt;/p&gt;

&lt;p&gt;Even though your snippet 4) feels like a hack, it might be able to pull this logic into PRN.modifyAccessPath()?&lt;br/&gt;
The simplified tree looks like:&lt;br/&gt;
    SELECT() - PRN () - SELECT() &lt;br/&gt;
We then call into the PRNs modifyAccessPath(), that again calls into the lower select modifyAccessPath() where we pull the WindowNodes up and modify the RCL. Once this is done, we could check for the presence of a PRN-&amp;gt;WindowNode as the top of the intial PRNs childResult, and pull the modified RCL up into the initial PRN? By doing so I imagine we may be able to eliminate any other problems caused by potential later/additional optimizer modifications to the querytree. I&apos;ll give it a try at least, and see what happens.&lt;/p&gt;</comment>
                            <comment id="12573683" author="thomanie" created="Fri, 29 Feb 2008 11:26:52 +0000"  >&lt;p&gt;The hack that Army did really solves the fact that VCNs are wrong in the initial PRN when there are window function columns in the PRNs child. I kept Armys 1)&lt;del&gt;3) changes, but removed the hack and fixed it by regenerating the VCNs in PRN.modifyAccessPath(). This is done after modifying the childResult &lt;b&gt;if&lt;/b&gt; that modification ends with the PRNs child being PRN&lt;/del&gt;&amp;gt;WN (meaning there are window functions in the childs RCL). This works fine, and I expect it to actually solve other possible problems with later/further optimization too.&lt;/p&gt;

&lt;p&gt;Attaching patch 19 and test9:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fix as described above&lt;/li&gt;
	&lt;li&gt;some cleanup of unused methods and whitespace diffs&lt;/li&gt;
	&lt;li&gt;test9 includes the last two join queries.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;OLAPTest with test9 applied pass.&lt;br/&gt;
I&apos;ll run suites.All and derbyAll to make sure nothing else is broken.&lt;/p&gt;</comment>
                            <comment id="12573708" author="thomanie" created="Fri, 29 Feb 2008 12:32:39 +0000"  >&lt;p&gt;Both suites.All and derbyAll passed with patch 19&lt;/p&gt;</comment>
                            <comment id="12573867" author="army" created="Fri, 29 Feb 2008 18:04:06 +0000"  >&lt;p&gt;Thanks for patch 19, Thomas.  I think your approach to handling the virtual column nodes is a good one (certainly better than the alternatives seen thus far).  In the interest of getting something into the codeline for others to play with-&lt;del&gt;and to simplify future patches&lt;/del&gt;-per Dan&apos;s comment a few days back, I&apos;ll try to commit patch 19 sometime today.&lt;/p&gt;

&lt;p&gt;Once that is committed, perhaps you can post one or more follow-up patches to address the following un-related comments, which I noticed while looking into the VCN issue.  Of these # 3 is probably the most important one...&lt;/p&gt;

&lt;p&gt;1) Instead of using &quot;row_number()&quot; for the default name of a ROW_NUMBER() column, I think it&apos;d be better to use a normal generated column name, as is done for all other un-named expressions in Derby (I believe?).  So something like:&lt;/p&gt;

&lt;p&gt;  select i, j, i+j, row_number() over() from t1&lt;/p&gt;

&lt;p&gt;should return four columns, &quot;I&quot;, &quot;J&quot;, &quot;3&quot;, and &quot;4&quot;, where the last two are generic generated names used for unnamed expressions.  With patch 19 such a query currently returns &quot;I&quot;, &quot;J&quot;, &quot;3&quot;, &quot;row_number()&quot;, which deviates from the existing pattern.&lt;/p&gt;

&lt;p&gt;2) Regarding the following logic in PredicateList.pushExpressionsIntoSelect():&lt;/p&gt;

&lt;p&gt;    ColumnReference ref = (ColumnReference)e.nextElement();&lt;br/&gt;
    if (!ref.pointsToColumnReference() &amp;amp;&amp;amp;&lt;br/&gt;
        !ref.pointsToWindowFunction())&lt;/p&gt;
    {
         state = false;
         break;
    }

&lt;p&gt;I think it says &quot;if the column reference points to something that is neither a) another column reference NOR b) a window function, then do &lt;b&gt;not&lt;/b&gt; push it down.&quot;  So if the column reference points to a window function, we we could still potentially push it down.  Is that what we want?  For the record, I commented the call to &quot;pointsToWindowFunction()&quot; out completely and all of the queries still ran the same.  So is this check still necessary?&lt;/p&gt;

&lt;p&gt;3) The following query returns one row, regardless of how many rows there are in T1:&lt;/p&gt;

&lt;p&gt;  select distinct row_number() over(), &apos;HMM&apos; from t1&lt;/p&gt;

&lt;p&gt;It appears that we will evaluate the entire SELECT result set, then apply the DISTINCT, and finally, assign the row numbers.  So if there are five rows in T1, we&apos;ll get five rows having a single &quot;HMM&quot; column, then we&apos;ll apply the distinct to get a single &quot;HMM&quot; row, and that row will have row number &quot;1&quot;.  But is that the correct behavior?  Or is the row_number() supposed to be included in the &quot;DISTINCT&quot; qualification, in which case the query would return 5 rows because each row has a different row number and thus each is distinct from the others?&lt;/p&gt;

&lt;p&gt;Just to see what would happen I ran the above query on DB2 v8 and it returned one row for each row in T1.  I took a look at the syntax rules for &amp;lt;window function&amp;gt; in SQL 2003 spec section 6.10 but could not, in my inexperience with reading specs, determine one way or the other.  That said, though, I think functions in a ResultColumnList are typically evaluated once per row, &lt;b&gt;prior&lt;/b&gt; to the DISTINCT being applied, so I would guess ROW_NUMBER() should do the same?&lt;/p&gt;

&lt;p&gt;4) Might be good to add some test cases for GROUP BY and HAVING clauses in the presence of ROW_NUMBER().  I tried a few quick ones and they seem to be working fine, but it wouldn&apos;t hurt to add some tests for posterity.  These are the ones I tried, but use your imagination &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  select r from (select i, row_number() over() as r, j from t1) x group by r;&lt;br/&gt;
  select * from (select i, row_number() over() as r, j from t1) x group by i, j, r;&lt;br/&gt;
  select * from (select i, row_number() over() as r, j from t1) x group by j, r, i;&lt;/p&gt;

&lt;p&gt;  select * from&lt;br/&gt;
      (select i, row_number() over() as r, j from t1) x&lt;br/&gt;
    group by j, r, i&lt;br/&gt;
    having r &amp;gt; 2;&lt;/p&gt;

&lt;p&gt;  select * from&lt;br/&gt;
      (select i, row_number() over() as r, j from t1) x&lt;br/&gt;
    group by j, r, i&lt;br/&gt;
    having r &amp;gt; 2 and i &amp;gt;=3&lt;br/&gt;
    order by i desc;&lt;/p&gt;

&lt;p&gt;  select * from&lt;br/&gt;
      (select i, row_number() over() as r, j from t1) x&lt;br/&gt;
    group by j, r, i&lt;br/&gt;
    having r &amp;gt; 2 and i &amp;gt;=3&lt;br/&gt;
    order by r desc;&lt;/p&gt;

&lt;p&gt;  select * from&lt;br/&gt;
      (select i, row_number() over() as r, j from t1) x&lt;br/&gt;
    group by j, r, i&lt;br/&gt;
    having r &amp;gt; 2 and i &amp;gt;=3&lt;br/&gt;
    order by i asc, r desc;&lt;/p&gt;

&lt;p&gt;And yes I realize that grouping by a ROW_NUMBER() is kind of silly since row numbers are unique across rows--but it&apos;s good make sure the behavior is correct &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5) SQL spec indicates that window functions like ROW_NUMBER() can be used in an ORDER BY clause, but that is not yet implemented (right?).  Do you think it would be worth it to add a statement saying as much to the documentation?&lt;/p&gt;</comment>
                            <comment id="12573916" author="thomanie" created="Fri, 29 Feb 2008 19:31:45 +0000"  >&lt;p&gt;Thanks for your continued help Army. I can indeed add some smaller additional smaller patches to fix these issues if patch 19 goes in the trunk.&lt;/p&gt;

&lt;p&gt;Ad 1) Agree. This should follow the existing pattern.&lt;/p&gt;

&lt;p&gt;Ad 2) ...obviously not needed anymore.&lt;/p&gt;

&lt;p&gt;Ad 3) &lt;br/&gt;
In SQL2003 DISTINCT handling is defined in 10.9 &amp;lt;aggregate function&amp;gt;. Its section &quot;General Rules&quot;, clause 4), b), i) refers on to subclause 8.2 &amp;lt;comparison predicate&amp;gt; for how to eliminate duplicates. 8.2 does not specify how to handle window functions explicitly, only general number/value handling.&lt;br/&gt;
Since 10.9s &quot;General Rules&quot; 4) a) specifies that expressions should be evaluated for every row before DISTINCT, I agree that the current patch is not according to the spec in this respect. The DB2 behaviour you see is conformant. We should return 5, not 1, rows as you say.&lt;/p&gt;

&lt;p&gt;I haven&apos;t given this a very hard look, but it seems this will introduce some additional branching in SelectNode.genProjectRestrict(). As of now, DISTINCT is evaluated before ordering and grouping. To be conformant for window functions, it looks like we have to delay the DISTINCT evaluation, or even pull the DISTINCT out of the current PRN, and evaluate it in an additional PRN on top of the current one. Probably is sufficient to mark as !distinctScanPossible and delay insertion of the DISTINCT_NODE if there&apos;s a window function in the RCL.&lt;/p&gt;

&lt;p&gt;Ad 4)&lt;br/&gt;
My imagination... &lt;b&gt;ugh&lt;/b&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I&apos;ll add the one you listed at least, and see if I can find some extra ones too.&lt;/p&gt;

&lt;p&gt;Ad 5)&lt;br/&gt;
No, window functions are not allowed in the ORDER BY clause as of now. Agree - it&apos;s a good idea to add this to the docs.&lt;/p&gt;</comment>
                            <comment id="12573929" author="thomanie" created="Fri, 29 Feb 2008 19:57:55 +0000"  >&lt;p&gt;Ad 3) &lt;br/&gt;
I quickly tried delaying DISTINCT evaluation when there&apos;s a window function in the RCL, and it seems to work as expected -  behaves like Army reported from DB2, and does not break the existing test.&lt;/p&gt;</comment>
                            <comment id="12574006" author="army" created="Fri, 29 Feb 2008 23:25:55 +0000"  >&lt;p&gt;Committed d2998-19.diff and d2998-test9.diff both with svn # 632494:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=632494&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=632494&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In addition to the follow-up work mentioned in my previous comment, I also noticed one more thing that requires investigation.  The following query fails with an ArrayIndexOutOfBounds exception while trying to print the query plan (i.e. after the query is executed, and only if &quot;logQueryPlan&quot; is set to true):&lt;/p&gt;

&lt;p&gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from&lt;br/&gt;
  (select i, row_number() over () from t1&lt;br/&gt;
    union all&lt;br/&gt;
   select distinct row_number() over(), row_number() over() from t1) x(a, b);&lt;/p&gt;

&lt;p&gt;If I remove the &quot;DISTINCT&quot; or else replace one of the row_number() columns in the SELECT DISTINCT query with a simple column reference, the query plan is generated correctly.  Pretty minor in the grand scheme of things, but I thought I&apos;d mention it.&lt;/p&gt;

&lt;p&gt;Thanks for all of your work on this, Thomas!&lt;/p&gt;</comment>
                            <comment id="12574074" author="thomanie" created="Sat, 1 Mar 2008 06:26:38 +0000"  >&lt;p&gt;Thanks for your help Army &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I&apos;ll start looking at the followup patches.&lt;/p&gt;</comment>
                            <comment id="12574150" author="thomanie" created="Sat, 1 Mar 2008 20:36:20 +0000"  >&lt;p&gt;Attaching miniature patch for followup issue #1 - column name changed from &quot;row_number()&quot; to existing pattern (meaning not set when not explicitly aliased).&lt;/p&gt;</comment>
                            <comment id="12574155" author="thomanie" created="Sat, 1 Mar 2008 20:49:16 +0000"  >&lt;p&gt;Attaching miniature patch for followup issue #2 - unnecessary pointsToWindowNode() in PredicateList.java&lt;br/&gt;
Like Army posted, OLAPTest still pass after this change.&lt;/p&gt;</comment>
                            <comment id="12574397" author="dyret" created="Mon, 3 Mar 2008 09:39:57 +0000"  >&lt;p&gt;Committed d2998-followup-issue1.diff with revision 632988, and d2998-followup-2.diff with revision 632992.&lt;/p&gt;</comment>
                            <comment id="12574427" author="thomanie" created="Mon, 3 Mar 2008 10:59:29 +0000"  >&lt;p&gt;Attaching a patch to include the OLAPTest in the lang testsuite, &apos;d2998-followup-testsuite.diff&apos; &lt;br/&gt;
Suite runs successfully with this patch applied.&lt;/p&gt;</comment>
                            <comment id="12574431" author="thomanie" created="Mon, 3 Mar 2008 11:12:40 +0000"  >&lt;p&gt;Attaching updated doc patch.&lt;br/&gt;
Also addresses Armys followup issue #5.&lt;/p&gt;

&lt;p&gt;Docs build cleanly with this patch.&lt;/p&gt;</comment>
                            <comment id="12574451" author="thomanie" created="Mon, 3 Mar 2008 11:51:20 +0000"  >&lt;p&gt;Thanks for committing the followups, Dyre.&lt;/p&gt;

&lt;p&gt;Attaching patch with group by and having queries that Army listed - issue #4.&lt;br/&gt;
OLAPTest pass with this patch applied.&lt;/p&gt;</comment>
                            <comment id="12574487" author="dyret" created="Mon, 3 Mar 2008 13:02:35 +0000"  >&lt;p&gt;Patch file: d2998-followup-testsuite.diff&lt;br/&gt;
Committed revision 633058.&lt;/p&gt;

&lt;p&gt;Patch file: d2998-followup-issue4.diff&lt;br/&gt;
Committed revision 633067.&lt;/p&gt;</comment>
                            <comment id="12574503" author="dyret" created="Mon, 3 Mar 2008 13:49:49 +0000"  >&lt;p&gt;Patch file: d2998-doc-2.diff&lt;br/&gt;
Committed revision 633083.&lt;/p&gt;</comment>
                            <comment id="12574543" author="thomanie" created="Mon, 3 Mar 2008 15:03:45 +0000"  >&lt;p&gt;Thanks again Dyre.&lt;/p&gt;

&lt;p&gt;Attaching followup patch for the ArrayIndexOutOfBoundsException when logging queryplans.&lt;br/&gt;
There was an unhandled case of an existing but empty list in RealDistinctScanStatistics.java.&lt;/p&gt;

&lt;p&gt;lang._Suite runs fine (doesn&apos;t print queryplans AFAIK), and derbyall is still running (but shouldn&apos;t show any problems).&lt;/p&gt;</comment>
                            <comment id="12574615" author="army" created="Mon, 3 Mar 2008 17:29:07 +0000"  >&lt;p&gt;Thank you for all of the follow-up patches, Thomas.  (And thank for the commits, Dyre!)&lt;/p&gt;

&lt;p&gt;Regarding d2998-followup-2.diff: with this change the method &quot;pointsToWindowFunction()&quot; in ColumnReference.java is no longer called.  Would it make sense to remove the method altogether?&lt;/p&gt;

&lt;p&gt;Regarding d2998-followup-queryplanAOOB.diff: With this patch applied the query plan now shows:&lt;/p&gt;

&lt;p&gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from&lt;br/&gt;
  (select i, row_number() over () from t1&lt;br/&gt;
    union all&lt;br/&gt;
   select distinct row_number() over(), row_number() over() from t1) x(a, b); &lt;/p&gt;

&lt;p&gt;  ...&lt;br/&gt;
        Distinct Scan ResultSet for T1 at read committed isolation level using instantaneous share row locking:&lt;br/&gt;
        Number of opens = 1&lt;br/&gt;
        Hash table size = 1&lt;br/&gt;
        Distinct column is column number -1&lt;br/&gt;
        Rows seen = 1&lt;/p&gt;

&lt;p&gt;From reading the plan it wasn&apos;t immediately clear to me what &quot;Distinct column is column number -1&quot; meant.  Esp. what does a column number of &quot;-1&quot; mean?  I then ran a bunch of simple SELECT DISTINCT ... from T1 queries and determined that the distinct column number which is printed as part of the query plan is meant to be the 0-based position of the column as it appears in the conglomerate being scanned.  Since ROW_NUMBER() is not a column in the conglomerate, I guess &quot;-1&quot; seems like an okay value.&lt;/p&gt;

&lt;p&gt;Having said that, though, I think it&apos;s interesting that if we replace ROW_NUMBER() with any other expression-&lt;del&gt;such as &quot;i+j&quot; or a literal&lt;/del&gt;-a Distinct scan on the conglomerate doesn&apos;t happen: instead, we do a normal scan of the conglomerate and then a distinct sort on the results.  I was expecting ROW_NUMBER() to behave the same, but apparently it doesn&apos;t.  Is this because ROW_NUMBER() is (incorrectly) applied &lt;b&gt;after&lt;/b&gt; the DISTINCT, instead of before, per earlier discussion?  And if so, do you happen to know if this change to RealDistinctScanStatistics will still be needed after the DISTINCT issue is resolved?&lt;/p&gt;</comment>
                            <comment id="12574678" author="thomanie" created="Mon, 3 Mar 2008 19:12:00 +0000"  >&lt;p&gt;Army&amp;gt; &quot;pointsToWindowFunction()&quot; in ColumnReference.java is no longer called. Would it make sense to remove the method altogether? &lt;/p&gt;

&lt;p&gt;Yes - it should be removed. Will fix tomorrow.&lt;/p&gt;

&lt;p&gt;Army&amp;gt;  .... And if so, do you happen to know if this change to RealDistinctScanStatistics will still be needed after the DISTINCT issue is resolved?&lt;/p&gt;

&lt;p&gt;Fixing the distinct with a window function issue will result in placing the distinct node on top of the window node(s). Today it&apos;s the other way around. To do so involves explicitly doing a normal scan and a distinct sort - like you say. So, yes, we might not actually need it - please don&apos;t commit it yet.&lt;/p&gt;

&lt;p&gt;I&apos;ll start on the distinct fix tomorrow. The fix I tried in my sandbox worked for non-nested queries, but not when there&apos;s a subquery with a window function. This resulted in incorrect results being returned. Looked like a column mapping issue in the distinct node from the couple of alternative queries I tried without a window function. I know where to start looking at least &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12574711" author="army" created="Mon, 3 Mar 2008 19:55:30 +0000"  >&lt;p&gt;Fixed some javadoc warnings introduced by d2998-19.diff with svn # 633251:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=633251&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=633251&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12574756" author="thomanie" created="Mon, 3 Mar 2008 21:49:32 +0000"  >&lt;p&gt;I was looking into why the distinct issue happened tonight and decided to fix it. &lt;br/&gt;
Attaching &apos;d2998-followup-distinct.diff&apos; that solves this for both queries and subqueries, as well as adding a couple of DISTINCT queries to OLAPTest. &lt;br/&gt;
The updated OLAPTest pass.&lt;/p&gt;

&lt;p&gt;The proposed change in ProjectRestrictNode.java isn&apos;t perfect. I had to use a boolean variable to trigger VCN regeneration to avoid getting a nasty if-instanceof construct. It might just be too late in the day...&lt;/p&gt;

&lt;p&gt;When the distinct issue is fixed the ArrayIndexOutOfBoundsException Army reported is avoided since RealDistinctScanStatistics is not used. I&apos;ll remove the patch I uploaded earlier today.&lt;/p&gt;</comment>
                            <comment id="12574793" author="army" created="Mon, 3 Mar 2008 23:56:34 +0000"  >&lt;p&gt;I applied &quot;d2998-followup-distinct.diff&quot; and verified that both the DISTINCT issue and the ArrayIndexOutOfBounds issue are resolved.&lt;/p&gt;

&lt;p&gt;That said, in re-reading the comments in ProjectRestrictNode I noticed this:&lt;/p&gt;

&lt;p&gt;    /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;We have a window function column in the RCL of our child&lt;/li&gt;
	&lt;li&gt;PRN, and need to regenerate the VCNs.&lt;br/&gt;
     */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Out of curiosity I made a quick change so that, instead of checking for instances of WindowNode and DIstinctNode, the code just checked the condition described in the comment, i.e. &quot;do we have a window function column in the RCL of our child PRN?&quot;.  So I replaced:&lt;/p&gt;

&lt;p&gt;        boolean regenVCN = false;&lt;br/&gt;
        ProjectRestrictNode prn = (ProjectRestrictNode)childResult;&lt;br/&gt;
        if (prn.childResult instanceof WindowNode)&lt;/p&gt;
{
            regenVCN = true;
        }
&lt;p&gt;        if (prn.childResult instanceof DistinctNode){&lt;br/&gt;
            DistinctNode dn = (DistinctNode)prn.childResult;&lt;br/&gt;
            if (dn.childResult instanceof WindowNode)&lt;/p&gt;
{
                regenVCN = true;
            }
&lt;p&gt;        }&lt;br/&gt;
        if (regenVCN){&lt;br/&gt;
            ...&lt;/p&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;p&gt;        ProjectRestrictNode prn = (ProjectRestrictNode)childResult;&lt;br/&gt;
        if (prn.childResult.getResultColumns()&lt;br/&gt;
                .containsWindowFunctionResultColumn())&lt;br/&gt;
        {&lt;br/&gt;
            ...&lt;/p&gt;

&lt;p&gt;From what I can tell this change still makes all of the queries pass (including OLAPTest).  Would this be a viable alternative, or would such an approach be too broad?  I admit I didn&apos;t do any tracing with this particular change, I just ran the tests and noted that they appear to run to correctly.  The code seems cleaner and matches the comment, so I thought I&apos;d throw it out there...&lt;/p&gt;

&lt;p&gt;On a completely unrelated note, I accidentally discovered that queries of the form:&lt;/p&gt;

&lt;p&gt;   select * from (select row_number() over() as r, ... from t) x where r &amp;lt; ...&lt;/p&gt;

&lt;p&gt;can actually return different results depending on the presence of indexes.  This is because the rows returned from the subquery have no guaranteed ordering (Derby doesn&apos;t allow ORDER BY in subqueries), and thus any predicate which restricts based on row_number() will restrict the rows based on an undefined order.  Since the order of the rows from the subquery may depend on the presence of indexes, the set of rows which survives a row_order()&lt;del&gt;based restriction may depend on the indexes, as well.  In the end I do &lt;em&gt;not&lt;/em&gt; think this is a bug&lt;/del&gt;-but it does strike me as a probable point of confusion for users.  It seems that anyone who wants &quot;the first x rows only&quot; has to either accept the fact that &quot;first&quot; does not imply &quot;ordered&quot; (and thus results can vary depending on what conglomerate the optimizer chooses), or else s/he has to use optimizer ovverides to force the optimizer to use an index which is ordered on the desired columns.  Is that an accurate assessment? I&apos;m not saying anything needs to be done to address this, I&apos;m just curious as to whether or not I&apos;ve understood this correctly.&lt;/p&gt;

&lt;p&gt;But all of that aside, thanks for resolving the DISTINCT issue, Thomas! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12574892" author="thomanie" created="Tue, 4 Mar 2008 08:59:38 +0000"  >&lt;p&gt;I considered your proposed change, but turned it down as I thought it too general. That&apos;s why I ended up checking for the WindowNodes - we know it&apos;s at the top of the child &lt;b&gt;if&lt;/b&gt; it&apos;s there. I&apos;ll do some tracing to see whether my conclusion was wrong or not.&lt;/p&gt;

&lt;p&gt;Wrt to window functions and ordering:&lt;br/&gt;
Yes, the below ResultSets can return rows in an arbitrary order depending on indexes or not - and on other characteristics of the database engine. Very familiar with this from the distributed database I&apos;ve worked on earlier. And, yes, my experience is it&apos;s something most users run into somehow &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; The same goes for joins - think 2 rows joined with 3 rows. No &lt;b&gt;guarantee&lt;/b&gt; that the join is performed a certain way and presence of an index may cause different row ordering that without. This really applies to all queries, as long as there is no ORDER BY clause, there is really no guarantee for the ordering. Since Derby does not support ordering in subqueries, we have no option but to take what the selected conglomorate supplies of row ordering. &lt;/p&gt;

&lt;p&gt;I&apos;ll add a paragraph about this behaviour to the row_number page in the reference manual.&lt;/p&gt;

&lt;p&gt;Note that once we get better/full window support, we should be able to specify ordering of the window in the window definition. This will hopefully help those that require the window to be ordered, and &lt;b&gt;may&lt;/b&gt; work around the no-orderby-in-subquery limitation currently in Derby &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12574911" author="thomanie" created="Tue, 4 Mar 2008 10:10:04 +0000"  >&lt;p&gt;Attaching diff &apos;d2998-followup-doc3.diff&apos; with extra note on the subquery ordering behaviour in the row_number page of ref man, as well as the resulting generated html.&lt;/p&gt;</comment>
                            <comment id="12574962" author="thomanie" created="Tue, 4 Mar 2008 12:54:05 +0000"  >&lt;p&gt;Wrt allowing order by in a subquery select:&lt;br/&gt;
I did the limited changes needed to allow order by in a subquery select, and have a working proto in my sandbox. Enables ordering and restriction on the window function column like we would like.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from (select row_number() over () as r, t.* from t order by b desc) tr  where r&amp;lt;3;&lt;br/&gt;
R                   |A          |B          &lt;br/&gt;
--------------------------------------------&lt;br/&gt;
1                   |50         |500        &lt;br/&gt;
2                   |40         |400&lt;/p&gt;

&lt;p&gt;Is this something we would like to support?&lt;br/&gt;
Do you think it&apos;s worth making a new jira for this? &lt;/p&gt;

&lt;p&gt;The closest I could find was &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4&quot; title=&quot;&amp;quot;order by&amp;quot; is not supported for &amp;quot;insert ... select&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4&quot;&gt;&lt;del&gt;DERBY-4&lt;/del&gt;&lt;/a&gt;, but it&apos;s not identical as it centers around a INSERT INTO ... SELECT FROM ... query. And it is currently veto&apos;ed. Looking at the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4&quot; title=&quot;&amp;quot;order by&amp;quot; is not supported for &amp;quot;insert ... select&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4&quot;&gt;&lt;del&gt;DERBY-4&lt;/del&gt;&lt;/a&gt; now, I see it does more or less the same thing as my changes, only for insert statements.&lt;/p&gt;</comment>
                            <comment id="12575044" author="army" created="Tue, 4 Mar 2008 16:33:08 +0000"  >&lt;p&gt;&amp;gt; I considered your proposed change, but turned it down as I thought it too general.&lt;/p&gt;

&lt;p&gt;Okay, good to know the idea was at least considered &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; I did the limited changes needed to allow order by in a subquery select&lt;br/&gt;
&amp;gt; Is this something we would like to support?&lt;/p&gt;

&lt;p&gt;I think the first question is whether or not that is supported by the standard.  If it&apos;s not in SQL standard but is &quot;de-facto&quot; standard, meaning (I think) that most database vendors support it and the behavior is consistent across vendors, then I think that would be acceptable, as well.  But I don&apos;t know whether or not either of those is true for ORDER BY in a subquery?&lt;/p&gt;

&lt;p&gt;In any event, I definitely think it would warrant it&apos;s own Jira.&lt;/p&gt;</comment>
                            <comment id="12575092" author="thomanie" created="Tue, 4 Mar 2008 18:33:11 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; I considered your proposed change, but turned it down as I thought it too general.&lt;br/&gt;
&amp;gt; Okay, good to know the idea was at least considered &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;It seems using containsWindowFunctionResultColumn() is safe after all. I&apos;ll upload a new patch tomorrow morning, along with the removal of ColumnReference.pointsToWindowFunction().&lt;/p&gt;

&lt;p&gt;Army&amp;gt; I think the first question is whether or not that is supported by the standard. &lt;/p&gt;

&lt;p&gt;Actually it doesn&apos;t seem to be - and that&apos;s most likely the reason why it&apos;s not in there already &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  The &amp;lt;order by clause&amp;gt; is part of &amp;lt;declare cursor&amp;gt;. &amp;lt;subquery&amp;gt; only includes &amp;lt;query expression&amp;gt;, which again includes &amp;lt;query specification&amp;gt;, which again does &lt;b&gt;not&lt;/b&gt; include &amp;lt;declare cursor&amp;gt;.&lt;/p&gt;

&lt;p&gt;The specific problem we want to solve will be fixed when window ordering is included, so I won&apos;t pursue this now.&lt;/p&gt;</comment>
                            <comment id="12575270" author="thomanie" created="Wed, 5 Mar 2008 08:34:03 +0000"  >&lt;p&gt;Attaching &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;updated followup patch for distinct with changes to PRN&lt;/li&gt;
	&lt;li&gt;followup patch to remove unused ColumnReference.pointsToWindowFunction()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;OLAPTest runs successfully with these patches.&lt;/p&gt;</comment>
                            <comment id="12575512" author="army" created="Wed, 5 Mar 2008 22:18:36 +0000"  >&lt;p&gt;Committed d2998-followup-distinct.diff and d2998-followup-removeunused.diff with svn # 634057:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=634057&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=634057&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thanks Thomas!  Can you perhaps give a quick update on what else you have planned for for this issue in the 10.4 timeframe?&lt;/p&gt;</comment>
                            <comment id="12575593" author="thomanie" created="Thu, 6 Mar 2008 07:29:44 +0000"  >&lt;p&gt;Thanks Army!&lt;/p&gt;

&lt;p&gt;I do not have any more work lined up on this for 10.4. Given that there&apos;s only two days until feature freeze, I don&apos;t think there&apos;s time to do much else &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I suggest we resolve and close this one as completed, and do any followup work in new jiras.&lt;/p&gt;</comment>
                            <comment id="12575788" author="army" created="Thu, 6 Mar 2008 17:23:02 +0000"  >&lt;p&gt;&amp;gt; I do not have any more work lined up on this for 10.4. &lt;/p&gt;

&lt;p&gt;Okay, thanks Thomas!&lt;/p&gt;

&lt;p&gt;The reason I asked is because on Feb 25 I posted a bunch of comments, of which #8 mentioned how predicates on a ROW_NUMBER() do &lt;b&gt;not&lt;/b&gt; actually limit rows from store, and thus such a restriction will probably not meet the performance expectations of the user who specifies it.  For reference, the example query was:&lt;/p&gt;

&lt;p&gt;    SELECT * FROM (&lt;br/&gt;
      SELECT row_number() over () as r, t.* FROM T&lt;br/&gt;
    ) AS tmp WHERE r &amp;lt;= 3;&lt;/p&gt;

&lt;p&gt;for which the plan shows the following for the top-most ProjectRestrictResultSet:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;
					&lt;ul&gt;
						&lt;li&gt;
						&lt;ul&gt;
							&lt;li&gt;Project-Restrict ResultSet (1):&lt;br/&gt;
  Number of opens = 1&lt;br/&gt;
  Rows seen = 1280&lt;br/&gt;
  Rows filtered = 1277&lt;br/&gt;
  restriction = true&lt;/li&gt;
						&lt;/ul&gt;
						&lt;/li&gt;
					&lt;/ul&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So we actually read all 1280 rows from disk, then filtered 1277 of them out so that, in the end, we only returned 3 rows.&lt;/p&gt;

&lt;p&gt;In response to that you wrote (on Feb 26):&lt;/p&gt;

&lt;p&gt;Thomas&amp;gt; It seems we don&apos;t take the fact that we know we have an ascending column&lt;br/&gt;
Thomas&amp;gt; into consideration any more (we used to). I&apos;ll have to have another look at this.&lt;/p&gt;

&lt;p&gt;So is it safe to say that this will &lt;b&gt;not&lt;/b&gt; be addressed for 10.4?  That&apos;s perfectly fine, I just want to make sure we&apos;re clear on that (esp. so that if users ask, we can give a clear answer &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Do you think it would be worth it to file a separate enhancement Jira for that particular task?  (or is there one already?)&lt;/p&gt;</comment>
                            <comment id="12575795" author="thomanie" created="Thu, 6 Mar 2008 17:35:51 +0000"  >&lt;p&gt;Updated the description field as suggested by Mike.&lt;/p&gt;</comment>
                            <comment id="12575811" author="thomanie" created="Thu, 6 Mar 2008 17:58:34 +0000"  >&lt;p&gt;Amry, I don&apos;t think there&apos;s time to address that in the 10.4 timeframe. But I&apos;ll give it a shot!&lt;/p&gt;

&lt;p&gt;I created &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3505&quot; title=&quot;Current implementation of ROW_NUMBER() window function does not stop execution once criteria is met&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3505&quot;&gt;DERBY-3505&lt;/a&gt; for the &quot;#8 comment&quot; about ROW_NUMBER() performance.  Whenever &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3505&quot; title=&quot;Current implementation of ROW_NUMBER() window function does not stop execution once criteria is met&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3505&quot;&gt;DERBY-3505&lt;/a&gt; is fixed on trunk it can be ported to the 10.4 branch (no interface changes, only internal) and the improved performance shipped with the next update release off the 10.4 branch?&lt;/p&gt;</comment>
                            <comment id="12575819" author="army" created="Thu, 6 Mar 2008 18:08:34 +0000"  >&lt;p&gt;&amp;gt; I&apos;ll give it a shot!&lt;/p&gt;

&lt;p&gt;Probably not something that should be rushed &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Post 10.4 is fine with me, I was just looking for a clear update on that issue.  The filing of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3505&quot; title=&quot;Current implementation of ROW_NUMBER() window function does not stop execution once criteria is met&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3505&quot;&gt;DERBY-3505&lt;/a&gt; is good enough for me right now.&lt;/p&gt;</comment>
                            <comment id="12576070" author="thomanie" created="Fri, 7 Mar 2008 08:04:33 +0000"  >&lt;p&gt;Looks like the doc-3 patch still hasn&apos;t been comitted. I&apos;ll resolve once that has gone in &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12576104" author="dyret" created="Fri, 7 Mar 2008 09:55:25 +0000"  >&lt;p&gt;Patch file: d2998-followup-doc3.diff&lt;br/&gt;
Committed revision 634587.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12394334">DERBY-3634</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12415975">DERBY-4079</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12374708" name="d2998-10.diff" size="53157" author="thomanie" created="Mon, 4 Feb 2008 21:47:09 +0000"/>
                            <attachment id="12374712" name="d2998-10.stat" size="1224" author="thomanie" created="Mon, 4 Feb 2008 21:52:50 +0000"/>
                            <attachment id="12374821" name="d2998-11.diff" size="51435" author="thomanie" created="Tue, 5 Feb 2008 21:31:57 +0000"/>
                            <attachment id="12375485" name="d2998-12.diff" size="53520" author="thomanie" created="Wed, 13 Feb 2008 13:38:54 +0000"/>
                            <attachment id="12375486" name="d2998-12.stat" size="1349" author="thomanie" created="Wed, 13 Feb 2008 13:38:54 +0000"/>
                            <attachment id="12375582" name="d2998-13.diff" size="54137" author="thomanie" created="Thu, 14 Feb 2008 12:21:44 +0000"/>
                            <attachment id="12375583" name="d2998-13.stat" size="1349" author="thomanie" created="Thu, 14 Feb 2008 12:21:45 +0000"/>
                            <attachment id="12376157" name="d2998-14.diff" size="52924" author="thomanie" created="Thu, 21 Feb 2008 20:15:37 +0000"/>
                            <attachment id="12376158" name="d2998-14.stat" size="1295" author="thomanie" created="Thu, 21 Feb 2008 20:15:37 +0000"/>
                            <attachment id="12376393" name="d2998-15.diff" size="56632" author="thomanie" created="Mon, 25 Feb 2008 10:03:11 +0000"/>
                            <attachment id="12376394" name="d2998-15.stat" size="1432" author="thomanie" created="Mon, 25 Feb 2008 10:03:11 +0000"/>
                            <attachment id="12376481" name="d2998-16.diff" size="57983" author="thomanie" created="Tue, 26 Feb 2008 11:55:36 +0000"/>
                            <attachment id="12376482" name="d2998-16.stat" size="1541" author="thomanie" created="Tue, 26 Feb 2008 11:55:36 +0000"/>
                            <attachment id="12376496" name="d2998-17.diff" size="60076" author="thomanie" created="Tue, 26 Feb 2008 16:04:46 +0000"/>
                            <attachment id="12376497" name="d2998-17.stat" size="1394" author="thomanie" created="Tue, 26 Feb 2008 16:04:46 +0000"/>
                            <attachment id="12376634" name="d2998-18.diff" size="59639" author="thomanie" created="Wed, 27 Feb 2008 15:46:48 +0000"/>
                            <attachment id="12376635" name="d2998-18.stat" size="1624" author="thomanie" created="Wed, 27 Feb 2008 15:46:48 +0000"/>
                            <attachment id="12376807" name="d2998-19.diff" size="58143" author="thomanie" created="Fri, 29 Feb 2008 11:26:52 +0000"/>
                            <attachment id="12376808" name="d2998-19.stat" size="1541" author="thomanie" created="Fri, 29 Feb 2008 11:26:52 +0000"/>
                            <attachment id="12369982" name="d2998-4.diff" size="45219" author="thomanie" created="Wed, 21 Nov 2007 15:23:41 +0000"/>
                            <attachment id="12369983" name="d2998-4.stat" size="1060" author="thomanie" created="Wed, 21 Nov 2007 15:23:41 +0000"/>
                            <attachment id="12370305" name="d2998-5.diff" size="39835" author="thomanie" created="Tue, 27 Nov 2007 13:39:42 +0000"/>
                            <attachment id="12370304" name="d2998-5.stat" size="914" author="thomanie" created="Tue, 27 Nov 2007 13:39:42 +0000"/>
                            <attachment id="12371349" name="d2998-6.diff" size="46332" author="thomanie" created="Mon, 10 Dec 2007 12:05:46 +0000"/>
                            <attachment id="12371350" name="d2998-6.stat" size="1089" author="thomanie" created="Mon, 10 Dec 2007 12:05:46 +0000"/>
                            <attachment id="12371651" name="d2998-7.diff" size="45689" author="thomanie" created="Fri, 14 Dec 2007 08:37:42 +0000"/>
                            <attachment id="12371652" name="d2998-7.stat" size="1089" author="thomanie" created="Fri, 14 Dec 2007 08:37:43 +0000"/>
                            <attachment id="12373387" name="d2998-8.diff" size="47229" author="thomanie" created="Thu, 17 Jan 2008 12:06:50 +0000"/>
                            <attachment id="12373386" name="d2998-8.stat" size="1168" author="thomanie" created="Thu, 17 Jan 2008 12:06:50 +0000"/>
                            <attachment id="12374255" name="d2998-9-derby.log" size="61027" author="thomanie" created="Tue, 29 Jan 2008 12:02:36 +0000"/>
                            <attachment id="12374253" name="d2998-9.diff" size="53193" author="thomanie" created="Tue, 29 Jan 2008 12:02:36 +0000"/>
                            <attachment id="12374254" name="d2998-9.stat" size="1100" author="thomanie" created="Tue, 29 Jan 2008 12:02:36 +0000"/>
                            <attachment id="12371791" name="d2998-doc-1.diff" size="3923" author="thomanie" created="Mon, 17 Dec 2007 12:09:47 +0000"/>
                            <attachment id="12371792" name="d2998-doc-1.stat" size="108" author="thomanie" created="Mon, 17 Dec 2007 12:09:47 +0000"/>
                            <attachment id="12376962" name="d2998-doc-2.diff" size="3989" author="thomanie" created="Mon, 3 Mar 2008 11:12:40 +0000"/>
                            <attachment id="12376961" name="d2998-doc-2.stat" size="108" author="thomanie" created="Mon, 3 Mar 2008 11:12:40 +0000"/>
                            <attachment id="12376915" name="d2998-followup-2.diff" size="644" author="thomanie" created="Sat, 1 Mar 2008 20:49:16 +0000"/>
                            <attachment id="12376916" name="d2998-followup-2.stat" size="73" author="thomanie" created="Sat, 1 Mar 2008 20:49:16 +0000"/>
                            <attachment id="12377144" name="d2998-followup-distinct.diff" size="4792" author="thomanie" created="Wed, 5 Mar 2008 08:34:03 +0000"/>
                            <attachment id="12377014" name="d2998-followup-distinct.diff" size="5069" author="thomanie" created="Mon, 3 Mar 2008 21:49:32 +0000"/>
                            <attachment id="12377015" name="d2998-followup-distinct.stat" size="233" author="thomanie" created="Mon, 3 Mar 2008 21:49:32 +0000"/>
                            <attachment id="12377060" name="d2998-followup-doc3.diff" size="1301" author="thomanie" created="Tue, 4 Mar 2008 10:10:04 +0000"/>
                            <attachment id="12377061" name="d2998-followup-doc3.stat" size="38" author="thomanie" created="Tue, 4 Mar 2008 10:10:04 +0000"/>
                            <attachment id="12376911" name="d2998-followup-issue1.diff" size="627" author="thomanie" created="Sat, 1 Mar 2008 20:36:20 +0000"/>
                            <attachment id="12376912" name="d2998-followup-issue1.stat" size="68" author="thomanie" created="Sat, 1 Mar 2008 20:36:20 +0000"/>
                            <attachment id="12376965" name="d2998-followup-issue4.diff" size="2952" author="thomanie" created="Mon, 3 Mar 2008 11:51:20 +0000"/>
                            <attachment id="12376966" name="d2998-followup-issue4.stat" size="83" author="thomanie" created="Mon, 3 Mar 2008 11:51:20 +0000"/>
                            <attachment id="12377145" name="d2998-followup-removeunused.diff" size="940" author="thomanie" created="Wed, 5 Mar 2008 08:34:03 +0000"/>
                            <attachment id="12376958" name="d2998-followup-testsuite.diff" size="682" author="thomanie" created="Mon, 3 Mar 2008 10:59:29 +0000"/>
                            <attachment id="12376959" name="d2998-followup-testsuite.stat" size="81" author="thomanie" created="Mon, 3 Mar 2008 10:59:29 +0000"/>
                            <attachment id="12370932" name="d2998-test.diff" size="4928" author="thomanie" created="Tue, 4 Dec 2007 10:25:47 +0000"/>
                            <attachment id="12370933" name="d2998-test.stat" size="84" author="thomanie" created="Tue, 4 Dec 2007 10:25:47 +0000"/>
                            <attachment id="12371014" name="d2998-test2.diff" size="1559" author="thomanie" created="Wed, 5 Dec 2007 10:06:55 +0000"/>
                            <attachment id="12371015" name="d2998-test2.stat" size="83" author="thomanie" created="Wed, 5 Dec 2007 10:06:56 +0000"/>
                            <attachment id="12371653" name="d2998-test3.diff" size="3336" author="thomanie" created="Fri, 14 Dec 2007 08:38:30 +0000"/>
                            <attachment id="12371654" name="d2998-test3.stat" size="83" author="thomanie" created="Fri, 14 Dec 2007 08:38:30 +0000"/>
                            <attachment id="12375483" name="d2998-test4.diff" size="6207" author="thomanie" created="Wed, 13 Feb 2008 13:21:31 +0000"/>
                            <attachment id="12375484" name="d2998-test4.stat" size="83" author="thomanie" created="Wed, 13 Feb 2008 13:21:31 +0000"/>
                            <attachment id="12375584" name="d2998-test6.diff" size="7860" author="thomanie" created="Thu, 14 Feb 2008 12:21:45 +0000"/>
                            <attachment id="12376438" name="d2998-test7.diff" size="7654" author="thomanie" created="Mon, 25 Feb 2008 20:52:25 +0000"/>
                            <attachment id="12376636" name="d2998-test8.diff" size="11631" author="thomanie" created="Wed, 27 Feb 2008 15:46:48 +0000"/>
                            <attachment id="12376809" name="d2998-test9.diff" size="12074" author="thomanie" created="Fri, 29 Feb 2008 11:26:52 +0000"/>
                            <attachment id="12377062" name="rreffuncrownumber.html" size="4333" author="thomanie" created="Tue, 4 Mar 2008 10:10:04 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>63.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 28 Aug 2007 16:35:04 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30685</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0k0n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37061</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>