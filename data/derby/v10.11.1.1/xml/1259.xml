<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:41:02 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1259/DERBY-1259.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1259] Optimizer plan consideration doesn&apos;t account for infinite cost estimates and can therefore choose plans requiring excessive memory.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1259</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When deciding whether or not to choose a particular access path as the &quot;best one so far&quot;, the optimizer tries to guess what the memory usage for the path will be and, if it&apos;s prohibitive, it (the optimizer) will reject the plan.  Currently this only applies to hash joins in Derby.&lt;/p&gt;

&lt;p&gt;The call that starts the check for excessive memory exists in two places in OptimizerImpl.java: costBasedCostOptimizable() and considerCost().  There we have the following:&lt;/p&gt;

&lt;p&gt;  /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Skip this access path if it takes too much memory.&lt;br/&gt;
  **&lt;/li&gt;
		&lt;li&gt;NOTE: The default assumption here is that the number of rows in&lt;/li&gt;
		&lt;li&gt;a single scan is the total number of rows divided by the number&lt;/li&gt;
		&lt;li&gt;of outer rows.  The optimizable may over-ride this assumption.&lt;br/&gt;
  */&lt;br/&gt;
  if( ! optimizable.memoryUsageOK(estimatedCost.rowCount() / outerCost.rowCount(), maxMemoryPerTable))
  &lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    if (optimizerTrace)    {
      trace(SKIPPING_DUE_TO_EXCESS_MEMORY, 0, 0, 0.0, null);
    }    return;  }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;However, if the outerCost has an estimated row count of Double.POSITIVE_INFINITY, which can happen if the query is very deeply nested and/or has a lot of FROM tables/expressions, the division of estimatedCost.rowCount() by outerCost.rowCount() will result in a &quot;NaN&quot; value.  If that value is then passed to FromTable (which is the base implementation of an Optimizable), the memoryUsageOK method looks like this:&lt;/p&gt;

&lt;p&gt;    public boolean memoryUsageOK( double rowCount, int maxMemoryPerTable)&lt;br/&gt;
      throws StandardException&lt;/p&gt;
    {
      /*
      ** Don&apos;t enforce maximum memory usage for a user-specified join
      ** strategy.
      */
      if( userSpecifiedJoinStrategy != null)
            return true;

        int intRowCount = (rowCount &amp;gt; Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) rowCount;
        return intRowCount &amp;lt;= maxCapacity( getCurrentAccessPath().getJoinStrategy(), maxMemoryPerTable);
    }

&lt;p&gt;If rowCount is &quot;NaN&quot;, the comparison to see if it&apos;s greater than MAX_VALUE will return false, which means that intRowCount gets set to &quot;(int)rowCount&quot;.  But when we cast rowCount, which is &quot;NaN&quot; represented by a double, to an int the result is 0.  The final check then becomes &quot;0 &amp;lt;= maxCapacity(...)&quot;, which will always return true.  Thus regardless of what the estimated cost for the optimizable is, the &quot;memoryUsageOK&quot; check will always return true if the outer cost is infinity, and thus the optimizer could very well decide to choose a path that it should have rejected because of excessive memory requirements (where &quot;should&quot; means based on the estimates; the accuracy of the estimates in this case is another issue altogether).&lt;/p&gt;

&lt;p&gt;That said, I went in and made a small change to the above code to cause the Optimizer to reject a plan if it&apos;s cost was infinity, and the result was that some queries-&lt;del&gt;esp. those seen in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1205&quot; title=&quot;Unexpectedly very slow performance compared to DB2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1205&quot;&gt;&lt;del&gt;DERBY-1205&lt;/del&gt;&lt;/a&gt;&lt;/del&gt;-actually ended up running more slowly.  The reason is that &quot;infinity&quot; is obviously not an accurate cost estimate for the hash joins, and in the case of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1205&quot; title=&quot;Unexpectedly very slow performance compared to DB2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1205&quot;&gt;&lt;del&gt;DERBY-1205&lt;/del&gt;&lt;/a&gt; the hash joins, while expensive, still end up being cheaper than nested loop joins.  So the result of &quot;fixing&quot; the logic with a small change ended up making the queries run more slowly.  Thus more investigation is required regarding to how to best approach this.&lt;/p&gt;</description>
                <environment>Windows 2000, ibm142</environment>
        <key id="12332769">DERBY-1259</key>
            <summary>Optimizer plan consideration doesn&apos;t account for infinite cost estimates and can therefore choose plans requiring excessive memory.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="army">A B</reporter>
                        <labels>
                            <label>derby_triage10_8</label>
                    </labels>
                <created>Thu, 27 Apr 2006 13:48:59 +0100</created>
                <updated>Thu, 17 Feb 2011 00:27:22 +0000</updated>
                                            <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                                                    <component>SQL</component>
                        <due></due>
                            <votes>4</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12376778" author="mikem" created="Fri, 28 Apr 2006 02:33:45 +0100"  >&lt;p&gt;At least in the 10.2 development line, I believe we should fix this issue and then address the fallout as &lt;br/&gt;
necessary.  It seems reasonable not to change the query performance in a stable release like 10.1.3, so&lt;br/&gt;
am ok with leaving the logic there until we can figure out larger fix.  Even if  it means some queries will go slower,  hopefully other queries will go faster when the code does what it was intended to do.    &lt;br/&gt;
Counting on leaving a bug in the system to make up for another&lt;br/&gt;
problem in the system which produced a bad estimate is just going to lead us down a path where no one&lt;br/&gt;
can understand why the optimizer picks the plan it does.  &lt;/p&gt;

&lt;p&gt;The history of hash joins is as follows.  The code has only ever expected to use them when the number/size of&lt;br/&gt;
rows could reasonably be expected to fit in memory.  The costing the optimizer uses only ever assumes in&lt;br/&gt;
memory java hash tables.  The costing for hash scans that store returns only account for in memory hash tables.&lt;br/&gt;
The cost assumption is that probes into the in memory hash table is basically free after it has paid the cost to &lt;br/&gt;
build it.  As described above the optimizer code estimated the hash table size and would reject plans it &lt;br/&gt;
estimated would not fit into memory.  For a long time  all rows in a hash scan would go into memory even if&lt;br/&gt;
the optimizer estimate was way low, which in some cases would result in out of memory.&lt;/p&gt;

&lt;p&gt;Recently a change was made to overflow the hash tables to disk.  At that time the intent of this change was to&lt;br/&gt;
handle the problem where the optimizer  picked wrong - but just go slower rather than get an error.  The assumption&lt;br/&gt;
was it was still an error case rather than a normal expected path.  No costing was added for the overflow to disk&lt;br/&gt;
of the hash table.  Note in the worst case this of an extremely large result set the cost of  each probe into an &lt;br/&gt;
overflowed hash table may be one synchronous I/O per row (definitely far from &quot;free&quot;). &lt;/p&gt;

&lt;p&gt;If we really think it is a good idea to allow overflow hash tables in normal query processing then we should add&lt;br/&gt;
real costing of such a beast.  Do note that providing the real costing is not going to help the query slow down &lt;br/&gt;
above, as the real problem is that the original row estimate is bad.&lt;/p&gt;

&lt;p&gt;My opinion is that there are better query processing options in cases where &lt;br/&gt;
we expect the dataset to much larger than reasonably fits in memory, my &lt;br/&gt;
favorite being some sort of sort /merge &amp;#8211; especially when there already exists indexes on the 2 join keys thus&lt;br/&gt;
giving you favorable I/O clustering on the data set.   In reality what you are doing with &quot;overflow&quot; hash tables&lt;br/&gt;
is creating an on the fly , disk based index for query processing.  In that case I think it might be better to just&lt;br/&gt;
go ahead and either use the existing sorted set (an existing index), or create a sorted resultset for sort merge&lt;br/&gt;
(throw it to the existing sorter).  &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 28 Apr 2006 01:33:45 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22401</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0i13:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36739</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>