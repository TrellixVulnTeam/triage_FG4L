<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:17:55 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3257/DERBY-3257.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3257] SELECT with HAVING clause containing OR conditional incorrectly return 1 row - should return 2 rows - works correctly with 10.2 DB</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3257</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Attached program demonstrates the problem.  Only one count is returned (matching CODE= GBR) - the count of CODE=CHA is not returned.  Works fine with versions 10.1 and 10.2 or if program is run using 10.3 jars and 10.2 database (soft upgrade).&lt;/p&gt;

&lt;p&gt;Query:&lt;br/&gt;
SELECT COUNT(t0.ID) FROM CTS1.TEST_TABLE t0 &lt;br/&gt;
  GROUP BY t0.CODE &lt;br/&gt;
    HAVING (t0.CODE = &apos;GBR&apos; OR t0.CODE = &apos;CHA&apos;) AND t0.CODE IS NOT NULL&lt;/p&gt;

&lt;p&gt;Incorrect results (see last line):&lt;br/&gt;
Database product: Apache Derby&lt;br/&gt;
Database version: 10.3.1.5 - (579866)&lt;br/&gt;
Driver name:      Apache Derby Embedded JDBC Driver&lt;br/&gt;
Driver version:   10.3.1.5 - (579866)&lt;br/&gt;
result: 2&lt;/p&gt;


&lt;p&gt;Correct results:&lt;br/&gt;
Database product: Apache Derby&lt;br/&gt;
Database version: 10.2.2.0 - (485682)&lt;br/&gt;
Driver name:      Apache Derby Embedded JDBC Driver&lt;br/&gt;
Driver version:   10.2.2.0 - (485682)&lt;br/&gt;
result: 4&lt;br/&gt;
result: 2&lt;/p&gt;</description>
                <environment></environment>
        <key id="12384034">DERBY-3257</key>
            <summary>SELECT with HAVING clause containing OR conditional incorrectly return 1 row - should return 2 rows - works correctly with 10.2 DB</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kmarsden">Kathey Marsden</assignee>
                                    <reporter username="stan">Stan Bradbury</reporter>
                        <labels>
                    </labels>
                <created>Thu, 6 Dec 2007 00:57:49 +0000</created>
                <updated>Tue, 30 Jun 2009 16:55:47 +0100</updated>
                            <resolved>Tue, 22 Jan 2008 20:22:12 +0000</resolved>
                                    <version>10.3.1.4</version>
                    <version>10.3.2.1</version>
                    <version>10.4.1.3</version>
                                    <fixVersion>10.3.3.0</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12549097" author="army" created="Thu, 6 Dec 2007 17:01:36 +0000"  >&lt;p&gt;Thanks for the reproducible program, Stan.  The test returns correct results before svn # 516454 (for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt;), but returns incorrect results after.  So it appears that &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; is at least partially at play here.  Early (incremental) changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; might also be a factor, but I haven&apos;t confirmed one way or the other.&lt;/p&gt;</comment>
                            <comment id="12551569" author="mamtas" created="Thu, 13 Dec 2007 18:24:35 +0000"  >&lt;p&gt;My trunk client is at revision 603368&lt;br/&gt;
$ svn info&lt;br/&gt;
Path: .&lt;br/&gt;
URL: &lt;a href=&quot;https://svn.apache.org/repos/asf/db/derby/code/trunk&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/repos/asf/db/derby/code/trunk&lt;/a&gt;&lt;br/&gt;
Repository UUID: 13f79535-47bb-0310-9956-ffa450edef68&lt;br/&gt;
Revision: 603368&lt;br/&gt;
Node Kind: directory&lt;br/&gt;
Schedule: normal&lt;br/&gt;
Last Changed Author: kmarsden&lt;br/&gt;
Last Changed Rev: 603301&lt;br/&gt;
Last Changed Date: 2007-12-11 09:03:01 -0800 (Tue, 11 Dec 2007)&lt;br/&gt;
Properties Last Updated: 2007-11-26 09:22:05 -0800 (Mon, 26 Nov 2007)&lt;/p&gt;

&lt;p&gt;When I run the attached test case with revision 603368, I get incorrect results, ie only one count is returned back.&lt;br/&gt;
$ java org.apache.derbyTesting.functionTests.tests.lang.DERBY_3257_Repro&lt;br/&gt;
Database product: Apache Derby&lt;br/&gt;
Database version: 10.4.0.0 alpha - (1)&lt;br/&gt;
Driver name:      Apache Derby Embedded JDBC Driver&lt;br/&gt;
Driver version:   10.4.0.0 alpha - (1)&lt;br/&gt;
result: 2&lt;/p&gt;</comment>
                            <comment id="12559758" author="kmarsden" created="Thu, 17 Jan 2008 00:21:43 +0000"  >&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3231&quot; title=&quot;Sorting on COUNT with OR and GROUP BY delivers wrong results.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3231&quot;&gt;&lt;del&gt;DERBY-3231&lt;/del&gt;&lt;/a&gt;, Manish mentioned.&lt;/p&gt;

&lt;p&gt;&amp;gt;Mike, I&apos;ll take a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3257&quot; title=&quot;SELECT with HAVING clause containing OR conditional incorrectly return 1 row - should return 2 rows - works correctly with 10.2 DB&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3257&quot;&gt;&lt;del&gt;DERBY-3257&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Manish, I was wondering if you have been able to make any progress on this issue. I&apos;d be willing to help in any way I can, adding tests, committing the change etc.  I am not sure exactly how much else I can offer. I thought I would try to educate myself by reading the notes attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt;, but have to admit I am a bit lost.  Any tips for the novice that you can offer would be greatly appreciated.&lt;/p&gt;</comment>
                            <comment id="12560034" author="kmarsden" created="Thu, 17 Jan 2008 19:06:21 +0000"  >&lt;p&gt;Attaching the query plans for 10.2 vs 10.4&lt;/p&gt;</comment>
                            <comment id="12560068" author="kmarsden" created="Thu, 17 Jan 2008 20:15:30 +0000"  >&lt;p&gt;Interestingly if I remove AND t0.CODE IS NOT NULL (there are no null codes to eliminate), I get the right result, two rows.&lt;br/&gt;
        PreparedStatement pstmt = conn.prepareStatement(&quot;SELECT t0.CODE, COUNT(t0.ID) FROM CTS1.TEST_TABLE t0 GROUP BY t0.CODE  HAVING (t0.CODE = ? OR t0.CODE = ?)&quot;);&lt;/p&gt;</comment>
                            <comment id="12560151" author="army" created="Thu, 17 Jan 2008 23:09:05 +0000"  >&lt;p&gt;I noticed that if the ordering of the predicates inside the HAVING clause is reversed, the query returns the &quot;other&quot; results, i.e:&lt;/p&gt;

&lt;p&gt;  &amp;#8211; Returns &quot;2&quot;&lt;br/&gt;
  SELECT COUNT(t0.ID) FROM TEST_TABLE t0&lt;br/&gt;
   GROUP BY t0.CODE HAVING (t0.CODE = &apos;GBR&apos; OR t0.CODE = &apos;CHA&apos;) AND t0.CODE IS NOT NULL;&lt;/p&gt;

&lt;p&gt;  &amp;#8211; Returns &quot;4&quot;&lt;br/&gt;
  SELECT COUNT(t0.ID) FROM TEST_TABLE t0&lt;br/&gt;
   GROUP BY t0.CODE HAVING (t0.CODE = &apos;CHA&apos; OR t0.CODE = &apos;GBR&apos;) AND t0.CODE IS NOT NULL;&lt;/p&gt;

&lt;p&gt;With a little tracing it turns out that the HAVING clause is somehow getting messed up during preprocessing.  More specifically, see line 883 in SelectNode.preprocess():&lt;/p&gt;

&lt;p&gt;    if (havingClause != null) &lt;/p&gt;
{
        havingClause = havingClause.preprocess(
                numTables, fromList, havingSubquerys, wherePredicates);
    }

&lt;p&gt;Before the call to &quot;havingClause.preprocess(...)&quot; the HAVING clause is correct:&lt;/p&gt;

&lt;p&gt;  havingClause ==&amp;gt; (OrNode AND NotNullNode)&lt;/p&gt;

&lt;p&gt;where:&lt;/p&gt;

&lt;p&gt;  &amp;#8211; OrNode ==&amp;gt; (BinaryRelationalOperatorNode_0  OR BinaryRelationalOperatorNode_1)&lt;br/&gt;
  &amp;#8211; BinaryRelationalOperatorNode_0 ==&amp;gt; (t0.CODE = &apos;GBR&apos;)&lt;br/&gt;
  &amp;#8211; BinaryRelationalOperatorNode_1 ==&amp;gt; (t0.CODE = &apos;CHA&apos;)&lt;/p&gt;

&lt;p&gt;But after the call to that method, the OrNode has been replaced with its left operand:&lt;/p&gt;

&lt;p&gt;  havingClause ==&amp;gt; (BinaryRelationalOperatorNode_0 AND NotNullNode)&lt;/p&gt;

&lt;p&gt;So we lose half of the OR condition, and that&apos;s why we end up with missing rows.  A good start for this issue would be to set a break point inside the above &quot;if&quot; statement and then trace through the preprocessing logic to see when/how/why the OrNode gets replaced with its left operand...&lt;/p&gt;</comment>
                            <comment id="12560161" author="army" created="Thu, 17 Jan 2008 23:40:36 +0000"  >&lt;p&gt;I started worrying that the underlying cause of this might be &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; after all, so I did a little more tracing.  From what I can tell, the code in OrNode.preprocess() that converts an OR chain into a IN list was doing the wrong thing--esp. it was only grabbing the left OR value, not the right.  If the same predicate appears in the WHERE clause the preprocessing is fine, though...&lt;/p&gt;

&lt;p&gt;It turns out that the OrNode preprocess() method expects everything to be normalized to Conjunctive Normal Form--and we do in fact normalize the WHERE as part of SelectNode.normExpressions().  But we do &lt;b&gt;NOT&lt;/b&gt; currently normalize the HAVING clause, so when the OrNode in the HAVING clause was preprocessed, we were doing the wrong thing.&lt;/p&gt;

&lt;p&gt;I made a very quick change to normalize the HAVING clause, as well, and the queries posted to this issue now return correct results (2 rows).  I have not run any other tests on it, though, so this might not be a valid fix.  But it does indicate what the problem is to some degree...&lt;/p&gt;

&lt;p&gt;Why this worked before &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; and fails after I&apos;m not sure, but given the scope of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; it seems quite possible that the changes for that issue affected HAVING predicates in a way such that normalization is now a requirement...?&lt;/p&gt;

&lt;p&gt;I&apos;m calling my quick change d3257_doNOTCommit.patch because I haven&apos;t tested it at all (except for the queries in this issue).  It should not be considered a viable approach until someone does more verification...&lt;/p&gt;</comment>
                            <comment id="12560164" author="army" created="Thu, 17 Jan 2008 23:50:16 +0000"  >&lt;p&gt;Sorry for the spam, attached wrong file last time.&lt;/p&gt;</comment>
                            <comment id="12560186" author="kmarsden" created="Fri, 18 Jan 2008 01:07:27 +0000"  >&lt;p&gt;Thanks Army for looking at this issue. I ran lang._Suite with the patch and see an interesting symptom that some queries are now throwing a 42X24 exception. e.g. in aggregate.sql&lt;/p&gt;

&lt;p&gt;select c1 from t1&lt;br/&gt;
group by c1&lt;br/&gt;
having max(c2) in (select c1 from t2);&lt;br/&gt;
ERROR 42X24: Column C1 is referenced in the HAVING clause but is not in the GROUP BY list.&lt;/p&gt;

&lt;p&gt;Thanks for the jump start though.  I will investigate what is going on with this error with the patch.  &lt;/p&gt;
</comment>
                            <comment id="12560206" author="kmarsden" created="Fri, 18 Jan 2008 03:16:48 +0000"  >&lt;p&gt;Here is the script to reproduce the 42X24 error message with the patch.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; run &apos;42X24_error.sql&apos;;&lt;br/&gt;
ij&amp;gt; connect &apos;jdbc:derby:wombat;create=true&apos;;&lt;br/&gt;
WARNING 01J01: Database &apos;wombat&apos; not created, connection made to existing database instead.&lt;br/&gt;
ij&amp;gt; drop table t1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; drop table t2;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table t1 (c1 int, c2 int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table t2 (c1 int, c2 int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table oneRow (c1 int, c2 int);&lt;br/&gt;
ERROR X0Y32: Table/View &apos;ONEROW&apos; already exists in Schema &apos;APP&apos;.&lt;br/&gt;
java.sql.SQLException: Table/View &apos;ONEROW&apos; already exists in Schema &apos;APP&apos;.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:202)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:391)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:1666)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1324)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:624)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:556)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:330)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:508)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:350)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.go(Main.java:215)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:181)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.main(Main.java:73)&lt;br/&gt;
        at org.apache.derby.tools.ij.main(ij.java:59)&lt;br/&gt;
Caused by: ERROR X0Y32: Table/View &apos;ONEROW&apos; already exists in Schema &apos;APP&apos;.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:371)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.duplicateDescriptorException(DataDictionaryImpl.java:167&lt;br/&gt;
3)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addDescriptor(DataDictionaryImpl.java:1664)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addDescriptor(DataDictionaryImpl.java:1643)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.CreateTableConstantAction.executeConstantAction(CreateTableConstantAction.j&lt;br/&gt;
ava:238)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.MiscResultSet.open(MiscResultSet.java:64)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1234)&lt;br/&gt;
        ... 10 more&lt;br/&gt;
ij&amp;gt; insert into oneRow values(1,1);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t1 values (null, null), (1,1), (null, null), (2,1), (3,1), (10,10);&lt;br/&gt;
6 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t2 values (null, null), (1,1), (null, null), (2,1), (3,1), (10,10);&lt;br/&gt;
6 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select c1 from t1&lt;br/&gt;
group by c1&lt;br/&gt;
having max(c2) in (select c1 from t2);&lt;br/&gt;
ERROR 42X24: Column C1 is referenced in the HAVING clause but is not in the GROUP BY list.&lt;br/&gt;
java.sql.SQLException: Column C1 is referenced in the HAVING clause but is not in the GROUP BY list.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:202)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:391)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:1666)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:613)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:556)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:330)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:508)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:350)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.go(Main.java:215)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:181)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.Main.main(Main.java:73)&lt;br/&gt;
        at org.apache.derby.tools.ij.main(ij.java:59)&lt;br/&gt;
Caused by: ERROR 42X24: Column C1 is referenced in the HAVING clause but is not in the GROUP BY list.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:290)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.GroupByNode.addNewColumnsForAggregation(GroupByNode.java:529)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.GroupByNode.addAggregates(GroupByNode.java:237)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.GroupByNode.init(GroupByNode.java:181)&lt;br/&gt;
        at org.apache.derby.iapi.sql.compile.NodeFactory.getNode(NodeFactory.java:273)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.SelectNode.genProjectRestrict(SelectNode.java:1242)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.SelectNode.modifyAccessPaths(SelectNode.java:1816)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.DMLStatementNode.optimizeStatement(DMLStatementNode.java:307)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.CursorNode.optimizeStatement(CursorNode.java:515)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:365)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConne&lt;br/&gt;
ctionContext.java:756)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:607)&lt;br/&gt;
        ... 9 more&lt;br/&gt;
ij&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12560469" author="kmarsden" created="Fri, 18 Jan 2008 17:24:20 +0000"  >&lt;p&gt;I notice that if I avoid normExpressions for SubqueryNodes, things seem to work ok for both the test case and 42X24_error.sql.  i.e.&lt;br/&gt;
		if (! (havingClause instanceof SubqueryNode))&lt;br/&gt;
		    havingClause = normExpressions(havingClause);&lt;/p&gt;

&lt;p&gt;I am not sure that this is the right solution.  I think I need a better understanding of why it is necessary for the havingClause to be in CNF before the call to preprocess and is it a problem to avoid that for SubqueryNodes.  I am running suites.All to see if there are any issues but would appreciate input on whether I am on the right track here.&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;



</comment>
                            <comment id="12560471" author="kmarsden" created="Fri, 18 Jan 2008 17:26:26 +0000"  >&lt;p&gt;TestHaving cannot be contributed to Apache. We will need to make another test.  Reattaching without grant license.&lt;/p&gt;</comment>
                            <comment id="12560494" author="army" created="Fri, 18 Jan 2008 18:37:46 +0000"  >&lt;p&gt;&amp;gt; I think I need a better understanding of why it is necessary for the havingClause&lt;br/&gt;
&amp;gt; to be in CNF before the call to preprocess&lt;/p&gt;

&lt;p&gt;This is a good question--and perhaps in the long run this is not requirement per se.  The only reason I thought to normalize the havingClause is because the OrNode.preprocess() method expects that the OrNode has been normalized.  I.e. it expects that the predicate:&lt;/p&gt;

&lt;p&gt;  &lt;span class=&quot;error&quot;&gt;&amp;#91;not normalized&amp;#93;&lt;/span&gt; =&amp;gt;  (t0.CODE = &apos;GBR&apos; OR t0.CODE = &apos;CHA&apos;)&lt;/p&gt;

&lt;p&gt;becomes&lt;/p&gt;

&lt;p&gt;  &lt;span class=&quot;error&quot;&gt;&amp;#91;normalized&amp;#93;&lt;/span&gt; =&amp;gt; (t0.CODE = &apos;GBR&apos; OR ((t0.CODE = &apos;CHA&apos;) OR FALSE))&lt;/p&gt;

&lt;p&gt;When it transforms the OR list into an IN list, then, it just walks the tree and grabs the left operand from all of the chained ORs.  So in the normalized case we grab:&lt;/p&gt;

&lt;p&gt;  1. t0.CODE = &apos;GBR&apos;&lt;br/&gt;
  2. t0.CODE = &apos;CHA&apos;&lt;/p&gt;

&lt;p&gt;From those two predicates we then get &quot;t0.CODE in (&apos;GBR&apos;, &apos;CHA&apos;)&quot;, which is correct.  If the HAVING clause is not normalized, though, then the logic in OrNode will only grab:&lt;/p&gt;

&lt;p&gt;  1. t0.CODE = &apos;GBR&apos;&lt;/p&gt;

&lt;p&gt;because there is only one OrNode and that&apos;s its left operand.   So we end up with &quot;t0.CODE in (&apos;GBR&apos;)&quot; and thus we miss the row for &apos;CHA&apos;.&lt;/p&gt;

&lt;p&gt;All of that said, maybe normalizing the HAVING clause is not the best solution, or perhaps it goes too far?  Maybe OrNode should be changed to recognize if it is NON-normalized and should not try to transform itself in that case?  If that&apos;s true, the follow-up question would be: Are there other places in the code that expect the having clause to be normalized, as well?&lt;/p&gt;

&lt;p&gt;It seems to me that something in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt; has exposed the HAVING clause to processing that was previously only applied to WHERE clauses.  If that&apos;s true, and if the change was intentional, then the HAVING clause should (in theory) have to go through the same pre-processing steps as the WHERE clause--which includes normalization.  If that change in behavior was not intentional, though, then maybe the fix for this issue is to somehow prevent WHERE-clause -specific processing from happening on the HAVING clause.  I don&apos;t know for sure, but that last option sounds pretty hard...&lt;/p&gt;

&lt;p&gt;&amp;gt; is it a problem to avoid &lt;span class=&quot;error&quot;&gt;&amp;#91;normalization&amp;#93;&lt;/span&gt; for SubqueryNodes?&lt;/p&gt;

&lt;p&gt;I would follow this up with two other questions:&lt;/p&gt;

&lt;p&gt;  1. What it is about normalization that causes problems for the SubqueryNode?  It looks like the 42X24 error comes because the result column referenced within the subquery has a &quot;source level&quot; that is the same as the outer query--and that is (apparently?) because the SuqbueryNode somehow &quot;disappears&quot; as a result of the normalization.  That suggests that perhaps the Subquery is being flattened during, or as a result of, normalization.  Without normalization, the SubqueryNode hangs around and its result column gets a source level that is different from the outer query, so the check in GroupByNode.addNewColumnsForAggregation() passes.&lt;/p&gt;

&lt;p&gt;  2. What happens if the same nested query appears in a WHERE clause and the WHERE clause is normalized?  Will the subquery be flattened during or after normalization?&lt;/p&gt;

&lt;p&gt;These two questions don&apos;t answer yours, but perhaps some investigation of them will lead to an answer.  If the answer is &quot;Yes, it&apos;s okay to avoid normalization for SubqueryNodes&quot;, then that leads to yet another question: are there other nodes for which it is okay to avoid normalization, as well?&lt;/p&gt;</comment>
                            <comment id="12560503" author="army" created="Fri, 18 Jan 2008 18:58:32 +0000"  >&lt;p&gt;Just noticed that the code which is failing with 42X24 was added as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt;.  The corresponding comments in that issue:&lt;/p&gt;

&lt;p&gt;&amp;lt;begin&amp;gt;&lt;/p&gt;

&lt;p&gt;Basically I want to ensure that there are no column references in the havingClause as the same nesting level as this query. I think the comments with the code are adequate explanation. A new SQLCode is used for this error.&lt;/p&gt;

&lt;p&gt;Since error checking depends on nestingLevel I had to fix up code to make sure that it was set correctly in various places.&lt;/p&gt;

&lt;p&gt;&amp;lt;end&amp;gt;&lt;/p&gt;

&lt;p&gt;Not sure if this is relevant or not, but I thought I&apos;d mention it since I was thinking the error was in code that had been around since before &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-681&quot; title=&quot;Eliminate the parser&amp;#39;s rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-681&quot;&gt;&lt;del&gt;DERBY-681&lt;/del&gt;&lt;/a&gt;...&lt;/p&gt;</comment>
                            <comment id="12560591" author="kmarsden" created="Fri, 18 Jan 2008 23:04:36 +0000"  >&lt;p&gt;Army asked;&lt;br/&gt;
&amp;gt;1. What it is about normalization that causes problems for the SubqueryNode?&lt;br/&gt;
In SubqueryNode.preProcess() there is this code&lt;br/&gt;
	flattenable = (resultSet instanceof SelectNode) &amp;amp;&amp;amp;&lt;br/&gt;
					  underTopAndNode &amp;amp;&amp;amp;&lt;br/&gt;
					  (isIN() || isANY() || isEXISTS() || flattenableNotExists ||       &lt;br/&gt;
                       parentComparisonOperator != null);&lt;/p&gt;

&lt;p&gt;Without normalization underTopAndNode is false and so we don&apos;t flatten.&lt;/p&gt;


</comment>
                            <comment id="12560745" author="kmarsden" created="Sat, 19 Jan 2008 23:13:53 +0000"  >&lt;p&gt;Attached is a patch to fix this issue. derby-3257_diff.txt.  It has Army&apos;s changes plus code to mark the subqueries that are in the having clause as such so that we can avoid flattenning during preprocess.  We clearly are not setup to handle subquery flattenning within the having clause and just happenned to avoid it before because the having clause was not normalized.  Adding the normalization meant we needed another mechanism to flag these subqueries to avoid flattenning.  Perhaps a better long term strategy would be to allow for flattenning of subqueries in the having clause, but I am guessing that is a fairly significant endeavor.&lt;/p&gt;
</comment>
                            <comment id="12561065" author="army" created="Mon, 21 Jan 2008 17:02:28 +0000"  >&lt;p&gt;Thank you for investigating this further, and for posting a complete patch, Kathey.  I verified that the new test case passes with the changes and fails without them.&lt;/p&gt;

&lt;p&gt;&amp;gt; We clearly are not setup to handle subquery flattenning within the having clause&lt;/p&gt;

&lt;p&gt;This is good to know.  Just curious: is there something in the code that makes this limitation explicit, or does this statement just follow from the fact that attempts to flatten such a subquery lead to other errors?&lt;/p&gt;

&lt;p&gt;Very minor nits on the patch that you can ignore if you choose:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Might be good to add another bullet to the list in the comment preceding the following&lt;br/&gt;
    line, so that the comments and the code match each other.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;        @@ -609,7 +615,7 @@&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;underTopAndNode &amp;amp;&amp;amp;&lt;br/&gt;
        +           underTopAndNode &amp;amp;&amp;amp; !havingSubquery &amp;amp;&amp;amp;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Likewise for the other, similar change further down in that method.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Some whitespace inconsistencies between new code and existing code.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Maybe the new test case in GroupByTest would be better called &quot;testOrNodeInHavingClause()&quot;&lt;br/&gt;
    instead of &quot;testDerby3257?&quot;  This doesn&apos;t affect the test at all, and the comments for the fixture&lt;br/&gt;
    clearly indicate what is being tested, so this is definitely &quot;nit-picking&quot;.  But a meaningful method&lt;br/&gt;
    name seems (to me, as reader of the test) slightly more convenient than the Derby Jira number.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But these nits aside, if you&apos;ve run derbyall and suites.All with this change and there were no failures, I think the patch can be committed...&lt;/p&gt;</comment>
                            <comment id="12561101" author="kmarsden" created="Mon, 21 Jan 2008 19:18:00 +0000"  >&lt;p&gt;Thanks Army for looking at the patch.&lt;br/&gt;
Attached is a revised patch derby-3257_diff2.txt with the changes you recommended.  I will commit this afternoon if I don&apos;t hear anything back.&lt;/p&gt;

&lt;p&gt;You asked&lt;br/&gt;
&amp;gt;Is there something in the code that makes this limitation explicit, or does this statement just follow from the fact that attempts to flatten such a subquery lead to other errors?&lt;/p&gt;

&lt;p&gt;Flattenning produces a column in the having clause that is not generated to replace an aggregate causing this condition to throw the exception:&lt;br/&gt;
if (!cr.getGeneratedToReplaceAggregate() &amp;amp;&amp;amp; &lt;br/&gt;
						cr.getSourceLevel() == level) &lt;/p&gt;
{
					throw StandardException.newException(
							SQLState.LANG_INVALID_COL_HAVING_CLAUSE, 
							cr.getSQLColumnName());						
				}

&lt;p&gt;I tried to understand why this condition was necessary by commenting it out and I ended up with a null pointer exception in the generated code when I had a select in the having clause.  I didn&apos;t pursue it much further than that and figured Manish put that condition and error there for good reason.  Perhaps there is a way to allow the flattenning of the subquery  but I was not able to figure out how to do it so went with this solution.&lt;/p&gt;

&lt;p&gt;I&apos;m hoping at some point.  Manish or someone else can take a look at this and come up with a more elegant solution allowing the subqueries to be flattenned in the having clause.  &lt;/p&gt;</comment>
                            <comment id="12561113" author="dyret" created="Mon, 21 Jan 2008 20:13:32 +0000"  >&lt;p&gt;Fwiw: I applied the first version of your patch and verified that the repro worked correctly. I also ran all the tests with the patch. I saw no failures. +1 to commit. And thanks for addressing this - one less regression to worry about &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12561384" author="kmarsden" created="Tue, 22 Jan 2008 17:21:32 +0000"  >&lt;p&gt;Looks like there were no issues with the nightlies due to this change.  I will check into 10.3 as soon as my tests complete.&lt;/p&gt;</comment>
                            <comment id="12561449" author="kmarsden" created="Tue, 22 Jan 2008 20:22:12 +0000"  >&lt;p&gt;Merged fix to 10.3 with revision  614304&lt;/p&gt;</comment>
                            <comment id="12562288" author="stan" created="Thu, 24 Jan 2008 23:12:43 +0000"  >&lt;p&gt;Catching up on Closing my reported issues.  Thanks to Dyre for the workflow reminder today.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12354628">DERBY-2034</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12325311">DERBY-681</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12373466" name="42X24_error.sql" size="452" author="kmarsden" created="Fri, 18 Jan 2008 03:16:48 +0000"/>
                            <attachment id="12373540" name="TestHaving.java" size="4707" author="kmarsden" created="Fri, 18 Jan 2008 17:26:26 +0000"/>
                            <attachment id="12373458" name="d3257_doNOTCommit.patch" size="2665" author="army" created="Thu, 17 Jan 2008 23:50:16 +0000"/>
                            <attachment id="12373610" name="derby-3257_diff.txt" size="7869" author="kmarsden" created="Sat, 19 Jan 2008 23:13:53 +0000"/>
                            <attachment id="12373697" name="derby-3257_diff2.txt" size="8623" author="kmarsden" created="Mon, 21 Jan 2008 19:18:00 +0000"/>
                            <attachment id="12373420" name="derby-3257_plan_10.2.txt" size="3557" author="kmarsden" created="Thu, 17 Jan 2008 19:06:21 +0000"/>
                            <attachment id="12373421" name="derby-3257_plan_10.4.txt" size="2412" author="kmarsden" created="Thu, 17 Jan 2008 19:06:21 +0000"/>
                            <attachment id="12373611" name="derby-3257_stat.txt" size="301" author="kmarsden" created="Sat, 19 Jan 2008 23:13:53 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 6 Dec 2007 17:01:36 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23526</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0uvb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38819</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>