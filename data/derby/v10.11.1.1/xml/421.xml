<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:16:03 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-421/DERBY-421.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-421] starting an XA transaction resets the isolation level set with SET CURRENT ISOLATION</title>
                <link>https://issues.apache.org/jira/browse/DERBY-421</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When an XA Transaction is started the isolation level set with SET CURRENT ISOLATION gets reset to CS.&lt;br/&gt;
Embedded setTransactionIsolation  does not have this problem but this problem is the root cause of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-414&quot; title=&quot;With Network Client starting an XA transaction resets the isolation level set with setTransactionIsolation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-414&quot;&gt;&lt;del&gt;DERBY-414&lt;/del&gt;&lt;/a&gt; because client implements setTransactionIsolation by sending SET CURRENT ISOLATION&lt;/p&gt;

&lt;p&gt;$ java TestSetCurrentIsolation&lt;br/&gt;
Database product: Apache Derby&lt;br/&gt;
Database version: 10.2.0.0 alpha&lt;br/&gt;
Driver name:      Apache Derby Embedded JDBC Driver&lt;br/&gt;
Driver version:   10.2.0.0 alpha&lt;br/&gt;
SET CURRENT ISOLATION = UR&lt;br/&gt;
CURRENT ISOLATION: UR&lt;br/&gt;
getTransactionIsolation:TRANSACTION_READ_UNCOMMITTED:1&lt;br/&gt;
Isolation level after xa start&lt;br/&gt;
CURRENT ISOLATION: CS&lt;br/&gt;
getTransactionIsolation:TRANSACTION_READ_COMMITTED:2&lt;br/&gt;
$&lt;/p&gt;


&lt;p&gt;import java.sql.*;&lt;/p&gt;

&lt;p&gt;import javax.sql.*;&lt;br/&gt;
import javax.transaction.xa.*;&lt;/p&gt;

&lt;p&gt;public class TestSetCurrentIsolation&lt;br/&gt;
{&lt;br/&gt;
    public static void main(String[] args) throws Throwable&lt;br/&gt;
    {&lt;br/&gt;
        try&lt;/p&gt;
        {
             final org.apache.derby.jdbc.EmbeddedXADataSource ds =
             new org.apache.derby.jdbc.EmbeddedXADataSource();
             ds.setDatabaseName(&quot;C:\\drivers\\derby\\databases\\SCHEDDB&quot;);
             ds.setUser(&quot;dbuser1&quot;);
             ds.setPassword(&quot;******&quot;);



            XAConnection xaConn = ds.getXAConnection();
            Connection conn = xaConn.getConnection();

            conn.setAutoCommit(true);

            System.out.println(&quot;Database product: &quot; + conn.getMetaData().getDatabaseProductName());
            System.out.println(&quot;Database version: &quot; + conn.getMetaData().getDatabaseProductVersion());
            System.out.println(&quot;Driver name:      &quot; + conn.getMetaData().getDriverName());
            System.out.println(&quot;Driver version:   &quot; + conn.getMetaData().getDriverVersion());

            Statement stmt = conn.createStatement();
            System.out.println(&quot;SET CURRENT ISOLATION = UR&quot;);
            stmt.executeUpdate(&quot;SET CURRENT ISOLATION = UR&quot;);
            showIsolationLevel(conn);
            conn.setAutoCommit(false);

            XAResource xaRes = xaConn.getXAResource();
            Xid xid = new TestXid(1,(byte) 32, (byte) 32);

            xaRes.start(xid, XAResource.TMNOFLAGS);
            System.out.println(&quot;Isolation level after xa start&quot;);
            showIsolationLevel(conn);
            
            xaRes.end(xid, XAResource.TMSUCCESS);
            xaRes.rollback(xid);


            conn.close();
            xaConn.close();
        }
&lt;p&gt;        catch (SQLException sqlX)&lt;/p&gt;
        {
            System.out.println(&quot;Error on thread 1.&quot;);
            do sqlX.printStackTrace();
            while ((sqlX = sqlX.getNextException()) != null);
        }
&lt;p&gt;        catch (Throwable th)&lt;/p&gt;
        {
            System.out.println(&quot;Error on thread 1.&quot;);
            do th.printStackTrace();
            while ((th = th.getCause()) != null);
        }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param conn&lt;/li&gt;
	&lt;li&gt;@throws SQLException&lt;br/&gt;
	 */&lt;br/&gt;
	private static void showIsolationLevel(Connection conn) throws SQLException 
{
		PreparedStatement ps = conn.prepareStatement(&quot;VALUES CURRENT ISOLATION&quot;);
		ResultSet rs = ps.executeQuery();
		//ResultSet rs = conn.createStatement().executeQuery(&quot;VALUES CURRENT ISOLATION&quot;);
		rs.next();
		System.out.println(&quot;CURRENT ISOLATION: &quot; +  rs.getString(1));
		System.out.println(&quot;getTransactionIsolation:&quot; + 
					getIsoLevelName(conn.getTransactionIsolation()));						
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public static String getIsoLevelName(int level)&lt;br/&gt;
	{&lt;br/&gt;
		switch (level) &lt;/p&gt;
{
			case java.sql.Connection.TRANSACTION_REPEATABLE_READ:
				return &quot;TRANSACTION_REAPEATABLE_READ:&quot; + level;
					
			case java.sql.Connection.TRANSACTION_READ_COMMITTED:
				return &quot;TRANSACTION_READ_COMMITTED:&quot; + level;
			case java.sql.Connection.TRANSACTION_SERIALIZABLE:
				return &quot;TRANSACTION_SERIALIZABLE:&quot; + level;
			case java.sql.Connection.TRANSACTION_READ_UNCOMMITTED:
				return &quot;TRANSACTION_READ_UNCOMMITTED:&quot; + level;

		}
&lt;p&gt;		return &quot;UNEXPECTED_ISO_LEVEL&quot;;&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;</description>
                <environment></environment>
        <key id="12311845">DERBY-421</key>
            <summary>starting an XA transaction resets the isolation level set with SET CURRENT ISOLATION</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12311791">DERBY-414</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                    </labels>
                <created>Fri, 1 Jul 2005 08:59:01 +0100</created>
                <updated>Thu, 26 Jan 2006 01:59:07 +0000</updated>
                            <resolved>Tue, 13 Sep 2005 13:52:21 +0100</resolved>
                                                    <fixVersion>10.1.2.1</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12314959" author="mamtas" created="Sun, 3 Jul 2005 13:18:48 +0100"  >&lt;p&gt;I did some debugging on this bug and here is the reason behind the current behavior.&lt;/p&gt;

&lt;p&gt;When SQL &quot;SET CURRENT ISOLATION = newValue&quot; is used in XA environment, outside the global transaction, it ends up calling GenericLanguageConnectionContext.setTransactionIsolation(). &lt;/p&gt;

&lt;p&gt;When JDBC api Connection.setTransactionIsolation is used, in XA environment, outside the global transaction, it calls BrokeredConnection.setTransactionIsolation(), which looks as follows&lt;br/&gt;
	public final void setTransactionIsolation(int level) throws SQLException &lt;br/&gt;
	{&lt;br/&gt;
		try &lt;/p&gt;
{
			getRealConnection().setTransactionIsolation(level);
			stateIsolationLevel = level;
		}
&lt;p&gt; catch (SQLException sqle) &lt;/p&gt;
{
			notifyException(sqle);
			throw sqle;
		}
&lt;p&gt;	}&lt;br/&gt;
Just like in the case of sql processing, getRealConnection().setTransactionIsolation(level) ends up in GenericLanguageConnectionContext.setTransactionIsolation(). And so the behavior with JDBC api and SQL is the same so far. But with JDBC api, the additional step of setting stateIsolationLevel in BrokeredConnection to the new isolation level happens but this step is missing when using SQL. Later, when global transaction is started, in EmbedXAConnection.start(), the value of stateIsolationLevel gets used but this variable does not have updated value when coming through the SQL &quot;SET CURRENT ISOLATION = newValue&quot;.&lt;/p&gt;

&lt;p&gt;What I don&apos;t understand is why do we have to keep the isolation level and readonly information is BrokeredConnection.java. We need to keep autocommit and holdability information because they get changed by Derby inside the global transaction to false and CLOSE_CURSORS_ON_COMMIT and we need to restore the original values when the connection is out of the global transaction. But why do we have to keep the state information for isolation level and readonly. I think once I understand this, I will be able to make more progress on the bug.&lt;/p&gt;
</comment>
                            <comment id="12314961" author="mamtas" created="Sun, 3 Jul 2005 16:22:48 +0100"  >&lt;p&gt;If anyone knows of the history behind state information related to isolation level and readonly mode in BrokeredConnection, please share them. &lt;/p&gt;</comment>
                            <comment id="12317181" author="mamtas" created="Sat, 30 Jul 2005 01:03:04 +0100"  >&lt;p&gt;I have been on vacation for last 3 weeks so didn&apos;t get a chance to followup further on this issue. Does anyone have any comments on why we keep the state information about isolation level and readonly?&lt;/p&gt;</comment>
                            <comment id="12317372" author="djd" created="Tue, 2 Aug 2005 07:35:13 +0100"  >&lt;p&gt;State information is kept in BrokeredConnection for this reason (comment in BrokeredConnection)&lt;br/&gt;
	/**&lt;br/&gt;
		Maintain state as seen by this Connection handle, not the state&lt;br/&gt;
		of the underlying Connection it is attached to.&lt;br/&gt;
	*/&lt;/p&gt;

&lt;p&gt;To expand on that, an application getting a Connection C from an XADataSource/XAConnection can use C in local mode or in global mode. The application can set  C&apos;s state with various setXXX calls, and thus the applcation has expectation of what the state is. When C is connected to a local transaction, the state of the connection needs to match any state set by the application. When C is attached an existing  global transaction the C&apos;s state needs to match that of the exsiting transaction, not the state as expected by the application. Then when reverting to local mode,  the state needs to be reset as the application expects it.&lt;br/&gt;
Here&apos;s a simple example.&lt;/p&gt;

&lt;p&gt;c.setReadOnly(true);&lt;br/&gt;
// do some local work&lt;/p&gt;

&lt;p&gt;// now attach to an existing global transaction&lt;br/&gt;
c.isReadOnly(); // returns false as the transaction has included modifications&lt;/p&gt;

&lt;p&gt;// now detach from the global transaction&lt;/p&gt;

&lt;p&gt;// This is the critical point&lt;br/&gt;
c..isReadOnly();  // needs to return true because that&apos;s what the application is expecting&lt;/p&gt;

&lt;p&gt;Thus the BrokeredConnection maintains the state that it needs to set on the new local underlying EmbedConnection object to ensure its state is in sync with the application&apos;s expectation. This is also because the Derby embedded implementation always creates a new EmbedConnection object when switching from global to local.&lt;/p&gt;</comment>
                            <comment id="12319679" author="mamtas" created="Tue, 23 Aug 2005 16:07:37 +0100"  >&lt;p&gt;Attaching a patch for this JIRA entry. Following is some information on the patch.&lt;/p&gt;

&lt;p&gt;When a connection object is obtained through XADataSource, it can be part of a local transaction or it can be attached to a global transaction. The state of the connection object can be different depending on whether it is used in local transaction or global transaction. Among other state information, isolation level is saved as part of the connection object&apos;s state information. This isolation level state is set correctly when isolation level is set using JDBC api. But it gets out of sync when SQL is used to set the isolation level state. In order to fix this, I have added a flag in GenericLanguageConnectionContext which will get set to true anytime isolation level is set using JDBC/SQL api. And this flag is later used to keep the isolation level state information uptodate in BrokeredConnection. The classes changed by this fix are as follows.&lt;/p&gt;

&lt;p&gt;svn stat&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\conn\GenericLanguageConnectionContext.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\sql\conn\LanguageConnectionContext.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\jdbc\BrokeredConnection.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\jdbc\BrokeredConnectionControl.java&lt;br/&gt;
M      java\engine\org\apache\derby\jdbc\EmbedPooledConnection.java&lt;br/&gt;
M      java\engine\org\apache\derby\jdbc\EmbedXAConnection.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\jdbcapi\checkDataSource.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\checkDataSource.out&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\checkDataSource30.out&lt;/p&gt;</comment>
                            <comment id="12319732" author="djd" created="Wed, 24 Aug 2005 01:54:38 +0100"  >&lt;p&gt;I&apos;ll look into committing the patch&lt;/p&gt;</comment>
                            <comment id="12319883" author="djd" created="Thu, 25 Aug 2005 03:08:06 +0100"  >&lt;p&gt;A few questions on the patch:&lt;/p&gt;

&lt;p&gt;1) In BrokeredConnection.setState() the method getIsolationUptoDate() is called. This new method updates the BrokeredConnection state according to the state of the underlying connection, but the purpose and description of the setState() method is the opposite. Thus this method call looks out pf place. Additional comments indicating why it is here would be useful.&lt;/p&gt;

&lt;p&gt;2) The new field isolationLevelSetUsingSQLorJDBC in GenericLanguageConnectionContext seems to have similar functionality to the existing field isolationLevelExplicitlySet. Are two fields really required? Usually multiple similar state fields is a recipe for bugs.&lt;/p&gt;

&lt;p&gt;3)  The number of new methods to acheive this functionality seems high, I wonder if there is a simpler approach, it would be easier to tell if you could expand on your comment  &apos;And this flag is later used to keep the isolation level state information uptodate in BrokeredConnection.&apos; Could you comment on exactly when this flag is used to reset the state?&lt;/p&gt;</comment>
                            <comment id="12320405" author="mamtas" created="Mon, 29 Aug 2005 17:38:14 +0100"  >&lt;p&gt;As for question 2), regarding the existing field isolationLevelExplicitlySet, I see that it gets set to true when the isolation level is set using JDBC or SQL. But I don&apos;t see it getting reset to false. Maybe someone who has worked on this flag can share the purpose of this flag. I noticed that this flag gets used later in GenericStatement.prepMinion to set the isolation level of the CompilerContext. &lt;/p&gt;

&lt;p&gt;What I need is some kind of flag which will get set to true if isolation has been set using JDBC or SQL in a given&lt;br/&gt;
transaction. When entering/exiting a global transaction later, I want to see if the flag is set to true and if so, set the isolation state in BrokeredConnection to that of EmbedConnection (since the isolation state in BrokeredConnection can be incorrect if SQL was used to set the isolation level). After this state update in BrokeredConnection, I want to reset the flag back to false. I don&apos;t think I can use isolationLevelExplicitlySet for this functionality but more information will clarify this more.&lt;/p&gt;</comment>
                            <comment id="12320442" author="kmarsden" created="Tue, 30 Aug 2005 03:43:32 +0100"  >&lt;p&gt;BACKGROUND:&lt;br/&gt;
For JCC connections to Network Server, when the user sets the isolaton with setTransactionIsolation,   the isolation level is encoded in each subsequent statement&apos;s package name  rather than being set for the connection.   see DRDAStatement.setPkgnamcsn(String pkgnamcsn) for the package name format.   Network server calls setPrepareIsolation(level) to set prepareIsolationLevel when  this occurs and the statement gets prepared with that isolation level.&lt;/p&gt;

&lt;p&gt;As I recall,  if the isolation level is  set  with an SQL statement it basically overrides the prepare isolation, isolationLevelExplicitlySet gets  set and the prepareIsolation is ignored. &lt;/p&gt;

&lt;p&gt;I don&apos;t  think it can get reset back to false, because that would turn off the override.  &lt;/p&gt;

&lt;p&gt;In the case you describe I don&apos;t quite understand why it would be desirable to set the flag to false after updating the state.  If we did, wouldn&apos;t that  cause trouble  if we started another  global transaction later?&lt;/p&gt;
</comment>
                            <comment id="12320544" author="mamtas" created="Tue, 30 Aug 2005 18:21:38 +0100"  >&lt;p&gt;Kathey, thanks for your explanation of prepareIsolationLevel in GenericLanguageConnectionContext.java. &lt;/p&gt;

&lt;p&gt;As for your question, following set of steps hopefully will help understand why the flag needs to be reset.&lt;/p&gt;

&lt;p&gt;Say, the user application has following code.&lt;br/&gt;
XAConnection xac = xaDataSource.getXAConnection();&lt;br/&gt;
At this point, xac will be EmbedXAConnection object with real database connection EmbedConnection in it.&lt;/p&gt;

&lt;p&gt;The user application can then request a connection handle (BrokeredConnection) from EmbedXAConnection. Derby will set the state of this connection handle to that of the real database connection.&lt;br/&gt;
Connection con = xac.getConnection();&lt;/p&gt;

&lt;p&gt;Let&apos;s say the local transaction then sets the state using JDBC api&lt;br/&gt;
con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);&lt;br/&gt;
This call will change the isolation level of the real database connection to the new value and the state of the connection handle also gets set correctly inside BrokeredConnection.setTransactionIsolation method.&lt;/p&gt;

&lt;p&gt;But if the local transaction sets the state using SQL&lt;br/&gt;
BrokeredStatement.executeUpdate(&quot;set current isolation = RR&quot;);&lt;br/&gt;
real database connection&apos;s isolation level gets set to new value but the state information in BrokeredConnection doesn&apos;t.&lt;/p&gt;

&lt;p&gt;Now if the user application says&lt;br/&gt;
XAResource.start(xid, XAResource.TMNOFLAGS);&lt;br/&gt;
Before starting a global transaction, EmbedXAConnection&apos;s start method checks if there is already a real database connection and a handle to it. If yes, it calls connection handle&apos;s setState(true). (The current Derby code without my changes) sets the state of the real database connection object to the handle&apos;s state. But handle&apos;s state is out of sync at this point because of earlier SQL set current isolation. And hence the state setting onto real connection will be incorrect. (this is the cause of Derby-421) &lt;/p&gt;

&lt;p&gt;To fix this, I have a call to connection handle&apos;s (BrokeredConnection&apos;s) getIsolationUptoDate() method prior to setting the real connection&apos;s state to connection handle&apos;s state. If the isolation was changed via JDBC/SQL, the connection handle&apos;s state will be brought to the correct value, and the flag used to keep track of isolation level change will be set to false.&lt;/p&gt;

&lt;p&gt;Similar thing needs to happen when the global transaction is ended because isolation level could have been set using SQL inside the global transaction as shown below.&lt;br/&gt;
BrokeredStatement.executeUpdate(&quot;set current isolation = UR&quot;);&lt;br/&gt;
Again, this will update the real database connection&apos;s isolation to UR, but BrokeredConnection&apos;s state does not get changed.&lt;/p&gt;

&lt;p&gt;To correct the state information of BrokeredConnection, when the global transation is ended as follows&lt;br/&gt;
XAResource.end(xid, XAResource.TMSUCCESS);&lt;br/&gt;
EmbedXAConnection&apos;s end method checks if the BrokeredConnection is not null. If not null, it brings the isolation level upto date by calling BrokeredConnection.getIsolationUptoDate and then resets the flag.&lt;/p&gt;

&lt;p&gt;If say, the flag is not reset after fixing the BrokeredConnection&apos;s state information during the global transaction start and end times, then once isolation level is changed in a global transaction, local transaction will always take the isolation level of last global transaction that just ended. This is incorrect. Local transaction should take the isolation level of last global transaction only if the isolation level was changed in that transaction. Following is the incorrect behavior with no flag resetting:&lt;/p&gt;

&lt;p&gt;Start a local transaction. &lt;br/&gt;
	isolation level default CS&lt;br/&gt;
Start global transaction 1&lt;br/&gt;
	isolation level default CS&lt;br/&gt;
	Change isolation level in global transaction 1 to UR(the flag gets set to true at this point)&lt;br/&gt;
Exit global transaction 1. Isolation level is local transaction&lt;br/&gt;
	isolation level UR&lt;br/&gt;
	Change isolation level in local transaction to RS&lt;br/&gt;
Start global transaction 2&lt;br/&gt;
	isolation level RS&lt;br/&gt;
End global transaction 2 and rejoin global transaction 1&lt;br/&gt;
	isolation level UR&lt;br/&gt;
Exit global transaction 1. The isolation level in local transaction at this point should have been RS but it got set to UR which is the last global transaction&apos;s isolation level. This happened because the flag was not reset to false at the end of first global transaction when the isolation was set using JDBC/SQL.&lt;/p&gt;

&lt;p&gt;Kathey, I hope this is not too much information and helps answer your question. If I have missed a scenario in which we could run into problem, let me know.&lt;/p&gt;

&lt;p&gt;Also, Dan, I am making couple changes to the code and putting some more comments and will send a new review package soon(after running the tests) with explanation as to why we need so many methods.&lt;/p&gt;</comment>
                            <comment id="12320661" author="mamtas" created="Wed, 31 Aug 2005 14:28:23 +0100"  >&lt;p&gt;Here is another review package with more code comments and little reorganization of the code. The files changed remain the same&lt;br/&gt;
as the previous patch.&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\conn\GenericLanguageConnectionContext.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\sql\conn\LanguageConnectionContext.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\jdbc\BrokeredConnection.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\jdbc\BrokeredConnectionControl.java&lt;br/&gt;
M      java\engine\org\apache\derby\jdbc\EmbedPooledConnection.java&lt;br/&gt;
M      java\engine\org\apache\derby\jdbc\EmbedXAConnection.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\jdbcapi\checkDataSource.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\checkDataSource.out&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\checkDataSource30.out&lt;/p&gt;

&lt;p&gt;This patch gets the isolation level state information in BrokeredConnection in sync with the Real Connection&apos;s isolation level&lt;br/&gt;
state. This is necessary because any isolation level changes using SQL do not get to BrokeredConnection and hence &lt;br/&gt;
BrokeredConnection can end with the incorrect isolation level state. The change adds a new flag in &lt;br/&gt;
GenericLanguageConnectionContext, namely isolationLevelSetUsingSQLorJDBC. This flag gets set to true anytime isolation level&lt;br/&gt;
is changed using JDBC or SQL. Later, at the start and end of a global transaction, EmbedXAConnection checks if the flag is&lt;br/&gt;
set to true and if yes, it puts the real connection&apos;s isolation level into into BrokeredConnection and then resets the flag&lt;br/&gt;
in GenericLanguageConnectionContext. The reason for adding methods for this flag maintenance in both BrokeredConnection&lt;br/&gt;
and EmbedPooledConnection is that BrokeredConnection does not have access to GenericeLanguageConnectionContext which has&lt;br/&gt;
the flag. EmbedPooledConnection does have access to GenericLanguageConnectionContext and hence the methods in &lt;br/&gt;
BrokeredConnection have to go through EmbedPooledConnection.&lt;/p&gt;

&lt;p&gt;I have run the tests and the patch didn&apos;t cause any failures.&lt;/p&gt;</comment>
                            <comment id="12322756" author="djd" created="Wed, 7 Sep 2005 03:58:17 +0100"  >&lt;p&gt;Thanks for the explanations and improved comments on the code. I&apos;ll submit this patch but there are opportunities to reduce the code.&lt;/p&gt;

&lt;p&gt;1) Note that the flag you&apos;ve added is always required to be reset once it is read, thus the reset could be combined into the method used to read it,&lt;br/&gt;
thus removing the two reset methods.&lt;/p&gt;

&lt;p&gt;2) It&apos;s possible as well that the read method could instead return the isolation level needed to be stored in the BrokeredConnection (logical connection). Thus this would remove an extra method call and remove the need for the try catch block, as the method returning the isolation level would not need to declare throing any exceptions.&lt;/p&gt;

&lt;p&gt;3) Possibly the start() and end() methods could get the isolation level (since they have a reference to the physical connection as an EmbedConnection) and pass it into BrokeredConnection, thus removing the need for the methods added to EmbedPooledConnection &lt;/p&gt;</comment>
                            <comment id="12322966" author="mamtas" created="Fri, 9 Sep 2005 06:34:14 +0100"  >&lt;p&gt;I merged the main codeline changes for this bug into 10.1 codeline on my machine and ran all the tests and they ran with no new failures. Here is the merge command I used on 10.1 codeline &lt;br/&gt;
svn merge -r 279086:279087 &lt;a href=&quot;https://svn.apache.org/repos/asf/db/derby/code/trunk/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/repos/asf/db/derby/code/trunk/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can a commiter please commit this onto 10.1 codeline? This is the first time merging from main to branch for me, so let me know if a commiter would need more information to commit this.&lt;/p&gt;</comment>
                            <comment id="12322978" author="kmarsden" created="Fri, 9 Sep 2005 08:47:59 +0100"  >&lt;p&gt;commtted this to 10.1&lt;/p&gt;

&lt;p&gt;Date: Thu Sep  8 15:45:47 2005&lt;br/&gt;
New Revision: 279665&lt;br/&gt;
URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=279665&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=279665&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12324285" author="mamtas" created="Tue, 13 Sep 2005 13:52:21 +0100"  >&lt;p&gt;The fix went into both 10.2 and 10.1 codeline&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12311900" name="derby421XAIsolation082205.txt" size="16250" author="mamtas" created="Tue, 23 Aug 2005 16:07:37 +0100"/>
                            <attachment id="12312102" name="derby421XAIsolation083005.txt" size="17631" author="mamtas" created="Wed, 31 Aug 2005 14:28:23 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 3 Jul 2005 12:18:48 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29536</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy17af:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40831</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>