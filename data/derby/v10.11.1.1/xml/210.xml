<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:26:50 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-210/DERBY-210.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-210] Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed</title>
                <link>https://issues.apache.org/jira/browse/DERBY-210</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Network server will not garbage collect prepared statements that are not explicitly closed by the user.  So  a loop like this will leak.&lt;/p&gt;

&lt;p&gt;...&lt;br/&gt;
PreparedStatement ps;&lt;/p&gt;

&lt;p&gt; for (int i = 0 ; i  &amp;lt; numPs; i++)&lt;br/&gt;
	{&lt;/p&gt;

&lt;p&gt;	 ps = conn.prepareStatement(selTabSql);&lt;br/&gt;
	 rs =ps.executeQuery();&lt;/p&gt;

&lt;p&gt;	 while (rs.next())&lt;/p&gt;
	{
	    rs.getString(1);
	}
&lt;p&gt;	rs.close();&lt;br/&gt;
	// I&apos;m a sloppy java programmer&lt;br/&gt;
	//ps.close();&lt;/p&gt;

&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;To reproduce run the attached program &lt;br/&gt;
java derbyStress&lt;/p&gt;

&lt;p&gt;Both client and server will grow until the connection is closed.&lt;/p&gt;


&lt;p&gt;It is likely that the fix for this will have to be in the client.  The client does not send protocol to close the prepared statement, but rather reuses the PKGNAMCSN on the PRPSQLSTT request once the prepared statement has been closed. This is how the server knows to close the old statement and create a new one.&lt;/p&gt;</description>
                <environment></environment>
        <key id="31585">DERBY-210</key>
            <summary>Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                            <label>derby_triage10_9</label>
                    </labels>
                <created>Mon, 11 Apr 2005 11:07:11 +0100</created>
                <updated>Mon, 20 Feb 2012 22:18:13 +0000</updated>
                                            <version>10.0.2.0</version>
                                                    <component>Network Client</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>2</watches>
                                                                                                            <comments>
                            <comment id="65369" author="kmarsden" created="Sat, 14 May 2005 08:48:58 +0100"  >&lt;p&gt;This is actually a client issue. There is no protocol in the specification to close a prepared statement, but if the client, reuses section numbers in the PKGNAMCSN for prepared statements  that are no longer referenced by the user, this leak could be mitigated.  Maybe WeakReference could be utilized for this purpose.&lt;/p&gt;

</comment>
                            <comment id="12315888" author="kmarsden" created="Fri, 15 Jul 2005 13:06:27 +0100"  >&lt;p&gt;The workaround for this issue is for the application to explicitly close all prepared statements.  The close  is often omitted for error conditions causing slow leaks. Applications can&apos;t  rely on garbage collection to clean up prepared statements.&lt;/p&gt;

&lt;p&gt;A good way to  diagnose which statements are leaking if you have this &lt;br/&gt;
problem is to run&lt;br/&gt;
    java org.apache.derby.drda.NetworkServerControl runtimeinfo&lt;/p&gt;

&lt;p&gt;runtimeinfo shows the statements currently open on the server.&lt;/p&gt;</comment>
                            <comment id="12362697" author="deepa" created="Sat, 14 Jan 2006 07:42:42 +0000"  >&lt;p&gt;I have attached a partial patch &apos;derby-210-patch1.diff&apos; for this problem. It does not solve the entire memory leak problem. &lt;/p&gt;

&lt;p&gt;PreparedStatement references are stored by client driver at following places:&lt;br/&gt;
1. In org.apache.derby.client.am.Connection, they are added to java.util.LinkedList &apos;openStatements_&apos; &lt;br/&gt;
2. In org.apache.derby.client.am.Connection, they are added to java.util.LinkedList &apos;CommitAndRollbackListeners_&apos; &lt;/p&gt;

&lt;p&gt;This patch eliminates the above references by using WeakHashMap instead of LinkedList. When there are no other references to the keys in a WeakHashMap, they will get removed from the map and can thus get garbage-collected. They do not have to wait till the Connection object is collected. &lt;/p&gt;

&lt;p&gt;I removed the list RollbackOnlyListeners_ since this is not being used. &lt;/p&gt;

&lt;p&gt;I have also updated the following comment for openStatements_: &lt;br/&gt;
// Since DERBY prepared statements must be re-prepared after a commit,&lt;br/&gt;
// then we must traverse this list after a commit and notify statements&lt;br/&gt;
// that they are now in an un-prepared state.&lt;br/&gt;
final java.util.LinkedList openStatements_ = new java.util.LinkedList();&lt;/p&gt;

&lt;p&gt;In the code, I did not see this list being traversed after a commit to re-prepare statements. Also, I think this is not needed since Derby does not require re-prepare of statements after a commit. Currently, this list is used to close all open statements when the originating connection is closed. &lt;/p&gt;

&lt;p&gt;With this patch, I ran derbyall successfully with Sun JDK 1.4.2 on Windows XP. I&apos;d appreciate if someone can review this patch and provide me feedback.&lt;/p&gt;</comment>
                            <comment id="12362709" author="deepa" created="Sat, 14 Jan 2006 11:19:14 +0000"  >&lt;p&gt;I don&apos;t have a patch ready for the rest of the problem. But I have narrowed it down to this:&lt;/p&gt;

&lt;p&gt;The only other reference holding on to the PreparedStatement is in the ResultSet object which remains alive till the PreparedStatement is closed. ResultSet does not get garbage-collected even after ResultSet.close() is called. It gets ready for grabage-collection only when the statement which created it is closed. This is because client driver holds references to ResultSets in a Hashtable &apos;positionedUpdateCursorNameToResultSet_&apos; in SectionManager object. All ResultSets get added to this Hashtable  though only ResultSets from positioned update statements are retrieved and used from this table. Also, only ResultSets of positioned update statements get removed from the HashTable. Other ResultSets remain in the Hashtable. So ResultSet objects cannot get finalized even after ResultSet.close() is called. Because ResultSet has reference to the PreparedStatement object, it also does not get garbage-collected.&lt;/p&gt;

&lt;p&gt;However, when PreparedStatement.close() is called, the section used by the statement is freed and gets re-used by new statements. Server cursor names are associated with a section and so the new statement uses the same server cursor name as previous statement (which has been closed). And ResultSet from new statement gets added to the HashTable with same cursor name as used by previous statement. So the Hashtable value gets over-written and previous ResultSet is now free for garbage collection. And the previous PreparedStatement is also free.&lt;/p&gt;

&lt;p&gt;To verify this, I added following line to the method Statement.resetCursorNameAndRemoveFromWhereCurrentOfMappings&lt;/p&gt;

&lt;p&gt;//Also remove resultset mapping for other cursors&lt;br/&gt;
agent_.sectionManager_.removeCursorNameToResultSetMapping(cursorName_,&lt;br/&gt;
                    section_.getServerCursorName());&lt;/p&gt;

&lt;p&gt;It was only doing this:&lt;br/&gt;
agent_.sectionManager_.removeCursorNameToResultSetMapping(cursorName_,&lt;br/&gt;
                    section_.getServerCursorNameForPositionedUpdate());&lt;/p&gt;

&lt;p&gt;With this change and  changes from derby-210-patch1.diff, prepared statements get garbage collected even if the user does not explicitly close them. I could run the attached repro derbyStress.java with 40000 prepared statements. I also successfully ran derbynetclientmats.&lt;/p&gt;

&lt;p&gt;Adding the above line seems to solve the problem. But there seems to be some extra work going on in client driver in just adding and removing &quot;all&quot; result sets to the Hashtable &apos;positionedUpdateCursorNameToResultSet_&apos;. I think this can be avoided. I am trying to understand why positionedUpdateCursorNameToResultSet_ is needed. In the meantime, I&apos;d appreciate any feedback to know that I am in right direction.&lt;/p&gt;</comment>
                            <comment id="12362711" author="bryanpendleton" created="Sat, 14 Jan 2006 11:38:47 +0000"  >&lt;p&gt;If I understand your comment correctly, you feel that you now have a correct fix, which avoids the memory leaks; however, you are concerned that there is a performance problem because the tracking of the ResultSet objects in the SectionManager hashtable is in some or all cases unnecessary.&lt;/p&gt;

&lt;p&gt;In that case, my opinion is that you should commit the correctness fix now, and file the performance issue as a separate bug and address it separately.&lt;/p&gt;

&lt;p&gt;I will try to take a closer look at your changes over the next week and I will let you know if I have any other comments.&lt;/p&gt;</comment>
                            <comment id="12362873" author="deepa" created="Tue, 17 Jan 2006 03:28:27 +0000"  >&lt;p&gt;I am uploading a combined patch &apos;derby-210.diff&apos; which solves the memory leak. As Bryan suggested, I am uploading this patch and will open jira issues for other optimizations. Patch does the following:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Eliminates the below references to PreparedStatement objects by using WeakHashMap instead of LinkedList. When there are no other references to the keys in a WeakHashMap, they will get removed from the map and can thus get garbage-collected. They do not have to wait till the Connection object is collected.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&apos;openStatements_&apos; in org.apache.derby.client.am.Connection&lt;/li&gt;
	&lt;li&gt;&apos;CommitAndRollbackListeners_&apos; in org.apache.derby.client.am.Connection&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Removes the list &apos;RollbackOnlyListeners_&apos; since this is not being used.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Updates the following comment for openStatements_:&lt;br/&gt;
// Since DERBY prepared statements must be re-prepared after a commit,&lt;br/&gt;
// then we must traverse this list after a commit and notify statements&lt;br/&gt;
// that they are now in an un-prepared state.&lt;br/&gt;
final java.util.LinkedList openStatements_ = new java.util.LinkedList();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In the code, I did not see this list being traversed after a commit to re-prepare statements. Also, I think this is not needed since Derby does not require re-prepare of statements after a commit. Currently, this list is used to close all open statements when the originating connection is closed.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Removes all ResultSets from HashTable &apos;positionedUpdateCursorNameToResultSet_&apos; in SectionManager. Only result sets of positioned update statements were being removed from this hashtable whereas all result sets were added. Because of this, client driver was holding on to result sets and statements even after rs.close() was called.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Adds a test &apos;derbyStress.java&apos; to jdbcapi suite. This test is based on the repro for this patch. Without this patch, it fails when run with client driver. Kathey had suggested in another mail that tests for client memory leak problems (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-557&quot; title=&quot;Client driver gets OutOfMemoryError when re-executing statement without closing ResultSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-557&quot;&gt;&lt;del&gt;DERBY-557&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;) can be added to same test. I did not see an existing test. So I created this new test. If &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-557&quot; title=&quot;Client driver gets OutOfMemoryError when re-executing statement without closing ResultSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-557&quot;&gt;&lt;del&gt;DERBY-557&lt;/del&gt;&lt;/a&gt; does not have a test, I think it can be added to this new test.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Excludes the new test from running with jcc because jcc gives out of memory error.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Creates &apos;derbyStress_app.properties&apos; with following property &apos;jvmflags=-Xmx64M&apos; to guarantee the test fails on all machines.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Successfully ran derbyall with Sun JDK 1.4.2 on Windows XP. Please take a look at this patch.&lt;/p&gt;</comment>
                            <comment id="12362900" author="kmarsden" created="Tue, 17 Jan 2006 09:19:39 +0000"  >&lt;p&gt;Committed this patch.&lt;/p&gt;

&lt;p&gt;Date: Mon Jan 16 16:10:58 2006&lt;br/&gt;
New Revision: 369612&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=369612&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=369612&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thank you Deepa for resolving this important client issue.    I think that this might be a good candidate to port to 10.1.  Do you see any issues/risks associated  with porting this fix  to 10.1? &lt;/p&gt;

&lt;p&gt;Also I will add some additional cleanup comments to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-817&quot; title=&quot;Improvements to Network Client driver - analyze/improve use of java collection classes in the code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-817&quot;&gt;DERBY-817&lt;/a&gt;.&lt;/p&gt;
</comment>
                            <comment id="12362980" author="deepa" created="Wed, 18 Jan 2006 01:05:23 +0000"  >&lt;p&gt;Attaching a patch &apos;derby-210_10.1.diff&apos; for 10.1 branch. I could not merge the changes because of conflict in &apos;DerbyNet.exclude&apos; file. Also I had to add the method &apos;cleanUpTest&apos; from TestUtil.java to 10.1 as my test uses this new method.&lt;/p&gt;

&lt;p&gt;Ran derbyall in 10.1 with Sun JDK 1.4.2 on Windows XP.  Only 1 intermittent failure in lang/ConcurrentImplicitCreateSchema.java.&lt;/p&gt;</comment>
                            <comment id="12363147" author="deepa" created="Thu, 19 Jan 2006 04:38:57 +0000"  >&lt;p&gt;This patch is causing a regression in the nightlies with Sun JDK1.5. The test lang/updatableResultset.java is failing in derbynetclientmats on this jvm.&lt;/p&gt;

&lt;p&gt;Kathey, can you please revert the patch from trunk? I will try to see what is causing this failure and upload a new patch.&lt;/p&gt;</comment>
                            <comment id="12363172" author="kmarsden" created="Thu, 19 Jan 2006 06:58:19 +0000"  >&lt;p&gt;I reverted this patch and ran derbynetclientmats&lt;br/&gt;
I saw two failures also in nightlies:&lt;/p&gt;

&lt;p&gt;jdbcapi/metadata.java&lt;br/&gt;
lang/syscat.sql&lt;/p&gt;

&lt;p&gt;Date: Wed Jan 18 13:55:36 2006&lt;br/&gt;
New Revision: 370275&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=370275&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=370275&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12363439" author="deepa" created="Sat, 21 Jan 2006 04:40:53 +0000"  >&lt;p&gt;I looked into the failure in lang/updatableResultSet.java with derbynetclient on JDK 1.5 and this is what I found:&lt;/p&gt;

&lt;p&gt;This test was failing after my patch for derby-210 was committed. The failure occurs in the following part of the test. I have included some of my thoughts as comments starting with &quot;// *****&quot; in the below code:&lt;br/&gt;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
System.out.println(&quot;Positive Test34 - in autocommit mode, check that updateRow and deleteRow does not commit&quot;);&lt;br/&gt;
conn.setAutoCommit(true);&lt;/p&gt;

&lt;p&gt;// First try deleteRow and updateRow on &lt;b&gt;first&lt;/b&gt; row of result set&lt;br/&gt;
reloadData();&lt;br/&gt;
System.out.println(&quot;  Contents before changes to first row in RS:&quot;);&lt;br/&gt;
dumpRS(stmt.executeQuery(&quot;select * from t1&quot;));&lt;br/&gt;
stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;
rs = stmt.executeQuery(&quot;SELECT * FROM t1 FOR UPDATE&quot;);&lt;br/&gt;
rs.next();&lt;br/&gt;
rs.deleteRow();&lt;br/&gt;
conn.rollback();&lt;br/&gt;
rs.close();&lt;br/&gt;
System.out.println(&quot;  Make sure the contents of table are unchanged:&quot;);&lt;br/&gt;
dumpRS(stmt.executeQuery(&quot;select * from t1&quot;));&lt;br/&gt;
stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;
rs = stmt.executeQuery(&quot;SELECT * FROM t1 FOR UPDATE&quot;);&lt;br/&gt;
rs.next();&lt;br/&gt;
rs.updateInt(1,-rs.getInt(1));&lt;br/&gt;
rs.updateRow();&lt;/p&gt;

&lt;p&gt;		// ****************************************************************************************************************		&lt;br/&gt;
		// ************************************* A commit was occurring here  ******************************************&lt;br/&gt;
		// ****************************************************************************************************************&lt;/p&gt;

&lt;p&gt;conn.rollback();&lt;br/&gt;
rs.close();&lt;br/&gt;
System.out.println(&quot;  Make sure the contents of table are unchanged:&quot;);&lt;br/&gt;
dumpRS(stmt.executeQuery(&quot;select * from t1&quot;)); &lt;/p&gt;

&lt;p&gt;                // ***************************************************************************************************************&lt;br/&gt;
                // ******************************* Test was failing since the row gets changed due to the commit ***********&lt;br/&gt;
		// ***************************************************************************************************************&lt;/p&gt;

&lt;p&gt;// Now try the same on the &lt;b&gt;last&lt;/b&gt; row in the result set&lt;br/&gt;
reloadData();&lt;br/&gt;
stmt = conn.createStatement();&lt;br/&gt;
rs = stmt.executeQuery(&quot;SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM t1&quot;);&lt;br/&gt;
rs.next();&lt;br/&gt;
int count = rs.getInt(1);&lt;br/&gt;
rs.close();&lt;/p&gt;

&lt;p&gt;System.out.println(&quot;  Contents before changes to last row in RS:&quot;);&lt;br/&gt;
dumpRS(stmt.executeQuery(&quot;select * from t1&quot;));&lt;br/&gt;
stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;
rs = stmt.executeQuery(&quot;SELECT * FROM t1 FOR UPDATE&quot;);&lt;br/&gt;
for (int j = 0; j &amp;lt; count; j++) &lt;/p&gt;
{
   rs.next();
}&lt;br/&gt;
rs.deleteRow();&lt;br/&gt;
conn.rollback();&lt;br/&gt;
rs.close();&lt;br/&gt;
System.out.println(&quot;  Make sure the contents of table are unchanged:&quot;);&lt;br/&gt;
dumpRS(stmt.executeQuery(&quot;select * from t1&quot;));&lt;br/&gt;
&lt;br/&gt;
stmt = conn.createStatement();&lt;br/&gt;
rs = stmt.executeQuery(&quot;SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM t1&quot;);&lt;br/&gt;
rs.next();&lt;br/&gt;
count = rs.getInt(1);&lt;br/&gt;
rs.close();&lt;br/&gt;
&lt;br/&gt;
stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;
rs = stmt.executeQuery(&quot;SELECT * FROM t1 FOR UPDATE&quot;);&lt;br/&gt;
for (int j = 0; j &amp;lt; count; j++) {
   rs.next();
}
&lt;p&gt;rs.updateInt(1,-rs.getInt(1));&lt;br/&gt;
rs.updateRow();&lt;/p&gt;

&lt;p&gt;                // *******************************************************************************************************************************		&lt;br/&gt;
		// ************* No commit was occurring here. This made me think the commit is being sent from some other place  &lt;br/&gt;
		// *******************************************************************************************************************************&lt;/p&gt;

&lt;p&gt;conn.rollback();&lt;br/&gt;
rs.close();&lt;br/&gt;
System.out.println(&quot;  Make sure the contents of table are unchanged:&quot;);&lt;br/&gt;
dumpRS(stmt.executeQuery(&quot;select * from t1&quot;));&lt;/p&gt;

&lt;p&gt;                 // ****************************************************************************************************************&lt;br/&gt;
                // ******************************* Test passes here, which means the failure is sporadic  *******************&lt;br/&gt;
		// ****************************************************************************************************************&lt;/p&gt;

&lt;p&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;I could see in Network Server trace that it was getting a commit command (RDBCMM) in between the rs.updateRow and conn.rollback() only in one particular case. I tried to trace the client to see from where this commit was coming from. But turning on client trace made this problem go away. I tried to create a smaller repro for the problem but was not able to simulate this failure. Also, the test was failing only on &quot;Sun JDK 1.5.0_02&quot;. If I even slightly change the order in the test, this problem goes away. So the failure was sporadic but happens consistently with the updatableResultSet test on Sun JDK 1.5.0_02. I am glad we caught this problem on this jvm. Because after debugging, I realize this can occur on any jvm/platform. It just depends on when the garbage collector (GC) runs. &lt;/p&gt;

&lt;p&gt;Since my patch changed when statements get garbage collected, I walked through that path and found that it was the GC that was sending this commit to network server. When a statement object gets ready for garbage collection, GC calls it&apos;s finalize() method. The finalize() method in Statement class actually calls closeX() which does the same things as Statement.close() method.  When autocommit is on, in some cases, this will call connection_.writeAutoCommit() as shown by this code snippet from Statement.writeCloseResultSets. This causes a commit to be sent to network server and if this happens at wrong time, the output becomes erroneous. &lt;br/&gt;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;if (connection_.autoCommit_ &amp;amp;&amp;amp; requiresAutocommit &amp;amp;&amp;amp; isAutoCommittableStatement_) {&lt;br/&gt;
	connection_.writeAutoCommit();&lt;br/&gt;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;This problem will not occur without my patch because of this:&lt;/p&gt;

&lt;p&gt;--------------------------------&lt;br/&gt;
Without my patch: &lt;br/&gt;
--------------------------------&lt;br/&gt;
Statements get free for garbage collection:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ONLY after they are explicitly closed (Statement.close() has been called) or the connection itself is closed.&lt;br/&gt;
 AND&lt;/li&gt;
	&lt;li&gt;when the user application has no more references to the Statement&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In this case, when GC claims a statement object, it would have been closed already. Because of this, when finalize() --&amp;gt; closeX() is called, openOnClient_ is false and hence finalize() method returns without calling closeX().&lt;/p&gt;

&lt;p&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
protected void finalize() throws java.lang.Throwable {&lt;br/&gt;
        if (agent_.loggingEnabled()) &lt;/p&gt;
{
            agent_.logWriter_.traceEntry(this, &quot;finalize&quot;);
        }
&lt;p&gt;        if (openOnClient_) {&lt;br/&gt;
            synchronized (connection_) &lt;/p&gt;
{
                closeX();
            }
&lt;p&gt;        }&lt;br/&gt;
        super.finalize();&lt;br/&gt;
}&lt;br/&gt;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;--------------------------------&lt;br/&gt;
With my patch: &lt;br/&gt;
--------------------------------&lt;br/&gt;
Statements get free for garbage collection:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;when the user application has no more references to the Statement&lt;br/&gt;
which I think is the correct behavior. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In this case, when GC claims a statement object, openOnClient_ will be true if no Statement.close() has been called previously. Because of this, finalize() --&amp;gt; closeX() is called. And it goes through the entire chain of actions which happen in closeX(). One of this is a call to connection_.writeAutoCommit() which sends a RDBCMM to the server and server does a commit. By chance if the commit message is recieved after the execution of a statement which is not supposed to be autocommitted (like the updateRow statement), this causes erroneous behavior.&lt;/p&gt;

&lt;p&gt;I verified using printlns that this commit is getting sent from Statement.writeCloseResultSets. Also ran the test after removing call to closeX() from Statement.finalize(), in which case this problem goes away. This call to closeX() seems to be the cause of the problem. I am yet to figure out what subset of actions need to be done in finalize().&lt;/p&gt;

&lt;p&gt;--------------------------------&lt;br/&gt;
Summary:&lt;br/&gt;
--------------------------------&lt;br/&gt;
I think my patch for derby-210 is doing the right thing by preventing statement leaks. However, with my patch, some paths of code are getting visited for first time from the GC thread. This is causing sporadic failures because the finalize method in statement class (I think) does a lot more things than required,  one of them being sending commit message to the server. I think the statement finalizer should not be sending anything to the network server, at least not at connection level. I have to look some more into the finalizers in client classes and what happens at server side before I can re-submit a patch for this. I thought I&apos;ll post this to see what others think.&lt;/p&gt;

&lt;p&gt;I would appreciate any feedback on this. &lt;/p&gt;</comment>
                            <comment id="12363480" author="kmarsden" created="Sat, 21 Jan 2006 08:44:42 +0000"  >&lt;p&gt;It sounds to me like you are on the right  track.   I agree, the finalize method is not the same as a close and should not send a commit or otherwise affect data.  It should only cleanup resources. This  is an interesting test, to rollback in autocommit mode.  You could probably force a gc() right befor e the rollback to make  the issue happen with  other jvms.  &lt;/p&gt;
</comment>
                            <comment id="12363585" author="bryanpendleton" created="Mon, 23 Jan 2006 04:22:45 +0000"  >&lt;p&gt;Hi Deepa, thanks very much for posting your research, it was extremely interesting.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I agree with Kathey, though. My expectation was that garbage collecting a Statement &lt;b&gt;is&lt;/b&gt; the same as close, and so I think your implementation is correct and the test is not written precisely enough.&lt;/p&gt;

&lt;p&gt;Here&apos;s an interesting post from a Sun web page:&lt;br/&gt;
&lt;a href=&quot;http://forum.java.sun.com/thread.jspa?threadID=689539&amp;amp;messageID=4018996&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forum.java.sun.com/thread.jspa?threadID=689539&amp;amp;messageID=4018996&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It seems to me like the next step is to try to study the specs and clarify the requirements: what exactly is it supposed to mean to garbage collect a Statement object?&lt;/p&gt;</comment>
                            <comment id="12363684" author="djd" created="Tue, 24 Jan 2006 00:32:58 +0000"  >&lt;p&gt;Couple of issues here:&lt;/p&gt;

&lt;p&gt;1) Doing anything complex in a finalizer can be trouble, as the order of finalizer execution is not guaranteed and so any synchronization can lead to deadlocks. The embedded engine works around this by having the finalizer just mark some object as not being used any more and some later action on the connection will also cleanup the finailzed object.&lt;/p&gt;

&lt;p&gt;2) I think the actions of Statement.close() need to be investigated, I didn&apos;t think that Statement.close() had anyrelationship to automcommit and issuing a COMMIT.  Section 10.1 of JDBC 3.0 has no mention of Statement.close().&lt;/p&gt;</comment>
                            <comment id="12363983" author="deepa" created="Thu, 26 Jan 2006 02:32:24 +0000"  >&lt;p&gt;Thanks Kathey, Bryan and Dan for your comments. &lt;/p&gt;

&lt;p&gt;As Bryan pointed out, the javadoc for Statement.close mentions &quot;A Statement object is automatically closed when it is garbage collected&quot;. I did not see this mentioned in the JDBC spec though. However, I still think close() and finalize() must be different. close() methods can throw SQLExceptions. javadoc for finalize() says this &quot;Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.&quot; So I think we should just ensure that we can clean up all resources when finalize() gets run.  Another reason which Dan pointed out is that  the order of finalizer execution is not guaranteed.&lt;/p&gt;

&lt;p&gt;Dan, after reading through Section 10.1, I think we do not need to auto-commit when we close a statement.&lt;/p&gt;

&lt;p&gt;Kathey, I tried to force gc to repro this problem on other VMs. But I was not successful in creating another repro. The thing is that I am not able to repro this at all anymore, not even on jdk1.5. After I updated my local svn workspace and applied my original patch, I do not get this problem anymore. However, it consistently repoduces with jdk1.5 when running with the revision where the patch was committed (svn 369612). So I am doing changes on svn revision 369612 and running tests to verify this problem does not occur. Then I&apos;ll update to latest svn revision, do the same changes and run tests. I cannot think of any other way to verify this.&lt;/p&gt;</comment>
                            <comment id="12363995" author="kmarsden" created="Thu, 26 Jan 2006 05:07:14 +0000"  >&lt;p&gt;I agree  that garbage collection should not drive a commit, for the reasons stated by you and Dan and the fact that it is just to scary.  It would mean non-holdable cursors will close, some transaction in progress can just commit out of the blue, etc, so it sounds like not a good thing to me.&lt;/p&gt;

&lt;p&gt;In terms of a repro, I would think you could repro the gc commit  with your fix by &lt;br/&gt;
1) make sure autocommit is on&lt;br/&gt;
2) Execute a select with a holdable cursor and do not select the last row.  &lt;br/&gt;
3) set the Statement reference to null.&lt;br/&gt;
4) Execute a select with a non-holdable cursor.  Do not fetch the last row.&lt;br/&gt;
5) force gc.&lt;br/&gt;
6) Try to select the next row for the non-holdable cursor.  It should say the cursor is closed because the gc would &lt;/p&gt;


&lt;p&gt;On whether a Statement.close() should drive a commit ..&lt;br/&gt;
From what was described earlier,  the commit comes from the ResultSet associated with the statement getting closed, not the statement itself.&lt;br/&gt;
I am loathe to enter this conversation again, as the problem seems intractable so will offer only quotes for evaluation by the reader.  &lt;/p&gt;

&lt;p&gt;From section 10.1&lt;/p&gt;

&lt;p&gt;For Select statements, the statement is complete when the associated result set is closed. The result set is closed as soon as one of the following occurs:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;all of the rows have been retrieved&lt;/li&gt;
	&lt;li&gt;the associated Statement object is re-executed&lt;/li&gt;
	&lt;li&gt;another Statement object is executed on the same connection&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The javadoc for Statement.close()&lt;/p&gt;

&lt;p&gt;From Statement javadoc&lt;br/&gt;
When a Statement object is closed, its current ResultSet object, if one exists, is also closed.&lt;/p&gt;

&lt;p&gt;The javadoc for ResultSet.close() &lt;br/&gt;
A ResultSet object is automatically closed by the Statement object that generated it when that Statement object is closed, re-executed, or is used to retrieve the next result from a sequence of multiple results. A ResultSet object is also automatically closed when it is garbage collected.&lt;/p&gt;
</comment>
                            <comment id="12364800" author="johnemb" created="Wed, 1 Feb 2006 22:43:50 +0000"  >&lt;p&gt;Uploaded graphs showing the Sun 1.5 JVM&apos;s utilization of Permanent Generation space in the Java heap (i.e., the JVM running the Derby Network Server) when running the DOTS test case ATCJ2 using Derby @ SVN 373478 (Jan 30 2006), with and without the derby-210.diff patch uploaded by Deepa. Statistics were obtained by using the &quot;jstat&quot; monitoring tool.&lt;/p&gt;

&lt;p&gt;The heap size was fixed at 128 MB, and the Permanent Generation Space was fixed at 64 MB. The attached graphs show the PermSpace because that was the part of the heap that was having the most trouble during the DOTS test run.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;DOTS_ATCJ2_Derby-noPatch.png&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;shows PermSpace utilization on the server side &lt;em&gt;without&lt;/em&gt; the patch, the first 20 hours (72k seconds) of the test run. The Server JVM threw an &quot;OutOfMemoryError: PermGen space&quot; after approximately 3 hours.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;DOTS_ATCJ2_Derby-withPatch.png&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;shows PermSpace utilization on the server side &lt;em&gt;with&lt;/em&gt; the patch, the first 20 hours of the test run. No OutOfMemoryErrors were thrown within this time period.&lt;/p&gt;


&lt;p&gt;In other words, the patch seems to provide significant improvement to Derby robustness with regards to cases where statements are not always explicitly closed by the application using the Derby client. The garbage collector is able to collect much more garbage with the patch than without.&lt;/p&gt;

&lt;p&gt;For details on the DOTS test case and results obtained by running it, please refer to the following thread on the derby-user mailing list: &lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/OutOfMemoryErrors-when-testing-Derby-with-DOTS-t1010027.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/OutOfMemoryErrors-when-testing-Derby-with-DOTS-t1010027.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When it comes to GC performance, it seems that &lt;em&gt;with&lt;/em&gt; the patch, the garbage collector spends less time doing (fewer) major (full) GCs, but more time doing (more) minor GCs. Minor GC is a lot cheaper than major GC, since only the &quot;young&quot; generations are garbage collected, not the entire heap (young + tenured + permanent space).&lt;/p&gt;

&lt;p&gt;I hope this patch gets (re-)committed once the current issues are resolved. Thanks, Deepa!&lt;/p&gt;</comment>
                            <comment id="12365773" author="deepa" created="Fri, 10 Feb 2006 03:35:24 +0000"  >&lt;p&gt;I am attaching a draft patch &apos;derby-210-v2-draft.diff&apos; for review. It is not ready for commit. This patch contains changes in my first patch and some additional changes which I am describing below. I would appreciate if someone can read this and let me know if this is the right approach.&lt;/p&gt;

&lt;p&gt;The changes numbered 1-7 were done as part of first patch. I am copying it from my previous comment:&lt;/p&gt;

&lt;p&gt;1. Eliminates the below references to PreparedStatement objects by using WeakHashMap instead of LinkedList. When there are no other references to the keys in a WeakHashMap, they will get removed from the map and can thus get garbage-collected. They do not have to wait till the Connection object is collected.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&apos;openStatements_&apos; in org.apache.derby.client.am.Connection&lt;/li&gt;
	&lt;li&gt;&apos;CommitAndRollbackListeners_&apos; in org.apache.derby.client.am.Connection&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2. Removes the list &apos;RollbackOnlyListeners_&apos; since this is not being used.&lt;/p&gt;

&lt;p&gt;3. Updates the following comment for openStatements_:&lt;br/&gt;
// Since DERBY prepared statements must be re-prepared after a commit,&lt;br/&gt;
// then we must traverse this list after a commit and notify statements&lt;br/&gt;
// that they are now in an un-prepared state.&lt;br/&gt;
final java.util.LinkedList openStatements_ = new java.util.LinkedList();&lt;/p&gt;

&lt;p&gt;In the code, I did not see this list being traversed after a commit to re-prepare statements. Also, I think this is not needed since Derby does not require re-prepare of statements after a commit. Currently, this list is used to close all open statements when the originating connection is closed.&lt;/p&gt;

&lt;p&gt;4. Removes all ResultSets from HashTable &apos;positionedUpdateCursorNameToResultSet_&apos; in SectionManager. Only result sets of positioned update statements were being removed from this hashtable whereas all result sets were added. Because of this, client driver was holding on to result sets and statements even after rs.close() was called.&lt;/p&gt;

&lt;p&gt;5. Adds a test &apos;derbyStress.java&apos; to jdbcapi suite. This test is based on the repro for this patch. Without this patch, it fails when run with client driver. Kathey had suggested in another mail that tests for client memory leak problems (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-557&quot; title=&quot;Client driver gets OutOfMemoryError when re-executing statement without closing ResultSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-557&quot;&gt;&lt;del&gt;DERBY-557&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;) can be added to same test. I did not see an existing test. So I created this new test. If &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-557&quot; title=&quot;Client driver gets OutOfMemoryError when re-executing statement without closing ResultSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-557&quot;&gt;&lt;del&gt;DERBY-557&lt;/del&gt;&lt;/a&gt; does not have a test, I think it can be added to this new test.&lt;/p&gt;

&lt;p&gt;6. Excludes the new test from running with jcc because jcc gives out of memory error.&lt;/p&gt;

&lt;p&gt;7. Creates &apos;derbyStress_app.properties&apos; with following property &apos;jvmflags=-Xmx64M&apos; to guarantee the test fails on all machines.&lt;/p&gt;

&lt;p&gt;With these changes, the memory leak mentioned in this issue was solved but it was causing an intermittent failure in lang/updatableResultSet.java as described in  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210#action_12363439&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-210#action_12363439&lt;/a&gt;. To solve the regression caused by the first patch, I changed the finalizer in Statement and PreparedStatement classes to avoid network operations. Changes are:&lt;/p&gt;

&lt;p&gt;8. In PreparedStatement class, the finalizer was calling closeX method, which was doing:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Call super.closeX() ---&amp;gt; Statement.closeX()&lt;/li&gt;
	&lt;li&gt;Cleanup parameter objects - parameterMetaData_, sql_, parameters_ array&lt;/li&gt;
	&lt;li&gt;Remove the PreparedStatement from connection_.CommitAndRollbackListeners_ list&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   Changes done by patch:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Move cleanup of objects to a new method cleanupParameters()&lt;/li&gt;
	&lt;li&gt;Call the new method cleanupParameters() from closeX() and finalize()&lt;/li&gt;
	&lt;li&gt;In finalize() method, call super.finalize() which is Statement.finalize() and it will do the remaining cleanup&lt;/li&gt;
	&lt;li&gt;Since WeakHashMap is used for Connection.CommitAndRollbackListeners_, the prepared statement object would already have been removed from this list before entering the finalizer. So there is no need to explicitly call a remove in the finalizer.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;9. In Statement class, the finalizer was calling closeX method, which was doing:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Close any open cursors for this statement on the server.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If result set is open on server, send CLSQRY to the server.&lt;/li&gt;
	&lt;li&gt;check if autocommit is required when closing result sets and flow a commit to server, if required&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Call Statement.markClosed(), which does&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark close the result sets on the client&lt;/li&gt;
	&lt;li&gt;If cursor name was set on the statement, remove it from Connection.clientCursorNameCache_&lt;/li&gt;
	&lt;li&gt;Call markClosed() on prepared statements for auto generated keys&lt;/li&gt;
	&lt;li&gt;Call markClosedOnServer(), which frees up the section. The freed section will be re-used by new statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Remove the Statement from Connection.openStatements_ list&lt;/li&gt;
	&lt;li&gt;Cleanup ResultSetMetaData&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Changes done by patch:	&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Move the cleanup of ResultSetMetaData into markClosed() method. This will keep all client-side cleanup in markClosed().&lt;/li&gt;
	&lt;li&gt;Change the finalizer to just call markClosed(). This method frees up client-side resources and operates on synchronized collections. So I have removed the synchronize block from the finalizer. markClosed() in turn calls markClosedOnServer(), which frees up a section. When the section gets re-used by new statement on client, server re-uses the same statement. newDrdaStatement in org.apache.derby.impl.drda.Database has this code:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;        		/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Get a new DRDA statement and store it in the stmtTable if stortStmt is true&lt;/li&gt;
	&lt;li&gt;If possible recycle an existing statement&lt;/li&gt;
	&lt;li&gt;If we are asking for one with the same name it means it&lt;/li&gt;
	&lt;li&gt;was already closed.&lt;/li&gt;
	&lt;li&gt;@param pkgnamcsn  Package name and section&lt;/li&gt;
	&lt;li&gt;@return DRDAStatement&lt;br/&gt;
			 */&lt;br/&gt;
			protected DRDAStatement newDRDAStatement(Pkgnamcsn pkgnamcsn)&lt;br/&gt;
			throws SQLException
			&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {				DRDAStatement stmt = getDRDAStatement(pkgnamcsn);				if (stmt != null)					stmt.close();				else				{
					stmt = new DRDAStatement(this);
					stmt.setPkgnamcsn(pkgnamcsn);
					storeStatement(stmt);
				}				return stmt;			}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;In the above method, close() is called before re-using the DRDAStatement. This will ensure the statement state is restored. DRDAStatement.close() also ensures the result set objects are closed and result set tables and all result sets are freed on server side. So there is no need to send explicit CLSQRY from client-side statement finalizer.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Since WeakHashMap is used for Connection.openStatements_, the statement object would already have been removed from this list before entering the finalizer. So there is no need to explicitly call a remove in the finalizer.&lt;/li&gt;
	&lt;li&gt;The autocommit logic does not exist in the finalizer since only markClosed() is called from finalizer. This will avoid untimely commits which was causing the regression in the test lang/updatableResultSet.java.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With the above changes, I ran derbynetclientmats few times with jdk14 and jdk15. All tests passed except an intermittent failure in derbynet/prepStmt.java. This was happening in the test added for Jira125 where it calls rs.next(). I was getting the following exception:&lt;/p&gt;

&lt;p&gt;java.lang.StringIndexOutOfBoundsException: String index out of range: 25242&lt;br/&gt;
	at java.lang.String.checkBounds(String.java:372)&lt;br/&gt;
	at java.lang.String.&amp;lt;init&amp;gt;(String.java:404)&lt;br/&gt;
	at org.apache.derby.client.net.NetCursor.readFdocaString(NetCursor.java:753)&lt;br/&gt;
	at org.apache.derby.client.net.NetCursor.parseVCS(NetCursor.java:726)&lt;br/&gt;
	at org.apache.derby.client.net.NetCursor.parseSQLCAXGRP(NetCursor.java:693)&lt;br/&gt;
	at org.apache.derby.client.net.NetCursor.parseSQLCAGRP(NetCursor.java:622)&lt;br/&gt;
	at org.apache.derby.client.net.NetCursor.parseSQLCARD(NetCursor.java:595)&lt;br/&gt;
	at org.apache.derby.client.net.NetCursor.calculateColumnOffsetsForRow_(NetCursor.java:112)&lt;br/&gt;
	at org.apache.derby.client.am.Cursor.next(Cursor.java:165)&lt;br/&gt;
	at org.apache.derby.client.am.ResultSet.nextX(ResultSet.java:287)&lt;br/&gt;
	at org.apache.derby.client.am.ResultSet.next(ResultSet.java:259)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.derbynet.prepStmt.jira125Test_a(prepStmt.java:904)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.derbynet.prepStmt.jira125Test(prepStmt.java:820)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.derbynet.prepStmt.main(prepStmt.java:313)&lt;/p&gt;

&lt;p&gt;It seemed to me that on the client side, the cleanup was happening correctly but on server side, the statement re-use was not happening correctly. DRDAStatement.close() was restoring all members except &apos;currentDrdaRs&apos; and &apos;needsToSendParamData&apos;. &lt;/p&gt;

&lt;p&gt;10. I added the following to DRDAStatement.close() method. This will ensure the previous result set is freed. &lt;br/&gt;
		currentDrdaRs = new DRDAResultSet();&lt;br/&gt;
		needsToSendParamData = false;&lt;/p&gt;

&lt;p&gt;With this change, I am running derbynetclientmats in a loop. I did not see any failures so far. I also ran the repro derbyStress.java with 50,000 prepared statements and did not get an out of memory error. &lt;/p&gt;

&lt;p&gt;I am attaching this interim draft patch to get feedback about the changes. Please let me know if this approach is okay. Thanks much for reading this.&lt;/p&gt;</comment>
                            <comment id="12365834" author="djd" created="Fri, 10 Feb 2006 13:35:55 +0000"  >&lt;p&gt;My gut feeling is that this single patch is trying to do too much (10 described items). If any of these steps are independent I would strongly encourage you to submit them as separate patches. Looks like step 2) for example is independent and possibly a low risk change.&lt;br/&gt;
Separate patches are good, they are easier to review, easier to explain, easier to manage during development as if you have several sets of changes in a client built on top of each other then as you code and re-code the most recent step you run the risk of corrupting the earlier changes. Getting the individual pieces out there earlier also gives them more exposure in the code line to additional testing and inspection. More people are likely to see the changes when they are in the code than when they are in a patch file.&lt;/p&gt;</comment>
                            <comment id="12365950" author="deepa" created="Sat, 11 Feb 2006 04:10:33 +0000"  >&lt;p&gt;Attaching a patch &apos;derby-210-patch1.diff&apos; which removes the list &apos;RollbackOnlyListeners_&apos; from org.apache.derby.client.am.Connection class since this is not being used. This is an incremental patch and does not solve the issue fully. &lt;/p&gt;

&lt;p&gt;While working on this issue, I found one of the causes of memory leaks is object references stored in the lists in the Connection class. On looking at the lists, I found that &apos;RollbackOnlyListeners&apos; is not being used anywhere in the client code. Submitting this patch to remove this.&lt;/p&gt;

&lt;p&gt;Ran derbynetclientmats suite with Sun JDK1.4.2 on Windows XP. I see 1 failure in lang/wisconsin.java which is also seen in Ole&apos;s tests and reported in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-937&quot; title=&quot;Instability in wisconsin test&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-937&quot;&gt;&lt;del&gt;DERBY-937&lt;/del&gt;&lt;/a&gt;. I would appreciate if someone can look at this patch.&lt;/p&gt;</comment>
                            <comment id="12365991" author="kmarsden" created="Sat, 11 Feb 2006 07:09:08 +0000"  >&lt;p&gt;Submitted derby-210-patch1.diff&lt;/p&gt;

&lt;p&gt;Date: Fri Feb 10 14:00:11 2006&lt;br/&gt;
New Revision: 376874&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=376874&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=376874&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12365996" author="deepa" created="Sat, 11 Feb 2006 07:52:12 +0000"  >&lt;p&gt;Attaching second patch &apos;derby-210-patch2.diff&apos; which adds a test to jdbcapi suite for this issue. Patch does the following:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Adds a test derbyStress.java to jdbcapi suite. This test is based on the repro for this patch.&lt;/li&gt;
	&lt;li&gt;Excludes the new test from running with client driver, jcc and j9 because it gives out of memory error. Once derby-210 is resolved, this test should pass with client driver and the exclude must be removed from DerbyNetClient.exclude&lt;/li&gt;
	&lt;li&gt;Creates &apos;derbyStress_app.properties&apos; with following property &apos;jvmflags=-Xmx64M&apos; to guarantee the test fails on all machines with the current client driver.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I ran jdbcapi suite with all frameworks using Sun JDK1.4.2 on Windows XP. Verified that the new test gets run with embedded and is skipped for client and jcc frameworks. Also ran the new test with j9 vms. Verified it passes with j9_foundation and is skipped for other j9s. Please take a look at this patch. &lt;/p&gt;</comment>
                            <comment id="12366002" author="kmarsden" created="Sat, 11 Feb 2006 10:33:12 +0000"  >&lt;p&gt;I checked in  &apos;derby-210-patch2.diff&apos; to add a test in preparation for the fix for this issue.&lt;br/&gt;
Date: Fri Feb 10 17:29:09 2006&lt;br/&gt;
New Revision: 376904&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=376904&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=376904&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12366044" author="knutanders" created="Sun, 12 Feb 2006 07:59:17 +0000"  >&lt;p&gt;Hi Deepa,&lt;/p&gt;

&lt;p&gt;I have attached a patch to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-557&quot; title=&quot;Client driver gets OutOfMemoryError when re-executing statement without closing ResultSet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-557&quot;&gt;&lt;del&gt;DERBY-557&lt;/del&gt;&lt;/a&gt; which adds a test case to your&lt;br/&gt;
new test. In that patch, I enabled the test for the client driver, but&lt;br/&gt;
inserted this into the test code to prevent your test case from being&lt;br/&gt;
run:&lt;/p&gt;

&lt;p&gt;  // Don&apos;t run under DerbyNetClient until &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt; is fixed&lt;br/&gt;
  if (TestUtil.isDerbyNetClientFramework()) return;&lt;/p&gt;

&lt;p&gt;Hope I didn&apos;t mess things up for you.&lt;/p&gt;</comment>
                            <comment id="12366219" author="deepa" created="Tue, 14 Feb 2006 02:45:19 +0000"  >&lt;p&gt;Attaching &apos;derby-210-patch3.diff&apos; which changes method DRDAStatement.close() in Network Server. The following line is added to the method: &lt;br/&gt;
currentDrdaRs = new DRDAResultSet();&lt;/p&gt;

&lt;p&gt;This is required when statements get re-used without an explicit close done on the client side. &lt;/p&gt;

&lt;p&gt;With this patch, I ran derbynetmats and derbynetclientmats with Sun JDK1.4.2 on Windows XP.  Please take a look at this patch. Thanks.&lt;/p&gt;</comment>
                            <comment id="12366223" author="deepa" created="Tue, 14 Feb 2006 03:21:18 +0000"  >&lt;p&gt;Attaching &apos;derby-210-patch4.diff&apos; which changes the finalizer method in Statement and PreparedStatement classes in the client driver. Changes are:&lt;/p&gt;

&lt;p&gt;1. In PreparedStatement class, the finalizer was calling closeX method, which was doing:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Call super.closeX() ---&amp;gt; Statement.closeX()&lt;/li&gt;
	&lt;li&gt;Cleanup parameter objects - parameterMetaData_, sql_, parameters_ array&lt;/li&gt;
	&lt;li&gt;Remove the PreparedStatement from connection_.CommitAndRollbackListeners_ list&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   Changes done by patch:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Add a new method markClosed() which will free client-side resources.&lt;/li&gt;
	&lt;li&gt;The new method is named markClosed() to keep it uniform with naming convention in superclass.&lt;/li&gt;
	&lt;li&gt;This method is called from close() and finalize() methods.&lt;/li&gt;
	&lt;li&gt;markClosed() method will call super.markClosed() to perform cleanup of parent class. It will cleanup the objects specific to PreparedStatement, which are ParameterMetaData and parameters. It also removes the PreparedStatement form the list in Connection object.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2. In Statement class, the finalizer was calling closeX method, which was doing:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Close any open cursors for this statement on the server.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If result set is open on server, send CLSQRY to the server.&lt;/li&gt;
	&lt;li&gt;check if autocommit is required when closing result sets and flow a commit to server, if required&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Call Statement.markClosed(), which does&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark close the result sets on the client&lt;/li&gt;
	&lt;li&gt;If cursor name was set on the statement, remove it from Connection.clientCursorNameCache_&lt;/li&gt;
	&lt;li&gt;Call markClosed() on prepared statements for auto generated keys&lt;/li&gt;
	&lt;li&gt;Call markClosedOnServer(), which frees up the section. The freed section will be re-used by new statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Remove the Statement from Connection.openStatements_ list&lt;/li&gt;
	&lt;li&gt;Cleanup ResultSetMetaData&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Changes done by patch:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Move the cleanup of ResultSetMetaData and remove of Statement from Connection.openStatements_ list into markClosed() method. This will keep all client-side cleanup in markClosed().&lt;/li&gt;
	&lt;li&gt;Change the finalizer to just call markClosed(). This method frees up client-side resources and operates on synchronized collections. So I have removed the synchronize block from the finalizer.&lt;/li&gt;
	&lt;li&gt;The autocommit logic does not exist in the finalizer since only markClosed() is called from finalizer. This will avoid untimely commits which was causing the regression in the test lang/updatableResultSet.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With this patch, I ran derbynetclientmats with  Sun JDK1.4.2 on Windows XP.&lt;/p&gt;

&lt;p&gt;Just before submitting this, I was re-reading the patch and noticed there is no need to override close and closeX method in PreparedStatement since these methods are doing exactly same things as the methods in Statement class. close() method in both classes just call closeX. And closeX does server-side cleanup and calls markClosed. And markClosed in PreparedStatement calls the super.markClosed. So there is no need for a close() and closeX() in PreparedStatement. This is possible because of the name change suggested by Bryan. Thanks again. I hope this change is okay. I will re-run derbynetclientmats and will submit a revised patch4. &lt;/p&gt;

&lt;p&gt;Bryan, if you get time, I would appreciate if you can look at this patch and let me know if it covers your comments. &lt;/p&gt;</comment>
                            <comment id="12366232" author="djd" created="Tue, 14 Feb 2006 03:52:01 +0000"  >&lt;p&gt;The use of close() for close and reset is confusing (I know it&apos;s existing code).&lt;/p&gt;

&lt;p&gt;Your addition is now the only  code in close() that actually generates new objects. This code&lt;br/&gt;
will be called even when the statement is being closed in order that it no longer be used.&lt;br/&gt;
This might have a performance impact, I don&apos;t know how often in a well behaved application&lt;br/&gt;
this internal close method would be called. Once per statement execution or creation?&lt;/p&gt;

&lt;p&gt;I&apos;m unclear on what this patch (&apos;derby-210-patch3.diff&apos;) is addrressing. The comments for&lt;br/&gt;
item 10) above don&apos;t actually help me much. Was the old code successfully re-using the old&lt;br/&gt;
DRDAResultSet() but now for some reason we force it to use a new one every time?&lt;/p&gt;</comment>
                            <comment id="12366374" author="deepa" created="Wed, 15 Feb 2006 04:56:37 +0000"  >&lt;p&gt;Attaching a patch &apos;derby-210-patch4-v2.diff&apos; which fixes the finalization code in Statement classes in client driver. This patch is in preparation for the fixes to memory leaks. &lt;/p&gt;

&lt;p&gt;Summary of changes: &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Changes the finalizers in Statement classes to do only client-side cleanup. No network operations are done in the finalizers.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Adds markClosed method to PreparedStatement class which overrides the markClosed method in Statement class. All client-side cleanup code is moved to markClosed method. Two forms of markClosed method are added:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;markClosed() method will perform clean up but will not remove Statement from the open statements list and PreparedStatement from the commit and rollback listeners list in org.apache.derby.client.am.Connection. This method is called from finalize(), Connection#markStatementsClosed(), and to close positioned update statements. For the finaizer to be called, the Statement should not have any references and so it should have been already removed from the lists.  Connection#markStatementsClosed method explicitly removes the Statement from open statements list. Positioned update statements are not added to the open statements list. Hence, markClosed() is called in these cases.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;markClosed(true) will additionally remove the statement objects from the lists. This is called from close() method.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;After these changes, it is not required to override close(), closeX() and finalize() methods in PreparedStatement class since they contain same code as in Statement class. So these methods are removed.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With these changes, I ran derbynetclientmats with Sun JDK 1.4.2. jdbcapi/dbMetaDataJdbc30.java failed. This test has been already fixed by David. &lt;/p&gt;

&lt;p&gt;Please take a look at this patch. Thanks.&lt;/p&gt;</comment>
                            <comment id="12366818" author="deepa" created="Sat, 18 Feb 2006 02:22:51 +0000"  >&lt;p&gt;&apos;derby-210-patch4-v2.diff&apos; is available for review.  Please take a look at this patch.&lt;/p&gt;

&lt;p&gt;Status of attached patches:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Patches already committed: derby-210-patch1.diff, derby-210-patch2.diff&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Patches which should not be committed: derby-210-v2-draft.diff, derby-210-patch3.diff (problem solved in derby-614)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Patch available for review: derby-210-patch4-v2.diff&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12366856" author="kmarsden" created="Sat, 18 Feb 2006 07:25:41 +0000"  >&lt;p&gt;Firstly Deepa, let me say I am sorry I did not get to look at this part of the big patch when it was first posted.&lt;br/&gt;
I think I need a little more background on the two lists in questions before I can review.&lt;br/&gt;
Connection.openStatements_ and Connection.CommitAndRollbackListeners_&lt;/p&gt;

&lt;p&gt;Why are they needed?&lt;/p&gt;

&lt;p&gt;If they are needed....&lt;br/&gt;
What are they used for?&lt;br/&gt;
What is added and when?&lt;br/&gt;
What is removed and when (finalize/close/some other time)&lt;/p&gt;

&lt;p&gt;The descriptions of both lists seem to describe things that I question.&lt;br/&gt;
The statements do not need to be  reprepared on the server after commit/rollback.&lt;br/&gt;
I also don&apos;t understand why the resultset would be unpositioned.&lt;/p&gt;


&lt;p&gt;//DERBY prepared statements must be re-prepared after a commit&lt;br/&gt;
    // then we must traverse this list after a commit and notify statements&lt;br/&gt;
    // that they are now in an un-prepared state.&lt;br/&gt;
    final java.util.LinkedList openStatements_ = new java.util.LinkedList();&lt;/p&gt;

&lt;p&gt;    // Some statuses of DERBY objects may be invalid on server&lt;br/&gt;
    // after both commit and rollback. For example,&lt;br/&gt;
    // (1) prepared statements need to be re-prepared&lt;br/&gt;
    //     after both commit and rollback                             &lt;br/&gt;
    // (2) result set will be unpositioned on server after both commit and rollback.&lt;br/&gt;
    // If they depend on both commit and rollback, they need to get on CommitAndRollbackListeners_.&lt;br/&gt;
final java.util.LinkedList CommitAndRollbackListeners_ = new java.util.LinkedList();&lt;/p&gt;
</comment>
                            <comment id="12366868" author="deepa" created="Sat, 18 Feb 2006 09:03:43 +0000"  >&lt;p&gt;Thanks Kathey for reading patch4. &lt;/p&gt;

&lt;p&gt;The purpose of these lists do not seem to be same as what is indicated in the code comments. In my work for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;, I found objects added to these lists is one of the causes of memory leak. Solution that was suggested by you and Bernt was to use weak references in these lists. In my patch proposal, I have mentioned use of WeakHashMap instead of LinkedList. &lt;/p&gt;

&lt;p&gt;I tried to see if I can remove these lists but thought it to be too disruptive since the usage of these lists is not very clear. So I have opened &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-817&quot; title=&quot;Improvements to Network Client driver - analyze/improve use of java collection classes in the code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-817&quot;&gt;DERBY-817&lt;/a&gt; for further work on these lists. Please check &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-817&quot; title=&quot;Improvements to Network Client driver - analyze/improve use of java collection classes in the code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-817&quot;&gt;DERBY-817&lt;/a&gt; to see if it answers some of your questions. &lt;/p&gt;

&lt;p&gt;I am trying to summarize my understanding about these lists: &lt;br/&gt;
-------------------------------------------------&lt;br/&gt;
openStatements_ : &lt;br/&gt;
-------------------------------------------------&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;What is it used for?&lt;br/&gt;
When Connection.close() is called, this list is checked to get a list of open statements and statements are marked closed and removed from the list. This happens in Connection.markStatementsClosed() method. They also are used in reset method called by ClientPooledConnection to reset statements when re-using the same physical connection.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What is added and when?&lt;br/&gt;
All statement objects, except positioned update statements, are added to this list. This happens in createStatement and prepare* methods in Connection class. For positioned update statements, there is a comment in the code in Connection.preparePositionedUpdateStatement: &lt;br/&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
        // The positioned update statement is not added to the list of open statements,&lt;br/&gt;
        // because this would cause a java.util.ConcurrentModificationException when&lt;br/&gt;
        // iterating thru the list of open statements to call completeRollback().&lt;br/&gt;
        // An updatable result set is marked closed on a call to completeRollback(),&lt;br/&gt;
        // and would therefore need to close the positioned update statement associated with the result set which would cause&lt;br/&gt;
        // it to be removed from the open statements list. Resulting in concurrent modification&lt;br/&gt;
        // on the open statements list.&lt;br/&gt;
        // Notice that ordinary Statement.closeX() is never called on the positioned update statement,&lt;br/&gt;
        // rather markClosed() is called to avoid trying to remove the statement from the openStatements_ list.&lt;br/&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What is removed and when (finalize/close/some other time) ?&lt;br/&gt;
Currently, removal happens when 1) Connection is closed 2) Statement is (explicitly) closed. 3) Code to &lt;b&gt;remove_from_list&lt;/b&gt; is also there is the finalize method call path. But this is a no-op since finalize() will get called only when there are no references to objects in any lists.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-------------------------------------------------&lt;br/&gt;
CommitAndRollbackListeners_ : &lt;br/&gt;
------------------------------------------------- &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;What is it used for?&lt;br/&gt;
Please see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-817&quot; title=&quot;Improvements to Network Client driver - analyze/improve use of java collection classes in the code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-817&quot;&gt;DERBY-817&lt;/a&gt;. It seems like this list is not needed at least for purposes indicated by comment. This may need further investigation.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What is added and when?&lt;br/&gt;
PreparedStatements, ResultSets and Lobs are added to this list from their listenToUnitOfWork() methods.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What is removed and when (finalize/close/some other time) ?&lt;br/&gt;
For all three types of objects, removal happens in their completeLocalCommit and completeLocalRollback methods. For PreparedStatement and ResultSet, they are also removed from this list when they are closed.  &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
What patch4 (it changes finalization of statement objects) does to removal from these lists :&lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
Removal of statement objects from these two lists is moved to markClosed method. With respect to these lists, whatever was previosuly done by markClosed() method remains unchanged. A new method markClosed(boolean removeListener) is added to distinguish when the objects will be removed from the list. markClosed(true) is only called from close() methods. In this case, there is no change from previous behaviour since the following was previously done in close() method:&lt;br/&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
            markClosed();&lt;br/&gt;
            connection_.openStatements_.remove(this);&lt;br/&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
and now it is replaced with&lt;br/&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
           markClosed(true);&lt;br/&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;Before this patch, finalize method code path also had &lt;b&gt;remove_from_list&lt;/b&gt; call. But this would never be visited. For finalize to be called, there should not be any reference to the statement object from any lists. Applying the same logic, in the patch, finalize just calls markClosed(), which does not have &lt;b&gt;remove_from_list&lt;/b&gt; call. &lt;/p&gt;

&lt;p&gt;I hope this helps you in continuing to read the patch.&lt;/p&gt;</comment>
                            <comment id="12366880" author="kmarsden" created="Sat, 18 Feb 2006 15:40:03 +0000"  >&lt;p&gt;Statement.finalize() comment says&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;This method cleans up client-side resources by calling markClosed().&lt;/li&gt;
	&lt;li&gt;It is different from close() method, which also does clean up on server.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;and the comment for closeX() says&lt;br/&gt;
/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;An untraced version of close(). This method cleans up client-side&lt;/li&gt;
	&lt;li&gt;resources and also sends commands to network server to perform&lt;/li&gt;
	&lt;li&gt;clean up. This should not be called in the finalizer.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@throws SqlException&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think that the closeX comment should be expanded a bit to talk about the other differences between finalize() and closeX&lt;/p&gt;

&lt;p&gt;Looking at writeCloseResultSets, where all the action is, it seems the difference between finalize() and closeX() is closeX:&lt;br/&gt;
	1) Sends commands to the server to close the result sets.&lt;br/&gt;
	2) Sends commands to the server to close the result sets of the generated keys query.&lt;br/&gt;
	3) Sends a commit if autocommit is on and it is appropriate.&lt;br/&gt;
	4) Explicitly removes the statement from connection_.openStatements_  and CommitAndRollbackListeners_  by passing true to markClosed.&lt;/p&gt;


&lt;p&gt;Working backwards for finalizer(), as best I can tell,  the finalizer does not need to do these things because  ...&lt;br/&gt;
	4) The fact that it is being garbage collected means it is not in connection_.openStatements or CommitAndRollbackListners.&lt;br/&gt;
	3) It is not a good idea for the gc() to be sending commits.&lt;br/&gt;
	2) Not sure about these. How do they get cleaned up?&lt;br/&gt;
	1) Somehow all of this causes the  section to be reused. So, while we won&apos;t have immediate cleanup on the server, it will happen if the section is reused.  Can you explain this process a bit more?&lt;/p&gt;

&lt;p&gt;I think these changes are good, but I do think the comments regarding the difference between finalize() and closeX() need to be clearer. At first I thought adding a parameter to markClosed for removeListners was confusing, but I think it is ok since we hopefully will be able to get rid of these lists all together long term.&lt;/p&gt;

&lt;p&gt;Thanks for your help understanding these changes.  I want to understand them well because we are not currently able to test them until your next patch goes in, and problems with gc() are always a bear to debug.&lt;/p&gt;


</comment>
                            <comment id="12366947" author="deepa" created="Sun, 19 Feb 2006 12:47:18 +0000"  >&lt;p&gt;Kathey, please see if the following answers your questions:&lt;/p&gt;

&lt;p&gt;2) Not sure about these. How do they get cleaned up?&lt;br/&gt;
The statement and result sets for generated keys query get cleaned up in Statement.markClosed() by call to markPreparedStatementForAutoGeneratedKeysClosed() method. This method calls markClosed on the auto-generated keys statement, which will ensure this statement and its result sets are cleaned on client side. The cleanup on server happens when section is re-used.&lt;/p&gt;

&lt;p&gt;1) Somehow all of this causes the section to be reused. So, while we won&apos;t have immediate cleanup on the server, it will happen if the section is reused. Can you explain this process a bit more? &lt;br/&gt;
As part of Statement.markClosed(), markClosedOnServer() method gets called. This method frees up the Section on the client. A stack is used to store the free sections. Hence, client driver will use this freed section for the next statement. When client driver re-uses the freed section, network server will find a statement with this section in its stmtTable and re-use the statement. This happens in Database.newDrdaStatement method in network server. Before re-using the statement, its close method is called. This close method cleans up the statement state and its current result set. All other resultsets in its result set table are freed. &lt;/p&gt;

&lt;p&gt;If you find these explanations are correct, I&apos;ll upload a revised version of patch4 with more comments.&lt;/p&gt;

&lt;p&gt;As you said, the code in patch4 will be not be fully covered by tests currently. The code in finalize method will be covered only after the patch which removes the memory leaks is reviewed and committed. This is in my next patch (patch5 - which removes the memory leaks + enable derbyStress test). I will run tests with patch4 + patch 5 and submit patch5, if that will help testing/reviewing.&lt;/p&gt;

&lt;p&gt;I think it would be good to do a long running test with patch4+patch5 before committing them. I&apos;ll be running the repro derbyStress.java with 1M prepared statements and will check client and server memory usage. Other than that, it may be good to run the patch through DOTS test. I do not have the DOTS setup. I would appreciate if John or anyone else has the setup for DOTS and will be willing to run the tests after I upload the new patches. Anyone has suggestions for other tests I can run to test this?&lt;/p&gt;</comment>
                            <comment id="12366967" author="kmarsden" created="Mon, 20 Feb 2006 00:49:38 +0000"  >&lt;p&gt;I am rephrasing this comment. I mispoke about the risidual statements not getting cleaned up.  That is and will remain a problem because there is no CLSSTMT in DRDA.  But this is what I meant to say about the result sets&lt;/p&gt;

&lt;p&gt; I think there actually is a problem with not sending CLSQRY for finalize. If I have 20,000 open valid and referenced prepared statements and then I dereference them. Their result sets will not get cleaned up until the connection ends because no CLSQRY will be sent.&lt;/p&gt;

&lt;p&gt;The reason for the change was to take the autocommit out of finalize and with that I fully agree, but I wonder: why do we have to take out the CLSQRY? writeCloseResultSets takes a boolean allowAutocommits. Could we continue to call it for finalize but just with that parameter set to false?&lt;/p&gt;

&lt;p&gt;Also I would appreciate input from others on this. &lt;/p&gt;</comment>
                            <comment id="12366995" author="deepa" created="Mon, 20 Feb 2006 09:20:21 +0000"  >&lt;p&gt;Thanks Kathey.&lt;/p&gt;

&lt;p&gt;In short, this is what I have been trying to do in patch4 - Limit the finalize in client statement classes to client side cleanup and let the server handle the cleanup of its objects based on current logic of statement re-use. So I changed finalize to not send any network commands. &lt;/p&gt;

&lt;p&gt;But this will not work well for Kathey&apos;s scenario, where an application keeps all its statement references and dereferences all of them in the end. With my change in finalize, the result sets will get cleaned up only when client driver re-uses a section number for a new statement which will make network server close it&apos;s statement and free up result sets OR when the connection is closed.&lt;/p&gt;

&lt;p&gt;On first look, Kathey&apos;s scenario seemed highly improbable but I guess an application can do that if it stores references to statements in some hashtable. I will try to create a repro for Kathey&apos;s scenario and add this case to derbyStress.java and see the behaviour with my patches.&lt;/p&gt;

&lt;p&gt;I&apos;m reworking finalize method to continue sending CLSQRY as Kathey suggested and will upload new version of patch 4.&lt;/p&gt;</comment>
                            <comment id="12367031" author="kmarsden" created="Mon, 20 Feb 2006 22:27:33 +0000"  >&lt;p&gt;Thanks Deepa.&lt;/p&gt;

&lt;p&gt;Perhaps this test case would show if the ResultSets are being closed.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;create a table  and insert a few rows with more than 32K of data.&lt;/li&gt;
	&lt;li&gt;create a prepared statement to drop the table.&lt;/li&gt;
	&lt;li&gt;fetch 1 row&lt;/li&gt;
	&lt;li&gt;dereference the statement&lt;/li&gt;
	&lt;li&gt;force garbage collection&lt;/li&gt;
	&lt;li&gt;try to drop the table with the prepared statement.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I t hink if the ResultSet  is not closed on garbage collection, you will not be able to drop the table.&lt;br/&gt;
I have not tried this, but just a thought.&lt;/p&gt;</comment>
                            <comment id="12367089" author="deepa" created="Tue, 21 Feb 2006 06:48:02 +0000"  >&lt;p&gt;Thanks Kathey for the test case. I got what you are trying to say and I am working on making the changes. However, I could not verify your test case with the current client code (I could verify it with few changes just for testing). With current client code, if we don&apos;t close a result set explicitly, it&apos;s statement object will not be freed. This is because result set gets added to &apos;positionedUpdateCursorNameToResultSet_&apos;  table in SectionManager. The result set object gets removed from this table only when ResultSet.markClosed() gets called. So the test you suggested cannot check the status of objects on network server since the current client-side cleanup itself is not complete. This issue is listed in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-817&quot; title=&quot;Improvements to Network Client driver - analyze/improve use of java collection classes in the code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-817&quot;&gt;DERBY-817&lt;/a&gt;. &lt;/p&gt;</comment>
                            <comment id="12367235" author="kmarsden" created="Wed, 22 Feb 2006 02:49:37 +0000"  >&lt;p&gt;There was a separate thread on this issue on the list  where  concerns were voiced about doing the result set cleanup work in finalize and maybe creating another thread to do that.  &lt;/p&gt;

&lt;p&gt;I talked with Deepa a bit on IRC about the impact of submitting her patch as is without the result set cleanup.&lt;br/&gt;
The summary is.  &lt;/p&gt;

&lt;p&gt;Before Deepa&apos;s patch 4:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;No statements or result sets get cleaned up until the end of the connection unless explicitly closed&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After Deepa&apos;s patch 4:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;No statements or result sets get cleaned up until the end of the connection unless explicitly closed.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After Deepa&apos;s planned patch 5:&lt;br/&gt;
Most statements and result sets get cleaned up automatically.&lt;/p&gt;


&lt;p&gt;So, I am of the opinion that Deepa&apos;s patch can go in as is and another  Jira entry filed for the result set cleanup.  Her planned work  is a huge improvement over the current state.  She does not need to include the result set cleanup in her patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;&lt;/p&gt;
</comment>
                            <comment id="12367700" author="deepa" created="Sat, 25 Feb 2006 04:43:34 +0000"  >&lt;p&gt;Attaching a patch &apos;derby-210-patch4-v3.diff&apos;.  In this patch, I synched upto latest revision and added the additional comments suggested by Kathey. There are no other changes from previous version (derby-210-patch4-v2.diff). With v3 patch, I have run derbynetclientmats with SunJDK 1.4.2 on WinXP.&lt;/p&gt;

&lt;p&gt;I have opened two other JIRA issues related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt; (&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1021&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1021&lt;/a&gt;) - This is for work on finalizers and can be worked on independently.&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1002&quot; title=&quot;Check that DRDAStatement and DRDAResultSet states are reset when they are re-used&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1002&quot;&gt;&lt;del&gt;DERBY-1002&lt;/del&gt;&lt;/a&gt; (&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1021&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1021&lt;/a&gt;) - This is for cleaning up the re-use code in network server. This issue blocks my planned patch5 for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I would appreciate if someone can review/commit patch4. &lt;/p&gt;</comment>
                            <comment id="12367743" author="kmarsden" created="Sat, 25 Feb 2006 08:36:55 +0000"  >&lt;p&gt;Thanks Deepa. The new comments look good.  I will kick of derbynetclientmats and commit later&lt;/p&gt;</comment>
                            <comment id="12367757" author="kmarsden" created="Sat, 25 Feb 2006 13:00:27 +0000"  >&lt;p&gt;Committed &apos;derby-210-patch4-v3.diff&apos;&lt;br/&gt;
Date: Fri Feb 24 19:57:51 2006&lt;br/&gt;
New Revision: 380892&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=380892&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=380892&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12368425" author="deepa" created="Thu, 2 Mar 2006 10:35:55 +0000"  >&lt;p&gt;Attaching a patch &apos;derby-210-patch5-v1.diff&apos; which removes the actual memory leaks. The previous patches were doing preliminary work to fix the client-side finalization and network server object re-use. This patch removes the actual memory leaks.&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------&lt;br/&gt;
Summary of patch:&lt;br/&gt;
-----------------------------------------------------------------&lt;br/&gt;
1. Eliminates the below references to PreparedStatement objects by using WeakHashMap instead of LinkedList. When there are no other references to the keys in a WeakHashMap, they will get removed from the map and can thus get garbage-collected. They do not have to wait till the Connection object is collected.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&apos;openStatements_&apos; in org.apache.derby.client.am.Connection&lt;/li&gt;
	&lt;li&gt;&apos;CommitAndRollbackListeners_&apos; in org.apache.derby.client.am.Connection&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2. Updates the following comment for openStatements_:&lt;br/&gt;
// Since DERBY prepared statements must be re-prepared after a commit,&lt;br/&gt;
// then we must traverse this list after a commit and notify statements&lt;br/&gt;
// that they are now in an un-prepared state.&lt;br/&gt;
final java.util.LinkedList openStatements_ = new java.util.LinkedList();&lt;/p&gt;

&lt;p&gt;In the code, I did not see this list being traversed after a commit to re-prepare statements. Also, I think this is not needed since Derby does not require re-prepare of statements after a commit. Currently, this list is used to close all open statements when the originating connection is closed.&lt;/p&gt;

&lt;p&gt;3. Removes all ResultSets from HashTable &apos;positionedUpdateCursorNameToResultSet_&apos; in SectionManager. Only result sets of positioned update statements were being removed from this hashtable whereas all result sets were added. Because of this, client driver was holding on to result sets and statements even after rs.close() was called.&lt;/p&gt;

&lt;p&gt;4. Modifies the test jdbcapi/derbyStress.java to run the test for derby-210. The test was checked in as patch2  but disabled for client framework.&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------&lt;br/&gt;
Open items related to this issue&lt;br/&gt;
-----------------------------------------------------------------&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-817&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-817&lt;/a&gt; (Improvements to Network Client driver - analyze/improve use of java collection classes in the code) - This issue lists some potential problem areas and cleanup tasks identified in the client driver code.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1002&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1002&lt;/a&gt; (Check that DRDAStatement and DRDAResultSet states are reset when they are re-used) - This issue was blocking &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;. Patch for the blocking issue has been committed. There is still some minor cleanup to be done in this issue.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1021&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1021&lt;/a&gt; (Perform cleanup actions which require synchronization outside the finalizer) - This issue is linked to (&quot;is part of&quot;) &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;. Maybe, it is easier if I had made this a sub-task of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;. I will close &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt; and open a sub-task for 210 with details about work needed on the finalizer.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With this patch, I ran the following tests on Windows XP:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;derbynetclientmats suite 6 times on my machine (3 times with Sun JDK1.4.2 and 3 times with Sun JDK1.5). No failures.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;repro with 100,000 statements and checked the memory usage on client and server. No spikes in memory usage. Without this patch, the repro used to give OutOfMemory error after executing 950 statements. Tests run with Sun JDK1.4.2 with 64M heap space .&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;test to compare memory usage when statements_are_not_explicitly_closed vs statements_are_explicitly_closed. Tests run with Sun JDK1.4.2 with 64M heap space.&lt;br/&gt;
   case1: repro with 5000 statements &lt;br/&gt;
   case2: modified_repro_which_explicitly_closes_prepared_statements with 5000 statements. &lt;br/&gt;
I compared the memory usage on client and server in these two cases and saw that memory usage over time is similar. Memory usage is calculated as Runtime.totalMemory() - Runtime.freeMemory().&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I would appreciate if someone can take a look at this patch.&lt;/p&gt;</comment>
                            <comment id="12368518" author="johnemb" created="Fri, 3 Mar 2006 00:24:31 +0000"  >&lt;p&gt;Regarding patch derby-210-patch5-v1.diff:&lt;/p&gt;

&lt;p&gt;I have not looked at the actual code, but I applied the patch to head of trunk and started to run some tests:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I started the previously mentioned DOTS test against trunk + patch, with same settings (or as close as possible) as earlier. If it runs without error for longer than 55 hours, it will be an improvement. I will publish the results later.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I created a smaller stand-alone application &quot;inspired by&quot; the really bad parts of the DOTS test, and got very promising results (using sane jars):&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Without the patch, head of trunk (SVN 382319), OutOfMemoryError occured in the derby server JVM after executing a little more than 11000 &quot;bad&quot; SELECT statements.&lt;/li&gt;
	&lt;li&gt;With the patch applied, the the server JVM was able to garbage collect the PermSpace, and executed 100000 &quot;bad&quot; statements without error &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will do some more testing, but it&apos;s certainly looking good so far!  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

</comment>
                            <comment id="12368534" author="deepa" created="Fri, 3 Mar 2006 01:25:11 +0000"  >&lt;p&gt;Thanks John for the quick response. I really appreciate your testing effort and waiting to see the results.&lt;/p&gt;

&lt;p&gt;Meantime, I have run derbyall with &apos;derby-210-patch5-v1.diff&apos; using Sun JDK 1.4.2 on Win XP. Only 1 failure (lang/wisconsin.java) also seen in nightlies.&lt;/p&gt;</comment>
                            <comment id="12368763" author="johnemb" created="Sat, 4 Mar 2006 02:06:21 +0000"  >&lt;p&gt;Uploaded my repro (StatementStress.java) for this issue.&lt;/p&gt;

&lt;p&gt;The repro is an independent Java program with elements inspired by some of the &quot;naughtiest&quot; parts of the infamous DOTS test case ATCJ2.java (see my previous comments to this issue).&lt;/p&gt;

&lt;p&gt;I have tried to incorporate lots of explicit comments in the code, so that I will not get bashed for not re-using or closing all PreparedStatements &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;See main-method comments for usage instructions.&lt;/p&gt;

&lt;p&gt;In short, the program does the following:&lt;/p&gt;

&lt;p&gt;====================================================================&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Connects to a database, &quot;naughtyWombat&quot;&lt;/li&gt;
	&lt;li&gt;Creates a table with two columns:&lt;/li&gt;
	&lt;li&gt;ID CHAR(12) NOT NULL PRIMARY KEY&lt;/li&gt;
	&lt;li&gt;DESCR VARCHAR(50)&lt;/li&gt;
	&lt;li&gt;Inserts 10000 rows into this table (in a sane fashion, I hope)&lt;/li&gt;
	&lt;li&gt;The ID column consists of the text &quot;ITEM-X&quot;, where X is a number between 1 and 10000.&lt;/li&gt;
	&lt;li&gt;The DESCR column is always &quot;This is a dummy description&quot;&lt;/li&gt;
	&lt;li&gt;Queries this table (by primary key) by:&lt;/li&gt;
	&lt;li&gt;Preparing a PreparedStatement (not using &quot;?&quot; placeholders, to stress the system)&lt;/li&gt;
	&lt;li&gt;Executing the query, and iterating through the result set&lt;/li&gt;
	&lt;li&gt;Closing the result set explicitly&lt;/li&gt;
	&lt;li&gt;Setting the PreparedStatement to null, without closing it explicitly first&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;====================================================================&lt;/p&gt;

&lt;p&gt;With Derby in Client/Server mode and a server JVM heap size of 128 MB and PermGen size of 64 MB (this is pretty close to the defaults on modern JVMs and desktop/server machines), I got the following results:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;With Derby trunk at SVN 382319, with Sun JDK 1.5, the server is disabled by an OutOfMemoryError (PermGenSpace) after executing approximately 11000 query statements.&lt;/li&gt;
	&lt;li&gt;With Derby trunk + derby-210-patch5-v1.diff (Sun JDK1.5), I have executed more than 900000 queries without any errors (the JVM is stressed, but is able to GC generated classes).&lt;/li&gt;
	&lt;li&gt;I have also run the test against Derby in embedded mode, without seeing any errors.&lt;/li&gt;
	&lt;li&gt;The test did not pass with jdk1.4.2, but I have not had time to test much or investigate (I would appreciate if someone else could try this as well).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There is one important thing to be aware of, though:&lt;/p&gt;

&lt;p&gt;It seems to me that it is not possible to eliminate this problem when the server is running on a 1.3 JVM! &lt;br/&gt;
This is because classes are not unloaded from the permanent generation with 1.3.x JVMs (as far as I know).&lt;/p&gt;

&lt;p&gt;Feel free to experiment with this code and/or adding some version of it as a regression test, if appropriate...&lt;/p&gt;
</comment>
                            <comment id="12369318" author="kmarsden" created="Wed, 8 Mar 2006 05:59:36 +0000"  >&lt;p&gt; I would like to suggest that we go ahead and commit Deepa&apos;s patch5, since it shows marked improvement and no signs of regression.  Any objections?  If I hear nothing I will checkin  later this afternoon.&lt;/p&gt;

&lt;p&gt;John, it would be interesting to see the output of runtimeinfo at the 55 hour mark, to see if it is really prepared statements leaking or something else.&lt;/p&gt;

</comment>
                            <comment id="12369413" author="johnemb" created="Wed, 8 Mar 2006 16:52:56 +0000"  >&lt;p&gt;I attached runtimeinfo_DOTS-OOME.txt, which is runtimeinfo (org.apache.derby.drda.NetworkServerControl runtimeinfo) collected a while after the first OutOfMemoryError (OOME) on the server, from the last failed DOTS test run, as discussed in the e-mail thread&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/-jira-Updated%3A-%28DERBY-210%29-Network-Server-will-leak-prepared-statements-if-not-explicitly-closed-by-the-user-until-the-connection-is-closed-t1219222.html#a3271800&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/-jira-Updated%3A-%28DERBY-210%29-Network-Server-will-leak-prepared-statements-if-not-explicitly-closed-by-the-user-until-the-connection-is-closed-t1219222.html#a3271800&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first OOME occurred after roughly 56 hours this time. I have collected similar runtimeinfos from previous failed test runs.&lt;br/&gt;
(I do not currently have a runtimeinfo from the exact time when the first OOME occurres.)&lt;/p&gt;

&lt;p&gt;Most of the statements seen in runtimeinfo are of the type&lt;/p&gt;

&lt;p&gt;SELECT SELLERID,DESCRIPTION,BID_PRICE,START_TIME,END_TIME,BID_COUNT FROM ITEM WHERE ITEMID = &apos;ITEM664222&apos;&lt;/p&gt;

&lt;p&gt;which seem to be unprepared statements, e.g.&lt;/p&gt;

&lt;p&gt;rs = stmt.executeQuery(getItemSQL + &quot;&apos;&quot; + itemID + &quot;&apos;&quot;);&lt;/p&gt;


&lt;p&gt;that are not always properly closed (see dots.advcase.ATCJ2.java).&lt;/p&gt;

&lt;p&gt;I guess that in this case the problem is a lack of closing all statements properly, regardless of whether they are prepared or not &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                            <comment id="12369555" author="kmarsden" created="Thu, 9 Mar 2006 06:15:57 +0000"  >&lt;p&gt;Committed  &apos;derby-210-patch5-v1.diff&apos; &lt;/p&gt;

&lt;p&gt;Date: Wed Mar  8 13:16:49 2006&lt;br/&gt;
New Revision: 384331&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=384331&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=384331&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thank you so much Deepa for all your hard work on this issue and Bryan and John too.&lt;br/&gt;
I talked with Deepa on IRC about the outstanding issues and possible organization of Jira issues, moving forward:&lt;/p&gt;

&lt;p&gt;The current oustanding issues seem to be:&lt;br/&gt;
a) Prepared statements are not garbage collected on the server until the sections  are reused.  (This I think has to be fixed with a DRDA protocol Change)&lt;br/&gt;
b) ResultSets are not garbage collected on the server until the  section is  reused.  (This could be fixed with  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
c) John found an issue with Statements not getting cleaned up at least on the server.&lt;/p&gt;

&lt;p&gt;Would this  sound like a reasonable course of action?&lt;br/&gt;
1) Open a subtask of this issue with the work Deepa has done so far and close it. Something like:&lt;br/&gt;
&quot;Change the client driver to allow statements to be garbage-collected once they are dereferenced by an application&quot; &lt;br/&gt;
2) Open a subtask of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt; for item &quot;a&quot;  above.&lt;br/&gt;
3) Open a new  issue for &quot;b&quot;  to replace  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt;. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt; could be a part of that issue or just closed.&lt;br/&gt;
4) Open a new issue for &quot;c&quot;&lt;/p&gt;


&lt;p&gt;Thanks&lt;br/&gt;
Kathey&lt;/p&gt;



&lt;p&gt;2)  &lt;/p&gt;





&lt;p&gt;Would the following sound like a reasonable course of action moving forward:&lt;/p&gt;

&lt;p&gt;1) Close &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt; and replace it with a subtask of this issue that is more specific, like:&lt;/p&gt;
</comment>
                            <comment id="12369556" author="kmarsden" created="Thu, 9 Mar 2006 06:20:29 +0000"  >&lt;p&gt;I committed Deepa&apos;s patch5&lt;br/&gt;
Thank you so much Deepa for all your hard work on this issue and Bryan and John too.&lt;/p&gt;

&lt;p&gt;Date: Wed Mar  8 13:16:49 2006&lt;br/&gt;
New Revision: 384331&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=384331&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=384331&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I spoke with Deepa on IRC about the oustanding issues and possible Jira organization.&lt;/p&gt;

&lt;p&gt;The current oustanding issues seem to be:&lt;br/&gt;
a) Prepared statements are not garbage collected on the server until the sections are reused. (This has to be fixed with a DRDA protocol Change)&lt;br/&gt;
b) ResultSets are not garbage collected on the server until the section is reused. (This could be fixed with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
c) John found an issue with Statements not getting cleaned up at least in the server.&lt;/p&gt;

&lt;p&gt;Would this sound like a reasonable course of action?&lt;br/&gt;
1) Open a subtask of this issue with the work Deepa has done so far and close it. Something like:&lt;br/&gt;
&quot;Change the client driver to allow statements to be garbage-collected once they are dereferenced by an application&quot;&lt;br/&gt;
2) Open a subtask of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt; for item a above.&lt;br/&gt;
3) Open an issue for &quot;b&quot; and make &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt; part of it or just close out &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1021&quot; title=&quot;Perform cleanup actions which require synchronization outside the finalizer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1021&quot;&gt;&lt;del&gt;DERBY-1021&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
4) Open a new issue for c&lt;/p&gt;
</comment>
                            <comment id="12370254" author="deepa" created="Tue, 14 Mar 2006 06:09:38 +0000"  >&lt;p&gt;I have opened a sub-task (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1103&quot; title=&quot;Change the client driver to allow statements to be garbage-collected once they are not referenced in an application&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1103&quot;&gt;&lt;del&gt;DERBY-1103&lt;/del&gt;&lt;/a&gt;) for the work I have done for this issue for 10.2.  I am unassigning myself from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt; as I will not be able to continue immediately with further work on it.&lt;/p&gt;

&lt;p&gt;Here is a list of other issues found when working on this one:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1104&quot; title=&quot;Finalization of statements in client driver should handle sending of CLSQRY to close result sets on network server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1104&quot;&gt;DERBY-1104&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1106&quot; title=&quot;Prepared statements are not garbage collected on the server until the sections are reused&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1106&quot;&gt;DERBY-1106&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1002&quot; title=&quot;Check that DRDAStatement and DRDAResultSet states are reset when they are re-used&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1002&quot;&gt;&lt;del&gt;DERBY-1002&lt;/del&gt;&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-817&quot; title=&quot;Improvements to Network Client driver - analyze/improve use of java collection classes in the code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-817&quot;&gt;DERBY-817&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;John mentioned potential memory leaks seen in the DOTS run. As Kathey suggested, it would be good to open a new issue for this, with a smaller repro, if possible.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12415172" author="deepa" created="Thu, 8 Jun 2006 01:04:11 +0100"  >&lt;p&gt;I had been working on this issue and had unassigned myself after completing the work I intended to do (covered in sub-task &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1103&quot; title=&quot;Change the client driver to allow statements to be garbage-collected once they are not referenced in an application&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1103&quot;&gt;&lt;del&gt;DERBY-1103&lt;/del&gt;&lt;/a&gt;). I checked that  there are no pending patches attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-210&quot; title=&quot;Network Server will leak prepared statements if not explicitly closed by the user until the connection is closed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-210&quot;&gt;DERBY-210&lt;/a&gt;. Hence unchecking the patch available check box. &lt;/p&gt;</comment>
                            <comment id="12729850" author="mikem" created="Fri, 10 Jul 2009 22:48:40 +0100"  >&lt;p&gt;Triaged July 10, 2009: assigned normal urgency. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12329287">DERBY-1021</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12322534" name="DOTS_ATCJ2_Derby-noPatch.png" size="6233" author="johnemb" created="Wed, 1 Feb 2006 22:43:49 +0000"/>
                            <attachment id="12322535" name="DOTS_ATCJ2_Derby-withPatch.png" size="7249" author="johnemb" created="Wed, 1 Feb 2006 22:43:50 +0000"/>
                            <attachment id="12323684" name="StatementStress.java" size="17363" author="johnemb" created="Sat, 4 Mar 2006 02:06:21 +0000"/>
                            <attachment id="12322844" name="derby-210-patch1.diff" size="1915" author="deepa" created="Sat, 11 Feb 2006 04:10:33 +0000"/>
                            <attachment id="12322861" name="derby-210-patch2.diff" size="8610" author="deepa" created="Sat, 11 Feb 2006 07:52:12 +0000"/>
                            <attachment id="12322862" name="derby-210-patch2.status" size="612" author="deepa" created="Sat, 11 Feb 2006 07:52:12 +0000"/>
                            <attachment id="12322931" name="derby-210-patch3.diff" size="811" author="deepa" created="Tue, 14 Feb 2006 02:45:19 +0000"/>
                            <attachment id="12322969" name="derby-210-patch4-v2.diff" size="6263" author="deepa" created="Wed, 15 Feb 2006 04:56:37 +0000"/>
                            <attachment id="12322970" name="derby-210-patch4-v2.status" size="132" author="deepa" created="Wed, 15 Feb 2006 04:56:37 +0000"/>
                            <attachment id="12323382" name="derby-210-patch4-v3.diff" size="6943" author="deepa" created="Sat, 25 Feb 2006 04:43:34 +0000"/>
                            <attachment id="12323383" name="derby-210-patch4-v3.status" size="132" author="deepa" created="Sat, 25 Feb 2006 04:43:34 +0000"/>
                            <attachment id="12323602" name="derby-210-patch5-v1.diff" size="10354" author="deepa" created="Thu, 2 Mar 2006 10:35:55 +0000"/>
                            <attachment id="12323603" name="derby-210-patch5-v1.status" size="403" author="deepa" created="Thu, 2 Mar 2006 10:35:55 +0000"/>
                            <attachment id="12322806" name="derby-210-v2-draft.diff" size="19471" author="deepa" created="Fri, 10 Feb 2006 03:35:24 +0000"/>
                            <attachment id="12322807" name="derby-210-v2-draft.status" size="813" author="deepa" created="Fri, 10 Feb 2006 03:35:24 +0000"/>
                            <attachment id="19583" name="derbyStress.java" size="12539" author="kmarsden" created="Mon, 11 Apr 2005 11:17:00 +0100"/>
                            <attachment id="12323920" name="runtimeinfo_DOTS-OOME.txt" size="32701" author="johnemb" created="Wed, 8 Mar 2006 16:52:56 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12330222">DERBY-1103</subtask>
                            <subtask id="12330223">DERBY-1104</subtask>
                            <subtask id="12330225">DERBY-1106</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>17.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 14 Jan 2006 07:42:42 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21836</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0div:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36009</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>