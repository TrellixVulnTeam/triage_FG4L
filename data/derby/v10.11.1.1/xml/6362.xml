<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:11:12 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-6362/DERBY-6362.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-6362] CHECK constraint uses wrong schema for unqualified routine invocations</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6362</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3944&quot; title=&quot;CHECK constraints involving user-coded functions may return different results depending on who performs the triggering INSERT/UPDATE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3944&quot;&gt;&lt;del&gt;DERBY-3944&lt;/del&gt;&lt;/a&gt; fixed the problem with CHECK constraints invoking different routines depending on who performed the triggering INSERT or UPDATE statement.&lt;/p&gt;

&lt;p&gt;The discussion leading up to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3944&quot; title=&quot;CHECK constraints involving user-coded functions may return different results depending on who performs the triggering INSERT/UPDATE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3944&quot;&gt;&lt;del&gt;DERBY-3944&lt;/del&gt;&lt;/a&gt; can be found here: &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/db-derby-dev/200811.mbox/%3C4919CD4A.5010408@sun.com%3E&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/db-derby-dev/200811.mbox/%3C4919CD4A.5010408@sun.com%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Three alternatives are discussed in the thread:&lt;/p&gt;

&lt;p&gt;A) The schema that holds the CHECK constraint?&lt;br/&gt;
B) The schema that holds the table?&lt;br/&gt;
C) The current schema when the CREATE TABLE statement was issued?&lt;/p&gt;

&lt;p&gt;The conclusion in the thread was that option C was the correct one. However, what was implemented, was option B.&lt;/p&gt;

&lt;p&gt;I cannot find any information in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3944&quot; title=&quot;CHECK constraints involving user-coded functions may return different results depending on who performs the triggering INSERT/UPDATE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3944&quot;&gt;&lt;del&gt;DERBY-3944&lt;/del&gt;&lt;/a&gt; about why option B ended up being chosen, so I assume that it was unintended.&lt;/p&gt;

&lt;p&gt;Here&apos;s an ij script that shows how the CHECK constraint tries to invoke the TO_HEX function in the schema of the target table (S2) instead of the schema that was the current schema at the time of CREATE TABLE:&lt;/p&gt;

&lt;p&gt;ij version 10.10&lt;br/&gt;
ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos;;&lt;br/&gt;
ij&amp;gt; create schema s1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create schema s2;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create function s1.to_hex(i int) returns char(4) language java parameter style java external name &apos;java.lang.Integer.toHexString&apos; no sql;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; set schema s1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table s2.t(x int, constraint cc check(to_hex&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &amp;lt;&amp;gt; &apos;80&apos;));&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into s2.t values 1;&lt;br/&gt;
ERROR 42Y03: &apos;TO_HEX&apos; is not recognized as a function or procedure. (errorCode = 30000)&lt;br/&gt;
ij&amp;gt; create function s2.to_hex(i int) returns char(4) language java parameter style java external name &apos;java.lang.Integer.toHexString&apos; no sql;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into s2.t values 1;&lt;br/&gt;
1 row inserted/updated/deleted&lt;/p&gt;</description>
                <environment></environment>
        <key id="12671742">DERBY-6362</key>
            <summary>CHECK constraint uses wrong schema for unqualified routine invocations</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                            <label>derby_backport_reject_10_10</label>
                    </labels>
                <created>Wed, 2 Oct 2013 10:18:47 +0100</created>
                <updated>Wed, 21 Jan 2015 00:23:37 +0000</updated>
                            <resolved>Thu, 5 Dec 2013 15:56:48 +0000</resolved>
                                    <version>10.10.1.1</version>
                                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13783896" author="rhillegas" created="Wed, 2 Oct 2013 14:10:58 +0100"  >&lt;p&gt;I see 3 messages in the email thread which Knut cited. The conclusion in the last message involves a leap of reasoning which I don&apos;t understand. The referenced part of the standard (part 2, section 4.27.2) just says that the routine&apos;s schema is determined when the check constraint is declared. It still doesn&apos;t say which of the 3 options is correct. I don&apos;t understand which part of the standard supports option C.&lt;/p&gt;

&lt;p&gt;Option C gives rise to non-deterministic behavior if the DDL is dumped via dblook and then re-run. You are not guaranteed that the CHECK constraint will be re-created from the same schema. Options A and B don&apos;t have this problem. I would be reluctant to introduce this non-determinacy.&lt;/p&gt;

&lt;p&gt;I can&apos;t reconstruct why the solution to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3944&quot; title=&quot;CHECK constraints involving user-coded functions may return different results depending on who performs the triggering INSERT/UPDATE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3944&quot;&gt;&lt;del&gt;DERBY-3944&lt;/del&gt;&lt;/a&gt; preferred option B over A. Thanks.&lt;/p&gt;</comment>
                            <comment id="13784102" author="knutanders" created="Wed, 2 Oct 2013 16:54:56 +0100"  >&lt;p&gt;I agree that the email thread doesn&apos;t get completely to the bottom of it, so more reading of the standard is needed in order to find out what&apos;s the correct behaviour.&lt;/p&gt;

&lt;p&gt;I think it is possible to make dblook have deterministic behaviour even with option C. We could make it create DDL that uses a schema qualified name for the routine, if it doesn&apos;t already.&lt;/p&gt;

&lt;p&gt;If we conclude that option B is correct, we still need to make changes to CHECK constraint, as it currently seems to use a mix of option B and option C. See for example this ij transcript:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ij version 10.10
ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos;;
ij&amp;gt; create function bin.f(i int) returns char(32) language java parameter style java external name &apos;java.lang.Integer.toBinaryString&apos; no sql;
0 rows inserted/updated/deleted
ij&amp;gt; create function hex.f(i int) returns char(4) language java parameter style java external name &apos;java.lang.Integer.toHexString&apos; no sql;
0 rows inserted/updated/deleted
ij&amp;gt; values (hex.f(10), bin.f(10));
1   |2                               
-------------------------------------
a   |1010                            

1 row selected
ij&amp;gt; set schema bin;
0 rows inserted/updated/deleted
ij&amp;gt; create table hex.t(x int, constraint cc check(f(x) = &apos;a&apos;));
0 rows inserted/updated/deleted
ij&amp;gt; insert into hex.t(x) values 10;
1 row inserted/updated/deleted
ij&amp;gt; insert into hex.t(x) values 11;
ERROR 23513: The check constraint &apos;CC&apos; was violated while performing an INSERT or UPDATE on table &apos;&quot;HEX&quot;.&quot;T&quot;&apos;.
ij&amp;gt; drop function hex.f;
0 rows inserted/updated/deleted
ij&amp;gt; drop function bin.f;
ERROR X0Y25: Operation &apos;DROP ROUTINE&apos; cannot be performed on object &apos;F&apos; because CONSTRAINT &apos;CC&apos; is dependent on that object.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the constraint CC apparently uses the function HEX.F. Still, there is no error or warning when HEX.F is dropped. But if you try to drop BIN.F, which is not used in constraint CC, you get an error saying that CC depends on it.&lt;/p&gt;

&lt;p&gt;Also, if you go back to the example in the bug description, I think that the error saying TO_HEX didn&apos;t exist should have happened at CREATE TABLE time, not when performing the INSERT.&lt;/p&gt;</comment>
                            <comment id="13786521" author="rhillegas" created="Fri, 4 Oct 2013 20:17:10 +0100"  >&lt;p&gt;Note that the SQL Standard, part 2, section 11.6 (table constraint definition), syntax rule 2 says that constraints must live in the same schema as the table they are attached to. So options A and B are the same.&lt;/p&gt;</comment>
                            <comment id="13787996" author="knutanders" created="Mon, 7 Oct 2013 09:55:51 +0100"  >&lt;p&gt;I wanted to see what other databases did, so I tested it on instances of MySQL, PostgreSQL and Oracle that I had access to. Oracle doesn&apos;t allow user-defined functions in CHECK constraints, and MySQL ignores CHECK constraints, so I got no useful information from those two databases. PostgreSQL seems to be using option C.&lt;/p&gt;</comment>
                            <comment id="13788013" author="knutanders" created="Mon, 7 Oct 2013 10:30:33 +0100"  >&lt;p&gt;It seems if you create a generated column in an Oracle database, it uses option A/B.&lt;/p&gt;</comment>
                            <comment id="13789244" author="rhillegas" created="Tue, 8 Oct 2013 15:30:37 +0100"  >&lt;p&gt;I have exchanged email with some other members of the SQL committee. They have pointed me at the portions of the SQL Standard which discuss the SQL-path. It sheds some light on this discussion.&lt;/p&gt;

&lt;p&gt;The SQL-path is introduced by part 2, section 4.29 (SQL-paths). Fully evolved, a SQL-path is a search order for schema resolution. It&apos;s akin to the search order in a Unix path or Java classpath. The CURRENT_PATH variable (implemented in some databases) shows the value of the SQL-path...&lt;/p&gt;

&lt;p&gt;    values CURRENT_PATH&lt;/p&gt;

&lt;p&gt;...much as the following Unix commands show the value of the shell&apos;s path and classpath variables:&lt;/p&gt;

&lt;p&gt;    echo $PATH&lt;br/&gt;
    echo $CLASSPATH&lt;/p&gt;

&lt;p&gt;According to part 2, section 4.29 (SQL-paths), the SQL-path is used to resolve routine and type references which lack a schema qualifier and which appear in &quot;preparable statements&quot;. These statements, in turn, include the standalone DDL statements like CREATE/ALTER TABLE. So SQL-path should be used to resolve unqualified routine/type references in CHECK constraints and generation clauses.&lt;/p&gt;

&lt;p&gt;The value of SQL-path is implementation-defined. The Standard lets you change the value of SQL-path via a SET PATH command, which Derby does not implement. SET PATH is independent of the SET SCHEMA command which Derby does implement. Note that the SET SCHEMA command (part 2, section 19.6) changes how unqualified names are resolved in &quot;preparable statements&quot;. However, that section does not claim that SET SCHEMA has any affect on SQL-path.&lt;/p&gt;

&lt;p&gt;The Derby code never speaks about SQL-path. This is a part of the Standard which Derby ignores. So Derby&apos;s inconsistent treatment of SQL-path is not surprising. That said, now that we are aware of SQL-path, it would be good to make Derby&apos;s behavior consistent.&lt;/p&gt;

&lt;p&gt;For most statements, Derby behaves as though CURRENT_PATH is a list with one value in it (CURRENT_SCHEMA). So, unqualified routine references in DML statements are resolved to CURRENT_SCHEMA. The same is true for unqualified routine references in generation clauses and unqualified type references in CREATE TABLE statements.&lt;/p&gt;

&lt;p&gt;If we treated CHECK constraints the same way, then we would have behavior (C) described above. This seems reasonable to me. That is, it makes sense to me that we should formalize our understand of SQL-path and apply it consistently going forward. Derby&apos;s implementation of SQL-path would be simple, viz., CURRENT_PATH = CURRENT_SCHEMA.&lt;/p&gt;

&lt;p&gt;The following script shows the current behavior of CURRENT_PATH:&lt;/p&gt;

&lt;p&gt;---------------------------------------------&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:memory:db;create=true&apos;;&lt;/p&gt;

&lt;p&gt;create schema neutralSchema;&lt;/p&gt;

&lt;p&gt;create schema ddlSessionSchema;&lt;br/&gt;
set schema ddlSessionSchema;&lt;/p&gt;

&lt;p&gt;create type myType external name &apos;java.util.HashMap&apos; language java;&lt;/p&gt;

&lt;p&gt;create function myCheckFunc( doubleVal double ) returns double&lt;br/&gt;
language java parameter style java deterministic no sql&lt;br/&gt;
external name &apos;java.lang.Math.sin&apos;;&lt;/p&gt;

&lt;p&gt;create function myGenColFunc( doubleVal double ) returns double&lt;br/&gt;
language java parameter style java deterministic no sql&lt;br/&gt;
external name &apos;java.lang.Math.abs&apos;;&lt;/p&gt;

&lt;p&gt;&amp;#8211; --------------------------------&lt;/p&gt;

&lt;p&gt;create schema tableSchema;&lt;br/&gt;
set schema tableSchema;&lt;/p&gt;

&lt;p&gt;create type myType external name &apos;java.util.ArrayList&apos; language java;&lt;/p&gt;

&lt;p&gt;create function myCheckFunc( doubleVal double ) returns double&lt;br/&gt;
language java parameter style java deterministic no sql&lt;br/&gt;
external name &apos;java.lang.Math.cos&apos;;&lt;/p&gt;

&lt;p&gt;create function myGenColFunc( doubleVal double ) returns double&lt;br/&gt;
language java parameter style java deterministic no sql&lt;br/&gt;
external name &apos;java.lang.Math.exp&apos;;&lt;/p&gt;

&lt;p&gt;&amp;#8211; --------------------------------&lt;/p&gt;

&lt;p&gt;set schema ddlSessionSchema;&lt;/p&gt;

&lt;p&gt;create table tableSchema.t&lt;br/&gt;
(&lt;br/&gt;
   a myType,&lt;br/&gt;
   b double check ( myCheckFunc( b ) &amp;gt; 0 ),&lt;br/&gt;
   c generated always as ( myGenColFunc( b ) )&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;&amp;#8211; --------------------------------&lt;/p&gt;

&lt;p&gt;set schema neutralSchema;&lt;/p&gt;

&lt;p&gt;values&lt;br/&gt;
(&lt;br/&gt;
    ddlSessionSchema.myCheckFunc( -1 ), ddlSessionSchema.myGenColFunc( -1 )&lt;br/&gt;
);&lt;br/&gt;
values&lt;br/&gt;
(&lt;br/&gt;
    tableSchema.myCheckFunc( -1 ), tableSchema.myGenColFunc( -1 )&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;&amp;#8211; fails because myType resolves to ddlSessionSchema.myType&lt;br/&gt;
insert into tableSchema.t( a ) values ( cast (null as tableSchema.myType) );&lt;/p&gt;

&lt;p&gt;&amp;#8211;&lt;br/&gt;
-- myCheckFunc resolves to tableSchema.myCheckFunc&lt;br/&gt;
&amp;#8211;&lt;br/&gt;
-- myGenColFunc resolves to ddlSessionSchema.myGenColFunc&lt;br/&gt;
&amp;#8211;&lt;br/&gt;
insert into tableSchema.t( b ) values ( -1 );&lt;br/&gt;
select * from tableSchema.t;&lt;/p&gt;

&lt;p&gt;&amp;#8211; --------------------------------&lt;/p&gt;

&lt;p&gt;set schema ddlSessionSchema;&lt;/p&gt;

&lt;p&gt;&amp;#8211; behaves as though CURRENT_PATH = ddlSessionSchema&lt;br/&gt;
values&lt;br/&gt;
(&lt;br/&gt;
    myCheckFunc( -1 ), myGenColFunc( -1 )&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;set schema tableSchema;&lt;/p&gt;

&lt;p&gt;&amp;#8211; behaves as though CURRENT_PATH = tableSchema&lt;br/&gt;
values&lt;br/&gt;
(&lt;br/&gt;
    myCheckFunc( -1 ), myGenColFunc( -1 )&lt;br/&gt;
);&lt;/p&gt;</comment>
                            <comment id="13789513" author="dagw" created="Tue, 8 Oct 2013 19:44:51 +0100"  >&lt;p&gt;I think resolving to use current schema as current path is a good way forward; +1.&lt;/p&gt;</comment>
                            <comment id="13790137" author="knutanders" created="Wed, 9 Oct 2013 08:47:33 +0100"  >&lt;p&gt;Thanks for digging into this, Rick. The suggested approach sounds fine to me.&lt;/p&gt;

&lt;p&gt;By the way, views and triggers seem to use the current schema too.&lt;/p&gt;</comment>
                            <comment id="13796929" author="knutanders" created="Wed, 16 Oct 2013 17:06:46 +0100"  >&lt;p&gt;How should this behave on upgrade if an existing database has a CHECK constraint with an unqualified identifier and the the original compilation schema is different from the schema in which the constraint lives? Only use the original compilation schema in hard-upgraded databases?&lt;/p&gt;</comment>
                            <comment id="13796950" author="rhillegas" created="Wed, 16 Oct 2013 17:35:33 +0100"  >&lt;p&gt;Thanks for raising that point, Knut. Is there a way to recover the original compilation schema when the database is upgraded? Thanks.&lt;/p&gt;</comment>
                            <comment id="13797035" author="knutanders" created="Wed, 16 Oct 2013 18:35:47 +0100"  >&lt;p&gt;I don&apos;t think the original compilation schema is stored currently, so we probably cannot get it for the existing constraints. So for the existing constraints that use unqualified function names, I think we only have these options on upgrade:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;use the constraint&apos;s schema as compilation schema (the constraint will preserve the old behaviour on upgrade)&lt;/li&gt;
	&lt;li&gt;fail (either on upgrade or when the CHECK constraint is evaluated)&lt;/li&gt;
	&lt;li&gt;drop ambiguous constraints&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I think I prefer option 1.&lt;/p&gt;

&lt;p&gt;We also need to decide what to do with new constraint definitions in soft upgrade. Since we don&apos;t have a mechanism to store the compilation schema currently, we probably have to use the constraint&apos;s schema for the constraints defined during soft upgrade. That is, preserve the old behaviour. In hard upgraded databases we could change ConstraintDescriptor to include the original compilation schema.&lt;/p&gt;</comment>
                            <comment id="13797131" author="rhillegas" created="Wed, 16 Oct 2013 20:02:13 +0100"  >&lt;p&gt;Thanks, Knut. I agree that option 1 sounds best.&lt;/p&gt;

&lt;p&gt;Where will the compilation schema be persisted? One solution might be to re-write the CHECK condition, adding schema qualifications to all unqualified names. That would be what&apos;s stored in SYS.SYSCHECKS.CHECKDEFINITION. That might finesse the soft-downgrade issue.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13797198" author="knutanders" created="Wed, 16 Oct 2013 21:12:08 +0100"  >&lt;p&gt;My first thought was to add a field to CheckConstraintDescriptor. That approach would require the addition of a new column in SYS.SYSCHECKS, which entails some upgrade work.&lt;/p&gt;

&lt;p&gt;I like the idea of rewriting the CHECK condition and making all unqualified names qualified. Such a solution might be useful for generated columns, views and triggers as well, since qualified names would make it easier to produce correct dblook output for them (see for example &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6370&quot; title=&quot;dblook doesn&amp;#39;t schema-qualify identifiers in trigger actions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6370&quot;&gt;&lt;del&gt;DERBY-6370&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Not sure how easy it is to do the rewrite in a reliable way, though. It might be possible to generalize the code in DataDictionaryImpl.getTriggerActionString(), which replaces old/new transition variables and transition tables with Java method calls or VTIs in trigger actions. But I haven&apos;t looked into that.&lt;/p&gt;

&lt;p&gt;Adding a new column to the system table and pushing the compilation schema might be more robust, since the rewrite may easily miss some references if we&apos;re not careful, or if we extend the allowed syntax later. But it&apos;s not as elegant as rewriting.&lt;/p&gt;</comment>
                            <comment id="13828833" author="knutanders" created="Thu, 21 Nov 2013 11:04:57 +0000"  >&lt;p&gt;I&apos;m looking into rewriting the CHECK constraint before storing it in SYSCHECKS. It looks like all the identifiers that need to be qualified are represented by TableName nodes (even those that are not tables), so using a visitor to find them all might be feasible. Most QueryTreeNode classes don&apos;t currently apply visitors to TableName fields, so many acceptChildren() methods have to be changed or added first.&lt;/p&gt;</comment>
                            <comment id="13829889" author="knutanders" created="Fri, 22 Nov 2013 11:18:49 +0000"  >&lt;p&gt;As to the discussion about SQL-path, Derby&apos;s implicit SQL-path for function name resolution includes the SYSFUN schema. That is, if an unqualified function name cannot be found in the current schema, Derby will try to find the function in SYSFUN.&lt;/p&gt;

&lt;p&gt;CHECK constraints don&apos;t currently handle this very well. If a CHECK constraint references a function in SYSFUN without explicit schema, and later creates a function with the same name in the current schema, the constraint will incorrectly start using the new function.&lt;/p&gt;

&lt;p&gt;Rewriting the CHECK constraint with qualified names before storing it SYSCHECKS will solve this problem. Storing the original compilation schema along with the constraint won&apos;t solve it, since that would not carry information about which function to resolve in the current schema and which to resolve in SYSFUN.&lt;/p&gt;</comment>
                            <comment id="13832529" author="knutanders" created="Tue, 26 Nov 2013 12:15:53 +0000"  >&lt;p&gt;Fetching all the TableName nodes and using them to rewrite the CHECK constraint definition before storing it in SYSCHECKS, seems to be working. As suggested earlier, many accept methods need to be changed in order to make the visitors actually see the TableName nodes. To make it easier to separate these mechanical changes from the new rewrite logic, I&apos;ve split the fix into three patches that should be applied on top of each other. The regression tests ran cleanly after each individual patch.&lt;/p&gt;

&lt;p&gt;Here&apos;s a description of the changes made by each of the patches:&lt;/p&gt;

&lt;p&gt;d6362-1a-visit-tablename.diff: This patch makes the acceptChildren() methods of all QueryTreeNode classes descend into any TableName field, including lists/arrays of TableNames. Since only a very limited subset of the language is allowed in CHECK constraints, we don&apos;t need all of these for CHECK constraints, but I found it easier to convince myself that no essential ones were forgotten if all were visited.&lt;/p&gt;

&lt;p&gt;d6362-2a-fix-tablename-offset.diff: This patch fixes a problem with qualified table names, where the begin offset was set to the beginning of the table name portion of the TableName node, whereas it should have been set to the beginning of the schema name portion. It also makes some synthetic TableName nodes have unspecified offsets (that is, -1) instead of fake offset values.&lt;/p&gt;

&lt;p&gt;d6362-3a-rewrite-checks.diff:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;This patch makes CHECK constraint definitions replace unqualified names with qualified names before storing them in SYS.SYSCHECKS.&lt;/li&gt;
	&lt;li&gt;Since some of the rewrite logic is very similar to the one used to replace references to transition variables in triggers with Java method calls, the common logic was factored out into a shared visitor class (OffsetOrderVisitor, which collects all nodes of a certain type and returns them in offset order).&lt;/li&gt;
	&lt;li&gt;In order to make UDT names in CAST expressions qualified, it had to modify the parser so that it adds a reference to the original TableName node from the CastNode. Without the original TableName node, the rewrite logic wouldn&apos;t know there was a name that needed qualification.&lt;/li&gt;
	&lt;li&gt;It also adds test case.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The test case for this issue tests that type names (in casts), function names and table names are rewritten as qualified identifiers. I&apos;m not aware of any other identifiers that could be used in CHECK constraints. Let me know if you can think of others, and I&apos;ll add tests for them.&lt;/p&gt;</comment>
                            <comment id="13832590" author="knutanders" created="Tue, 26 Nov 2013 13:43:35 +0000"  >&lt;p&gt;I&apos;m clearing the patch available flag because there&apos;s a conflict between these patches and one of the latest commit (either &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3155&quot; title=&quot;Support for SQL:2003 MERGE statement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3155&quot;&gt;&lt;del&gt;DERBY-3155&lt;/del&gt;&lt;/a&gt; revision 1545343, or &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; revision 1545394). When the patch is applied on head of trunk, some CHECK constraints start failing with IndexOutOfBoundsException:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ij&amp;gt; create table t(x varchar(100), check (x = upper(x)));
ERROR XJ001: Java exception: &apos;start 0, end -24, s.length() 14: java.lang.IndexOutOfBoundsException&apos;.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The error is not seen if the patches are applied on top of revision 1545179. I&apos;ll look into it.&lt;/p&gt;</comment>
                            <comment id="13836120" author="knutanders" created="Sun, 1 Dec 2013 21:14:21 +0000"  >&lt;p&gt;The failures seen when the patches are applied on head of trunk, were caused by some changes to the way column references are bound (in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3155&quot; title=&quot;Support for SQL:2003 MERGE statement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3155&quot;&gt;&lt;del&gt;DERBY-3155&lt;/del&gt;&lt;/a&gt;, revision 1545343). Now column references in the CHECK constraint node tree may reference TableName nodes that originate from outside the CHECK constraint. These TableName nodes are found by the visitor during the rewriting, but since they point to tokens outside of the actual CHECK constraint, trying to replace them in the CHECK constraint text will end in index out of bounds.&lt;/p&gt;

&lt;p&gt;I&apos;m uploading a new patch, d6362-3b.diff, that replaces the 3a patch. It should be applied on top of 1a and 2a. The only change in the updated patch is that OffsetOrderVisitor now ignores nodes whose getBeginOffset() and getEndOffset() methods return values that point to tokens outside of the particular SQL fragment that we want to rewrite.&lt;/p&gt;

&lt;p&gt;All regression tests passed with 1a+2a+3b applied on head of trunk.&lt;/p&gt;</comment>
                            <comment id="13840065" author="knutanders" created="Thu, 5 Dec 2013 13:15:22 +0000"  >&lt;p&gt;I have attached a 3c patch that supersedes the 3b patch. This patch removes a workaround that&apos;s not needed now that &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6421&quot; title=&quot;Cast to UDT in CHECK constraint causes NPE or assert failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6421&quot;&gt;&lt;del&gt;DERBY-6421&lt;/del&gt;&lt;/a&gt; has been fixed.&lt;/p&gt;</comment>
                            <comment id="13840067" author="jira-bot" created="Thu, 5 Dec 2013 13:17:13 +0000"  >&lt;p&gt;Commit 1548127 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knutanders&quot; class=&quot;user-hover&quot; rel=&quot;knutanders&quot;&gt;Knut Anders Hatlen&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1548127&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1548127&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6362&quot; title=&quot;CHECK constraint uses wrong schema for unqualified routine invocations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6362&quot;&gt;&lt;del&gt;DERBY-6362&lt;/del&gt;&lt;/a&gt;: CHECK constraint uses wrong schema for unqualified routine invocations&lt;/p&gt;

&lt;p&gt;Part 1: Make sure visitors descend into all TableName nodes.&lt;/p&gt;</comment>
                            <comment id="13840069" author="jira-bot" created="Thu, 5 Dec 2013 13:17:55 +0000"  >&lt;p&gt;Commit 1548128 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knutanders&quot; class=&quot;user-hover&quot; rel=&quot;knutanders&quot;&gt;Knut Anders Hatlen&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1548128&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1548128&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6362&quot; title=&quot;CHECK constraint uses wrong schema for unqualified routine invocations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6362&quot;&gt;&lt;del&gt;DERBY-6362&lt;/del&gt;&lt;/a&gt;: CHECK constraint uses wrong schema for unqualified routine invocations&lt;/p&gt;

&lt;p&gt;Part 2: Fix offset of qualified table names. Their begin offset&lt;br/&gt;
pointed to the beginning of the table name token, but should point to&lt;br/&gt;
the beginning of the schema name token if they have one.&lt;/p&gt;

&lt;p&gt;Also leave begin and end offset unspecified (-1 implied) for some&lt;br/&gt;
synthetic table name nodes that previously set the offsets to 0&lt;br/&gt;
explicitly. This makes it easier to tell whether they are synthetic&lt;br/&gt;
later.&lt;/p&gt;</comment>
                            <comment id="13840072" author="jira-bot" created="Thu, 5 Dec 2013 13:26:43 +0000"  >&lt;p&gt;Commit 1548132 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knutanders&quot; class=&quot;user-hover&quot; rel=&quot;knutanders&quot;&gt;Knut Anders Hatlen&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1548132&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1548132&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6362&quot; title=&quot;CHECK constraint uses wrong schema for unqualified routine invocations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6362&quot;&gt;&lt;del&gt;DERBY-6362&lt;/del&gt;&lt;/a&gt;: CHECK constraint uses wrong schema for unqualified routine invocations&lt;/p&gt;

&lt;p&gt;Part 3:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Refactor code that rewrites trigger actions so that it can be reused&lt;br/&gt;
  for rewriting CHECK constraints.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Rewrite CHECK constraints and make all identifiers schema qualified&lt;br/&gt;
  before storing them in the dictionary.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Make the parser preserve the TableName node for the target type in&lt;br/&gt;
  CAST expressions for user-defined types, so that they get detected&lt;br/&gt;
  by the rewrite logic.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13913295" author="mikem" created="Wed, 26 Feb 2014 18:42:42 +0000"  >&lt;p&gt;consider for 10.10 backport&lt;/p&gt;</comment>
                            <comment id="13915156" author="myrna" created="Thu, 27 Feb 2014 22:53:34 +0000"  >&lt;p&gt;This is a big change. I would suggest not backporting it. Other opinions?&lt;/p&gt;</comment>
                            <comment id="13915179" author="mikem" created="Thu, 27 Feb 2014 23:16:07 +0000"  >&lt;p&gt;I agree on first look.  Changes look intertwined with other changes, so likely not clean backport.  &lt;br/&gt;
+1 to leaving it fixed only in 10.11 and not backporting.&lt;/p&gt;</comment>
                            <comment id="14284832" author="myrna" created="Wed, 21 Jan 2015 00:23:37 +0000"  >&lt;p&gt;bulk change to close all issues resolved but not closed and not changed since June 1, 2014.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12408289">DERBY-3944</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12672316">DERBY-6370</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12615826" name="d6362-1a-visit-tablename.diff" size="26293" author="knutanders" created="Tue, 26 Nov 2013 12:15:53 +0000"/>
                            <attachment id="12615827" name="d6362-2a-fix-tablename-offset.diff" size="5730" author="knutanders" created="Tue, 26 Nov 2013 12:15:53 +0000"/>
                            <attachment id="12615828" name="d6362-3a-rewrite-checks.diff" size="22508" author="knutanders" created="Tue, 26 Nov 2013 12:15:53 +0000"/>
                            <attachment id="12616487" name="d6362-3b.diff" size="23820" author="knutanders" created="Sun, 1 Dec 2013 21:14:21 +0000"/>
                            <attachment id="12617160" name="d6362-3c.diff" size="23737" author="knutanders" created="Thu, 5 Dec 2013 13:15:22 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 2 Oct 2013 13:10:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>351454</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hzifvj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>351743</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>