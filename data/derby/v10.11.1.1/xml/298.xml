<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:07:51 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-298/DERBY-298.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-298] rollforward will not work correctly  if the system happens to crash immediately after rollforward backup.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-298</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;If the system crashes after a rollforward backup; last log file &lt;br/&gt;
is empty(say log2.dat). On next crash-recovery system ignores the  empty log &lt;br/&gt;
file and starts writing to the previous log(say log1.dat),  &lt;br/&gt;
even thought there was successfule log file switch  before the crash.&lt;br/&gt;
The reason I belive it is done this way to avoid special &lt;br/&gt;
handling of crashes  during the log switch process. &lt;/p&gt;

&lt;p&gt;Problem is  on rollfroward restore from a backup log1.dat will get overwritten &lt;br/&gt;
from the copy in the backup, so any transaction that got added to log1.dat&lt;br/&gt;
after the backup was taken will be lost. &lt;/p&gt;

&lt;p&gt;One possible solution that comes to my mind to solve this problem is &lt;br/&gt;
 1) check if an  empty a log file exist after a redo crash-recovery , if &lt;br/&gt;
     the log archive mode is enabled.&lt;br/&gt;
 2) If it exists , delete and do log file switch again &lt;/p&gt;


&lt;p&gt;Repro:&lt;br/&gt;
connect &apos;jdbc:derby:wombat;create=true&apos;;&lt;br/&gt;
create table t1(a int ) ;&lt;br/&gt;
insert into t1 values(1) ;&lt;br/&gt;
insert into t1 values(2) ;&lt;br/&gt;
call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(&lt;br/&gt;
    &apos;extinout/mybackup&apos;, 0);&lt;/p&gt;

&lt;p&gt;--crash (NO LOG RECORDS WENT IN AFTER THE BACKUP).&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:wombat&apos;;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
insert into t1 select a*2 from t1 ;&lt;br/&gt;
select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from t1 ;&lt;/p&gt;

&lt;p&gt;--exit from jvm and restore from backup&lt;/p&gt;

&lt;p&gt;connect&lt;br/&gt;
&apos;jdbc:derby:wombat;rollForwardRecoveryFrom=extinout/mybackup/wombat&apos;;&lt;br/&gt;
select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from t1 ;  &amp;#8211; THIS WILL GIVE INCORRECT VALUES&lt;/p&gt;</description>
                <environment></environment>
        <key id="32702">DERBY-298</key>
            <summary>rollforward will not work correctly  if the system happens to crash immediately after rollforward backup.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="oysteing">&#216;ystein Gr&#248;vlen</assignee>
                                    <reporter username="tsuresh">Suresh Thalamati</reporter>
                        <labels>
                    </labels>
                <created>Thu, 19 May 2005 05:30:02 +0100</created>
                <updated>Tue, 20 Mar 2007 21:53:59 +0000</updated>
                            <resolved>Tue, 10 Jan 2006 18:41:19 +0000</resolved>
                                    <version>10.0.2.1</version>
                                    <fixVersion>10.1.3.1</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="66168" author="oysteing" created="Tue, 24 May 2005 23:50:51 +0100"  >&lt;p&gt;Looking at the code, I became a bit confused about the definition of an empty log file.   Scan.getNextRecordForward contains debug output when it detects an empty log file.  It will then return without setting knownGoodLogEnd.  Hence, new log records will be written to the end of the previous file.  As Suresh says this is probably to be able to handle crashes during log switch.&lt;/p&gt;

&lt;p&gt;However, this is not what happens when I run the recovery part of the example in this report.  Since, currentLogFileLength is a large number, it detects &quot;zapped log end on log file&quot;, goes on to the next file, which does not exist, and returns.  (Who sets the length of a log file?  Is this maximum size until a log switch is performed?)  The effect is the same, but this can not be used to detect an empty log file and apply the solution proposed by Suresh.  Instead, one would have to do some hairy file handling at a later stage.&lt;/p&gt;

&lt;p&gt;An alternative way to fix this would be to just create a dummy log record in the new log file as part of the backup command.  This would make the redo scan end in the new log file.  However, this will not work for those who do backup with OS-commands (i.e., copy the files directly).&lt;/p&gt;

&lt;p&gt;I would also think it should be possible to do the log switch in such a way that it is possible to detect during recovery whether the log switch had completed or not.  If this was the case, one could just set knownGoodLogEnd of the redo scan to the start of the empty file if the log switch was completed.  Does anyone know if this is possible?&lt;/p&gt;

</comment>
                            <comment id="66209" author="oysteing" created="Wed, 25 May 2005 08:15:08 +0100"  >&lt;p&gt;On second thoughts, recovery after an OS-command backup is not an issue since the database will be shut down when the backup is  performed.  So, why not insert a &quot;dummy&quot; record in the new log file when doing backup?  Then, no changes would be needed to the recovery mechanism.&lt;/p&gt;</comment>
                            <comment id="12313185" author="oysteing" created="Fri, 10 Jun 2005 05:33:07 +0100"  >&lt;p&gt;This is further discussed in the following thread: &lt;a href=&quot;http://thread.gmane.org/gmane.comp.apache.db.derby.devel/4170&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://thread.gmane.org/gmane.comp.apache.db.derby.devel/4170&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My current view is that as long as the header it valid, it should be safe to use a new empty log file after recovery.  Unless someone protests, I will change the recovery code to accept the newest log file even if its empty.&lt;/p&gt;</comment>
                            <comment id="12314995" author="oysteing" created="Mon, 4 Jul 2005 20:17:40 +0100"  >&lt;p&gt;The attached patch fixes the bug by setting the logEnd after recovery to the beginning of the new empty log file instead of the end of the previous file. &lt;br/&gt;
The patch contains changes to the following files:&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/store/raw/log/FileLogger.java&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;At the end of the redo scan, if the scan stopped in a file succeeding the file of the last log record, update logEnd to this position.&lt;/li&gt;
	&lt;li&gt;Change assert to allow logEnd to be in a newer file than that of the last log record.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;M      java/engine/org/apache/derby/impl/store/raw/log/Scan.java&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Introduced new variable newFileStart which will only have a valid LogInstant value when the scan is at the header of the file.&lt;/li&gt;
	&lt;li&gt;When a new file is entered, set newFileStart to the first  possible LogInstant of this file (end of header).&lt;/li&gt;
	&lt;li&gt;When a log record is encountered, set newFileStart to INVALID_LOG_INSTANT.&lt;/li&gt;
	&lt;li&gt;Changed getLogRecordEnd() to return newFileStart if that is valid (i.e., scan is at the start of a file)&lt;/li&gt;
	&lt;li&gt;Removed comment about not starting to write to the new empty log file, since that is not true anymore.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackup_app.properties&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Test properties&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;M      java/testing/org/apache/derbyTesting/functionTests/tests/store/copyfiles.ant&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added new property files&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackupSetup_app.properties&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Test properties.&lt;/li&gt;
	&lt;li&gt;useextdirs=true needed so the backup is placed somewhere the next test can find it.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackup.java&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Test that is supposed to be run after RecoveryAfterBackupSetup.java.&lt;/li&gt;
	&lt;li&gt;Does recovery, updates the database, shutdowns the database, and does roll-forward restore.&lt;/li&gt;
	&lt;li&gt;Checks that updates made after recovery is reflected in the database after roll-forward restore.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackupSetup.java&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Test that does the preparation for the RecoveryAfterBackup test.&lt;/li&gt;
	&lt;li&gt;Inserts a few records, makes a backup, and stops without shutting down.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;M      java/testing/org/apache/derbyTesting/functionTests/harness/RunTest.java&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;For tests where the database is not deleted at the end of the test, do not delete the external directories either.&lt;/li&gt;
	&lt;li&gt;This is necessary to be able to access the backup in suceeding tests.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/master/RecoveryAfterBackupSetup.out&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Test output&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/master/RecoveryAfterBackup.out&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Test output&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;MM     java/testing/org/apache/derbyTesting/functionTests/suites/storerecovery.runall&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added tests to storerecovery suite.&lt;/li&gt;
	&lt;li&gt;Changed property eol-style.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12315265" author="tsuresh" created="Fri, 8 Jul 2005 08:29:28 +0100"  >&lt;p&gt;Hi &#216;ystein, &lt;/p&gt;

&lt;p&gt; I could not  understand from the  changes,  If the new log file will be recognized in the following two cases:&lt;br/&gt;
 1)  After the log switch,  if the first log record to the file  gets partially written on a preallocated log file &lt;br/&gt;
 2) After the log swith , if  the first log write is written out of order incompletely and the checksum check verification fails.&lt;/p&gt;

&lt;p&gt;In Scan.java : newFileStart gets set to LogCounter.INVALID_LOG_INSTANT,  immediately &lt;br/&gt;
after reading the instant , but the partial record verification and checksum checks happen&lt;br/&gt;
after that and valid  logEnd  value  still refers to previous log file . &lt;/p&gt;

&lt;p&gt;and also  it might  be good idea to make sure all the fields written in the initialization of  the log file are correct before using the new log file during recovery: initialization writes 4 fileds seperately , &lt;br/&gt;
whereas verification only looks at 3 fields. &lt;/p&gt;

&lt;p&gt;LogToFIle.java()  : initLogFile() :&lt;br/&gt;
newlog.writeInt(fid);&lt;br/&gt;
newlog.writeInt(OBSOLETE_LOG_VERSION_NUMBER); // for silly backwards compatibility reason&lt;br/&gt;
newlog.writeLong(number);&lt;br/&gt;
newlog.writeLong(prevLogRecordEndInstant);&lt;/p&gt;

&lt;p&gt;whereas  LogTOFIle: private boolean verifyLogFormat(StorageRandomAccessFile log, longnumber) &lt;br/&gt;
which is called before the swicth does not  read/verify  &quot;prevLogRecordEndInstant&quot; . &lt;/p&gt;


&lt;p&gt;Thanks&lt;br/&gt;
-suresh&lt;/p&gt;






</comment>
                            <comment id="12315919" author="oysteing" created="Fri, 15 Jul 2005 23:27:33 +0100"  >&lt;p&gt;Suresh,&lt;/p&gt;

&lt;p&gt;The intent is that the new log file should be recognized after a log switch, regardless of what log records may have been written after this log switch. I see your point that if the log file contains a single corrupt record,  the log switch will not have an effect since newFileStart has been reset and logEnd has not been advanced to the new file.  Thanks for detecting this.&lt;/p&gt;

&lt;p&gt;My suggestion for fixing this, is to drop the introduction of newFileStart and just update logEnd to the start of the new log file when the log file is detected.  In addition, logEnd must not be reset to INVALID_LOG_INSTANT when a scan is closed.  This way it is possible to get the logEnd after the scan is closed and check whether it has been advanced since the last log record was processed.&lt;/p&gt;

&lt;p&gt;For the verification of prevLogRecordEndInstant, I guess that the best is to verify this for all files processed during recovery.  I assume that the prevLogRecordEndInstant of a file should be equal to the current logEnd when switching to this file. &lt;/p&gt;

&lt;p&gt;Thanks for the advice, I will create a new patch.&lt;/p&gt;

&lt;p&gt;&#216;ystein&lt;/p&gt;</comment>
                            <comment id="12361100" author="oysteing" created="Thu, 22 Dec 2005 20:12:00 +0000"  >&lt;p&gt;The recently attached patch (derby-298a.diff) addresses Suresh&apos;s&lt;br/&gt;
review comments.  The only major change from the previous patch is in&lt;br/&gt;
java/engine/org/apache/derby/impl/store/raw/log/Scan.java. The changes&lt;br/&gt;
to this file compared to the current head of trunk are:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When a new log file is entered, check that the header of this&lt;br/&gt;
     file refers to the end of the last log record of the previous log&lt;br/&gt;
     file.  If not, stop the scan.&lt;/li&gt;
	&lt;li&gt;If the header was consistent, update knowGoodLogEnd to the first&lt;br/&gt;
     possible LogInstant of this file (end of header).&lt;/li&gt;
	&lt;li&gt;close() no longer reset knownGoodLogEnd since it is needed by&lt;br/&gt;
     FileLogger after the scan is closed.&lt;/li&gt;
	&lt;li&gt;Changed comment of getLogRecordEnd() to reflect that it can be&lt;br/&gt;
     used after the scan is closed, and that it at that time may&lt;br/&gt;
     return the start of an empty log file.&lt;/li&gt;
	&lt;li&gt;Removed comment about not starting to write to the new empty log&lt;br/&gt;
     file, since that is not true anymore.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In addition, the property files for the tests have been updated so&lt;br/&gt;
they are run without the security manager.&lt;/p&gt;

&lt;p&gt;derbyall has been run with no new failures.&lt;/p&gt;</comment>
                            <comment id="12361808" author="tsuresh" created="Thu, 5 Jan 2006 11:18:51 +0000"  >&lt;p&gt;&#216;ystein ,&lt;/p&gt;

&lt;p&gt;I reviewed the  latest patch, it looks good.  But  I could  not understand why you would need the following check ?&lt;/p&gt;

&lt;p&gt;FileLogge.java :&lt;br/&gt;
+            long end = redoScan.getLogRecordEnd(); &lt;br/&gt;
+            if (end != LogCounter.INVALID_LOG_INSTANT&lt;/p&gt;

&lt;p&gt;If end is  LogCounter.INVALID_LOG_INSTANT then logEnd is also likely to be LogCounter.INVALID_LOG_INSTANT  right ?&lt;/p&gt;

&lt;p&gt;+                &amp;amp;&amp;amp; (LogCounter.getLogFileNumber(logEnd) &lt;br/&gt;
+                    &amp;lt; LogCounter.getLogFileNumber(end))) &lt;/p&gt;
{
+                logEnd = end;
+            }

&lt;p&gt;In what secnario  condition  will be  false ?   If end is  LogCounter.INVALID_LOG_INSTANT then logEnd is also likely to be &lt;/p&gt;


&lt;p&gt;Another minor thing I notices is  test files copyrigth notices have wrong file names :&lt;br/&gt;
RecoveryAfterBackup.java:&lt;br/&gt;
Derby - Class org.apache.derbyTesting.functionTests.store.LogChecksumSetup&lt;br/&gt;
RecoveryAfterBackupSetup.java:&lt;br/&gt;
Derby - Class org.apache.derbyTesting.functionTests.store.LogChecksumSetup&lt;/p&gt;


&lt;p&gt;Thanks&lt;br/&gt;
-suresh&lt;/p&gt;</comment>
                            <comment id="12361817" author="oysteing" created="Thu, 5 Jan 2006 17:45:36 +0000"  >&lt;p&gt;Suresh,&lt;/p&gt;

&lt;p&gt;You are right that with my latest version of the patch,&lt;br/&gt;
getLogRecorEnd() will only return INVALID_LOG_INSTANT when the scan&lt;br/&gt;
did not get out of the starting blocks.  Regardsless of that, the&lt;br/&gt;
second part of the if test will always be false when end is&lt;br/&gt;
INVALID_LOG_INSTANT.&lt;/p&gt;

&lt;p&gt;I will remove the unecessary check and fix the copyright notices.&lt;/p&gt;</comment>
                            <comment id="12361843" author="oysteing" created="Thu, 5 Jan 2006 22:02:19 +0000"  >&lt;p&gt;derby-298b.diff is an updated patch that fixes the issues raised by Suresh in his latest review.&lt;br/&gt;
The storeall testsuite has been run without errors.  Are currently running the derbyall testsuite.  &lt;br/&gt;
Will notify list later today if derbyall should fail.&lt;/p&gt;</comment>
                            <comment id="12362313" author="oysteing" created="Tue, 10 Jan 2006 18:41:19 +0000"  >&lt;p&gt;Verified that the added test run without failure.&lt;/p&gt;</comment>
                            <comment id="12362691" author="djd" created="Sat, 14 Jan 2006 06:44:58 +0000"  >&lt;p&gt;This patch added two new tests, RecoveryAfterBackup and RecoveryAfterBackupSetup, both of which are being run without a SecurityManager due to the noSecurityManager=true in their _app.properties files.&lt;/p&gt;

&lt;p&gt;Why are these tests excluded from running with a SecurityManager?&lt;br/&gt;
It should be rare that a test is to not to be run with a SecurityManager, if such a need arises the noSecurityManager=true must be commented to indicate why this is the case.&lt;/p&gt;

&lt;p&gt;The default for any new tests in the existing harness should be to run with the SecurityManager.&lt;/p&gt;

&lt;p&gt;There are a handful of tests that have noSecurityManager=true with no comment or a comment that says needs investigating, I&apos;m working on all of these since they are exisiting tests, but it&apos;s not my itch to clean up new tests.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12311078" name="derby-298.diff" size="19972" author="oysteing" created="Mon, 4 Jul 2005 20:17:40 +0100"/>
                            <attachment id="12321515" name="derby-298a.diff" size="20015" author="oysteing" created="Thu, 22 Dec 2005 19:39:38 +0000"/>
                            <attachment id="12321717" name="derby-298b.diff" size="20015" author="oysteing" created="Thu, 5 Jan 2006 22:02:19 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 24 May 2005 22:50:51 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21879</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy12zr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40135</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>