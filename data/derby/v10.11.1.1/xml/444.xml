<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:44:13 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-444/DERBY-444.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-444] Handle OutOfMemoryError exceptions when creating a new embedded connection</title>
                <link>https://issues.apache.org/jira/browse/DERBY-444</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;If an OutOfMemoryError is thrown while creating objects for a new embedded connection, reject the connection request with a SQLException and do not shutdown the system.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12312021">DERBY-444</key>
            <summary>Handle OutOfMemoryError exceptions when creating a new embedded connection</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12312019">DERBY-443</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="djd">Daniel John Debrunner</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                    </labels>
                <created>Thu, 7 Jul 2005 06:28:36 +0100</created>
                <updated>Sat, 11 Mar 2006 03:04:45 +0000</updated>
                            <resolved>Sat, 11 Mar 2006 03:04:22 +0000</resolved>
                                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12368645" author="djd" created="Fri, 3 Mar 2006 12:55:03 +0000"  >&lt;p&gt;Draft patch of the direction I&apos;m working on.&lt;/p&gt;

&lt;p&gt;The program/test  memory/ConnectionHandling.java (added under this issue) creates about 19,000 connections&lt;br/&gt;
in a JVM limited to 64Mb before failing due to an OutOfMemoryError. The test then goes on to try to open 500&lt;br/&gt;
more connections (while holding the previous 19,000+ open)  to see what happens.&lt;/p&gt;

&lt;p&gt;With the existing code basically a mess happens, the initial OutOfMemoryError I think closes the database&lt;br/&gt;
and then each of the 500 connection opens is a (slow) boot attempt with limited memory. About 95 out of 500 pass,&lt;br/&gt;
but I believe all the existing connections are closed since the database was closed underneath them. The&lt;br/&gt;
test does have logic to count how many of its existing open connections have become closed , but with the&lt;br/&gt;
existing code an OutOfMemoryError is hit and no reporting takes place.&lt;/p&gt;

&lt;p&gt;With the patch, roughly the same number  (19,000+)  of connections are successfully opened, but the most of&lt;br/&gt;
the subsequent failures due to lack of memory receive a SQLException with a 08004 SQL state. These exceptions&lt;br/&gt;
do not shut down the database and the 19,000 connections remain open, and can be closed with no further exceptions.&lt;br/&gt;
About 495 of the 500 requests once memory is full receive a 08004 SQLException, and about 5 recieve a direct OutOfMemoryError.&lt;br/&gt;
These dirrect OutOfMemoryErrors occur above Derby, in the DriverManager class due to object allocation there. Thus the OOME has&lt;br/&gt;
no effect on Derby.&lt;/p&gt;

&lt;p&gt;Thus a summary is:&lt;br/&gt;
 Existing code:&lt;br/&gt;
       19,000+ connections in 64Mb, once limit is hit all are implicitly closed and a handful of future requests succeed&lt;br/&gt;
       but any OOME shuts the database down again. System does not degrade well.&lt;/p&gt;

&lt;p&gt;  Patch&lt;br/&gt;
       19,000+ connections in 64Mb, once limit is hit some stability is acheieved, no more connection requests succeed.&lt;br/&gt;
        System behaves well.&lt;/p&gt;

&lt;p&gt;Next comment will describe this draft patch&lt;/p&gt;</comment>
                            <comment id="12368650" author="djd" created="Fri, 3 Mar 2006 13:29:12 +0000"  >&lt;p&gt;The draft patch has three components:&lt;/p&gt;

&lt;p&gt;1) Catching OutOfMemoryErrors in the paths where a new embedded connection is obtained. Basically within&lt;br/&gt;
EmbeddedConnection constructor and within InternalDriver when creating the connection.&lt;/p&gt;

&lt;p&gt;2) A new static SQLException with SQLstate 08004 that is thrown when a connection cannot be obtained due to low memory&lt;/p&gt;

&lt;p&gt;3) A new LowMemory class that provides utiltity methods to indicate and check for low memory. Any area that&lt;br/&gt;
can recover from an out of memory situation can create a static instance of this class to manage its own low&lt;br/&gt;
memory threshold. The setLowMemory() is called when an OutOfMemoryError is thrown and records the current free&lt;br/&gt;
memory, that value is then used as future watermark at which point the operation (in this case opening a connection)&lt;br/&gt;
will not be attempted and instead a low memory situation is assumed, and the static exception thrown.&lt;br/&gt;
Setting the low water mark value needs some more investigation.&lt;/p&gt;

&lt;p&gt;Future ideas include having a callback where on a low memory situation, seen by LowMemory.setLowMemory,&lt;br/&gt;
callbaclks coudl be invoked to get classes to reduce their memory usage, such as caches.&lt;/p&gt;
</comment>
                            <comment id="12368805" author="bryanpendleton" created="Sat, 4 Mar 2006 07:08:41 +0000"  >&lt;p&gt;I&apos;m not sure I&apos;m following the basic thrust of this. Is there something special about the Connection object? Couldn&apos;t we just as easily happen to run out of memory when creating a Statement, or a ResultSet, or at various other places where the app calls into Derby to perform some work?&lt;/p&gt;

&lt;p&gt;Would every class in the external API need be changed similarly to how you changed EmbedConnection and InternalDriver?&lt;/p&gt;

&lt;p&gt;thanks,&lt;/p&gt;

&lt;p&gt;bryan&lt;/p&gt;</comment>
                            <comment id="12368811" author="djd" created="Sat, 4 Mar 2006 07:42:12 +0000"  >&lt;p&gt;This is a sub-task of &lt;/p&gt;

&lt;p&gt;Make Derby engine robust in case of OutOfMemoryError exceptions  (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-443&quot; title=&quot;Make Derby engine robust in case of OutOfMemoryError exceptions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-443&quot;&gt;DERBY-443&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;So, yes, one would need to do other changes in other areas, I&apos;m just starting off in one well contained area as a way to&lt;br/&gt;
see what is possible and to see if I can provide some form of initial framework/useful code. Incremental development,&lt;br/&gt;
get something simple working quickly and build from there, rather than trying to solve everything completely.&lt;/p&gt;

&lt;p&gt;I do think something needs to be done in this area (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-443&quot; title=&quot;Make Derby engine robust in case of OutOfMemoryError exceptions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-443&quot;&gt;DERBY-443&lt;/a&gt;), there is the person on derby-user that put the cache-size up&lt;br/&gt;
to 10,,000 pages and may be hitting OutOfMemoryErrors, wouldn&apos;t it be better if Derby just didn&apos;t shutdown with his&lt;br/&gt;
configuration, instead kept runing after it saw an OOME with a smaller cache. This specific patch/Jira issue doesn&apos;t get us there&lt;br/&gt;
but I&apos;m trying to make a start. I just chose to start with connections.&lt;/p&gt;</comment>
                            <comment id="12368821" author="djd" created="Sat, 4 Mar 2006 09:32:20 +0000"  >&lt;p&gt;More on the setting the low water mark. The low memory water mark is a value, proposed by this fix, that  disables operations&lt;br/&gt;
if the JVM&apos;s free memory is lower than the mark, to allow some chance of recovery rather than wasting cpu cycles performing&lt;br/&gt;
an operation that is most likely doomed to throw an OutOfMemoryError (OOME). The low water mark would be set dynamically per operation type by checking the free memory at the first OOME for that operation.&lt;/p&gt;

&lt;p&gt;Given that I can successfully open around 19,000 connections in 64Mb, that makes a just opened connection overhead on the order of  3.5kb.  I was suprised when the call  Runtime.getRuntime().freeMemory() returned around 100k to 400k when an OutOfMemoryError  (OOME) is hit the first time opening a connection. I was expecting a number closer to the apparent overhead of the connection.&lt;/p&gt;

&lt;p&gt;Because in a multi-threaded environment another thread could release a whole lot of memory between my thread&apos;s OOME and  it calling Runtime.getRuntime().freeMemory()  I was planning to ignore the low water mark if was was &quot;bigger&quot; than some estimate, in this case say 10k for a connection. This was to avoid a situation of setting a low water mark that was huge (due to other released memory) and subsequently disabling all connection requests.&lt;/p&gt;

&lt;p&gt;However the reality is the freeMemory at OOME time seems much bigger than any reasonable estimate, and I&apos;m not sure a estimate of 100k-400k for a connection seems reasonable when the overhead is 3.5k. Seems like in some JVMs the low water&lt;br/&gt;
mark could typically be much lower.&lt;/p&gt;

&lt;p&gt;My new approach is to only have the low water mark for 5 seconds, then it gets discarded, any subsequent  OOME for the same operation would then set a new low water mark. This means even a really bad low water mark would not break the system, but just deny service of that operation for five seconds. I picked five seconds as a reasonable time for memory to be released, say by future work in Derby.&lt;/p&gt;

&lt;p&gt;I also tried running the  memory/ConnectionHandling test without the concept of a low water mark, just throwing the&lt;br/&gt;
static SQLException if an OOME was thrown. This did not work, the test just hung somewhere in the opening 500&lt;br/&gt;
extra connections once the first OOME was hit. Thus this backing off strategy with the low water mark is some help,&lt;br/&gt;
it allows the JVM to spend some cpu cycles doing useful garbage collection, rather than trying operations that are doomed to fail.&lt;/p&gt;

</comment>
                    </comments>
                    <attachments>
                            <attachment id="12323656" name="derby444_draft_v1.txt" size="7006" author="djd" created="Fri, 3 Mar 2006 12:55:03 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 4 Mar 2006 07:08:41 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29551</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy1713:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40789</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>