<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:41:23 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4062/DERBY-4062.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4062] Remove single-argument getDataValue overrides from DataValueFactory interface</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4062</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;[ Issue title edited to reflect the discussion about how to clarify the use of this interface. ]&lt;/p&gt;

&lt;p&gt;I believe the problem involves o.a.d.iapi.types.DataValueFactory.&lt;br/&gt;
This interface defines dozens and dozens of overloads of the method&lt;br/&gt;
getDataValue(), for lots of different combinations of datatypes.&lt;/p&gt;

&lt;p&gt;For most of the Java &quot;boxed&quot; types (Short, Long, Float, Double, etc.),&lt;br/&gt;
DataValueFactory defines a pair of getDataValue() methods. For example,&lt;br/&gt;
here are the method pair that the interface defines for Short:&lt;/p&gt;

&lt;p&gt;        /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Get a SQL smallint with the given value.  A null argument means get&lt;/li&gt;
	&lt;li&gt;a SQL null value.  The second form uses the previous value (if non-null)&lt;/li&gt;
	&lt;li&gt;to hold the return value.&lt;br/&gt;
         *&lt;br/&gt;
         */&lt;br/&gt;
        NumberDataValue         getDataValue(Short value);&lt;br/&gt;
        NumberDataValue         getDataValue(Short value, NumberDataValue previous)&lt;br/&gt;
                                                        throws StandardException;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;HOWEVER, for the Integer type, DataValueFactory doesn&apos;t define both overloads,&lt;br/&gt;
but only defines the &apos;previous&apos;-style overload:&lt;/p&gt;

&lt;p&gt;        /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Get a SQL int with the given value.  A null argument means get&lt;/li&gt;
	&lt;li&gt;a SQL null value.  Uses the previous value (if non-null)&lt;/li&gt;
	&lt;li&gt;to hold the return value.&lt;br/&gt;
         *&lt;br/&gt;
         */&lt;br/&gt;
        NumberDataValue         getDataValue(Integer value, NumberDataValue previous)&lt;br/&gt;
                                                        throws StandardException;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The actual implementation, in o.a.d.iapi.types.DataValueFactoryImpl, though,&lt;br/&gt;
does implement both the Integer overloads. But this method is NOT present&lt;br/&gt;
in the DataValueFactory interface:&lt;/p&gt;

&lt;p&gt;        NumberDataValue         getDataValue(Integer value);&lt;/p&gt;

&lt;p&gt; Because this method is not present in the interface, code such as&lt;/p&gt;

&lt;p&gt;   row.setColumn(SYSXPLAIN_RESULTSET_NO_OPENS, dvf.getDataValue(no_opens));&lt;/p&gt;

&lt;p&gt;which the code anticipates will invoke the above method, instead calls the method&lt;/p&gt;

&lt;p&gt;   public UserDataValue getDataValue(Object value); &lt;/p&gt;

&lt;p&gt;which has a very different behavior (instead of returning a SQLInteger, it returns a UserType).&lt;/p&gt;

&lt;p&gt;This accidental invocation of the wrong implementation method was causing data corruption&lt;br/&gt;
errors in regression tests for the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2487&quot; title=&quot;Enhance Derby with EXPLAIN Functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2487&quot;&gt;&lt;del&gt;DERBY-2487&lt;/del&gt;&lt;/a&gt; patch, which uses the above setColumn call.&lt;br/&gt;
Instead of inserting SQLInteger values into the system table, the code was inserting&lt;br/&gt;
java.lang.Integer UserType values; since those values don&apos;t match the defined type of&lt;br/&gt;
the column(s) in the system catalog, the table appeared to be corrupt.&lt;/p&gt;

&lt;p&gt;I believe that this problem never affects external Derby applications, but only internal Derby code,&lt;br/&gt;
as the DataValueFactory interface is an internal interface only. Still, since it appeared to&lt;br/&gt;
cause data corruption and invalid query results, it is potentially a quite serious problem.&lt;/p&gt;

&lt;p&gt;See this thread in the derby-dev archives for a bit more discussion:&lt;br/&gt;
&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/db-derby-dev/200902.mbox/%3C4997818E.3080007@amberpoint.com%3E&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/db-derby-dev/200902.mbox/%3C4997818E.3080007@amberpoint.com%3E&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12414909">DERBY-4062</key>
            <summary>Remove single-argument getDataValue overrides from DataValueFactory interface</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12365794">DERBY-2487</parent>
                                    <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="bryanpendleton">Bryan Pendleton</assignee>
                                    <reporter username="bryanpendleton">Bryan Pendleton</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 Feb 2009 01:53:50 +0000</created>
                <updated>Fri, 21 Jan 2011 17:52:17 +0000</updated>
                            <resolved>Thu, 14 May 2009 03:36:49 +0100</resolved>
                                                    <fixVersion>10.6.1.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12674085" author="bryanpendleton" created="Tue, 17 Feb 2009 01:57:34 +0000"  >&lt;p&gt;Attached patch adds the indicated method to the DataValueFactory interface.&lt;/p&gt;

&lt;p&gt;The regular regression tests ran clean, except that I can&apos;t run the upgrade tests&lt;br/&gt;
right now due to svn.apache.org being down.&lt;/p&gt;

&lt;p&gt;Can anyone think of a straightforward way to write a regression test for this?&lt;br/&gt;
Since the DataValueFactory API is an internal class, it&apos;s hard to expose&lt;br/&gt;
this problem from one of the typical JDBC JUnit tests. Can one of our&lt;br/&gt;
JUnit tests get an instance of the DataValueFactoryImpl in a simple manner?&lt;/p&gt;
</comment>
                            <comment id="12674137" author="knutanders" created="Tue, 17 Feb 2009 08:16:40 +0000"  >&lt;p&gt;Myrna mentioned on derby-dev that the method used to be there. I checked and it&apos;s still in the 10.0-10.2 branches. It was removed in this commit:&lt;/p&gt;

&lt;p&gt;------------------------------------------------------------------------&lt;br/&gt;
r540791 | djd | 2007-05-23 01:34:39 +0200 (Wed, 23 May 2007) | 2 lines&lt;/p&gt;

&lt;p&gt;Remove some unused methods in DataValueFactory that fetched new DataValueDescriptors without passing&lt;br/&gt;
in a holder object.&lt;br/&gt;
------------------------------------------------------------------------&lt;/p&gt;</comment>
                            <comment id="12674323" author="bryanpendleton" created="Tue, 17 Feb 2009 19:26:57 +0000"  >&lt;p&gt;Thanks for tracking the commit down, Knut. That change occurred&lt;br/&gt;
after the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2487&quot; title=&quot;Enhance Derby with EXPLAIN Functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2487&quot;&gt;&lt;del&gt;DERBY-2487&lt;/del&gt;&lt;/a&gt; patch was originally developed, which&lt;br/&gt;
helps explain why the original developer of that patch didn&apos;t notice this.&lt;/p&gt;

&lt;p&gt;I&apos;m a little confused about why the change removed some of &lt;br/&gt;
the DVF single-argument API overloads, but not all of them.&lt;/p&gt;

&lt;p&gt;For example, revision 540791 removed getDataValue(short)&lt;br/&gt;
from the DataValueFactory interface, but left getDataValue(Short).&lt;/p&gt;

&lt;p&gt;But the reverse change occurred with int/Integer: revision 540791&lt;br/&gt;
removed getDataValue(Integer) from the DataValueFactory interface,&lt;br/&gt;
but left getDataValue(int). So that&apos;s confusing.&lt;/p&gt;

&lt;p&gt;Also, the change removed the &lt;b&gt;implementation&lt;/b&gt; of getDataValue(short)&lt;br/&gt;
as well as the interface, but for getDataValue(Integer) the method&lt;br/&gt;
was removed only from the interface, not from the implementation.&lt;/p&gt;

&lt;p&gt;I suppose that one alternative is to leave this alone as is, and to alter&lt;br/&gt;
the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2487&quot; title=&quot;Enhance Derby with EXPLAIN Functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2487&quot;&gt;&lt;del&gt;DERBY-2487&lt;/del&gt;&lt;/a&gt; code so that instead of calling getDataValue(Integer),&lt;br/&gt;
it calls getDataValue(Integer, NumberDataValue previous), and pass&lt;br/&gt;
a NULL value for previous. Thus change:&lt;/p&gt;

&lt;p&gt;  row.setColumn(SYSXPLAIN_RESULTSET_NO_OPENS, dvf.getDataValue(no_opens));&lt;/p&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;p&gt;  row.setColumn(SYSXPLAIN_RESULTSET_NO_OPENS, dvf.getDataValue(no_opens, (NumberDataValue)null));&lt;/p&gt;

&lt;p&gt;and similarly for all the other Integer columns in the new system tables.&lt;/p&gt;

&lt;p&gt;It&apos;s a little bit scary to leave this interface in this strange state where, due&lt;br/&gt;
to argument promotion rules, the caller may not be completely clear on&lt;br/&gt;
what actual overridden method will be called.&lt;/p&gt;
</comment>
                            <comment id="12674567" author="knutanders" created="Wed, 18 Feb 2009 10:38:32 +0000"  >&lt;p&gt;I find this change confusing too. I&apos;d say we should either remove all the methods without a previous parameter, or we should keep all of them. The existence of a catch-all method (getDataValue(Object)) that silently returns another data type than expected makes it too risky to have the mix that we have now, in my opinion.&lt;/p&gt;

&lt;p&gt;If we follow the pattern of the 540791 commit, we should replace calls to dvf.getDataValue() without a previous argument with a direct call to the constructor of the data type we want. So we would change&lt;/p&gt;

&lt;p&gt;  row.setColumn(SYSXPLAIN_RESULTSET_NO_OPENS, dvf.getDataValue(no_opens));&lt;/p&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;p&gt;  row.setColumn(SYSXPLAIN_RESULTSET_NO_OPENS, new SQLInteger(no_opens));&lt;/p&gt;

&lt;p&gt;I see that that&apos;s what many other row factories do as well, and in some ways I think it&apos;s easier to read as you immediately see what&apos;s the intended data type for that column. And the SQL* classes are in the same iapi package as the DataValueFactory interface, so it&apos;s not like we&apos;re exposing implementation details by making such a change.&lt;/p&gt;</comment>
                            <comment id="12674568" author="kristwaa" created="Wed, 18 Feb 2009 10:59:49 +0000"  >&lt;p&gt;I guess the DataValueFactory interface (and the two implementations) were introduced to allow for multiple setups.&lt;br/&gt;
Is it safe to create the data types directly? I&apos;m thinking of cases like DECIMAL, where we need a special implementation to support J2ME.&lt;/p&gt;</comment>
                            <comment id="12674580" author="knutanders" created="Wed, 18 Feb 2009 11:52:35 +0000"  >&lt;p&gt;The methods that have different implementations have their own separate names (getDecimalDataValue() instead of getDataValue()) so I don&apos;t think they will be affected if we remove the getDataValue() methods.&lt;/p&gt;</comment>
                            <comment id="12674653" author="bryanpendleton" created="Wed, 18 Feb 2009 15:30:02 +0000"  >&lt;p&gt;I think that removing the single-argument overrides would clarify the use of&lt;br/&gt;
the interface, and so for the present I changed the issue to title to reflect that idea.&lt;/p&gt;</comment>
                            <comment id="12705599" author="bryanpendleton" created="Mon, 4 May 2009 15:21:26 +0100"  >&lt;p&gt;There are a couple dozen calls to the single-argument version&lt;br/&gt;
of getDataValue(). It seems that if I could replace those calls&lt;br/&gt;
either with (a) equivalent calls to the multi-argument versions,&lt;br/&gt;
or with (b) direct calls to the underlying data type constructors,&lt;br/&gt;
then I could remove all the single-argument getDataValue&lt;br/&gt;
overrides from both the interface and the implementation,&lt;br/&gt;
and the result would be less code and simpler code.&lt;/p&gt;

&lt;p&gt;I&apos;ll investigate a possible patch that does this.&lt;/p&gt;</comment>
                            <comment id="12705659" author="bryanpendleton" created="Mon, 4 May 2009 18:45:48 +0100"  >&lt;p&gt;Consider this little snippet of code from SQLBooleanConstantNode.java:&lt;/p&gt;

&lt;p&gt;                if ( val == null )&lt;/p&gt;
                {
                        setValue(getTypeServices().getNull() );
                }&lt;br/&gt;
                else&lt;br/&gt;
                {
                        setValue(getDataValueFactory().getDataValue(val.booleanValue()));
                }&lt;br/&gt;
&lt;br/&gt;
It seems like there are (at least) 4 possible ways to re-write it, with (I believe) the same result.&lt;br/&gt;
&lt;br/&gt;
The first way I thought of was to replace the call to the single-argument version of&lt;br/&gt;
getDataValue(boolean) with a call to getDataValue(boolean, BooleanDataValue). This makes&lt;br/&gt;
this bit of code a little bit messier, but it allows us to remove getDataValue(boolean) from&lt;br/&gt;
the DataValueFactory interface.&lt;br/&gt;
&lt;br/&gt;
                if ( val == null )&lt;br/&gt;
                {
                        setValue(getTypeServices().getNull() );
                }
&lt;p&gt;                else&lt;/p&gt;
                {
                        setValue(getDataValueFactory().getDataValue(val.booleanValue(), (BooleanDataValue)null));
                }

&lt;p&gt;The second way I thought of is to use Knut&apos;s suggestion of directly calling the SQLBoolean&lt;br/&gt;
constructor that we want, which in this case is SQLBoolean(boolean):&lt;/p&gt;

&lt;p&gt;                if ( val == null )&lt;/p&gt;
                {
                        setValue(getTypeServices().getNull() );
                }
&lt;p&gt;                else&lt;/p&gt;
                {
                        setValue(new SQLBoolean(val.booleanValue()));
                }

&lt;p&gt;The third way to handle this is to observe that DataValueFactoryImpl.getDataValue(Boolean)&lt;br/&gt;
already knows what to do if the passed-in Boolean object is null, so we can simplify&lt;br/&gt;
this entire code in SQLBooleanConstantNode.java, I think, with the following:&lt;/p&gt;

&lt;p&gt;                setValue(getDataValueFactory().getDataValue(val));&lt;/p&gt;

&lt;p&gt;The fourth way to handle this is to again eliminate the call to the DataValueFactory,&lt;br/&gt;
which doesn&apos;t seem to be adding much value here, and simply construct a SQLBoolean&lt;br/&gt;
object using the SQLBoolean(Boolean) constructor, which, too, knows what to do if&lt;br/&gt;
the passed-in Boolean object is null, so we can just write:&lt;/p&gt;

&lt;p&gt;                setValue(new SQLBoolean(val));&lt;/p&gt;

&lt;p&gt;This last code seems quite clear and simple, but I&apos;m worried that maybe I&apos;m over-simplifying&lt;br/&gt;
things too much? Still, I think I&apos;ll at least pursue this 4th approach, and see what sort of&lt;br/&gt;
a patch proposal I end up with.&lt;/p&gt;</comment>
                            <comment id="12706004" author="knutanders" created="Tue, 5 May 2009 13:00:21 +0100"  >&lt;p&gt;Alternative 4 sounds good to me. I think both (3) and (4) are better than (1) and (2), but (3) still uses the single-argument getDataValue method (I assume that&apos;s just a typo?).&lt;/p&gt;</comment>
                            <comment id="12706536" author="bryanpendleton" created="Wed, 6 May 2009 18:48:38 +0100"  >&lt;p&gt;Knut, thanks for the feedback. You&apos;re right, that was a typo in my previous comment,&lt;br/&gt;
I had meant to suggest the alternative of switching to the 2-argument getDataValue() call.&lt;/p&gt;

&lt;p&gt;But I also feel that the 4th alternative, the one which directly invokes the SQLtype constructor,&lt;br/&gt;
is the cleanest, so I went ahead with a prototype of this approach.&lt;/p&gt;

&lt;p&gt;Attached is removeSingleArgOverrides.diff, a patch proposal. I think it&apos;s appealing&lt;br/&gt;
because not only does it remove the core problem that this issue is concerned with&lt;br/&gt;
(ambiguity in method overriding in the DataValueFactory interface), but it also does&lt;br/&gt;
so by deleting code (which is good), and by making the code more self-evident, I think.&lt;/p&gt;

&lt;p&gt;For example, consider this bit from SYSCONGLOMERATESRowFactory.java:&lt;/p&gt;

&lt;p&gt;The current code says:&lt;/p&gt;

&lt;p&gt;                /* 3rd column is CONGLOMERATENUMBER (long) */&lt;br/&gt;
                row.setColumn(3, dvf.getDataValue(conglomNumber));&lt;/p&gt;

&lt;p&gt;The new code says:&lt;br/&gt;
                /* 3rd column is CONGLOMERATENUMBER (long) */&lt;br/&gt;
                row.setColumn(3, new SQLLongint(conglomNumber));&lt;/p&gt;

&lt;p&gt;I think that the new code is clearer.&lt;/p&gt;

&lt;p&gt;Please have a look at the patch and let me know what you think.&lt;/p&gt;</comment>
                            <comment id="12706768" author="knutanders" created="Thu, 7 May 2009 09:52:47 +0100"  >&lt;p&gt;The patch looks like an improvement to me. +1 to commit it as it is.&lt;/p&gt;

&lt;p&gt;Is there any particular reason why you want to keep the single-arg method that takes an Object and returns a UserType?&lt;/p&gt;

&lt;p&gt;I think some of the methods in DataValueFactoryImpl can be simplified even further. For example:&lt;/p&gt;

&lt;p&gt;                 if (previous == null)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return getDataValue(value);&lt;br/&gt;
+                
{
+                    if (value != null)
+                        return new SQLSmallint(value.shortValue());
+                    else
+                        return new SQLSmallint();
+                }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Could be: if (previous == null) return new SQLSmallint(value);&lt;/p&gt;</comment>
                            <comment id="12708045" author="bryanpendleton" created="Mon, 11 May 2009 15:20:22 +0100"  >&lt;p&gt;Thanks Knut for the careful review. I&apos;ve updated the patch, and&lt;br/&gt;
I think it&apos;s looking quite clean.&lt;/p&gt;

&lt;p&gt;My regression test runs were successful; I think this patch is&lt;br/&gt;
ready for any last review prior to commit. Please let me know&lt;br/&gt;
of any additional comments or suggestions.&lt;/p&gt;</comment>
                            <comment id="12708409" author="knutanders" created="Tue, 12 May 2009 13:12:17 +0100"  >&lt;p&gt;Thanks for the updated patch, Bryan. I don&apos;t have any further comments. +1&lt;/p&gt;</comment>
                            <comment id="12709249" author="bryanpendleton" created="Thu, 14 May 2009 03:36:49 +0100"  >&lt;p&gt;Committed to the trunk as revision 774617.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12400303" name="addToInterface.diff" size="617" author="bryanpendleton" created="Tue, 17 Feb 2009 01:57:34 +0000"/>
                            <attachment id="12407779" name="changesFromReview.diff" size="41827" author="bryanpendleton" created="Mon, 11 May 2009 15:20:22 +0100"/>
                            <attachment id="12407155" name="getDataValueCalls.out" size="9093" author="bryanpendleton" created="Mon, 4 May 2009 15:21:26 +0100"/>
                            <attachment id="12407378" name="removeSingleArgOverrides.diff" size="30178" author="bryanpendleton" created="Wed, 6 May 2009 18:48:38 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10364"><![CDATA[Data corruption]]></customfieldvalue>
    <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 17 Feb 2009 08:16:40 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31116</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0l73:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37252</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>