<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:08:36 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3693/DERBY-3693.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3693] Deadlocks accessing DB metadata</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3693</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;My code changes DB structure (create a column), then immediately after setting autocommit back to true, the code rescans the DB metadata&lt;br/&gt;
DatabaseMetaData.getColumns(catalog, schemaName, tableName, null);&lt;/p&gt;

&lt;p&gt;I am sometimes getting a deadlock with these operations:&lt;/p&gt;

&lt;p&gt;2008-04-16 19:50:47.833 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Default RequestProcessor,1,system&amp;#93;&lt;/span&gt; (XID = 569844), (SESSIONID = 2), (DATABASE = /..../a3/.config/localdb/db), (DRDAID = null), Cleanup action starting 2008-04-16 19:50:47.833 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Default RequestProcessor,1,system&amp;#93;&lt;/span&gt; (XID = 569844), (SESSIONID = 2),  (DATABASE = /..../IJCProjects/a3/.config/localdb/db), (DRDAID = null), Failed Statement is: EXECUTE STATEMENT SYS.&quot;getColumns&quot; ERROR 40XL2: A lock could not be obtained within the time requested.&lt;/p&gt;

&lt;p&gt;The lockTable dump is:&lt;br/&gt;
2008-04-16 19:50:47.796 GMT&lt;br/&gt;
XID       |TYPE         |MODE|LOCKCOUNT|LOCKNAME                                                 |STATE|TABLETYPE /LOCKOBJ                   |INDEXNAME / CONTAINER_ID / MODE for LATCH only)  |TABLENAME / CONGLOM_ID                |&lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;The following row is the victim ***&lt;br/&gt;
569852    |ROW          |X   |0        |(44,7)                                                |WAIT |S                      |NULL |SYSSTATEMENTS                         | &lt;/li&gt;
			&lt;li&gt;The above row is the victim ***&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The stacktrace of the operation causing the deadlock is &lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.Timeout.createException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.Timeout.buildException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.xact.RowLocking3.lockRecordForWrite(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source) &lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(Unknown Source) &lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(Unknown Source )&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.rePrepare(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeQuery(Unknown Source) &lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)&lt;/p&gt;

&lt;p&gt;I&apos;ve seen the deadlock occur during several get-metadata operations (getImportedKeys, ...), each time waiting on the SYSSTATEMENTS apparently because of internally constructed PreparedStatement. The lock eventually times out and the locked out operation completes without error.&lt;/p&gt;

&lt;p&gt;When the deadlock occurs, the &quot;real&quot; SQL into systables is being compiled (I traced this sql to be the value of &quot;getColumns&quot; key in org/apache/derby/impl/jdbc/metadata.properties file):&lt;br/&gt;
--------&lt;del&gt;%&amp;lt;&lt;/del&gt;---------------------&lt;del&gt;%&amp;lt;&lt;/del&gt;-------------&lt;br/&gt;
Begin compiling prepared statement: SELECT CAST (&apos;&apos; AS VARCHAR(128)) AS PKTABLE_CAT, S.SCHEMANAME AS PKTABLE_SCHEM, TABLENAME AS&lt;br/&gt;
PKTABLE_NAME, COLS.COLUMNNAME AS PKCOLUMN_NAME, CAST (&apos;&apos; AS VARCHAR(128)) AS FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FKCOLUMN_NAME, CAST ...&lt;br/&gt;
--------&lt;del&gt;%&amp;lt;&lt;/del&gt;---------------------&lt;del&gt;%&amp;lt;&lt;/del&gt;-------------&lt;/p&gt;</description>
                <environment>Linux amd64 or Windows 32bit</environment>
        <key id="12396923">DERBY-3693</key>
            <summary>Deadlocks accessing DB metadata</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="svatoun">Svata Dedic</reporter>
                        <labels>
                    </labels>
                <created>Tue, 27 May 2008 21:55:23 +0100</created>
                <updated>Fri, 21 Jan 2011 17:51:58 +0000</updated>
                            <resolved>Mon, 25 Aug 2008 17:09:02 +0100</resolved>
                                    <version>10.3.2.1</version>
                    <version>10.3.3.0</version>
                    <version>10.4.1.3</version>
                                    <fixVersion>10.4.2.0</fixVersion>
                    <fixVersion>10.5.1.1</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12600322" author="dagw" created="Wed, 28 May 2008 01:23:33 +0100"  >&lt;p&gt;Are are able to produce a repro program for this? I tried to make one based on your explanations, but no luck yet.&lt;br/&gt;
From what you say, the problem is intermittent, so presumably more than one connection makes the&lt;br/&gt;
metadata queries? What isolation level are you running with? (default is read committed).&lt;br/&gt;
Is there more information in derby.log? Did the deadlock dump only show the victim?&lt;/p&gt;</comment>
                            <comment id="12600755" author="knutanders" created="Thu, 29 May 2008 13:26:43 +0100"  >&lt;p&gt;It&apos;s just a guess, but perhaps the attached patch deadlock.diff solves the problem. Stored prepared statements (which are used for the meta-data queries) are compiled in a nested transaction so that locks on system tables can be released before the main transaction is completed. If the main transaction already has a lock on something the nested transaction also needs to lock, the nested transaction may get a lock timeout, in which case we retry the operation in the parent transaction. We don&apos;t retry if the nested transaction runs into a deadlock, which is what happens in Svata&apos;s case. I don&apos;t think it&apos;s possible that the nested transaction runs into a deadlock with the main transaction, since the main transaction isn&apos;t waiting for any locks while the nested transaction is executing, but it may perhaps happen if there are more threads involved?&lt;/p&gt;

&lt;p&gt;Anyway, I just wanted to throw out the idea. The patch has not been tested.&lt;/p&gt;</comment>
                            <comment id="12600757" author="knutanders" created="Thu, 29 May 2008 13:29:18 +0100"  >&lt;p&gt;I removed the &quot;Existing Application Impact&quot; flag since it refers to the impact of the fix, not the bug.&lt;/p&gt;</comment>
                            <comment id="12606060" author="belgarat" created="Wed, 18 Jun 2008 20:44:01 +0100"  >&lt;p&gt;Knut,&lt;/p&gt;

&lt;p&gt;I tried your patch - the conditional code activates (I put a println in there), but only after a considerable timeout elapses &amp;#8211; so it does not solve the issue.&lt;/p&gt;

&lt;p&gt;There are no other threads accessing the database at the time the deadlock occurs, the thread which waits (until timeout elapses and the lock is broken) is the only one working with Derby. The connection may handed to several threads in our app, but only one of them can get and use it at any given time.&lt;/p&gt;</comment>
                            <comment id="12606770" author="knutanders" created="Fri, 20 Jun 2008 15:13:15 +0100"  >&lt;p&gt;Attached is a small test case that reproduces the problem. It creates a deadlock between two transactions by first obtaining shared locks on the rows in SYSSTATEMENTS for getTables and getColumns in both transactions. Then one transaction tries to obtain an exclusive lock on the getTables row (because it needs to compile getTables), and the other transaction on getColumns. This results in the following error and stack trace:&lt;/p&gt;

&lt;p&gt;ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:&lt;br/&gt;
Lock : ROW, SYSSTATEMENTS, (15,7)&lt;br/&gt;
  Waiting XID : &lt;/p&gt;
{149, X}
&lt;p&gt; , APP, EXECUTE STATEMENT SYS.&quot;getTables&quot;&lt;br/&gt;
  Granted XID : &lt;/p&gt;
{149, S} , {148, S} &lt;br/&gt;
Lock : ROW, SYSSTATEMENTS, (19,6)&lt;br/&gt;
  Waiting XID : {148, X} , APP, EXECUTE STATEMENT SYS.&quot;getColumns&quot;&lt;br/&gt;
  Granted XID : {148, S} , {149, S}
&lt;p&gt; &lt;br/&gt;
. The selected victim is XID : 149.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:303)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.Deadlock.buildException(Deadlock.java:361)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(ConcurrentLockSet.java:613)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.AbstractPool.lockObject(AbstractPool.java:117)&lt;br/&gt;
        at org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(ConcurrentPool.java:28)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.xact.RowLocking3.lockRecordForWrite(RowLocking3.java:248)&lt;br/&gt;
        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(HeapController.java:504)&lt;br/&gt;
        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(HeapController.java:638)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(B2IRowLocking3.java:335)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(B2IRowLocking3.java:628)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(B2IRowLockingRR.java:112)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(BTreeForwardScan.java:304)&lt;br/&gt;
        at org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(BTreeScan.java:1809)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(TabInfoImpl.java:1085)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(TabInfoImpl.java:975)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(DataDictionaryImpl.java:4042)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(SPSDescriptor.java:1104)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:728)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:642)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(ExecSPSNode.java:177)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:447)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:794)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:128)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(EmbedPreparedStatement20.java:82)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(EmbedPreparedStatement30.java:63)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(EmbedPreparedStatement40.java:40)&lt;br/&gt;
        at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Driver40.java:105)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(EmbedConnection.java:2624)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(EmbedDatabaseMetaData.java:3657)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(EmbedDatabaseMetaData.java:3493)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(EmbedDatabaseMetaData.java:3542)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(EmbedDatabaseMetaData.java:3567)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getTables(EmbedDatabaseMetaData.java:1708)&lt;br/&gt;
        at d3693.T1(d3693.java:57)&lt;br/&gt;
        at d3693.main(d3693.java:32)&lt;/p&gt;


&lt;p&gt;I&apos;m not sure how this could happen in a normal application, though.&lt;/p&gt;</comment>
                            <comment id="12607359" author="knutanders" created="Mon, 23 Jun 2008 20:38:32 +0100"  >&lt;p&gt;Svata, if you can reproduce this problem reliably, it would be great if you could run with derby.language.logStatementText=true and derby.locks.deadlockTrace=true and post the full contents of derby.log. Then we might see which transaction is leaving a lock and causing the timeout.&lt;/p&gt;</comment>
                            <comment id="12614520" author="david.capelle" created="Thu, 17 Jul 2008 21:09:57 +0100"  >&lt;p&gt;Hi Knut, Svata,&lt;/p&gt;

&lt;p&gt;We have a similar problem with metadata.&lt;br/&gt;
Since we have added a new table in our schema, we always have a deadlock .&lt;br/&gt;
We have noticed that if we delete a table (regardless of wich table), than deadlock does&apos;t happend anymore.  &lt;br/&gt;
Our scenario:&lt;br/&gt;
1. Create all the tables (including index)&lt;br/&gt;
2. For each table, check if there are new ForeignKey to create&lt;br/&gt;
3. Create all new foreignKeys.&lt;br/&gt;
Dealock happens in the second step. Only one thread is connected to Derby (and so one connection).&lt;br/&gt;
I will send you our derby.log file.&lt;/p&gt;</comment>
                            <comment id="12614671" author="knutanders" created="Fri, 18 Jul 2008 10:02:18 +0100"  >&lt;p&gt;Thanks David, that was a very useful piece of information! I think I (almost) see what&apos;s happening in your case.&lt;/p&gt;

&lt;p&gt;Derby periodically checks whether a compiled plan should be recompiled (configurable with the derby.language.stalePlanCheckInterval property). When it detects that the size of SYS.SYSTABLES has changed considerably since getTables() was compiled the last time (because you have added more tables), it&apos;ll recompile the plan to see if it can create a plan that is more efficient.&lt;/p&gt;

&lt;p&gt;The recompilation happens in a nested transaction, which runs into a lock conflict with the parent transaction when it tries to store the compiled plan in SYS.SYSSTATEMENTS, and therefore it hangs for the duration specified by derby.locks.waitTimeout. This hang is &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-177&quot; title=&quot;Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-177&quot;&gt;&lt;del&gt;DERBY-177&lt;/del&gt;&lt;/a&gt;. This is the part I don&apos;t quite understand. The parent transaction shouldn&apos;t have any locks in this case, since it hasn&apos;t performed any operations before the call to getTables(). My guess is that it still holds some locks after querying the system tables to see if a recompilation is needed.&lt;/p&gt;

&lt;p&gt;Normally, after the nested transaction times out, the timeout exception is intercepted and the recompilation is retried in the parent transaction. However, because derby.locks.deadlockTrace is set, the timeout exception has a different SQLState than what the retry logic expects (40XL2 instead of 40XL1), and the exception is not intercepted.&lt;/p&gt;

&lt;p&gt;I have attached a java class (GetTables.java) that simulates your application. It has a loop which continuously executes CREATE TABLE and getTables(). If I run the class without derby.locks.deadlockTrace, I see a hang each time getTables() is recompiled. It continues with no error after the hang. If I run with derby.locks.deadlockTrace, it fails with a timeout exception the first time getTables() is recompiled.&lt;/p&gt;

&lt;p&gt;Now, I think the patch I attached earlier (deadlock.diff) will help so that the timeout exception isn&apos;t thrown, but as Svata noted, you&apos;ll still see the hang.&lt;/p&gt;

&lt;p&gt;I see the following possible workarounds:&lt;/p&gt;

&lt;p&gt;  1) Don&apos;t run with derby.locks.deadlockTrace. You&apos;ll still see the hangs, but it won&apos;t fail. You may also want to lower derby.locks.waitTimeout to reduce the problem with the hangs.&lt;/p&gt;

&lt;p&gt;  2) Increase the value of derby.language.stalePlanCheckInterval (default 100) so that you manage to create all your tables without recompiling getTables().&lt;/p&gt;

&lt;p&gt;To fix the issue permanently, we need to find out why the parent transaction holds locks in the system tables before it recompiles the getTables() query, and find out how we can ensure that these locks don&apos;t conflict with the nested transaction.&lt;/p&gt;</comment>
                            <comment id="12614889" author="knutanders" created="Fri, 18 Jul 2008 22:47:34 +0100"  >&lt;p&gt;It seems like the plan for the meta-data query is invalidated in the user transaction. When the plan is invalidated, SYS.SYSSTATEMENTS is updated to reflect that the plan is invalid, hence the user transaction has an exclusive lock on a row in SYS.SYSSTATEMENTS. However, the meta-data query is recompiled in a sub-transaction, and therefore it runs into a lock conflict with the user transaction. Perhaps we could get around this problem by also performing the invalidation in a sub-transaction so that the exclusive lock is released once the plan has been marked as invalid. Statements within triggers probably also suffer from the same problem.&lt;/p&gt;</comment>
                            <comment id="12615074" author="david.capelle" created="Sun, 20 Jul 2008 11:14:57 +0100"  >&lt;p&gt;Thanks a lot for your investigations, &lt;br/&gt;
After lower derby.locks.waitTimeout to16 sec and derby.locks.deadlockTimeout to 15,  we still have deadlock (in derby.log file) but we don&apos;t wait more than 15 seconds, so it&apos;s acceptable.&lt;br/&gt;
I also have tested the second workaround (derby.language.stalePlanCheckInterval). I have set it to 200. ThIs time, deadlock doesn&apos;t occur.&lt;br/&gt;
If I understand well, changing this last property only affect performance on metadata getTable method? &lt;/p&gt;

&lt;p&gt;BR&lt;/p&gt;</comment>
                            <comment id="12615201" author="knutanders" created="Mon, 21 Jul 2008 11:26:51 +0100"  >&lt;p&gt;Increasing derby.language.stalePlanCheckInterval could affect all statements, but I don&apos;t think it&apos;s likely that you&apos;ll notice any difference. What could be getting worse, is that it takes longer from the size of a table changes so that the chosen plan is not the most efficient one anymore, until Derby notices it and creates a new plan. On the other hand, increasing it could also improve the performance, since it&apos;ll lead to less checking of the plan at run time and less recompiling. I&apos;d guess that in most cases the recompiling won&apos;t actually choose another plan, so doing it less frequently shouldn&apos;t hurt.&lt;/p&gt;

&lt;p&gt;The timeout will only happen with meta-data queries and statements in triggers, though, since the execution plans for those queries are stored in the database. The execution plans for other SQL statements are stored in memory only, so there&apos;s no need to modify system tables when they are recompiled.&lt;/p&gt;</comment>
                            <comment id="12617033" author="knutanders" created="Fri, 25 Jul 2008 21:04:17 +0100"  >&lt;p&gt;Invalidating the meta-data queries in a nested transaction seems to fix the problem. The attached patch (nested_transaction.diff) shows this approach, and the timeout is not seen in the repro (GetTables.java) anymore. I haven&apos;t run the regression tests or added new regression tests for this problem yet, and will probably not have time to do it in a couple of weeks, but I&apos;m attaching the patch now for others to try and comment on.&lt;/p&gt;</comment>
                            <comment id="12623683" author="knutanders" created="Tue, 19 Aug 2008 15:20:00 +0100"  >&lt;p&gt;I ran suites.All and derbyall successfully with&lt;br/&gt;
nested_transaction.diff, but it took very long time for the tests to&lt;br/&gt;
complete. I think that the problem is that the patch attempts to&lt;br/&gt;
update SYSSTATEMENTS in a nested transaction every time an SPS is&lt;br/&gt;
invalidated, regardless of why the invalidation request was sent. In&lt;br/&gt;
some of those cases (like when makeInvalid() is called with action =&lt;br/&gt;
DependencyManager.CREATE_TRIGGER) the user transaction already holds&lt;br/&gt;
locks on rows in SYSSTATEMENTS and the nested transaction almost&lt;br/&gt;
definitely runs into a lock conflict with its parent.&lt;/p&gt;

&lt;p&gt;To fix the reported issue without introducing hangs in other cases, we&lt;br/&gt;
can probably limit the use of nested transactions to the case where&lt;br/&gt;
makeInvalid() is called for recompile requests&lt;br/&gt;
(INTERNAL_RECOMPILE_REQUEST and possibly USER_RECOMPILE_REQUEST)&lt;/p&gt;</comment>
                            <comment id="12624342" author="knutanders" created="Thu, 21 Aug 2008 12:48:54 +0100"  >&lt;p&gt;Here&apos;s a new version of the patch. Changes from the previous patch:&lt;/p&gt;

&lt;p&gt;  1) only invalidate in a nested transaction for INTERNAL_RECOMPILE_REQUEST&lt;/p&gt;

&lt;p&gt;  2) added regression test&lt;/p&gt;

&lt;p&gt;Although (1) fixed most of the internal timeouts that were seen with the previous patch, I still see one timeout in GrantRevokeDDLTest (no error, since the retry in the parent transaction succeeds), so I don&apos;t think the patch should be committed yet. The timeout apparently happens because GrantRevokeConstantAction invalidates statements with INTERNAL_RECOMPILE_REQUEST while it&apos;s probably holding a lock in SYSSTATEMENTS.&lt;/p&gt;

&lt;p&gt;The best way to fix this problem would be if we could make the logic to prevent waiting for locks in SPSDescriptor.updateSYSSTATEMENTS() work for row locks. Currently, it only prevents waiting for table locks. See also some discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-177&quot; title=&quot;Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-177&quot;&gt;&lt;del&gt;DERBY-177&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12624860" author="knutanders" created="Fri, 22 Aug 2008 15:56:47 +0100"  >&lt;p&gt;Here&apos;s a patch (dontWait.diff) which attacks the problem from a different angle. Instead of preventing the invalidation from obtaining a lock on the system tables in the user transaction, this patch makes the nested transaction used for recompiling the meta-data query fail immediately in case of a lock conflict. The original code also attempts this, but only for table-level locks. This patch makes all lock requests in the nested transaction time out immediately if there&apos;s a lock conflict, so that there&apos;s no hang before we retry in the user transaction.&lt;/p&gt;

&lt;p&gt;The approach taken is this:&lt;/p&gt;

&lt;p&gt;The CompatibilitySpace class used in the lock manager has an owner field, which normally is the transaction object. This field is however of type java.lang.Object and can theoretically be anything. In the patch, I changed this field to be of the type LockOwner, which is a new interface under iapi.services.locks. The interface has a method noWait() that returns a boolean value. The lock manager will check the return value of this method if lockObject() or zeroDurationlockObject() can&apos;t lock the object immediately, and if it is true, a timeout exception is thrown instead of waiting.&lt;/p&gt;

&lt;p&gt;In SPSDescriptor, I set a flag in the nested transaction so that it returns true from its noWait() method. This means we&apos;ll not see the lock conflicts between the nested transaction and its parent as hangs anymore.&lt;/p&gt;

&lt;p&gt;I have successfully run the repro, the regression test that was added to DatabaseMetaDataTest, and a set of tests that had problems with the previous patches. Didn&apos;t see any problems in those tests. Will start the full regression test suite and report back.&lt;/p&gt;</comment>
                            <comment id="12624864" author="knutanders" created="Fri, 22 Aug 2008 16:03:09 +0100"  >&lt;p&gt;With the latest patch, we can probably remove the lowering of the lock timeout in some of the regression tests marked with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-177&quot; title=&quot;Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-177&quot;&gt;&lt;del&gt;DERBY-177&lt;/del&gt;&lt;/a&gt;. The tests affected by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-177&quot; title=&quot;Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-177&quot;&gt;&lt;del&gt;DERBY-177&lt;/del&gt;&lt;/a&gt; can be found in DatabaseMetaDataTest and UpdatableResultSetTest.&lt;/p&gt;</comment>
                            <comment id="12624981" author="knutanders" created="Fri, 22 Aug 2008 22:16:24 +0100"  >&lt;p&gt;The regression tests passed on JDK 6. I&apos;ll start a test run on Java 1.4 as well, since a different code path is followed there.&lt;/p&gt;</comment>
                            <comment id="12625029" author="knutanders" created="Sat, 23 Aug 2008 08:44:10 +0100"  >&lt;p&gt;The regression tests passed on Java 1.4.2 as well, so I checked in the patch with revision 688274.&lt;/p&gt;

&lt;p&gt;I think this fix should be back-ported since the problem was reported against 10.3, and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-177&quot; title=&quot;Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-177&quot;&gt;&lt;del&gt;DERBY-177&lt;/del&gt;&lt;/a&gt;, which is probably the same issue, was reported against 10.0. Will do that in a couple of days if the nightly regression tests don&apos;t show any problems and no one objects to the patch.&lt;/p&gt;

&lt;p&gt;Some cleanups that should be performed before closing this issue:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;remove workaround for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-177&quot; title=&quot;Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-177&quot;&gt;&lt;del&gt;DERBY-177&lt;/del&gt;&lt;/a&gt; in tests&lt;/li&gt;
	&lt;li&gt;remove logic to prevent waiting for table locks in SPSDescriptor.updateSYSSTATEMENTS() since the new mechanism will prevent waiting for all types of locks&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12625185" author="bryanpendleton" created="Sun, 24 Aug 2008 17:47:13 +0100"  >&lt;p&gt;Hi Knut, thanks for working on this problem. I think your approach is excellent &amp;#8211; good catch&lt;br/&gt;
on figuring out that the previous implementation was only working for table-level locks.&lt;/p&gt;

&lt;p&gt;I read through dontWait.diff and it seems quite clear; the new LockOwner interface&lt;br/&gt;
seems like a straightforward way to increase the communication between the locking&lt;br/&gt;
services and the higher-level client code without introducing a lot of coupling, very nice.&lt;/p&gt;

&lt;p&gt;I did feel, however, that the patch could use significantly more comments. Looking just&lt;br/&gt;
at the patch, without referring to the detailed comments in this JIRA report, I found it&lt;br/&gt;
hard to see when it would be appropriate to call setNoLockWait(true).&lt;/p&gt;

&lt;p&gt;In other words, I think it would be nice if the patch could include sufficient comments&lt;br/&gt;
that future code which creates a nested transaction could determine when to use&lt;br/&gt;
this new API or not. Should &lt;b&gt;all&lt;/b&gt; nested transactions use no-wait locking? If not, which&lt;br/&gt;
ones should, and why? &lt;/p&gt;

&lt;p&gt;I think that the crucial bit of missing information involves the fact(s) that:&lt;br/&gt;
 a) the nested transaction might be blocking on locks held by the parent transaction&lt;br/&gt;
 b) some callers are smart enough to know that if a lock-related problem occurs with&lt;br/&gt;
     the nested transaction, they can re-try the work using the parent transaction&lt;/p&gt;

&lt;p&gt;If possible, I think that some useful places for such information would be:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LockOwner.noWait: more information about why a lock owner might return true from noWait&lt;br/&gt;
   (e.g., because its a nested transaction which might be blocking on its own parent)&lt;/li&gt;
	&lt;li&gt;Xact.setNoLockWait: more information about why a client might want to configure&lt;br/&gt;
   a transaction to use no-wait behavior, when that is appropriate, when it won&apos;t work,&lt;br/&gt;
   and what the caller should be prepared to do when the lock requests fail rather than waiting&lt;br/&gt;
  (e.g., catch the failure and retry the operation on the parent xact)&lt;/li&gt;
	&lt;li&gt;SPSDescriptor.java: more information about why nested transactions which access&lt;br/&gt;
   stored prepared statements are able to use lock-failure behavior (that is, because&lt;br/&gt;
   the code is smart enough to catch the failure in the nested transaction and retry&lt;br/&gt;
   the acces using the parent transaction)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Again, thanks &lt;b&gt;so&lt;/b&gt; much for this fix, I think this is a big improvement. &lt;/p&gt;
</comment>
                            <comment id="12625404" author="knutanders" created="Mon, 25 Aug 2008 16:50:23 +0100"  >&lt;p&gt;Thanks for looking at the patch, Bryan, and for providing constructive feedback, as always!&lt;/p&gt;

&lt;p&gt;I have tried to improve the comments (see the attached patch, committed with revision 688756) the following way:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LockOwner.noWait(): Give more details and an example of when to return true.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Transaction/TransactionController.setNoLockWait(): Added a (short) description of when/how to use it and linked it to LockOwner.noWait() with a @see javadoc tag.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Xact/RAMTransaction.setNoLockWait(): Expanded the comments and cross references by inheriting javadoc comments from the interfaces.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SPSDescription.getPreparedStatement(): Expanded comment right before the call to nestedTC.setNoLockWait(true). The method already has good comments from before the fix explaining the timeout/retry logic, so I tried to keep it short in order to avoid duplicating too much information.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12625410" author="knutanders" created="Mon, 25 Aug 2008 16:58:51 +0100"  >&lt;p&gt;I merged the fix to the 10.4 branch with revision 688766.&lt;/p&gt;

&lt;p&gt;I guess the issue must be marked as resolved in order to show up in the list of fixed issues in the 10.4.2 release notes, and the release candidate will be built very soon. There are still some clean-up tasks related to this issue, but since they are not needed for the fix, I think I&apos;ll resolve this issue and open a new issue for the clean-up tasks.&lt;/p&gt;</comment>
                            <comment id="12625415" author="knutanders" created="Mon, 25 Aug 2008 17:09:02 +0100"  >&lt;p&gt;Filed remaining tasks as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3850&quot; title=&quot;Remove unneeded workarounds for DERBY-177 and DERBY-3693&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3850&quot;&gt;&lt;del&gt;DERBY-3850&lt;/del&gt;&lt;/a&gt;. Marking this bug as resolved.&lt;/p&gt;</comment>
                            <comment id="12625416" author="bryanpendleton" created="Mon, 25 Aug 2008 17:11:36 +0100"  >&lt;p&gt;comments.diff looks excellent! Thanks for taking the time to clarify the doc. I can&apos;t think of anything else to add.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="31112">DERBY-177</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="31112">DERBY-177</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12402999">DERBY-3850</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12386375" name="GetTables.java" size="1443" author="knutanders" created="Fri, 18 Jul 2008 10:02:18 +0100"/>
                            <attachment id="12388853" name="comments.diff" size="7078" author="knutanders" created="Mon, 25 Aug 2008 16:50:23 +0100"/>
                            <attachment id="12384382" name="d3693.java" size="2767" author="knutanders" created="Fri, 20 Jun 2008 15:13:15 +0100"/>
                            <attachment id="12383010" name="deadlock.diff" size="1117" author="knutanders" created="Thu, 29 May 2008 13:26:43 +0100"/>
                            <attachment id="12386343" name="derby.log" size="1053627" author="david.capelle" created="Thu, 17 Jul 2008 21:12:55 +0100"/>
                            <attachment id="12388747" name="dontWait.diff" size="25501" author="knutanders" created="Fri, 22 Aug 2008 15:56:47 +0100"/>
                            <attachment id="12388748" name="dontWait.stat" size="1201" author="knutanders" created="Fri, 22 Aug 2008 15:56:47 +0100"/>
                            <attachment id="12386918" name="nested_transaction.diff" size="3129" author="knutanders" created="Fri, 25 Jul 2008 21:04:17 +0100"/>
                            <attachment id="12388667" name="nested_transaction_v2.diff" size="8898" author="knutanders" created="Thu, 21 Aug 2008 12:48:54 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 28 May 2008 00:23:33 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23792</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ldr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37282</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>