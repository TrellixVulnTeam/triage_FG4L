<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:55:16 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-479/DERBY-479.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-479] Passing the return of  a RETURN NULL ON NULL INPUT function to another function call throws linkage error.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-479</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Error in ij (RN_RADIANS is a function declared as returns null on null input)&lt;/p&gt;

&lt;p&gt;ij&amp;gt; VALUES CAST( CALL_COS(RN_RADIANS(90.0)) AS DECIMAL(3,2));&lt;br/&gt;
ERROR XBCM1: Java linkage error thrown during load of generated class org.apache.derby.exe.ace5214067x0105x5e41x7a46xffff855452e375.&lt;br/&gt;
ERROR XJ001: Java exception: &apos;(class: org/apache/derby/exe/ace5214067x0105x5e41x&lt;br/&gt;
7a46xffff855452e375, method: e0 signature: ()Ljava/lang/Object&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Expecting to find double on stack: java.lang.VerifyError&apos;.&lt;/p&gt;


&lt;p&gt;extract from derby.log&lt;/p&gt;

&lt;p&gt;2005-07-28 16:23:43.836 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; Wrote class org.apache.derby.exe&lt;br/&gt;
.ace5214067x0105x5e41x7a46xffff855452e375 to file C:&amp;#95;work\svn_pb\trunk\systest\&lt;br/&gt;
out\functions\ace5214067x0105x5e41x7a46xffff855452e375.class. Please provide sup&lt;br/&gt;
port with the file and the following exception information: java.lang.VerifyErro&lt;br/&gt;
r: (class: org/apache/derby/exe/ace5214067x0105x5e41x7a46xffff855452e375, method&lt;br/&gt;
: e0 signature: ()Ljava/lang/Object&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Expecting to find double on stack&lt;/p&gt;


&lt;p&gt;I will add a test case to lang/functions.sql commented with this bug number. Test cases&lt;br/&gt;
that fail will be commented out.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12312748">DERBY-479</key>
            <summary>Passing the return of  a RETURN NULL ON NULL INPUT function to another function call throws linkage error.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                    </labels>
                <created>Fri, 29 Jul 2005 02:35:12 +0100</created>
                <updated>Tue, 1 Dec 2009 18:10:45 +0000</updated>
                            <resolved>Tue, 7 Mar 2006 12:45:25 +0000</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12365538" author="mamtas" created="Wed, 8 Feb 2006 19:15:44 +0000"  >&lt;p&gt;I spent some time on this bug and was able to reproduce it without casting and multiple functions. The following simpler test case will run into similar linkage error as the one reported in the bug&lt;br/&gt;
CREATE FUNCTION RN_abs(A int) RETURNS int&lt;br/&gt;
EXTERNAL NAME &apos;java.lang.Math.abs(int)&apos;&lt;br/&gt;
RETURNS NULL ON NULL INPUT&lt;br/&gt;
LANGUAGE JAVA PARAMETER STYLE JAVA;&lt;br/&gt;
VALUES ( RN_abS(RN_abs(90)));&lt;/p&gt;

&lt;p&gt;The function is defined such that if the argument to it is null, it should simply return null w/o invoking the function. But, in order to return null, the function&apos;s return type can&apos;t be primitive (it is int in this example). To get around this, the generator generates the output of the RN_abs function as java.lang.Integer. But since in the given example, (RN_abs(90)) is input to another function which is expecting to get a primitive data type of int, and not java.lang.Integer, Derby raises an error for type mismatch because (RN_abs(90)) is going to return java.lang.Integer and not int. &lt;/p&gt;

&lt;p&gt;I will continue to look into this, but does this explanation trigger a thought process in anyone&apos;s mind? &lt;/p&gt;</comment>
                            <comment id="12365609" author="djd" created="Thu, 9 Feb 2006 03:25:25 +0000"  >&lt;p&gt;It helps in these situations to be clear about SQL function vs. Java method. For example the the first sentence in the last comment should be:&lt;/p&gt;

&lt;p&gt;&amp;gt; The function is defined such that if the argument to it is null, it should simply return null w/o invoking the method.&lt;/p&gt;

&lt;p&gt;Then this leads to the next sentence saying:&lt;/p&gt;

&lt;p&gt;&amp;gt; But, in order to return null, the method&apos;s return type can&apos;t be primitive&lt;/p&gt;

&lt;p&gt;This is wrong, if it relates to the first sentence, if the method is never being called when the input is SQL NULL, then it doesn&apos;t matter&lt;br/&gt;
what the return type of the method is (since the method is never called).  &lt;/p&gt;

&lt;p&gt;It is correct however if the method needs to return a NULL value when the input parameters are not NULL, or the SQL function&lt;br/&gt;
is declared as CALLED ON  NULL INPUT. then the Java method does need to have a return type of  java.lang.Integer.&lt;/p&gt;

&lt;p&gt;One thought is related to the handling of converting types between the SQL domain and the Java domain. The nodes pushed for such&lt;br/&gt;
an expression are something like:&lt;/p&gt;

&lt;p&gt; JavaToSQL( StaticMethodCall(  SQLtoJava ( JavaToSQL ( StaticMethodCall (constant 90) ) ) ) ) &lt;/p&gt;

&lt;p&gt;That is any compiled node that results in a Java value is automatically wrapped in a JavaToSQL node that  converts the value&lt;br/&gt;
from the Java space (a Java object ot primitive) to the SQL space (a DataValueDescriptor). The assumption is the Java value&lt;br/&gt;
is most likely returned to the SQL space. If a SQL value needs to be pushed into the Java space the converse node is used.&lt;/p&gt;

&lt;p&gt;When a SQLtoJava  wraps a JavaToSQL node   (or vice versa) the compiler (I think) will just remove these two nodes so that &lt;br/&gt;
there is no performance overhead due to the no-op conversion . I think the logic for this removal was not updated for the RETURNS&lt;br/&gt;
NULL ON NULL INPUT case, because this clause means the double conversion is not  no-op.&lt;/p&gt;</comment>
                            <comment id="12366243" author="mamtas" created="Tue, 14 Feb 2006 06:24:45 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I have a patch for this bug. The patch description in brief is as follows.&lt;/p&gt;

&lt;p&gt;I have taken an example to explain the patch. Consider following sql function.(Notice it is defined with RETURNS NULL ON NULL INPUT)&lt;/p&gt;

&lt;p&gt;CREATE FUNCTION RN_abs(A int) RETURNS int&lt;br/&gt;
EXTERNAL NAME &apos;java.lang.Math.abs(int)&apos;&lt;br/&gt;
RETURNS NULL ON NULL INPUT&lt;br/&gt;
LANGUAGE JAVA PARAMETER STYLE JAVA;&lt;br/&gt;
VALUES CAST( RN_abS(RN_abs(90)) AS INTEGER);&lt;/p&gt;

&lt;p&gt;First let&apos;s start out by a VALUES query that does work fine.&lt;br/&gt;
VALUES RN_abs(90)&lt;/p&gt;

&lt;p&gt;During the bind phase of VALUES RN_abs(90), following nodes are created&lt;br/&gt;
JavaToSQL ( StaticMethodCall (SQLToJava (NumericConstantNode for constant 90) ) )&lt;/p&gt;

&lt;p&gt;During code generation, StaticMethodCallNode, for each of the parameters, calls generateOneParameter. In this eg, there is only one parameter and the node for that parameter is SQLToJavaValueNode. This node first generates the SQL value by calling generate on NumericConstantNode. NumericConstantNode generates code to get NumberDataValue for constant 90. This is the right type for the SQL domain but since this needs to be passed into Java domain, we need to do some casting. The java domain value would be to get a primitive int from NumberDataValue. To achieve this, SQLToJavaValueNode in it&apos;s generateJavaValue generates the code to get primitive value from NumberDataValue. In this case, it will be generating code to call getInt() on NumberDataValue so that we have the correct type for the java domain.&lt;/p&gt;

&lt;p&gt;StaticMethodCallNode after generating each parameter checks if the argument type to SQL function is same&lt;br/&gt;
as the parameter type to the Java method. In this case, the SQL argument type is java.lang.Integer and Java method parameter type is int. Because of this, it casts the item on the top of the stack to Java method parameter type. &lt;/p&gt;

&lt;p&gt;After taking care of parameter code generation, StaticMethodCallNode checks if the sql function is defined to return null if any of its arguments are null. This is true for our specific sql function. To take care of this, StaticMethodNode needs to have a return type of Object rather than primitive int type. After generating code to call java.lang.Math.abs, it generates the code to return java.lang.Math.abs&apos;s return value as java.lang.Integer This is where VALUES ( RN_abS(RN_abs(90))) runs into problem. &lt;/p&gt;

&lt;p&gt;So, now let&apos;s look at the problem sql.&lt;br/&gt;
VALUES ( RN_abS(RN_abs(90)));&lt;/p&gt;

&lt;p&gt;In the bind phase, following nodes are created for VALUES ( RN_abS(RN_abs(90)))&lt;br/&gt;
JavaToSQL ( StaticMethodCall ( StaticMethodCall (SQLToJava (NumericConstantNode for constant 90) ) )  )&lt;/p&gt;

&lt;p&gt;In generate phase, SQLToJavaValueNode generates code for SQL domain NumberDataValue first. But since the value needs to be returned to Java domain, it generates code to call getInt on NumberDataValue to get int for the Java domain. The inside StaticMethodCallNode finds that SQL function argument type is not same as Java parameter type and hence it generates code to cast the stack value to Java method parameter type. StaticMethodNode then generates the code to call java.lang.Math.abs and it converts the int type of the Java method return value into java.lang.Integer because the sql function has been defined to return null on null input. In order to be able to return null, the return type can&apos;t be primitive, it has to be an Object which in this case is java.lang.Integer. So far the code generation is same as for simple VALUES RN_abs(90). The problem happens during code generation for outside StaticMethodCallNode. Outside StaticMethodCallNode is expecting an int type but inside StaticMethodNode returned java.lang.Integer to cover return null on null state definition of the sql function. This type mismatch is what causes the linkage exception. &lt;/p&gt;

&lt;p&gt;I have resolved this type mismatch for outside sql function call by retrieving int value from java.lang.Integer with the help of the DataValueFactory, as shown below (I have added the code for this in MethodCallNode.generateParameters. The new code has !!! in front of them in following code)&lt;br/&gt;
   if (!parameterType.equals(argumentType))&lt;br/&gt;
   {&lt;br/&gt;
    // since we reached here through method resolution&lt;br/&gt;
    // casts are only required for primitive types.&lt;br/&gt;
    // In any other case the expression type must be assignable&lt;br/&gt;
    // to the parameter type.&lt;br/&gt;
    if (classInspector.primitiveType(parameterType)) &lt;/p&gt;
{
!!!     //The type on the stack for this parameter will not be primitive if this parameter
!!!     //is a call to another sql function which is defined to return null on null input.
!!!     //To take care of such a case, first generate the code to extract primitive type
!!!     //from the value on the top of the stack. Derby479. eg 
!!!     //CREATE FUNCTION RN_abs(A int) RETURNS int
!!!     //EXTERNAL NAME &apos;java.lang.Math.abs(int)&apos;
!!!     //RETURNS NULL ON NULL INPUT
!!!     //LANGUAGE JAVA PARAMETER STYLE JAVA;
!!!     //VALUES ( RN_abS(RN_abs(90)));
!!!     //Inside RN_abs is returning a java.lang.Math so that it can return null if the argument
!!!     //to it is null. But inside RN_abS is expecting primitive type int as input argument.
!!!     //Following piece of code extract primitive value from the Object value.
!!!     TypeId temp = methodParms[param].getJSQLType().getSQLType().getTypeId();
!!!     acb.generateDataValue(mb, getTypeCompiler(temp), (LocalField) null);
!!!     mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
!!!       getTypeCompiler(temp).getPrimitiveMethodName(), 
!!!       getTypeCompiler(temp).getCorrespondingPrimitiveTypeName(), 0);
     mb.cast(parameterType);
    }
&lt;p&gt; else {&lt;br/&gt;
Because of these changes to MethodCallNode, mb.cast doesn&apos;t run into casting exception anymore. I have attached the code changes to the JIRA entry.&lt;/p&gt;

&lt;p&gt;svn stat&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\ActivationClassBuilder.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\MethodCallNode.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\CursorNode.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\SQLToJavaValueNode.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\lang\functions.sql&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\functions.out&lt;/p&gt;

&lt;p&gt;I ran derbyall on my Windows XP with Sun&apos;s jdk14 and everything ran fine.&lt;/p&gt;

&lt;p&gt;Please send any feedback you might have.&lt;/p&gt;</comment>
                            <comment id="12366445" author="mamtas" created="Wed, 15 Feb 2006 15:23:45 +0000"  >&lt;p&gt;The reason for this exception lies in the parsing phase where MethodCallNode.addParams(Vector) tries to do some optimization. Rather than putting SQLToJavaValueNode on top of JavaToSQLValueNode, it directly gets the JavaValueNode. The comment for this shortcircuit in MethodCallNode.addParams(Vector) says &quot;In general, we want to avoid converting the same value back and forth between the SQL and Java domains,&quot; But going directly to java domain value causes type mismatch for a SQL function defined with return null on null input and when that SQL function is used as an argument to another SQL function. In order to generate the correct code for such a SQL function, we need access to both SQL domain value and Java domain value. In my patch, I have removed the optimization code from MethodCallNode.addParams(Vector) so that now, we do create a SQLToJavaValueNode on top of JavaToSQLValueNode. This change fixes the problem. I have attached the patch for it to JIRA. Please send any comments you might have after the review.&lt;/p&gt;

&lt;p&gt;I have run derbyall suite on Windows XP with Sun jdk14 and there were no problems. &lt;/p&gt;

&lt;p&gt;svn stat&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\ActivationClassBuilder.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\MethodCallNode.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\CursorNode.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\lang\functions.sql&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\functions.out&lt;/p&gt;</comment>
                            <comment id="12366484" author="djd" created="Wed, 15 Feb 2006 23:16:13 +0000"  >&lt;p&gt;The patch seems to always remove the optimization, isn&apos;t the optimization still useful for functions that are CALLED ON NULL INPUT?&lt;/p&gt;</comment>
                            <comment id="12366523" author="mamtas" created="Thu, 16 Feb 2006 04:06:16 +0000"  >&lt;p&gt;In the parsing phase, we do not yet know whether the sql function is defined as RETURN NULL ON NULL INPUT or as CALLED ON NULL INPUT and hence the optimization for CALLED ON NULL INPUT can&apos;t done in MethodCallNode.addParams(Vector). But during the bind phase, after all the parameters are bound (StaticMethodCallNode.bindExpression line number 170), we get information about the  underlying sql function from the system tables. At this point (StaticMethodCallNode.bindExpression line number 241), we can find out whether the function is defined as CALLED ON NULL INPUT and possibly can optimize the parameter code for CALLED ON NULL INPUT by going directly to java value rather than going JavaToSQLValueNode and then SLQToJavaValueNode on top of it. Let me know if anyone has any comments on this approach. If not, I will investigate in putting the shortcut code in for CALLED ON NULL INPUT.&lt;/p&gt;</comment>
                            <comment id="12366661" author="mamtas" created="Fri, 17 Feb 2006 03:58:28 +0000"  >&lt;p&gt;I have attached a patch (Derby479LinkageErrorReturnNullIfNulldiff021606.txt) which solves the problem by leaving SQLToJavaValueNode wrapper on top of JavaToSQLValueNode in case of a SQL function defined as RETURN NULL ON NULL INPUT. This is because, such a function requires access to both SQL domain value and Java domain value. This is not required for SQL function defined as CALLED ON NULL INPUT and hence we will continue to do the optimization for such functions by removing the wrapper classes SQLToJavaValueNode&lt;br/&gt;
and JavaToSQLValueNode and going directly to java domain value. This happens in StaticMethodCallNode.bindExpression()&lt;/p&gt;

&lt;p&gt;svn stat&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\ActivationClassBuilder.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\MethodCallNode.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\CursorNode.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\StaticMethodCallNode.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\lang\functions.sql&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\functions.out&lt;/p&gt;</comment>
                            <comment id="12366726" author="djd" created="Fri, 17 Feb 2006 09:35:24 +0000"  >&lt;p&gt;Thanks for the updated patch:&lt;br/&gt;
Minor comments now:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;You removed all the comment in MethodCallNode, but it seems half of that comment was still applicable.&lt;br/&gt;
    At least the code&apos;s that left needs some comments.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I like the separate optimizeDomainValueConversion method&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;optimizeDomainValueConversion, can you make the comments to this method javadoc comments.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  /**&lt;br/&gt;
  */&lt;br/&gt;
 before the method defintiion. This means they will appear in the javadoc and in eclipse when the cursor is hovering&lt;br/&gt;
over a call to this method. In general always use /** */ javadoc comments for classes, methods and fields.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In optimizeDomainValueConversion when can methodParms&lt;span class=&quot;error&quot;&gt;&amp;#91;parm&amp;#93;&lt;/span&gt; be null?&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12366820" author="mamtas" created="Sat, 18 Feb 2006 02:35:06 +0000"  >&lt;p&gt;Thanks for reviewing the patch. As for the last comment about methodParms&lt;span class=&quot;error&quot;&gt;&amp;#91;parm&amp;#93;&lt;/span&gt; null check, I did it because there are several such checks in MethodCallNode. Based on that, I assumed that it is required for some edge case. (I have to admit that I did wonder why there was such a check and probably should have asked the list). I have taken that null check out and rerunning the tests right now to make sure nothing breaks. Will post a new patch once the tests have completed successfully.&lt;/p&gt;</comment>
                            <comment id="12367052" author="mamtas" created="Tue, 21 Feb 2006 01:54:46 +0000"  >&lt;p&gt;I reran the tests after removing the &quot;if (methodParms&lt;span class=&quot;error&quot;&gt;&amp;#91;parm&amp;#93;&lt;/span&gt; != null)&quot; from StaticMethodCallNBode.optimizeDomainValueConversion and this caused lang/wisconsin.java test to fail. I am not sure exactly why, but if I put the null check back, the wisconsin test doesnot fail. I have attached the original master as wisconsin.out and the failed wisconsin results as wisconsinAfterRemovingNullChk.out to this JIRA entry to shows what the diffs are. Does this ring a bell to anyone? &lt;/p&gt;</comment>
                            <comment id="12367149" author="mamtas" created="Tue, 21 Feb 2006 15:12:36 +0000"  >&lt;p&gt;Dan, I have addressed all your comments in this (Derby479Version4LinkageErrorReturnNullIfNull022006.txt) patch. Also, as Myrna mentioned on the derby list, I indeed was running into intermittent failures of wisconsin.java test. Thanks, Myrna. I ran the test many times, with and without the parameter null check, and the test passed majority of the times. It intermittently failed for both with and without the parameter null check. Based on this, I have removed the parameter null check from StaticMethodCallNode.optimizeDomainValueConversion(). If anyone has any comments, please let me know. Otherwise, can a committer please commit this patch?&lt;/p&gt;</comment>
                            <comment id="12367150" author="mamtas" created="Tue, 21 Feb 2006 15:18:08 +0000"  >&lt;p&gt;The svn stat for Derby479Version4LinkageErrorReturnNullIfNull022006.txt is as follows&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\ActivationClassBuilder.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\MethodCallNode.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\CursorNode.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\StaticMethodCallNode.java&lt;br/&gt;
M java\testing\org\apache\derbyTesting\functionTests\tests\lang\functions.sql&lt;br/&gt;
M java\testing\org\apache\derbyTesting\functionTests\master\functions.out&lt;/p&gt;</comment>
                            <comment id="12367261" author="djd" created="Wed, 22 Feb 2006 06:12:40 +0000"  >&lt;p&gt;The comment you added/modified in MethodCallNode is:&lt;/p&gt;

&lt;p&gt;+			** If the parameter is a SQL ValueNode, then put a&lt;br/&gt;
+			** SQLToJavaValueNode on top of it.&lt;/p&gt;

&lt;p&gt;I see that as a comment that doesn&apos;t add any value, from the code I can see that is being done, the real value in a comment is explaining &lt;b&gt;why&lt;/b&gt; something is done.&lt;/p&gt;

&lt;p&gt;Looking more at StaticMethodCallNode.optimizeDomainValueConversion() I&apos;m not convinced it is correct.&lt;br/&gt;
The comments and code seem to say if I have&lt;/p&gt;

&lt;p&gt; f1(f2())&lt;/p&gt;

&lt;p&gt;then if f2() is CALLED ON NULL INPUT then I can take the java value directly from f2() and pass it to f1().&lt;/p&gt;

&lt;p&gt;But, what if f1() is RETURNS NULL ON NULL INPUT, don&apos;t I need the SQL nodes to perform the NULL check?&lt;br/&gt;
Thus don&apos;t both methods, the one being called and the one providing the parameter have to be CALLED ON NULL INPUT to take allow the conversion nodes to be dropped?&lt;/p&gt;

&lt;p&gt;In the optimizeDomainValueConversion I think you need to check for the node being an instance of StaticMethodCallNode and not MethodCallNode, and I think for routine being null. StaticMethodCallNode and MethodCallNode are stil used for internal SQL that uses Java expressions directly and are not defined SQL routines.&lt;/p&gt;

&lt;p&gt;Another aspect that may not be important, but before this change the conversion nodes are always dropped if they are between Java expressions, and that was incorrect in one situation, functions with RETURNS NULL ON NULL INPUT. Now you have changed it so they are only dropped in one situation, both methods being CALLED ON NULL INPUT (assuming a modified patch). Thus the optimization is being lost in situations where it is useful. Maybe this is not an issue because those siutations typically don&apos;t arise any more, but some internal statements that use Java expressions may be losing this optimization.&lt;/p&gt;



</comment>
                            <comment id="12367315" author="mamtas" created="Wed, 22 Feb 2006 16:55:21 +0000"  >&lt;p&gt;Dan, you are probably right about following &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Dan&apos;s review comments start&lt;br/&gt;
&quot;Looking more at StaticMethodCallNode.optimizeDomainValueConversion() I&apos;m not convinced it is correct. &lt;br/&gt;
The comments and code seem to say if I have &lt;/p&gt;

&lt;p&gt; f1(f2()) &lt;/p&gt;

&lt;p&gt;then if f2() is CALLED ON NULL INPUT then I can take the java value directly from f2() and pass it to f1(). &lt;/p&gt;

&lt;p&gt;But, what if f1() is RETURNS NULL ON NULL INPUT, don&apos;t I need the SQL nodes to perform the NULL check? &lt;br/&gt;
Thus don&apos;t both methods, the one being called and the one providing the parameter have to be CALLED ON NULL INPUT to take allow the conversion nodes to be dropped? &quot;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Dan&apos;s review comments end&lt;/p&gt;

&lt;p&gt;But I wanted to write an example for what you have described above to test what exactly happens with my changes.&lt;/p&gt;

&lt;p&gt;Following is the example I came up with and it worked fine with my changes&lt;/p&gt;

&lt;p&gt;CREATE FUNCTION f2(A varchar(128)) RETURNS varchar(128)&lt;br/&gt;
EXTERNAL NAME &apos;org.apache.derbyTesting.functionTests.util.ProcedureTest.function2AlwaysReturnsNull&apos;&lt;br/&gt;
CALLED ON NULL INPUT&lt;br/&gt;
LANGUAGE JAVA PARAMETER STYLE JAVA;&lt;/p&gt;

&lt;p&gt;CREATE FUNCTION f1(A varchar(128)) RETURNS varchar(128)&lt;br/&gt;
EXTERNAL NAME &apos;org.apache.derbyTesting.functionTests.util.ProcedureTest.function1AlwaysReturnsAAA&apos;&lt;br/&gt;
RETURNs NULL ON NULL INPUT&lt;br/&gt;
LANGUAGE JAVA PARAMETER STYLE JAVA;&lt;/p&gt;

&lt;p&gt;The java methods invoked by the 2 sql functions are as follows&lt;br/&gt;
	public static String function1AlwaysReturnsAAA(String a) throws SQLException&lt;/p&gt;
	{
		return &quot;AAA&quot;;
	}

&lt;p&gt;	public static String function2AlwaysReturnsNull(String a) throws SQLException&lt;/p&gt;
	{
		return (String)null;
	}

&lt;p&gt;Then I tried following in ij and both of them returned null which is the correct value&lt;br/&gt;
values f1(f2(&apos;sss&apos;));&lt;br/&gt;
1&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
NULL&lt;/p&gt;

&lt;p&gt;values f1(f2(null));&lt;br/&gt;
1&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
NULL&lt;/p&gt;

&lt;p&gt;I have spent couple of hours on trying to come up with another example where I can see that my changes won&apos;t work but I haven&apos;t succedded. Do you have an example in mind which I can try? Thanks&lt;/p&gt;</comment>
                            <comment id="12367394" author="djd" created="Thu, 23 Feb 2006 05:02:10 +0000"  >&lt;p&gt;Single patch could fix &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-479&quot; title=&quot;Passing the return of  a RETURN NULL ON NULL INPUT function to another function call throws linkage error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-479&quot;&gt;&lt;del&gt;DERBY-479&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1030&quot; title=&quot;In some situations a RETURNS NULL ON NULL function is called when one ot its parameters is NULL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1030&quot;&gt;&lt;del&gt;DERBY-1030&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12367396" author="djd" created="Thu, 23 Feb 2006 05:03:19 +0000"  >&lt;p&gt;Single patch could fix &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-479&quot; title=&quot;Passing the return of  a RETURN NULL ON NULL INPUT function to another function call throws linkage error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-479&quot;&gt;&lt;del&gt;DERBY-479&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1030&quot; title=&quot;In some situations a RETURNS NULL ON NULL function is called when one ot its parameters is NULL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1030&quot;&gt;&lt;del&gt;DERBY-1030&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12367473" author="mamtas" created="Thu, 23 Feb 2006 14:50:59 +0000"  >&lt;p&gt;Based on today&apos;s mail sent by Dan where he identified another issue with functions (Derby-1030), I am submitting a patch(Derby479Version5LinkageErrorReturnNullIfNull022206.txt) that just addresses Derby-479. I will work on Derby-1030 after finishing up feature development work for 10.2 &lt;br/&gt;
(Dan&apos;s mail is titled Re: &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; Commented: (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-479&quot; title=&quot;Passing the return of  a RETURN NULL ON NULL INPUT function to another function call throws linkage error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-479&quot;&gt;&lt;del&gt;DERBY-479&lt;/del&gt;&lt;/a&gt;) Passing the return of a RETURN NULL ON NULL INPUT function to another function call throws linkage error) (For some reason, that mail from Dan is not showing up in derby dev archives and hence I don&apos;t have a direct html link to post here), &lt;/p&gt;</comment>
                            <comment id="12368068" author="djd" created="Tue, 28 Feb 2006 12:56:40 +0000"  >&lt;p&gt;Patch submitted  - minus changes that were not related to this issue.&lt;/p&gt;

&lt;p&gt;Sending        java\engine\org\apache\derby\impl\sql\compile\MethodCallNode.java&lt;br/&gt;
Sending        java\engine\org\apache\derby\impl\sql\compile\StaticMethodCallNode.java&lt;br/&gt;
Sending        java\testing\org\apache\derbyTesting\functionTests\master\functions.out&lt;br/&gt;
Sending        java\testing\org\apache\derbyTesting\functionTests\tests\lang\functions.sql&lt;br/&gt;
Transmitting file data ....&lt;br/&gt;
Committed revision 381553&lt;/p&gt;</comment>
                            <comment id="12369157" author="mamtas" created="Tue, 7 Mar 2006 12:45:25 +0000"  >&lt;p&gt;The patch fixes the problem test case in functions.sql. Dan, if you have no further comments on this particular issue, I will close it on Wednesday.&lt;/p&gt;</comment>
                            <comment id="12413279" author="djd" created="Fri, 26 May 2006 01:12:37 +0100"  >&lt;p&gt;Back in an earlier comment I said:&lt;/p&gt;

&lt;p&gt;Another aspect that may not be important, but before this change the conversion nodes are always dropped if they are between Java expressions, and that was incorrect in one situation, functions with RETURNS NULL ON NULL INPUT. Now you have changed it so they are only dropped in one situation, both methods being CALLED ON NULL INPUT (assuming a modified patch). Thus the optimization is being lost in situations where it is useful. Maybe this is not an issue because those siutations typically don&apos;t arise any more, but some internal statements that use Java expressions may be losing this optimization.&lt;/p&gt;

&lt;p&gt;Having worked on triggers recently for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt; I see that Java expressions are heavily used in accessing data with a trigger&apos;s action statement. Thus it would be best to reinstate the optimization of dropping conversion nodes for pure java expressions to avoid performance degradation in 10.2&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12442110">DERBY-4459</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12329346">DERBY-1030</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12322935" name="Derby479LinkageErrorReturnNullIfNulldiff021306.txt" size="6720" author="mamtas" created="Tue, 14 Feb 2006 06:24:45 +0000"/>
                            <attachment id="12322985" name="Derby479LinkageErrorReturnNullIfNulldiff021406.txt" size="6399" author="mamtas" created="Wed, 15 Feb 2006 15:23:45 +0000"/>
                            <attachment id="12323066" name="Derby479LinkageErrorReturnNullIfNulldiff021606.txt" size="9135" author="mamtas" created="Fri, 17 Feb 2006 03:58:28 +0000"/>
                            <attachment id="12323227" name="Derby479Version4LinkageErrorReturnNullIfNull022006.txt" size="9232" author="mamtas" created="Tue, 21 Feb 2006 15:12:36 +0000"/>
                            <attachment id="12323307" name="Derby479Version5LinkageErrorReturnNullIfNull022206.txt" size="9464" author="mamtas" created="Thu, 23 Feb 2006 14:50:59 +0000"/>
                            <attachment id="12323196" name="wisconsin.out" size="1543534" author="mamtas" created="Tue, 21 Feb 2006 01:54:46 +0000"/>
                            <attachment id="12323197" name="wisconsinAfterRemovingNullChk.out" size="1543204" author="mamtas" created="Tue, 21 Feb 2006 01:54:46 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 8 Feb 2006 19:15:44 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21974</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0rif:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38275</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>