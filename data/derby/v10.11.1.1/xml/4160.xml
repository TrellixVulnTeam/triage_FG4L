<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:23:09 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4160/DERBY-4160.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4160] getMetaData().getIndexInfo crashes with &quot;ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&quot;</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4160</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The following code in DataNucleus:&lt;br/&gt;
rs = conn.getMetaData().getIndexInfo(catalogName, schemaName, tableName, false,&lt;br/&gt;
true);&lt;br/&gt;
triggers an Exception (&lt;a href=&quot;http://gist.github.com/95679):&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://gist.github.com/95679):&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Caused by: java.sql.SQLException: Column &apos;PARAM1&apos; already exists.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
        ... 105 more&lt;br/&gt;
Caused by: ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:303)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.duplicateDescriptorException(DataDictionaryImpl.java:1678)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addDescriptor(DataDictionaryImpl.java:1662)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addSPSParams(DataDictionaryImpl.java:3682)&lt;br/&gt;
        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(DataDictionaryImpl.java:3830)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(SPSDescriptor.java:1112)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:736)&lt;br/&gt;
        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:642)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(ExecSPSNode.java:177)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:447)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:794)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:128)&lt;br/&gt;
        ... 99 more&lt;/p&gt;</description>
                <environment>FreeBSD java 1.6.0, 64-Bit Server VM; DataNucleus JDO</environment>
        <key id="12422868">DERBY-4160</key>
            <summary>getMetaData().getIndexInfo crashes with &quot;ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&quot;</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="artem@bizlink.ru">ArtemGr</reporter>
                        <labels>
                            <label>derby_triage10_5_2</label>
                    </labels>
                <created>Wed, 15 Apr 2009 12:37:26 +0100</created>
                <updated>Wed, 21 Jan 2015 00:23:37 +0000</updated>
                            <resolved>Wed, 5 Mar 2014 07:57:47 +0000</resolved>
                                    <version>10.4.2.0</version>
                                    <fixVersion>10.10.2.0</fixVersion>
                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="12699162" author="knutanders" created="Wed, 15 Apr 2009 13:02:52 +0100"  >&lt;p&gt;It is triggered when we try to add rows to SYS.SYSCOLUMNS in DataDictionaryImpl.updateSPS():&lt;/p&gt;

&lt;p&gt;		if(firstCompilation)&lt;/p&gt;
		{
			/*beetle:5119, reason for doing add here instead of update
			 *is with NOCOMPILE option of create statement/boot time SPS,
			 *SPS statement is not compiled to find out the parameter info.
			 *Because of the parameter info was not inserted at SPSDescriptor 
			 *creation time. As this is the first time we are compiling paramter
			 *infor should be inserted instead of the update.
			 */
			addSPSParams(spsd, tc);
		}

&lt;p&gt;For some reason the rows already exist, even though the meta-data statement has not been compiled before.&lt;/p&gt;

&lt;p&gt;I&apos;m wondering if this is related to the retry logic in SPSDescriptor.getPreparedStatement(boolean):&lt;/p&gt;

&lt;p&gt;				// &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt;: If the first attempt to compile the query fails,&lt;br/&gt;
				// we need to reset initiallyCompilable to make sure the&lt;br/&gt;
				// prepared plan is fully stored to disk. Save the initial&lt;br/&gt;
				// value here.&lt;br/&gt;
				final boolean compilable = initiallyCompilable;&lt;/p&gt;

&lt;p&gt;				try&lt;/p&gt;
				{
					prepareAndRelease(lcc, null, nestedTC);
					updateSYSSTATEMENTS(lcc, RECOMPILE, nestedTC);
				}
&lt;p&gt;				catch (StandardException se)&lt;br/&gt;
				{&lt;br/&gt;
					if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))&lt;br/&gt;
					{&lt;br/&gt;
						if (nestedTC != null)&lt;/p&gt;
						{
						nestedTC.commit();
						nestedTC.destroy();
						nestedTC = null;
						}
&lt;p&gt;						// if we couldn&apos;t do this with a nested xaction, retry with&lt;br/&gt;
						// parent-- we need to wait this time!&lt;br/&gt;
						initiallyCompilable = compilable;&lt;br/&gt;
						prepareAndRelease(lcc, null, null);&lt;br/&gt;
						updateSYSSTATEMENTS(lcc, RECOMPILE, null);&lt;br/&gt;
					}&lt;br/&gt;
					else throw se;&lt;br/&gt;
				}&lt;/p&gt;

&lt;p&gt;If the lock timeout in the nested transaction happens after addSPSParams() has been called, the rows will be there when we retry the operation in the user transaction since we commit the nested transaction instead of aborting it. I think we can&apos;t abort the nested transaction because it will also abort the parent transaction, but perhaps it is possible to use savepoints to make sure that all the changes made by the nested transaction are rolled back before we retry.&lt;/p&gt;</comment>
                            <comment id="12699165" author="knutanders" created="Wed, 15 Apr 2009 13:13:33 +0100"  >&lt;p&gt;If this is easily reproducible for you, could you try to run with -Dderby.locks.deadlockTrace=true and see if you get a lock timeout?&lt;/p&gt;</comment>
                            <comment id="12699208" author="artem@bizlink.ru" created="Wed, 15 Apr 2009 15:11:30 +0100"  >&lt;p&gt;I did run with&lt;br/&gt;
    System.setProperty (&quot;derby.locks.deadlockTrace&quot;, &quot;true&quot;)&lt;/p&gt;

&lt;p&gt;what should I look for?&lt;/p&gt;

&lt;p&gt;Here is my log (widh deadlockTrace enabled):&lt;br/&gt;
&lt;a href=&quot;http://chicago045.server4you.de/derby.log&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://chicago045.server4you.de/derby.log&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12699230" author="knutanders" created="Wed, 15 Apr 2009 16:01:24 +0100"  >&lt;p&gt;I was suspecting that we&apos;d see a lock timeout, but I didn&apos;t find any in the log. Did you run with a fresh database or with one where you&apos;d seen the error before? Did you set the property before the Derby driver was loaded?&lt;/p&gt;

&lt;p&gt;This last log shows that the error happened in getImportedKeys() so the problem does not seem to be limited to getIndexInfo().&lt;/p&gt;</comment>
                            <comment id="12699236" author="artem@bizlink.ru" created="Wed, 15 Apr 2009 16:22:32 +0100"  >&lt;p&gt;&amp;gt; Did you run with a fresh database or with one where you&apos;d seen the error before?&lt;br/&gt;
Fresh one.&lt;br/&gt;
On the first run with a fresh database DataNucleus creates the schemas. On the second run it checks them and runs into this error.&lt;br/&gt;
&amp;gt; Did you set the property before the Derby driver was loaded?&lt;br/&gt;
Yes.&lt;/p&gt;</comment>
                            <comment id="12726595" author="rhillegas" created="Thu, 2 Jul 2009 19:11:39 +0100"  >&lt;p&gt;Triaged July 2, 2009: This does not seem to satify our definition of a crash. I don&apos;t see why a release note is needed.&lt;/p&gt;</comment>
                            <comment id="13291648" author="jodeleit" created="Fri, 8 Jun 2012 10:27:41 +0100"  >&lt;p&gt;Got the same issue when changing the transaction isolation from READ_COMMITED to SERIALIZABLE.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;EDIT&amp;#93;&lt;/span&gt;&lt;br/&gt;
The issue does not show up all the time (twice of three runs of our integration test suite). Seems to be a timing issue because of incorrect synchronization.&lt;/p&gt;</comment>
                            <comment id="13291881" author="dagw" created="Fri, 8 Jun 2012 18:53:36 +0100"  >&lt;p&gt;Hi Peter, thanks for the update report. you wouldn&apos;t by any change have a repro you could post or let of of the devs use? It would increase your chances for getting this fixed.&lt;/p&gt;</comment>
                            <comment id="13292727" author="jodeleit" created="Mon, 11 Jun 2012 11:12:37 +0100"  >&lt;p&gt;Hi Dag,&lt;br/&gt;
there seems to be a relation to bug &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt;. I checked the log files of the weekend and the exception reported there seems similar &lt;span class=&quot;error&quot;&gt;&amp;#91;trace below&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;I could give you an outline of our integration test. It should be easy to extract a dedicated test from this, but i didn&apos;t tried yet (and i don&apos;t think i&apos;ll find time for this in the near future).&lt;br/&gt;
What we do is:&lt;br/&gt;
1) create a databases&lt;br/&gt;
2) query the database meta data&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;3) create some table 4) perform some CRUD operations&amp;#93;&lt;/span&gt;&lt;br/&gt;
5) Loop to step 1 for a few times&lt;/p&gt;

&lt;p&gt;As in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt; if transaction isolation is READ_COMMITTED everything works as expected (bug did not show up for about 3 months with 10.8.2.2. or with 10.5.3.0 for more than two years, both with alomst daily execution of the test suite).&lt;/p&gt;

&lt;p&gt;This is the trace I got last friday:&lt;br/&gt;
ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.duplicateDescriptorException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addDescriptor(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addSPSParams(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericTableSynchronizer.getColumns(GenericTableSynchronizer.java:306)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericTableSynchronizer.updateDB(GenericTableSynchronizer.java:120)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericSchemaSynchronizer.updateDB(GenericSchemaSynchronizer.java:145)&lt;br/&gt;
	at de.espirit.or.impl.schema.SchemaImpl.updateDBTables(SchemaImpl.java:409)&lt;br/&gt;
	at de.espirit.or.impl.AbstractSessionHandler.syncSchemaWithDB(AbstractSessionHandler.java:934)&lt;br/&gt;
	at de.espirit.or.impl.AbstractSessionHandler.syncSchemaWithDB(AbstractSessionHandler.java:77)&lt;br/&gt;
	at de.espirit.firstspirit.content.ContentManagerImpl$TemporalSessionHandler.syncSchemaWithDB(ContentManagerImpl.java:1310)&lt;/p&gt;

&lt;p&gt;This is the trace I got this weekend. As you can see, the call to &quot;DatabaseMetaData.getColumns(..)&quot; was successfull in this run. The only code change was an additional call to &quot;DatabaseMetaData.getDatabaseProductName()&quot; for logging.&lt;br/&gt;
java.sql.SQLException: Java exception: &apos;1: java.lang.ArrayIndexOutOfBoundsException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericTableSynchronizer.getColumns(GenericTableSynchronizer.java:313)&lt;br/&gt;
	... 27 more&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;1: java.lang.ArrayIndexOutOfBoundsException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)&lt;br/&gt;
	... 47 more&lt;br/&gt;
Caused by: java.lang.ArrayIndexOutOfBoundsException: 1&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericParameterValueSet.initialize(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BaseActivation.setupActivation(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.getActivation(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericTableSynchronizer.getColumns(GenericTableSynchronizer.java:313)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericTableSynchronizer.updateDB(GenericTableSynchronizer.java:121)&lt;br/&gt;
	at de.espirit.or.impl.generic.GenericSchemaSynchronizer.updateDB(GenericSchemaSynchronizer.java:145)&lt;br/&gt;
	at de.espirit.or.impl.schema.SchemaImpl.updateDBTables(SchemaImpl.java:409)&lt;br/&gt;
	at de.espirit.or.impl.AbstractSessionHandler.syncSchemaWithDB(AbstractSessionHandler.java:934)&lt;br/&gt;
	at de.espirit.or.impl.AbstractSessionHandler.syncSchemaWithDB(AbstractSessionHandler.java:77)&lt;br/&gt;
	at de.espirit.firstspirit.content.ContentManagerImpl$TemporalSessionHandler.syncSchemaWithDB(ContentManagerImpl.java:1310)&lt;/p&gt;

&lt;p&gt;I changed our code back to READ_COMMITTED now, perhaps I use the same workaround as in mentioned in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt; (using READ_COMMITTED for database meta data operations and SERIALIZABLE for the rest).&lt;/p&gt;</comment>
                            <comment id="13903097" author="knutanders" created="Mon, 17 Feb 2014 09:35:49 +0000"  >&lt;p&gt;The attached program (D4160.java) reliably reproduces the bug in my environment.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;java.sql.SQLException: Column &apos;PARAM1&apos; already exists.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:103)
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:288)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:424)
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:353)
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2396)
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:82)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:152)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement42.&amp;lt;init&amp;gt;(EmbedPreparedStatement42.java:41)
	at org.apache.derby.jdbc.Driver42.newEmbedPreparedStatement(Driver42.java:59)
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(EmbedConnection.java:2865)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(EmbedDatabaseMetaData.java:3791)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(EmbedDatabaseMetaData.java:3623)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(EmbedDatabaseMetaData.java:3674)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(EmbedDatabaseMetaData.java:3701)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetBestRowId(EmbedDatabaseMetaData.java:2160)
	at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getBestRowIdentifier(EmbedDatabaseMetaData.java:2101)
	at D4160$1.run(D4160.java:25)
Caused by: java.sql.SQLException: Column &apos;PARAM1&apos; already exists.
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory.java:141)
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:73)
	... 16 more
Caused by: ERROR X0Y68: Column &apos;PARAM1&apos; already exists.
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:265)
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:260)
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.duplicateDescriptorException(DataDictionaryImpl.java:2032)
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addDescriptor(DataDictionaryImpl.java:2015)
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.addSPSParams(DataDictionaryImpl.java:4363)
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(DataDictionaryImpl.java:4511)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(SPSDescriptor.java:1142)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:764)
	at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:655)
	at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(ExecSPSNode.java:167)
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:546)
	at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:99)
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:1116)
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:134)
	... 10 more
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13903280" author="knutanders" created="Mon, 17 Feb 2014 14:41:20 +0000"  >&lt;p&gt;On 15/Apr/09 I commented:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the lock timeout in the nested transaction happens after addSPSParams() has been called, the rows will be there when we retry the operation in the user transaction since we commit the nested transaction instead of aborting it. I think we can&apos;t abort the nested transaction because it will also abort the parent transaction, but perhaps it is possible to use savepoints to make sure that all the changes made by the nested transaction are rolled back before we retry.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the attached repro, it looks like that&apos;s indeed what&apos;s happening. There&apos;s a lock conflict that prevents the nested transaction from completing the creation of the SPS immediately, so it is retried in the parent transaction. But the nested transaction has already added rows for some of the parameters, so the retry in the parent transaction fails because it tries to insert duplicates.&lt;/p&gt;

&lt;p&gt;As already mentioned, aborting/rolling back the nested transaction before retrying will also cause the parent transaction to be aborted, so we cannot do that. It was suggested that we use savepoints instead. Unfortunately, savepoints are not supported in nested transactions, so that won&apos;t work either.&lt;/p&gt;

&lt;p&gt;One possible workaround might be to drop the added rows before retrying. I&apos;m experimenting with adding&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        dropAllColumnDescriptors(uuid, tc);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to the beginning of DataDictionaryImpl.addSPSParams(). That makes the repro stop failing. I&apos;m running the regression test suite now to see if that change breaks something.&lt;/p&gt;</comment>
                            <comment id="13904296" author="knutanders" created="Tue, 18 Feb 2014 17:39:28 +0000"  >&lt;p&gt;Actually, nested transactions &lt;b&gt;do&lt;/b&gt; support savepoints. It was the more low-level internal transactions that didn&apos;t.&lt;/p&gt;

&lt;p&gt;Unfortunately, adding a savepoint at the beginning of the nested transaction and rolling back to the savepoint on error does not seem to fix the bug. That makes me wonder if the real problem here is not the lack of rollback before retrying, but rather that the other thread has compiled and stored the SPS when the current thread retries. If that&apos;s the problem (more debugging is needed to verify it), we may need logic to avoid the retry if it is the SPS has already been recompiled by someone else.&lt;/p&gt;</comment>
                            <comment id="13905475" author="knutanders" created="Wed, 19 Feb 2014 14:19:35 +0000"  >&lt;p&gt;It looks like this is a race condition in the handling of the SYS.SYSSTATEMENTS.INITIALLY_COMPILABLE column. We have seen other race conditions in the handling of this column before, see for example &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The column tells whether a stored prepared statement is compiled when it&apos;s created, or if it has to be compiled later. In practice, this means it should be true for trigger statements, and false for meta-data statements (because meta-data statements are added to the database so early in the database creation or upgrade that there is no LanguageConnectionContext available yet, and they cannot be compiled).&lt;/p&gt;

&lt;p&gt;However, once a meta-data statement has been compiled, the value of the column is switched from false to true. So it doesn&apos;t actually tell whether the SPS was initially compilable, but rather whether it has been compiled at least once. This is used by DataDictionaryImpl.updateSPS() to decide whether it should update the existing SPS or create it from scratch.&lt;/p&gt;

&lt;p&gt;What happens in the repro, is: Two threads attempt to execute the same meta-data query. They both read the SPSDescriptor from the dictionary, and they both see that INITIALLY_COMPILABLE is false because the meta-data query has not been executed before. Both of them compile the query, and both of them try to store the SPS. Because of locking in the system tables, one of them has to wait for the other to complete before it goes ahead and stores it. Since it had previously seen that INITIALLY_COMPILABLE was false, it gets confused when it finds that the SPS is already in the database, and throws the above mentioned exception &quot;ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&quot;&lt;/p&gt;

&lt;p&gt;I suppose we could add more logic to synchronize between the two threads to avoid the race condition. But I think the best solution would be to change the use of INITIALLY_COMPILABLE so that its value represents what its name suggests: whether or not the statement was initially compilable. Now, since this means INITIALLY_COMPILABLE won&apos;t change during the lifetime of the SPS, it also means that there won&apos;t be any race conditions when accessing it.&lt;/p&gt;

&lt;p&gt;This change means that DataDictionaryImpl.updateSPS() can no longer tell whether or not the SPS is already stored in the database based on that column. But that information is not strictly needed. It is currently used in order to decide whether the existing SPS should be updated or a new one created. We could instead change the code to always replace the existing one (that is, delete the existing one if one exists, and create a new one). This change will actually simplify this part of the code significantly, since we get a shared code path for the first compilation of an SPS and subsequent recompilations, whereas they currently have two separate code paths. Additionally, the redefinition of INITIALLY_COMPILABLE probably fixes &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt; as well, so that we can remove the current workaround that we have for that bug.&lt;/p&gt;</comment>
                            <comment id="13906846" author="knutanders" created="Thu, 20 Feb 2014 10:44:33 +0000"  >&lt;p&gt;The attached patch, d4160-1a.diff, makes the following changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Use a savepoint to roll back the work done by the nested transaction if an error occurs. Although this wasn&apos;t what caused the problem (at least not in the repro), this sounds like the right thing to do.&lt;/li&gt;
	&lt;li&gt;Make DataDictionaryImpl.updateSPS() do exactly the same on the first compilation as it does on subsequent compilations. This way, we avoid the race condition since the threads that update the SPS don&apos;t need to know if it has been compiled before.&lt;/li&gt;
	&lt;li&gt;Remove the no longer needed workaround for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2584&quot; title=&quot;Creating a database with JPOX SchemaTool sometimes gives ArrayIndexOutOfBoundsException when getIndexInfo() is called&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2584&quot;&gt;&lt;del&gt;DERBY-2584&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
	&lt;li&gt;Add a test case to DatabaseMetaDataTest to verify the fix.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The patch removes more code than it adds, so I think it also reduces code complexity and makes it easier to follow the logic.&lt;/p&gt;

&lt;p&gt;All regression tests ran cleanly with the patch.&lt;/p&gt;</comment>
                            <comment id="13908095" author="jira-bot" created="Fri, 21 Feb 2014 08:34:37 +0000"  >&lt;p&gt;Commit 1570488 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knutanders&quot; class=&quot;user-hover&quot; rel=&quot;knutanders&quot;&gt;Knut Anders Hatlen&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1570488&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1570488&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4160&quot; title=&quot;getMetaData().getIndexInfo crashes with &amp;quot;ERROR X0Y68: Column &amp;#39;PARAM1&amp;#39; already exists.&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4160&quot;&gt;&lt;del&gt;DERBY-4160&lt;/del&gt;&lt;/a&gt;: getMetaData().getIndexInfo crashes with &quot;ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&quot;&lt;/p&gt;

&lt;p&gt;Use a shared code path for adding parameters to SYS.SYSCOLUMNS on the&lt;br/&gt;
first compilation and subsequent compilations of a meta-data query.&lt;br/&gt;
Previously, the first compilation took a different code path, but that&lt;br/&gt;
caused problems if two threads compiled a meta-data query at the same&lt;br/&gt;
time, and both threads thought they were first.&lt;/p&gt;

&lt;p&gt;Set a savepoint before attempting to write a stored prepared statement&lt;br/&gt;
to the system tables in a nested transaction, and roll back to the&lt;br/&gt;
savepoint if an error happens. This prevents partially stored prepared&lt;br/&gt;
statements from lying around in the system tables after an error.&lt;/p&gt;</comment>
                            <comment id="13908113" author="knutanders" created="Fri, 21 Feb 2014 09:23:09 +0000"  >&lt;p&gt;I think it is OK to backport this fix back to 10.5 (I&apos;m not planning to port it that far back, though). Backporting it further is not safe in its current shape because of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1107&quot; title=&quot;For existing databases JDBC metadata queries do not get updated properly  between maintenance versions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1107&quot;&gt;&lt;del&gt;DERBY-1107&lt;/del&gt;&lt;/a&gt; (fixed in 10.5). Meta-data SPSs created with the fix for this issue need to be dropped and recreated before they can be used by versions without the fix, otherwise the older version will get confused when it finds a compiled SPS whose INITIALLY_COMPILABLE column is still false. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1107&quot; title=&quot;For existing databases JDBC metadata queries do not get updated properly  between maintenance versions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1107&quot;&gt;&lt;del&gt;DERBY-1107&lt;/del&gt;&lt;/a&gt; made Derby drop and recreate meta-data SPSs on all version changes, not only when upgrading across branches, so this should not be a problem on 10.5 and later.&lt;/p&gt;</comment>
                            <comment id="13920626" author="jira-bot" created="Wed, 5 Mar 2014 07:57:05 +0000"  >&lt;p&gt;Commit 1574389 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knutanders&quot; class=&quot;user-hover&quot; rel=&quot;knutanders&quot;&gt;Knut Anders Hatlen&lt;/a&gt; in branch &apos;code/branches/10.10&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1574389&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1574389&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4160&quot; title=&quot;getMetaData().getIndexInfo crashes with &amp;quot;ERROR X0Y68: Column &amp;#39;PARAM1&amp;#39; already exists.&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4160&quot;&gt;&lt;del&gt;DERBY-4160&lt;/del&gt;&lt;/a&gt;: getMetaData().getIndexInfo crashes with &quot;ERROR X0Y68: Column &apos;PARAM1&apos; already exists.&quot;&lt;/p&gt;

&lt;p&gt;Merged revision 1570488 from trunk.&lt;/p&gt;</comment>
                            <comment id="14284831" author="myrna" created="Wed, 21 Jan 2015 00:23:37 +0000"  >&lt;p&gt;bulk change to close all issues resolved but not closed and not changed since June 1, 2014.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12367904">DERBY-2584</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12629345" name="D4160.java" size="1483" author="knutanders" created="Mon, 17 Feb 2014 09:35:49 +0000"/>
                            <attachment id="12630037" name="d4160-1a.diff" size="16907" author="knutanders" created="Thu, 20 Feb 2014 10:44:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 15 Apr 2009 12:02:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24071</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0bef:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35665</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>