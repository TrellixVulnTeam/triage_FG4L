<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:21:31 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1482/DERBY-1482.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1482] Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1482</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Suppose I have 1) a table &quot;t1&quot; with blob data in it, and 2) an UPDATE trigger &quot;tr1&quot; defined on that table, where the triggered-SQL-action for &quot;tr1&quot; does NOT reference any of the blob columns in the table. [ Note that this is different from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt; because &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt; deals with triggers that &lt;em&gt;do&lt;/em&gt; reference the blob column(s), whereas this issue deals with triggers that do &lt;em&gt;not&lt;/em&gt; reference the blob columns--but I think they&apos;re related, so I&apos;m creating this as subtask to 438 ]. In such a case, if the trigger is fired, the blob data will be streamed into memory and thus consume JVM heap, even though it (the blob data) is never actually referenced/accessed by the trigger statement.&lt;/p&gt;

&lt;p&gt;For example, suppose we have the following DDL:&lt;/p&gt;

&lt;p&gt;    create table t1 (id int, status smallint, bl blob(2G));&lt;br/&gt;
    create table t2 (id int, updated int default 0);&lt;br/&gt;
    create trigger tr1 after update of status on t1 referencing new as n_row for each row mode db2sql update t2 set updated = updated + 1 where t2.id = n_row.id;&lt;/p&gt;

&lt;p&gt;Then if t1 and t2 both have data and we make a call to:&lt;/p&gt;

&lt;p&gt;    update t1 set status = 3;&lt;/p&gt;

&lt;p&gt;the trigger tr1 will fire, which will cause the blob column in t1 to be streamed into memory for each row affected by the trigger. The result is that, if the blob data is large, we end up using a lot of JVM memory when we really shouldn&apos;t have to (at least, in &lt;em&gt;theory&lt;/em&gt; we shouldn&apos;t have to...).&lt;/p&gt;

&lt;p&gt;Ideally, Derby could figure out whether or not the blob column is referenced, and avoid streaming the lob into memory whenever possible (hence this is probably more of an &quot;enhancement&quot; request than a bug)... &lt;/p&gt;</description>
                <environment></environment>
        <key id="12345511">DERBY-1482</key>
            <summary>Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                            <label>LOB</label>
                            <label>derby_backport_reject_10_8</label>
                    </labels>
                <created>Thu, 6 Jul 2006 23:04:48 +0100</created>
                <updated>Mon, 17 Jun 2013 10:19:12 +0100</updated>
                            <resolved>Tue, 17 May 2011 19:59:40 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.9.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12419539" author="djd" created="Thu, 6 Jul 2006 23:06:21 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-442&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-442&quot;&gt;&lt;del&gt;DERBY-442&lt;/del&gt;&lt;/a&gt; is marked as a sub-taks of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt; but in reality this is a separate bug.&lt;br/&gt;
The existing comments in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-442&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-442&quot;&gt;&lt;del&gt;DERBY-442&lt;/del&gt;&lt;/a&gt; and repro conttinue to apply for this bug.&lt;/p&gt;</comment>
                            <comment id="12435871" author="rhillegas" created="Tue, 19 Sep 2006 16:21:36 +0100"  >&lt;p&gt;Moving to 10.2.2.0.&lt;/p&gt;</comment>
                            <comment id="12456054" author="rhillegas" created="Wed, 6 Dec 2006 14:45:27 +0000"  >&lt;p&gt;Move to 10.2.3.0.&lt;/p&gt;</comment>
                            <comment id="12467542" author="fuzzylogic" created="Thu, 25 Jan 2007 20:36:38 +0000"  >&lt;p&gt;Unsetting Fix Version for unassigned issues.&lt;/p&gt;</comment>
                            <comment id="12546489" author="kmarsden" created="Wed, 28 Nov 2007 23:51:06 +0000"  >&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-442&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-442&quot;&gt;&lt;del&gt;DERBY-442&lt;/del&gt;&lt;/a&gt;, Manish said:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-442#action_12374273&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-442#action_12374273&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&quot;If we want to be smart and not read the columns which are not needed by the trigger, the trigger descriptor and the system table will have to remember which columns are referenced by the trigger. Confusingly, the referencedcolumns column of SYSTRIGGERS actually contains the triggering columns!&quot;&lt;/p&gt;

&lt;p&gt;Does this mean that in order to fix this upgrade changes will be required?&lt;/p&gt;

</comment>
                            <comment id="12546496" author="djd" created="Thu, 29 Nov 2007 00:05:03 +0000"  >&lt;p&gt;Possibly not, don&apos;t jump to the conclusion that reading all the columns implies that LOB columns must be loaded into memory.&lt;/p&gt;

&lt;p&gt;So while reading all columns for the row is undesirable, it may not be causing the actual problem. The problem is that once a LOB column is read it is being streamed into memory even if it isn&apos;t referenced.&lt;/p&gt;

&lt;p&gt;Compare to a SELECT * from a table with LOB columns. All the columns are read from the table, but if the application never fetches the LOB columns they will not be read into memory, so what in the trigger case is causing the LOB values to be fully read.&lt;/p&gt;</comment>
                            <comment id="12546768" author="kmarsden" created="Thu, 29 Nov 2007 15:41:18 +0000"  >&lt;p&gt;My ultimate goal is to get a patch for 10.1 which will allow triggers on tables with blob columns if none of the blob columns are referenced.   I see three possible approaches.&lt;/p&gt;

&lt;p&gt;1) Port &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt;.  This is a huge change and my initial cursory attempts weren&apos;t successful, but I could give it another shot.&lt;/p&gt;

&lt;p&gt;2) Try to fix this bug in the hopes that eliminating the read of the lob columns will allow us to have triggers on non-LOB columns.&lt;/p&gt;

&lt;p&gt;3) Something completely different for 10.1 to not read LOB columns at all in triggers.&lt;/p&gt;

&lt;p&gt;Do you think fixing this bug to not fully read the lob values will allow us to have triggers on non-LOB columns?&lt;/p&gt;

</comment>
                            <comment id="12546782" author="djd" created="Thu, 29 Nov 2007 16:12:55 +0000"  >&lt;p&gt;Sorry, misunderstood what you were trying to achieve. I guess I was just pointing out that 2) is one possible fix to &lt;b&gt;this&lt;/b&gt; bug, but will have upgrade costs. Look strictly at the symptoms of this bug there may be an easier fix (for this bug) that reads the columns but does not stream them in. The first action would be to find why the LOB values are being streamed in, that&apos;s not a requirement for the column be read from the store.&lt;/p&gt;

&lt;p&gt;As for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt;, maybe the discussion would be better in that issue, since it&apos;s then clear what is being attempted.&lt;/p&gt;</comment>
                            <comment id="12546793" author="kmarsden" created="Thu, 29 Nov 2007 16:46:19 +0000"  >&lt;p&gt;I came across this relevant comment in DMLWriteResultSet and thought I would post for reference.&lt;/p&gt;

&lt;p&gt;/* We only need to objectify the streams here if they are exposed to the users through the&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;trigger context.  For &quot;before&quot; trigger, we could just return the stream wrapped in&lt;/li&gt;
	&lt;li&gt;RememberBytesInputStream to the user and reset it after usage, but this wouldn&apos;t work&lt;/li&gt;
	&lt;li&gt;because the user may get the stream in trigger action and do something with it in parallel&lt;/li&gt;
	&lt;li&gt;with the store doing insert.  We could also delay the materializing until the stream is&lt;/li&gt;
	&lt;li&gt;fetched in before trigger but that would complicate the code.  For &quot;after&quot; trigger, we have&lt;/li&gt;
	&lt;li&gt;to materialize it here because store only keeps a page&apos;s amount for each round.  For other&lt;/li&gt;
	&lt;li&gt;reasons of &quot;deferred&quot; operations we don&apos;t need to objectify here.  Simply going through a&lt;/li&gt;
	&lt;li&gt;temp table (either in memory part or spilled to disk) is fine for the stream, unless a&lt;/li&gt;
	&lt;li&gt;same stream appears in two rows in the temp table, which could happen for an &quot;update&quot;, in&lt;/li&gt;
	&lt;li&gt;which case we do the objectifying in UpdateResultSet.  Beetle 4896.  Related bug entries:&lt;/li&gt;
	&lt;li&gt;2432, 3383.&lt;br/&gt;
		 */&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12546865" author="djd" created="Thu, 29 Nov 2007 20:09:27 +0000"  >&lt;p&gt;Sorry, I&apos;m confused again:&lt;/p&gt;

&lt;p&gt;&amp;gt;My ultimate goal is to get a patch for 10.1 which will allow triggers on tables with blob columns if none of the blob columns are referenced. I see three possible approaches.&lt;br/&gt;
&amp;gt; 1) Port &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-438&quot; title=&quot;Update triggers on tables with BLOB and CLOB columns fail at execution time if the triggered-SQL-statement references the LOB column(s).&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-438&quot;&gt;&lt;del&gt;DERBY-438&lt;/del&gt;&lt;/a&gt; is about triggers that reference BLOB columns, how does that relate to the problem you are seeing which is for triggers that do not reference BLOB columns?&lt;/p&gt;</comment>
                            <comment id="12546887" author="djd" created="Thu, 29 Nov 2007 20:55:18 +0000"  >&lt;p&gt;I don&apos;t think this issue is related to streaming BLOBs into memory. I think the out of memory in the repro is due to the page cache blowing the memory limits.&lt;/p&gt;

&lt;p&gt;If I run the repro with a page cache size of 50 then the repro program succeeds with -Xm4m.&lt;/p&gt;

&lt;p&gt;I put trace code in SQLBlob that would print out if the BLOB values were being converted from a stream to a byte[] and non were printed.&lt;/p&gt;</comment>
                            <comment id="12546889" author="djd" created="Thu, 29 Nov 2007 20:57:50 +0000"  >&lt;p&gt;Just to add the page cache is larger in size for the BLOB table case because the page size for the table will have increased to 32k instead of 4k for the table without BLOB columns.&lt;/p&gt;</comment>
                            <comment id="12546904" author="djd" created="Thu, 29 Nov 2007 21:29:24 +0000"  >&lt;p&gt;Turns out this is an issue (BLOBs are streamed into memory) but the repro program does not show it. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The repro uses blobs of 30k which will not be streamed by the store, and even if they were 30k is unlikely to cause any memory issues.&lt;/p&gt;

&lt;p&gt;Changing the BLOB size to 30Mb showed the problem, here&apos;s the stack trace of where the BLOB is being serialized:&lt;/p&gt;

&lt;p&gt;        at org.apache.derby.iapi.types.SQLBinary.getValue(SQLBinary.java:219)&lt;br/&gt;
        at org.apache.derby.iapi.types.SQLBinary.loadStream(SQLBinary.java:573)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.DMLWriteResultSet.objectifyStreams(DMLWriteResultSet.java:152)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:133)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.UpdateResultSet.collectAffectedRows(UpdateResultSet.java:437)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:256)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1228)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1650)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(EmbedPreparedStatement.java:299)&lt;br/&gt;
        at d442.run(d442.java:192)&lt;/p&gt;</comment>
                            <comment id="12803588" author="mamtas" created="Fri, 22 Jan 2010 03:32:22 +0000"  >&lt;p&gt;Including the steps here to reproduce the problem of out of memory.&lt;br/&gt;
1)First create the database with 3 populated tables using the attached java program derby1482Repro.java as follows&lt;br/&gt;
java org.apache.derbyTesting.functionTests.tests.lang.derby1482Repro&lt;br/&gt;
Some information about the 3 tables&lt;br/&gt;
   a)Table t1 has a BLOB column along with other columns.&lt;br/&gt;
   b)Table t3 is similar to t1 but without a BLOB column&lt;br/&gt;
   c)Table t1 has an update trigger defined on it which updates table t2 in the trigger action.&lt;br/&gt;
   d)Table t3 also has an update trigger defined on it which also updates table t2 in the trigger action.&lt;br/&gt;
2)To reproduce the problem of OutOfMemory, connect to the database using ij with very limited heap&lt;br/&gt;
java -Xmx4m -Dij.exceptionTrace=true org.apache.derby.tools.ij&lt;br/&gt;
connect &apos;jdbc:derby:testDB1482;create=true&apos;;&lt;br/&gt;
--following update of table t3 works with no problem. This is the table with no BLOB column&lt;br/&gt;
update t3 set status = 1 where id = 1;&lt;br/&gt;
--But the following update will fail with OOM. This update is on the table with BLOB column&lt;br/&gt;
update t1 set status = 1 where id = 1;&lt;/p&gt;

&lt;p&gt;The attached derby1482Repro.java is subset of the repro provided by Army for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-442&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-442&quot;&gt;&lt;del&gt;DERBY-442&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12805593" author="mikem" created="Wed, 27 Jan 2010 18:01:52 +0000"  >&lt;p&gt;Does anyone know what guarantees there are on the &quot;old&quot; and &quot;new&quot; values in&lt;br/&gt;
the trigger action.  I understand they should represent before and after values&lt;br/&gt;
with respect to triggering statement.  But must they be unaffected by actions&lt;br/&gt;
taken in the trigger action.&lt;/p&gt;

&lt;p&gt;So for instance you have a before trigger, and the trigger action changes&lt;br/&gt;
the value of the row twice.  Do we guarantee that the &quot;old&quot; value will not&lt;br/&gt;
change?&lt;/p&gt;

&lt;p&gt;I ask this while trying to understand what is necessary for LOB old and new&lt;br/&gt;
values.&lt;/p&gt;

&lt;p&gt;I am trying to understand how this issue could be addressed without doing&lt;br/&gt;
the work Kathey describes to figure out what old and new column values are&lt;br/&gt;
referenced.  Without this info I don&apos;t think it is possible to guarantee&lt;br/&gt;
an old value of a LOB around without somehow saving a copy of the whole stream.&lt;br/&gt;
The easiest to understand case is if someone actually updates the LOB&lt;br/&gt;
between the time the row was first saved and when the trigger action&lt;br/&gt;
references it.  In this case if we have not drained the stream before then&lt;br/&gt;
it is not guaranteed to still be valid in the store.  The store does not&lt;br/&gt;
guarantee access to the old lob if it has been updated.  Maintaining a lock&lt;br/&gt;
on the row will stop other threads from updating it but it could still be&lt;br/&gt;
changed by the same transaction.&lt;/p&gt;

&lt;p&gt;It would not be hard to figure out if the trigger statement could change&lt;br/&gt;
various columns.  It would be slightly harder to figure out if the trigger&lt;br/&gt;
action could change the values, as it could be multiple statements.&lt;/p&gt;

&lt;p&gt;On the face of this I only see the following possibilities:&lt;br/&gt;
1) do the work to figure out what columns the trigger action accesses.  Then&lt;br/&gt;
   we only need to save old/new values of those columns referenced.&lt;/p&gt;

&lt;p&gt;2) Rather than reading the lobs into memory, existing interfaces could be used&lt;br/&gt;
   to stream the lobs to temp tables, and then save a stream reference to these.&lt;br/&gt;
   But this still would cause a lot of overhead for a trigger that never&lt;br/&gt;
   references the lobs.&lt;/p&gt;

&lt;p&gt;3) Define the behaviour in a subset of the cases such that we can use the&lt;br/&gt;
   existing lob in the db, and just maintain a stream reference to it.  Somethin&lt;br/&gt;
g like:&lt;br/&gt;
   o after trigger uses existing lob if trigger statement does not update&lt;br/&gt;
     lob column.  Ignore trigger action possibly changing the lob value.&lt;br/&gt;
   o before triggers always use exising lob in db, ignores possibility of&lt;br/&gt;
     same xact changing the lob value in trigger action.&lt;/p&gt;</comment>
                            <comment id="12805606" author="mamtas" created="Wed, 27 Jan 2010 18:35:35 +0000"  >&lt;p&gt;I am working on writing few trigger test cases where it demonstrates various requirements for LOB streaming/objectifying because of them being accesses by trigger statement or trigger action or both. Additionally, few trigger test cases where LOB is not accessed at all by the trigger statement or trigger action. I think these test cases will come handy with any work that goes in for this jira. Currently, I am writing them as a standalone java program rather than a junit test.&lt;/p&gt;</comment>
                            <comment id="12805611" author="kristwaa" created="Wed, 27 Jan 2010 18:54:48 +0000"  >&lt;p&gt;Regarding the tests that don&apos;t actually access the LOBs, it would be helpful to have one where the LOB is larger than the Java heap.&lt;/p&gt;

&lt;p&gt;While working on the LOB streaming / cloning issues, I discovered that the sorter always materializes LOBs, causing queries like &apos;select ... from ... order by length(myLOBs)&apos; to be either very inefficient (despite that we in many cases have stored information about the length) or to fail with an OOME (depends on whether the code writes the records to temporary disk storage or not).&lt;br/&gt;
I&apos;ll log an issue to track this when I have investigated a bit more.&lt;/p&gt;</comment>
                            <comment id="12828197" author="mamtas" created="Mon, 1 Feb 2010 17:49:05 +0000"  >&lt;p&gt;I have been spending some time on this jira writing test cases and researching the code a bit. Also spoke to Mike about the jira in general. Here are the findings so far.&lt;/p&gt;

&lt;p&gt;Following is the Derby behavior that we expect in regards to the lob columns and update triggers&lt;br/&gt;
1)In case of an AFTER UPDATE TRIGGER on the LOB column, we expect Derby to do a deep copy of the before and after image of LOB columns in the triggering table. The reason for deep copy is the contents of LOB will be different in store before the update and after the update.  I have a java program conforming this behavior. That java program is attached and the program&apos;s name is derby1482DeepCopyAfterTriggerOnLobColumn.java&lt;br/&gt;
2)If the AFTER UPDATE TRIGGER is defined on non-LOB column, Derby still does a deep copy of before and after image of LOB columns in the triggering table. The possible improvements that can be made to Derby is to detect somehow if there is any need to do deep copy at all if the LOB columns are not getting accessed in the TRIGGER. If they are never accessed, there is no need to any before/after update values of the LOB columns thus saving memory requirement and unnecssary time spent in doing copy. I am working on writing a test case conforming that deep copy is being done even though there is really no need to since LOB columns are not getting accessed.&lt;br/&gt;
3)In case of BEFORE UPDATE TRIGGER, we should not be doing any deep copy because the before and after images of LOB should be same (which will be the LOB value before update was done). I am working on writing test case for this scenario too.&lt;/p&gt;</comment>
                            <comment id="12828255" author="mamtas" created="Mon, 1 Feb 2010 20:11:36 +0000"  >&lt;p&gt;Deleted old derby1482DeepCopyAfterTriggerOnLobColumn.java and attaching a newer version derby1482DeepCopyAfterTriggerOnLobColumn.java which not only shows how available heap memory impact an AFTER UPDATE TRIGGER on a LOB column by making it run into out of memory error, but it also shows that the heap memory change does not impact similar AFTER UPDATE TRIGGER but on a CHAR column rather than a LOB column. I am copying the javadoc comments from the program here to show what it is doing&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt; - This program shows that we are successfully doing deepcopy&lt;/li&gt;
	&lt;li&gt;of before and after images of a lob object during an after update&lt;/li&gt;
	&lt;li&gt;trigger(that is provided we are running with enough memory.)&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;In case of after update trigger, we MUST do a deepcopy since the store&lt;/li&gt;
	&lt;li&gt;value of lob is going to be different before and after the update.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;There are 2 sets of test cases&lt;/li&gt;
	&lt;li&gt;1)The first test case(runLobTest), the AFTER UPDATE TRIGGER has been defined&lt;/li&gt;
	&lt;li&gt;on LOB column which means that Derby has to have enough memory to do the&lt;/li&gt;
	&lt;li&gt;deep copy of the before and after image of the LOB column. With enough&lt;/li&gt;
	&lt;li&gt;memory, the program will run with no OOM errors. Steps to runs the&lt;/li&gt;
	&lt;li&gt;program successfully (w/o OOM error) for this test case is as follows&lt;/li&gt;
	&lt;li&gt;java org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn load&lt;/li&gt;
	&lt;li&gt;java org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn runLobTest&lt;/li&gt;
	&lt;li&gt;For this same test case, if we run the test with limited memory, we will run&lt;/li&gt;
	&lt;li&gt;into OOM error showing that there is not enough memory available to do the&lt;/li&gt;
	&lt;li&gt;deep copy. Follow the steps below to see that behavior&lt;/li&gt;
	&lt;li&gt;java org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn load&lt;/li&gt;
	&lt;li&gt;java -Xmx4m org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn runLobTest&lt;/li&gt;
	&lt;li&gt;2)The second test case(runCharTest) shows that there is no issue with OOM&lt;/li&gt;
	&lt;li&gt;even when running with limited memory when LOB column is not used in the&lt;/li&gt;
	&lt;li&gt;triggering table, meaning Derby does not have any LOB columns to have to&lt;/li&gt;
	&lt;li&gt;copy in memory. This test case has the AFTER UPDATE TRIGGER on a CHAR&lt;/li&gt;
	&lt;li&gt;column. The steps to run with plenty memory is as follows&lt;/li&gt;
	&lt;li&gt;java org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn load&lt;/li&gt;
	&lt;li&gt;java org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn runCharTest&lt;/li&gt;
	&lt;li&gt;The steps to run this CHAR trigger with limited memory is as shown below.&lt;/li&gt;
	&lt;li&gt;The limited memory has no impact (in orther words no OOM) for CHAR trigger&lt;/li&gt;
	&lt;li&gt;java org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn load&lt;/li&gt;
	&lt;li&gt;java -Xmx4m org.apache.derbyTesting.functionTests.tests.lang.derby1482DeepCopyAfterTriggerOnLobColumn runCharTest&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;The first step in all the test scenarios is to first load the data needed&lt;/li&gt;
	&lt;li&gt;and then perform the next step.&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12834008" author="mamtas" created="Mon, 15 Feb 2010 22:38:16 +0000"  >&lt;p&gt;The current reproducible attached to this jira derby1482Repro.java really runs into OOM because it can&apos;t get enough page cache from the heap available to the jvm. This problem can be easily resolved by decreasing the amount of page cache requested from the heap. This can be achieved by using the property -Dderby.storage.pageCacheSize=smallerpagecache. Once the page cache requirement is lowered derby1482Repro.java runs fine without any problems with LOB streaming. The reason we don&apos;t run into OOM for streaming of LOB with derby1482Repro.java is that the LOB data size is not big enough. derby1482Repro.java is inserting only 30K data into the 2G LOB(notice I am talking about data size and not column size. LOB column is declared as 2G but data loaded into it is only 30K). Store does not stream data out of store when the data size is less than the page size (in Derby, page size is 32K). In order for us to cause the data to be read in the memory, the data size has to be bigger. &lt;/p&gt;

&lt;p&gt;What we are really after is a reproducible program which runs into OOM while LOBs are being streamed into memory as part of trigger execution when the LOBs are really not needed to be streamed in because they are not being accessed/updated. I have spent some time on coming up with a repro for OOM as a result of LOB streaming. That repro is attached as derby1482ReproVersion2.java This test case runs into OOM while streaming the LOB because now the LOB data is 320M in size, much larger than the page size of 32K. Since the BLOB is so large, Store will stream it into memory, thus running into OOM). &lt;br/&gt;
To reproduce the problem, use the following steps&lt;br/&gt;
1)First create the database with 3 populated tables using the attached java program &lt;br/&gt;
derby1482ReproVersion2.java as follows &lt;br/&gt;
java org.apache.derbyTesting.functionTests.tests.lang.derby1482ReproVersion2&lt;br/&gt;
Some information about the 3 tables &lt;br/&gt;
   a)Table t1 has a BLOB column along with other columns. &lt;br/&gt;
   b)Table t3 is similar to t1 but without a BLOB column &lt;br/&gt;
   c)Table t1 has an update trigger defined on it which updates table t2 in the trigger action. &lt;br/&gt;
   d)Table t3 also has an update trigger defined on it which also updates table t2 in the trigger action. &lt;br/&gt;
2)To reproduce the problem of OutOfMemory, connect to the database using ij with very limited heap &lt;br/&gt;
java -Xmx4m -Dderby.storage.pageCacheSize=40 -Dij.exceptionTrace=true org.apache.derby.tools.ij &lt;br/&gt;
connect &apos;jdbc:derby:testDB1482;create=true&apos;; &lt;br/&gt;
--following update of table t3 works with no problem. This is the table with no BLOB column &lt;br/&gt;
update t3 set status = 1 where id = 1; &lt;br/&gt;
--But the following update will fail with OOM. This update is on the table with BLOB column &lt;br/&gt;
update t1 set status = 1 where id = 1; &lt;/p&gt;</comment>
                            <comment id="12834011" author="mamtas" created="Mon, 15 Feb 2010 22:59:52 +0000"  >&lt;p&gt;The stack trace of OOM for the reprodcuible is as follows&lt;br/&gt;
2010-02-15 20:37:07.296 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 37836), (SESSIONID = 1), (DATABASE = testDB1482), (DRDAID = null), Failed Statement is: update t1 set status = 1 where id = 1&lt;br/&gt;
java.lang.OutOfMemoryError&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLBinary.readExternal(SQLBinary.java:421)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLBinary.getValue(SQLBinary.java:241)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLBinary.loadStream(SQLBinary.java:686)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.doProjection(ProjectRestrictResultSet.java:533)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:297)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.getNextRowCore(NormalizeResultSet.java:185)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:127)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.collectAffectedRows(UpdateResultSet.java:425)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:254)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:436)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:317)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:625)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:555)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:329)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:521)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:363)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:261)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Main.java:229)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:184)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.main(Main.java:75)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(ij.java:59)&lt;br/&gt;
Cleanup action completed&lt;/p&gt;
</comment>
                            <comment id="12834061" author="mamtas" created="Tue, 16 Feb 2010 03:51:07 +0000"  >&lt;p&gt;For the repro derby1482Repro.java that I attached earlier today, I played a little with the heap size to see if it can be big enough to satisfy the default page cache size of 1000 pages but not big enough to be able to stream the LOB into memory. The heap size of 100M seems to meet that requirement. So the OOM above can be reproduced using following ij command once the database has been created.&lt;/p&gt;

&lt;p&gt;java -Xmx100m -Dij.exceptionTrace=true org.apache.derby.tools.ij&lt;br/&gt;
connect &apos;jdbc:derby:testDB1482;create=true&apos;; &lt;br/&gt;
--following update of table t3 works with no problem. This is the table with no BLOB column &lt;br/&gt;
update t3 set status = 1 where id = 1; &lt;br/&gt;
--But the following update will fail with OOM. This update is on the table with BLOB column &lt;br/&gt;
update t1 set status = 1 where id = 1;&lt;/p&gt;</comment>
                            <comment id="12834132" author="kristwaa" created="Tue, 16 Feb 2010 09:13:21 +0000"  >&lt;p&gt;The stack trace above from running derby1482ReproVersion2 is slightly outdated.&lt;br/&gt;
Here&apos;s a newer stack trace:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; update t1 set status = 1 where id = 1; &lt;br/&gt;
ERROR XJ001: Java exception: &apos;Java heap space: java.lang.OutOfMemoryError&apos;.&lt;br/&gt;
[ snip ]&lt;br/&gt;
Caused by: java.lang.OutOfMemoryError: Java heap space&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLBinary.readExternal(SQLBinary.java:421)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLBinary.getValue(SQLBinary.java:241)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLBinary.loadStream(SQLBinary.java:686)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.objectifyStreams(DMLWriteResultSet.java:156)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:135)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.collectAffectedRows(UpdateResultSet.java:425)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:254)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:436)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:317)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	... 10 more&lt;br/&gt;
ij&amp;gt; &lt;/p&gt;

&lt;p&gt;The code from the old stack trace has been rewritten (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4477&quot; title=&quot;Selecting / projecting a column whose value is represented by a stream more than once fails&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4477&quot;&gt;&lt;del&gt;DERBY-4477&lt;/del&gt;&lt;/a&gt;), loading the stream was only done temporarily until the underlying stream clone functionality was ready.&lt;/p&gt;

&lt;p&gt;Regarding the new repro, I do have code that will make that one pass too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
I will hold it back until you have been able to complete you current work, and my patch also needs more testing.&lt;/p&gt;

&lt;p&gt;The newly added clone functionality will basically allow all store streams to be cloned. To provoke an OOME one has to clone a stream that isn&apos;t cloneable. I haven&apos;t looked into how to do this, but I think one way of doing it is to provide a user stream to use for the update (or insert). I&apos;m sure there are other ways to do it too.&lt;br/&gt;
Despite the new cloning abilities, functionality to avoid referencing columns not being accessed will still give us benefits like increased performance and by avoiding OOMEs in certain situations.&lt;/p&gt;</comment>
                            <comment id="12834338" author="mikem" created="Tue, 16 Feb 2010 17:57:24 +0000"  >&lt;p&gt;Kristian, is there a writeup on how you will make all store streams clonable?  I am not sure how the trigger code is working, but will your cloning work for the following case.&lt;br/&gt;
With after triggers we are interested in the &quot;before&quot; and &quot;after&quot; values.  Does your code&lt;br/&gt;
somehow copy the data somewhere else from store, or do some sort of copy on&lt;br/&gt;
write?&lt;/p&gt;

&lt;p&gt;It seemed to me that the trigger full copy of the stream was trying to solve the following&lt;br/&gt;
problem, for a before trigger.  We need the before copy of the blob.  But the stored&lt;br/&gt;
value of the blob could be changed before we access it, so a a stream pointer to &lt;br/&gt;
the original blob is not going to be valid.  &lt;/p&gt;</comment>
                            <comment id="12834346" author="mamtas" created="Tue, 16 Feb 2010 18:05:14 +0000"  >&lt;p&gt;Kristian, I reran derby1482ReproVersion2 after doing a sync of the codeline and do see the updated stack. Thanks for taking the time to run the repro on your machine.&lt;/p&gt;

&lt;p&gt;I am almost done with bunch of trigger tests in combination with LOB column. Hope to post that in a day or two,&lt;/p&gt;

&lt;p&gt;My current work has to do with writing tests so feel free to checkin your code if you think it is ready.&lt;/p&gt;</comment>
                            <comment id="12835321" author="kristwaa" created="Thu, 18 Feb 2010 18:28:14 +0000"  >&lt;p&gt;@Mike (16/Feb/10):&lt;br/&gt;
I don&apos;t have a write-up, and I&apos;m not sure if the code will handle the scenarios you mention. I don&apos;t fully understand the details of the store and the trigger code in the case of inserts/updates of long columns.&lt;/p&gt;

&lt;p&gt;Can you help me understand your comment about the changing BLOB value:&lt;br/&gt;
&quot;But the stored&lt;br/&gt;
value of the blob could be changed before we access it, so a a stream pointer to&lt;br/&gt;
the original blob is not going to be valid. &quot;&lt;/p&gt;

&lt;p&gt;Who / what may change it;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the current transaction&apos;s update query?&lt;/li&gt;
	&lt;li&gt;the current transaction&apos;s trigger code?&lt;/li&gt;
	&lt;li&gt;other transactions?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I hope to be able to have a better look at the trigger code soon, but it&apos;s not on the top of my list atm.&lt;/p&gt;

&lt;p&gt;That said, I do see that we are having trouble dealing with &quot;inbound streams&quot; when they have to be used several times - our only tool there is to materialize the stream into memory. One extension would be to write data to disk temporarily to avoid OOME, but I&apos;m not sure if we can manage this without introducing a performance degradation. &lt;br/&gt;
The better option is probably to just write the value to the log and then read it back from the log as required. Do you have any idea about how much effort that would take? I&apos;m not suggesting that it should be done now, but it would be nice to have an idea about how difficult it is.&lt;/p&gt;</comment>
                            <comment id="12835612" author="mamtas" created="Fri, 19 Feb 2010 06:44:32 +0000"  >&lt;p&gt;The attached patch, TriggerTests_ver1_diff.txt, includes junit test which has few test fixtures to test triggers on table with LOB columns. Each and every one of those tests run into OOM probably because we are streaming the before and after values of LOB columns even when they are not being referenced by the trigger action. More code investigation is needed to identify different trigger cases where we should not stream the LOBs. &lt;/p&gt;

&lt;p&gt;I have added this junit test, TriggerTests.java, in org.apache.derbyTesting.functionTests.tests.memory package. It has been added to the _Suite in that package but has been commented for now with the following comments.&lt;br/&gt;
        //Disable following TriggerTests until &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt; has been fixed.&lt;br/&gt;
        //Without that fix, the test will run into OOM errors for all&lt;br/&gt;
        //the test fixtures. This test is written for triggers defined&lt;br/&gt;
        //on table with LOB columns. No matter whether the LoB columns&lt;br/&gt;
        //are touched in the trigger action, it appears that Derby is&lt;br/&gt;
        //streaming the before and after values of LOB columns. Once&lt;br/&gt;
        //the streaming problem has been resolved, we should be able&lt;br/&gt;
        //to uncomment the following test.&lt;br/&gt;
        //suite.addTest(TriggerTests.suite());&lt;br/&gt;
The org.apache.derbyTesting.functionTests.tests.memory._Suite gets run as part of the lowmem suite. lowmem suite runs all the tests in it with 16M heap. I have tweaked the page cache size for TriggerTests to 100 pages. The reason for this is that the test deals with pretty big LOBs(320M each) and we will soon run into OOM because of no memory left for page cache if we ran with the default page cache of 1000 against the 16M heap.&lt;/p&gt;

&lt;p&gt;For now, this suite runs only in embedded mode. When I ran with network server mode, I got following error. But for now, I just want to focus on the OOM failures. Once they are fixed, we can probably look at enabling this test for network server mode.&lt;br/&gt;
java.sql.SQLNonTransientConnectionException: Network protocol exception: actual code point, 4,692, does not match expected code point, 9,224.  The connection has been terminated.&lt;/p&gt;


&lt;p&gt;One interesting exception I have noticed for few of the test fixtures (in addition to OOM) looks something like following.&lt;br/&gt;
java.io.FileNotFoundException: system\wombat\log\log211.dat (The system cannot find the file specified.)&lt;br/&gt;
        at java.io.FileInputStream.open(Native Method)&lt;br/&gt;
        at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:112)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.copySingleFile(PrivilegedFileOpsForTests.java:245)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.recursiveCopy(PrivilegedFileOpsForTests.java:222)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.access$000(PrivilegedFileOpsForTests.java:47)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests$6.run(PrivilegedFileOpsForTests.java:184)&lt;br/&gt;
        at java.security.AccessController.doPrivileged(AccessController.java:251)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.copy(PrivilegedFileOpsForTests.java:182)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.recursiveCopy(PrivilegedFileOpsForTests.java:220)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.access$000(PrivilegedFileOpsForTests.java:47)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests$6.run(PrivilegedFileOpsForTests.java:184)&lt;br/&gt;
        at java.security.AccessController.doPrivileged(AccessController.java:251)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests.copy(PrivilegedFileOpsForTests.java:182)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:133)&lt;br/&gt;
        at junit.framework.TestResult$1.protect(TestResult.java:106)&lt;br/&gt;
        at junit.framework.TestResult.runProtected(TestResult.java:124)&lt;br/&gt;
        at junit.framework.TestResult.run(TestResult.java:109)&lt;br/&gt;
        at junit.framework.TestCase.run(TestCase.java:118)&lt;br/&gt;
        at junit.framework.TestSuite.runTest(TestSuite.java:208)&lt;br/&gt;
        at junit.framework.TestSuite.run(TestSuite.java:203)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.framework.TestResult.runProtected(TestResult.java:124)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.framework.TestResult.runProtected(TestResult.java:124)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
        at junit.framework.TestSuite.runTest(TestSuite.java:208)&lt;br/&gt;
        at junit.framework.TestSuite.run(TestSuite.java:203)&lt;br/&gt;
        at junit.textui.TestRunner.doRun(TestRunner.java:116)&lt;br/&gt;
        at junit.textui.TestRunner.start(TestRunner.java:172)&lt;br/&gt;
        at junit.textui.TestRunner.main(TestRunner.java:138)&lt;br/&gt;
I do not see this exception for first test fixtures. The reason behind these additional exceptions may be that we are running into OOM and jvm can start behaving unpredictably after running into OOMs. To verify that the problem is not with my tests, I changed the LOB size to 60K from 320M and ran with default heap and default page cache size and didn&apos;t run into above exceptions. Of course there were no OOMs either because we have enough heap memory to be able to stream the LOBs. In the patch attached, I have reverted my junit test back to use 320M LOB data, page cache size of 100 and limited heap of 16M enforced by the lowmem suite.&lt;/p&gt;


&lt;p&gt;The typical OOM exception for the test looks as follows&lt;br/&gt;
7) test1InsertBeforeTrigger(org.apache.derbyTesting.functionTests.tests.memory.TriggerTests)java.sql.SQLException: Java exception: &apos;: java.lang.OutOfMemoryError&apos;.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2269)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1321)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1673)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(EmbedPreparedStatement.java:303)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.runInsertTriggerTest(TriggerTests.java:1479)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.test1InsertBeforeTrigger(TriggerTests.java:541)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:109)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;: java.lang.OutOfMemoryError&apos;.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
        ... 38 more&lt;br/&gt;
Caused by: java.lang.OutOfMemoryError&lt;br/&gt;
        at org.apache.derby.iapi.types.SQLBinary.readExternal(SQLBinary.java:421)&lt;br/&gt;
        at org.apache.derby.iapi.types.SQLBinary.getValue(SQLBinary.java:244)&lt;br/&gt;
        at org.apache.derby.iapi.types.SQLBinary.loadStream(SQLBinary.java:686)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.DMLWriteResultSet.objectifyStreams(DMLWriteResultSet.java:156)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:135)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:494)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:436)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:317)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
        ... 31 more&lt;/p&gt;

&lt;p&gt;In order to run the junit test to repro the problem, first you will need to uncomment the test from  org.apache.derbyTesting.functionTests.tests.memory._Suite and compile the code. Next, you can run the lowmem suite one of the following 2 ways&lt;br/&gt;
1)You can run it as an ant target&lt;br/&gt;
ant junit-lowmem&lt;br/&gt;
2)java -Xmx16M junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.memory._Suite&lt;br/&gt;
Either one of above runs should show you OOMs for each of the test fixtures in TriggerTests.java&lt;/p&gt;

&lt;p&gt;Following documents the different trigger and LOB combinations that are being tested in TriggerTests.java. It also shows the test fixture name for that trigger and LOB test combination&lt;br/&gt;
                                                 NO REFERENCE CLAUSE in trigger definition&lt;br/&gt;
AFTER INSERT trigger        test5InsertAfterTriggerNoReferencingClause &lt;br/&gt;
BEFORE INSERT trigger    test5InsertBeforeTriggerNoReferencingClause &lt;br/&gt;
AFTER DELETE trigger       test5DeleteAfterTriggerNoReferencingClause &lt;br/&gt;
BEFORE DELETE trigger    test5DeleteBeforeTriggerNoReferencingClause &lt;br/&gt;
AFTER UPDATE trigger       test5UpdateAfterTriggerNoReferencingClause &lt;br/&gt;
BEFORE UPDATE trigger   test5UpdateBeforeTriggerNoReferencingClause &lt;/p&gt;


&lt;p&gt;                       tirgger created on non-LOB column and no LOB is referenced in trigger action&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;   &lt;br/&gt;
AFTER INSERT trigger       test1InsertAfterTrigger &lt;br/&gt;
BEFORE INSERT trigger    test1InsertBeforeTrigger &lt;br/&gt;
AFTER DELETE trigger       test1DeleteAfterTrigger &lt;br/&gt;
BEFORE DELETE trigger   test1DeleteBeforeTrigger &lt;br/&gt;
AFTER UPDATE trigger      test1UpdateAfterTrigger &lt;br/&gt;
BEFORE UPDATE trigger   test1UpdateBeforeTrigger &lt;/p&gt;


&lt;p&gt;                       tirgger created on non-LOB column and LOB is accessed in trigger action&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;br/&gt;
AFTER INSERT trigger        test2InsertAfterTriggerAccessLOB &lt;br/&gt;
BEFORE INSERT trigger     test2InsertBeforeTriggerAccessLOB &lt;br/&gt;
AFTER DELETE trigger       test2DeleteAfterTriggerAccessLOB &lt;br/&gt;
BEFORE DELETE trigger    test2DeleteBeforeTriggerAccessLOB &lt;br/&gt;
AFTER UPDATE trigger       test2UpdateAfterTriggerAccessLOB &lt;br/&gt;
BEFORE UPDATE trigger   test2UpdateBeforeTriggerAccessLOB &lt;/p&gt;



&lt;p&gt;                  tirgger created on non-LOB column and LOB is getting UPDATEed in trigger action&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;br/&gt;
AFTER INSERT trigger        test2InsertAfterTriggerUpdatedLOB &lt;br/&gt;
BEFORE INSERT trigger    No test - BEFORE triggers do not allow INSERT/UPDATE/DELETE in trigger action &lt;br/&gt;
AFTER DELETE trigger       No test - the row has been deleted and hence no way for trigger action to modify the LOB of the deleted row &lt;br/&gt;
BEFORE DELETE trigger    No test - BEFORE triggers do not allow INSERT/UPDATE/DELETE in trigger action &lt;br/&gt;
AFTER UPDATE trigger       test2UpdateAfterTriggerUpdatedLOB &lt;br/&gt;
BEFORE UPDATE trigger   No test - BEFORE triggers do not allow INSERT/UPDATE/DELETE in trigger action &lt;/p&gt;

&lt;p&gt;                       tirgger created on LOB column and no LOB is referenced in trigger action  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;br/&gt;
AFTER INSERT trigger        No test because INSERT trigger is defined on a row, not a column. test1InsertAfterTrigger will suffice. &lt;br/&gt;
BEFORE INSERT trigger     No test because INSERT trigger is defined on a row, not a column. test1InsertBeforeTrigger will suffice. &lt;br/&gt;
AFTER DELETE trigger       No test because DELETE trigger is defined on a row, not a column. test1DeleteAfterTrigger will suffice. &lt;br/&gt;
BEFORE DELETE trigger    No test because DELETE trigger is defined on a row, not a column. test1DeleteBeforeTrigger will suffice. &lt;br/&gt;
AFTER UPDATE trigger       test3UpdateAfterTrigger &lt;br/&gt;
BEFORE UPDATE trigger   test3UpdateBeforeTrigger                       &lt;/p&gt;


&lt;p&gt;                       tirgger created on LOB column and LOB is accessed in trigger action&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;br/&gt;
AFTER INSERT trigger       No test because INSERT trigger is defined on a row, not a column. test2InsertAfterTriggerAccessLOB will suffice. &lt;br/&gt;
BEFORE INSERT trigger   No test because INSERT trigger is defined on a row, not a column. test2InsertBeforeTriggerAccessLOB will suffice. &lt;br/&gt;
AFTER DELETE trigger     No test because DELETE trigger is defined on a row, not a column. test2DeleteAfterTriggerAccessLOB will suffice. &lt;br/&gt;
BEFORE DELETE trigger  No test because DELETE trigger is defined on a row, not a column. test2DeleteBeforeTriggerAccessLOB will suffice. &lt;br/&gt;
AFTER UPDATE trigger     test4UpdateAfterTriggerAccessLOB &lt;br/&gt;
BEFORE UPDATE trigger  test4UpdateBeforeTrigger &lt;/p&gt;


&lt;p&gt;                       tirgger created on LOB column and LOB is getting UPDATEed in trigger action&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;br/&gt;
AFTER INSERT trigger    No test because INSERT trigger is defined on a row, not a column. test2InsertAfterTriggerUpdatedLOB will suffice. &lt;br/&gt;
BEFORE INSERT trigger  No test - BEFORE triggers do not allow INSERT/UPDATE/DELETE in trigger action &lt;br/&gt;
AFTER DELETE trigger   No test - the row has been deleted and hence no way for trigger action to modify the LOB of the deleted row &lt;br/&gt;
BEFORE DELETE trigger  No test - BEFORE triggers do not allow INSERT/UPDATE/DELETE in trigger action &lt;br/&gt;
AFTER UPDATE trigger     test4UpdateAfterTriggerUpdatedLOB &lt;br/&gt;
BEFORE UPDATE trigger  No test - BEFORE triggers do not allow INSERT/UPDATE/DELETE in trigger action   &lt;/p&gt;



&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Has two versions of this trigger+LOB combination. The trigger action is coded as either a stored procedure call or as a direct SQL statement. &lt;br/&gt;
(+)These test cases do not have stored procedure version of them. The reason is that the trigger action references LOB columns and at this point, there is no way to pass LOB parameters to a stored procedure &lt;/p&gt;
</comment>
                            <comment id="12836742" author="mamtas" created="Mon, 22 Feb 2010 17:36:26 +0000"  >&lt;p&gt;I wrote following ij script to understand what kind of information is kept in SYSTRIGGERS when REFERENCING clause is specified or missing in the CREATE TRIGGER sql. There are 2 booolean columns, namely, REFERENCINGOLD and REFERENCINGNEW in SYSTRIGGERS table which are set to false if REFERENCING is missing. If either one of the REFERENCING clauses are specified (for OLD and NEW), the corresponding columns&apos; values will be set to TRUE, We can hopefully use this information to disable streaming of LOB columns. I will look at the code to see how this information can be used. I will assign this jira to me while I look at this aspect of REFERENCING clause.&lt;/p&gt;

&lt;p&gt;java -Dij.exceptionTrace=true org.apache.derby.tools.ij &lt;br/&gt;
connect &apos;jdbc:derby:testDB1482;create=true&apos;; &lt;br/&gt;
create table table1 (c11 int, c12 int default 0);&lt;br/&gt;
create index i1 on table1(c11);&lt;br/&gt;
create table table2 (c21 int, c22 int default 0);&lt;br/&gt;
create index i2 on table2(c21);&lt;br/&gt;
--For the trigger below, REFERENCINGOLD and REFERENCINGNEW will be false.&lt;br/&gt;
&amp;#8211; REFERENCINGOLD and REFERENCINGNEW are false because no REFERENCING clause was used in the CREATE TRIGGER.&lt;br/&gt;
create trigger trigger1 AFTER INSERT on table1 insert into table2(c21, c22) values (100, -1);&lt;br/&gt;
--For the trigger below, REFERENCINGNEW will be true because CREATE TRIGGER used REFERENCING NEW.&lt;br/&gt;
&amp;#8211; REFERENCINGOLD will be false because no REFERENCING OLD was specified in the CREATE TRIGGER sql.&lt;br/&gt;
create trigger trigger2 AFTER UPDATE of c12 on table1 REFERENCING NEW as new FOR EACH ROW &lt;br/&gt;
	update table2 set c22=-1 where c21=new.c11;&lt;br/&gt;
select CAST(TRIGGERNAME as char(14)), REFERENCEDCOLUMNS, TRIGGERDEFINITION, REFERENCINGOLD, REFERENCINGNEW from sys.systriggers;&lt;/p&gt;</comment>
                            <comment id="12837079" author="mamtas" created="Tue, 23 Feb 2010 04:52:07 +0000"  >&lt;p&gt;Commited the test TriggerTests.java with revision 915177.&lt;/p&gt;

&lt;p&gt;The commit comments are as follows&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We do not have many tests for triggers on tables with LOB columns. Checking in few tests with this checkin. The tests are disabled at this point because they run out of memory when run with limited heap because of streaming of the LOB columns whether they are needed or not. The test is part of lowmem suite which will automatically take care of running the tests with limited heap which is 16M for that suite at this point.&lt;/p&gt;

&lt;p&gt;More information on the test can be found in the comments in the test and also in the jira.&lt;/p&gt;</comment>
                            <comment id="12837104" author="mamtas" created="Tue, 23 Feb 2010 06:45:05 +0000"  >&lt;p&gt;One of the questions that has come up in this jira is are we reading all the columns when there is a trigger defined on a table with LOB column(s). I found following relevant code comment in impl.sql.compile.UpdateNode:getUpdateReadMap which confirms that we indeed are reading all the columns any time there is a trigger involved on a table involved in definitely an UPDATE DML.&lt;br/&gt;
		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;If we have any triggers, then get all the columns&lt;/li&gt;
		&lt;li&gt;because we don&apos;t know what the user will ultimately&lt;/li&gt;
		&lt;li&gt;reference.&lt;br/&gt;
	 	*/&lt;br/&gt;
The job of getUpdateReadMap as the method javadoc says&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Builds a bitmap of all columns which should be read from the&lt;/li&gt;
	&lt;li&gt;Store in order to satisfy an UPDATE statement.&lt;br/&gt;
But as soon as we find that there are triggers involved on the table, we mark all the columns as required to be read from&lt;br/&gt;
the store. This is the comment from the method&apos;s javadoc&lt;/li&gt;
	&lt;li&gt;6)	if there are any triggers, marks all columns in the bitmap&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12837222" author="kristwaa" created="Tue, 23 Feb 2010 12:43:38 +0000"  >&lt;p&gt;Fixed some JavaDoc warnings with revision 915310.&lt;/p&gt;</comment>
                            <comment id="12837341" author="mikem" created="Tue, 23 Feb 2010 17:49:31 +0000"  >&lt;p&gt;&amp;gt; @Mike (16/Feb/10):&lt;br/&gt;
&amp;gt; I don&apos;t have a write-up, and I&apos;m not sure if the code will handle the scenario&lt;br/&gt;
s you mention. I don&apos;t fully understand the details of the store and the trigger&lt;br/&gt;
 code in the case of inserts/updates of long columns.&lt;br/&gt;
My comments apply on to the store side of the streaming blobs.&lt;/p&gt;

&lt;p&gt;I am not exactly sure where the blobs are coming from in the sql layer.  I&lt;br/&gt;
think there may be some defered update tables, so the question is if the&lt;br/&gt;
streams are from the original table original table or a deferred update&lt;br/&gt;
table.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Can you help me understand your comment about the changing BLOB value:&lt;br/&gt;
&amp;gt; &quot;But the stored&lt;br/&gt;
&amp;gt; value of the blob could be changed before we access it, so a a stream pointer&lt;br/&gt;
to&lt;br/&gt;
&amp;gt; the original blob is not going to be valid. &quot;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Who / what may change it;&lt;br/&gt;
&amp;gt;  - the current transaction&apos;s update query?&lt;br/&gt;
&amp;gt;   - the current transaction&apos;s trigger code?&lt;br/&gt;
&amp;gt;    - other transactions?&lt;/p&gt;

&lt;p&gt;I believe both the first 2 are possibilities.  Locking should prevent any&lt;br/&gt;
changes to the affected row by other transactions.  So there are 2 cases:&lt;/p&gt;

&lt;p&gt;1) the current tranaction statement that causes the trigger may change the&lt;br/&gt;
   blob.&lt;/p&gt;


&lt;p&gt;   insert - value in store table could be used to stream&lt;br/&gt;
   delete - value in store table won&apos;t be avaliable after the delete&lt;br/&gt;
   update - value in store table may be changed by the update itself&lt;/p&gt;

&lt;p&gt;2) the trigger action code might change the blob.&lt;/p&gt;

&lt;p&gt;   This case is more obscure and needs to happen in a procedure.  And the&lt;br/&gt;
   only way to use the old and new values is to pass them into the procedure,&lt;br/&gt;
   and currently our procedures don&apos;t support blobs as arguments.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    That said, I do see that we are having trouble dealing with &quot;inbound stream&lt;br/&gt;
s&quot; when they have to be used several times - our only tool there is to materiali&lt;br/&gt;
ze the stream into memory. One extension would be to write data to disk temporar&lt;br/&gt;
ily to avoid OOME, but I&apos;m not sure if we can manage this without introducing a&lt;br/&gt;
performance degradation.&lt;br/&gt;
&amp;gt;    The better option is probably to just write the value to the log and then r&lt;br/&gt;
ead it back from the log as required. Do you have any idea about how much effort&lt;br/&gt;
 that would take? I&apos;m not suggesting that it should be done now, but it would be&lt;br/&gt;
 nice to have an idea about how difficult it is.&lt;br/&gt;
That sounds &quot;hard&quot; to me.  I would definitely not want to see the sql layer&lt;br/&gt;
accessing the log.  The clean separation of sql layer from the store layer&lt;br/&gt;
has greatly helped the reliablity of the product.  Also timing of it might&lt;br/&gt;
be a problem as the current trigger code may need a second access to a stream&lt;br/&gt;
before the actual value has been logged.  Again I think the key here may be&lt;br/&gt;
in understanding the deferred update tables and how they apply to all&lt;br/&gt;
the matrix of before/after insert/delete/update triggers.&lt;/p&gt;

&lt;p&gt;You also raise an interesting point about performance.  There are definitely&lt;br/&gt;
a set of applications out there that are just fine with us temporarily&lt;br/&gt;
instantiating copies of blobs into memory. Where our stream threshold is&lt;br/&gt;
a max of 32k, 2 gig of memory is very likely available.  So there should be&lt;br/&gt;
some discussion before any change goes in that would automatically stream&lt;br/&gt;
something to disk that currently uses in memory.&lt;/p&gt;</comment>
                            <comment id="12838342" author="kristwaa" created="Thu, 25 Feb 2010 13:37:47 +0000"  >&lt;p&gt;Mike wrote:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Kristian&amp;gt; The better option is probably to just write the value to the log and then read it back from the log as required. &lt;br/&gt;
Kristian&amp;gt; Do you have any idea about how much effort that would take?&lt;br/&gt;
Kristian&amp;gt; I&apos;m not suggesting that it should be done now, but it would be nice to have an idea about how difficult it is.&lt;/p&gt;

&lt;p&gt;That sounds &quot;hard&quot; to me. I would definitely not want to see the sql layer&lt;br/&gt;
accessing the log. The clean separation of sql layer from the store layer&lt;br/&gt;
has greatly helped the reliablity of the product.&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;Do you feel the same about reading the value back from the table itself (instead of the log)?&lt;br/&gt;
I&apos;ve seen this approach suggested in another Jira. If feasible, is this also hard to do?&lt;/p&gt;</comment>
                            <comment id="12839135" author="mikem" created="Sat, 27 Feb 2010 02:11:22 +0000"  >&lt;p&gt;I think reading it again from the store is a much better approach.  Best if the mechanism can be somehow hidden withing the stream that the is passed from the&lt;br/&gt;
store up to the user.&lt;/p&gt;

&lt;p&gt;This may or may not solve the various trigger issues, as the trigger needs a specific&lt;br/&gt;
version of the row which might change between when the stream is returned and when it is asked for.  For instance an update trigger must provide the before and after version of the value, but the trigger action itself may change the row.  This may not be an issue if the getting it &quot;from the store&quot; in this case is actually getting it from a deffered update temporary table, then there would be no worry about the trigger action changing it.&lt;/p&gt;

&lt;p&gt;I think this is easier than the log approach, but not a simple change.  I was thinking of taking a look at this but would rather let you get all your stream changes in to see what problems remain.  &lt;/p&gt;</comment>
                            <comment id="12843779" author="mamtas" created="Wed, 10 Mar 2010 21:21:19 +0000"  >&lt;p&gt;Just wanted to share that I am working on collecting the column referenced by the trigger action (when it is not a stored procedure call. I hope to tackle that as a seperate step) During the create trigger bind time, we go through the columns referenced by the trigger action and isolate the ones which come from the new/old tables through the REFERENCING clause. The information about those columns will be saved in a new column in SYSTRIGGERS. At triggering statement execution time, we will go through SYSTRIGGERS&apos;s new column and determine which columns should be read in rather than all the columns. This should help with OOM issues involving LOB columns.&lt;/p&gt;

&lt;p&gt;Will need to work with upgrade code to support the new column in SYSTRIGGERS. At this point, I am focusing on non-upgarde code changes.&lt;/p&gt;

&lt;p&gt;I have finished the rough code changes on collecting the columns referenced in trigger action when trigger action is not a stored procedure call. The information collected would be something like &lt;span class=&quot;error&quot;&gt;&amp;#91;1,3&amp;#93;&lt;/span&gt; which means column numbers 1 and 3 are accessed by the trigger action. But the tricky party is to transform column 3 from triggering table to column 2 in the columns that will be read into memory. eg&lt;br/&gt;
create table t1 (c11 int, c12 int, c13 int)&lt;br/&gt;
insert into t1 values (11,12, 13)&lt;br/&gt;
and say there is a trigger defined on t1 which references column numbers 1 and 3 meaning columns c11 and c13. Once I finish coding the logic completely, we will read only values 11 and 13 since c12 is not referenced by the trigger action. But the way code works right now, we try to look at the columns through the column number meaning for our eg, c11 will be looked through position 1 which is good. But c13 will be looked through position 3 but really, c13 is in position 2 of the subset of the original row from t1. &lt;/p&gt;

&lt;p&gt;My apologies if above eg is little confusing. I will try to make changes so that we look for c13 in position 2 of the subset row rather than position 3.&lt;/p&gt;

&lt;p&gt;Any feedback appreciated.&lt;/p&gt;</comment>
                            <comment id="12850374" author="mamtas" created="Fri, 26 Mar 2010 22:04:43 +0000"  >&lt;p&gt;I am attaching a patch, derby1482_patch1_diff.txt,  which is NOT READY FOR commit yet because the required upgrade work for system table change has not been done yet. If this patch is committed in it&apos;s current state, the older releases databases will fail with the trunk even with hard upgrade. I plan to work on the upgrade work soon.&lt;/p&gt;

&lt;p&gt;I ran derbyall and junit All suite with my patch. During the junite All suite run, I am getting lots of errors in the upgrade suite. The failures are attached to this jira as junitUpgradeTestFailureWithPatch1.out I think this probably is because of the new column that I have added to SYSTRIGGERS. I have not investigated this failure enough to know for sure but I will be tackling the upgrade changes soon. &lt;/p&gt;

&lt;p&gt;Next, I am planning on focusing on following tasks&lt;br/&gt;
1)Implement Rick&apos;s suggestion of including the extra information we need about trigger in existing column SYSTRIGGERS.REFERENCEDCOLUMNS This columns is of type ReferencedColumnsDescriptorImpl and I can hopefully enhance that type to include the additional information. Hopefully this approach will make it the next task easier which is to make upgrade changes.&lt;br/&gt;
2)Work on the upgrade code so this change in system table does not break older release databases when they are run in soft/hard upgrade mode with the suggested work done through this jira.&lt;br/&gt;
3)Add more test cases in addition to what was added through TriggerTests.java&lt;/p&gt;

&lt;p&gt;One thing to keep in mind is the improvement proposed by this patch will work only for UPDATE triggers defined at row level AND they identify specific columns on which the trigger is defined. eg&lt;br/&gt;
	CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 &lt;br/&gt;
	    REFERENCING OLD AS oldt NEW AS newt&lt;br/&gt;
	    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;&lt;br/&gt;
The trigger above is a row level UPDATE trigger and it identifies column &quot;c12&quot; as the triggering column. For all other kinds of triggers(INSERT, DELETE, UPDATE trigger defined at table leve, UPDATE trigger defined at row level but does not identify trigger columns), the improvement proposed by this patch will not kick in. That is because all the other kinds of triggers do not identify specific trigger columns. In the absence of specific trigger columns, Derby decides to fetch in all the columns from the triggering table since it doesn&apos;t know what column it might need to fetch at trigger execution time.&lt;/p&gt;

&lt;p&gt;Following is the description of the existing behavior and changes made through my patch. It is rather long but I wanted to provide as much information as I can since some part of the code is little tricky.&lt;/p&gt;

&lt;p&gt;I am going to work with following example to show what is being done by Derby today and what changes I am suggesting.&lt;br/&gt;
	CREATE TABLE table1 (c11 int, c12 int, c13 int, c14 int, c15 int);&lt;br/&gt;
	INSERT INTO table1 VALUES(1,2,3,4,5);&lt;br/&gt;
	CREATE TABLE table2 (c21 int, c22 int, c23 int, c24 int, c25 int);&lt;br/&gt;
	INSERT INTO table2 VALUES(2,2,3,-1,5);&lt;br/&gt;
	CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 &lt;br/&gt;
	    REFERENCING OLD AS oldt NEW AS newt&lt;br/&gt;
	    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;&lt;br/&gt;
In the update trigger tr1 above, the trigger column is c12 and trigger action references old/new transition variable oldt.c14 Note that the trigger table, table1, has 5 columns and of those only 2 columns are really needed by the trigger tr1. The trunk code converts the trigger action UPDATE table2 SET c24=oldt.c14 to UPDATE table2 SET c24=org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().getOldRow().getInt(4)&lt;br/&gt;
Note that oldt.c14 gets referenced through it&apos;s column position in triggering table table1.&lt;br/&gt;
Now let&apos;s consider the triggering statement&lt;br/&gt;
	UPDATE table1 SET c12 = -9 WHERE c11=1;&lt;br/&gt;
The trunk code is written to fetch all the 5 columns in trigger table table1 even though the trigger is only in need of columns c12 and c14. If in our example, if table1 had a LOB column with large amount of data, we would fetch that LOB column in memory too even though trigger does not need that column.&lt;/p&gt;

&lt;p&gt;With my patch, I am keeping track of references to old/new transition variables in trigger action. Trunk code already keeps track of trigger columns in SYSTRIGGERS.REFERENCEDCOLUMNS. The combination of the two will tell us exactly what columns are needed for trigger execution from the triggering table and we fetch only those columns. For the trigger tr1, that would mean column c12(which is the trigger column) and column c14(which is in the trigger action). Because of this, columns c11, c13 and c15 will not be read into memory. If one or more of those columns were LOB columns, that can result in lot of performance and memory consumption improvement. My code will convert the trigger action UPDATE table2 SET c24=oldt.c14 &lt;br/&gt;
to &lt;br/&gt;
UPDATE table2 SET c24=org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().getOldRow().getInt(2)&lt;br/&gt;
Note that oldt.c14 get referenced through it&apos;s column position is what columns are fetched and not by it&apos;s column position in the trigger table table1. In our specific eg, we are fetching column c12 and c14 and column c14 is in the 2nd position in that set. But when we make a note of the trigger action columns in SYSTRIGGERS, we want to record it by it&apos;s column position in the trigger table to know exactly what columns we are talking about. So, for our trigger eg below, SYSTRIGGERS will look as follows&lt;br/&gt;
	CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 &lt;br/&gt;
	    REFERENCING OLD AS oldt NEW AS newt&lt;br/&gt;
	    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;&lt;br/&gt;
select TRIGGERNAME, EVENT, TYPE, REFERENCEDCOLUMNS, REFCOLSTRIGGERACTION, TRIGGERDEFINITION from sys.systriggers;&lt;br/&gt;
TRIGGERNAME|EVENT|TYPE|REFERENCEDCOLUMNS|REFCOLSTRIGGERACTION|TRIGGERDEFINITION&lt;br/&gt;
--------------------------------------------------------------------------------------------&lt;br/&gt;
TR1        |U    |R   |(2)              |(4)                 |update table2 set c24=oldt.c14&lt;br/&gt;
So, the column numbers to recognize the trigger columns and trigger action columns, we use their position in triggering table. But to convert the trigger action to org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().getxxxRow().getXXX&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, for ?, we &lt;br/&gt;
need to use the relative column position in the columns actually fetched from triggering table. My apologies if this sounds confusing. In one of intermediate work on my machine, my code didn&apos;t account for this difference in column position in table vs column position in the columns &lt;br/&gt;
actually fetched, and I started getting NPE because there is no column at position 4 since we are in a need to fetch only 2 columns. This 2 different column numbering scheme makes the code little tricky to follow but if we one understands the eg above, I think then it becomes easier to understand the code. I will be happy to hear if someone has ideas on may be code this differently. &lt;/p&gt;</comment>
                            <comment id="12852719" author="mamtas" created="Fri, 2 Apr 2010 06:33:16 +0100"  >&lt;p&gt;Attaching patch, derby1482_patch2_diff.txt, which is very similar to the 1st patch except that rather than adding a new column to SYSTRIGGERS to save the trigger action columns information, it expands the functionality of ReferenceColumn implementation to include trigger action columns. This will hopefully make it easier upgrade path. The only surprise I ran into so far is that ReferenceColumn gets used by 2 more system tables namely SYSCHECKS&lt;br/&gt;
and SYSCONSTRAINTS which means we need to make sure that upgrade code works for those system tables too. Next, I will start looking at the upgrade code. I think, the upgrade work that needs to go in for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt; will be similar to what was done for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-606&quot; title=&quot;SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE fails on (very) large tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-606&quot;&gt;&lt;del&gt;DERBY-606&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
(committed with revision number 484797). I will study that patch more to see how it&apos;s logic can be used for the changes to SYSTRIGGERS.REFERENCEDCOLUMNS needed for this jira.&lt;/p&gt;</comment>
                            <comment id="12852911" author="rhillegas" created="Fri, 2 Apr 2010 19:49:18 +0100"  >&lt;p&gt;Thanks for the patch, Mamta. I have a couple comments:&lt;/p&gt;

&lt;p&gt;CreateTriggerNode:&lt;/p&gt;

&lt;p&gt;o In the comments there are several references to the columns mentioned in the REFERENCING clause. I think the meaning would be a little more clear and specific if these comments talked about the columns mentioned in the trigger action.&lt;/p&gt;

&lt;p&gt;o There are two places in bindReferencesClause() where -1s are squeezed out of arrays. This is done for triggerColsAndTriggerActionCols and triggerActionColsOnly. It seems to me that there is an opportunity here to factor this squeezing code into a helper method. That will make the code a little easier to read and maintain.&lt;/p&gt;

&lt;p&gt;o I believe that the new code (computing the columns referenced in trigger actions and optimizing the generated text) should only be performed if the database is at level 10.6 or above. I am worried that the trigger will fail if the user soft-downgrades back to 10.5. If the database is at level 10.5 or lower, then the old code should be used.&lt;/p&gt;


&lt;p&gt;TriggerDescriptor&lt;/p&gt;

&lt;p&gt;o This patch changes the serialized form of TriggerDescriptor. This is ok as long as we can convince ourselves that these objects are never persisted. These objects do live in the ConstantActions of query plans for INSERT, UPDATE, and DELETE statements. Can we convince ourselves that the compiled forms of INSERT, UPDATE, and DELETE statements never persist across soft-upgrades?&lt;/p&gt;


&lt;p&gt;ReferencedColumnDescriptorImpl&lt;/p&gt;

&lt;p&gt;o I think that readExternal() won&apos;t be able to read descriptors from soft-upgraded 10.5 databases. And writeExternal() will write descriptors which won&apos;t be readable if the user soft-downgrades to 10.5. I think that the following alternative implementations will work.&lt;/p&gt;

&lt;p&gt;	public void readExternal(ObjectInput in) throws IOException&lt;br/&gt;
	{&lt;br/&gt;
		int rcLength;&lt;br/&gt;
		int versionNumber = in.readInt();&lt;/p&gt;

&lt;p&gt;        if ( versionNumber &amp;lt; 0 ) &lt;/p&gt;
{ rcLength = in.readInt(); }
&lt;p&gt;        else &lt;/p&gt;
{ rcLength = versionNumber; }

&lt;p&gt;		referencedColumns = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;rcLength&amp;#93;&lt;/span&gt;;&lt;br/&gt;
		for (int i = 0; i &amp;lt; rcLength; i++)&lt;/p&gt;
		{
			referencedColumns[i] = in.readInt();
		}

&lt;p&gt;        if ( versionNumber &amp;lt; 0 )&lt;br/&gt;
        {&lt;br/&gt;
            int  rctaLength = in.readInt();&lt;/p&gt;

&lt;p&gt;			referencedColumnsInTriggerAction = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;rctaLength&amp;#93;&lt;/span&gt;;&lt;br/&gt;
			for (int i = 0; i &amp;lt; rctaLength; i++)&lt;/p&gt;
			{
				referencedColumnsInTriggerAction[i] = in.readInt();
			}
&lt;p&gt;        }&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;	public void writeExternal(ObjectOutput out) throws IOException&lt;br/&gt;
	{&lt;br/&gt;
        int versionNumber = referencedColumnsInTriggerAction == null ? referencedColumns.length : -1;&lt;/p&gt;

&lt;p&gt;		out.writeInt( versionNumber );&lt;/p&gt;

&lt;p&gt;        if ( versionNumber &amp;lt; 0 ) &lt;/p&gt;
{ out.writeInt( referencedColumns.length ); }

&lt;p&gt;		for (int i = 0; i &amp;lt; referencedColumns.length; i++)&lt;/p&gt;
		{
			out.writeInt(referencedColumns[i]);
		}

&lt;p&gt;        if ( versionNumber &amp;lt; 0 )&lt;br/&gt;
        {&lt;br/&gt;
			out.writeInt(referencedColumnsInTriggerAction.length);&lt;br/&gt;
			for (int i = 0; i &amp;lt; referencedColumnsInTriggerAction.length; i++)&lt;/p&gt;
			{
				out.writeInt(referencedColumnsInTriggerAction[i]);
			}
&lt;p&gt;        }&lt;/p&gt;

&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12855845" author="mamtas" created="Mon, 12 Apr 2010 06:32:21 +0100"  >&lt;p&gt;Rick, thanks for reviewing the patch and for your comments. One thing may not have been clear in my patch comments is that now, with my changes in the patch, it is possible to have referencedColumns as null but referencedColumnsInTriggerAction as not null. eg&lt;br/&gt;
     create trigger tr1 after update on t1 referencing old as oldt  for each row values(oldt.id);&lt;br/&gt;
For the trigger above, the user has not provided a list of columns whose update should fire trigger tr1. Because of that, any column update from table t1 will cause trigger tr1 to fire. But the columns referenced in trigger action through old/new transiten variables is column &quot;id&quot;. in other words, for this trigger, referencedColumns will be null but referencedColumnsInTriggerAction will not be null. The changes to readExternal and writeExternal will have to account for possibility of referencedColumns being null. Prior to my changes in the patch, if referencedColumns was null for a trigger, the entire object ReferencedColumnDescriptorImpl will be null and hence we will never get to these methods. The null case was handled by FormatIdOutputStream.writeObject(Object) with the following code&lt;br/&gt;
	public void writeObject(Object ref) throws IOException&lt;br/&gt;
	{&lt;br/&gt;
		if (ref == null)&lt;/p&gt;
		{
			FormatIdUtil.writeFormatIdInteger(this, StoredFormatIds.NULL_FORMAT_ID);
			return;
		}
&lt;p&gt;                                          .........&lt;/p&gt;

&lt;p&gt;The stack trace of such a call is as follows.&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 95 in FormatIdOutputStream))	&lt;br/&gt;
	FormatIdOutputStream.writeObject(Object) line: 95	&lt;br/&gt;
	UserType.writeExternal(ObjectOutput) line: 291	&lt;br/&gt;
	StoredPage.logColumn(Object[], int, DynamicByteArrayOutputStream, int, int, int) line: 6243	&lt;br/&gt;
	StoredPage.logRow(int, boolean, int, Object[], FormatableBitSet, DynamicByteArrayOutputStream, int, byte, int, int, int) line: 3963	&lt;br/&gt;
	InsertOperation.writeOptionalDataToBuffer(RawTransaction, DynamicByteArrayOutputStream, Object[], FormatableBitSet, boolean, int, int, int) line: 370	&lt;br/&gt;
	InsertOperation.&amp;lt;init&amp;gt;(RawTransaction, BasePage, int, int, Object[], FormatableBitSet, LogicalUndo, byte, int, boolean, int, DynamicByteArrayOutputStream, int, int) line: 115	&lt;br/&gt;
	LoggableActions.actionInsert(RawTransaction, BasePage, int, int, Object[], FormatableBitSet, LogicalUndo, byte, int, boolean, int, DynamicByteArrayOutputStream, int, int) line: 139	&lt;br/&gt;
	StoredPage(BasePage).insertNoOverflow(int, Object[], FormatableBitSet, LogicalUndo, byte, int) line: 602	&lt;br/&gt;
	StoredPage(BasePage).insertAtSlot(int, Object[], FormatableBitSet, LogicalUndo, byte, int) line: 523	&lt;br/&gt;
	StoredPage.insertAtSlot(int, Object[], FormatableBitSet, LogicalUndo, byte, int) line: 6723	&lt;br/&gt;
	StoredPage(BasePage).insert(Object[], FormatableBitSet, byte, int) line: 629	&lt;br/&gt;
	HeapController.doInsert(DataValueDescriptor[]) line: 288	&lt;br/&gt;
	HeapController.insertAndFetchLocation(DataValueDescriptor[], RowLocation) line: 599	&lt;br/&gt;
	TabInfoImpl.insertRowListImpl(ExecRow[], TransactionController, RowLocation[]) line: 511	&lt;br/&gt;
	TabInfoImpl.insertRow(ExecRow, TransactionController) line: 420	&lt;br/&gt;
	DataDictionaryImpl.addDescriptor(TupleDescriptor, TupleDescriptor, int, boolean, TransactionController) line: 1824	&lt;br/&gt;
	CreateTriggerConstantAction.executeConstantAction(Activation) line: 321	&lt;br/&gt;
	MiscResultSet.open() line: 61	&lt;br/&gt;
	GenericPreparedStatement.executeStmt(Activation, boolean, long) line: 436	&lt;br/&gt;
	GenericPreparedStatement.execute(Activation, long) line: 317	&lt;br/&gt;
	EmbedStatement.executeStatement(Activation, boolean, boolean) line: 1232	&lt;br/&gt;
	EmbedStatement.execute(String, boolean, boolean, int, int[], String[]) line: 625	&lt;br/&gt;
	EmbedStatement.execute(String) line: 555	&lt;br/&gt;
	ij.executeImmediate(String) line: 367	&lt;br/&gt;
	utilMain.doCatch(String) line: 521	&lt;br/&gt;
	utilMain.runScriptGuts() line: 363	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput) line: 261	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput) line: 229	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 184	&lt;br/&gt;
	Main.main(String[]) line: 75	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;
</comment>
                            <comment id="12855852" author="mamtas" created="Mon, 12 Apr 2010 07:19:42 +0100"  >&lt;p&gt;I will post by tomorrow what I think the changed readExternal and writeExternal should look like(taking into account the fact that referencedColumns can be null and the fact that we could be dealing with pre-10.6 database as part of soft-upgrade). Rick and others, I would greatly appreciate if you will take a look at that code once I have it up in the jira.&lt;/p&gt;</comment>
                            <comment id="12856168" author="mamtas" created="Mon, 12 Apr 2010 21:58:30 +0100"  >&lt;p&gt;Based on the fact that with the patch, it is possible to have referencedColumns null, I think readExternal and writeExternal should look like following (this should make sure that we read the pre-10.6 dbs in soft upgrade mode correctly and write the new descriptors correctly provided that as suggested by Rick, in CreateTriggerNode, we use the new code only if the db is at &amp;gt;10.5 level)&lt;/p&gt;

&lt;p&gt;I will add following class comment to ReferencedColumnsDescriptorImpl &lt;br/&gt;
/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;For triggers, ReferencedColumnsDescriptorImpl object has 3 possibilites&lt;/li&gt;
	&lt;li&gt;1)referencedColumns is not null but referencedColumnsInTriggerAction&lt;/li&gt;
	&lt;li&gt;is null - meaning the trigger is defined on specific columns but trigger&lt;/li&gt;
	&lt;li&gt;action does not reference any column through old/new transient variables.&lt;/li&gt;
	&lt;li&gt;Another reason for referencedColumnsInTriggerAction to be null(even though&lt;/li&gt;
	&lt;li&gt;trigger action does reference columns though old/new transient variables&lt;/li&gt;
	&lt;li&gt;would be that we are in soft-upgrade mode for pre-10.6 databases and&lt;/li&gt;
	&lt;li&gt;hence we do not want to write anything about&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction for backward compatibility (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt;).&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 for each row values(1);&lt;/li&gt;
	&lt;li&gt;2)referencedColumns is null but referencedColumnsInTriggerAction is not null&lt;/li&gt;
	&lt;li&gt;- meaning the trigger is not defined on specific columns but trigger&lt;/li&gt;
	&lt;li&gt;action references column through old/new transient variables&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;/li&gt;
	&lt;li&gt;3)referencedColumns and referencedColumnsInTriggerAction are not null -&lt;/li&gt;
	&lt;li&gt;meaning the trigger is defined on specific columns and trigger action&lt;/li&gt;
	&lt;li&gt;references column through old/new transient variables&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;For triggers, 3 possible scenarios&lt;/li&gt;
	&lt;li&gt;1)referencedColumns is not null but referencedColumnsInTriggerAction&lt;/li&gt;
	&lt;li&gt;is null - then following will get read&lt;/li&gt;
	&lt;li&gt;referencedColumns.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumns arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 for each row values(1);&lt;/li&gt;
	&lt;li&gt;2)referencedColumns is null but referencedColumnsInTriggerAction is not&lt;/li&gt;
	&lt;li&gt;null - then following will get read&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumnsInTriggerAction arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;/li&gt;
	&lt;li&gt;3)referencedColumns and referencedColumnsInTriggerAction are not null -&lt;/li&gt;
	&lt;li&gt;then following will get read&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;referencedColumns.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumns arrary&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumnsInTriggerAction arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;br/&gt;
	 */&lt;br/&gt;
	public void readExternal(ObjectInput in) throws IOException &lt;br/&gt;
	{&lt;br/&gt;
	        int rcLength; &lt;br/&gt;
	        int versionNumber = in.readInt(); &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	        if ( versionNumber &amp;lt; 0 ) { &lt;br/&gt;
	           //A negative value for versionNumber means that this trigger action&lt;br/&gt;
	           //references columns through old/new transient variables. Now, check&lt;br/&gt;
	           //if trigger has been defined on selected columns&lt;br/&gt;
	            rcLength = in.readInt(); &lt;br/&gt;
	            if ( rcLength &amp;lt; 0 ) &lt;/p&gt;
{ //trigger is not defined on selected columns
	                rcLength = 0;
	            }
&lt;p&gt; else&lt;br/&gt;
	                referencedColumns = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;rcLength&amp;#93;&lt;/span&gt;; &lt;br/&gt;
	        } else &lt;/p&gt;
{ //this trigger only has trigger columns saved on the disc
	            rcLength = versionNumber; 
	            referencedColumns = new int[rcLength]; 
	        }
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;	        for (int i = 0; i &amp;lt; rcLength; i++) &lt;/p&gt;
	        { 
	            //if we are in this loop, then it means that this trigger has been
	            //defined on specific columns. Read in information about those columns
	            referencedColumns[i] = in.readInt(); 
	        } 

&lt;p&gt;	        if ( versionNumber &amp;lt; 0 ) &lt;br/&gt;
	        { &lt;br/&gt;
	           //As mentioned earlier, a negative value for versionNumber means that &lt;br/&gt;
	           //this trigger action references columns through old/new transient variables. &lt;br/&gt;
	           //Read information about those columns into referencedColumnsInTriggerAction&lt;br/&gt;
	            int rctaLength = in.readInt(); &lt;/p&gt;

&lt;p&gt;	            referencedColumnsInTriggerAction = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;rctaLength&amp;#93;&lt;/span&gt;; &lt;br/&gt;
	            for (int i = 0; i &amp;lt; rctaLength; i++) &lt;/p&gt;
	            { 
	                referencedColumnsInTriggerAction[i] = in.readInt(); 
	            } 
&lt;p&gt;	        } &lt;br/&gt;
	} &lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;For triggers, 3 possible scenarios&lt;/li&gt;
	&lt;li&gt;1)referencedColumns is not null but referencedColumnsInTriggerAction&lt;/li&gt;
	&lt;li&gt;is null - then following gets written&lt;/li&gt;
	&lt;li&gt;referencedColumns.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumns arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 for each row values(1);&lt;/li&gt;
	&lt;li&gt;2)referencedColumns is null but referencedColumnsInTriggerAction is not&lt;/li&gt;
	&lt;li&gt;null - then following gets written&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumnsInTriggerAction arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;/li&gt;
	&lt;li&gt;3)referencedColumns and referencedColumnsInTriggerAction are not null -&lt;/li&gt;
	&lt;li&gt;then following gets written&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;referencedColumns.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumns arrary&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumnsInTriggerAction arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;br/&gt;
	 */&lt;br/&gt;
	public void writeExternal(ObjectOutput out) throws IOException &lt;br/&gt;
	{ &lt;br/&gt;
	        //A null value for referencedColumnsInTriggerAction means one of 2 cases&lt;br/&gt;
	        //1)We are working in soft-upgrade mode dealing with databases lower than 10.6&lt;br/&gt;
	        //  Prior to 10.6 release, we did not keep track of trigger action columns&lt;br/&gt;
	        //2)We are working with &amp;gt;10.5 release database and the trigger action does not &lt;br/&gt;
	        //  reference any column through old/new transient variables&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	        //versionNumber will be -1 if referencedColumnsInTriggerAction is not null,&lt;br/&gt;
	        //meaning, we are dealing with &amp;gt;10.5 release database and the trigger has referenced&lt;br/&gt;
	        //columns in trigger action through old/new transient variables.&lt;br/&gt;
	        //Otherwise, versionNumber will be the length of the arrary referencedColumns. This&lt;br/&gt;
	        //arrary holds the columns on which trigger is defined. The detailed meaning of&lt;br/&gt;
	        //these 2 arrays is described at the class level comments(towards the beginning of&lt;br/&gt;
	        //this class.&lt;br/&gt;
	        int versionNumber = referencedColumnsInTriggerAction == null ? referencedColumns.length : -1; &lt;/p&gt;

&lt;p&gt;	        out.writeInt( versionNumber ); &lt;/p&gt;

&lt;p&gt;	        if ( versionNumber &amp;lt; 0 ) { &lt;br/&gt;
	        	//If we are here, then it means that trigger action references &lt;br/&gt;
	        	//columns through old/new transient variables. &lt;br/&gt;
	        	//First we will check if there are any trigger columns selected&lt;br/&gt;
	        	//for this trigger. If yes, we will write information about &lt;br/&gt;
	        	//trigger columns and if not, then we will write -1 to indicate &lt;br/&gt;
	        	//that there are no trigger columns selected.&lt;br/&gt;
	        	//After that, we will write info about trigger action columns.&lt;br/&gt;
	            if ( referencedColumns != null ) &lt;/p&gt;
{ 
	            	writeReferencedColumns(out);
	            }
&lt;p&gt; else&lt;br/&gt;
	                out.writeInt(versionNumber);&lt;br/&gt;
	            //Write info about trigger action columns referenced through &lt;br/&gt;
	            //old/new transient variables&lt;br/&gt;
	            out.writeInt(referencedColumnsInTriggerAction.length); &lt;br/&gt;
	            for (int i = 0; i &amp;lt; referencedColumnsInTriggerAction.length; i++) &lt;/p&gt;
	            { 
	                out.writeInt(referencedColumnsInTriggerAction[i]); 
	            } 
&lt;p&gt;	        } else &lt;/p&gt;
{
	        	//If we are here, then it means there are no references in 
	        	//trigger action to old/new transient variables. But, three are
	        	//trigger columns selected for this trigger. Write info about 
	        	//trigger columns
	        	writeReferencedColumns(out);
	        }
&lt;p&gt;	         &lt;br/&gt;
	} &lt;/p&gt;

&lt;p&gt;	private void writeReferencedColumns(ObjectOutput out) throws IOException &lt;br/&gt;
	{ &lt;br/&gt;
    	    //trigger is defined on select columns. Write info about trigger columns&lt;br/&gt;
    	    out.writeInt( referencedColumns.length ); &lt;br/&gt;
    	    for (int i = 0; i &amp;lt; referencedColumns.length; i++) &lt;/p&gt;
    	    { 
    	        out.writeInt(referencedColumns[i]); 
    	    } 
&lt;p&gt;	}&lt;/p&gt;
</comment>
                            <comment id="12856200" author="mikem" created="Mon, 12 Apr 2010 23:03:29 +0100"  >&lt;p&gt;i like the approach rick has suggested, it makes the upgrade a lot easier and avoids the need to have new format id&apos;s.  The first int becomes a &quot;version&quot; of the data structure.  As a way to incrementally implement this I suggest you first get soft upgrade to work, and then just get new triggers to work, and finally if necessary worry about hard upgrading the old triggers to new trigger data structure.&lt;/p&gt;

&lt;p&gt;I think you can handle it all just in the read and write external routines, if you code your in memory datastructures right.  What looks missing is that even if your in memory data structure has extra reference column information, you should test for soft upgrade in the write external method and not write that information out.  &lt;/p&gt;</comment>
                            <comment id="12857516" author="mamtas" created="Thu, 15 Apr 2010 21:02:14 +0100"  >&lt;p&gt;I was under the impression that I would need a new format id but since the code changes in 10.6 will still be able to read the old ReferencedColumnsDescriptor there is not a need for new format id. I have removed my format id changes from my codeline (before removing those changes, I was constantly getting no class implementation found for format id). But there is a bug in the writeExternal that I posted above. In the case of missing trigger action column references, my code was incorrectly writing the length of trigger columns twice. I have fixed that problem. The new writeExternal will look like following&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;For triggers, 3 possible scenarios&lt;/li&gt;
	&lt;li&gt;1)referencedColumns is not null but referencedColumnsInTriggerAction&lt;/li&gt;
	&lt;li&gt;is null - then following gets written&lt;/li&gt;
	&lt;li&gt;referencedColumns.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumns arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 for each row values(1);&lt;/li&gt;
	&lt;li&gt;2)referencedColumns is null but referencedColumnsInTriggerAction is not&lt;/li&gt;
	&lt;li&gt;null - then following gets written&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumnsInTriggerAction arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;/li&gt;
	&lt;li&gt;3)referencedColumns and referencedColumnsInTriggerAction are not null -&lt;/li&gt;
	&lt;li&gt;then following gets written&lt;/li&gt;
	&lt;li&gt;-1&lt;/li&gt;
	&lt;li&gt;referencedColumns.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumns arrary&lt;/li&gt;
	&lt;li&gt;referencedColumnsInTriggerAction.length&lt;/li&gt;
	&lt;li&gt;individual elements from referencedColumnsInTriggerAction arrary&lt;/li&gt;
	&lt;li&gt;eg create trigger tr1 after update of c1 on t1 referencing old as oldt&lt;/li&gt;
	&lt;li&gt;for each row values(oldt.id);&lt;br/&gt;
	 */&lt;br/&gt;
	public void writeExternal(ObjectOutput out) throws IOException &lt;br/&gt;
	{ &lt;br/&gt;
	        //A null value for referencedColumnsInTriggerAction means one of 2 cases&lt;br/&gt;
	        //1)We are working in soft-upgrade mode dealing with databases lower than 10.6&lt;br/&gt;
	        //  Prior to 10.6 release, we did not keep track of trigger action columns&lt;br/&gt;
	        //2)We are working with &amp;gt;10.5 release database and the trigger action does not &lt;br/&gt;
	        //  reference any column through old/new transient variables&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	        //versionNumber will be -1 if referencedColumnsInTriggerAction is not null,&lt;br/&gt;
	        //meaning, we are dealing with &amp;gt;10.5 release database and the trigger has referenced&lt;br/&gt;
	        //columns in trigger action through old/new transient variables.&lt;br/&gt;
	        //Otherwise, versionNumber will be the length of the arrary referencedColumns. This&lt;br/&gt;
	        //arrary holds the columns on which trigger is defined. The detailed meaning of&lt;br/&gt;
	        //these 2 arrays is described at the class level comments(towards the beginning of&lt;br/&gt;
	        //this class.&lt;br/&gt;
	        int versionNumber = referencedColumnsInTriggerAction == null ? referencedColumns.length : -1; &lt;/p&gt;

&lt;p&gt;	        if ( versionNumber &amp;lt; 0 ) { &lt;br/&gt;
		        out.writeInt( versionNumber ); &lt;br/&gt;
	        	//If we are here, then it means that trigger action references &lt;br/&gt;
	        	//columns through old/new transient variables. &lt;br/&gt;
	        	//First we will check if there are any trigger columns selected&lt;br/&gt;
	        	//for this trigger. If yes, we will write information about &lt;br/&gt;
	        	//trigger columns and if not, then we will write -1 to indicate &lt;br/&gt;
	        	//that there are no trigger columns selected.&lt;br/&gt;
	        	//After that, we will write info about trigger action columns.&lt;br/&gt;
	            if ( referencedColumns != null ) &lt;/p&gt;
{ 
	            	writeReferencedColumns(out);
	            }
&lt;p&gt; else &lt;/p&gt;
{
	                out.writeInt(versionNumber);
	            }
&lt;p&gt;	            //Write info about trigger action columns referenced through &lt;br/&gt;
	            //old/new transient variables&lt;br/&gt;
	            out.writeInt(referencedColumnsInTriggerAction.length); &lt;br/&gt;
	            for (int i = 0; i &amp;lt; referencedColumnsInTriggerAction.length; i++) &lt;/p&gt;
	            { 
	                out.writeInt(referencedColumnsInTriggerAction[i]); 
	            } 
&lt;p&gt;	        } else &lt;/p&gt;
{
	        	//If we are here, then it means there are no references in 
	        	//trigger action to old/new transient variables. But, three are
	        	//trigger columns selected for this trigger. Write info about 
	        	//trigger columns
            	writeReferencedColumns(out);
	        }
&lt;p&gt;	         &lt;br/&gt;
	} &lt;br/&gt;
	private void writeReferencedColumns(ObjectOutput out) throws IOException &lt;br/&gt;
	{ &lt;br/&gt;
    	//trigger is defined on select columns. Write info about trigger columns&lt;br/&gt;
        out.writeInt( referencedColumns.length ); &lt;br/&gt;
        for (int i = 0; i &amp;lt; referencedColumns.length; i++) &lt;/p&gt;
        { 
            out.writeInt(referencedColumns[i]); 
        } 
&lt;p&gt;	}&lt;/p&gt;</comment>
                            <comment id="12857518" author="mamtas" created="Thu, 15 Apr 2010 21:04:02 +0100"  >&lt;p&gt;I have next started looking at how soft upgrade should be handled.&lt;/p&gt;</comment>
                            <comment id="12857938" author="mamtas" created="Fri, 16 Apr 2010 20:13:05 +0100"  >&lt;p&gt;Mike you suggested that we check if we are in soft upgrade mode inside writeExternal or readExternal methods but I think to find if we are in soft upgrade mode we need access to LanguageConnectionContext(I don&apos;t have the exact call but it probably looks something similar to following). &lt;br/&gt;
getLanguageConnectionContext().getDataDictionary().checkVersion(DataDictionary.DD_VERSION_CURRENT,null);&lt;br/&gt;
To my knowledge, readExternal and writeExternal methods do not have access to LanguageConnectionContext and DataDictionary objects.&lt;/p&gt;

&lt;p&gt;Before going further into how we might detect if we are in soft upgrade mode inside those methods, I want to go over what different possibilites we need to handle to make sure that I haven&apos;t missed anything.&lt;/p&gt;

&lt;p&gt;When dealing with any trigger, we can have following possible scenarios&lt;br/&gt;
	a)trigger is getting created in newly created 10.6 db&lt;br/&gt;
	b)trigger already created in the pre-10.6db before soft upgrade&lt;br/&gt;
	c)trigger is getting created while in soft upgrad mode with pre-10.6 db&lt;br/&gt;
	d)trigger already created in the pre-10.6db before hard upgrade&lt;br/&gt;
	e)trigger is getting created after pre-10.6db is hard upgraded&lt;/p&gt;

&lt;p&gt;Now let&apos;s let specific trigger scenarios for above db levels&lt;br/&gt;
1) create trigger tr1 after update on t1 for each row values(1); &lt;br/&gt;
        Same for all 5 levels of db listed above. Nothing gets written in ReferencedColumnsDescriptorImpl.writeExternal. Instead, FormatIdOutputStream.writeObject writes StoredFormatIds.NULL_FORMAT_ID to indicate that ReferencedColumnsDescriptorImpl object is null.&lt;/p&gt;

&lt;p&gt;2) create trigger tr1 after update of c1 on t1 for each row values(1); &lt;br/&gt;
        Same for all 5 levels of db listed above. ReferencedColumnsDescriptorImpl.writeExternal will write following&lt;br/&gt;
		referencedColumns.length&lt;br/&gt;
		referencedColumns elements column positions&lt;/p&gt;

&lt;p&gt;3) create trigger tr1 after update of c1 on t1 referencing old as oldt for each row values(oldt.id); &lt;br/&gt;
        different for the 5 possible scenarios descibed above&lt;br/&gt;
	a)10.6 - ReferencedColumnsDescriptorImpl.writeExternal will write following&lt;br/&gt;
		-1 &lt;br/&gt;
		referencedColumns.length&lt;br/&gt;
		referencedColumns elements column positions&lt;br/&gt;
		referencedColumnsInTriggerAction.length&lt;br/&gt;
		referencedColumnsInTriggerAction elements column positions&lt;/p&gt;

&lt;p&gt;	b)trigger already created in the pre-10.6db before soft upgrade - We will find following &lt;br/&gt;
		referencedColumns.length&lt;br/&gt;
		referencedColumns elements column positions&lt;/p&gt;

&lt;p&gt;	c)trigger is getting created while in soft upgrad mode with pre-10.6 db - I need to make changes in CreateTriggerNode  to detect that we are in soft upgrade mode and hence do not collect information about trigger action columns. With those changes, we will write following in ReferencedColumnsDescriptorImpl.writeExternal &lt;br/&gt;
		referencedColumns.length&lt;br/&gt;
		referencedColumns elements column positions&lt;/p&gt;

&lt;p&gt;	d)trigger already created in the pre-10.6db before hard upgrade - We will find following (unless during hard upgrade we find a way to recompile all the triggers so proper information gets created for them)&lt;br/&gt;
		referencedColumns.length&lt;br/&gt;
		referencedColumns elements column positions&lt;/p&gt;

&lt;p&gt;	e)trigger is getting created after pre-10.6db is hard upgraded - ReferencedColumnsDescriptorImpl.writeExternal &lt;br/&gt;
	  will write following&lt;br/&gt;
		-1 &lt;br/&gt;
		referencedColumns.length&lt;br/&gt;
		referencedColumns elements column positions&lt;br/&gt;
		referencedColumnsInTriggerAction.length&lt;br/&gt;
		referencedColumnsInTriggerAction elements column positions&lt;/p&gt;

&lt;p&gt;4) create trigger tr1 after update on t1 referencing old as oldt for each row values(oldt.id); &lt;br/&gt;
        different for the 5 possible scenarios descibed above&lt;br/&gt;
	a)10.6 - ReferencedColumnsDescriptorImpl.writeExternal will write following&lt;br/&gt;
		-1 &lt;br/&gt;
		-1 &lt;br/&gt;
		referencedColumnsInTriggerAction.length&lt;br/&gt;
		referencedColumnsInTriggerAction elements column positions&lt;/p&gt;

&lt;p&gt;	b)trigger already created in the pre-10.6db before soft upgrade - Nothing gets written in ReferencedColumnsDescriptorImpl.writeExternal. Instead, FormatIdOutputStream.writeObject writes StoredFormatIds.NULL_FORMAT_ID to indicate that ReferencedColumnsDescriptorImpl object is null.&lt;/p&gt;

&lt;p&gt;	c)trigger is getting created while in soft upgrad mode with pre-10.6 db - I need to make changes in CreateTriggerNode to detect that we are in soft upgrade mode and hence do not collect information about trigger action columns. With those changes, ReferencedColumnsDescriptorImpl will end up becoming null and we will write StoredFormatIds.NULL_FORMAT_ID in FormatIdOutputStream.writeObject.&lt;/p&gt;

&lt;p&gt;	d)trigger already created in the pre-10.6db before hard upgrade - - Nothing gets written in (unless during hard upgrade we find a way to recompile all the triggers so proper information gets created for them) ReferencedColumnsDescriptorImpl.writeExternal. Instead, FormatIdOutputStream.writeObject writes StoredFormatIds.NULL_FORMAT_ID to indicate that ReferencedColumnsDescriptorImpl object is null.&lt;/p&gt;

&lt;p&gt;	e)trigger is getting created after pre-10.6db is hard upgraded - ReferencedColumnsDescriptorImpl.writeExternal &lt;br/&gt;
	  will write following&lt;br/&gt;
		-1 &lt;br/&gt;
		-1 &lt;br/&gt;
		referencedColumnsInTriggerAction.length&lt;br/&gt;
		referencedColumnsInTriggerAction elements column positions&lt;/p&gt;

&lt;p&gt;My changes will decide on what columns to read from the trigger table based on this saved information. Which means for cases 3b), 3c), 3d), 4b), 4c) and 4d), we will incorrectly not read columns involved in trigger action thus causing problems. &lt;/p&gt;

&lt;p&gt;For soft upgrade problem scenarios, 3b), 3c), 4b) and 4c), we can probably check that if we are in soft upgrade mode and if there are triggers involved, then read all the columns from the trigger table (just like what gets done today in the trunk and prior releases), no matter if they are all needed or not. This logic though will also require us to read all the columns from trigger table for case 2) above in soft upgrade mode. So, basically, we will read more columns that probably needed but nothing will be broken. Also, we do not anticipate users doing ton of work while in soft-upgrade mode.&lt;/p&gt;

&lt;p&gt;But that still leaves issues with hard upgrade scenarios 3d) and 4d). One way to resolve the problems with 3d) and 4d) would be that during hard upgrade, find a way to recompile all the triggers so proper information gets created for them. &lt;/p&gt;</comment>
                            <comment id="12857951" author="rhillegas" created="Fri, 16 Apr 2010 20:44:40 +0100"  >&lt;p&gt;I recommend that the (de)serialization logic not depend on context outside the object. That is because, with 10.6, objects can be serialized across the network and sent to clients for retrieval via ResultSet.getObject(). Serialization across the network is supposed to work if both the client and the server are 10.6 code. Bad things will happen if the client tries to deserialize one of these objects and can&apos;t find a LanguageConnectionContext.&lt;/p&gt;

&lt;p&gt;It ought to be possible to design serialization so that it is completely self-contained.&lt;/p&gt;</comment>
                            <comment id="12858389" author="mamtas" created="Mon, 19 Apr 2010 07:03:40 +0100"  >&lt;p&gt;I need to do little more experimentation but I think, after all,  case 4 create trigger tr1 after update on t1 referencing old as oldt for each row values(oldt.id); might not be an issue because if no trigger columns are found, Derby decides to read all the columns no matter what columns are referenced in trigger action through old/new transition variable (this happens in impl.sql.compile.UpdateNod.getUpdateReadMap()) and hence even though different things get written for the 5 levels discussed below for case 4, we might be ok. Will post soon after I have done some more testing for case 4)&lt;/p&gt;</comment>
                            <comment id="12858671" author="mamtas" created="Mon, 19 Apr 2010 21:35:07 +0100"  >&lt;p&gt;I ran the tests for trigger where there are no trigger columns specified but there are columns referenced in trigger action through old/new transition variables which is the case 4) above and we should not run into any issues with that scenario because Derby decides to read all the columns from the trigger table if there are not trigger columns specified for it. So, no matter which one of the following scenario has been used to create the trigger, of kind 4) case 10.6 code will work fine since Derby is going to read all the columns create trigger tr1 after update on t1 referencing old as oldt for each row values(oldt.id); &lt;br/&gt;
a)trigger is getting created in newly created 10.6 db &lt;br/&gt;
b)trigger already created in the pre-10.6db before soft upgrade &lt;br/&gt;
c)trigger is getting created while in soft upgrad mode with pre-10.6 db &lt;br/&gt;
d)trigger already created in the pre-10.6db before hard upgrade &lt;br/&gt;
e)trigger is getting created after pre-10.6db is hard upgraded &lt;/p&gt;


&lt;p&gt;So, the only issue we need to worry about is case 3), which is create trigger tr1 after update of c1 on t1 referencing old as oldt for each row values(oldt.id); &lt;/p&gt;

&lt;p&gt;I think we can solve the soft-upgrade problems by just having Derby read all the columns no matter what(or none) trigger columns are specified. I think it is an acceptable solution because user probably would not be running their databases in soft-upgrade mode for a long time. Let me know what your thoughts might be.&lt;/p&gt;

&lt;p&gt;The only issue left then is 3d), triggers which were created prior to 10.6 and that database has been hard-upgrade. In such hard upgraded databases, we will run into not running enough columns for trigger case 3)create trigger tr1 after update of c1 on t1 referencing old as oldt for each row values(oldt.id); One way to resolve such trigger cases would be at upgrade time, invalidate the trigger so that get recompiled before they are used next in the hard-upgraded database. &lt;/p&gt;

&lt;p&gt;Any thoughts/feedback greatly appreciated.&lt;/p&gt;</comment>
                            <comment id="12858704" author="mikem" created="Mon, 19 Apr 2010 23:15:16 +0100"  >&lt;p&gt;ReadExternal should never need to access anything about &quot;soft/hard upgrade&quot;.  The state of the object is defined by whatever it is reading from disk.  How to build the object is all determined by the first int you read from disk.  &lt;/p&gt;

&lt;p&gt;After thinking about it I agree there should not be &quot;soft/hard upgrade&quot; references in the writeExternal.  Somehow the object itself should know whether it should write the old or&lt;br/&gt;
new format out.  I think you may be describing some tricky ways to do this.  I think if I were&lt;br/&gt;
doing this I would just add a new field to the object, something like version_id.  If version_id = 0 then write old format, if version_id=1 then write new version.  Read external will need to change to set this appropriately.  And the code that is called by create trigger will also need to change to set this correctly based on database version, this probably is in the constructor somewhere.&lt;/p&gt;

&lt;p&gt;Do add more comments to the read and write external describing better the old and new formats.  What you are proposing is a little tricky, so best to have some block of code that describes &quot;version 0&quot; format and &quot;version 1&quot; format.  &lt;/p&gt;

&lt;p&gt;If you get this right from bottom up then I think all the hard/soft upgrade stuff will just work correctly.  I would leave how you get the old format converted to new format as a &lt;br/&gt;
last step, as you need to make sure old format in new db&apos;s yields correct results (while maybe not optimized results).  &lt;/p&gt;</comment>
                            <comment id="12872309" author="mamtas" created="Thu, 27 May 2010 19:08:24 +0100"  >&lt;p&gt;Rick, I will post the patch soon for this jira. Thanks for your comments on earlier patch. I have taken care of all of them except 2.&lt;/p&gt;

&lt;p&gt;One of the comment was as follows&lt;br/&gt;
***************************************************************&lt;br/&gt;
CreateTriggerNode: &lt;br/&gt;
o In the comments there are several references to the columns mentioned in the REFERENCING clause. I think the meaning would be a little more clear and specific if these comments talked about the columns mentioned in the trigger action. &lt;/p&gt;

&lt;p&gt;The reason I am not directly using trigger action columns is because this deals only the trigger action columns available through the REFERENCING clause. It does not include the columns from the objects in the trigger action. To differentiate between these 2 different types of column possibilites in trigger action, I think it is better to say columns available through REFERNCING clause. I may be mistaken. Would like to know if you agree with my reasoning.&lt;br/&gt;
***************************************************************&lt;/p&gt;


&lt;p&gt;The second comment was as follows&lt;br/&gt;
***************************************************************&lt;br/&gt;
o This patch changes the serialized form of TriggerDescriptor. This is ok as long as we can convince ourselves that these objects are never persisted. These objects do live in the ConstantActions of query plans for INSERT, UPDATE, and DELETE statements. Can we convince ourselves that the compiled forms of INSERT, UPDATE, and DELETE statements never persist across soft-upgrades? &lt;/p&gt;

&lt;p&gt;I don&apos;t completely comprehend this comment. When working with pre-10.7 dbs, my changes will not generate any information about trigger action columns available through REFERENCING clause, thus marking referencedColsInTriggerAction in TriggerDescriptor null. But I do have new changes in TriggerDescriptor&apos;s readExternal and writeExternal. &lt;br/&gt;
WriteExternal will write 0 if trigger action columns are null&lt;br/&gt;
		if (referencedColsInTriggerAction == null)&lt;/p&gt;
		{
			out.writeInt(0);
		}
&lt;p&gt;		else&lt;br/&gt;
		{ ... write about trigger action columns&lt;/p&gt;

&lt;p&gt;ReadExternal will check if there is a 0 for trigger action columns and if not found, will read trigger action columns info&lt;br/&gt;
		length = in.readInt();&lt;br/&gt;
		if (length != 0)&lt;br/&gt;
		{&lt;br/&gt;
			referencedColsInTriggerAction = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
			for (int i = 0; i &amp;lt; length; i++)&lt;/p&gt;
			{
				referencedColsInTriggerAction[i] = in.readInt();
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;May be I should check if I am dealing with pre-10.7 dbs, then I should not write 0 for trigger action columns and do the reverse for readExternal, meaning if dealing with pre-10.7dbs, do not look for any information about trigger action columns. Is that what you were bringing up in your comment? Thanks&lt;br/&gt;
***************************************************************&lt;/p&gt;</comment>
                            <comment id="12872333" author="rhillegas" created="Thu, 27 May 2010 20:26:40 +0100"  >&lt;p&gt;Hi Mamta,&lt;/p&gt;

&lt;p&gt;Concerning the first comment, let&apos;s just wait for the new patch. If the comments still puzzle me, I&apos;ll let you know.&lt;/p&gt;

&lt;p&gt;Concerning the second comment: If the new serialized form is only used in new databases and hard-upgraded databases, then there should be no problem. There should be no problem if new trigger descriptors in soft-upgraded databases have the same serialized form as 10.6 trigger descriptors. This is the situation you want to avoid:&lt;/p&gt;

&lt;p&gt;1) You create a new trigger in a soft-upgraded database.&lt;/p&gt;

&lt;p&gt;2) Then you soft-downgrade to 10.6.&lt;/p&gt;

&lt;p&gt;3) Because the serialized form has changed, the 10.6 server raises a deserialization error (or worse) every time the new trigger fires.&lt;/p&gt;

&lt;p&gt;Note that, because this patch didn&apos;t make it into 10.6, there is now another serialization issue which we have to deal with:&lt;/p&gt;

&lt;p&gt;In 10.5 and earlier, the objects stored in system tables were converted into strings when they were selected by clients. That is, a 10.5 or earlier server returned ReferencedColumnDescriptorImpl.toString() for the following query:&lt;/p&gt;

&lt;p&gt;   select referencedcolumns from sys.systriggers&lt;/p&gt;

&lt;p&gt;In 10.6, the above query uses the writeExternal()/readExternal() machinery to send the ReferencedColumnDescriptor object if both the client and the server are at 10.6 or higher. That query will choke a 10.6 client when it hits a trigger with a referencing clause that is created in a 10.7 database. For this sort of problem, the Formatable machinery calls for introducing a new formatable id. In the end, this may make your serialization logic easier to read but it may not improve the situation for 10.6 clients. I think that the following will work:&lt;/p&gt;

&lt;p&gt;Introduce a new subclass of ReferencedColumnDescriptorImpl called ReferencedColumnDescriptorImpl_7_0. That class will have its own formatable id and will serialize itself differently than the old ReferencedColumnDescriptorImpl. If one of these new classes is sent to a 10.6 client, then you will get an error looking up the formatable id. I don&apos;t know if that error will be any better or worse. We may want to add a release note saying that we don&apos;t handle this edge case gracefully.&lt;/p&gt;


&lt;p&gt;Hope this answers your questions.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12872348" author="mamtas" created="Thu, 27 May 2010 21:20:50 +0100"  >&lt;p&gt;Attaching patch derby1482_patch3_diff.txt which along with the core work also takes care of upgrade. Please share your comments on the patch.&lt;/p&gt;

&lt;p&gt;Here are the patch comments&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt; will improve on Derby&apos;s behavior about which columns should be read in when a trigger fires. The current behavior of Derby reads all the columns from the trigger table whether or not all the columns are needed for trigger execution. This can be troublesome when the trigger table has large data LOB columns causing Derby to run out of memory. With this patch, Derby will narrow down cases where it should be sufficient to read only a subset of columns from the trigger table.&lt;br/&gt;
eg of such a trigger would be the trigger below which has both trigger columns and trigger action columns through old/new transition variables&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON t1&lt;/li&gt;
	&lt;li&gt;REFERENCING OLD AS oldt NEW AS newt&lt;/li&gt;
	&lt;li&gt;FOR EACH ROW UPDATE t2 SET c24=oldt.j;&lt;br/&gt;
For a trigger like above, Derby knows exactly which columns are needed from the trigger table during trigger execution. A note of those columns to read will be made in SYSTRIGGERS table.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The general rules for what columns will be read in during a trigger execution will be as follows&lt;br/&gt;
Rule1)If trigger column information is null, then Derby will read all the columns from trigger table into memory irrespective of whether there is any trigger action column information. eg triggers&lt;br/&gt;
            create trigger tr1 after update on t1 for each row values(1); &lt;br/&gt;
            create trigger tr1 after update on t1 referencing old as oldt for each row insert into t2 values(2,oldt.j,-2); &lt;/p&gt;

&lt;p&gt;Rule2)If trigger column information is available but no trigger action column information is found and no REFERENCES clause is used for the trigger, then read all the columns identified by the trigger column. eg trigger&lt;br/&gt;
            create trigger tr1 after update of c1 on t1 for each row values(1); &lt;/p&gt;

&lt;p&gt;Rule3)If trigger column information and trigger action column information both are not null, then only those columns will be read into memory. This will be a trigger created in 10.7 or higher level db. Because prior to that we did not collect trigger action column informatoin. eg&lt;br/&gt;
            create trigger tr1 after update of c1 on t1 referencing old as oldt for each row insert into t2 values(2,oldt.j,-2); &lt;/p&gt;

&lt;p&gt;Rule4)If trigger column information is available and no trigger action column information is found but REFERENCES clause is used for the trigger, then we will read all the columns from the trigger table. I believe that this will cover soft-upgrade and hard-&lt;br/&gt;
upgrade scenario during trigger execution of triggers created pre-10.7. This will prevent us from having special logic of soft-upgrade. &lt;br/&gt;
Additionally, this logic makes invalidation of existing triggers unnecessary during hard-upgrade. The pre-10.7 created triggers will work just fine even though for some triggers, they would have trigger action columns missing. A user can choose to drop and recreate such triggers to take advantage of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1482&quot; title=&quot;Update triggers on tables with blob columns stream blobs into memory even when the blobs are not referenced/accessed.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1482&quot;&gt;&lt;del&gt;DERBY-1482&lt;/del&gt;&lt;/a&gt; work which will avoid unnecssary column reads during trigger execution if the trigger action column information was available along with trigger column info. eg trigger created prior to 10.7&lt;br/&gt;
            create trigger tr1 after update of c1 on t1 referencing old as oldt for each row insert into t2 values(2,oldt.j,-2);&lt;br/&gt;
The Rule4) is there to cover triggers created with pre-10,7 releases but now that database has been hard/soft-upgraded to 10.7&lt;br/&gt;
or higher version. Prior to 10.7, we did not collect any information about trigger action columns. So, both of the 2 kinds of triggers shown above prior to 10.7 will not have any trigger action column info on them in SYSTRIGGERS table. Without our last rule about what columns should be read in, we will run into problems for soft-upgrade or hard-upgrade causing us to not read all the required columns.The trigger eg above if created prior to 10.7 mode will have trigger column and REFERENCING clause set in SYSTRIGGERS but will not have trigger action column info even 	though there are columns referenced in trigger action through old/new transition variables. This same trigger if created in 10.7 or higher 	version will have trigger column, REFERENCING clause and trigger action column set for it in SYSTRIGGERS. To handle this on a hard/soft-upgraded db, we will just choose to read all the columns from trigger table if SYSTRIGGER shows trigger column and REFERENCING clause for a trigger but no trigger action column. &lt;/p&gt;

&lt;p&gt;Rule5)The only place we will need special code for soft-upgrade is during trigger creation. If we are in soft-upgrade mode, we want to make sure that we do not save information about trigger action columns in SYSTRIGGERS because the releases prior to 10.7 do not understand trigger action column information.&lt;/p&gt;



&lt;p&gt;Let&apos;s see with examples, when the rules described above kick in&lt;br/&gt;
Consider following 4 trigger scenarios &lt;br/&gt;
            1) create trigger tr1 after update on t1 for each row values(1); &lt;br/&gt;
            2) create trigger tr1 after update on t1 referencing old as oldt for each row insert into t2 values(2,oldt.j,-2); &lt;br/&gt;
            3) create trigger tr1 after update of c1 on t1 for each row values(1); &lt;br/&gt;
            4) create trigger tr1 after update of c1 on t1 referencing old as oldt for each row insert into t2 values(2,oldt.j,-2); &lt;/p&gt;

&lt;p&gt;And these different triggers could be created in following various combination of soft-upgrade, hard-upgrade, brand new db&lt;br/&gt;
	a)trigger is getting created in newly created 10.7 db &lt;br/&gt;
	b)trigger already created in the pre-10.7db before soft upgrade &lt;br/&gt;
	c)trigger is getting created while in soft upgrad mode with pre-10.7 db &lt;br/&gt;
	d)trigger already created in the pre-10.7db before hard upgrade &lt;br/&gt;
	e)trigger is getting created after pre-10.7db is hard upgraded &lt;/p&gt;

&lt;p&gt;All the db variations for trigger scenario 1 will be covered by Rule1).&lt;br/&gt;
All the db variations for trigger scenario 2 will be covered by Rule1)&lt;br/&gt;
All the db variations for trigger scenario 3 will be covered by Rule2).&lt;br/&gt;
For trigger scenario 4, different rules will apply depending on db variations&lt;br/&gt;
	For 4a), Rule3) will apply&lt;br/&gt;
	For 4b), Rule4) will apply&lt;br/&gt;
	For 4c), Rule5) will apply&lt;br/&gt;
	For 4d), Rule4) will apply&lt;br/&gt;
	For 4e), Rule3) will apply&lt;/p&gt;</comment>
                            <comment id="12873006" author="rhillegas" created="Fri, 28 May 2010 16:10:27 +0100"  >&lt;p&gt;Thanks for the patch, Mamta. If I understand correctly, users should expect to see the following behaviors:&lt;/p&gt;

&lt;p&gt;1) No behavior change for legacy triggers created before 10.7 is released.&lt;/p&gt;

&lt;p&gt;2) No behavior change for triggers created in soft-upgraded databases.&lt;/p&gt;

&lt;p&gt;3) Potential performance improvement for triggers created in new 10.7 databases.&lt;/p&gt;

&lt;p&gt;4) Potential performance improvement for triggers created in legacy databases after hard-upgrade to 10.7.&lt;/p&gt;

&lt;p&gt;Before looking into the details of this patch, I would like to explore an alternative solution. Maybe this solution has already been considered and rejected. If so, I apologize for the noise. This alternative approach would bring the performance improvement to more cases and would avoid the soft-upgrade and serialization issues. I think that it would re-use most of the code which you are supplying with the current patch:&lt;/p&gt;

&lt;p&gt;A) Do not change what is stored in SYSTRIGGERS.&lt;/p&gt;

&lt;p&gt;B) Instead, the very first time that a trigger is run, if there is a REFERENCING clause, re-parse the trigger text in order to find the columns that are actually needed.&lt;/p&gt;

&lt;p&gt;C) Store the extra referenced column information in a transient field of the trigger descriptor for use by later firings.&lt;/p&gt;

&lt;p&gt;The disadvantage of this approach is that the first firing of a trigger would incur an extra compilation tax. I think that this tax would not be noticed.&lt;/p&gt;

&lt;p&gt;The advantage of this approach is that the performance improvement would be seen in cases (1) and (2) above and not just in cases (3) and (4). In addition, we would avoid the tricky serialization incompatibilities.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12873076" author="mikem" created="Fri, 28 May 2010 18:52:09 +0100"  >&lt;p&gt;I like the current appoach of changing what is stored in SYSTRIGGERS.  I think that it fits well with current architecture.  &lt;/p&gt;

&lt;p&gt;I have reviewed the serialization code and believe it is correct.  If there are any problems please comment.  It would be nice if it were &quot;less tricky&quot;, as it sort of&lt;br/&gt;
overloads existing fields in the data structure - but this is not uncommon in derby when dealing with stored representations of data.   I am ok&lt;br/&gt;
with the tradeoff of how it is currently implemented vs. the alternative of upgrading&lt;br/&gt;
the actual type of the column in the system catalog or adding a new column to the&lt;br/&gt;
system catalog.  It would be nice if we came up with a standard way, well tested &lt;br/&gt;
way to do this - but would not hold up this change on that.&lt;/p&gt;

&lt;p&gt;If someone is interested I do think that #1 of Rick&apos;s 4 cases could be implemented as a separate next increment.  A simple non-code workaround would be to drop and recreate the triggers.  A code change would be to run&lt;br/&gt;
some code at upgrade time to rewrite the triggers.   At that point only soft upgraded databases would not get&lt;br/&gt;
the performance improvement, which should not surprise customers much.&lt;/p&gt;</comment>
                            <comment id="12873101" author="mikem" created="Fri, 28 May 2010 19:32:01 +0100"  >&lt;p&gt;I just read back a bit and see the issue about SERIALIZATION across client/server.  Do you know what JIRA caused this behavior change in 10.6?  I am not sure if it is even possible to do a proper &lt;br/&gt;
soft/hard upgrade on anything in a system catalog that could properly take account of client/server&lt;br/&gt;
mismatches.&lt;/p&gt;

&lt;p&gt;I would lean toward documenting that we don&apos;t support this access, it seems like we should only &lt;br/&gt;
support using the standard jdbc data dictionary interfaces. &lt;/p&gt;

&lt;p&gt;I was not aware of this new client/server behavior.  One of the reasons for the current design in this fix, was to avoid the complication of creating new format id&apos;s and subclasses.  And as you point out even&lt;br/&gt;
if we do this we can&apos;t guarantee anything other than a format id not found error on the backward client since in the worst case it can&apos;t have any new code to handle new stuff in hard upgraded servers.  &lt;/p&gt;</comment>
                            <comment id="12873126" author="rhillegas" created="Fri, 28 May 2010 20:40:42 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;The handling of Java Objects stored in system tables was changed as part of the UDT work. For the details, see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4491&quot; title=&quot;The network client changes UDTs into Strings and returns their type as LONGVARBINARY.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4491&quot;&gt;&lt;del&gt;DERBY-4491&lt;/del&gt;&lt;/a&gt;. That issue brought the client behavior into agreement with the embedded behavior and the JDBC spec.&lt;/p&gt;

&lt;p&gt;The Reference Guide already says that Derby-specific objects in the catalogs are not part of our public API. This disclaimer is tacked onto the description of every catalog column which contains Derby-specific objects. That means that those objects can change shape and behavior and that we make no guarantees of cross-version compatibility.  I don&apos;t think it&apos;s necessary to punch up the disclaimer but it wouldn&apos;t hurt.&lt;/p&gt;

&lt;p&gt;Beyond that explicit disclaimer, we have never claimed that the catalogs will retain their current shape. We have always reserved the right to add, delete, and modify catalog columns. Maybe we haven&apos;t made that clear enough to users. However, we do say the following in the Reference Guide section titled &quot;Derby system tables&quot;:&lt;/p&gt;

&lt;p&gt;&quot;You can query system tables, but you cannot alter them...The recommended way to get more information about these tables is to use an instance of the Java interface java.sql.DatabaseMetaData.&quot;&lt;/p&gt;

&lt;p&gt;We let users query the catalogs because JDBC metadata is not rich enough for portability layers to introspect the capabilities of SQL databases and Derby has not implemented the Standard information schema.&lt;/p&gt;

&lt;p&gt;Because we do let users query the catalogs, I think that we should include a 10.7 release note warning users about the compatibility issues with SYSTRIGGERS.REFERENCEDCOLUMNS.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12873137" author="mikem" created="Fri, 28 May 2010 21:21:42 +0100"  >&lt;p&gt;thanks rick, now I understand why the change.  I see why it would be needed for udt&apos;s.  And it sounds&lt;br/&gt;
like we are covered in the documention about these columns.&lt;/p&gt;

&lt;p&gt;This is probably a hole in our testing, i am not sure there is a way in junit testing to test client with only client jars in the classpath - I believe this is what is documented for derby client users.  Have you ever tried accessing these fields from derby client with only the derby client jar in the class path?  It seems like it would need the server jar&apos;s to be able to work.  &lt;/p&gt;</comment>
                            <comment id="12873172" author="kmarsden" created="Fri, 28 May 2010 23:51:51 +0100"  >&lt;p&gt;Yes Mike, you are right, you need the server jars to select objects from the system tables, for example:&lt;br/&gt;
ij&amp;gt; connect &apos;jdbc:derby://localhost:1527/wombat&apos;;&lt;br/&gt;
ij&amp;gt; select * from sys.sysaliases&lt;br/&gt;
&amp;gt; ;&lt;br/&gt;
ALIASID                             |ALIAS&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;SCHEMAID                            &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;JAVACLASSNAME&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;amp;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;amp;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;SYST&amp;amp;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;ALIASINFO      &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;SPECIFICNAME&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;--------------------------------------------------------------------------------&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
--------------------------------------------------------------------------------&lt;br/&gt;
------&lt;br/&gt;
ERROR XN020: Error marshalling or unmarshalling a user defined type: org.apache.&lt;br/&gt;
derby.catalog.types.RoutineAliasInfo&lt;br/&gt;
ij&amp;gt;&lt;/p&gt;

&lt;p&gt;With the 10.5 client it gives the text of the procedure or function definition for ALIASINFO  may have been useful to someone, e.g.&lt;br/&gt;
SQLCAMESSAGE(IN SQLCODE INTEGER,IN SQLERRML SMALLINT,IN SQLERRMC VARCHAR(2400),I&lt;br/&gt;
N SQLERRP CHAR(8),IN SQLERRD0 INTEGER,IN SQLERR&amp;amp;&lt;/p&gt;

&lt;p&gt;I think you are right about this being a hole in our testing.  Perhaps we should have  an option to run tests with the client in a separate class loader or something.&lt;/p&gt;

</comment>
                            <comment id="12881029" author="mamtas" created="Tue, 22 Jun 2010 03:46:06 +0100"  >&lt;p&gt;I looked through our code during upgrade and found in DD_Version.handleMinorRevisionChange that during any kind of upgrade, we either invalidate or delete the stored prepared statements. This will ensure that we don&apos;t hold on TriggerDescriptor data structure that may not be incompatible across the Derby releases. &lt;/p&gt;

&lt;p&gt;As for the serialization, we already have that issue in our network server product. I would like to go ahead and commit my changes. The general serialization between client and server can be taken as a separate task.&lt;/p&gt;</comment>
                            <comment id="12881087" author="kristwaa" created="Tue, 22 Jun 2010 07:12:21 +0100"  >&lt;p&gt;I&apos;m wondering if we really need to test with LOBs as large as 300 MB?&lt;br/&gt;
That&apos;s not big enough to trigger the issue with most default JVM heap settings these days (i.e. max heap size is typically 512 MB or 1 GB), which forces us to run with specific heap options. We are currently running with a 16 MB heap in junit-lowmem, and writing/reading 300 MB LOBs take a while.&lt;/p&gt;

&lt;p&gt;For another time and effort, we can consider adding a method to return an appropriate LOB size, i.e. by using Runtime.totalMemory(). I haven&apos;t verified that this will work &lt;span class=&quot;error&quot;&gt;&amp;#91;in all JVMs&amp;#93;&lt;/span&gt;, and we should also centralize this method to make it easy to track and override its return value if required.&lt;/p&gt;</comment>
                            <comment id="12881750" author="mamtas" created="Wed, 23 Jun 2010 17:58:21 +0100"  >&lt;p&gt;I had missed two master files with my previous commit. Fixed them with revision 957269.&lt;/p&gt;

&lt;p&gt;Kristian, I will work on reducing the size of LOBs to 50MB since junit-lowmem gets run with 16MB. Please let me know if you think it should be even lower. Thanks for looking at the test.&lt;/p&gt;</comment>
                            <comment id="13012631" author="mamtas" created="Tue, 29 Mar 2011 20:13:44 +0100"  >&lt;p&gt;The work that went under this jira caused data corruption logged under &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5121&quot; title=&quot;Data corruption when executing an UPDATE trigger&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5121&quot;&gt;&lt;del&gt;DERBY-5121&lt;/del&gt;&lt;/a&gt;. The problem is that the resultset expected by the trigger at execution time may not be same as what the triggering sql requires. This can result in trigger picking up the data from incorrect columns.&lt;/p&gt;</comment>
                            <comment id="13014784" author="mamtas" created="Fri, 1 Apr 2011 19:33:17 +0100"  >&lt;p&gt;This patch is not ready for commit but I wanted to put it down for review. I will be on vacation for next few days and&lt;br/&gt;
will look at the review comments once I am back. But what the patch does is to read all the necessary columns during triggering sql&apos;s execution rather than read all the columns from the trigger table just because there is a trigger defined on the table. The thing to keep in mind is that the triggering sql might need more columns in it&apos;s resultset that what a trigger might need during it&apos;s execution. So, the other thing that the patch does is to carve out a temporary resulset for every firing trigger which will be exactly same as the resulset created by the triggering sql or a subset of the resulset created by the triggering sql. Once the right resulset set is constructed for the firing trigger, it will be able to find the columns referenced in it&apos;s trigger action through the REFERENCING clause in the correct positions&lt;br/&gt;
in the resulset.&lt;/p&gt;

&lt;p&gt;I have not run the derbyall and junit suite on this. I plan to work on that after I return from by vacation.&lt;/p&gt;</comment>
                            <comment id="13030999" author="mamtas" created="Tue, 10 May 2011 04:52:34 +0100"  >&lt;p&gt;I ran derbyall and junit suite with this patch and found that handful of upgrade tests are failing. After debugging, I have found the reason to be that my patch does optimization of reading only required columns and hence the trigger action column positions in that selective list of read columns may not be same as their column positions in the underlying trigger table. This column mismatch is not recognized by 10.7 released jars. I am making changes that when in soft upgrade mode, do not do the column reading optimization so the generated trigger action sql will still work when it is taken back to the older release which does not do any column reading optimization.&lt;/p&gt;</comment>
                            <comment id="13032475" author="mamtas" created="Thu, 12 May 2011 17:04:50 +0100"  >&lt;p&gt;Attaching a new patch derby1482_patch5_diff.txt which takes care of the upgrade problems which I ran into with the earlier draft patch. &lt;/p&gt;

&lt;p&gt;During an upgrade(soft/hard), the trigger action SPSes get marked invalid and hence when they fire next time, they will be regenerated and recompiled. The issue with the earlier patch was that when in soft-upgrade mode, the patch was using the new code to do the column read optimization while generating the internal trigger action sql but when such a database goes back to it&apos;s original version, the generated trigger action sql won&apos;t work anymore because previous releases of Derby do not recognize this column read optimization. In order to fix this, the code has to be smart to see if it is working with a pre-10.9 database(which in other words means that we are in soft-upgrade mode) and if yes, then it should not use the column read optimization code during trigger action SPS regeneration and during UPDATE execution when we read limited columns from the trigger table based on what is required by the UPDATE sql and the firing triggers  I have made that change in the attached patch and now&lt;br/&gt;
the upgrade tests work fine. I have also run the complete junit suite and it ranfine. derbyall is still running on my machine. &lt;/p&gt;

&lt;p&gt;I will go ahead and commit this patch on Monday if there are no comments.&lt;/p&gt;</comment>
                            <comment id="13032546" author="mamtas" created="Thu, 12 May 2011 18:58:22 +0100"  >&lt;p&gt;derbyall ran fine with derby1482_patch5_diff.txt&lt;/p&gt;</comment>
                            <comment id="13032746" author="mamtas" created="Fri, 13 May 2011 00:35:20 +0100"  >&lt;p&gt;I ran lowmem suite(ant junit-lowmem) with my changes and it ran fine.&lt;/p&gt;</comment>
                            <comment id="13032749" author="mamtas" created="Fri, 13 May 2011 00:40:16 +0100"  >&lt;p&gt;The attached patch derby1482_patch6_diff.txt is exactly same as the previous patch(derby1482_patch5_diff.txt) except that I have enabled the tests that were written for this jira. We had disabled those tests after encountering the corruption issue &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5121&quot; title=&quot;Data corruption when executing an UPDATE trigger&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5121&quot;&gt;&lt;del&gt;DERBY-5121&lt;/del&gt;&lt;/a&gt;. Those tests now work fine with the attached patch.&lt;/p&gt;</comment>
                            <comment id="13034977" author="mamtas" created="Tue, 17 May 2011 19:59:40 +0100"  >&lt;p&gt;The changes for this jira has been committed to 10.9 codeline. Backport of this to 10.8 can cause an issue because we already have a release out for 10.8(10.8.2) which does not do any column reading optimization. If we were to migrate these changes to the next point release of 10.8, we could run into problems when the 10.8.2 database is used with next point release of 10.8 which does column read optimization. When such a db is taken back to 10.8.2, it can run into issues because 10.8.2 doesn&apos;t recognize column read optimization performed by the next point release of 10.8 and hence genereated trigger action SPSes will not work correctly in 10.8.1.&lt;/p&gt;</comment>
                            <comment id="13069833" author="mamtas" created="Sat, 23 Jul 2011 00:03:09 +0100"  >&lt;p&gt;Attaching a release note for the jira.&lt;/p&gt;</comment>
                            <comment id="13685162" author="knutanders" created="Mon, 17 Jun 2013 10:19:12 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12408012">DERBY-3940</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12312010">DERBY-442</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12510419">DERBY-5277</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12511411">DERBY-5294</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12455381">DERBY-4537</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12455390">DERBY-4538</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310050">
                    <name>Regression</name>
                                            <outwardlinks description="breaks">
                                        <issuelink>
            <issuekey id="12500978">DERBY-5121</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12475247" name="DERBY_1482_patch4_diff.txt" size="22410" author="mamtas" created="Fri, 1 Apr 2011 19:33:17 +0100"/>
                            <attachment id="12475248" name="DERBY_1482_patch4_stat.txt" size="876" author="mamtas" created="Fri, 1 Apr 2011 19:33:17 +0100"/>
                            <attachment id="12436290" name="TriggerTests_ver1_diff.txt" size="65117" author="mamtas" created="Fri, 19 Feb 2010 06:44:32 +0000"/>
                            <attachment id="12436291" name="TriggerTests_ver1_stat.txt" size="176" author="mamtas" created="Fri, 19 Feb 2010 06:44:32 +0000"/>
                            <attachment id="12434429" name="derby1482DeepCopyAfterTriggerOnLobColumn.java" size="11030" author="mamtas" created="Mon, 1 Feb 2010 20:11:36 +0000"/>
                            <attachment id="12431091" name="derby1482Repro.java" size="2987" author="mamtas" created="Fri, 22 Jan 2010 03:32:22 +0000"/>
                            <attachment id="12435915" name="derby1482ReproVersion2.java" size="2995" author="mamtas" created="Mon, 15 Feb 2010 22:38:16 +0000"/>
                            <attachment id="12439923" name="derby1482_patch1_diff.txt" size="60755" author="mamtas" created="Fri, 26 Mar 2010 22:04:43 +0000"/>
                            <attachment id="12439924" name="derby1482_patch1_stat.txt" size="1441" author="mamtas" created="Fri, 26 Mar 2010 22:04:43 +0000"/>
                            <attachment id="12440581" name="derby1482_patch2_diff.txt" size="51284" author="mamtas" created="Fri, 2 Apr 2010 06:33:16 +0100"/>
                            <attachment id="12440582" name="derby1482_patch2_stat.txt" size="913" author="mamtas" created="Fri, 2 Apr 2010 06:33:16 +0100"/>
                            <attachment id="12445694" name="derby1482_patch3_diff.txt" size="104284" author="mamtas" created="Thu, 27 May 2010 21:20:50 +0100"/>
                            <attachment id="12445695" name="derby1482_patch3_stat.txt" size="1470" author="mamtas" created="Thu, 27 May 2010 21:20:50 +0100"/>
                            <attachment id="12478985" name="derby1482_patch5_diff.txt" size="34161" author="mamtas" created="Thu, 12 May 2011 17:04:50 +0100"/>
                            <attachment id="12478986" name="derby1482_patch5_stat.txt" size="876" author="mamtas" created="Thu, 12 May 2011 17:04:50 +0100"/>
                            <attachment id="12479033" name="derby1482_patch6_diff.txt" size="35230" author="mamtas" created="Fri, 13 May 2011 00:40:16 +0100"/>
                            <attachment id="12479034" name="derby1482_patch6_stat.txt" size="967" author="mamtas" created="Fri, 13 May 2011 00:40:16 +0100"/>
                            <attachment id="12439922" name="junitUpgradeTestFailureWithPatch1.out" size="277627" author="mamtas" created="Fri, 26 Mar 2010 22:04:43 +0000"/>
                            <attachment id="12487570" name="releaseNote.html" size="4388" author="mamtas" created="Sat, 23 Jul 2011 00:03:09 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>19.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 19 Sep 2006 15:21:36 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22532</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0flz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36347</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10053"><![CDATA[Low]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>