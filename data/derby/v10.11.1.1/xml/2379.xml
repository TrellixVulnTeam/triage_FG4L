<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:34:21 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2379/DERBY-2379.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2379] provide encryption support for temporary files used by lob if the data base is encrypted</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2379</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description></description>
                <environment>all</environment>
        <key id="12363734">DERBY-2379</key>
            <summary>provide encryption support for temporary files used by lob if the data base is encrypted</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12343409">DERBY-1341</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="anurag">Anurag Shekhar</assignee>
                                    <reporter username="anurag">Anurag Shekhar</reporter>
                        <labels>
                    </labels>
                <created>Tue, 27 Feb 2007 19:45:55 +0000</created>
                <updated>Tue, 25 May 2010 10:43:46 +0100</updated>
                            <resolved>Tue, 12 Jun 2007 13:59:37 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12476350" author="anurag" created="Tue, 27 Feb 2007 19:58:46 +0000"  >&lt;p&gt;Description of patch derby-2379.diff&lt;br/&gt;
This patch introduces a new class LOBFile which is encryption aware and uses store factory methods to encrypt and decrypt bytes before writing or after reading from the file in case of encrypted databse. This class is used by LOBStreamControl for accessing temporary file.&lt;br/&gt;
It also contains changes in TestConfiguration and JDBCDataSource to enable support for running test suites in encrypted mode (only in embedded mode).&lt;/p&gt;

&lt;p&gt;New Files added &lt;br/&gt;
java/engine/org/apache/derby/impl/jdbc/LOBFile.java&lt;br/&gt;
Class to handle plain/encrypted io to temporary file.&lt;/p&gt;

&lt;p&gt;Modified Files&lt;br/&gt;
java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java&lt;br/&gt;
Modified to use LOBFile&lt;/p&gt;

&lt;p&gt;java/engine/org/apache/derby/iapi/store/raw/data/DataFactory.java&lt;br/&gt;
added a new method to return true if the database is encrypted&lt;/p&gt;

&lt;p&gt;java/testing/org/apache/derbyTesting/junit/TestConfiguration.java&lt;br/&gt;
java/testing/org/apache/derbyTesting/junit/JDBCDataSource.java&lt;br/&gt;
Modified to run tests in encrypted mode.&lt;/p&gt;

&lt;p&gt;java/testing/org/apache/derbyTesting/functionTests/tests/jdbc4/BlobSetMethodsTest.java&lt;br/&gt;
java/testing/org/apache/derbyTesting/functionTests/tests/jdbc4/LobStreamTest.java&lt;/p&gt;

&lt;p&gt;Enabled in encrypted mode too.&lt;/p&gt;




</comment>
                            <comment id="12476450" author="mikem" created="Tue, 27 Feb 2007 23:35:16 +0000"  >&lt;p&gt;Can you document a little about the intended usage of LOBFile?  Ie. is it a purely a server side action vs. a client side?  I&lt;br/&gt;
am trying to understand if the store module usage from the jdbc layer is appropriate.&lt;/p&gt;</comment>
                            <comment id="12476500" author="anurag" created="Wed, 28 Feb 2007 03:52:52 +0000"  >&lt;p&gt;LOBFile is a server side class and will be used by embedded jdbc driver.&lt;/p&gt;</comment>
                            <comment id="12483945" author="knutanders" created="Sun, 25 Mar 2007 15:56:19 +0100"  >&lt;ul&gt;
	&lt;li&gt;It seems to me LOBFile implements all the methods of the&lt;br/&gt;
  StorageRandomAccessFile interface, but the class doesn&apos;t implement&lt;br/&gt;
  the interface. Would it make sense to let LOBFile implement&lt;br/&gt;
  StorageRandomAccessFile? That would require fewer changes in&lt;br/&gt;
  LOBStreamControl, and one could also leave the non-encrypted&lt;br/&gt;
  read/write methods out of LOBFile.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It would be good to add some comments explaining the purpose of the&lt;br/&gt;
  instance variables and the private methods in LOBFile.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Is the lobFile field in LOBFile necessary? It doesn&apos;t seem to be&lt;br/&gt;
  used outside the constructor.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.getBlocks:&lt;br/&gt;
  Is it necessary to check whether len is negative and thrown an&lt;br/&gt;
  IndexOutOfBoundsException? I guess the boundaries are checked on a&lt;br/&gt;
  higher level as well, and you&apos;ll get a NegativeArraySizeException&lt;br/&gt;
  anyway if len in negative, so I don&apos;t see any need to explicitly&lt;br/&gt;
  throw IndexOutOfBoundsException.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.getBlocks:&lt;br/&gt;
  Couldn&apos;t the calculation of endPos be expressed without the&lt;br/&gt;
  condition, like this:&lt;br/&gt;
    long endPos = (pos + len + blockSize - 1) / blockSize * blockSize;&lt;br/&gt;
  I&apos;m not saying it will improve the readability significantly,&lt;br/&gt;
  though... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.writeEncrypted(byte):&lt;br/&gt;
    tailSize = (pos &amp;gt; tailSize - 1) ? pos + 1 : tailSize;&lt;br/&gt;
  Perhaps this is clearer when written like this:&lt;br/&gt;
    if (pos &amp;gt;= tailSize) tailSize = pos + 1;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.writeEncrypted(byte):&lt;br/&gt;
+                long l = randomAccessFile.length();&lt;br/&gt;
+                tailSize = 0;&lt;br/&gt;
+            }&lt;br/&gt;
  The variable l is never used.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The read*/write* methods of LOBFile have many calls to&lt;br/&gt;
  RandomAccessFile.length(). Would it be possible to reduce the number&lt;br/&gt;
  of times it is called? I&apos;m not sure, but I suspect length() might&lt;br/&gt;
  involve a system call, so one shouldn&apos;t call it too frequently. I&lt;br/&gt;
  was thinking perhaps we could change code that looks like this&lt;br/&gt;
+        if (currentPos &amp;gt;= randomAccessFile.length()) {&lt;br/&gt;
+            //current postion is in memory&lt;br/&gt;
+            int pos = (int) (currentPos - randomAccessFile.length());&lt;br/&gt;
into something like this:&lt;br/&gt;
    long fileLength = randomAccessFile.length();&lt;br/&gt;
    if (currentPos &amp;gt;= fileLength) {&lt;br/&gt;
        int pos = (int) (currentPos - fileLength);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.writeEncrypted(byte[],int,int):&lt;br/&gt;
+        if (finalPos &amp;lt; blockSize) 
{
+            //updated size won&apos;t be enough to perform encryption&apos;
+            System.arraycopy (b, off, tail, pos, len);
+            tailSize = pos + len;
+            currentPos += len;
+            return;
+        }
&lt;p&gt;Shouldn&apos;t tailSize be max(tailSize, pos+len)?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;+        //copy the bytes from tail which won&apos;t be overwritten&apos;&lt;br/&gt;
+        System.arraycopy (tail, 0, clearText, 0, pos);&lt;br/&gt;
Shouldn&apos;t the last argument have been tailLength in case we are not&lt;br/&gt;
overwriting the end of the tail?&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;LOBFile.readEncrypted():&lt;br/&gt;
  It doesn&apos;t seem like currentPos is incremented in the case where we&lt;br/&gt;
  need to read from the file.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.readEncrypted(byte[],int,int) / writeEncrypted(byte[],int,int):&lt;br/&gt;
  It&apos;s probably slightly faster to replace this kind of loops&lt;br/&gt;
+            for (int i = 0; i &amp;lt; cypherText.length / blockSize; i++) 
{
+                df.decrypt (cypherText, i * blockSize, blockSize, tmpByte, 
+                                                                i * blockSize);
+            }
&lt;p&gt;  with&lt;br/&gt;
    for (int offset = 0; offset &amp;lt; cypherText.length; offset += blockSize) &lt;/p&gt;
{
        df.decrypt(cypherText, offset, blockSize, tmpByte, offset);
    }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.readEncrypted(byte[],int,int):&lt;br/&gt;
  currentPos is not incremented when overFlow == 0.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.readEncrypted(byte[],int,int):&lt;br/&gt;
  This part doesn&apos;t look correct to me:&lt;br/&gt;
+            //find out total number of bytes we can read&lt;br/&gt;
+            int newLen = (len - cypherText.length &amp;lt; tailSize) &lt;br/&gt;
+                            ? len - cypherText.length&lt;br/&gt;
+                            : tailSize;&lt;br/&gt;
  I think it only works if the read starts on a block boundary, and it&lt;br/&gt;
  should have used overflow instead of (len - cypherText.length).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I don&apos;t understand why getFilePointer, seek, read(byte[],off,len)&lt;br/&gt;
  and setLength are synchronized. Could you explain why these methods&lt;br/&gt;
  need synchronization, and why the other methods don&apos;t?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LOBFile.setLength() is a no-op if the new length is greater than the&lt;br/&gt;
  old length. Wouldn&apos;t it be better to throw an error in this case?&lt;br/&gt;
  It&apos;s not supposed to happen since it&apos;s only called from&lt;br/&gt;
  LOBStreamControl.truncate(), but since setLength() is already&lt;br/&gt;
  checking that the new size is not greater, I think it&apos;s better to&lt;br/&gt;
  throw an IllegalArgumentException or UnsupportedOperationException&lt;br/&gt;
  than to silently return.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I got these warnings when I tried to generate the javadoc:&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; .../LOBFile.java:254: warning - @return tag has no arguments.&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; .../LOBFile.java:346: warning - @return tag has no arguments.&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; .../DataFactory.java:381: warning - @return tag has no arguments.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If my comments have revealed bugs in the patch, I think it would be&lt;br/&gt;
  good to write test cases which exposes them and add them to the&lt;br/&gt;
  JUnit tests.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12484013" author="narayanan" created="Mon, 26 Mar 2007 05:20:43 +0100"  >&lt;p&gt;I was reviewing this patch yesterday and had a few comments too. I have not checked to see if the intersection of the set of comments of knut and that of mine is a null set but I am putting it out there anyway.&lt;/p&gt;

&lt;p&gt;My comments are mostly cosmetic except for the below. The attachment contains the cosmetic issues that I identified. I was planning to send the attachment internally only.&lt;/p&gt;

&lt;p&gt;you are doing the below in BlobSetMethods test. Shouldn&apos;t one of them have been&lt;br/&gt;
embeddedEncryptedSuite instead of embeddedSuite?&lt;/p&gt;

&lt;p&gt;+        TestSuite blobSuite = new TestSuite (&quot;blob set tests&quot;);&lt;br/&gt;
+        blobSuite.addTest (TestConfiguration.embeddedSuite&lt;br/&gt;
+                                                (BlobSetMethodsTest.class));&lt;br/&gt;
+        blobSuite.addTest (TestConfiguration.embeddedSuite&lt;br/&gt;
+                                                (BlobSetMethodsTest.class));&lt;br/&gt;
+        return blobSuite;&lt;/p&gt;

&lt;p&gt;There is a similar issue in LobStreamTest.&lt;/p&gt;

&lt;p&gt;Also you have made setLength and read synchronized but readByte and all the write methods are not synchronized. Probably I am having this doubt because of my not knowing the code properly but can you explain why you have done this? &lt;/p&gt;

&lt;p&gt;The cosmetic comments I had can be ignored if you want to. I consider them trivial. For whatever it is worth I wrote those comments in the form of a text file and am attaching the file to this issue.&lt;/p&gt;</comment>
                            <comment id="12484016" author="narayanan" created="Mon, 26 Mar 2007 05:22:05 +0100"  >&lt;p&gt;Attached is the file containing the cosmetic issues I identified. Pls feel free to ignore them if you want to.&lt;/p&gt;</comment>
                            <comment id="12484017" author="narayanan" created="Mon, 26 Mar 2007 05:30:29 +0100"  >&lt;p&gt;I am sorry I meant to say I was planning to paste the attachment internally only (but since the comments were trivial javadoc issues I decided against pasting it internally and pasted it as a external text file.)&lt;/p&gt;</comment>
                            <comment id="12492095" author="anurag" created="Thu, 26 Apr 2007 20:06:35 +0100"  >&lt;p&gt;Descriptions of path (derby-2379v2.diff)&lt;br/&gt;
Fixed bugs found in Knuth and Narayanan reviews&lt;br/&gt;
Removed my code to run tests in encrypted mode instead using the Decorator method for the same&lt;br/&gt;
Enabled jdbcapi/BlobClob4BlobTest, jdbcapi/LobStreamsTest, jdbcapi/ClobUpdatableReaderTest, jdbc4/LobStreamTest to include testing in encrypted db.&lt;br/&gt;
Fixed Javadoc warning and added throws clause in LOBFile methods&lt;br/&gt;
Removed unused varraibles&lt;br/&gt;
Removed redundant calls to file.length from read and write methods&lt;br/&gt;
Added an exception in case setLength is called with a value longer than the file  length.&lt;/p&gt;

&lt;p&gt;About synchronization&lt;br/&gt;
I have decided to follow RandomAccessFile models (making this class thread unsafe). The user of this class has to ensure synchronization which is being taking care in this case by LOBStreamControl. added a note about it in java doc.&lt;/p&gt;


&lt;p&gt;I haven&apos;t extended the LOBFile class from StorageRandomAccessFile as doing so will need empty implimentation of several methods (inherited from parent interfaces of StorageRandomAccessFile)&lt;/p&gt;

&lt;p&gt;there was bug in the test case modification i had done (as Naryanan pointed) so the bugs knut pointed in his review remained unexposed.All the tests I have enabled for encrypted mode test most of the new code.&lt;/p&gt;
</comment>
                            <comment id="12495643" author="knutanders" created="Mon, 14 May 2007 16:07:33 +0100"  >&lt;p&gt;Thanks for posting the new patch, Anurag! See my comments below.&lt;/p&gt;

&lt;p&gt;&amp;gt; I haven&apos;t extended the LOBFile class from StorageRandomAccessFile as&lt;br/&gt;
&amp;gt; doing so will need empty implimentation of several methods&lt;br/&gt;
&amp;gt; (inherited from parent interfaces of StorageRandomAccessFile)&lt;/p&gt;

&lt;p&gt;The implementations of StorageRandomAccessFile normally extend&lt;br/&gt;
java.io.RandomAccessFile which implements all the methods of the&lt;br/&gt;
StorageRandomAccessFile interface. Could that help LOBFile as well?&lt;/p&gt;

&lt;p&gt;Some of my previous comments were not addressed or only partly&lt;br/&gt;
addressed. I have included them below, some of them with extra&lt;br/&gt;
comments. If you don&apos;t agree with my comments, please say so. There&lt;br/&gt;
are so many different cases that need to be covered, so I can very&lt;br/&gt;
well have misunderstood something.&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.getBlocks:&lt;br/&gt;
&amp;gt;   Is it necessary to check whether len is negative and thrown an&lt;br/&gt;
&amp;gt;   IndexOutOfBoundsException? I guess the boundaries are checked on a&lt;br/&gt;
&amp;gt;   higher level as well, and you&apos;ll get a NegativeArraySizeException&lt;br/&gt;
&amp;gt;   anyway if len in negative, so I don&apos;t see any need to explicitly&lt;br/&gt;
&amp;gt;   throw IndexOutOfBoundsException.&lt;/p&gt;

&lt;p&gt;Not addressed as far as I can see.&lt;/p&gt;

&lt;p&gt;&amp;gt; * The read*/write* methods of LOBFile have many calls to&lt;br/&gt;
&amp;gt;   RandomAccessFile.length(). Would it be possible to reduce the number&lt;br/&gt;
&amp;gt;   of times it is called? I&apos;m not sure, but I suspect length() might&lt;br/&gt;
&amp;gt;   involve a system call, so one shouldn&apos;t call it too frequently. I&lt;br/&gt;
&amp;gt;   was thinking perhaps we could change code that looks like this&lt;br/&gt;
&amp;gt; + if (currentPos &amp;gt;= randomAccessFile.length()) {&lt;br/&gt;
&amp;gt; + //current postion is in memory&lt;br/&gt;
&amp;gt; + int pos = (int) (currentPos - randomAccessFile.length());&lt;br/&gt;
&amp;gt; into something like this:&lt;br/&gt;
&amp;gt;     long fileLength = randomAccessFile.length();&lt;br/&gt;
&amp;gt;     if (currentPos &amp;gt;= fileLength) {&lt;br/&gt;
&amp;gt;         int pos = (int) (currentPos - fileLength);&lt;/p&gt;

&lt;p&gt;Partly addressed. Still occurrences of multiple calls to length() in&lt;br/&gt;
writeEncrypted(byte), writeEncrypted(byte[],int,int) and setLength().&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.writeEncrypted(byte[],int,int):&lt;br/&gt;
&amp;gt; + //copy the bytes from tail which won&apos;t be overwritten&apos;&lt;br/&gt;
&amp;gt; + System.arraycopy (tail, 0, clearText, 0, pos);&lt;br/&gt;
&amp;gt; Shouldn&apos;t the last argument have been tailLength in case we are not&lt;br/&gt;
&amp;gt; overwriting the end of the tail?&lt;/p&gt;

&lt;p&gt;Not addressed, but I don&apos;t understand what I meant by that comment, so&lt;br/&gt;
it&apos;s probably OK... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.readEncrypted(byte[],int,int) / writeEncrypted(byte[],int,int):&lt;br/&gt;
&amp;gt;   It&apos;s probably slightly faster to replace this kind of loops&lt;br/&gt;
&amp;gt; + for (int i = 0; i &amp;lt; cypherText.length / blockSize; i++) &lt;/p&gt;
{
&amp;gt; + df.decrypt (cypherText, i * blockSize, blockSize, tmpByte,
&amp;gt; + i * blockSize);
&amp;gt; + }
&lt;p&gt;&amp;gt;   with&lt;br/&gt;
&amp;gt;     for (int offset = 0; offset &amp;lt; cypherText.length; offset += blockSize) &lt;/p&gt;
{
&amp;gt;         df.decrypt(cypherText, offset, blockSize, tmpByte, offset);
&amp;gt;     }

&lt;p&gt;Not addressed, I think.&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.readEncrypted(byte[],int,int):&lt;br/&gt;
&amp;gt;   This part doesn&apos;t look correct to me:&lt;br/&gt;
&amp;gt; + //find out total number of bytes we can read&lt;br/&gt;
&amp;gt; + int newLen = (len - cypherText.length &amp;lt; tailSize)&lt;br/&gt;
&amp;gt; + ? len - cypherText.length&lt;br/&gt;
&amp;gt; + : tailSize;&lt;br/&gt;
&amp;gt;   I think it only works if the read starts on a block boundary, and it&lt;br/&gt;
&amp;gt;   should have used overflow instead of (len - cypherText.length).&lt;/p&gt;

&lt;p&gt;Only partly addressed. I think both occurrences of (len -&lt;br/&gt;
cypherText.length) should have been replaced. Actually, I think it&lt;br/&gt;
could be as simple as newLen = min(overFlow, tailSize).&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.setLength() is a no-op if the new length is greater than the&lt;br/&gt;
&amp;gt;   old length. Wouldn&apos;t it be better to throw an error in this case?&lt;br/&gt;
&amp;gt;   It&apos;s not supposed to happen since it&apos;s only called from&lt;br/&gt;
&amp;gt;   LOBStreamControl.truncate(), but since setLength() is already&lt;br/&gt;
&amp;gt;   checking that the new size is not greater, I think it&apos;s better to&lt;br/&gt;
&amp;gt;   throw an IllegalArgumentException or UnsupportedOperationException&lt;br/&gt;
&amp;gt;   than to silently return.&lt;/p&gt;

&lt;p&gt;This seems to have been fixed, but the javadoc still says that it&apos;s a&lt;br/&gt;
no-op.&lt;/p&gt;

&lt;p&gt;A couple of other things I noticed when I looked at the patch again:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The javadoc comments often just have a @param tag or @throws tag&lt;br/&gt;
  which tells the name of the parameter or exception, and doesn&apos;t&lt;br/&gt;
  describe it. It would be good if they also contained a description.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Some of the @throws tags are on this form:&lt;br/&gt;
    @throws IOException, SQLException, StandardException&lt;br/&gt;
  Here, &quot;SQLException, StandardException&quot; will be interpreted as the&lt;br/&gt;
  description of IOException. Please use one @throws tag per&lt;br/&gt;
  exception.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The javadoc for LOBFile.seek() says that it&apos;s a no-op if pos is&lt;br/&gt;
  greater than length. However, it will always modify currentPos, so&lt;br/&gt;
  it&apos;s not actually a no-op.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LOBFile.readEncrypted(byte[],int,int) has this code:&lt;br/&gt;
+        if (newLen == 0)&lt;br/&gt;
+            return -1;&lt;br/&gt;
  This means -1 is returned if someone requests 0 bytes. I think the&lt;br/&gt;
  condition should also include &quot;&amp;amp;&amp;amp; len &amp;gt; 0&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When readEncrypted() and writeEncrypted() calculate the value of&lt;br/&gt;
  overFlow, I think it would be more readable if it were written as:&lt;br/&gt;
    int overFlow = (int) Math.max(0L, currentPos + len - fileLength);&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12496266" author="anurag" created="Wed, 16 May 2007 12:45:00 +0100"  >&lt;p&gt;derby-2379v2-conflict.diff:&lt;br/&gt;
Resolved conflicts of derby-2379v2, no real change from derby-2379v2.&lt;/p&gt;</comment>
                            <comment id="12496297" author="anurag" created="Wed, 16 May 2007 14:26:00 +0100"  >&lt;p&gt;I am still working on the comments Knuth has posted but mean while i uploaded a new patch to resolve merge conflicts, in case some one wants to look at the patch.&lt;/p&gt;</comment>
                            <comment id="12496741" author="anurag" created="Fri, 18 May 2007 01:49:29 +0100"  >&lt;p&gt;about derby-2379v3.diff&lt;/p&gt;


&lt;p&gt;&amp;gt;The implementations of StorageRandomAccessFile normally extend&lt;br/&gt;
&amp;gt;java.io.RandomAccessFile which implements all the methods of the&lt;br/&gt;
&amp;gt;StorageRandomAccessFile interface. Could that help LOBFile as well?&lt;/p&gt;

&lt;p&gt;Problem with extending RandomAccessFile is that I will need to intercept all the methods to either throw not supported exception or to include encryption. &lt;/p&gt;



&lt;p&gt;&amp;gt; * LOBFile.getBlocks:&lt;br/&gt;
&amp;gt; Is it necessary to check whether len is negative and thrown an&lt;br/&gt;
&amp;gt; IndexOutOfBoundsException? I guess the boundaries are checked on a&lt;br/&gt;
&amp;gt; higher level as well, and you&apos;ll get a NegativeArraySizeException&lt;br/&gt;
&amp;gt; anyway if len in negative, so I don&apos;t see any need to explicitly&lt;br/&gt;
&amp;gt; throw IndexOutOfBoundsException.&lt;/p&gt;

&lt;p&gt;&amp;gt;Not addressed as far as I can see.&lt;/p&gt;

&lt;p&gt;i have this checking beacuase stream classes need to throw IndexOutOfBoundsException in case of negative length.&lt;/p&gt;


&lt;p&gt;&amp;gt; * The read*/write* methods of LOBFile have many calls to&lt;br/&gt;
&amp;gt; RandomAccessFile.length(). Would it be possible to reduce the number&lt;br/&gt;
&amp;gt; of times it is called? I&apos;m not sure, but I suspect length() might&lt;br/&gt;
&amp;gt; involve a system call, so one shouldn&apos;t call it too frequently. I&lt;br/&gt;
&amp;gt; was thinking perhaps we could change code that looks like this&lt;br/&gt;
&amp;gt; + if (currentPos &amp;gt;= randomAccessFile.length()) {&lt;br/&gt;
&amp;gt; + //current postion is in memory&lt;br/&gt;
&amp;gt; + int pos = (int) (currentPos - randomAccessFile.length());&lt;br/&gt;
&amp;gt; into something like this:&lt;br/&gt;
&amp;gt; long fileLength = randomAccessFile.length();&lt;br/&gt;
&amp;gt; if (currentPos &amp;gt;= fileLength) {&lt;br/&gt;
&amp;gt; int pos = (int) (currentPos - fileLength);&lt;/p&gt;

&lt;p&gt;&amp;gt;Partly addressed. Still occurrences of multiple calls to length() in&lt;br/&gt;
&amp;gt;writeEncrypted(byte), writeEncrypted(byte[],int,int) and setLength().&lt;/p&gt;

&lt;p&gt;fixed&lt;/p&gt;


&lt;p&gt;&amp;gt; * LOBFile.readEncrypted(byte[],int,int) / writeEncrypted(byte[],int,int):&lt;br/&gt;
&amp;gt; It&apos;s probably slightly faster to replace this kind of loops&lt;br/&gt;
&amp;gt; + for (int i = 0; i &amp;lt; cypherText.length / blockSize; i++) &lt;/p&gt;
{
&amp;gt; + df.decrypt (cypherText, i * blockSize, blockSize, tmpByte,
&amp;gt; + i * blockSize);
&amp;gt; + }
&lt;p&gt;&amp;gt; with&lt;br/&gt;
&amp;gt; for (int offset = 0; offset &amp;lt; cypherText.length; offset += blockSize) &lt;/p&gt;
{
&amp;gt; df.decrypt(cypherText, offset, blockSize, tmpByte, offset);
&amp;gt; }

&lt;p&gt;&amp;gt;Not addressed, I think.&lt;br/&gt;
changed&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.readEncrypted(byte[],int,int):&lt;br/&gt;
&amp;gt; This part doesn&apos;t look correct to me:&lt;br/&gt;
&amp;gt; + //find out total number of bytes we can read&lt;br/&gt;
&amp;gt; + int newLen = (len - cypherText.length &amp;lt; tailSize)&lt;br/&gt;
&amp;gt; + ? len - cypherText.length&lt;br/&gt;
&amp;gt; + : tailSize;&lt;br/&gt;
&amp;gt; I think it only works if the read starts on a block boundary, and it&lt;br/&gt;
&amp;gt; should have used overflow instead of (len - cypherText.length).&lt;/p&gt;

&lt;p&gt;&amp;gt;Only partly addressed. I think both occurrences of (len -&lt;br/&gt;
&amp;gt;cypherText.length) should have been replaced. Actually, I think it&lt;br/&gt;
&amp;gt;could be as simple as newLen = min(overFlow, tailSize).&lt;/p&gt;

&lt;p&gt;changed&lt;/p&gt;

&lt;p&gt;&amp;gt; * LOBFile.setLength() is a no-op if the new length is greater than the&lt;br/&gt;
&amp;gt; old length. Wouldn&apos;t it be better to throw an error in this case?&lt;br/&gt;
&amp;gt; It&apos;s not supposed to happen since it&apos;s only called from&lt;br/&gt;
&amp;gt; LOBStreamControl.truncate(), but since setLength() is already&lt;br/&gt;
&amp;gt; checking that the new size is not greater, I think it&apos;s better to&lt;br/&gt;
&amp;gt; throw an IllegalArgumentException or UnsupportedOperationException&lt;br/&gt;
&amp;gt; than to silently return.&lt;/p&gt;

&lt;p&gt;&amp;gt;This seems to have been fixed, but the javadoc still says that it&apos;s a&lt;br/&gt;
&amp;gt;no-op.&lt;/p&gt;

&lt;p&gt;updated javadoc &lt;/p&gt;

&lt;p&gt;&amp;gt;A couple of other things I noticed when I looked at the patch again:&lt;/p&gt;

&lt;p&gt;&amp;gt; The javadoc comments often just have a @param tag or @throws tag&lt;br/&gt;
&amp;gt;  which tells the name of the parameter or exception, and doesn&apos;t&lt;br/&gt;
&amp;gt;  describe it. It would be good if they also contained a description.&lt;/p&gt;

&lt;p&gt;added description of params and exceptions&lt;/p&gt;

&lt;p&gt;&amp;gt; Some of the @throws tags are on this form:&lt;br/&gt;
&amp;gt;    @throws IOException, SQLException, StandardException&lt;br/&gt;
&amp;gt;  Here, &quot;SQLException, StandardException&quot; will be interpreted as the&lt;br/&gt;
&amp;gt;  description of IOException. Please use one @throws tag per&lt;br/&gt;
&amp;gt;  exception.&lt;/p&gt;

&lt;p&gt;done&lt;/p&gt;

&lt;p&gt;&amp;gt; The javadoc for LOBFile.seek() says that it&apos;s a no-op if pos is&lt;br/&gt;
&amp;gt;  greater than length. However, it will always modify currentPos, so&lt;br/&gt;
&amp;gt;  it&apos;s not actually a no-op.&lt;/p&gt;

&lt;p&gt;fixed also added same code in seek method if new pos is larger than file size&lt;/p&gt;

&lt;p&gt;&amp;gt; LOBFile.readEncrypted(byte[],int,int) has this code:&lt;br/&gt;
&amp;gt; if (newLen == 0)&lt;br/&gt;
&amp;gt; return -1;&lt;br/&gt;
&amp;gt;  This means -1 is returned if someone requests 0 bytes. I think the&lt;br/&gt;
&amp;gt;  condition should also include &quot;&amp;amp;&amp;amp; len &amp;gt; 0&quot;.&lt;/p&gt;

&lt;p&gt;fixed&lt;/p&gt;

&lt;p&gt;&amp;gt; When readEncrypted() and writeEncrypted() calculate the value of&lt;br/&gt;
&amp;gt;  overFlow, I think it would be more readable if it were written as:&lt;br/&gt;
&amp;gt;    int overFlow = (int) Math.max(0L, currentPos + len - fileLength);&lt;/p&gt;

&lt;p&gt;changed&lt;/p&gt;</comment>
                            <comment id="12497880" author="knutanders" created="Tue, 22 May 2007 15:31:40 +0100"  >&lt;p&gt;Thanks for addressing my comments, Anurag! I will take a look at the latest patch and commit it if the tests pass and I don&apos;t find more issues.&lt;/p&gt;

&lt;p&gt;As to the discussion about LOBFile, even if we cannot let LOBFile implement the StorageFile interface, I still feel it would be cleaner to split the code for encrypted and non-encrypted LOBs. For instance, we could let LOBFile handle unencrypted LOBs, and have another class EncryptedLOBFile which extended LOBFile and handled the encrypted LOBs. But that could be addressed as a separate clean-up task later.&lt;/p&gt;</comment>
                            <comment id="12498249" author="knutanders" created="Wed, 23 May 2007 15:24:11 +0100"  >&lt;p&gt;I have looked at the v3 patch, and it looks correct to me. However,&lt;br/&gt;
I&apos;m a bit worried about the performance impact this patch may have on&lt;br/&gt;
unencrypted data.&lt;/p&gt;

&lt;p&gt;I would expect this to have close to zero overhead for unencrypted&lt;br/&gt;
lobs, but I think the patch adds some of the overhead needed for the&lt;br/&gt;
encrypted lobs to the unencrypted lobs as well. For instance, if we&lt;br/&gt;
look a call to LOBStreamControl.read(long) on an unencrypted database,&lt;br/&gt;
this is what happens today:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StorageRandomAccessFile.getFilePointer() is called to check&lt;br/&gt;
    whether we need to reposition with StorageRandomAccessFile.seek()&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StorageRandomAccessFile.readByte() is called, and its return value&lt;br/&gt;
    is returned&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With the patch, this is what happens:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LOBFile.getFilePointer() is called to check whether we need to&lt;br/&gt;
    reposition. If we need to reposition, LOBFile.seek() is called,&lt;br/&gt;
    which triggers these operations:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;one call to StorageRandomAccessFile.length() to check whether&lt;br/&gt;
        the new position is after the end of the file&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;one call to StorageRandomAccessFile.length() to check whether&lt;br/&gt;
        the new position is before the end of file, in which case&lt;br/&gt;
        StorageRandomAccessFile.seek() is called&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;update current position pointer in LOBFile&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LOBFile.readByte() is called, which triggers these operations:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;one call to StorageRandomAccessFile.length() to check whether&lt;br/&gt;
        we try to read after the end of the file&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;one call to StorageRandomAccessFile.getFilePointer() to see&lt;br/&gt;
        whether we need to reposition, in which case&lt;br/&gt;
        StorageRandomAccessFile.seek() is called&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;one call to StorageRandomAccessFile.readByte()&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;update current position pointer in LOBFile&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Similar overhead seems to have been added to all the read and write&lt;br/&gt;
methods, and most of it is because we maintain the current position&lt;br/&gt;
pointer for unencrypted lobs. I think most of the overhead could have&lt;br/&gt;
been avoided if LOBFile had used an OO approach with a base class for&lt;br/&gt;
unencrypted lobs and a sub-class for encrypted lobs.&lt;/p&gt;</comment>
                            <comment id="12498587" author="anurag" created="Thu, 24 May 2007 12:17:04 +0100"  >&lt;p&gt;Thanks for the earlier reviews and comments.&lt;/p&gt;

&lt;p&gt;I have separated EncryptedLOBFile to handle encrypted file. Now the LOBFile acts like a wrapper for StorageRandomAccessFile forwarding all calls to  StorageRandomAccessFile.&lt;/p&gt;

&lt;p&gt;I have noticed some failures because I haven&apos;t set path for old version jars. I will run the tests again and will post the results.&lt;/p&gt;</comment>
                            <comment id="12498588" author="anurag" created="Thu, 24 May 2007 12:17:52 +0100"  >&lt;p&gt;Thanks for the earlier reviews and comments.&lt;/p&gt;

&lt;p&gt;I have introduced EncryptedLOBFile and separated code for unencrypted  lob in this. Now the LOBFile is just a wrapper over StorageRandomAccessFile and forwarding all calls to it.&lt;/p&gt;

&lt;p&gt;While running the test I saw some failure because I hadn&apos;t set old jar&apos;s path.&lt;/p&gt;

&lt;p&gt;I will run the tests again and will post the result after that.&lt;/p&gt;</comment>
                            <comment id="12499021" author="anurag" created="Fri, 25 May 2007 11:16:47 +0100"  >&lt;p&gt;i ran the tests again every thing passes except for java.security.AccessControlException in Encryption suite.&lt;/p&gt;</comment>
                            <comment id="12499404" author="knutanders" created="Sun, 27 May 2007 13:58:12 +0100"  >&lt;p&gt;Thanks Anurag! Committed revision 541981.&lt;/p&gt;</comment>
                            <comment id="12499729" author="knutanders" created="Tue, 29 May 2007 09:53:46 +0100"  >&lt;p&gt;Would it be possible to rewrite seek(), setLength() and readByte() in EncryptedLOBFile so that they only called RandomAccessFile.length() once?&lt;/p&gt;</comment>
                            <comment id="12500053" author="knutanders" created="Wed, 30 May 2007 08:56:35 +0100"  >&lt;p&gt;It seems like the patch caused failures in the regression tests on some platforms (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2715&quot; title=&quot;AssertionFailedError in LobStreamsTest and ClobUpdateableReaderTest on WinXP, Win2003&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2715&quot;&gt;&lt;del&gt;DERBY-2715&lt;/del&gt;&lt;/a&gt;). Anurag, could you take a look at it?&lt;/p&gt;</comment>
                            <comment id="12500058" author="knutanders" created="Wed, 30 May 2007 09:13:11 +0100"  >&lt;p&gt;Could this check-in have caused &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2718&quot; title=&quot;BlobClob4BlobTest and LobStreamTest fail creating database due to NullPointerException  on weme 6.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2718&quot;&gt;&lt;del&gt;DERBY-2718&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="12500075" author="anurag" created="Wed, 30 May 2007 10:23:52 +0100"  >&lt;p&gt;seek(), setLength() and readByte() in EncryptedLOBFile to avoid multiple calls to RandomAccessFile.length () method&lt;/p&gt;</comment>
                            <comment id="12500707" author="knutanders" created="Fri, 1 Jun 2007 14:25:42 +0100"  >&lt;p&gt;Thanks Anurag. Committed revision 543483.&lt;/p&gt;</comment>
                            <comment id="12502669" author="myrna" created="Fri, 8 Jun 2007 06:30:11 +0100"  >&lt;p&gt;Is this issue complete? If so, it can be closed. Does it need a release note - i.e. is there existing application impact?&lt;/p&gt;</comment>
                            <comment id="12871071" author="kristwaa" created="Tue, 25 May 2010 10:43:46 +0100"  >&lt;p&gt;Based on the lack of feedback I&apos;m assuming all work has been completed for this issue. It is already resolved as fixed so I&apos;m closing it.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12370414">DERBY-2715</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12354179" name="CosmeticComments_1.txt" size="2489" author="narayanan" created="Mon, 26 Mar 2007 05:22:05 +0100"/>
                            <attachment id="12358514" name="derby-2379-followup.diff" size="2703" author="anurag" created="Wed, 30 May 2007 10:23:52 +0100"/>
                            <attachment id="12352160" name="derby-2379.diff" size="25611" author="anurag" created="Tue, 27 Feb 2007 19:58:45 +0000"/>
                            <attachment id="12357461" name="derby-2379v2-conflict.diff" size="36488" author="anurag" created="Wed, 16 May 2007 12:45:00 +0100"/>
                            <attachment id="12356363" name="derby-2379v2.diff" size="37518" author="anurag" created="Thu, 26 Apr 2007 20:06:35 +0100"/>
                            <attachment id="12357597" name="derby-2379v3.diff" size="37219" author="anurag" created="Fri, 18 May 2007 01:49:29 +0100"/>
                            <attachment id="12358089" name="derby-2379v4.diff" size="40394" author="anurag" created="Thu, 24 May 2007 12:17:52 +0100"/>
                            <attachment id="12358088" name="derby-2379v4.diff" size="40394" author="anurag" created="Thu, 24 May 2007 12:17:04 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 27 Feb 2007 23:35:16 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30408</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0qa7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38076</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>