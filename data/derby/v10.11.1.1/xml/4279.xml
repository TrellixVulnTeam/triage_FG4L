<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:29:12 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4279/DERBY-4279.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4279] Statement cache deadlock</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4279</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Due to a design flaw in the statement cache, a deadlock can occur if a prepared statement becomes out-of-date.&lt;/p&gt;

&lt;p&gt;I will illustrate this with the following example:&lt;/p&gt;

&lt;p&gt;The application is using the embedded Derby driver. The application has two threads, and each thread uses its own connection.&lt;/p&gt;

&lt;p&gt;There is a table named MYTABLE with column MYCOLUMN.&lt;/p&gt;

&lt;p&gt;1. A thread prepares and executes the query SELECT MYCOLUMN FROM MYTABLE. The prepared statement is stored in the statement cache (see org.apache.derby.impl.sql.GenericStatement for this logic)&lt;br/&gt;
2. After some time, the prepared statement becomes invalid or out-of-date for some reason (see org.apache.derby.impl.sql.GenericPreparedStatement)&lt;br/&gt;
3. Thread 1 begins a transaction and executes LOCK TABLE MYTABLE IN EXCLUSIVE MODE&lt;br/&gt;
4. Thread 2 begins a transaction and executes SELECT MYCOLUMN FROM MYTABLE. The statement is in the statement cache but it is out-of-date. The thread begins to recompile the statement. To compile the statement, the thread needs a shared lock on MYTABLE. Thread 1 already has an exclusive lock on MYTABLE. Thread 2 waits.&lt;br/&gt;
5. Thread 1 executes SELECT MYCOLUMN FROM MYTABLE. The statement is in the statement cache but it is being compiled. Thread 1 waits on the statement&apos;s monitor.&lt;br/&gt;
6. We have a deadlock. Derby eventually detects a lock timeout, but the error message is not descriptive. The stacks at the time of the deadlock are:&lt;/p&gt;

&lt;p&gt;This deadlock is unique because it can still occur in a properly designed database. You are only safe if all of your transactions are very simple and cannot be interleaved in a sequence that causes the deadlock, or if your particular statements do not require a table lock to compile. (For the sake of simplicity, I used LOCK TABLE in my example, but any UPDATE statement would fit.)&lt;/p&gt;</description>
                <environment>Windows Vista, OS X 10.5+</environment>
        <key id="12428429">DERBY-4279</key>
            <summary>Statement cache deadlock</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="brettw">Brett Wooldridge</assignee>
                                    <reporter username="stuckman">Jeff Stuckman</reporter>
                        <labels>
                            <label>derby_triage10_5_2</label>
                    </labels>
                <created>Sat, 20 Jun 2009 00:29:37 +0100</created>
                <updated>Wed, 3 Sep 2014 09:31:36 +0100</updated>
                            <resolved>Wed, 12 Sep 2012 18:09:39 +0100</resolved>
                                    <version>10.0.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.2.0</version>
                    <version>10.3.3.0</version>
                    <version>10.4.2.0</version>
                    <version>10.5.1.1</version>
                    <version>10.8.1.2</version>
                                    <fixVersion>10.8.3.0</fixVersion>
                    <fixVersion>10.9.2.2</fixVersion>
                    <fixVersion>10.10.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>7</votes>
                                    <watches>8</watches>
                                                                <comments>
                            <comment id="12722088" author="stuckman" created="Sat, 20 Jun 2009 00:32:48 +0100"  >&lt;p&gt;Output from test case:&lt;/p&gt;

&lt;p&gt;Invalidating the prepared statements...&lt;br/&gt;
Table locked.&lt;br/&gt;
Executing query 1. Query should block because other thread has lock.&lt;br/&gt;
Executing query 2. Query should not block because this thread already has the necessary locks.&lt;br/&gt;
java.sql.SQLTransactionRollbackException: A lock could not be obtained within the time requested&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeQuery(Unknown Source)&lt;br/&gt;
	at Derby4279$Thread2.run(Derby4279.java:81)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
Caused by: java.sql.SQLException: A lock could not be obtained within the time requested&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)&lt;br/&gt;
	... 11 more&lt;br/&gt;
Caused by: ERROR 40XL1: A lock could not be obtained within the time requested&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.xact.RowLocking2.lockContainer(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BaseContainerHandle.useContainer(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BaseDataFileFactory.openContainer(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BaseDataFileFactory.openContainer(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.xact.Xact.openContainer(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.access.conglomerate.OpenConglomerate.init(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.access.heap.Heap.open(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.access.RAMTransaction.openConglomerate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.store.access.RAMTransaction.openConglomerate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ResultColumnList.generateHolderMethod(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.getScanArguments(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.generateResultSet(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.IndexToBaseRowNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ScrollInsensitiveResultSetNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.CursorNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.StatementNode.generate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.rePrepare(Unknown Source)&lt;br/&gt;
	... 5 more&lt;br/&gt;
Query 2 finished.&lt;/p&gt;</comment>
                            <comment id="12722089" author="stuckman" created="Sat, 20 Jun 2009 00:35:28 +0100"  >&lt;p&gt;Test case&lt;/p&gt;</comment>
                            <comment id="12722093" author="stuckman" created="Sat, 20 Jun 2009 00:43:06 +0100"  >&lt;p&gt;One workaround is to set derby.language.statementCacheSize=0. However, the impact of setting this property may be unclear to users because it is not documented. (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4280&quot; title=&quot;Property not documented - derby.language.statementCacheSize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4280&quot;&gt;&lt;del&gt;DERBY-4280&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;</comment>
                            <comment id="12727011" author="dagw" created="Fri, 3 Jul 2009 16:42:25 +0100"  >&lt;p&gt;Triaged for 10.5.2, checking &quot;repro attached&quot;, setting &quot;normal&quot; urgency.&lt;/p&gt;</comment>
                            <comment id="12727015" author="dagw" created="Fri, 3 Jul 2009 16:54:19 +0100"  >&lt;p&gt;Seen back to 10.0.&lt;/p&gt;</comment>
                            <comment id="12877328" author="brettw" created="Thu, 10 Jun 2010 06:43:42 +0100"  >&lt;p&gt;This defect is a major issue for my company and product.  I am submitting a patch to address this defect.  The attached patch is against the 10.6 branch, but I would expect it to equally apply to the trunk.  The description in the initial report by Jeff Stuckman is accurate, please read it before studying the patch.&lt;/p&gt;

&lt;p&gt;Let me explain the patch, and the rationale behind it.  Some familiarity with the code in question is assumed.  Four files where touched:&lt;/p&gt;

&lt;p&gt;org.apache.derby.iapi.sql.PreparedStatement&lt;br/&gt;
org.apache.derby.impl.sql.GenericStatement&lt;br/&gt;
org.apache.derby.impl.sql.GenericActivationHolder&lt;br/&gt;
org.apache.derby.impl.sql.GenericPreparedStatement&lt;/p&gt;

&lt;p&gt;Basically the previous code did this:&lt;/p&gt;

&lt;p&gt;   Block Thread B if it tries to recompile a statement that is being recompiled by Thread A&lt;/p&gt;

&lt;p&gt;This would result in deadlock if Thread A needs the exclusive (DB) lock held by thread B.&lt;/p&gt;

&lt;p&gt;Basically the new code does this:&lt;/p&gt;

&lt;p&gt;   When Thread B tries to recompile a statement AND that statement is currently being recompiled (by another thread), don&apos;t block, simply create a new GenericPreparedStatement and compile that instead.  In essence, this is treated like a &quot;cache miss&quot;.&lt;/p&gt;

&lt;p&gt;At the GenericStatement level, there is no way to know what Storage level locks are being held.  Therefore, blocking Thread B (via a Java lock) while awaiting notification by a thread (Thread A) that might itself be waiting on a Storage level lock held by Thread B is bound to lead to deadlocks in this, and possibly other, scenarios.&lt;/p&gt;

&lt;p&gt;This patch foregoes some &lt;span class=&quot;error&quot;&gt;&amp;#91;extremely&amp;#93;&lt;/span&gt; minor cache efficiencies by treating concurrent recompilation of a statement as a cache miss.  Recompilation by a single thread is not treated as a cache miss, and the code flow is unchanged in that case.  Unless a statement undergoes constant concurrent recompilation (defeating the statement cache anyway), I would expect this change to have an almost immeasurable performance impact on applications.  Certainly compared to the workaround of disabling the statement cache, well, there is no comparison.&lt;/p&gt;

&lt;p&gt;When studying this patch, I recommend reading in this order for clarity:&lt;/p&gt;

&lt;p&gt;1. PreparedStatement&lt;br/&gt;
2. GenericPreparedStatement&lt;br/&gt;
3. GenericActivationHolder&lt;br/&gt;
4. GenericStatement&lt;/p&gt;

&lt;p&gt;PreparedStatement:&lt;br/&gt;
   The interface was changed so that rePrepare() might return a new statement.&lt;/p&gt;

&lt;p&gt;GenericPreparedStatement:&lt;br/&gt;
   In the &quot;rePrepare()&quot; implementation, account for the fact that a new statement may be returned.&lt;/p&gt;

&lt;p&gt;GenericActivationHolder:&lt;br/&gt;
   In execute(), when a PreparedStatement is recognized as invalid and therefore rePrepare()&apos;d, accept the re-prepared statement and use it.  99% of the time, the returned statement will be the same statement as the original.  But in the case of a concurrent re-preparation, a new statement will be returned.&lt;/p&gt;

&lt;p&gt;GenericStatement:&lt;br/&gt;
   in prepMinion(), when we realize were in a &quot;concurrent re-compile&quot; situation, rather than block waiting for the &quot;other thread&quot; to complete recompiling the cached statement, simply create a new GenericPreparedStatement() and compile it instead.  This is where the rubber meets the road, and the deadlock is avoided.&lt;/p&gt;

&lt;p&gt;I ran the &apos;derbyall&apos; test suite, and while I did receive two failures, they seem unrelated to this fix and have more to do with my environment.  I would appreciate someone reviewing the patch, applying it to their system (with a known passing test suite), and running it through a regression test pass.&lt;/p&gt;</comment>
                            <comment id="12877329" author="brettw" created="Thu, 10 Jun 2010 06:45:21 +0100"  >&lt;p&gt;Proposed patch for 4279.&lt;/p&gt;</comment>
                            <comment id="12877365" author="brettw" created="Thu, 10 Jun 2010 09:06:12 +0100"  >&lt;p&gt;Just a further comment.  We see this in a client/server setup.  The original bug mentions the Embedded driver, but because this code in common between the network server and the embedded driver, the issue is the same.&lt;/p&gt;</comment>
                            <comment id="12877407" author="kristwaa" created="Thu, 10 Jun 2010 13:43:09 +0100"  >&lt;p&gt;Hi Brett,&lt;/p&gt;

&lt;p&gt;I had a quick look at your patch, applied it and ran it through suites.All. I see the following error(s):&lt;/p&gt;

&lt;p&gt;testStressMulti(org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest) FAILURE:&lt;br/&gt;
junit.framework.AssertionFailedError: Caused by: &lt;br/&gt;
java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2269)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1321)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:625)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeQuery(EmbedStatement.java:152)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.select(StressMultiTest.java:555)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.run(StressMultiTest.java:429)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	... 12 more&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericActivationHolder.execute(GenericActivationHolder.java:298)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:437)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:320)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	... 5 more&lt;/p&gt;

&lt;p&gt;	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest.handleException(StressMultiTest.java:351)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest.access$200(StressMultiTest.java:70)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.run(StressMultiTest.java:445)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;/p&gt;

&lt;p&gt;testStressMulti(org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest) FAILURE:&lt;br/&gt;
junit.framework.AssertionFailedError: Caused by: &lt;br/&gt;
java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2269)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1321)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:625)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeQuery(EmbedStatement.java:152)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.select(StressMultiTest.java:555)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.run(StressMultiTest.java:429)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	... 12 more&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericActivationHolder.execute(GenericActivationHolder.java:298)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:437)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:320)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	... 5 more&lt;/p&gt;

&lt;p&gt;	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest.handleException(StressMultiTest.java:351)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest.access$200(StressMultiTest.java:70)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.run(StressMultiTest.java:445)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;/p&gt;

&lt;p&gt;I haven&apos;t had the time to investigate this further, others should definitely do so if they think they can contribute &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
A first step would be to verify this error (running the multi.StressMultiTest).&lt;/p&gt;
</comment>
                            <comment id="12877682" author="brettw" created="Fri, 11 Jun 2010 02:28:02 +0100"  >&lt;p&gt;Thanks for the feedback.  Typo in my patch.  In GenericActivationHolder.java I had:&lt;/p&gt;

&lt;p&gt;newPS = (ExecPreparedStatement) ps.rePrepare...&lt;br/&gt;
newGC = ps.getActivationClass();&lt;/p&gt;

&lt;p&gt;When I meant:&lt;/p&gt;

&lt;p&gt;newPS = (ExecPreparedStatement) ps.rePrepare...&lt;br/&gt;
newGC = newPS.getActivationClass();&lt;/p&gt;

&lt;p&gt;I&apos;ve run the multi stress suite, and it now passes without error.  I have updated the patch.&lt;/p&gt;</comment>
                            <comment id="12877683" author="brettw" created="Fri, 11 Jun 2010 02:29:33 +0100"  >&lt;p&gt;Updated patch file (10.6 base)&lt;/p&gt;</comment>
                            <comment id="12877761" author="knutanders" created="Fri, 11 Jun 2010 10:51:25 +0100"  >&lt;p&gt;Hi Brett,&lt;/p&gt;

&lt;p&gt;Thanks for contributing the patch. I think creating a new statement instead of waiting sounds like a reasonable approach to solve this bug.&lt;/p&gt;

&lt;p&gt;I have a couple of questions about the patch:&lt;/p&gt;

&lt;p&gt;1) The synchronized block in GenericActivationHolder.execute() is expanded. What&apos;s the reasoning behind this change?&lt;/p&gt;

&lt;p&gt;2) In GenericStatement, I noticed that the old code that generates a new statement if the session schema is references, sets foundInCache to false to prevent the call to removeStatement() in catch blocks further down. Should we do the same in the new code that checks the value of compilingStatement? I&apos;m not sure if calling removeStatement() on a statement that&apos;s not in the cache does any harm, but I thought I&apos;d mention it in any case.&lt;/p&gt;

&lt;p&gt;3) Since the patch removes the call to wait() on the prepared statement (the only call to wait() as far as I can tell), do you think it would be safe to also remove the calls to notifyAll() in GenericStatement and GenericPreparedStatement?&lt;/p&gt;</comment>
                            <comment id="12877821" author="brettw" created="Fri, 11 Jun 2010 15:35:23 +0100"  >&lt;p&gt;Hi Knut, thanks for taking a look.&lt;/p&gt;

&lt;p&gt;1) The synchronized block in GenericActivationHolder.execute() was actually completely commented out in the original &amp;#8211; but the comment regarding the synchronized block remained.  I&apos;m actually unsure if there is indeed multi-threaded access to GenericActivationHolder &amp;#8211; but I believe there can be.  Because that method replaces several member variables, it seems unsafe to do so outside of the context of a synchronized block.  So, basically I just restored the synchronized block.  If it can be shown that there is no multi-threaded access &amp;#8211; for example because of a lock higher up the call chain, we can certainly remove it.  But being unfamiliar with the Derby codebase in general, I decided to err on the side of caution.&lt;/p&gt;

&lt;p&gt;2) My thinking on removing the statement from the cache was that the new statement is an equal candidate to be cached, and because it was just recompiled the one that does exist in the cache is stale in a sense.&lt;/p&gt;

&lt;p&gt;3) I thought that too.  I think it would indeed be safe to remove to calls to notifyAll(), at least in the case of GenericStatement.&lt;/p&gt;</comment>
                            <comment id="12877841" author="bryanpendleton" created="Fri, 11 Jun 2010 16:59:17 +0100"  >&lt;p&gt;+1 to the strategy of the patch. I think the approach of allowing each caller to prepare&lt;br/&gt;
the statement independently is valid and useful. In this age of multi-core computing,&lt;br/&gt;
I think doing possibly extra work like this in search of higher concurrency (and fewer&lt;br/&gt;
deadlocks) is a good technique.&lt;/p&gt;

&lt;p&gt;I, too, was worried about the patch&apos;s modifications to the synchronized() blocks, so&lt;br/&gt;
I&apos;d like to see that discussion resolved prior to commit.&lt;/p&gt;</comment>
                            <comment id="12878516" author="knutanders" created="Mon, 14 Jun 2010 10:41:21 +0100"  >&lt;p&gt;There&apos;s a smaller synchronized block within the block where the synchronization is commented out (both synchronized on ps). The inner synchronization was added to address &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3260&quot; title=&quot;NullPointerException caused by race condition in GenericActivationHolder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3260&quot;&gt;&lt;del&gt;DERBY-3260&lt;/del&gt;&lt;/a&gt;. The question was raised at that time too, why the synchronization had been commented out in the first place. Since we didn&apos;t know why, we went for the minimum needed to fix that bug. Unless there&apos;s some change in the patch that makes it necessary to synchronize on the entire block, I&apos;d be more comfortable with leaving the synchronization as it is for now. It&apos;s not that I&apos;m 100% convinced the current approach is correct, but if we find problems there, we could address them in a separate issue.&lt;/p&gt;

&lt;p&gt;As to multi-threaded access to GenericActivationHolders, I don&apos;t think that will happen. I believe GenericActivationHolder instances are private to a transaction, and concurrent access will be prevented by synchronization at a higher level. The instance stored in the ps field can however be shared by multiple GenericActivationHolders, and the synchronization is there to give a consistent view of that object&apos;s state.&lt;/p&gt;

&lt;p&gt;Another thing that makes me think we should be careful with adding synchronization here, is that it adds to the problem reported in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3024&quot; title=&quot;Validation of shared plans hurts scalability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3024&quot;&gt;&lt;del&gt;DERBY-3024&lt;/del&gt;&lt;/a&gt;. I did a few runs on a 32-core machine with the test client attached there, and saw a 10-30% performance degradation for various multi-threaded configurations when the patch was applied.&lt;/p&gt;</comment>
                            <comment id="12878726" author="mamtas" created="Mon, 14 Jun 2010 21:14:24 +0100"  >&lt;p&gt;The synchronization was commented out before the code was open sourced.  The change was part of a fix for a java monitor deadlock while running a stress test.  Unfortunately the stress test is no longer available and will not run against the derby codeline.  &lt;/p&gt;

&lt;p&gt;I will attach the original stack trace, but the code has changed quite a bit so the routine names, locations, will have changed.  About the only thing relevant will be the monitor deadlock info.&lt;/p&gt;

&lt;p&gt;Based on this, I do not think we should just go ahead and put the synchronization back into GenericActivationHolder.execute(). &lt;/p&gt;

&lt;p&gt;Does the new fix add any additional need for synchonization?&lt;/p&gt;</comment>
                            <comment id="12878730" author="mamtas" created="Mon, 14 Jun 2010 21:22:31 +0100"  >&lt;p&gt;Attaching the stack trace for the monitor deadlock from a stress test which was seen with Cloudscape release and as a result, the synchornization code was commented.&lt;/p&gt;</comment>
                            <comment id="12878829" author="brettw" created="Tue, 15 Jun 2010 03:22:24 +0100"  >&lt;p&gt;Attached is a new patch with narrowed synchronization in GenericActivationHolder.  Still, the synchronization is not the same as previously because I think that synchronization was wrong.&lt;/p&gt;

&lt;p&gt;The previous code had this logic OUTSIDE of synchronized blocks:&lt;/p&gt;

&lt;p&gt;284     newGC = gc;&lt;br/&gt;
296     BaseActivation newAC = (BaseActivation) newGC.newInstance(lcc);&lt;br/&gt;
298     DataTypeDescriptor[]  newParamTypes = ps.getParameterTypes();&lt;/p&gt;

&lt;p&gt;then later:&lt;br/&gt;
333     ac = newAC;&lt;br/&gt;
334     gc = newGC;&lt;br/&gt;
335     paramTypes = newParamTypes;&lt;br/&gt;
...&lt;br/&gt;
352     return ac.execute();  &amp;lt;-- Particularly dangerous&lt;/p&gt;

&lt;p&gt;These unprotected accesses (both read and write) to member variables shared by multiple threads is inherently dangerous.&lt;/p&gt;

&lt;p&gt;The new patch for GenericActivationHolder takes the approach of copying the member variables into local variables within a synchronized block, and then using those locals throughout.  At the end of the code path where a statement is re-prepared (and a new generated class, activation class, and parameter types created), the member variables are then updated within a synchronized block.&lt;/p&gt;

&lt;p&gt;I believe this approach should eliminate all synchronization issues within the execute() method while minimizing the synchronization windows.&lt;/p&gt;
</comment>
                            <comment id="12878831" author="brettw" created="Tue, 15 Jun 2010 03:39:36 +0100"  >&lt;p&gt;Updated patch with synchronization changes in GenericActivationHolder.&lt;/p&gt;</comment>
                            <comment id="12878886" author="knutanders" created="Tue, 15 Jun 2010 09:31:45 +0100"  >&lt;p&gt;Thanks for digging up this information, Mamta.&lt;/p&gt;

&lt;p&gt;Brett: The way I understand this code, GenericActivationHolder instances are private to a transaction, and therefore only accessed by a single thread (enforced by synchronization in EmbedStatement.execute()). So I think the synchronization on &quot;this&quot; added in the latest patch won&apos;t have any effect.&lt;/p&gt;</comment>
                            <comment id="12879202" author="brettw" created="Wed, 16 Jun 2010 01:24:47 +0100"  >&lt;p&gt;Knut, thanks for the code review.  I have updated the synchronization to synchronize on the ExecPreparedStatement (ps) object thoughout the execute()  method.  If you have time, please review the new uploaded patch.&lt;/p&gt;</comment>
                            <comment id="12879203" author="brettw" created="Wed, 16 Jun 2010 01:25:33 +0100"  >&lt;p&gt;Patch with updated synchronization.&lt;/p&gt;</comment>
                            <comment id="12879293" author="knutanders" created="Wed, 16 Jun 2010 10:48:26 +0100"  >&lt;p&gt;The new synchronized blocks in execute() still only access fields local to GenericActivationHolder, so I&apos;m not sure I understand the need to synchronize on the prepared statement there. I think it would be fine to use the second revision of the patch (the one that fixed the NPE) and change it so that it didn&apos;t uncomment the outer synchronization block.&lt;/p&gt;</comment>
                            <comment id="12879337" author="brettw" created="Wed, 16 Jun 2010 14:38:51 +0100"  >&lt;p&gt;The original still had a synchronized block that synchronized on the prepared statement.  Was it unnecessary?  I&apos;m not so sure...&lt;/p&gt;

&lt;p&gt;One concern is the statement above &quot;GenericActivationHolder instances are private to a transaction&quot;.  Private to a transaction, and private to a thread are two different things.  We run in an XA environment, and theoretically (as far as I understand XA), a transaction can span both connections and threads.&lt;/p&gt;

&lt;p&gt;Another issue, is that, when running with the above patch I am seeing intermittent failures in our server application.  There are multiple threads doing &quot;DELETE FROM&quot; and &quot;INSERT INTO&quot; the same table, and I am seeing an occasional insert failure stating that the insert would cause a primary key violation.&lt;/p&gt;

&lt;p&gt;At this point, I am not sure it is related to the patch or not because our server code has been shifting about as well.  However, a short run using 10.6.1.0 without the patch did not see this particular error.  Because the issue is intermittent, and I unsure whether the cause is the patch or application level code.  Further testing tomorrow should clarify.&lt;/p&gt;

&lt;p&gt;Note that running the derby test suite did not result in any errors.&lt;/p&gt;</comment>
                            <comment id="12879388" author="knutanders" created="Wed, 16 Jun 2010 18:11:51 +0100"  >&lt;p&gt;&amp;gt; The original still had a synchronized block that synchronized on the&lt;br/&gt;
&amp;gt; prepared statement. Was it unnecessary? I&apos;m not so sure...&lt;/p&gt;

&lt;p&gt;The original synchronization block enclosed code that accessed the&lt;br/&gt;
prepared statement, which may be shared between threads. So that&lt;br/&gt;
synchronization should not be removed, I was only talking about the&lt;br/&gt;
synchronization blocks that were added by the patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; One concern is the statement above &quot;GenericActivationHolder instances&lt;br/&gt;
&amp;gt; are private to a transaction&quot;. Private to a transaction, and private&lt;br/&gt;
&amp;gt; to a thread are two different things. We run in an XA environment, and&lt;br/&gt;
&amp;gt; theoretically (as far as I understand XA), a transaction can span both&lt;br/&gt;
&amp;gt; connections and threads.&lt;/p&gt;

&lt;p&gt;In this case, &quot;private to a transaction&quot; meant &quot;private to a local&lt;br/&gt;
Derby transaction&quot;, so XA won&apos;t come into the picture. Still, it&apos;s&lt;br/&gt;
true that a single transaction can run in multiple threads. For&lt;br/&gt;
example, I can prepare a statement in one thread, execute the&lt;br/&gt;
statement in another thread, and commit the transaction in a third&lt;br/&gt;
thread. However, there&apos;s synchronization at a higher level that&lt;br/&gt;
prevents multiple threads from running in the same transaction&lt;br/&gt;
concurrently. This is ensured at the entry points in EmbedConnection,&lt;br/&gt;
EmbedStatement and EmbedResultSet. The engine code therefore safely&lt;br/&gt;
assumes that &quot;private to a transaction&quot; implies &quot;not accessed by&lt;br/&gt;
multiple threads concurrently&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; Another issue, is that, when running with the above patch I am seeing&lt;br/&gt;
&amp;gt; intermittent failures in our server application. There are multiple&lt;br/&gt;
&amp;gt; threads doing &quot;DELETE FROM&quot; and &quot;INSERT INTO&quot; the same table, and I am&lt;br/&gt;
&amp;gt; seeing an occasional insert failure stating that the insert would&lt;br/&gt;
&amp;gt; cause a primary key violation.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; At this point, I am not sure it is related to the patch or not because&lt;br/&gt;
&amp;gt; our server code has been shifting about as well. However, a short run&lt;br/&gt;
&amp;gt; using 10.6.1.0 without the patch did not see this particular&lt;br/&gt;
&amp;gt; error. Because the issue is intermittent, and I unsure whether the&lt;br/&gt;
&amp;gt; cause is the patch or application level code. Further testing tomorrow&lt;br/&gt;
&amp;gt; should clarify.&lt;/p&gt;

&lt;p&gt;Thanks for investigating this further. It would be good to understand&lt;br/&gt;
why you see this error before we proceed with getting the patch into&lt;br/&gt;
the code tree.&lt;/p&gt;

&lt;p&gt;&amp;gt; Note that running the derby test suite did not result in any errors.&lt;/p&gt;

&lt;p&gt;Yes, the regression test suite doesn&apos;t have many multi-threaded tests&lt;br/&gt;
and isn&apos;t good at catching such errors, unfortunately...&lt;/p&gt;</comment>
                            <comment id="12880062" author="brettw" created="Fri, 18 Jun 2010 04:24:59 +0100"  >&lt;p&gt;Thanks for the overview, it was helpful.  I have reverted the synchronization to it&apos;s former state.&lt;/p&gt;

&lt;p&gt;The issue I was seeing with duplicate primary keys turned out to be a Hibernate bug, not related to this patch.  So, I am comfortable going forward with this patch.&lt;/p&gt;

&lt;p&gt;Thanks all for the review.&lt;/p&gt;</comment>
                            <comment id="12880147" author="knutanders" created="Fri, 18 Jun 2010 10:57:16 +0100"  >&lt;p&gt;Thanks Brett! The patch looks good to me. I&apos;ll run the regression tests and intend to commit it if they pass.&lt;/p&gt;</comment>
                            <comment id="12880398" author="bryanpendleton" created="Sat, 19 Jun 2010 02:22:35 +0100"  >&lt;p&gt;+1. The latest version of the patch looks good to me. Thanks Brett for working on this problem.&lt;/p&gt;</comment>
                            <comment id="12880755" author="knutanders" created="Mon, 21 Jun 2010 10:10:50 +0100"  >&lt;p&gt;All the regression tests ran cleanly in my environment. Committed revision 956504.&lt;/p&gt;</comment>
                            <comment id="12880770" author="knutanders" created="Mon, 21 Jun 2010 10:50:10 +0100"  >&lt;p&gt;Perhaps we should try to convert the test case Jeff provided to JUnit and add it to the regression test suite before we close the issue?&lt;/p&gt;</comment>
                            <comment id="12881103" author="kristwaa" created="Tue, 22 Jun 2010 07:59:04 +0100"  >&lt;p&gt;The tinderbox test failed again with the following error in StressTestMulti:&lt;br/&gt;
2010-06-21 16:02:44.542 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_1289,5,derby.daemons&amp;#93;&lt;/span&gt; (XID = 1929067), (SESSIONID = 61), (DATABASE = wombat), (DRDAID = NF000001.P530-869193450946392963&lt;/p&gt;
{30}
&lt;p&gt;), Failed Statement is: null&lt;br/&gt;
java.lang.NullPointerException&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.getMetaData(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.drda.DRDAConnThread.writeSQLDARD(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.drda.DRDAConnThread.processCommands(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.drda.DRDAConnThread.run(Unknown Source)&lt;/p&gt;

&lt;p&gt;It looks suspicious that after the change from returning void to returning a PreparedStatement, the return value is ignored in EmbedPreparedStatement.getMetaData. Is this correct?&lt;/p&gt;

&lt;p&gt;As for the error itself, it has already been reported (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3823&quot; title=&quot;NullPointerException in stress.multi test&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3823&quot;&gt;&lt;del&gt;DERBY-3823&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="12881209" author="brettw" created="Tue, 22 Jun 2010 15:24:05 +0100"  >&lt;p&gt;I need some input here, because I&apos;m wading into unknown waters...&lt;/p&gt;

&lt;p&gt;Certainly, the return value from rePrepare() can be assigned back to preparedStatement on line 1080 ... along the lines of:&lt;/p&gt;

&lt;p&gt;preparedStatement = preparedStatement.rePrepare(lcc);&lt;/p&gt;

&lt;p&gt;But I am concerned about synchronization issues.  While the getMetaData() method itself obtains a lock via:&lt;/p&gt;

&lt;p&gt;synchronized (getConnectionSynchronization())&lt;/p&gt;
{
   ...
}

&lt;p&gt;Many other places in EmbedPreparedStatement access the preparedStatement member variable without such synchronization.  It is safe to assume these other accesses are synchronized by some higher-level lock?&lt;/p&gt;</comment>
                            <comment id="12881214" author="brettw" created="Tue, 22 Jun 2010 15:31:14 +0100"  >&lt;p&gt;Along the same lines, GenericPreparedStatement line 250 (in getActivation()) receives the value of rePrepare() into a local PreparedStatement (post-patch), but only for the purpose of asserting that it didn&apos;t change.  This is also possibly incorrect ... but I&apos;m not sure I grok all of the interactions between GenericPreparedStatement, GeneratedClass, GenericActivationHolder, LanguageConnectionContext, and EmbedPreparedStatement.&lt;/p&gt;

&lt;p&gt;I didn&apos;t encounter any errors in the stressmulti test, and I&apos;m running on an 8-core box, so I am not sure how easily I can validate the robustness of this change.  I may require some assistance, and certainly knowledgable input is welcome.&lt;/p&gt;</comment>
                            <comment id="12882166" author="knutanders" created="Thu, 24 Jun 2010 15:34:06 +0100"  >&lt;p&gt;I haven&apos;t studied the details of this code yet, but the synchronization on getConnectionSynchronization() is probably not enough to ensure safe access to the GenericPreparedStatement. getConnectionSynchronization() is used to ensure that a single connection cannot be executing in two threads at the same time, but one GenericPreparedStatement can be shared between multiple connections.&lt;/p&gt;

&lt;p&gt;Assuming this is the same issue as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3823&quot; title=&quot;NullPointerException in stress.multi test&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3823&quot;&gt;&lt;del&gt;DERBY-3823&lt;/del&gt;&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1635&quot; title=&quot;stress.multi fails on 10.1/ibm131/jcc2.4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1635&quot;&gt;&lt;del&gt;DERBY-1635&lt;/del&gt;&lt;/a&gt; and it is getActivationClass() that returns null, it looks like getMetaData() must have been called when the statement was being recompiled by another thread, and that thread had already called preparedStatement.setActivationClass(null) in GenericPreparedStatement.prepMinion(). I&apos;m not sure if more synchronization is what&apos;s needed to fix this bug, or if the code just needs to handle null returned from getActivationClass(), or perhaps both.&lt;/p&gt;</comment>
                            <comment id="12882853" author="knutanders" created="Sat, 26 Jun 2010 17:51:53 +0100"  >&lt;p&gt;A couple more suspected fallouts of this fix:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mamta added a comment to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4167&quot; title=&quot;NullPointerException in StressMultiTest (testStressMulti) with ibm 1.5 on iseries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4167&quot;&gt;&lt;del&gt;DERBY-4167&lt;/del&gt;&lt;/a&gt; about another NPE in StressMultiTest right after the fix was checked in.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Olav&apos;s nightly performance regression tests (&lt;a href=&quot;http://home.online.no/~olmsan/derby/perf/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://home.online.no/~olmsan/derby/perf/&lt;/a&gt;) have not been able to complete after the check-in. It gets stuck in the multi-threaded delete tests. I&apos;ll investigate and try to isolate the problem.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12882926" author="brettw" created="Sun, 27 Jun 2010 09:00:52 +0100"  >&lt;p&gt;I recommend backing out this fix until synchronization/threading issues have been resolved.&lt;/p&gt;</comment>
                            <comment id="12882984" author="mikem" created="Sun, 27 Jun 2010 20:42:37 +0100"  >&lt;p&gt;I remember when a lot of the original Statement Cache work was being done the original multi stress test was particularly good at showing up issues.  There is a version that I don&apos;t think gets &lt;br/&gt;
run nightly that is even more of a load - StressMulti50x59.java, it runs 50 users for 59 minutes.&lt;br/&gt;
Even then just passing this test once did not really prove anything as the issues often are very&lt;br/&gt;
subtle and timing dependent.  Often we would run this test over and over again as machine resources were available.  This week I will see if we can find a machine to do this but I don&apos;t think&lt;br/&gt;
we have anything more than a couple of processors.&lt;/p&gt;

&lt;p&gt;Running this test on a machine with the most possible processors would be good to verify this&lt;br/&gt;
fix.  &lt;/p&gt;

&lt;p&gt;Does this fix mean that we never wait for an existing query plan?   Does anyone understand what this means about performance for queries that take extremely long to compile.  Unfortunately I have seen plans take many minutes to compile depending on how complex, and some customers often &quot;pre-load&quot; the plans at application startup, set the cache size such that the plan is expected to be in cache.&lt;/p&gt;</comment>
                            <comment id="12883064" author="kristwaa" created="Mon, 28 Jun 2010 09:20:11 +0100"  >&lt;p&gt;Attached &apos;client_stacktrace_activation_closed.txt&apos;, an error that happened a few times when running the test in a loop (&quot;Activation closed, operation execute not permitted&quot;).&lt;br/&gt;
Attaching it for reference, I&apos;m not 100% sure it is valid since the test created a derby.log file of 108GB. This caused my disk to fill up and it was deleted when the process died.&lt;/p&gt;</comment>
                            <comment id="12883081" author="kristwaa" created="Mon, 28 Jun 2010 10:24:01 +0100"  >&lt;p&gt;Another error. I was trying to get a stack trace with line numbers for the getMetaData error, but this popped up instead.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Error/failure logged at Sat Jun 26 06:04:57 CEST 2010&amp;#93;&lt;/span&gt;&lt;br/&gt;
junit.framework.AssertionFailedError: Caused by: &lt;br/&gt;
java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2269)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:614)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeQuery(EmbedStatement.java:152)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.select(StressMultiTest.java:555)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.run(StressMultiTest.java:429)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
        ... 11 more&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(GenericActivationHolder.java:129)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.getActivation(GenericPreparedStatement.java:257)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:609)&lt;br/&gt;
        ... 4 more&lt;/p&gt;

&lt;p&gt;        at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest.handleException(StressMultiTest.java:351)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest.access$200(StressMultiTest.java:70)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.multi.StressMultiTest$StressMultiRunnable.run(StressMultiTest.java:445)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:619)&lt;/p&gt;</comment>
                            <comment id="12883093" author="knutanders" created="Mon, 28 Jun 2010 11:06:49 +0100"  >&lt;p&gt;I&apos;ve backed out the fix from trunk. Committed revision 958529.&lt;/p&gt;</comment>
                            <comment id="12896623" author="myrna" created="Mon, 9 Aug 2010 18:08:36 +0100"  >&lt;p&gt;linking, because when further work is done on this, re-occurrence of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4721&quot; title=&quot;NullPointerException on StressMultiTest in language layer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4721&quot;&gt;&lt;del&gt;DERBY-4721&lt;/del&gt;&lt;/a&gt; needs to be prevented.&lt;/p&gt;</comment>
                            <comment id="13095694" author="brettw" created="Fri, 2 Sep 2011 01:44:03 +0100"  >&lt;p&gt;I am changing this bug back to unassigned.  I have been unable to work on this issue, and leaving it as assigned to me potentially prevents another developer from picking it up.  This is still a major bug, and we still see it in our production server sporadically.&lt;/p&gt;

&lt;p&gt;I hope someone else can pick it up and run with it.  I could suggest looking at the patch here only to gain some understand of the pieces involved &amp;#8211; I think the general approach of the patch may be inherently incorrect.&lt;/p&gt;</comment>
                            <comment id="13108421" author="kristwaa" created="Tue, 20 Sep 2011 08:49:28 +0100"  >&lt;p&gt;Ticked &quot;Seen in production&quot;. See &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5367&quot; title=&quot;Stale data retrieved when using new collation=TERRITORY_BASED:PRIMARY feature&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5367&quot;&gt;&lt;del&gt;DERBY-5367&lt;/del&gt;&lt;/a&gt; (comment of 20/Sep/11 01:22) for an example of a workaround to avoid this bug. To me, that workaround seems like a significant burden for people implementing applications on top of Derby.&lt;/p&gt;</comment>
                            <comment id="13146734" author="brettw" created="Wed, 9 Nov 2011 02:28:40 +0000"  >&lt;p&gt;Funny you mention 5367 and the workaround there.  It was me who opened 5367, and mentioned my workaround.  I guess I should amend my comment there, because just today I discovered that my &quot;workaround&quot; does not in fact work.  It appeared to work, and seems somewhat less likely to trigger this deadlock, but ultimately under load it still encounters this issue.&lt;/p&gt;</comment>
                            <comment id="13146735" author="brettw" created="Wed, 9 Nov 2011 02:32:43 +0000"  >&lt;p&gt;It is inappropriate to offer a &quot;bounty&quot; for this bug?  I&apos;m willing to pay to have this fixed.  The amount of time I&apos;ve spent trying to workaround this issue is ridiculous, and ultimately all such attempts have ended up distorting the readability of the code.&lt;/p&gt;

&lt;p&gt;I am actually stunned that more people are not encountering this bug.  Basically if two (or more) threads are SELECTing and UPDATEing the same table, they WILL hit this issue under load.&lt;/p&gt;</comment>
                            <comment id="13262826" author="chaase3" created="Thu, 26 Apr 2012 19:26:52 +0100"  >&lt;p&gt;If/when this issue is fixed, a documentation JIRA should be filed: the statements made for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4280&quot; title=&quot;Property not documented - derby.language.statementCacheSize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4280&quot;&gt;&lt;del&gt;DERBY-4280&lt;/del&gt;&lt;/a&gt; about setting the statementCacheSize property to 0 should be removed.&lt;/p&gt;</comment>
                            <comment id="13400091" author="brettw" created="Sun, 24 Jun 2012 04:51:59 +0100"  >&lt;p&gt;I&apos;ve been looking at 4279 again today...&lt;/p&gt;

&lt;p&gt;..and thinking of possible solutions, when a question arose.  First and foremost, the deadlock is caused by the fact that preparing a statement requires a table lock (shared) in Derby.  Why is this, technically?  If the requirement that a table lock is needed to prepare a statement can be removed, this deadlock can be&lt;br/&gt;
fixed.&lt;/p&gt;

&lt;p&gt;Alternatively, if the requirement that a table lock is needed cannot be removed, a possible resolution for 4279 is to remove the concept that prepared statements are shared across connections and instead make the statement cache per-connection.  While this increases the memory overhead slightly &amp;#8211; I have to believe that the artifacts of a prepared statement are in fact extremely small &amp;#8211; it removes a lot of shared-cache synchronization code and probably increases concurrency in general.  If you&apos;ve been in that code, the synchronization is pretty hairy (as you can see from the comments in 4279 as well) and there are synchronization blocks in there but commented out for reasons no existing developers can explain.&lt;/p&gt;

&lt;p&gt;In fact, now that I think of it, it would be great if the requirement for a table lock could be removed when preparing a statement AND the cache made per-connection (to simplify the code to a point that humans can understand).&lt;/p&gt;

&lt;p&gt;I understand there is probably an edge case whereby performance would be degraded compared to existing code &amp;#8211; that being a scenario in which connections are created and discarded frequently.  But that is a scenario easily solved by connection re-use, either explicit or by use of a connection pool.&lt;/p&gt;

&lt;p&gt;Thoughts?  I&apos;m willing to put in some work if either of these approaches is acceptable.  I already put in considerable time on 4279 over a year ago, but eventually abandoned it (as you can see in the comments) due to synchronization issues in the shared cache.&lt;/p&gt;</comment>
                            <comment id="13400683" author="mikem" created="Mon, 25 Jun 2012 18:17:45 +0100"  >&lt;p&gt;I have not been following this issue, so not sure of the details and am not an expert in this area of the code but here is what I think.  I assume that Derby is getting a table level &quot;INTENT&quot; shared lock vs a table level &quot;SHARED&quot; lock.  This&lt;br/&gt;
is a very different thing, but for your purposes is causing the same issue.  Intent locks conflict with other table level SHARED AND EXCLUSIVE locks but not with other&lt;br/&gt;
intent locks.&lt;/p&gt;

&lt;p&gt;I think prepare gets these intent locks on the table to insure it gets a consistent view of all the ddl associated with the table that it is compiling.  The main goal is to block other ddl&lt;br/&gt;
from happening during the prepare, the assumption is that ddl and table level share and exclusive locking is rare (obviously this assumption is not working in the case of your&lt;br/&gt;
application.)  I assume more people are not seeing this because most applications do not require table level shared and exclusive access.  Someone with more expertise&lt;br/&gt;
is this area of the code should comment, but I wonder if we could either eliminate this lock or make it much shorter term if we guaranteed to check if ddl had happened&lt;br/&gt;
during the prepare at the very end - a lot of this information is cached so I wonder if the locks are actually doing the work I describe above or if you just need the locks&lt;br/&gt;
short term to consistently populate the caches.  &lt;/p&gt;

&lt;p&gt; Because all the information for a single table is spread across multiple catalogs one may need to do multiple probes to get all the information for a single prepare.&lt;br/&gt;
An example of the kind of bug that has happened in the past is that a prepare produces a plan that is not aware of a new index just added, and a subsequent insert using that&lt;br/&gt;
plan does not update the index and thus results in a corrupt database.&lt;/p&gt;

&lt;p&gt;Sharing plans across connections was a big performance improvement added to derby based on many customer applications and benchmarks.  Derby compile tiime is often very&lt;br/&gt;
slow so anything that can be done to reduce/eliminate that compile time is important. There are a lot of applications out there that are getting performance boosts from the&lt;br/&gt;
shared query cache without even knowing it, and yes they may be able to get similar results with application changes but instead now are gettting it automatically.  So I would&lt;br/&gt;
not support eliminating altogether, but Derby is built on modular concept.  If you wanted to add a change that allowed derby to boot in a mode that did not have a shared&lt;br/&gt;
cache (while still supporting default of a shared cache), that might be a reasonable approach.  Similar to we default to derby working disk based, but allow it to booted with&lt;br/&gt;
a different module that allows it to be memory based.  I know at least the disk page cache is implemented in a module that was designed to be easily replaced, not sure about &lt;br/&gt;
current state of query cache.&lt;/p&gt;</comment>
                            <comment id="13402024" author="brettw" created="Wed, 27 Jun 2012 08:33:58 +0100"  >&lt;p&gt;Okay, here is my second cut a fix...&lt;/p&gt;

&lt;p&gt;First of all, the original report surmised that any DML, not just SELECT, could cause this deadlock.  I myself thought this as well, but it turns out not to be the case.&lt;/p&gt;

&lt;p&gt;There are two places in the statement compilation code where openConglomerate() is called.   All compiled statement nodes ultimately inherit from StatementNode.  In StatementNode.lockTableForCompilation() you will find this logic:&lt;/p&gt;

&lt;p&gt;if (dataDictionary.getCacheMode() == DataDictionary.DDL_MODE)   &amp;lt;=== Important&lt;/p&gt;
{
    ...
    heapCC = tc.openConglomerate(td.getHeapConglomerateId(),
        false,
        TransactionController.OPENMODE_FORUPDATE |
        TransactionController.OPENMODE_FOR_LOCK_ONLY,
        TransactionController.MODE_RECORD,
        TransactionController.ISOLATION_SERIALIZABLE);   &amp;lt;=== Important
    ...
}

&lt;p&gt;The method is preceded with this comment:&lt;/p&gt;

&lt;p&gt;	/* We need to get some kind of table lock (IX here) at the beginning of&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;compilation of DMLModStatementNode and DDLStatementNode, to prevent the&lt;/li&gt;
	&lt;li&gt;interference of insert/update/delete/DDL compilation and DDL execution,&lt;/li&gt;
	&lt;li&gt;see beetle 3976, 4343, and $WS/language/SolutionsToConcurrencyIssues.txt&lt;br/&gt;
	 */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;However, ultimately, according to the logic the lock is only obtained if the DataDictionary is in DDL_MODE.  This is all fine.&lt;/p&gt;

&lt;p&gt;Now to the heart of the issue.  The second place where openConglomerate() is called is in ResultColumnList.generateHolderMethod().  This is used for SELECT statements for columns that will ultimately appear in the ResultSet (or sub-SELECTs in nested queries).  In ResultColumnList.generateHolderMethod() you will find this logic:&lt;/p&gt;

&lt;p&gt;cc = getLanguageConnectionContext().getTransactionCompile().openConglomerate(&lt;br/&gt;
        conglomerateId,&lt;br/&gt;
        false,&lt;br/&gt;
        0,&lt;br/&gt;
        TransactionController.MODE_RECORD,&lt;br/&gt;
        TransactionController.ISOLATION_READ_COMMITTED);   &amp;lt;=== Important&lt;/p&gt;

&lt;p&gt;Notice no conditional logic.  In other words, a lock on the conglomerate is unconditionally obtained.  It is this lock that contends with a table lock that may have been obtained elsewhere (possibly DDL, possibly an explicit lock).  The attached patch changes this code to the following:&lt;/p&gt;

&lt;p&gt;LanguageConnectionContext lcc = getLanguageConnectionContext();&lt;br/&gt;
DataDictionary dd = lcc.getDataDictionary();&lt;br/&gt;
int isolationLevel = (dd.getCacheMode() == DataDictionary.DDL_MODE) ?&lt;br/&gt;
        TransactionController.ISOLATION_READ_COMMITTED : TransactionController.ISOLATION_NOLOCK;&lt;br/&gt;
cc = lcc.getTransactionCompile().openConglomerate(&lt;br/&gt;
        conglomerateId,&lt;br/&gt;
        false,&lt;br/&gt;
        0,&lt;br/&gt;
        TransactionController.MODE_RECORD,&lt;br/&gt;
        isolationLevel);&lt;/p&gt;

&lt;p&gt;Basically, it too checks the DataDictionary to see if it is in DDL_MODE.  If it is, it maintains the same locking level as the existing code.  However, if the DataDictionary is not being modified the code will not obtain a lock.&lt;/p&gt;

&lt;p&gt;What is the impact?  The original code has the effect of blocking DDL from execution by locking the table(s) during this compile phase.  And in turn, if DDL has locked the table(s), the compilation will be blocked.  The first I take to be an unintended side-effect (as you&apos;ll see).&lt;/p&gt;

&lt;p&gt;Let&apos;s take the second case first.  If DDL has occurred (and locked tables), the DataDictionary will be in DDL_MODE, and the new code behaves the same as the old code; the conglomerate is opened with READ_COMMITTED isolation and the compilation will be blocked just as before.&lt;/p&gt;

&lt;p&gt;Now the first case.  If compilation of a statement (that involves ResultColumnList) has started and no DDL is in-progress at that instant, no locks are obtained (because the cache mode is not DDL_MODE).  This is the same as other statement types &lt;span class=&quot;error&quot;&gt;&amp;#91;that extend from StatementNode&amp;#93;&lt;/span&gt;.  If DDL occurs after compilation has started, it will not be blocked (but it was never blocked in all other cases).  Because it was never blocked in other cases (due to the conditional logic), I take this to be a side-effect.  However...&lt;/p&gt;

&lt;p&gt;If DDL does happen to alter the table(s) involved there is already code to handle it.  All roads to ResultColumnList.generateHolderMethod() lead back to GenericStatement.prepare().  GenericStatement.prepare() has this logic fragment:&lt;/p&gt;

&lt;p&gt;try &lt;/p&gt;
{
    return prepMinion(lcc, true, (Object[]) null, (SchemaDescriptor) null, forMetaData);
}
&lt;p&gt; catch (StandardException se) {&lt;br/&gt;
    // There is a chance that we didn&apos;t see the invalidation&lt;br/&gt;
    // request from a DDL operation in another thread because&lt;br/&gt;
    // the statement wasn&apos;t registered as a dependent until&lt;br/&gt;
    // after the invalidation had been completed. Assume that&apos;s&lt;br/&gt;
    // what has happened if we see a conglomerate does not exist&lt;br/&gt;
    // error, and force a retry even if the statement hasn&apos;t been&lt;br/&gt;
    // invalidated.&lt;br/&gt;
    if (SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST.equals(se.getMessageId())) &lt;/p&gt;
{
        ... recompile ...
    }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;So, even though the compile of a SELECT will no longer block DDL from occurring (remember UPDATE, DELETE, and all other DML never blocked it anyway) there is code in-place to handle the possibility that openConglomerate() in StatementNode or ResultColumnList might fail.  In that case, the compile is given one more shot before failing (recompile = true).&lt;/p&gt;

&lt;p&gt;It is debatable now that the logic in ResultColumnList is the same as StatementNode, whether the isolation in ResultColumnList should also be ISOLATION_SERIALIZABLE like StatementNode given that it is now also conditional based on DataDictionary.getCacheMode() == DDL_MODE.  However, my approach was to be least impacting in terms of deviation from current known working code.&lt;/p&gt;

&lt;p&gt;On a final note, this patch obviously fixed the test case attached to this issue, however past attempts to fix this bug did the same but ultimately failed in some of the long running stress tests.  It would be helpful if this patch could be applied and let run through the usual full barrage of tests.  That said, the previous patch attempted to fix the issue at the statement cache level with all of it&apos;s hairy synchronization.  This patch is considerably simpler both conceptually and implementation-wise.&lt;/p&gt;</comment>
                            <comment id="13402147" author="kristwaa" created="Wed, 27 Jun 2012 12:32:11 +0100"  >&lt;p&gt;Thanks for your continued effort on this problem, Brett.&lt;/p&gt;

&lt;p&gt;Without having reviewed the approach used in the patch thoroughly, I can say that suites.All and derbyall passed with the patch applied in my environment.&lt;/p&gt;

&lt;p&gt;BW&amp;gt; So, even though the compile of a SELECT will no longer block DDL from occurring &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m not convinced this is true. There&apos;s another mechanism in place in the data dictionary (DD) to stop that from happening. For a DDL operation to be allowed, there can&apos;t be any ongoing compilations. Note that the opposite isn&apos;t the case; compilations can occur even though a DDL is in progress. In the latter case the system catalogs are queried directly instead of going through the/a cache.&lt;/p&gt;

&lt;p&gt;Now, this mechanism relies on several state objects and is a bit complicated so I&apos;m not 100% sure I&apos;m correct. The methods startReading/doneReading and startWriting/transactionFinished in DataDictionaryImpl are good starting points to investigate this further. Note the use of the lock and the relevant counters.&lt;/p&gt;</comment>
                            <comment id="13402191" author="brettw" created="Wed, 27 Jun 2012 13:43:38 +0100"  >&lt;p&gt;Kristian,&lt;/p&gt;

&lt;p&gt;You might be right, I could be mistaken about a SELECT not blocking DDL.  Be that as it may, this defect here is only tangential to DDL, and as the testcase shows, the deadlock occurs without any DDL per se.  Just simple table-locking.  As to whether this change could adversely affect DDL that is run concurrently with queries &amp;#8211; such as it used to block it but now doesn&apos;t, I am not sure.  I don&apos;t have a test that runs DDL concurrently with queries, do you know if any of the standard tests or stress tests do that?&lt;/p&gt;</comment>
                            <comment id="13402899" author="kristwaa" created="Thu, 28 Jun 2012 08:19:04 +0100"  >&lt;p&gt;Brett,&lt;/p&gt;

&lt;p&gt;I think store.AutomaticIndexStatisticsMultiTest may test this scenario.&lt;br/&gt;
My point was not to claim that there is something wrong with the patch, but rather to point out that I believe there is another mechanism in place that will block DDL if a compilation is taking place. Your patch doesn&apos;t change anything wrt that mechanism.&lt;/p&gt;


&lt;p&gt;Now, looking at that second call to openConglomerate it seems to me it&apos;s being done only to obtain a row location template. Only heaps can create row location objects. A heap row location template is nothing but a Java object wrapping a few primitive values that haven&apos;t been set. I don&apos;t immediately see why the conglomerate/heap even has to be open to obtain such an object, but maybe the restriction was put in place for a good reason (anyone?).&lt;/p&gt;

&lt;p&gt;I&apos;m optimistic that the approach in the patch is sound. The question is if obtaining the lock can cause problems in DDL mode, and if we can skip taking it in that mode too. However, I haven&apos;t dug deep enough to understand the locking code. Can anyone with more experience in that area see if not taking the lock in RCL.generateHolderMethod has consequences the code isn&apos;t prepared to handle?&lt;/p&gt;</comment>
                            <comment id="13402921" author="kristwaa" created="Thu, 28 Jun 2012 09:10:42 +0100"  >&lt;p&gt;As an experiment I ran the JUnit regression tests with the patch &apos;no-lock-experiment.diff&apos;. It just hardcodes the use of a HeapRowLocation instead of opening the conglomerate and getting a lock.&lt;/p&gt;

&lt;p&gt;The tests completed without any errors.&lt;br/&gt;
The problem is I don&apos;t really know if all aspects of the change has been tested, and since most of the tests are single-threaded having these tests pass doesn&apos;t really give me that much confidence about the change.&lt;/p&gt;</comment>
                            <comment id="13403101" author="brettw" created="Thu, 28 Jun 2012 14:51:30 +0100"  >&lt;p&gt;Kristian,&lt;/p&gt;

&lt;p&gt;None of this is documented obviously, but here is my best guess why that code is the way that it is.  Trying to open the conglomerate acts as a check that the schema has not been modified by another thread/transaction.  There may be other locks in place, as you mentioned, that attempt to prevent DDL run running but my guess is there are still &apos;seams&apos; where it can happen.  Hence the opening of the conglomerate, and note also (especially) the comments in the try...catch in GenericStatement.prepare() where the StandardException is caught and explicitly checked for an error.  The comment is:&lt;/p&gt;

&lt;p&gt;    // There is a chance that we didn&apos;t see the invalidation &lt;br/&gt;
    // request from a DDL operation in another thread because &lt;br/&gt;
    // the statement wasn&apos;t registered as a dependent until &lt;br/&gt;
    // after the invalidation had been completed.  Assume that&apos;s &lt;br/&gt;
    // what has happened if we see a conglomerate does not exist &lt;br/&gt;
    // error...&lt;/p&gt;

&lt;p&gt;Which implies to me that DDL might not always be blocked, and code was put in place to handle that case.  Since DDL is rare in a running system, catching an exception might therefore be much cheaper than some kind of read/write lock to try to prevent it.&lt;/p&gt;

&lt;p&gt;The other possibility is that DDL and DML are completely protected/synchronized now (compared to when that code was written), and some of that code is simply unnecessary.  I&apos;m not in a position to make that judgement.  Hence my attempt to retain as much as of the original behavior, be it inefficient or not, to minimize side-effects.&lt;/p&gt;

&lt;p&gt;I would be perfectly happy with the patch as submitted along with additional comments in the code basically asking &apos;Is the still necessary?&apos; with a reference to this bug.  Maybe at some point in the future someone digging through the code will unravel the logic completely and determine that &apos;yes, it is necessary&apos; or &apos;no, it is not&apos;.&lt;/p&gt;</comment>
                            <comment id="13403353" author="mikem" created="Thu, 28 Jun 2012 19:46:29 +0100"  >&lt;p&gt;commenting on RowLocation.  The system is designed such that one could implement multiple types of conglomerates.  Currently there are only 2 types, btree and heap - but a lot of structure to allow for more.  So in keeping with this callers know they need a RowLocation but it is up to each implementation to provide the &quot;hidden&quot; actual implementation, in this case the HeapRowLocation.  Getting&lt;br/&gt;
this row location from an open conglomerate seemed a natural place as almost all work with a conglomerate already has an open conglomerate of some sort. &lt;/p&gt;

&lt;p&gt;If it helps to not have to open a conglomerate to get this RowLocation then it would be best to just add a new interface.  I think code could be written to just return the right kind of RowLocation based&lt;br/&gt;
on the conglomerate id.  At least with the current conglomerate inplementations there is nothing ddl related that would change the RowLocation object returned.  There might be future implementations&lt;br/&gt;
that might require a lock, but I would just add comments about the current problems with getting locks in this operation and the JIRA issue and let future implementers think about that.  &lt;/p&gt;

&lt;p&gt;New interface would look something like:  TransactionController.newRowLocationTemplate(conglomerateId)&lt;/p&gt;

&lt;p&gt;If it looks like this is needed let me know, I would be happy to submit a patch with this new interface - if the testing shows this to be helpful.&lt;/p&gt;</comment>
                            <comment id="13403846" author="kristwaa" created="Fri, 29 Jun 2012 12:45:03 +0100"  >&lt;p&gt;Thanks for sharing your knowledge on this, Mike.&lt;br/&gt;
The way I see it, the demand for a new interface is not strong enough based on this particular case only. It would be if it turns out using the existing interface is too costly performance-wise, but we don&apos;t have any data/indications on that.&lt;/p&gt;

&lt;p&gt;For now I&apos;d be content with using Brett&apos;s patch with ISOLATION_NOLOCK (assuming it does what it implies). It would be good to determine if we can use ISOLATION_NOLOCK in this particular case also when the dictionary is in DDL-mode (see comment below on the DD mode), but that can be done as a separate step.&lt;/p&gt;

&lt;p&gt;One more comment on the DD modes.&lt;br/&gt;
If the DD is in compile only mode and a compilation is in progress, then no DDL will take place.&lt;br/&gt;
If the DD is in DDL mode and a compilation starts, then the compilation may be performed concurrently with DDL.&lt;/p&gt;</comment>
                            <comment id="13403869" author="brettw" created="Fri, 29 Jun 2012 13:31:35 +0100"  >&lt;p&gt;Kristian and Mike,&lt;/p&gt;

&lt;p&gt;Thanks for both of your inputs on this issue.  It&apos;s been nagging me for 2 years now, I&apos;ll be glad to see it buried.  Let me know if there is anything else I can do.&lt;/p&gt;</comment>
                            <comment id="13404148" author="mamtas" created="Fri, 29 Jun 2012 20:41:41 +0100"  >&lt;p&gt;I am not familiar with the synchronization code during stale prepared statement re-compile. But I was looking at the first patch submitted by Brett and suggestion by Knut about statements using session schema and how they do not get saved in the statement cache. &lt;/p&gt;

&lt;p&gt;I worked on statements involving session schema many years back and recall implementing logic which will prevent such statements from going into statement cache. &lt;/p&gt;

&lt;p&gt;Will a similar logic for this jira help with all the synchronization issues we are dealing with? ie, if a thread finds that the prepared statement is already in cache but it is being compiled by another thread, then go ahead and create a new GenericPreparedStatement and compile that instead(same as if the statement never existed in the cahce), BUT do not save this new statement in the statement cache(just like a statement referencing session schema). So, this newly compiled statement will not be available to any other thread. But that should be fine because original preapred statement in the cache is already getting compiled and hence it will be available to other threads in future. Like Brett mentioned, &quot;Unless a statement undergoes constant concurrent recompilation (defeating the statement cache anyway)&quot;, throwing away a compiled statement after use by a thread if that thread finds previously compiled statement in invalid state and getting compiled by another thread should not be a big overhead.&lt;/p&gt;

&lt;p&gt;I am not sure if creating a GenericPreparedStatement for use by just one thread will solve the synchronization problem in this jira but I wanted to put it out anyways in case if this approach helps.&lt;/p&gt;</comment>
                            <comment id="13404390" author="brettw" created="Sat, 30 Jun 2012 05:52:04 +0100"  >&lt;p&gt;Mamta,&lt;/p&gt;

&lt;p&gt;Thanks for your feedback.  From an efficiency point of view, I think your suggestion (and my initial attempt at a bug fix) is a good approach in general.  As Bryan Pendleton commented earlier,&lt;/p&gt;

&lt;p&gt;&quot;I think the approach of allowing each caller to prepare the statement independently is valid and useful. In this age of multi-core computing, I think doing possibly extra work like this in search of higher concurrency (and fewer deadlocks) is a good technique.&quot;&lt;/p&gt;

&lt;p&gt;I would however like to do that work under another bug (enhancement), as I think the most recent patch to fix this bug is both sufficient and correct to address this bug per se.  When this change has been accepted, I&apos;ll open another bug under which to do work on concurrency.&lt;/p&gt;</comment>
                            <comment id="13411448" author="brettw" created="Wed, 11 Jul 2012 13:56:09 +0100"  >&lt;p&gt;Can somebody with checkin privileges commit this patch?  It is complete as far as I am concerned.&lt;/p&gt;</comment>
                            <comment id="13419085" author="kristwaa" created="Fri, 20 Jul 2012 13:30:35 +0100"  >&lt;p&gt; I&apos;ve just returned from vacation, and I&apos;ll to do that over the week end. I want to check a few last things before committing.&lt;/p&gt;</comment>
                            <comment id="13422261" author="kristwaa" created="Wed, 25 Jul 2012 14:39:41 +0100"  >&lt;p&gt;From what I can see, the lock, which is a &quot;container intention read lock&quot; (CIS), is released as soon as the controller is closed. I observed this by tracing the locks (derby.debug.true=LockTrace + a custom message to the log to navigate in derby.log). This is a very short time-span, and it happens independently of the isolation level of the transaction (separate sub-transaction for compilation?). Once my test-run has completed I will commit the patch.&lt;/p&gt;

&lt;p&gt;If we observe the deadlock also when the mode is DDL_MODE I don&apos;t see why we can&apos;t use NO_LOCK in all cases, since the code appears to be prepared to handle that the conglomerate is dropped under its feet. However, it seems safer to me to keep the change minimal for the time being.&lt;/p&gt;</comment>
                            <comment id="13422393" author="kristwaa" created="Wed, 25 Jul 2012 17:39:40 +0100"  >&lt;p&gt;Committed patch &apos;derby4279_2.txt&apos; to trunk with revision 1365661.&lt;br/&gt;
I plan to backport this patch in a while.&lt;/p&gt;</comment>
                            <comment id="13422398" author="kristwaa" created="Wed, 25 Jul 2012 17:42:02 +0100"  >&lt;p&gt;Think I just found another keyboard shortcut or something... Reassigning back to Brett.&lt;/p&gt;</comment>
                            <comment id="13435837" author="kristwaa" created="Thu, 16 Aug 2012 09:26:19 +0100"  >&lt;p&gt;Backported the fix to 10.9 with revision 1373749.&lt;br/&gt;
The fix is pretty isolated, it may be possible to port it further back if anyone sees the need for that.&lt;/p&gt;

&lt;p&gt;Issue ready for verification/closing.&lt;/p&gt;</comment>
                            <comment id="13449992" author="forcers" created="Thu, 6 Sep 2012 20:54:56 +0100"  >&lt;p&gt;I don&apos;t think this fix is in 10.9.1.0.  If not, any idea when 10.9.1.1 will be released? &lt;/p&gt;</comment>
                            <comment id="13453872" author="kristwaa" created="Wed, 12 Sep 2012 10:56:52 +0100"  >&lt;p&gt;Reopening for back-port to the 10.8 branch (with 10.8.3 as a potential release vehicle).&lt;/p&gt;</comment>
                            <comment id="13454131" author="kristwaa" created="Wed, 12 Sep 2012 18:09:39 +0100"  >&lt;p&gt;Back-ported fix to 10.8 with revision 1384037. I don&apos;t plan to go further back.&lt;/p&gt;

&lt;p&gt;Regarding a 10.9 maintenance release, I haven&apos;t seen anyone come forward to be release manager so I guess there are no plans right now.&lt;br/&gt;
It appears a 10.8 maintenance release is being planned, although no information has been added to the wiki yet.&lt;/p&gt;</comment>
                            <comment id="14119605" author="knutanders" created="Wed, 3 Sep 2014 09:31:36 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12552109">DERBY-5703</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12468091">DERBY-4721</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12411287" name="Derby4279.java" size="3252" author="stuckman" created="Sat, 20 Jun 2009 00:35:28 +0100"/>
                            <attachment id="12448187" name="client_stacktrace_activation_closed.txt" size="2336" author="kristwaa" created="Mon, 28 Jun 2010 09:20:11 +0100"/>
                            <attachment id="12533789" name="no-lock-experiment.diff" size="1977" author="kristwaa" created="Thu, 28 Jun 2012 09:10:42 +0100"/>
                            <attachment id="12447427" name="patch4279.txt" size="8691" author="brettw" created="Fri, 18 Jun 2010 04:24:59 +0100"/>
                            <attachment id="12533615" name="patch4279_2.txt" size="1198" author="brettw" created="Wed, 27 Jun 2012 08:33:58 +0100"/>
                            <attachment id="12447063" name="stacktrace.txt" size="36993" author="mamtas" created="Mon, 14 Jun 2010 21:22:31 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10421"><![CDATA[Seen in production]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 3 Jul 2009 15:42:25 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24151</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0a3r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35455</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>