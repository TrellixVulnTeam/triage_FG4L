<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:54:07 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3172/DERBY-3172.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3172] ConnectionEventListener.connectionErrorOccurred not being executed when SQLState 08006 Error is thrown</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3172</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The attached program demonstrates the problem.  Using the ClientConnectionPoolDataSource40 with a connectionEventListener the defined method connectionErrorOccurred is not executed after the Network Server is shutdown and activity is performed on a previously established pooled connection.&lt;/p&gt;

&lt;p&gt;Program also demonstrates that the connectionClosed method is executed when the connection is closed.&lt;/p&gt;

&lt;p&gt;To run the reproduction:&lt;br/&gt;
1) start network server (listening on default host/port and  -noSecurityManager specified)&lt;br/&gt;
2) run the program&lt;/p&gt;

&lt;p&gt;Output is:&lt;br/&gt;
 &amp;gt; java DerbyNotification2&lt;br/&gt;
10.3.1.5 - (579866)&lt;/p&gt;

&lt;p&gt;Apache Derby&lt;br/&gt;
 .got connection...check if connectionClosed method is called&lt;br/&gt;
EVENT CALLED: Connection closed happened&lt;br/&gt;
 . . .&lt;br/&gt;
 . . .Get connection and issue test SQL statement&lt;br/&gt;
 . . .AS EXPECTED: no table exists&lt;br/&gt;
 . SHUTDOWN Network server and check if connectionErrorOccurred is called&lt;br/&gt;
now try to use the connection after the NS is STOPPED&lt;br/&gt;
SQLState is: 08006&lt;br/&gt;
Error is: -4499&lt;br/&gt;
Message is: Insufficient data while reading from the network - expected a minimum of 6 bytes and received only -1 bytes.  The connection has been terminated.&lt;br/&gt;
Exception in thread &quot;main&quot; java.sql.SQLNonTransientConnectionException: Insufficient data while reading from the network - expected a minimum of 6 bytes and received only -1 bytes.  The connection has&lt;br/&gt;
 been terminated.&lt;br/&gt;
        at org.apache.derby.client.am.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.SqlException.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.Connection.prepareStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.LogicalConnection.prepareStatement(Unknown Source)&lt;br/&gt;
        at DerbyNotification2.runTest(DerbyNotification2.java:64)&lt;br/&gt;
        at DerbyNotification2.main(DerbyNotification2.java:87)&lt;br/&gt;
Caused by: org.apache.derby.client.am.DisconnectException: Insufficient data while reading from the network - expected a minimum of 6 bytes and received only -1 bytes.  The connection has been termina&lt;br/&gt;
ted.&lt;br/&gt;
        at org.apache.derby.client.net.Reply.fill(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.net.Reply.ensureALayerDataInBuffer(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.net.Reply.readDssHeader(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.net.Reply.startSameIdChainParse(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementReply.readPrepareDescribeOutput(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.net.StatementReply.readPrepareDescribeOutput(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatement.readPrepareDescribeOutput_(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.Statement.readPrepareDescribeOutput(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.readPrepareDescribeInputOutput(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.flowPrepareDescribeInputOutput(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.prepare(Unknown Source)&lt;br/&gt;
        at org.apache.derby.client.am.Connection.prepareStatementX(Unknown Source)&lt;br/&gt;
        ... 4 more&lt;/p&gt;</description>
                <environment></environment>
        <key id="12381670">DERBY-3172</key>
            <summary>ConnectionEventListener.connectionErrorOccurred not being executed when SQLState 08006 Error is thrown</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="stan">Stan Bradbury</reporter>
                        <labels>
                    </labels>
                <created>Fri, 2 Nov 2007 01:26:02 +0000</created>
                <updated>Thu, 24 Jan 2008 22:57:35 +0000</updated>
                            <resolved>Tue, 27 Nov 2007 19:26:55 +0000</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.2.1</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12540862" author="mamtas" created="Wed, 7 Nov 2007 19:50:23 +0000"  >&lt;p&gt;I investigated this Jira issue and following is what I found along with a proposed solution at the end.&lt;/p&gt;

&lt;p&gt;Consider following piece of code In embedded mode, &lt;br/&gt;
      EmbeddedConnectionPoolDataSource ds =&lt;br/&gt;
         new EmbeddedConnectionPoolDataSource();&lt;br/&gt;
      ((EmbeddedConnectionPoolDataSource)ds).setDatabaseName(&quot;c:/dellater/derby_3172_embedded;create=true&quot;);&lt;/p&gt;

&lt;p&gt;        PooledConnection pooledCon = ds.getPooledConnection();&lt;br/&gt;
        pooledCon.addConnectionEventListener(this);&lt;br/&gt;
        Connection conn = pooledCon.getConnection();&lt;/p&gt;

&lt;p&gt;        try&lt;/p&gt;
        {
                Class.forName(&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;); 
                String url = &quot;jdbc:derby:c:/dellater/derby_3172_embedded;shutdown=true&quot;;
                Connection c = DriverManager.getConnection(url);        		
        }
&lt;p&gt;        catch (Exception e)&lt;/p&gt;
        {
               System.out.println(&quot;Exception shutting down Network Server&quot;);
        }

&lt;p&gt;The shutdown above throws&quot;Database &apos;c:/dellater/derby_3172_embedded&apos; shutdown.&quot; exception but the connection event listener does not get any events at this point. Continuing the eg above with following &lt;br/&gt;
        PrepareStatement ps1 = conn.prepareStatement(&quot;CREATE TABLE TAB1(COL1 INT NOT NULL)&quot;);&lt;br/&gt;
The above statement throws an exception(SQLState 08003 No current connection.). But before throwing the exception, the connection event listener gets an event about connection error. This part is missing when similar code is tried in Network Server.&lt;/p&gt;

&lt;p&gt;Consider similar eg for Network Server code&lt;br/&gt;
        ClientConnectionPoolDataSource ds =&lt;br/&gt;
             new ClientConnectionPoolDataSource();&lt;br/&gt;
         ((ClientConnectionPoolDataSource)ds).setDatabaseName(&quot;c:/dellater/derby_3172_embedded;create=true&quot;);&lt;/p&gt;

&lt;p&gt;        PooledConnection pooledCon = ds.getPooledConnection();&lt;br/&gt;
        pooledCon.addConnectionEventListener(this);&lt;br/&gt;
        Connection conn = pooledCon.getConnection();&lt;/p&gt;

&lt;p&gt;        NetworkServerControl server = new NetworkServerControl();&lt;br/&gt;
        server.shutdown();        		&lt;br/&gt;
        PrepareStatement ps1 = conn.prepareStatement(&quot;CREATE TABLE TAB1(COL1 INT NOT NULL)&quot;);&lt;br/&gt;
When the code above is run in Network Server mode, shutdown of Network Server does not throw any exception to the client. But when the program gets to conn.prepareStatement, following exception(SQLState 08006) is thrown as expected&lt;br/&gt;
	A communications error has been detected: Software caused connection abort: recv failed.&lt;br/&gt;
*****But no connection event error is received by the connection event listener. *****&lt;/p&gt;

&lt;p&gt;The difference in code that I find between client driver and embedded driver is following&lt;br/&gt;
iapi.jdbc.BrokeredConnection in embedded catches the exception about no current connection and notifies the listeners as follows&lt;br/&gt;
	public final PreparedStatement prepareStatement(String sql)&lt;br/&gt;
	    throws SQLException &lt;br/&gt;
	{&lt;br/&gt;
		try &lt;/p&gt;
{
			return control.wrapStatement(getRealConnection().prepareStatement(sql), sql, null);
		}
&lt;p&gt; catch (SQLException sqle) &lt;/p&gt;
{
			notifyException(sqle);
			throw sqle;
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;But on the client side in client.am.LogicalConnection has following code (ie it does not do anything with SQLException that it receives)&lt;br/&gt;
    synchronized public java.sql.PreparedStatement prepareStatement(String sql) throws SQLException &lt;/p&gt;
{
        checkForNullPhysicalConnection();
        return physicalConnection_.prepareStatement(sql);
    }

&lt;p&gt;I think to solve the problem, we need to have try catch in prepareStatement method on the client side and send event to the listeners through pooledConnection_. We do something similar in close() method on the client side. I think this needs to be done for all JDBC methods implemented in client.am.LogicalConnection. Let me know if anyone has any thoughts on this approach. I will start looking at implementing this soon.&lt;/p&gt;</comment>
                            <comment id="12540896" author="mamtas" created="Wed, 7 Nov 2007 21:06:19 +0000"  >&lt;p&gt;I was thinking about junit testing for the proposed fix and having 2 test cases. 1)For Network Server, shutdown the database and see if listener gets the connection error event when the user tries to communicate to Network Server 2)Shutdown Derby engine and see if the listener gets the connection error event when the user tries to talk to Derby engine.&lt;/p&gt;

&lt;p&gt;I was wondering how would I shut down the Network server and Derby engine inside junit framework. Maybe some of the existing junit tests do that already. I will try to hunt them down. But in the mean time, if someone knows how to shut down the Network server and Derby engine inside junit framework, I would appreciate that information.&lt;/p&gt;</comment>
                            <comment id="12540925" author="mkutty" created="Wed, 7 Nov 2007 23:21:57 +0000"  >&lt;p&gt;There is this test called ShutdownDatabaseTest.java in lang which does the shutdown of derby engine.&lt;/p&gt;</comment>
                            <comment id="12540934" author="mamtas" created="Thu, 8 Nov 2007 00:19:22 +0000"  >&lt;p&gt;Thanks, Manjula. I will look at it for embedded test case.&lt;/p&gt;</comment>
                            <comment id="12541091" author="mamtas" created="Thu, 8 Nov 2007 17:49:20 +0000"  >&lt;p&gt;While working on this issue, I found that when a JCBC Connection is already closed and user attempts to close it again, in embedded mode, the driver simply returns from the method *&lt;b&gt;without&lt;/b&gt;* sending a notification to the ConnectionEventListener. Following is the code for close() in iapi.jdbc.BrokeredConnection&lt;br/&gt;
public final void close() throws SQLException &lt;br/&gt;
{ &lt;br/&gt;
	if (isClosed)&lt;br/&gt;
		return;&lt;br/&gt;
	try {&lt;br/&gt;
		if (!control.closingConnection()) &lt;/p&gt;
{
			isClosed = true;
			return;
		}
&lt;p&gt;		isClosed = true;&lt;/p&gt;

&lt;p&gt;		getRealConnection().close();&lt;br/&gt;
	} catch (SQLException sqle) &lt;/p&gt;
{
		notifyException(sqle);
		throw sqle;
	}
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;But in the client driver side, if a Connection object is already closed, then next attempt to close it send connectionErrorOccurred to the listeners.  Following is the code for close() in client.am.LogicalConnection&lt;br/&gt;
    synchronized public void close() throws SQLException {&lt;br/&gt;
        try&lt;br/&gt;
        {&lt;br/&gt;
            // we also need to loop thru all the logicalStatements and close them&lt;br/&gt;
            if (physicalConnection_ == null) &lt;/p&gt;
{
                return;
            }
&lt;p&gt;            if (physicalConnection_.agent_.loggingEnabled()) &lt;/p&gt;
{
                physicalConnection_.agent_.logWriter_.traceEntry(this, &quot;close&quot;);
            }

&lt;p&gt;            if (physicalConnection_.isClosed()) // connection is closed or has become stale&lt;br/&gt;
            &lt;/p&gt;
{
                pooledConnection_.trashConnection(new SqlException(null, 
                    new ClientMessageId(
                        SQLState.PHYSICAL_CONNECTION_ALREADY_CLOSED)));
            }
&lt;p&gt; else {&lt;br/&gt;
                physicalConnection_.closeForReuse();&lt;br/&gt;
                if (!physicalConnection_.isGlobalPending_()) &lt;/p&gt;
{
                    pooledConnection_.recycleConnection();
                }
&lt;p&gt;            }&lt;br/&gt;
            physicalConnection_ = null;&lt;br/&gt;
            pooledConnection_.nullLogicalConnection();&lt;br/&gt;
        }&lt;br/&gt;
        catch ( SqlException se )&lt;/p&gt;
        {
            throw se.getSQLException();
        }
&lt;p&gt;    }&lt;/p&gt;


&lt;p&gt;I am not sure why we have this difference in behavior between the 2 drivers. I will make the client driver match the behavior of embedded driver ie do not send any events if close is being called on a closed Connection object. Please let me know if anyone has objections to this.&lt;/p&gt;</comment>
                            <comment id="12541095" author="mamtas" created="Thu, 8 Nov 2007 18:19:16 +0000"  >&lt;p&gt;After a quick talk with Dan, I realize that the embedded driver behavior is correct. The JDBC api for close() says &quot;Calling the method close on a Connection object that is already closed is a no-op.&quot; And that is what the embedded driver is doing. &lt;/p&gt;

&lt;p&gt;I will go ahead and change the client&apos;s behavior so that we do not send any connection error event when close is called on a closed connection object.&lt;/p&gt;</comment>
                            <comment id="12541161" author="mamtas" created="Thu, 8 Nov 2007 22:38:56 +0000"  >&lt;p&gt;On further investigation, it seems that in client server mode, we are changing the exception&apos;s severity code from session severity to some DRDA severity and that causes the connection error event to not trigger even with my local code changes. &lt;/p&gt;

&lt;p&gt;The exception that gets thrown when Network Server is down is &lt;br/&gt;
    String COMMUNICATION_ERROR                                  = &quot;08006.C.3&quot;;&lt;br/&gt;
derby,shared.common.error.ExceptionUtil.java uses 08006 and determines the severity code to be session severity. So far so good. But later derby.client.am.SqlException changes the severity code to  disconnectError which is defined as new SqlCode(-4499) in client,am.SqlCode&lt;/p&gt;

&lt;p&gt;    public SqlException(LogWriter logWriter, ClientMessageId msgid, Object[] args,&lt;br/&gt;
        SqlCode sqlcode, Throwable t) &lt;/p&gt;
{
        this(logWriter, msgid, args, t);
        this.errorcode_ = sqlcode.getCode();
    }

&lt;p&gt;So the cause of the problem is this change of severity code. Does anyone know why do we overwrite the severity code determined based on 08006 to a completely different value.&lt;/p&gt;

&lt;p&gt;I need to run pickup my daughter so if this information looks incomplete or if I can provide further information, let me know and I will post something later tonight.,&lt;/p&gt;</comment>
                            <comment id="12541170" author="kmarsden" created="Thu, 8 Nov 2007 23:13:33 +0000"  >&lt;p&gt;I had thought in 10.2 we had changed the client error codes to match embedded but apparently not.  The code -4499 I don&apos;t believe has anything to do with DRDA, but is just the code used by client for disconnect exceptions.  Options are:&lt;br/&gt;
1) To change that code to match embedded SESSION_LEVEL severity&lt;br/&gt;
2) To trigger a connectionError event for the -4499 exception.&lt;/p&gt;

&lt;p&gt;I tend to think 1 might be a good option for trunk but is too risky for the 10.3 branch. There I think 2 would be more appropriate.&lt;/p&gt;</comment>
                            <comment id="12541383" author="mamtas" created="Fri, 9 Nov 2007 17:27:42 +0000"  >&lt;p&gt;Thanks for your input Kathey. I am leaning more towards option 1 in both trunk and 10.3 codeline to keep the codeline consistent as much as possible. Let me know if anyone feels strongly about not using option 2 or some other solution.&lt;/p&gt;</comment>
                            <comment id="12542592" author="mamtas" created="Wed, 14 Nov 2007 20:53:53 +0000"  >&lt;p&gt;Commited(revision 595047) the changes into trunk codeline with following commit comments&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3172&quot; title=&quot;ConnectionEventListener.connectionErrorOccurred not being executed when SQLState 08006 Error is thrown&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3172&quot;&gt;&lt;del&gt;DERBY-3172&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Change the Network Server code so that when the Network Server is shutdown, any api on Connection object will raise a Connection error event (similar to what is done in embedded mode). This also required me changing the disconnectError from -4999 to 40000(to match embedded). This change was made client.am.SqlCode. I have added tests for all the apis on Connection object in DataSourceTest. Had to change couple tests which were testing for -4999. Now they look for 40000. I will merge this change into 10.3 and run tests there before committing the changes in 10.3 codeline.&lt;/p&gt;</comment>
                            <comment id="12542716" author="knutanders" created="Thu, 15 Nov 2007 09:16:16 +0000"  >&lt;p&gt;Seems like the Tinderbox was broken by this commit. &lt;a href=&quot;http://dbtg.thresher.com/derby/test/tinderbox_trunk16/jvm1.6/testing/Limited/testSummary-595050.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dbtg.thresher.com/derby/test/tinderbox_trunk16/jvm1.6/testing/Limited/testSummary-595050.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12542805" author="mamtas" created="Thu, 15 Nov 2007 15:42:50 +0000"  >&lt;p&gt;The test runs fine on my machine, not sure why it failed on Tinderbox. I am looking into it. Thanks for the headsup, Knut.&lt;/p&gt;</comment>
                            <comment id="12542824" author="mamtas" created="Thu, 15 Nov 2007 17:25:08 +0000"  >&lt;p&gt;It appears that the test fails in Sun&apos;s jdk16 but passes on Sun&apos;s jdk142. I am not sure why. I will keep looking into it.&lt;/p&gt;</comment>
                            <comment id="12543190" author="mamtas" created="Fri, 16 Nov 2007 20:12:27 +0000"  >&lt;p&gt;Just committed a change into trunk through 595803 which should take care of DataSourceTest failure. The commit comments are as follows&lt;/p&gt;

&lt;p&gt;This is a followup checkin to checkin(595047) was committed for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3172&quot; title=&quot;ConnectionEventListener.connectionErrorOccurred not being executed when SQLState 08006 Error is thrown&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3172&quot;&gt;&lt;del&gt;DERBY-3172&lt;/del&gt;&lt;/a&gt;. The DataSourceTest had started failing under JDK1.6 after 595047. The particular test case that was failing was for Connection.getTypeMap The reason for failure was that this method was overridden in a subclass which kicks in only when JDBC4.0 is available. The overriden method was not sending the correct connection error event as expected by the test and hence the failure. While fixing this, I realized that there are several new JDBC4.0 apis that need to send the correct events to ConnectionEventListeners. This checkin takes care of those apis. More info on what was changed in this commit is as follows.&lt;/p&gt;

&lt;p&gt;New JDBC4.0 api, setClientInfo, wraps SQLException inside SQLClientInfoException but we were not copying the error code of SQLException into SQLClientInfoException. Without the correct error code, we would not send connection error event because the severity has to be fatal for us to send connection error event. Because of this, I had to change several places where SQLException is wrapped inside SQLClientInfoException to pass SQLException&apos;s error code to SQLClientInfoException. The classes changed because of this are EmbedConnection40, BrokeredConnection40, NetConnection40.&lt;/p&gt;

&lt;p&gt;For methods that throw SQLClientInfoException, we were not notifying the connection error events. I made changes to fix this.&lt;/p&gt;

&lt;p&gt;Several of new JDBC4 apis on connection object were not sending error events so I changed those methods in BrokeredConnection40 and LogicalConnection40. &lt;/p&gt;

&lt;p&gt;BrokeredConnection40 implements new JDBC4 methods on Connection object but these new methods did not follow the same logic as the other existing pre-JDBC4 methods to check for connection close and that caused the events to be not sent correctly. The problematic apis were createBlob, createClob, isWrapperFor, unwrap and I fixed those.&lt;/p&gt;

&lt;p&gt;Not all the new JDBC4 apis have been implemented (they throw not implemented exception) so the tests written for those apis just catch the unimplemented exception. These methods include createArrayOf, createNClob, createSQLXML, createStruct.&lt;/p&gt;

&lt;p&gt;In JDBC4, Connection object has two methods isWrapperFor and unwrap which do not go to the server when Derby is being accessed in client server mode and because of this, we never detect that the server is down and hence no connection error event is thrown in client server mode for these 2 apis. But when the same apis are called in embedded Derby after the engine is shutdown, we get connection error event. I have added the test for these 2 apis to count for the different in behavior but I am not sure if this is the expected behavior difference between the 2 configurations of Derby. I will enter a Jira entry for this.&lt;/p&gt;

&lt;p&gt;And lastly, the new JDBC4 api isValid on Connection object has different behavior in client server mode and embedded mode. They both throw exception that the connection is down but the connection close and error events are not dealt the same way in the 2 configurations. In embedded mode, after the engine is shutdown, an isValid call on Connection object raises a connection closed event and no connection error event. In client server mode, after the Network Server is shutdown, an isValid call on Connection object does not raise any event. In both the configurations, we do get a SQLException stating that connection is down. Again, I am not sure if this is expected bahavior difference between the 2 configurations of Derby. I will enter a Jira entry for this too. In addition, as per Connection.isValid api Java specification, a SQLException is thrown under following condition which is not being followed in embedded and client-server mode&lt;br/&gt;
Throws: &lt;br/&gt;
SQLException - if the value supplied for timeout is less then 0&lt;br/&gt;
Based on this, I am not sure if our behavior is correct to throw an SQLException if the server/engine is down. I will include this information in the Jira entry that I will make.&lt;/p&gt;

&lt;p&gt;The tests for all these new JDBC4 apis are in jdbc4/DataSourceTest.  &lt;/p&gt;

&lt;p&gt;I moved the AssertEventCatcher class implementation from jdbcapi/DataSourceTest into a class of it&apos;s own. This way, it can be shared by jdbcapi/DataSourceTest and jdbc4/DataSourceTest.&lt;/p&gt;</comment>
                            <comment id="12545979" author="mamtas" created="Tue, 27 Nov 2007 19:26:55 +0000"  >&lt;p&gt;Merged changes into 10.3 codeline with revision 598712 and the commit comments were as follows&lt;/p&gt;


&lt;p&gt;This commit merges into 10.3 codeline the 2 changes that went into trunk (595047 and 595803) for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3172&quot; title=&quot;ConnectionEventListener.connectionErrorOccurred not being executed when SQLState 08006 Error is thrown&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3172&quot;&gt;&lt;del&gt;DERBY-3172&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I had to modify the merged code for the 2 test files by adding code to start and stop network server in jdbcapi.DataSourceTest and jdbc4.DataSourceTest.&lt;/p&gt;

&lt;p&gt;In the trunk, these 2 functionalities of start and stop of network server are already available in the TestConfiguration.java. This functionalities were added into trunk as part of checkin 574053 for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2855&quot; title=&quot;Convert jdbc4/TestConnectionMethods.java to JUnit&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2855&quot;&gt;&lt;del&gt;DERBY-2855&lt;/del&gt;&lt;/a&gt;. I could merge the changes that went into  TestConfiguration to introduce these 2 functionalities in 10.3 codeline but there is an outstanding jira issue about this functionality causing derbynet.jar dependency. The jira issue is &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3151&quot; title=&quot;Reduce dependency on NetworkServerControl in TestConfiguration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3151&quot;&gt;&lt;del&gt;DERBY-3151&lt;/del&gt;&lt;/a&gt; &quot;Reduce dependency on NetworkServerControl in TestConfiguration&quot; Because of this, I opted to add start and stop network server functionality in jdbcapi.DataSourceTest and jdbc4.DataSourceTest. I have updated &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3151&quot; title=&quot;Reduce dependency on NetworkServerControl in TestConfiguration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3151&quot;&gt;&lt;del&gt;DERBY-3151&lt;/del&gt;&lt;/a&gt; requesting that once we reach a resolution, we should migrate the changes into 10.3 codeline too so that individual tests requiring start and stop network server do not have to write the code themselves, instead they can depend on the TestConfiguration.java or some other class to provide that functionality. Once that work is done, jdbcapi.DataSourceTest and jdbc4.DataSourceTest should be modified. I think in addition to these 2 tests, OutBufferedStream.java and TestConnectionMethods.java also have start and stop network server code in 10.3 codeline.&lt;/p&gt;
</comment>
                            <comment id="12546886" author="mamtas" created="Thu, 29 Nov 2007 20:53:30 +0000"  >&lt;p&gt;Entered jira entry &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3237&quot; title=&quot;3 JDBC4.0 apis on Connection object behave differently in Network Server and Embedded mode after Derby is shutdown&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3237&quot;&gt;DERBY-3237&lt;/a&gt; for difference in behavior between network server and embedded for 3 JDBC4.0 apis on Connection object.&lt;/p&gt;</comment>
                            <comment id="12562277" author="stan" created="Thu, 24 Jan 2008 22:57:35 +0000"  >&lt;p&gt;Catching up on Closing my reported issues.  Thanks to Dyre for the workflow reminder today.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12368855" name="DerbyNotification2.java" size="2801" author="stan" created="Fri, 2 Nov 2007 01:26:47 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 7 Nov 2007 19:50:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23475</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0zlz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39587</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>