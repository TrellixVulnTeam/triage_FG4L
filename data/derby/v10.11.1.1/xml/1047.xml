<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:36:05 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1047/DERBY-1047.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1047] [xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &apos;Statement&apos; already closed.&apos;  when used after the global transaction ends</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1047</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;In checkDataSource there is a case where a statement is created outside a global transaction,&lt;br/&gt;
the global transaction is started and ended  and then the statement reused.  In this case with client we can an error &lt;br/&gt;
 java.sql.SQLException: &apos;Statement&apos; already closed.  I will exclude this case and reference this bug number in the &lt;br/&gt;
test&lt;/p&gt;

&lt;p&gt;Note:  The server side error indicates the error occurs on session close, but I don&apos;t understand how the session is getting closed in this case.  Also the test comments say a new underlying connection is created after xa_end, but I don&apos;t know what that means with regard to the statement prepared before the global transaction started.&lt;/p&gt;


&lt;p&gt;The code:&lt;/p&gt;

&lt;p&gt;PreparedStatement psParams = cs1.prepareStatement(&quot;select * from ru where i &amp;gt; ?&quot;);&lt;br/&gt;
		psParams.setCursorName(&quot;params&quot;);&lt;br/&gt;
		psParams.setInt(1, 2);&lt;br/&gt;
		resultSetQuery(&quot;Params-local-1&quot;, psParams.executeQuery());&lt;/p&gt;

&lt;p&gt;		sruBatch.addBatch(&quot;insert into ru values 4&quot;);&lt;br/&gt;
		queryOnStatement(&quot;sru1-local-1&quot;, cs1, sru1);&lt;br/&gt;
		cs1.commit(); // need to commit to switch to an global connection;&lt;br/&gt;
		xid = new cdsXid(1, (byte) 103, (byte) 119);&lt;br/&gt;
		xar.start(xid, XAResource.TMNOFLAGS); // simple case - underlying connection is re-used for global.&lt;br/&gt;
		System.out.println(&quot;Expecting exception because global transaction sru1-global-2 is trying to use a statement with holdability true&quot;);&lt;br/&gt;
		queryOnStatement(&quot;sru1-global-2&quot;, cs1, sru1);&lt;br/&gt;
		sruBatch.addBatch(&quot;insert into ru values 5&quot;);&lt;br/&gt;
		Statement sru2 = cs1.createStatement();&lt;br/&gt;
		sru2.setCursorName(&quot;OAK2&quot;);&lt;br/&gt;
		queryOnStatement(&quot;sru2-global-3&quot;, cs1, sru2);&lt;br/&gt;
		System.out.println(&quot;Expecting exception because global transaction sru1-global-4 is trying to use a statement with holdability true&quot;);&lt;br/&gt;
		queryOnStatement(&quot;sru1-global-4&quot;, cs1, sru1);&lt;br/&gt;
		showStatementState(&quot;GLOBAL &quot;, sruState);&lt;br/&gt;
		showStatementState(&quot;PS GLOBAL &quot;, psruState);&lt;br/&gt;
		showStatementState(&quot;CS GLOBAL &quot;, csruState);&lt;br/&gt;
		try &lt;/p&gt;
{
			resultSetQuery(&quot;Params-global-1&quot;, psParams.executeQuery());
			System.out.println(&quot;FAIL: should have gotten exception because holdability is true on prepared statement and that is not allowed in global transactions&quot;);
		}
&lt;p&gt; catch (SQLException ex) &lt;/p&gt;
{
			System.out.println(&quot;PASS: got exception because holdability is true on prepared statement and that is not allowed in global transactions&quot;);
			System.out.println(ex.getMessage());
		}

&lt;p&gt;		xar.end(xid, XAResource.TMSUCCESS);&lt;br/&gt;
		// now a new underlying connection is created&lt;br/&gt;
		queryOnStatement(&quot;sru1-local-5&quot;, cs1, sru1);&lt;br/&gt;
		queryOnStatement(&quot;sru2-local-6&quot;, cs1, sru2);&lt;br/&gt;
		sruBatch.addBatch(&quot;insert into ru values 6,7&quot;);&lt;br/&gt;
		Statement sru3 = cs1.createStatement();&lt;br/&gt;
		sru3.setCursorName(&quot;SF3&quot;);&lt;br/&gt;
		queryOnStatement(&quot;sru3-local-7&quot;, cs1, sru3);&lt;br/&gt;
		// Two transactions should hold locks (global and the current XA);&lt;br/&gt;
		showStatementState(&quot;LOCAL &quot;, sruState);&lt;br/&gt;
		showStatementState(&quot;PS LOCAL &quot;, psruState);&lt;br/&gt;
		showStatementState(&quot;CS LOCAL &quot;, csruState);&lt;br/&gt;
		resultSetQuery(&quot;Params-local-2&quot;, psParams.executeQuery());    /// this is the line that failes with Statement alread closed.&lt;/p&gt;

&lt;p&gt;		checkLocks(cs1);&lt;br/&gt;
		cs1.commit();&lt;/p&gt;

&lt;p&gt;The client error:&lt;br/&gt;
  getMaxRows() 85&lt;br/&gt;
java.sql.SQLException: &apos;Statement&apos; already closed.&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:285)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQuery(PreparedStatement.java:301)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource.runTest(checkDataSource.java:514)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource.main(checkDataSource.java:133)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: &apos;Statement&apos; already closed.&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeSqlca(Statement.java:1612)&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeOpenQuery(Statement.java:1283)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseOpenQueryFailure(NetStatementReply.java:506)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseOPNQRYreply(NetStatementReply.java:229)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.readOpenQuery(NetStatementReply.java:59)&lt;br/&gt;
	at org.apache.derby.client.net.StatementReply.readOpenQuery(StatementReply.java:49)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatement.readOpenQuery_(NetStatement.java:151)&lt;br/&gt;
	at org.apache.derby.client.am.Statement.readOpenQuery(Statement.java:1279)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.flowExecute(PreparedStatement.java:1685)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQueryX(PreparedStatement.java:307)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQuery(PreparedStatement.java:292)&lt;br/&gt;
	... 2 more&lt;br/&gt;
java.sql.SQLException: &apos;Statement&apos; already closed.&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:285)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQuery(PreparedStatement.java:301)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource.runTest(checkDataSource.java:514)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.checkDataSource.main(checkDataSource.java:133)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: &apos;Statement&apos; already closed.&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeSqlca(Statement.java:1612)&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeOpenQuery(Statement.java:1283)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseOpenQueryFailure(NetStatementReply.java:506)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseOPNQRYreply(NetStatementReply.java:229)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.readOpenQuery(NetStatementReply.java:59)&lt;br/&gt;
	at org.apache.derby.client.net.StatementReply.readOpenQuery(StatementReply.java:49)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatement.readOpenQuery_(NetStatement.java:151)&lt;br/&gt;
	at org.apache.derby.client.am.Statement.readOpenQuery(Statement.java:1279)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.flowExecute(PreparedStatement.java:1685)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQueryX(PreparedStatement.java:307)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQuery(PreparedStatement.java:292)&lt;br/&gt;
	... 2 more&lt;br/&gt;
Exception in thread &quot;main&quot; &lt;/p&gt;


&lt;p&gt;The Server error in the derby.log&lt;br/&gt;
&apos;Statement&apos; already closed.&lt;/p&gt;

&lt;p&gt;SQL Exception: &apos;Statement&apos; already closed.&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:80)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:87)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:166)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.EmbedConnection.newSQLException(EmbedConnection.java:1919)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.ConnectionChild.newSQLException(ConnectionChild.java:163)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.EmbedStatement.checkStatus(EmbedStatement.java:1247)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.jdbc.EmbedStatement.getFetchDirection(EmbedStatement.java:741)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.iapi.jdbc.BrokeredStatement.setStatementState(BrokeredStatement.java:506)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.iapi.jdbc.BrokeredPreparedStatement30.createDuplicateStatement(BrokeredPreparedStatement30.java:68)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.jdbc.XAStatementControl.getRealPreparedStatement(XAStatementControl.java:127)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.iapi.jdbc.BrokeredPreparedStatement.getPreparedStatement(BrokeredPreparedStatement.java:502)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.iapi.jdbc.BrokeredPreparedStatement.getStatement(BrokeredPreparedStatement.java:509)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.iapi.jdbc.BrokeredStatement.close(BrokeredStatement.java:130)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.drda.DRDAStatement.close(DRDAStatement.java:959)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.drda.Database.close(Database.java:301)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.drda.Session.close(Session.java:110)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.drda.DRDAConnThread.closeSession(DRDAConnThread.java:7106)&lt;/p&gt;

&lt;p&gt;	at org.apache.derby.impl.drda.DRDAConnThread.run(DRDAConnThread.java:251)&lt;/p&gt;

&lt;p&gt;Apache Derby Network Server - 10.2.0.0 alpha shutdown at 2006-02-24 12:44:49.278 GMT&lt;/p&gt;

</description>
                <environment></environment>
        <key id="12329421">DERBY-1047</key>
            <summary>[xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &apos;Statement&apos; already closed.&apos;  when used after the global transaction ends</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="6">Invalid</resolution>
                                        <assignee username="kmarsden">Kathey Marsden</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                    </labels>
                <created>Fri, 24 Feb 2006 22:12:53 +0000</created>
                <updated>Mon, 10 Apr 2006 03:06:23 +0100</updated>
                            <resolved>Mon, 10 Apr 2006 02:14:46 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12373702" author="kmarsden" created="Sat, 8 Apr 2006 09:32:59 +0100"  >&lt;p&gt;I have a fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1047&quot; title=&quot;[xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &amp;#39;Statement&amp;#39; already closed.&amp;#39;  when used after the global transaction ends&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1047&quot;&gt;&lt;del&gt;DERBY-1047&lt;/del&gt;&lt;/a&gt; but now the original test case no longer fails and I am having trrouble coming up with a new test case.&lt;/p&gt;

&lt;p&gt;Firstly the problem description is not really correct:&lt;/p&gt;

&lt;p&gt;The actual problem is that  network server was closing the prepared statement if an error occurred on execution (OPNQRY) , so a subsequent execution of the prepared statement would fail.    I am attaching the  patch that fixes this issue for reference but will wait until I have a test case to commit.&lt;br/&gt;
derby1047.patch&lt;/p&gt;


&lt;p&gt;The reason the original repro no longer shows the issue is that  the exception that was used to invoke the issue  (using a holdable statement in a global transaction)  no longer occurs, because the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1158&quot; title=&quot;Allow use of Statements created in local transaction with default holdability to be used in global transactions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1158&quot;&gt;&lt;del&gt;DERBY-1158&lt;/del&gt;&lt;/a&gt; makes this legal.  I thought that I would change the test case to have a lock timeout instead and in fact the issue  would ocur for regular connectiosn,  but for some reason that does not seem to provoke the problem.  Attached are the old and new test cases.  &lt;br/&gt;
 Derby1047.java   - Old failing case (Doesn&apos;t fail anymore) :  run&lt;br/&gt;
     java -Dframework=DerbyNetClient Derby1047&lt;/p&gt;

&lt;p&gt;UsePSAfterError.java - Attempt to write a new test case.&lt;br/&gt;
    java -Dframework=DerbyNetClient UsePSAfterError&lt;/p&gt;


&lt;p&gt;One other interesting thing to note is that this code to close the prepared statement on statement execution error (OPNQRY error)   seems to be new to 10.2.  I do not see it in  the 10.1 codeline.  I am not sure when and why it was added.&lt;/p&gt;







</comment>
                            <comment id="12373703" author="kmarsden" created="Sat, 8 Apr 2006 09:35:01 +0100"  >&lt;p&gt;Original repro.  Doesn&apos;t actually fail anymore.&lt;/p&gt;</comment>
                            <comment id="12373704" author="kmarsden" created="Sat, 8 Apr 2006 09:36:51 +0100"  >&lt;p&gt;New attempt at a repro:&lt;br/&gt;
Try to use prepared statement after lock timeout. &lt;/p&gt;

&lt;p&gt;java -Dframework=DerbyNetClient UsePSAfterError&lt;/p&gt;</comment>
                            <comment id="12373705" author="kmarsden" created="Sat, 8 Apr 2006 09:41:20 +0100"  >&lt;p&gt;Patch that fixes the issue, but still  need a new test case.&lt;br/&gt;
In DRDAConnThread.processCommands, if there was a failure executing a statement, the prepared statement would get closed.  This patch removes that code.  &lt;br/&gt;
Note: The code to close the prepared statement after OPNQRY only exists on the trunk, not 10.1&lt;/p&gt;

</comment>
                            <comment id="12373782" author="kmarsden" created="Mon, 10 Apr 2006 02:14:46 +0100"  >&lt;p&gt;The core problem with the initial test case for this issue was not the problem described in the bug summary.  The &apos;Statement&apos; already closed message only occurred if the had been a previous error executing the statement.  That issue has been filed and fixed as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1196&quot; title=&quot;Network server closes  prepared statements  prematurely if  exception occurs during OPNQRY  and can cause &amp;quot;&amp;#39;Statement&amp;#39; already closed&amp;quot; exception on reexecution&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1196&quot;&gt;&lt;del&gt;DERBY-1196&lt;/del&gt;&lt;/a&gt;, so I am closing this bug &quot;Invalid&quot;.&lt;/p&gt;


</comment>
                    </comments>
                    <attachments>
                            <attachment id="12325073" name="Derby1047.java" size="3537" author="kmarsden" created="Sat, 8 Apr 2006 09:34:59 +0100"/>
                            <attachment id="12325074" name="UsePSAfterError.java" size="3091" author="kmarsden" created="Sat, 8 Apr 2006 09:36:51 +0100"/>
                            <attachment id="12325075" name="derby1047.diff" size="3685" author="kmarsden" created="Sat, 8 Apr 2006 09:41:20 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22281</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy16w7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40767</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>