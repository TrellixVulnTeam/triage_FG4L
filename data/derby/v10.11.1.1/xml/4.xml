<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:27:03 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4/DERBY-4.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4] &quot;order by&quot; is not supported for &quot;insert ... select&quot;</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When filling a table with &quot;insert ... select ...&quot;, &quot;order by&quot; cannot be specified.&lt;/p&gt;

&lt;p&gt;There is no method to copy a table sorted into another table (except using export/import). This would be useful to optimize performance for big tables, or to create identity values that are ascending (related to another column).&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;create table temp1 (&lt;br/&gt;
   s varchar(10));&lt;/p&gt;

&lt;p&gt;insert into temp1 values &apos;x&apos;,&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;a&apos;;&lt;/p&gt;

&lt;p&gt;create table temp2 (&lt;br/&gt;
   i integer not null&lt;br/&gt;
      generated always as identity&lt;br/&gt;
      primary key,&lt;br/&gt;
   s varchar(10));&lt;/p&gt;

&lt;p&gt;insert into temp2 (s)&lt;br/&gt;
   select s from temp1 order by s;&lt;/p&gt;

&lt;p&gt;--&amp;gt; Error: &quot;order by&quot; is not allowed.&lt;/p&gt;

&lt;p&gt;&amp;#8211; trying to use &quot;group by&quot; instead of &quot;oder by&quot;:&lt;/p&gt;

&lt;p&gt;insert into temp2 (s)&lt;br/&gt;
   select s from temp1 group by s;&lt;br/&gt;
select * from temp2;&lt;/p&gt;

&lt;p&gt;--&amp;gt; &quot;group by&quot; did not sort the table.&lt;/p&gt;
</description>
                <environment></environment>
        <key id="27482">DERBY-4</key>
            <summary>&quot;order by&quot; is not supported for &quot;insert ... select&quot;</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="chdh@inventec.ch">Christian d&apos;Heureuse</reporter>
                        <labels>
                    </labels>
                <created>Mon, 27 Sep 2004 18:53:35 +0100</created>
                <updated>Mon, 17 Jun 2013 10:19:46 +0100</updated>
                            <resolved>Wed, 12 May 2010 15:50:32 +0100</resolved>
                                                                    <component>SQL</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="53453" author="swazoo" created="Tue, 28 Sep 2004 08:39:23 +0100"  >&lt;p&gt;I see what you want to do here: you are trying to number the rows in a table according to an ordering.&lt;/p&gt;

&lt;p&gt;Standard SQL doesn&apos;t allow the &quot;order by&quot; clause on an insert-select. Normally, this makes sense because a table (AKA relation) is an unordered set of rows (AKA tuples). Normally, the order that the rows are inserted would have no consequence that one should rely on. For example, if you select the rows from the table you just inserted them into, there is no guarantee that they would come back in the same order.&lt;/p&gt;

&lt;p&gt;In this case, though, you want to rely on a side-effect of inserting (the generation of indentity values) as the insert happens. This is a valid thing to want to do - however, it makes me nervous to make a broad extension for such a specific purpose.&lt;/p&gt;

&lt;p&gt;If the Virtual Table Interface (VTI) still existed (it was in Cloudscape 5.1 and earlier versions), I would suggest using that as a workaround. VTIs allowed the user to write a Java class with methods that returned ResultSets. One could easily hide the &quot;order by&quot; clause inside the VTI.&lt;/p&gt;

&lt;p&gt;I don&apos;t think &quot;group by&quot; is a valid workaround. A select statement with a &quot;group by&quot; and no aggregates in the select list is the same as a &quot;select distinct.&quot; No ordering is guaranteed - for example, a smart optimizer could avoid a sort if there were a unique index on a subset of the result columns.&lt;/p&gt;</comment>
                            <comment id="53460" author="chdh@inventec.ch" created="Tue, 28 Sep 2004 15:08:15 +0100"  >&lt;p&gt;Thanks for your explanations.&lt;/p&gt;

&lt;p&gt;For the ordered numbering I could write a stored procedure that inserts the data row for row.&lt;/p&gt;

&lt;p&gt;What do you think about a (system) stored procedure to re-load a table, so that the records are physically sorted by the primary key? Maybe it could be an extension to SYSCS_UTIL.SYSCS_COMPRESS_TABLE.&lt;br/&gt;
I assume that this would not solve the &quot;insert select&quot; problem, because there is no guarantee that the &quot;physical&quot; order would be used to insert the rows. But it would be useful to optimize disk access for large tables, e.g. journal records for adresses could be physically grouped together (for each address). Otherwise one has to define an index that includes all columns that are accessed.&lt;br/&gt;
Another solution would be to implement clustering indexes.&lt;/p&gt;</comment>
                            <comment id="12496056" author="bryanpendleton" created="Tue, 15 May 2007 18:27:57 +0100"  >&lt;p&gt;I am interested in adding this feature to Derby; I find that I have the &lt;br/&gt;
same need that Christian identified.&lt;/p&gt;

&lt;p&gt;I understand the concerns that Jeff raised about this being a &lt;br/&gt;
non-standard language extension. However, Christian&apos;s usage&lt;br/&gt;
seems quite reasonable to me (and in fact matches my usage),&lt;br/&gt;
and this extension is commonly supported by many other databases&lt;br/&gt;
so we are not really breaking new ground here.&lt;/p&gt;

&lt;p&gt;I&apos;ve been working on a patch to add this support and hope to post it&lt;br/&gt;
soon for discussion, once I&apos;ve seen how the testing goes.&lt;/p&gt;</comment>
                            <comment id="12496080" author="chdh@inventec.ch" created="Tue, 15 May 2007 19:39:21 +0100"  >&lt;p&gt;Bryan, thanks for planning to implement the INSERT ... SELECT ... ORDER BY.&lt;br/&gt;
An alternative would be to implement a ROW_NUMBER ranking function, which would be more conforming to the SQL standard:&lt;/p&gt;

&lt;p&gt;  SELECT ROW_NUMBER() OVER (ORDER BY s) as i, s FROM temp1;&lt;/p&gt;</comment>
                            <comment id="12496085" author="djd" created="Tue, 15 May 2007 19:54:15 +0100"  >&lt;p&gt;Would the use of ORDER BY guarantee anything or is it just something that might work?&lt;/p&gt;

&lt;p&gt;I don&apos;t think it can guarantee contiguous values since other INSERTS can occur from other transactions that would use generated identity values.&lt;/p&gt;</comment>
                            <comment id="12496107" author="bryanpendleton" created="Tue, 15 May 2007 21:03:50 +0100"  >&lt;p&gt;Thanks Christian and Dan for the feedback. I agree about the contiguous&lt;br/&gt;
values, Dan. The guarantee that I think it can make is that the values are&lt;br/&gt;
monotonically increasing; that is, that the rows that are inserted, if later&lt;br/&gt;
sorted by their auto-generated field, will be in the same order as they came&lt;br/&gt;
from the SELECT. So it&apos;s preserving the order, which is all that is needed&lt;br/&gt;
for my application (I&apos;m using a &quot;temporary&quot; table for supporting paging in a UI,&lt;br/&gt;
and wish to preserve the the order of the rows as they arrive in that table.)&lt;/p&gt;

&lt;p&gt;Christian, regarding the ranking functions, I&apos;m quite interested in those, and&lt;br/&gt;
I think we should log them as an enhancement request and pursue them.&lt;br/&gt;
Perhaps you have already done so? If not I think that would be great.&lt;br/&gt;
However, in my particular case I don&apos;t have control over the SQL that is&lt;br/&gt;
being emitted; I&apos;m trying to get Derby to work with a tool written for another DBMS.&lt;/p&gt;</comment>
                            <comment id="12496158" author="chdh@inventec.ch" created="Wed, 16 May 2007 00:05:30 +0100"  >&lt;p&gt;Yes, there is already a JIRA entry for &quot;SQL pagination&quot; with the ROW_NUMBER ranking function: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-581&quot; title=&quot;Modify SQL to skip N rows of the result and return the next M rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-581&quot;&gt;&lt;del&gt;DERBY-581&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12496230" author="bernt" created="Wed, 16 May 2007 09:52:08 +0100"  >&lt;p&gt;I do not agree that we should implement this &quot;feature&quot;. First of all, it is not defined in the standard, and secondly it makes no sense wrt. SQL as a language. SQL is basically a set language where the rows have no order. The ORDER BY clause is used to order the rows when they are retrieved &lt;b&gt;from&lt;/b&gt; the database.&lt;/p&gt;

&lt;p&gt;Although the following SQL:&lt;br/&gt;
INSERT INTO T VALUES(1);&lt;br/&gt;
INSERT INTO T VALUES(2);&lt;br/&gt;
SELECT * FROM T;&lt;/p&gt;

&lt;p&gt;In most databases will give you the result&lt;br/&gt;
1&lt;br/&gt;
2&lt;br/&gt;
But I&apos;ve seen otherwise, and that&apos;s completely compliant with the standard. I would say that any application based on the assumption that the INSERT order has any influence on the result from a SELECT statement withou an ORDER BY clause is buggy, so the tool Bryan is referring to should be fixed.&lt;/p&gt;

&lt;p&gt;-1 To this &quot;feature&quot;.&lt;/p&gt;
</comment>
                            <comment id="12496316" author="bryanpendleton" created="Wed, 16 May 2007 15:40:02 +0100"  >&lt;p&gt;Hi Bernt, thanks for the feedback. I believe I understand your concerns.&lt;/p&gt;

&lt;p&gt;I am &lt;b&gt;not&lt;/b&gt; proposing that the ORDER BY should have any affect on&lt;br/&gt;
subsequent SELECT statements. Such a behavior would be indeed wrong.&lt;/p&gt;

&lt;p&gt;I am only proposing that the ORDER BY should affect the SELECT that is&lt;br/&gt;
part of the INSERT statement itself; that is, that it should affect the order in&lt;br/&gt;
which the INSERT statement processes the rows that the SELECT selects.&lt;/p&gt;

&lt;p&gt;Note that in Christian&apos;s example (and in the tool I&apos;m trying to support), there&lt;br/&gt;
is an auto-generated column. The database will automatically generate&lt;br/&gt;
new values for this column as the rows are inserted.&lt;/p&gt;

&lt;p&gt;The point of this feature is to allow the user to ensure that, *if the rows are&lt;br/&gt;
later selected and ordered by the auto-generated column*, then they will&lt;br/&gt;
appear in the same order as they appeared during the INSERT.&lt;/p&gt;

&lt;p&gt;Thus subsequent SELECT statements &lt;b&gt;do&lt;/b&gt; have an ORDER BY, but it&lt;br/&gt;
is an ORDER BY on the autogenerated column, not on the original columns&lt;br/&gt;
of the source data for the INSERT ... SELECT ... ORDER BY.&lt;/p&gt;

&lt;p&gt;Does this explanation make more sense?&lt;/p&gt;</comment>
                            <comment id="12496331" author="bryanpendleton" created="Wed, 16 May 2007 16:52:14 +0100"  >&lt;p&gt;Attached is &apos;insertOrderBy.diff&apos;, a patch containing code changes,&lt;br/&gt;
but no new tests. This patch is &lt;b&gt;not&lt;/b&gt; intended for commit, just as&lt;br/&gt;
a way to give us some concrete code to talk about. &lt;/p&gt;

&lt;p&gt;The patch adds a line to the parser to enable INSERT ... SELECT .. ORDER BY&lt;br/&gt;
and adds a bit of code to InsertNode to handle the OrderByList.&lt;/p&gt;

&lt;p&gt;The code in InsertNode mimics the implementation in CursorNode;&lt;br/&gt;
perhaps there is some way to arrange for these two nodes to&lt;br/&gt;
share this code?&lt;/p&gt;

&lt;p&gt;With the patch, derbyall and suites.All run clean, so I&apos;ve made a first&lt;br/&gt;
attempt at verifying that this change doesn&apos;t break existing behaviors.&lt;br/&gt;
Also, I verified that a similar change to 10.2 can be made, if desired,&lt;br/&gt;
and also adds the new behavior without (obviously) breaking existing ones.&lt;/p&gt;

&lt;p&gt;I&apos;d love to keep the discussion going: either more general comments&lt;br/&gt;
on the underlying concepts of the feature, or specific comments about&lt;br/&gt;
the possible implementation in code. Thanks to all who have participated so far!&lt;/p&gt;
</comment>
                            <comment id="12496611" author="djd" created="Thu, 17 May 2007 17:31:12 +0100"  >&lt;p&gt;&amp;gt; The point of this feature is to allow the user to ensure that, *if the rows are&lt;br/&gt;
&amp;gt; later selected and ordered by the auto-generated column*, then they will&lt;br/&gt;
&amp;gt; appear in the same order as they appeared during the INSERT. &lt;/p&gt;

&lt;p&gt;Once/if Derby supports the cycle option of identity columns  (CYCLE) then this would no longer be guaranteed,&lt;br/&gt;
so any documentation should clearly indicated the restricted cases where such a guarantee would apply.&lt;br/&gt;
(assuming of course the feature is accepted)&lt;/p&gt;</comment>
                            <comment id="12497129" author="bernt" created="Sat, 19 May 2007 09:11:39 +0100"  >&lt;p&gt;Hi Bryan. I see your point and the need wrt. the generated columns. I have tried to dive into the SQL 2003 standard to see if this extension violates any SQL semantics, and I admit I can&apos;t find any (although the construct is a bit &quot;un-SQL-like&quot;, but so are many constructs other SQL databases &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ). But it will restrain us from some optimizations in the future, e.g. if the result from the subquery is very large, it could be partitioned and the partitions inserted in parallell into the base table (maybe far fetched?). &lt;/p&gt;

&lt;p&gt;I see from the patch that you extend the insert statement and not generally the subquery. That is good. Is it an idea also to restrict the use of the order by clause in the insert statement to base tables with generated columns? &lt;/p&gt;</comment>
                            <comment id="12497149" author="knutanders" created="Sat, 19 May 2007 13:36:06 +0100"  >&lt;p&gt;If the temp1 table mentioned in the description had a unique constraint on s, and temp2.i were declared as generated by default as identity (instead of always as identity), the following query would be pretty close to what you want:&lt;/p&gt;

&lt;p&gt;insert into temp2 select count(b.s), a.s from temp1 a, temp1 b where b.s &amp;lt;= a.s group by a.s&lt;/p&gt;

&lt;p&gt;It&apos;s not a perfect match, but it would at least give the identity column the same ordering as the s column. Some extra tweaking is needed if temp2 is not empty when the insert is executed.&lt;/p&gt;</comment>
                            <comment id="12497168" author="chdh@inventec.ch" created="Sat, 19 May 2007 17:30:10 +0100"  >&lt;p&gt;&amp;gt; But it will restrain us from some optimizations in the future, &lt;/p&gt;

&lt;p&gt;I don&apos;t agree. An INSERT ... SELECT without an &quot;ORDER BY&quot; can still be optimized with parallel processing in the future. Only the new &quot;INSERT ... SELECT ... ORDER BY&quot; cannot be processed in parallel.&lt;/p&gt;

&lt;p&gt;&amp;gt; insert into temp2 select count(b.s), a.s from temp1 a, temp1 b where b.s &amp;lt;= a.s group by a.s&lt;/p&gt;

&lt;p&gt;This would be an alternative, but it&apos;s very slow for large tables, because the complexity is in the order of O(n*(n/2)).&lt;/p&gt;</comment>
                            <comment id="12497290" author="bryanpendleton" created="Sun, 20 May 2007 21:40:14 +0100"  >&lt;p&gt;Thanks to all for the continued feedback!&lt;/p&gt;

&lt;p&gt;Attached is a second version of the proposed patch. Again, this is&lt;br/&gt;
not for commit, just to continue to stimulate the discussion. This&lt;br/&gt;
patch has two changes from the previous patch:&lt;br/&gt;
1) An error message is added to InsertNode&apos;s initializer to reject&lt;br/&gt;
the use of ORDER BY for INSERT ... VALUES statements&lt;br/&gt;
2) SingleChildResultSetNode is changed to override the&lt;br/&gt;
pushOrderByList() method and to pass the orderByList on to its&lt;br/&gt;
childResult. This is important when there is a NormalizeResultSetNode,&lt;br/&gt;
as occurs when the number of columns being SELECTed does not&lt;br/&gt;
match the number of columns being INSERTed. This situation arises&lt;br/&gt;
when using auto-generated columns.&lt;/p&gt;

&lt;p&gt;Unfortunately, the original script from Christian is still not working&lt;br/&gt;
correctly with my patch. The ORDER BY list is properly passed to&lt;br/&gt;
the optimizer, and an OrderBy node is constructed to cause the&lt;br/&gt;
results to be generated in sorted order, but something goes wrong&lt;br/&gt;
and the final result is not properly sorted.&lt;/p&gt;

&lt;p&gt;Examples &lt;b&gt;without&lt;/b&gt; auto-generated columns seem to be working fine.&lt;/p&gt;

&lt;p&gt;I&apos;ll continue working on this problem to figure out why the sort isn&apos;t working.&lt;/p&gt;

&lt;p&gt;Also attached is &apos;samples.ij&apos;, which contains some SQL samples&lt;br/&gt;
that others might find interesting when experimenting with the patch,&lt;br/&gt;
and which I hope to someday turn into full-fledged test cases.&lt;/p&gt;

&lt;p&gt;As I said above, none of this is for commit; I&apos;m just trying to keep moving&lt;br/&gt;
the discussion and the implementation along and share the work&lt;br/&gt;
that I&apos;ve done so far.&lt;/p&gt;</comment>
                            <comment id="12497490" author="army" created="Mon, 21 May 2007 16:55:43 +0100"  >&lt;p&gt;&amp;gt; 1) An error message is added to InsertNode&apos;s initializer to reject&lt;br/&gt;
&amp;gt; the use of ORDER BY for INSERT ... VALUES statements &lt;/p&gt;

&lt;p&gt;Is there a technical reason for this restriction or is this just an incremental development and/or what-you&apos;re-willing-to-work-on-right-now restriction (which would be fine)?&lt;/p&gt;

&lt;p&gt;I scanned through the comments for this issue and didn&apos;t see anything explicit about why a SELECT ... VALUES ... ORDER BY statement should throw an error, so I&apos;m just wondering...&lt;/p&gt;</comment>
                            <comment id="12497637" author="bryanpendleton" created="Tue, 22 May 2007 00:45:12 +0100"  >&lt;p&gt;Hi Army, thanks for the question! &lt;/p&gt;

&lt;p&gt;No, there was no technical reason for the restriction.&lt;/p&gt;

&lt;p&gt;I think that ORDER BY clauses for VALUES expressions need &lt;br/&gt;
to order by a column position. That is:&lt;br/&gt;
  VALUES &apos;b17&apos;, &apos;b1&apos;, &apos;b52&apos; ORDER BY 1&lt;br/&gt;
makes sense, as does&lt;br/&gt;
  VALUES (&apos;ham&apos;, 50), (&apos;eggs&apos;, 100), (&apos;spam&apos;, 20) ORDER BY 2&lt;br/&gt;
but&lt;br/&gt;
  VALUES &apos;x&apos;, &apos;a&apos;, &apos;m&apos; ORDER BY c1&lt;br/&gt;
does not make sense, since columns in VALUES expressions&lt;br/&gt;
don&apos;t have names.&lt;/p&gt;

&lt;p&gt;I&apos;ll re-visit the VALUES restriction and see how to make it work.&lt;/p&gt;

&lt;p&gt;Meanwhile, I discovered a major problem in my previous patch; I had&lt;br/&gt;
inserted the bind processing for order by columns into the&lt;br/&gt;
InsertNode.bind() method in the wrong place, so it was binding the&lt;br/&gt;
columns incorrectly in the case(s) where NormalizeResultSetNode&lt;br/&gt;
instances were generated.&lt;/p&gt;

&lt;p&gt;I&apos;m working on a 3rd version of the patch, to incorporate all this&lt;br/&gt;
new knowledge &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12497652" author="mikem" created="Tue, 22 May 2007 01:35:10 +0100"  >&lt;p&gt;Does Derby today guarantee anything other than uniqueness from &quot;generated always&quot;  fields?  The current implementation&lt;br/&gt;
happens to return increasing keys, but do we ever guarantee that, and should we?  Will it limit the ability in the future to &lt;br/&gt;
optimize concurrency with respect to generating keys.  It may be easier to guarantee increasing keys within a single statement, but not across threads inserting into the same table.  &lt;/p&gt;

&lt;p&gt;An example of a cross thread optimization would be the following.  Today we allocate a chunk of keys and cache them in&lt;br/&gt;
one place in the system.  That place is a bottleneck for all concurrent inserters.   To completely alleviate the bottleneck we&lt;br/&gt;
could allocate a group of keys for each thread doing inserts, then they would only bottleneck when they had used up the&lt;br/&gt;
group of keys.  And if we didn&apos;t want to &quot;lose&quot; key space we might reuse the keys from the group that weren&apos;t exhausted which&lt;br/&gt;
then for a single thread might  result in keys not incrementing any more.  I believe there are some issues reported in jira about concurrency problems with generated keys, so work in this area may be required in the future.&lt;/p&gt;
</comment>
                            <comment id="12497655" author="bryanpendleton" created="Tue, 22 May 2007 02:03:11 +0100"  >&lt;p&gt;Mike asked: &quot;The current implementation happens to return increasing keys, but do we ever guarantee that, and should we?&quot;&lt;/p&gt;

&lt;p&gt;I believe the answer is that we guarantee to obey the START WITH and &lt;br/&gt;
INCREMENT BY attributes of the generated column At:&lt;br/&gt;
&lt;a href=&quot;http://db.apache.org/derby/docs/dev/ref/rrefsqlj37836.html#rrefsqlj37836&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/dev/ref/rrefsqlj37836.html#rrefsqlj37836&lt;/a&gt;&lt;br/&gt;
we say &quot;For SMALLINT, INT, and BIGINT columns with identity attributes, Derby automatically assigns increasing integer values to the column.&quot;&lt;/p&gt;

&lt;p&gt;Later, we also say: &quot;And if you specify a negative number for the increment value, Derby decrements the value with each insert. If this value is positive, Derby increments the value with each insert. &quot;&lt;/p&gt;

&lt;p&gt;It&apos;s hard to see how to interpret the &quot;START WITH&quot; and &quot;INCREMENT BY&quot;&lt;br/&gt;
attributes of the generated column spec without providing such guarantees. &lt;br/&gt;
INCREMENT BY 1 needs to increment by 1.&lt;/p&gt;

&lt;p&gt;I agree with you that relaxing these guarantees could allow higher-performing&lt;br/&gt;
implementations in the future.&lt;/p&gt;

&lt;p&gt;But I think that many applications are already depending on the current behavior of the&lt;br/&gt;
START WITH and INCREMENT BY properties.&lt;/p&gt;</comment>
                            <comment id="12497780" author="bernt" created="Tue, 22 May 2007 10:36:13 +0100"  >&lt;p&gt;Bryan wrote:&lt;br/&gt;
&amp;gt; It&apos;s hard to see how to interpret the &quot;START WITH&quot; and &quot;INCREMENT BY&quot;&lt;br/&gt;
&amp;gt; attributes of the generated column spec without providing such guarantees.&lt;br/&gt;
&amp;gt; INCREMENT BY 1 needs to increment by 1. &lt;/p&gt;

&lt;p&gt;Actually, the SQL standard does not require that we increment by 1 but&lt;br/&gt;
by N*1 where N is an non-negative integer. See Ch 9.21 which says that&lt;br/&gt;
the next value calculated like this:&lt;/p&gt;

&lt;p&gt;  &quot;If there exists a non-negative integer N such that SMIN &amp;lt;= CBV + N&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;INC &amp;lt;= SMAX and the value (CBV + N * INC) has not already been&lt;br/&gt;
   returned in the current cycle, then let V1 be (CBV + N * INC).&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So any value N * INC between the current base value (CBV) and the&lt;br/&gt;
limit (SMAX (or SMIN if the generator is decreasing)) is legal and&lt;br/&gt;
holes may not be reclaimed unless the base value is altered&lt;br/&gt;
explicitely (that is for non-cyclic generators, which is what Derby&lt;br/&gt;
supports). &lt;/p&gt;

&lt;p&gt;No well behaved application should depend on the increment actually to&lt;br/&gt;
be 1 every time (although it will be in most cases).&lt;/p&gt;


</comment>
                            <comment id="12498095" author="bryanpendleton" created="Wed, 23 May 2007 05:55:56 +0100"  >&lt;p&gt;It turns out that I had a major misunderstanding of the control&lt;br/&gt;
flow of INSERT ... SELECT and how it interacts with generated&lt;br/&gt;
identity columns.&lt;/p&gt;

&lt;p&gt;Consider the original example from this issue:&lt;/p&gt;

&lt;p&gt;  create table temp1(s varchar(10));&lt;br/&gt;
  insert into temp1 values &apos;x&apos;,&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;a&apos;;&lt;br/&gt;
  create table temp2(i integer not null generated always as identity,&lt;br/&gt;
                   s varchar(10));&lt;br/&gt;
  insert into temp2(s) select s from temp1 order by s;&lt;/p&gt;

&lt;p&gt;An INSERT ... SELECT statement has 3 basic stages of processing:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the SELECT statement retrieves rows of data&lt;/li&gt;
	&lt;li&gt;each retrieved row is transformed into the form needed by the&lt;br/&gt;
   target table&lt;/li&gt;
	&lt;li&gt;each row is then inserted into the target table&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;From a QueryTreeNode point of view, there is an InsertNode, which&lt;br/&gt;
points to a NormalizeResultSetNode, which in turn points either to&lt;br/&gt;
a UnionNode (in the case of INSERT ... VALUES ...), or to a&lt;br/&gt;
ProjectRestrictNode/SelectNode tree (in the case of INSERT ... SELECT ...).&lt;/p&gt;

&lt;p&gt;My assumption when I started investigating this issue was that&lt;br/&gt;
the values of the identity column were generated during the 3rd&lt;br/&gt;
stage, at the time of insert into the target table, by processing&lt;br/&gt;
that would occur in InsertResultSet.java&lt;/p&gt;

&lt;p&gt;Or, at least, that the identity values were generated during&lt;br/&gt;
the 2nd stage, as part of projecting and normalizing the source&lt;br/&gt;
data into the form needed by the target table, by processing that&lt;br/&gt;
would occur in NormalizeResultSet.java.&lt;/p&gt;

&lt;p&gt;Unfortunately, after stepping through the code in detail, I&apos;ve&lt;br/&gt;
come to the conclusion that the identity column values are&lt;br/&gt;
actually generated during the first stage, when the rows of&lt;br/&gt;
data are retrieved by the SELECT and are being fed &lt;b&gt;into&lt;/b&gt; the sorter.&lt;/p&gt;

&lt;p&gt;Thus, the identity column&apos;s values are generated &lt;b&gt;prior&lt;/b&gt; to the&lt;br/&gt;
sort, and hence there is no guarantee that the order of the&lt;br/&gt;
values bears any relationship to the ORDER BY clause.&lt;/p&gt;

&lt;p&gt;At the instant when the new value of the identity column is&lt;br/&gt;
being generated for the row that we&apos;re processing, the stack looks&lt;br/&gt;
like this:&lt;br/&gt;
  DataDictionaryImpl.getSetAutoincrementValue&lt;br/&gt;
   InsertResultSet.getSetAutoincrementValue&lt;br/&gt;
    BaseActivation.getSetAutoincrementValue&lt;br/&gt;
     &amp;lt;generated bytecode method &quot;e1&quot;&amp;gt;&lt;br/&gt;
      ProjectRestrictResultSet.doProjection&lt;br/&gt;
       ProjectRestrictResultSet.getNextRowCore&lt;br/&gt;
        SortResultSet.getRowFromResultSet&lt;br/&gt;
         SortResultSet.getNextRowFromRS&lt;br/&gt;
          SortResultSet.loadSorter&lt;br/&gt;
           SortResultSet.openCore&lt;br/&gt;
            NormalizeResultSet.openCore&lt;br/&gt;
             InsertResultSet.open&lt;/p&gt;

&lt;p&gt;Note that we are still loading the sorter at this point; the sort&lt;br/&gt;
has not yet been performed.&lt;/p&gt;

&lt;p&gt;My conclusion at this point is that I would have to make some much&lt;br/&gt;
more substantial changes to INSERT ... SELECT in order to get it&lt;br/&gt;
to perform the identity column generation &lt;b&gt;after&lt;/b&gt; the ORDER BY&lt;br/&gt;
processing had occurred.&lt;/p&gt;

&lt;p&gt;I&apos;m attaching an updated version of the patch that I was working with,&lt;br/&gt;
and an updated version of the sample SQL statements that I was&lt;br/&gt;
trying to run. The patched code has some interesting behaviors; it&lt;br/&gt;
definitely performs the ORDER BY processing faithfully.&lt;/p&gt;

&lt;p&gt;It just doesn&apos;t provide the identity column guarantees that&lt;br/&gt;
I was interested in exploring.&lt;/p&gt;</comment>
                            <comment id="12498261" author="djd" created="Wed, 23 May 2007 15:56:31 +0100"  >&lt;p&gt;I think your latest findings also relate to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3&quot; title=&quot;Identity column not filled consecutively with &amp;quot;insert ... select distinct&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3&quot;&gt;&lt;del&gt;DERBY-3&lt;/del&gt;&lt;/a&gt;, gaps in the identity sequence.&lt;/p&gt;

&lt;p&gt;BTW - Bernt raised a veto (-1) against this issue, that stands until he rescinds it.&lt;/p&gt;</comment>
                            <comment id="12498277" author="bryanpendleton" created="Wed, 23 May 2007 16:50:49 +0100"  >&lt;p&gt;I&apos;m not actively working on this anymore, although it was a very interesting learning experience and I&apos;m quite grateful for all the comments and suggestions!&lt;/p&gt;

&lt;p&gt;Hopefully this discussion will be useful to those who study this area further in the future.&lt;/p&gt;</comment>
                            <comment id="12498559" author="bernt" created="Thu, 24 May 2007 10:24:12 +0100"  >&lt;p&gt;Consider my veto temporary. When implementing a standard (in this case ISO 9075) one should stick to the standard. If we decide to violate and/or extend the standard, we must be very sure that it won&apos;t create future trouble for us. Such violations/extensions of standards have a nasty habit of backfiring at some later stage (I can point you to numerous examples of that). If we are convinced that this extension of the standard is without such potential problems, I think the feature should be implemented (if someone feels the itch, of course).&lt;/p&gt;</comment>
                            <comment id="12498649" author="bernt" created="Thu, 24 May 2007 15:11:25 +0100"  >&lt;p&gt;Anyway, as Christian metions, implementing ROW_NUMBER() is an alternate solution, which also will solve &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-581&quot; title=&quot;Modify SQL to skip N rows of the result and return the next M rows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-581&quot;&gt;&lt;del&gt;DERBY-581&lt;/del&gt;&lt;/a&gt;. Thus both issues may be solved with one feature which also happen to be defined in the SQL standard. I think that is a much more viable approach.&lt;/p&gt;</comment>
                            <comment id="12499187" author="bryanpendleton" created="Fri, 25 May 2007 18:52:10 +0100"  >&lt;p&gt;As Christian noted, one way for users to work around this limitation is to use&lt;br/&gt;
a stored procedure. In my experiments, I found that a procedure such as the&lt;br/&gt;
following can work acceptably:&lt;/p&gt;

&lt;p&gt;public static final void insertSelectOrderBy(String iString, String sString) throws SQLException&lt;br/&gt;
{&lt;br/&gt;
  Connection conn = DriverManager.getConnection(&quot;jdbc:default:connection&quot;);&lt;br/&gt;
  PreparedStatement iStmt = conn.prepareStatement(iString);&lt;br/&gt;
  Statement s = conn.createStatement();&lt;br/&gt;
  ResultSet rs = s.executeQuery(sString);&lt;br/&gt;
  int numParms = iStmt.getParameterMetaData().getParameterCount();&lt;br/&gt;
  while (rs.next())&lt;/p&gt;
  {
    for (int c = 1; c &amp;lt;= numParms; c++)
      iStmt.setObject(c, rs.getObject(c));
    iStmt.executeUpdate();
  }
&lt;p&gt;  rs.close(); s.close(); iStmt.close(); conn.close();&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;I&apos;m posting this possible workaround in the hopes that others may find it useful.&lt;/p&gt;</comment>
                            <comment id="12678264" author="knutanders" created="Tue, 3 Mar 2009 08:48:43 +0000"  >&lt;p&gt;It might be worth checking if SQL 2008 allows ORDER BY in INSERT INTO&lt;br/&gt;
... SELECT FROM ... . Dag wrote the following in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4079&quot; title=&quot;Add support for SQL:2008 &amp;lt;result offset clause&amp;gt; and &amp;lt;fetch first clause&amp;gt; to limit result set cardinality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4079&quot;&gt;&lt;del&gt;DERBY-4079&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&amp;gt; Note that both ORDER BY and the new clauses above are allowed also in&lt;br/&gt;
&amp;gt; subqueries in the new version of the SQL standard (section 7.13). I&lt;br/&gt;
&amp;gt; only propose to include this at the top level in DERBY for now. (ORDER&lt;br/&gt;
&amp;gt; BY is presently also not allowed in subqueries in Derby since SQL&lt;br/&gt;
&amp;gt; didn&apos;t allow for this until SQL 2008 either).&lt;/p&gt;</comment>
                            <comment id="12678583" author="dagw" created="Wed, 4 Mar 2009 04:50:09 +0000"  >&lt;p&gt;Knut, its seems it does, cf. these productions (quote):&lt;/p&gt;

&lt;p&gt;&amp;lt;query expression&amp;gt; ::=&lt;br/&gt;
 [ &amp;lt;with clause&amp;gt; ] &amp;lt;query expression body&amp;gt;&lt;br/&gt;
     [ &amp;lt;order by clause&amp;gt; ] [ &amp;lt;result offset clause&amp;gt; ] [ &amp;lt;fetch first clause&amp;gt; ]&lt;/p&gt;

&lt;p&gt;&amp;lt;insert statement&amp;gt; ::=&lt;br/&gt;
  INSERT INTO &amp;lt;insertion target&amp;gt; &amp;lt;insert columns and source&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;insert columns and source&amp;gt; ::=&lt;br/&gt;
    &amp;lt;from subquery&amp;gt;&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &amp;lt;from constructor&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &amp;lt;from default&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&amp;lt;from subquery&amp;gt; ::=&lt;br/&gt;
  [ &amp;lt;left paren&amp;gt; &amp;lt;insert column list&amp;gt; &amp;lt;right paren&amp;gt; ]&lt;br/&gt;
      [ &amp;lt;override clause&amp;gt; ]&lt;br/&gt;
      &amp;lt;query expression&amp;gt; &lt;/p&gt;

&lt;p&gt;This is just the syntax, however, but I haven&apos;t found any provision that would bar it.&lt;/p&gt;</comment>
                            <comment id="12769502" author="dagw" created="Fri, 23 Oct 2009 23:41:54 +0100"  >&lt;p&gt;Please note that INSERT INTO ... VALUES ... ORDER BY is not allowed by the 2008 standard, cf&lt;br/&gt;
the explanation given here (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4413&quot; title=&quot;INSERT from SELECT DISTINCT gives assertFailure (sane), or  NPE (insane) in presence of generated columns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4413&quot;&gt;&lt;del&gt;DERBY-4413&lt;/del&gt;&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4413?focusedCommentId=12769492&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12769492&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-4413?focusedCommentId=12769492&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12769492&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12769535" author="chdh@inventec.ch" created="Sat, 24 Oct 2009 00:42:02 +0100"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;Do you mean by &quot;not allowed&quot; that &quot;INSERT INTO ... ORDER BY&quot; is not conforming to the standard, or is it explicitly &quot;not allowed&quot;?&lt;/p&gt;

&lt;p&gt;Is it only not conforming with the VALUES clause, or is &quot;INSERT INTO ... SELECT ... ORDER BY&quot; also not conforming?&lt;/p&gt;</comment>
                            <comment id="12769557" author="dagw" created="Sat, 24 Oct 2009 02:03:09 +0100"  >&lt;p&gt;Christian, it&apos;s only the VALUES .. ORDER BY that is (implicitly by the syntax rules) not conforming.&lt;br/&gt;
It does not say explicitly that is is not allowed, so it would be an extension if we implemented it.&lt;br/&gt;
A SELECT .. ORDER BY is allowed as far as I can see.&lt;/p&gt;</comment>
                            <comment id="12771077" author="dagw" created="Wed, 28 Oct 2009 19:24:54 +0000"  >&lt;p&gt;My interest in warming this up again is &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4397&quot; title=&quot;Allow ORDER BY in subqueries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4397&quot;&gt;&lt;del&gt;DERBY-4397&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
I plan to use a modified version of this patch as part of that work.&lt;/p&gt;

&lt;p&gt;This patch is thus just a baseline of my work on this &quot;subproblem&quot; of&lt;br/&gt;
INSERT combined with ORDER BY and is not intended for commit. I just&lt;br/&gt;
post it here for the record. It passes regression tests, and besides&lt;br/&gt;
whats discussed below it seems to work for what I have thrown at it.&lt;/p&gt;

&lt;p&gt;This patch builds on Bryan&apos;s latest patch proposal for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4&quot; title=&quot;&amp;quot;order by&amp;quot; is not supported for &amp;quot;insert ... select&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4&quot;&gt;&lt;del&gt;DERBY-4&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
(thanks!), and adds a JUnit test. It does &lt;b&gt;not&lt;/b&gt; solve the problem&lt;br/&gt;
(&quot;early&quot; evaluation of identity columns, i.e. they are evaluated&lt;br/&gt;
before the ordering) which Bryan observed. I think the correct&lt;br/&gt;
solution &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; is to defer all default assignments (identity, plain&lt;br/&gt;
DEFAULT, generated columns) till after the result set is ready, as is&lt;br/&gt;
currently done for generated columns. If a target column list is given&lt;br/&gt;
in the INSERT, the result set would then be &quot;narrow&quot; (i.e. not&lt;br/&gt;
containing unspecified columns) until after the ordering. A top PRN&lt;br/&gt;
would be used to inject the missing columns with their (default)&lt;br/&gt;
values. This would solve &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4&quot; title=&quot;&amp;quot;order by&amp;quot; is not supported for &amp;quot;insert ... select&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4&quot;&gt;&lt;del&gt;DERBY-4&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Meanwhile, in preparation for that we should forbid ORDER BY on a&lt;br/&gt;
VALUES clause if it contains DEFAULT values (as a minimum, since&lt;br/&gt;
logically they have no value until after ordering; and physically, in&lt;br/&gt;
the case of generated columns, they are null and can&apos;t be used for&lt;br/&gt;
sorting), and probably also forbid ORDER BY on VALUES at all, as per&lt;br/&gt;
the standard (see explanation on why in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4413&quot; title=&quot;INSERT from SELECT DISTINCT gives assertFailure (sane), or  NPE (insane) in presence of generated columns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4413&quot;&gt;&lt;del&gt;DERBY-4413&lt;/del&gt;&lt;/a&gt;). As it stands,&lt;br/&gt;
this patch does the latter.&lt;/p&gt;

&lt;p&gt;Also, DEFAULT should be allowed only in simple VALUES clause, see&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4426&quot; title=&quot;With generated columns,  INSERT with DEFAULT inside a VALUES clause inside a UNION fails.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4426&quot;&gt;&lt;del&gt;DERBY-4426&lt;/del&gt;&lt;/a&gt;, ensuring it could never be the subject of sorting (e.g. in&lt;br/&gt;
a UNION).&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; See discussion on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4413&quot; title=&quot;INSERT from SELECT DISTINCT gives assertFailure (sane), or  NPE (insane) in presence of generated columns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4413&quot;&gt;&lt;del&gt;DERBY-4413&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Patch details:&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/SingleChildResultSetNode.java&lt;/p&gt;

&lt;p&gt;Added pushOrderByList, InsertNode uses analogue to pattern used by CursorNode.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/NormalizeResultSetNode.java&lt;/p&gt;

&lt;p&gt;Added bindExpressions.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java&lt;/p&gt;

&lt;p&gt;Removed a Sanity assert for a case and added a comment for when the&lt;br/&gt;
scenario can happen.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/CursorNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/OrderByList.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/IntersectOrExceptNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java&lt;/p&gt;

&lt;p&gt;Added colMap to account for column subset/reordering which happens as&lt;br/&gt;
a result of enhanceRCLForInsert called from InsertNode. Note that code&lt;br/&gt;
was written prior to our realizing that a simple VALUES clause could&lt;br/&gt;
not be followed by ORDER BY, so some code can probably be removed now&lt;br/&gt;
if that decision stands.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/InsertNode.java&lt;/p&gt;

&lt;p&gt;Add logic for OrderBy.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj&lt;/p&gt;

&lt;p&gt;Special syntax allowance for ORDER BY in INSERT. Will be&lt;br/&gt;
moved/generalized to subqueries for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4397&quot; title=&quot;Allow ORDER BY in subqueries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4397&quot;&gt;&lt;del&gt;DERBY-4397&lt;/del&gt;&lt;/a&gt;. Added a check that&lt;br/&gt;
ORDER BY can not be applied to a simple VALUES clause.&lt;/p&gt;

&lt;p&gt;A       java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByInSubqueries.java&lt;/p&gt;

&lt;p&gt;Also contains tests for VALUES .. ORDER BY, but commented out.  If the&lt;br/&gt;
check in sqlgrammar is removed these tests can be re-enabled and do&lt;br/&gt;
work.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/AlterTableNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/ColumnDefinitionNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/DMLModStatementNode.java&lt;/p&gt;

&lt;p&gt;Code cleanups only.&lt;/p&gt;</comment>
                            <comment id="12773221" author="knutanders" created="Tue, 3 Nov 2009 21:46:54 +0000"  >&lt;p&gt;Just to be clear, by the following&lt;/p&gt;

&lt;p&gt;&amp;gt; and probably also forbid ORDER BY on VALUES at all&lt;/p&gt;

&lt;p&gt;I take it you mean that it should be prohibited in an INSERT context,&lt;br/&gt;
and not generally for all VALUES clauses?&lt;/p&gt;

&lt;p&gt;That is, this will be disallowed:&lt;/p&gt;

&lt;p&gt;INSERT INTO T VALUES (&apos;a&apos;,&apos;b&apos;),(&apos;b&apos;,&apos;a&apos;) ORDER BY 2&lt;/p&gt;

&lt;p&gt;Whereas this will still be allowed:&lt;/p&gt;

&lt;p&gt;VALUES (&apos;a&apos;,&apos;b&apos;),(&apos;b&apos;,&apos;a&apos;) ORDER BY 2&lt;/p&gt;

&lt;p&gt;If this is what you suggest, +1.&lt;/p&gt;

&lt;p&gt;&amp;gt; Also, DEFAULT should be allowed only in simple VALUES clause, see&lt;br/&gt;
&amp;gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4426&quot; title=&quot;With generated columns,  INSERT with DEFAULT inside a VALUES clause inside a UNION fails.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4426&quot;&gt;&lt;del&gt;DERBY-4426&lt;/del&gt;&lt;/a&gt;, ensuring it could never be the subject of sorting (e.g. in&lt;br/&gt;
&amp;gt; a UNION).&lt;/p&gt;

&lt;p&gt;+1. I believe the current behaviour is just an unintended side-effect&lt;br/&gt;
of the implementation overloading UnionNode to represent both proper&lt;br/&gt;
UNIONs and multi-row VALUES clauses. Supporting this non-standard&lt;br/&gt;
extension of the syntax doesn&apos;t make much sense if it makes it harder&lt;br/&gt;
to get a consistent implementation of the syntax that the standard&lt;br/&gt;
actually defines. Also, I cannot imagine that &quot;INSERT INTO ... VALUES&lt;br/&gt;
1 UNION VALUES DEFAULT&quot; is widely used, if at all.&lt;/p&gt;</comment>
                            <comment id="12773570" author="dagw" created="Wed, 4 Nov 2009 17:12:03 +0000"  >&lt;p&gt;You understood me correctly, Knut, cf. the explanation in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4413&quot; title=&quot;INSERT from SELECT DISTINCT gives assertFailure (sane), or  NPE (insane) in presence of generated columns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4413&quot;&gt;&lt;del&gt;DERBY-4413&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;
</comment>
                            <comment id="12866589" author="knutanders" created="Wed, 12 May 2010 15:50:32 +0100"  >&lt;p&gt;This issue was fixed as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4397&quot; title=&quot;Allow ORDER BY in subqueries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4397&quot;&gt;&lt;del&gt;DERBY-4397&lt;/del&gt;&lt;/a&gt;, so closing it as a duplicate.&lt;/p&gt;</comment>
                            <comment id="13685353" author="knutanders" created="Mon, 17 Jun 2013 10:19:46 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12440634">DERBY-4442</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12437331">DERBY-4397</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12317141">DERBY-581</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12423484" name="derby-4_dhw.diff" size="38522" author="dagw" created="Wed, 28 Oct 2009 19:24:54 +0000"/>
                            <attachment id="12423485" name="derby-4_dhw.stat" size="1145" author="dagw" created="Wed, 28 Oct 2009 19:24:54 +0000"/>
                            <attachment id="12357481" name="insertOrderBy.diff" size="4282" author="bryanpendleton" created="Wed, 16 May 2007 16:52:14 +0100"/>
                            <attachment id="12357706" name="insertOrderBy_v2.diff" size="6419" author="bryanpendleton" created="Sun, 20 May 2007 21:40:14 +0100"/>
                            <attachment id="12357942" name="insertOrderBy_v3.diff" size="8834" author="bryanpendleton" created="Wed, 23 May 2007 05:55:56 +0100"/>
                            <attachment id="12357943" name="samples.ij" size="2350" author="bryanpendleton" created="Wed, 23 May 2007 05:55:56 +0100"/>
                            <attachment id="12357707" name="samples.ij" size="1188" author="bryanpendleton" created="Sun, 20 May 2007 21:40:14 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 28 Sep 2004 07:39:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29362</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0qbr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38083</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>