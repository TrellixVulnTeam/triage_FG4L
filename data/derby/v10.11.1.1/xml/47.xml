<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:54:39 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-47/DERBY-47.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-47] Some possible improvements to IN optimization</title>
                <link>https://issues.apache.org/jira/browse/DERBY-47</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Consider a simple case of  - &lt;br/&gt;
A table tbl has 10000 rows, there is a primary key index on i1&lt;br/&gt;
and the query in question is &lt;br/&gt;
 select * from tbl where i1 in (-1,100000)&lt;/p&gt;

&lt;p&gt;derby does a table scan of the entire table even though the &quot;IN&quot; list has only two values and the comparison is on a field that has an index.&lt;/p&gt;

&lt;p&gt;Briefly looking at the code, it seems like we insert a between and use the IN list to get the start and stop values for the scan. Thus the range of the values in the &quot;IN&quot; list here plays an important role. &lt;/p&gt;

&lt;p&gt;Thus if the query was changed to select * from tbl where i1 in (-1, 1), an index scan would be chosen.&lt;/p&gt;

&lt;p&gt;It would be nice if we could do something clever in this case where there is clearly an index on the field and the number of values in the IN list is known. Maybe use the rowcount estimate and the IN list size to do some optimizations.  &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;consider the length of the &quot;IN&quot; list to do searches on the table.  ie use the IN list values to do index key searches on the table,&lt;br/&gt;
-or try to convert it to a join. Use the &quot;IN&quot; list values to create a temporary table and do a join. It is most likely that the optimizer will choose the table with &quot;IN&quot; list here as the outer table in the join and thus will do key searches on the larger table. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-------------------------------------------------------------------&lt;br/&gt;
some query plans that I logged using derby.language.logQueryPlan=true for some similar queries:&lt;/p&gt;

&lt;p&gt;Table has ascending values from 0 - 9999 for i1. primary key index on i1.&lt;/p&gt;

&lt;p&gt;GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;UT0,5,main&amp;#93;&lt;/span&gt; (XID = 19941), (SESSIONID = 0), select * from scanfixed where i1 in (-1,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990) ******* Project-Restrict ResultSet (2):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 10000&lt;br/&gt;
Rows filtered = 9990&lt;br/&gt;
restriction = true&lt;br/&gt;
projection = false&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count:          750.38&lt;br/&gt;
	optimizer estimated cost:         8579.46&lt;/p&gt;

&lt;p&gt;Source result set:&lt;br/&gt;
	Table Scan ResultSet for SCANFIXED at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 10000&lt;br/&gt;
	Rows filtered = 0&lt;br/&gt;
	Fetch Size = 16&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;	scan information: &lt;br/&gt;
		Bit set of columns fetched=All&lt;br/&gt;
		Number of columns fetched=9&lt;br/&gt;
		Number of pages visited=417&lt;br/&gt;
		Number of rows qualified=10000&lt;br/&gt;
		Number of rows visited=10000&lt;br/&gt;
		Scan type=heap&lt;br/&gt;
		start position: &lt;br/&gt;
null		stop position: &lt;br/&gt;
null		qualifiers:&lt;br/&gt;
Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
Operator: &amp;lt;=&lt;br/&gt;
Ordered nulls: false&lt;br/&gt;
Unknown return value: false&lt;br/&gt;
Negate comparison result: false&lt;br/&gt;
Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
Operator: &amp;lt;&lt;br/&gt;
Ordered nulls: false&lt;br/&gt;
Unknown return value: true&lt;br/&gt;
Negate comparison result: true&lt;/p&gt;

&lt;p&gt;		optimizer estimated row count:          750.38&lt;br/&gt;
		optimizer estimated cost:         8579.46&lt;/p&gt;

&lt;p&gt;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
l&lt;br/&gt;
2004-10-14 18:59:47.577 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;UT0,5,main&amp;#93;&lt;/span&gt; (XID = 19216), (SESSIONID = 0), select * from scanfixed where i1 in (9999,9998,9997,9996,9995,9994,9993,9992,9991,9990) ******* Project-Restrict ResultSet (3):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 10&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = true&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count:            4.80&lt;br/&gt;
	optimizer estimated cost:           39.53&lt;/p&gt;

&lt;p&gt;Source result set:&lt;br/&gt;
	Index Row to Base Row ResultSet for SCANFIXED:&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows seen = 10&lt;br/&gt;
	Columns accessed from heap = &lt;/p&gt;
{0, 1, 2, 3, 4, 5, 6, 7, 8}
&lt;p&gt;		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count:            4.80&lt;br/&gt;
		optimizer estimated cost:           39.53&lt;/p&gt;

&lt;p&gt;		Index Scan ResultSet for SCANFIXED using index SCANFIXEDX at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 10&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 16&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;		scan information: &lt;br/&gt;
			Bit set of columns fetched=All&lt;br/&gt;
			Number of columns fetched=2&lt;br/&gt;
			Number of deleted rows visited=0&lt;br/&gt;
			Number of pages visited=2&lt;br/&gt;
			Number of rows qualified=10&lt;br/&gt;
			Number of rows visited=10&lt;br/&gt;
			Scan type=btree&lt;br/&gt;
			Tree height=2&lt;br/&gt;
			start position: &lt;br/&gt;
	&amp;gt;= on first 1 column(s).&lt;br/&gt;
	Ordered null semantics on the following columns: &lt;/p&gt;

&lt;p&gt;			stop position: &lt;br/&gt;
	&amp;gt; on first 1 column(s).&lt;br/&gt;
	Ordered null semantics on the following columns: &lt;/p&gt;

&lt;p&gt;			qualifiers:&lt;br/&gt;
None&lt;br/&gt;
			optimizer estimated row count:            4.80&lt;br/&gt;
			optimizer estimated cost:           39.53&lt;/p&gt;
</description>
                <environment>all</environment>
        <key id="27899">DERBY-47</key>
            <summary>Some possible improvements to IN optimization</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="skambha">Sunitha Kambhampati</reporter>
                        <labels>
                    </labels>
                <created>Thu, 21 Oct 2004 18:06:07 +0100</created>
                <updated>Thu, 18 Dec 2014 00:10:05 +0000</updated>
                            <resolved>Tue, 20 Mar 2007 00:26:38 +0000</resolved>
                                    <version>10.0.2.0</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>8</votes>
                                    <watches>4</watches>
                                                                                                            <comments>
                            <comment id="12357601" author="kevinhore" created="Tue, 15 Nov 2005 01:02:44 +0000"  >&lt;p&gt;I have also found this issue to be a problem and would like to know whether there are any plans to fix it?&lt;/p&gt;

&lt;p&gt;What follows is a copy of discussion from the derby-users mailing list form 2005/11/11 &quot;Poor query optimizer choices is making Derby unusable for large tables&quot;, it describes how the same behaviour is causing problems for a query with a GROUP BY clause:&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------------&lt;br/&gt;
Hi Kevin,&lt;/p&gt;

&lt;p&gt;Kevin Hore wrote:&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt; i) Does anyone have any plans to fix this problem?&lt;/p&gt;


&lt;p&gt;Can you file an enhancement request for this? I think Derby could&lt;br/&gt;
improve it&apos;s handling of OR/IN clauses. Many databases don&apos;t optimize OR&lt;br/&gt;
clauses as much as possible, though some do better than others. It would&lt;br/&gt;
be great if Derby could internally process this as two different scans&lt;br/&gt;
(one for &apos;CONTACT&apos; and another for &apos;ADD&apos;) and then combine the results.&lt;br/&gt;
Some databases can do this. However, the workaround suggested by Jeff L.&lt;br/&gt;
does this, though you have to rewrite the query.&lt;/p&gt;

&lt;p&gt;Satheesh&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt; ii) In the meantime, are there any work-arounds? I&apos;d appreciate any&lt;br/&gt;
&amp;gt;&amp;gt; suggestions that would decrease the execution time of my second query&lt;br/&gt;
&amp;gt;&amp;gt; below (the one with with two search terms). Likewise, any general&lt;br/&gt;
&amp;gt;&amp;gt; strategies for avoiding this problem with IN clauses would be&lt;br/&gt;
&amp;gt;&amp;gt; appreciated.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; ---&lt;del&gt;PROBLEM DESCRIPTION&lt;/del&gt;---&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Consider the table:&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; CREATE TABLE tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; (&lt;br/&gt;
&amp;gt;&amp;gt; ObjectId int NOT NULL,&lt;br/&gt;
&amp;gt;&amp;gt; ObjectType int NOT NULL,&lt;br/&gt;
&amp;gt;&amp;gt; Word VARCHAR(64) NOT NULL,&lt;br/&gt;
&amp;gt;&amp;gt; WordLocation int NOT NULL,&lt;br/&gt;
&amp;gt;&amp;gt; CONSTRAINT CONSd0e222 UNIQUE (ObjectId,ObjectType,Word,WordLocation)&lt;br/&gt;
&amp;gt;&amp;gt; );&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; This table has an index on each of the four columns, it also has the&lt;br/&gt;
&amp;gt;&amp;gt; unique index across all four columns as defined above:&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; CREATE INDEX tblSearchDictionaryObjectId ON tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; (ObjectId);&lt;br/&gt;
&amp;gt;&amp;gt; CREATE INDEX tblSearchDictionaryObjectType ON tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; (ObjectType);&lt;br/&gt;
&amp;gt;&amp;gt; CREATE INDEX tblSearchDictionaryWord ON tblSearchDictionary (Word);&lt;br/&gt;
&amp;gt;&amp;gt; CREATE INDEX tblSearchDictionaryWordLocation ON tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; (WordLocation);&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; The table contains about 260,000 rows.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; The following query selects all rows that match instances of string in&lt;br/&gt;
&amp;gt;&amp;gt; the Word column. It sums the WordLocation column having grouped by the&lt;br/&gt;
&amp;gt;&amp;gt; ObjectId column.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; SELECT ObjectId, SUM(WordLocation) AS Score&lt;br/&gt;
&amp;gt;&amp;gt; FROM tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; WHERE Word = &apos;CONTACT&apos;&lt;br/&gt;
&amp;gt;&amp;gt; GROUP BY ObjectId;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; On my machine this will usually complete in an acceptable time of&lt;br/&gt;
&amp;gt;&amp;gt; around 200ms.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Now consider the following query which adds a second search term on&lt;br/&gt;
&amp;gt;&amp;gt; the same column.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; SELECT ObjectId, SUM(WordLocation) AS Score&lt;br/&gt;
&amp;gt;&amp;gt; FROM tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; WHERE Word = &apos;CONTACT&apos; OR Word = &apos;ADD&apos;&lt;br/&gt;
&amp;gt;&amp;gt; GROUP BY ObjectId;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; This second query usually takes around 10000ms on my machine. My&lt;br/&gt;
&amp;gt;&amp;gt; understanding from the Derby optimizer docs and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; is that this&lt;br/&gt;
&amp;gt;&amp;gt; is because Derby is re-writing the query along the following lines,&lt;br/&gt;
&amp;gt;&amp;gt; and then choosing to do a table scan:&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; SELECT ObjectId, SUM(WordLocation) AS Score&lt;br/&gt;
&amp;gt;&amp;gt; FROM tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; WHERE&lt;br/&gt;
&amp;gt;&amp;gt;   Word IN (&apos;CONTACT&apos;, &apos;ADD&apos;)&lt;br/&gt;
&amp;gt;&amp;gt;   AND Word &amp;gt;= &apos;ADD&apos;&lt;br/&gt;
&amp;gt;&amp;gt;   AND Word &amp;lt;= &apos;CONTACT&apos;&lt;br/&gt;
&amp;gt;&amp;gt; GROUP BY ObjectId;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; The plan for the first query indicates that the tblSearchDictionaryWord&lt;br/&gt;
&amp;gt;&amp;gt; index is used to perform an index scan. However, the plan for the second&lt;br/&gt;
&amp;gt;&amp;gt; query indicates that the majority of the additional time is taken&lt;br/&gt;
&amp;gt;&amp;gt; performing a table scan over the entire table, instead of making use of&lt;br/&gt;
&amp;gt;&amp;gt; the indexes available. Our application uses IN quite frequently, so&lt;br/&gt;
&amp;gt;&amp;gt; this optimizer behaviour would seem to present a significant problem.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; --&lt;del&gt;QUERY PLAN FOR FIRST QUERY&lt;/del&gt;---&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Statement Name:&lt;br/&gt;
&amp;gt;&amp;gt;     null&lt;br/&gt;
&amp;gt;&amp;gt; Statement Text:&lt;br/&gt;
&amp;gt;&amp;gt;     SELECT&lt;br/&gt;
&amp;gt;&amp;gt;     ObjectId,&lt;br/&gt;
&amp;gt;&amp;gt;     SUM(WordLocation) AS Score&lt;br/&gt;
&amp;gt;&amp;gt; FROM tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; WHERE&lt;br/&gt;
&amp;gt;&amp;gt;         Word = &apos;CONTACT&apos;&lt;br/&gt;
&amp;gt;&amp;gt; GROUP BY&lt;br/&gt;
&amp;gt;&amp;gt;     ObjectId&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Parse Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Bind Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Optimize Time: 16&lt;br/&gt;
&amp;gt;&amp;gt; Generate Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Compile Time: 16&lt;br/&gt;
&amp;gt;&amp;gt; Execute Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Begin Compilation Timestamp : 2005-11-11 12:28:52.765&lt;br/&gt;
&amp;gt;&amp;gt; End Compilation Timestamp : 2005-11-11 12:28:52.781&lt;br/&gt;
&amp;gt;&amp;gt; Begin Execution Timestamp : 2005-11-11 13:08:15.406&lt;br/&gt;
&amp;gt;&amp;gt; End Execution Timestamp : 2005-11-11 13:08:15.406&lt;br/&gt;
&amp;gt;&amp;gt; Statement Execution Plan Text:&lt;br/&gt;
&amp;gt;&amp;gt; Project-Restrict ResultSet (5):&lt;br/&gt;
&amp;gt;&amp;gt; Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt; Rows seen = 93&lt;br/&gt;
&amp;gt;&amp;gt; Rows filtered = 0&lt;br/&gt;
&amp;gt;&amp;gt; restriction = false&lt;br/&gt;
&amp;gt;&amp;gt; projection = true&lt;br/&gt;
&amp;gt;&amp;gt;     constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     restriction time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     projection time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     optimizer estimated row count:            1.00&lt;br/&gt;
&amp;gt;&amp;gt;     optimizer estimated cost:          226.00&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;     Grouped Aggregate ResultSet:&lt;br/&gt;
&amp;gt;&amp;gt;     Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;     Rows input = 113&lt;br/&gt;
&amp;gt;&amp;gt;     Has distinct aggregate = false&lt;br/&gt;
&amp;gt;&amp;gt;     In sorted order = false&lt;br/&gt;
&amp;gt;&amp;gt;     Sort information:&lt;br/&gt;
&amp;gt;&amp;gt;         Number of rows input=113&lt;br/&gt;
&amp;gt;&amp;gt;         Number of rows output=93&lt;br/&gt;
&amp;gt;&amp;gt;         Sort type=internal&lt;br/&gt;
&amp;gt;&amp;gt;         constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         optimizer estimated row count:            1.00&lt;br/&gt;
&amp;gt;&amp;gt;         optimizer estimated cost:          226.00&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;         Project-Restrict ResultSet (4):&lt;br/&gt;
&amp;gt;&amp;gt;         Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;         Rows seen = 113&lt;br/&gt;
&amp;gt;&amp;gt;         Rows filtered = 0&lt;br/&gt;
&amp;gt;&amp;gt;         restriction = false&lt;br/&gt;
&amp;gt;&amp;gt;         projection = true&lt;br/&gt;
&amp;gt;&amp;gt;             constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             restriction time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             projection time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             optimizer estimated row count:          118.00&lt;br/&gt;
&amp;gt;&amp;gt;             optimizer estimated cost:          226.00&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;         Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;             Index Row to Base Row ResultSet for TBLSEARCHDICTIONARY:&lt;br/&gt;
&amp;gt;&amp;gt;             Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;             Rows seen = 113&lt;br/&gt;
&amp;gt;&amp;gt;             Columns accessed from heap = &lt;/p&gt;
{0, 3}
&lt;p&gt;&amp;gt;&amp;gt;                 constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 optimizer estimated row count:          118.00&lt;br/&gt;
&amp;gt;&amp;gt;                 optimizer estimated cost:          226.00&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;                 Index Scan ResultSet for TBLSEARCHDICTIONARY using index&lt;br/&gt;
&amp;gt;&amp;gt; TBLSEARCHDICTIONARYWORD at read committed isolation level using share&lt;br/&gt;
&amp;gt;&amp;gt; row locking chosen by the optimizer&lt;br/&gt;
&amp;gt;&amp;gt;                 Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;                 Rows seen = 113&lt;br/&gt;
&amp;gt;&amp;gt;                 Rows filtered = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 Fetch Size = 1&lt;br/&gt;
&amp;gt;&amp;gt;                     constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                     open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                     next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                     close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                     next time in milliseconds/row = 0&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;                 scan information:&lt;br/&gt;
&amp;gt;&amp;gt;                     Bit set of columns fetched=All&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of columns fetched=2&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of deleted rows visited=0&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of pages visited=4&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of rows qualified=113&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of rows visited=114&lt;br/&gt;
&amp;gt;&amp;gt;                     Scan type=btree&lt;br/&gt;
&amp;gt;&amp;gt;                     Tree height=3&lt;br/&gt;
&amp;gt;&amp;gt;                     start position:&lt;br/&gt;
&amp;gt;&amp;gt;     &amp;gt;= on first 1 column(s).&lt;br/&gt;
&amp;gt;&amp;gt;     Ordered null semantics on the following columns:&lt;br/&gt;
&amp;gt;&amp;gt; 0&lt;br/&gt;
&amp;gt;&amp;gt;                     stop position:&lt;br/&gt;
&amp;gt;&amp;gt;     &amp;gt; on first 1 column(s).&lt;br/&gt;
&amp;gt;&amp;gt;     Ordered null semantics on the following columns:&lt;br/&gt;
&amp;gt;&amp;gt; 0&lt;br/&gt;
&amp;gt;&amp;gt;                     qualifiers:&lt;br/&gt;
&amp;gt;&amp;gt; None&lt;br/&gt;
&amp;gt;&amp;gt;                     optimizer estimated row count:          118.00&lt;br/&gt;
&amp;gt;&amp;gt;                     optimizer estimated cost:          226.00&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; --&lt;del&gt;QUERY PLAN FOR SECOND QUERY&lt;/del&gt;---&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Statement Name:&lt;br/&gt;
&amp;gt;&amp;gt;     null&lt;br/&gt;
&amp;gt;&amp;gt; Statement Text:&lt;br/&gt;
&amp;gt;&amp;gt;     SELECT&lt;br/&gt;
&amp;gt;&amp;gt;     ObjectId,&lt;br/&gt;
&amp;gt;&amp;gt;     SUM(WordLocation) AS Score&lt;br/&gt;
&amp;gt;&amp;gt; FROM tblSearchDictionary&lt;br/&gt;
&amp;gt;&amp;gt; WHERE&lt;br/&gt;
&amp;gt;&amp;gt;         Word = &apos;CONTACT&apos; OR  Word = &apos;ADD&apos;&lt;br/&gt;
&amp;gt;&amp;gt; GROUP BY&lt;br/&gt;
&amp;gt;&amp;gt;     ObjectId&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Parse Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Bind Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Optimize Time: 0&lt;br/&gt;
&amp;gt;&amp;gt; Generate Time: 15&lt;br/&gt;
&amp;gt;&amp;gt; Compile Time: 15&lt;br/&gt;
&amp;gt;&amp;gt; Execute Time: 4250&lt;br/&gt;
&amp;gt;&amp;gt; Begin Compilation Timestamp : 2005-11-11 13:16:17.578&lt;br/&gt;
&amp;gt;&amp;gt; End Compilation Timestamp : 2005-11-11 13:16:17.593&lt;br/&gt;
&amp;gt;&amp;gt; Begin Execution Timestamp : 2005-11-11 13:16:17.593&lt;br/&gt;
&amp;gt;&amp;gt; End Execution Timestamp : 2005-11-11 13:16:27.437&lt;br/&gt;
&amp;gt;&amp;gt; Statement Execution Plan Text:&lt;br/&gt;
&amp;gt;&amp;gt; Project-Restrict ResultSet (5):&lt;br/&gt;
&amp;gt;&amp;gt; Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt; Rows seen = 100&lt;br/&gt;
&amp;gt;&amp;gt; Rows filtered = 0&lt;br/&gt;
&amp;gt;&amp;gt; restriction = false&lt;br/&gt;
&amp;gt;&amp;gt; projection = true&lt;br/&gt;
&amp;gt;&amp;gt;     constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     open time (milliseconds) = 4250&lt;br/&gt;
&amp;gt;&amp;gt;     next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     restriction time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     projection time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;     optimizer estimated row count:            1.00&lt;br/&gt;
&amp;gt;&amp;gt;     optimizer estimated cost:        82959.49&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;     Grouped Aggregate ResultSet:&lt;br/&gt;
&amp;gt;&amp;gt;     Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;     Rows input = 712&lt;br/&gt;
&amp;gt;&amp;gt;     Has distinct aggregate = false&lt;br/&gt;
&amp;gt;&amp;gt;     In sorted order = false&lt;br/&gt;
&amp;gt;&amp;gt;     Sort information:&lt;br/&gt;
&amp;gt;&amp;gt;         Number of rows input=712&lt;br/&gt;
&amp;gt;&amp;gt;         Number of rows output=593&lt;br/&gt;
&amp;gt;&amp;gt;         Sort type=internal&lt;br/&gt;
&amp;gt;&amp;gt;         constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         open time (milliseconds) = 4250&lt;br/&gt;
&amp;gt;&amp;gt;         next time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         close time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;         optimizer estimated row count:            1.00&lt;br/&gt;
&amp;gt;&amp;gt;         optimizer estimated cost:        82959.49&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;         Project-Restrict ResultSet (4):&lt;br/&gt;
&amp;gt;&amp;gt;         Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;         Rows seen = 712&lt;br/&gt;
&amp;gt;&amp;gt;         Rows filtered = 0&lt;br/&gt;
&amp;gt;&amp;gt;         restriction = false&lt;br/&gt;
&amp;gt;&amp;gt;         projection = true&lt;br/&gt;
&amp;gt;&amp;gt;             constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             next time (milliseconds) = 4219&lt;br/&gt;
&amp;gt;&amp;gt;             close time (milliseconds) = 15&lt;br/&gt;
&amp;gt;&amp;gt;             restriction time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             projection time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;             optimizer estimated row count:        19200.45&lt;br/&gt;
&amp;gt;&amp;gt;             optimizer estimated cost:        82959.49&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;         Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;             Project-Restrict ResultSet (3):&lt;br/&gt;
&amp;gt;&amp;gt;             Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;             Rows seen = 40806&lt;br/&gt;
&amp;gt;&amp;gt;             Rows filtered = 40094&lt;br/&gt;
&amp;gt;&amp;gt;             restriction = true&lt;br/&gt;
&amp;gt;&amp;gt;             projection = false&lt;br/&gt;
&amp;gt;&amp;gt;                 constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 next time (milliseconds) = 4219&lt;br/&gt;
&amp;gt;&amp;gt;                 close time (milliseconds) = 15&lt;br/&gt;
&amp;gt;&amp;gt;                 restriction time (milliseconds) = 124&lt;br/&gt;
&amp;gt;&amp;gt;                 projection time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 optimizer estimated row count:        19200.45&lt;br/&gt;
&amp;gt;&amp;gt;                 optimizer estimated cost:        82959.49&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;             Source result set:&lt;br/&gt;
&amp;gt;&amp;gt;                 Table Scan ResultSet for TBLSEARCHDICTIONARY at read&lt;br/&gt;
&amp;gt;&amp;gt; committed&lt;br/&gt;
&amp;gt;&amp;gt; isolation level using share row locking chosen by the optimizer&lt;br/&gt;
&amp;gt;&amp;gt;                 Number of opens = 1&lt;br/&gt;
&amp;gt;&amp;gt;                 Rows seen = 40806&lt;br/&gt;
&amp;gt;&amp;gt;                 Rows filtered = 0&lt;br/&gt;
&amp;gt;&amp;gt;                 Fetch Size = 1&lt;br/&gt;
&amp;gt;&amp;gt;                     constructor time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                     open time (milliseconds) = 0&lt;br/&gt;
&amp;gt;&amp;gt;                     next time (milliseconds) = 4001&lt;br/&gt;
&amp;gt;&amp;gt;                     close time (milliseconds) = 15&lt;br/&gt;
&amp;gt;&amp;gt;                     next time in milliseconds/row = 0&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;                 scan information:&lt;br/&gt;
&amp;gt;&amp;gt;                     Bit set of columns fetched=&lt;/p&gt;
{0, 2, 3}
&lt;p&gt;&amp;gt;&amp;gt;                     Number of columns fetched=3&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of pages visited=2978&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of rows qualified=40806&lt;br/&gt;
&amp;gt;&amp;gt;                     Number of rows visited=256001&lt;br/&gt;
&amp;gt;&amp;gt;                     Scan type=heap&lt;br/&gt;
&amp;gt;&amp;gt;                     start position:&lt;br/&gt;
&amp;gt;&amp;gt; null                    stop position:&lt;br/&gt;
&amp;gt;&amp;gt; null                    qualifiers:&lt;br/&gt;
&amp;gt;&amp;gt; Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 2&lt;br/&gt;
&amp;gt;&amp;gt; Operator: &amp;lt;&lt;br/&gt;
&amp;gt;&amp;gt; Ordered nulls: false&lt;br/&gt;
&amp;gt;&amp;gt; Unknown return value: true&lt;br/&gt;
&amp;gt;&amp;gt; Negate comparison result: true&lt;br/&gt;
&amp;gt;&amp;gt; Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Id: 2&lt;br/&gt;
&amp;gt;&amp;gt; Operator: &amp;lt;=&lt;br/&gt;
&amp;gt;&amp;gt; Ordered nulls: false&lt;br/&gt;
&amp;gt;&amp;gt; Unknown return value: false&lt;br/&gt;
&amp;gt;&amp;gt; Negate comparison result: false&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;                     optimizer estimated row count:        19200.45&lt;br/&gt;
&amp;gt;&amp;gt;                     optimizer estimated cost:        82959.49&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; ----------&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Thanks in advance for any help!&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Kind regards,&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Kevin Hore&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12357700" author="kevinhore" created="Wed, 16 Nov 2005 00:24:20 +0000"  >&lt;p&gt;I have evidence (presented below) that the query optimizer is making some very poor choices when deciding how to make use of the available indexes. Unfortunately, this is making Derby unusable for the application I&apos;m working on.&lt;/p&gt;

&lt;p&gt;Clearly, the Derby engine is fundamentally capable of executing queries in a sensible amount of time, but the query optimizer appears to get confused if there are several indexes to choose from and multiple references to the same column in the WHERE clause.&lt;/p&gt;

&lt;p&gt;In my previous, comment I gave details of simple example that demonstrated the problem. To recap, I am executing variants of the following SQL against a relatively simple table:&lt;/p&gt;

&lt;p&gt;SELECT ObjectId, SUM(WordLocation) AS Score&lt;br/&gt;
FROM tblSearchDictionary&lt;br/&gt;
WHERE Word = &apos;CONTACT&apos; OR  Word = &apos;ADD&apos;&lt;br/&gt;
GROUP BY ObjectId;&lt;/p&gt;

&lt;p&gt;It makes no difference to the query performance or query plan if the WHERE clause is as above, or is re-written as:&lt;/p&gt;

&lt;p&gt;WHERE Word IN (&apos;CONTACT&apos;, &apos;ADD&apos;)&lt;/p&gt;

&lt;p&gt;&amp;#8211; ORIGINAL RESULTS: &amp;#8211;&lt;/p&gt;

&lt;p&gt;The timings with the schema described in my previous comment are:&lt;/p&gt;

&lt;p&gt;Matching one term: ~200ms avg.&lt;br/&gt;
Matching two terms: ~10000ms avg.&lt;/p&gt;

&lt;p&gt;The &quot;matching one term&quot; timings are with the following WHERE clause:&lt;/p&gt;

&lt;p&gt;WHERE Word = &apos;CONTACT&apos;&lt;/p&gt;

&lt;p&gt;(searching just for &apos;ADD&apos; gives similar timings).&lt;/p&gt;

&lt;p&gt;The &quot;matching two terms&quot; timings are with the following WHERE clause:&lt;/p&gt;

&lt;p&gt;WHERE Word = &apos;CONTACT&apos; OR Word = &apos;ADD&apos;&lt;/p&gt;

&lt;p&gt;The query plans for these timings can be found in my previous comment.&lt;/p&gt;

&lt;p&gt;With some suggestions from the derby-users list, I have attempted to redefine the indexes on the table to see if that will have any effect on the choices made by the query planner.&lt;/p&gt;

&lt;p&gt;Dropping all the column indexes and then reordering the unique constraint so that the most varying column is first, and the least varying last, caused the query planner to change its plan to use the index backing the unique constraint to match the terms.&lt;/p&gt;

&lt;p&gt;DROP INDEX TBLSEARCHDICTIONARYOBJECTID;&lt;br/&gt;
DROP INDEX TBLSEARCHDICTIONARYOBJECTTYPE;&lt;br/&gt;
DROP INDEX TBLSEARCHDICTIONARYWORD;&lt;br/&gt;
DROP INDEX TBLSEARCHDICTIONARYWORDLOCATION;&lt;br/&gt;
ALTER TABLE TBLSEARCHDICTIONARY DROP UNIQUE CONSd0e222&lt;br/&gt;
ALTER TABLE TBLSEARCHDICTIONARY ADD CONSTRAINT CONSd0e222 UNIQUE&lt;br/&gt;
(ObjectId,Word,WordLocation,ObjectType);&lt;/p&gt;

&lt;p&gt;However from the results you can see that the search for a single term suffered a big loss in performance.&lt;/p&gt;

&lt;p&gt;&amp;#8211; RESULTS WITH OPTIMIZED CONSTRAINT:  &amp;#8211;&lt;/p&gt;

&lt;p&gt;Matching one term: ~4000ms avg.&lt;br/&gt;
Matching two terms: ~600ms avg.&lt;/p&gt;

&lt;p&gt;I have attached the relevant query plans for each of these results.&lt;/p&gt;

&lt;p&gt;This is a very surprising result: matching one term performs far worse than matching two.&lt;/p&gt;

&lt;p&gt;In an attempt to remedy problem of the poor single term performance, I re-introduced the index to the Word column with the following schema change:&lt;/p&gt;

&lt;p&gt;CREATE INDEX tblSearchDictionaryWord ON tblSearchDictionary (Word );&lt;/p&gt;

&lt;p&gt;&amp;#8211; RESULTS WITH OPTIMIZED CONSTRAINT AND INDEX ON WORD FIELD:  &amp;#8211;&lt;/p&gt;

&lt;p&gt;Matching one term: ~200ms avg.&lt;br/&gt;
Matching two terms: ~4500 ms avg.&lt;/p&gt;

&lt;p&gt;Again, I have attached the relevant query plans.&lt;/p&gt;

&lt;p&gt;Although the additional index is used in the single term query, it can be seen that adding the additional index has the effect of causing the planner to get confused about which indexes to use for the two term case. The plan here shows an index scan of both indexes, resulting in an average time seven times worse than before.&lt;/p&gt;

&lt;p&gt;I should add here that replacing the WHERE OR clause for the two term query with an IN() produces exactly the same plan and results, which is what one would expect based on the Derby documentation&apos;s description of how the optimizer re-writes WHERE OR clauses.&lt;/p&gt;

&lt;p&gt;It seems to me that the optimizer is broken when processing WHERE clauses with OR and WHERE clauses with IN. The engine is obviously capable of executing my example in a reasonable time, but the planner&apos;s choices let it down. This causes significant problems in large applications with many complex queries, particularly where the number of terms in an IN clause varies, as it then becomes almost impossible to construct queries that execute with reliably acceptable performance.&lt;/p&gt;

&lt;p&gt;It may be interesting to note that the application I&apos;m working on also can also use Mckoi or SQL Server 2000. Both the single and double term searches execute with acceptable performance with both of those database engines.&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;br/&gt;
Kevin Hore&lt;br/&gt;
www.araxis.com&lt;/p&gt;</comment>
                            <comment id="12357701" author="kevinhore" created="Wed, 16 Nov 2005 00:30:59 +0000"  >&lt;p&gt;Query plan for comment made by Kevin Hore 2005/11/15. This is the query plan produced by the optimizer when matching only a single term in a table that contains only the revised unique index.&lt;/p&gt;</comment>
                            <comment id="12357702" author="kevinhore" created="Wed, 16 Nov 2005 00:31:37 +0000"  >&lt;p&gt;Query plan for comment made by Kevin Hore 2005/11/15. This is the query plan produced by the optimizer when matchingtwo terms in a table that contains only the revised unique index.&lt;/p&gt;</comment>
                            <comment id="12357703" author="kevinhore" created="Wed, 16 Nov 2005 00:32:37 +0000"  >&lt;p&gt;Query plan for comment made by Kevin Hore 2005/11/15. This is the query plan produced by the optimizer when matching only a single term in a table that contains only the revised unique index.&lt;/p&gt;</comment>
                            <comment id="12357704" author="kevinhore" created="Wed, 16 Nov 2005 00:33:03 +0000"  >&lt;p&gt;Query plan for comment made by Kevin Hore 2005/11/15. This is the query plan produced by the optimizer when matching two terms in a table that contains only the revised unique index.&lt;/p&gt;</comment>
                            <comment id="12358064" author="bandaram" created="Sat, 19 Nov 2005 16:51:37 +0000"  >&lt;p&gt;Is it possible to contribute a test case with data that I can quickly setup to try on my machine? Make sure your data is sharable (to the whole world!). I do see some numbers here that I don&apos;t understand how it is possible, especially the case of two terms being faster than one. I would like to confirm if because of possible page cache and/or other suspects I have.&lt;/p&gt;</comment>
                            <comment id="12358463" author="danielneades" created="Thu, 24 Nov 2005 23:59:52 +0000"  >&lt;p&gt;I&apos;ll try to schedule some time for one of our engineers to contribute a test case with data. We&apos;re in the middle of a release cycle right now, so it might not be done straight away. Thank you for your interest.&lt;/p&gt;</comment>
                            <comment id="12432636" author="jmsynge" created="Tue, 5 Sep 2006 18:29:21 +0100"  >&lt;p&gt;I spent much of last week tracking down a performance problem in an application that I&apos;m working on, and it turned out to be described here.&lt;/p&gt;

&lt;p&gt;I developed a test application (that I will attach) that explores different ways of doing essentially this query:&lt;/p&gt;

&lt;p&gt;        SELECT * FROM myTable WHERE foreignKeyColumn IN (?, ..., ?)&lt;/p&gt;

&lt;p&gt;We tried the following strategies:&lt;/p&gt;

&lt;p&gt;Literals        - 1 query, using WHERE column IN (&apos;literal1&apos;, ..., &apos;literalN&apos;)&lt;br/&gt;
Literal         - N queries, using WHERE column = &apos;literal&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;&lt;br/&gt;
Markers         - 1 query, using WHERE column IN (?, ..., ?)&lt;br/&gt;
Marker          - N queries, using WHERE column = ?&lt;br/&gt;
TempTable       - 1 query, store parameters in a temp table, use nested select, then delete parameters&lt;br/&gt;
ScratchPad      - 1 query, store parameters in a table, use nested select, then delete parameters&lt;br/&gt;
ScrSavepoint    - 1 query, set savepoint, store parameters in a table, use nested select, then rollback savepoint&lt;/p&gt;

&lt;p&gt;We were astonished to find that converting the query to:&lt;/p&gt;

&lt;p&gt;        SELECT * FROM myTable WHERE foreignKeyColumn = ?&lt;/p&gt;

&lt;p&gt;And repeating that query N times was by far the best performer out of 7 different strategies I tried.  (This is what I call the Marker strategy above.)&lt;/p&gt;

&lt;p&gt;Here are the results for a table with 100,000 rows in it, and then after that for 1,000,000 rows:&lt;br/&gt;
(Note: this table is tab delimited, for easy importing into Excel.  I&apos;ll also attach this data.)&lt;/p&gt;

&lt;p&gt;	Literals		Literal		Markers		Marker		TempTable		ScratchPad		ScrSavepoint		&lt;br/&gt;
ID Count	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms&lt;br/&gt;
1	20	20	10	10	10	10	0	0	1232	1232	1132	1132	1022	1022&lt;br/&gt;
2	881	440	20	10	450	225	0	0	1022	511	1041	520	1042	521&lt;br/&gt;
3	1051	350	30	10	2794	931	0	0	1022	340	1022	340	1012	337&lt;br/&gt;
4	1012	253	40	10	2013	503	0	0	1032	258	1002	250	1202	300&lt;br/&gt;
5	1132	226	40	8	2053	410	0	0	1032	206	1022	204	1042	208&lt;br/&gt;
6	1042	173	50	8	1523	253	0	0	1012	168	1022	170	1051	175&lt;br/&gt;
7	1132	161	60	8	3145	449	0	0	1022	146	1032	147	1112	158&lt;br/&gt;
8	1102	137	60	7	3034	379	10	1	1062	132	1202	150	1082	135&lt;br/&gt;
9	1102	122	60	6	2965	329	0	0	1142	126	1151	127	992	110&lt;br/&gt;
10	1112	111	70	7	3526	352	0	0	1022	102	1052	105	1062	106&lt;br/&gt;
20	1142	57	120	6	3746	187	10	0	1022	51	1112	55	1232	61&lt;br/&gt;
30	1317	43	195	6	4117	137	10	0	1022	34	1082	36	1072	35&lt;br/&gt;
40	1252	31	250	6	4417	110	20	0	1022	25	1091	27	1282	32&lt;br/&gt;
50	1292	25	320	6	4777	95	20	0	1062	21	1052	21	1052	21&lt;br/&gt;
60	1327	22	350	5	5068	84	20	0	1062	17	1082	18	1112	18&lt;br/&gt;
70	1332	19	415	5	5504	78	30	0	1042	14	1142	16	1081	15&lt;br/&gt;
80	1327	16	471	5	5769	72	40	0	1041	13	1052	13	1277	15&lt;br/&gt;
90	1362	15	481	5	6330	70	40	0	1052	11	1152	12	1092	12&lt;br/&gt;
100	1372	13	536	5	6460	64	40	0	1283	12	1092	10	1202	12&lt;/p&gt;


&lt;p&gt;=============================================================================================================================&lt;/p&gt;

&lt;p&gt;	Literals		Literal		Markers		Marker		TempTable		ScratchPad		ScrSavepoint		&lt;br/&gt;
ID Count	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms	Total ms	Avg ms&lt;br/&gt;
1	160	160	70	70	40	40	41	41	69841	69841	44261	44261	36699	36699&lt;br/&gt;
2	44120	22060	181	90	222124	111062	0	0	8624	4312	6851	3425	6580	3290&lt;br/&gt;
3	10958	3652	120	40	12540	4180	10	3	6461	2153	6431	2143	6520	2173&lt;/p&gt;
</comment>
                            <comment id="12432866" author="jmsynge" created="Wed, 6 Sep 2006 15:52:58 +0100"  >&lt;p&gt;Updated the performance test with 3 join queries, to compare with the 3 nested queries (the joins perform much better).&lt;/p&gt;</comment>
                            <comment id="12451812" author="bryanpendleton" created="Tue, 21 Nov 2006 23:17:37 +0000"  >&lt;p&gt;Note that there is a Wiki page related to this issue: &lt;a href=&quot;http://wiki.apache.org/db-derby/DerbyBug47&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/DerbyBug47&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12459063" author="jmsynge" created="Sat, 16 Dec 2006 19:00:05 +0000"  >&lt;p&gt;I&apos;m (finally) preparing to work on this issue.  I have a general approach, which is to replace the IN LIST with an IN (sub-query-of-single-column-VirtualTable), but also some open questions.&lt;/p&gt;

&lt;p&gt;The basic question is &quot;when&quot; should I replace the IN predicate?  The two basic choices would seem to be during preprocessing or during getNextDecoratedPermutation.  The former would likely be simpler to implement, but would my force solution to always be used (which, given the poor cost estimates produced due to this bug, might be a good thing).  The latter would require replacing the Optimizable against which the IN predicate is being evaluated with a substitute that represents a nested join (probably).  I really don&apos;t have enough of a grasp of the sub-query optimization to know whether that is a good idea or not.&lt;/p&gt;

&lt;p&gt;The next question is how do I pass information to the VTI implementation regarding which parameters of the activation should it use as the values in the virtual table?  I suspect that the constructor will need to take the range [N, N+M) of parameter indices, and also some array of literals; i.e. the IN list can consist of both parameter markers, and literal parameters.  If the IN list were to include columns or functions, I suspect we&apos;d want to skip this &quot;solution&quot; as it wouldn&apos;t support that.&lt;/p&gt;

&lt;p&gt;I assume that the activation object passed to the VTI constructor in VTIResultSet.opencore is where I would get the values for the parameters.&lt;/p&gt;</comment>
                            <comment id="12459466" author="jmsynge" created="Mon, 18 Dec 2006 21:14:55 +0000"  >&lt;p&gt;I&apos;m currently looking to add the following if/else branch to InListOperatorNode:&lt;/p&gt;

&lt;p&gt;		else if ((leftOperand instanceof ColumnReference) &amp;amp;&amp;amp;&lt;br/&gt;
				 rightOperandList.containsAllConstantOrParameterNodes())&lt;/p&gt;
		{
			// TODO Create nodes representing a sub-select
			// SubqueryNode
			//		SelectNode
			//			FromList
			//				FromVTI
			//				(include the correlation name?)
			//					NewInvocationNode
			//						JSQLType (org.derby...InListAsTableVTI)
			//			ResultColumnList
			//				ResultColumn
			//			(don&apos;t need a where clause)
			//
			// Issue: how do I assign the table number for the FromVTI?
			// Issue: how do I get binding done for this new SelectNode?
			// 		(this is obviously trivial, but needs to be done)
			
			return this;
		}</comment>
                            <comment id="12459697" author="djd" created="Tue, 19 Dec 2006 17:08:29 +0000"  >&lt;p&gt;Are there possible existing temporary table mechanisms that could be used instead of relying on VTIs?&lt;br/&gt;
I would have thought there are existing cases where a temporary table is built during a query execution and used in subsequent joins.&lt;/p&gt;

&lt;p&gt;The concern I have over VTIs is type conversion, VTI&apos;s return rows as JDBC types, but the input to the IN list is in terms of internal DataValueDescriptors. If the IN list values could be kept as internal types then I think the solution would be easier.&lt;/p&gt;

&lt;p&gt;Of course this could be implemented using VTIs and subsequently improved to use an internal table type (language ResultSet implementation), but I wonder if that approach will lead to unnecessary  work.&lt;/p&gt;

&lt;p&gt;Even if an existing table type is not used, I wonder if it&apos;s easier to provide an implementation of Derby&apos;s language ResultSet wrapped around a collection of values instead of the JDBC ResultSet doing the same work. Of course with a new language ResultSet there may be more optimization work that one gets for free with a VTI.&lt;/p&gt;

&lt;p&gt;language ResultSet = org.apache.derby.iapi.sql.ResultSet&lt;/p&gt;


</comment>
                            <comment id="12459716" author="djd" created="Tue, 19 Dec 2006 18:24:43 +0000"  >&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2152&quot; title=&quot;Support diagnostic vti tables that take parameters, such as SpaceTable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2152&quot;&gt;&lt;del&gt;DERBY-2152&lt;/del&gt;&lt;/a&gt; James wrote:&lt;br/&gt;
--------------------&lt;br/&gt;
I&apos;m experimenting with transforming a query such as: &lt;/p&gt;

&lt;p&gt;SELECT * FROM tableA WHERE columnB IN (constC, ?, ?, constD)&lt;/p&gt;

&lt;p&gt;into&lt;/p&gt;

&lt;p&gt;SELECT * FROM tableA WHERE columnB IN (SELECT vti.column1 FROM new ArgsToRowsVTI(SomeArgs)) &lt;br/&gt;
----------------------&lt;/p&gt;

&lt;p&gt;Is this an step to solving &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, or does re-writing the query this way solve the performance problem?&lt;br/&gt;
I&apos;m confused because the new query still uses an IN operator and i don&apos;t see any queries like the above as performance experiments (e..g. using another table instead of a vti).&lt;/p&gt;

&lt;p&gt;I was thinking (along with the last comment), if there was a way to re-write the query using something along the lines of a VALUES clause.&lt;/p&gt;

&lt;p&gt; SELECT * FROM tableA  TABLE(VALUES constC, ?, ?, constD) AS X(C) where X.C = tableA.columnB = X.C;&lt;/p&gt;

&lt;p&gt;no idea how that would perform, it also needs tweaking to remove duplicates  from the list of values in the VALUES clause.&lt;/p&gt;



</comment>
                            <comment id="12459722" author="djd" created="Tue, 19 Dec 2006 18:37:46 +0000"  >
&lt;p&gt;&amp;gt; The next question is how do I pass information to the VTI implementation regarding which parameters of the activation should it use &amp;gt; as the values in the virtual table? I suspect that the constructor will need to take the range [N, N+M) of parameter indices, and also&lt;br/&gt;
&amp;gt; some array of literals; i.e. the IN list can consist of both parameter markers, and literal parameters. If the IN list were to include&lt;br/&gt;
&amp;gt; columns or functions, I suspect we&apos;d want to skip this &quot;solution&quot; as it wouldn&apos;t support that. &lt;/p&gt;

&lt;p&gt;Based on past experience it would be good to avoid generating code per literal value, as that&apos;s an easy way to hit limits in the compiled byte code. I think you should be able to build up a collection of literal values (DataValueDescriptors) at compile time and store it as a saved object. The runtime ResultSet can then obtain the same collection from the saved objects.&lt;br/&gt;
See CompilerContext.addSavedObject&lt;/p&gt;

&lt;p&gt;I think you have to do the same approach for the parameters, build up a collection of valid parameters, though maybe if you limit your solution you can get away with a range. A range does not work in the general case where a single value in the IN list can be composed of multiple parameters, e.g.&lt;br/&gt;
   IN (?,?,?, ?+?)&lt;/p&gt;

&lt;p&gt;With these approaches the amount of information required to create a ResultSet for such an IN list is fixed and not a factor of the number of values, thus leading to smaller generated code to generate the result set.&lt;/p&gt;
</comment>
                            <comment id="12459767" author="jmsynge" created="Tue, 19 Dec 2006 21:33:23 +0000"  >&lt;p&gt;Dan wrote:&lt;br/&gt;
&amp;gt; Is this an step to solving &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, or does re-writing the query this way solve the performance problem? &lt;/p&gt;

&lt;p&gt;The goal of the re-write is to avoid the source of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, which is that we don&apos;t have a multi-probe index scan, only range index scans, and worse still, when there are parameters involved, the range is the entire index.&lt;/p&gt;

&lt;p&gt;My intent is that the re-write will send it towards treating this like an exists; for example:&lt;/p&gt;

&lt;p&gt;SELECT * FROM tableA&lt;br/&gt;
WHERE EXISTS (SELECT 1 FROM new ArgsToRowsVTI(SomeArgs) AS X(C) WHERE tableA.columnB = X.C)&lt;/p&gt;

&lt;p&gt;&amp;gt; I was thinking (along with the last comment), if there was a way to re-write the query&lt;br/&gt;
&amp;gt; using something along the lines of a VALUES clause.&lt;br/&gt;
&amp;gt; SELECT * FROM tableA TABLE(VALUES constC, ?, ?, constD) AS X(C) where X.C = tableA.columnB = X.C; &lt;/p&gt;

&lt;p&gt;I tried a similar approach earlier, and found that it wouldn&apos;t compile.  Perhaps it was the version of Derby&lt;br/&gt;
I was testing with, or perhaps I just screwed up the syntax, but putting parameters into the FROM&lt;br/&gt;
clause didn&apos;t seem to be allowed.&lt;/p&gt;

&lt;p&gt;I&apos;m also concerned about the implications of moving the IN list to the FROM clause.  Isn&apos;t there a risk of changing the semantics?&lt;/p&gt;</comment>
                            <comment id="12459768" author="jmsynge" created="Tue, 19 Dec 2006 21:38:32 +0000"  >&lt;p&gt;Dan wrote:&lt;br/&gt;
&amp;gt; ... store it as a saved object.&lt;/p&gt;

&lt;p&gt;Thanks for the pointer to CompilerContext.addSavedObject, I&apos;d not come across it before.&lt;/p&gt;

&lt;p&gt;Do you think that I could &quot;just&quot; pass InListOperatorNode.rightOperandList (a ValueNodeList) to addSavedObject?  If so, then the whole process could be much simpler.&lt;/p&gt;</comment>
                            <comment id="12459777" author="djd" created="Tue, 19 Dec 2006 22:19:34 +0000"  >&lt;p&gt;&amp;gt; Do you think that I could &quot;just&quot; pass InListOperatorNode.rightOperandList (a ValueNodeList) to addSavedObject? &lt;/p&gt;

&lt;p&gt;No. QueryTreeNodes are for compile time and are assumed to be private to a connection. Any saved objects and the entire compiled plan is shared across multiple connections. Holding onto a node in the compiled plan would lead to memory leaks as the nodes contain references to objects of its connection, which could not be gc&apos;ed once the connection is closed if a compiled plan still had references to the nodes.&lt;/p&gt;</comment>
                            <comment id="12459973" author="jmsynge" created="Wed, 20 Dec 2006 15:54:10 +0000"  >&lt;p&gt;I think I&apos;ve found the code that caused a problem for me when I tried using VALUES to construct a table using parameters.&lt;br/&gt;
SubqueryNode.bindExpression contains the following:&lt;/p&gt;

&lt;p&gt;		/* reject ? parameters in the select list of subqueries */&lt;br/&gt;
		resultSet.rejectParameters();&lt;/p&gt;

&lt;p&gt;The syntax I&apos;d used involved replacing an IN list with an IN sub-query, and clearly that would run into the above code.&lt;/p&gt;

&lt;p&gt;So, any idea why that code is there?&lt;/p&gt;</comment>
                            <comment id="12459979" author="jmsynge" created="Wed, 20 Dec 2006 16:31:03 +0000"  >&lt;p&gt;I&apos;ve changed InListOperatorNode.preprocess to replace the node with a new SubqueryNode&lt;br/&gt;
in the case where the list is all parameter markers.  I&apos;ll attach the changed file.&lt;/p&gt;

&lt;p&gt;To make the SubqueryNode ready for use I need to call bindExpression and preprocess,&lt;br/&gt;
and this is failing in bindExpression because it is attempting to rebind the leftOperand&lt;br/&gt;
(a ColumnReference) when I don&apos;t have the full context of the original binding.&lt;/p&gt;

&lt;p&gt;I would seem to have a few choices:&lt;/p&gt;

&lt;p&gt;1) Modify ColumnReference.bindExpression so that it doesn&apos;t detects the rebinding&lt;br/&gt;
situation, and returns without doing anything.  I don&apos;t know if there are cases where&lt;br/&gt;
rebinding occurs currently, and is supposed to change the binding.  Besides that&lt;br/&gt;
uncertainty, this seems like a good choice.&lt;/p&gt;

&lt;p&gt;2) Modify SubqueryNode.bindExpression to detect when the leftOperand is a&lt;br/&gt;
ColumnReference that is already bound, and skip the leftOperand.bindExpression call.&lt;/p&gt;

&lt;p&gt;3) Copy much of the code from SubqueryNode.bindExpression into&lt;br/&gt;
InListOperatorNode.preprocess, allowing me to bypass the call to&lt;br/&gt;
leftOperand.bindExpression.  Definitely ugly, hard to maintain.&lt;/p&gt;

&lt;p&gt;4) Create a trivial ColumnReference subclass that has an empty bindExpression&lt;br/&gt;
implementation, and &quot;clone&quot; the InListOperatorNode.leftOperand as an instance&lt;br/&gt;
of this subclass for use as the SubqueryNode.leftOperand , thus avoiding the&lt;br/&gt;
problem.&lt;/p&gt;

&lt;p&gt;Any thoughts on the preferred approach?&lt;/p&gt;</comment>
                            <comment id="12459982" author="jmsynge" created="Wed, 20 Dec 2006 16:34:28 +0000"  >&lt;p&gt;Added code for replacing the InListOperatorNode with a SubqueryNode (IN_SUBQUERY) in the case where all of the list entries are parameter markers.  Not yet working (fails in SubqueryNode.bindExpression, calling leftOperand.bindExpression).&lt;/p&gt;</comment>
                            <comment id="12460327" author="jmsynge" created="Thu, 21 Dec 2006 19:40:51 +0000"  >&lt;p&gt;I&apos;ve been thinking more about the suggestion of using a table constructor.&lt;br/&gt;
I was concerned about several issues:&lt;/p&gt;

&lt;p&gt;1) When I tried it previously I got this error:&lt;/p&gt;

&lt;p&gt;         ERROR 42Y10: A table constructor that is not in an INSERT&lt;br/&gt;
         statement has all ? parameters in one of its columns.  For&lt;br/&gt;
         each column, at least one of the rows must have a non-parameter.&lt;/p&gt;

&lt;p&gt;    Working around this will require figuring out the type of the parameters,&lt;br/&gt;
    and creating a dummy value to include in the table, with extra code to&lt;br/&gt;
    remove it.&lt;/p&gt;

&lt;p&gt;2) Re-writing the query by adding the table constructor to the fromList&lt;br/&gt;
     of the SelectNode that includes the IN list predicate potentially&lt;br/&gt;
     changes the semantics of the query (for example, imagine the case&lt;br/&gt;
     where the IN list is OR&apos;d with other predicates).  This is why I&apos;ve been&lt;br/&gt;
     sticking with a sub-query (which my performance experiments indicated&lt;br/&gt;
     can perform well).&lt;/p&gt;

&lt;p&gt;I tried the table constructor again this morning, coming up with a query&lt;br/&gt;
re-write that combines the suggested table constructor with an IN sub-query.&lt;br/&gt;
For example, we would transform:&lt;/p&gt;

&lt;p&gt;SELECT * FROM tableA &lt;br/&gt;
WHERE columnB IN (constC, ?, ?, constD)&lt;/p&gt;

&lt;p&gt;into:&lt;/p&gt;

&lt;p&gt;SELECT * FROM tableA&lt;br/&gt;
WHERE columnB IN (&lt;br/&gt;
        SELECT v FROM TABLE(&lt;br/&gt;
                VALUES (dummyValue, 0), (constC, 1), (?, 1), (?, 1), (constD, 1)) AS X(v, k) WHERE k=1)&lt;/p&gt;

&lt;p&gt;The sub-query is built up as a tree (really a list) of UNIONs, union-ing together each&lt;br/&gt;
row in the VALUES clause.&lt;/p&gt;

&lt;p&gt;Unfortunately the performance of this is poor, with a table scan of tableA being performed,&lt;br/&gt;
rather than using the index on columnB.  I&apos;m investigating why this isn&apos;t transformed&lt;br/&gt;
into a nested loop join, with the UNION on the outside.&lt;/p&gt;</comment>
                            <comment id="12460530" author="jmsynge" created="Fri, 22 Dec 2006 16:07:49 +0000"  >&lt;p&gt;As stated in my previous comment, I&apos;ve been debugging the compilation of this query:&lt;/p&gt;

&lt;p&gt;SELECT * FROM tableA&lt;br/&gt;
WHERE columnB IN (&lt;br/&gt;
        SELECT v FROM TABLE(&lt;br/&gt;
                VALUES (dummyValue, 0), (constC, 1), (?, 1), (?, 1), (constD, 1)) AS X(v, k) WHERE k=1)&lt;/p&gt;

&lt;p&gt;The IN operator is represented with a SubqueryNode of type IN_SUBQUERY.&lt;br/&gt;
SubqueryNode.preprocess &quot;tries&quot; to flatten this, but because the rightOperand&lt;br/&gt;
is doesn&apos;t select from a single base table, it decides not to flatten the sub-query&lt;br/&gt;
(i.e. it doesn&apos;t hoist it up into its parent query).&lt;/p&gt;

&lt;p&gt;As a result, the optimizer isn&apos;t presented with a join that it can choose the order of,&lt;br/&gt;
but rather just one top-level optimizable, with a sub-query that must be optimized&lt;br/&gt;
&quot;separately&quot;.&lt;/p&gt;</comment>
                            <comment id="12460578" author="jmsynge" created="Fri, 22 Dec 2006 20:19:50 +0000"  >&lt;p&gt;Some success at last...&lt;/p&gt;

&lt;p&gt;I forced SubqueryNode.preprocess to flatten the sub-query mentioned&lt;br/&gt;
previously by modifying SubqueryNode.singleFromBaseTable to return&lt;br/&gt;
true (not a valid change, but it helps with this experiment), which then&lt;br/&gt;
enabled the optimizer to re-order the join so that the index on tableA&lt;br/&gt;
is used.  Yeah! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The performance was quite reasonable.&lt;/p&gt;

&lt;p&gt;Possible next steps:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Consider wrapping the sub-query&apos;s SelectNode in a MaterializeResultSetNode (helpful in those cases where the sub-query is invariant, and the sub-query ends up being executed multiple times... that latter is not really known until later in the optimization process)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Modify SubqueryNode.preprocess so that it can flatten more sub-queries (including the one produced above).  Materializing the sub-query could help with the flattening.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Modify InListOperatorNode.preprocess to produce a sub-query like the one above.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12466812" author="army" created="Tue, 23 Jan 2007 19:42:08 +0000"  >&lt;p&gt;I&apos;ve spent some time looking at this issue and have come up with a solution that is based on two earlier comments for this issue. Namely:&lt;/p&gt;

&lt;p&gt;Comment #1:&lt;/p&gt;

&lt;p&gt;&amp;gt; I was thinking if there was a way to re-write the query using something&lt;br/&gt;
&amp;gt; along the lines of a VALUES clause.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  SELECT * FROM tableA TABLE(VALUES constC, ?, ?, constD) AS X(C)&lt;br/&gt;
&amp;gt;    where X.C = tableA.columnB = X.C;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; no idea how that would perform, it also needs tweaking to remove duplicates&lt;br/&gt;
&amp;gt; from the list of values in the VALUES clause.&lt;/p&gt;

&lt;p&gt;The solution I&apos;ve come up with does in fact rewrite IN-list queries to create a join between the target table and &quot;something along the lines of a VALUES clause&quot;.  That said, though, a VALUES expression in Derby is internally parsed into a chain of nested UNIONs between RowResultSetNodes.  I did a quick prototype to duplicate that behavior and found that for IN lists with thousands of values in them, a chain of UNIONs is not acceptable.  More specifically, I found that such a chain inevitably leads to stack overflow because of recursion in preprocessing and/or optimization.  And even if the list is small enough to avoid stack overflow, the time it takes to optimize a UNION chain with, say, a thousand values is far too long (I was seeing optimization times of over 20 seconds with 1000 IN-list values).  And lastly, assuming that we were able to code around stack overflow and optimization time, the limit to the size of a UNION chain that Derby can successfully generate is far less than the current limit on IN-lists-&lt;del&gt;see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1315&quot; title=&quot;Statement optimization/compilation fails with OutOfMemoryException in largeCodeGen test  with embedded and framework DerbyNetClient&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1315&quot;&gt;&lt;del&gt;DERBY-1315&lt;/del&gt;&lt;/a&gt; for the details&lt;/del&gt;-which means we would have to skip the rewrite when the list has more than xxx values.  That&apos;s doable, but not pretty.&lt;/p&gt;

&lt;p&gt;So in my proposed solution we do not actually create a normal VALUEs expression.  Instead we create a new type of node called an &quot;InListResultSetNode&quot; that is specifically designed to handle potentially large lists of constant and/or parameter values.  Then we create a new equality predicate to join the InListRSN with the appropriate table, and since InListResultSetNode is an instance of Optimizable, the optimizer can then use the predicate to optimize the join.&lt;/p&gt;

&lt;p&gt;Note that I also made changes to the optimizer so that it recognizes InListResultSetNodes as &quot;fixed outer tables&quot;, meaning that they are prepended to the join order and remain fixed at their prepended positions throughout the optimization process.  This ensures that the optimizer does not have to deal with additional join orders as a result of the IN-list rewrite (it already looks at too many; see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1907&quot; title=&quot;Improve optimizer to prune query plans more aggressively.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1907&quot;&gt;DERBY-1907&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Comment #2:&lt;/p&gt;

&lt;p&gt;&amp;gt; Based on past experience it would be good to avoid generating code per&lt;br/&gt;
&amp;gt; literal value, as that&apos;s an easy way to hit limits in the compiled byte&lt;br/&gt;
&amp;gt; code. I think you should be able to build up a collection of literal values&lt;br/&gt;
&amp;gt; (DataValueDescriptors) at compile time and store it as a saved object. The&lt;br/&gt;
&amp;gt; runtime ResultSet can then obtain the same collection from the saved objects.&lt;br/&gt;
&amp;gt; See CompilerContext.addSavedObject&lt;/p&gt;

&lt;p&gt;In the solution I&apos;ve written we do in fact create a &quot;collection of literal values (DataValueDescriptors) at compile time and store it&quot;.  We do not, however, use saved objects to store/retrieve them.  Instead, we use existing code in InListOperatorNode to create an execution time &lt;b&gt;array&lt;/b&gt; of DataValueDescriptors and we pass that array to a new execution time result set, InListResultSet, that returns the list of values as a single-column result set.  This approach works for both constants and parameters.&lt;/p&gt;

&lt;p&gt;By re-using the existing InListOperator code generation we ensure that the max size of an IN-list after these changes will be the same as what it was before these changes.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;All of that said, the internal addition of a new InListResultSetNode to a FromList is not without its side effects.  The following are the three areas in which I&apos;ve noticed an unintended change in behavior caused by adding an InListRSN to a FromList.  I have a &quot;progress-not-perfection&quot; workaround for the first issue; I still need to investigate the latter two (any input from others would of course be much appreciated).&lt;/p&gt;

&lt;p&gt;  1) Derby has internal restrictions on the types of queries that it can flatten.  Most notably (and as James Synge also noted) a subquery cannot be flattened if its FromList contains more than a single FromTable.  When rewriting the IN-list operator as described above, we add the new inListRSN to the appropriate FromList.  That means that the FromList will now have more than one FromTable and thus the subquery is no longer flattenable.  So for the following query:&lt;/p&gt;

&lt;p&gt;  select * from t2, (select * from t1 where i in (1, 2, 3)) x&lt;/p&gt;

&lt;p&gt;the inner select is currently flattened during preprocessing.  With the changes as I&apos;ve described them, though, the IN list for the subquery would become an InListResultSetNode that is added to the inner FromList, thus rendering the inner query non-flattenable.  In the interest of making progress (instead of perfection) on this issue, I simply added logic to skip rewriting an IN-list if appears in a subquery.  In that case we will default to normal IN-list processing as it is today.&lt;/p&gt;

&lt;p&gt;  2) I just discovered this morning that the addition of an InListResultSet to the FromList causes all of the SUR (scrollable updatable result set) tests that use an IN-clause to fail--apparently the presence of the InListResultSet results in a downgrade of the cursor scrollability to &quot;CONCUR_READ_ONLY&quot;.  I do not yet know why this is the case, nor do I know how to prevent it.&lt;/p&gt;

&lt;p&gt;  3) The store/readlocks.sql test fails with the proposed changes because of missing ROW locks.  I do not know if these missing locks are a problem or just a side effect that can be &quot;fixed&quot; with a master update.  More investigation required...&lt;/p&gt;

&lt;p&gt;There were of course other tests that failed with row orderings and/or different plans, but so far as I can tell all of those are expected and correct--so I will just update the master files as needed.&lt;/p&gt;

&lt;p&gt;For now I have just attached an initial version of the engine changes, d47_engine_doNotCommit_v1.patch, for general review/comments if anyone has any.  I plan to look into the above issues more and will probably go to derby-dev with questions where needed.  In the meantime, any feedback on the general approach as outlined above would be appreciated.&lt;/p&gt;

&lt;p&gt;Oh, and by the way: I ran Derby47PerformanceTest.java (as attached to this issue) with 100,000 rows after applying this patch.  Whereas the &quot;Markers&quot; strategy was by far the worse query before my changes, it ends up being the best strategy after my changes, beating out the &quot;Marker&quot; and &quot;JoinTemp&quot; strategies (which were previously the best) by roughly 30 and 25 percent, respectively.&lt;/p&gt;</comment>
                            <comment id="12466871" author="army" created="Wed, 24 Jan 2007 00:36:47 +0000"  >&lt;p&gt;Accidentally attached the _v1 files without granting license to ASF.  So I&apos;m reattaching with the correct &quot;Attachment license&quot; option.&lt;/p&gt;</comment>
                            <comment id="12466876" author="army" created="Wed, 24 Jan 2007 00:53:42 +0000"  >&lt;p&gt;Attaching the diff seen with store/readlocks.sql when d47_engine_doNotCommit_v1.patch is applied.  This is the actual diff produced from the test; I&apos;ll try to post a modified diff that includes the relevant queries tomorrow, to (hopefully) aid in the determination of whether or not this diff is acceptable...&lt;/p&gt;</comment>
                            <comment id="12467172" author="army" created="Wed, 24 Jan 2007 22:12:46 +0000"  >&lt;p&gt;Attaching another readlocks diff, this time with more context so that the queries in question can be seen...&lt;/p&gt;</comment>
                            <comment id="12474895" author="army" created="Thu, 22 Feb 2007 00:41:07 +0000"  >&lt;p&gt;In one of my previous comments I mentioned that d47_engine_doNOTCommit_v1.patch has a problem where the addition of an InListResultSet to the FromList causes all of the SUR (Scrollable Updatable Result set) tests that use an IN-clause to fail. More specifically, the presence of the InListResultSet causes Derby to downgrade the cursor scrollability to &quot;CONCUR_READ_ONLY&quot;. &lt;/p&gt;

&lt;p&gt;I was eventually able to track down the cause of this behavior: whether or not Derby downgrades a result set to CONCUR_READ_ONLY depends on the value returned by the execution time result set in the &quot;isForUpdate()&quot; method.  The default (as defined in NoPutResultSetImpl) is to return false.&lt;/p&gt;

&lt;p&gt;In the case of the SUR tests (prior to my changes) we were getting a ScrollInsensitiveResultSet on top of a TableScanResultSet.  The former gets its &quot;isForUpdate()&quot; value from the latter, and the latter correctly returns &quot;true&quot; to indicate that the result set is for update and thus no downgrade is needed. With d47_engine_doNotCommit_v1.patch applied, though, we add an InListResultSet to the FromList, which ultimately gives us a JoinResultSet at execution time.  The JoinResultSet class does not define an &quot;isForUpdate()&quot; method, so we just return the default--which is &quot;false&quot;.  That causes the cursor concurrency to be downgraded to CONCUR_READ_ONLY.  &lt;/p&gt;

&lt;p&gt;To see what would happen I forced JoinResultSet to return &quot;true&quot; and then there was an ASSERT failure because JoinResultSets are not expected to be used for update/delete.  The relevant code is in execute/JoinResultSet.java; in the &quot;getRowLocation()&quot; method we see the following comment:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;A join is combining rows from two sources, so it has no&lt;/li&gt;
	&lt;li&gt;single row location to return; just return a null.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My guess is that, since the decision to disallow update/delete on a JoinResultSet was intentional, trying to code around that restriction is a bad idea.  Or at the very least, it would require a lot more investigation and/or work.&lt;/p&gt;

&lt;p&gt;Instead of pursuing that potentially treacherous path, I was able to come up with some logic that checks to see if a result set is updatable at compile time and, if so, to skip the IN-list rewrite.  Early testing suggests that this is viable solution.&lt;/p&gt;

&lt;p&gt;HOWEVER, as the list of &quot;exceptions&quot; to the IN-list (_v1.patch) rewrite grew, I started to wonder if there wasn&apos;t some other solution to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; that would accomplish the same thing, minus all of the exception cases.&lt;/p&gt;

&lt;p&gt;A few days later I came across some queries involving multiple IN-list predicates for a single SELECT statement.  It turns out that many of those queries return incorrect results (duplicate rows) and/or run much more slowly with the _v1 patch than without.&lt;/p&gt;

&lt;p&gt;The fact that there are so many &quot;exceptions to the rule&quot; combined with the undesirable behavior in the face of multiple IN-lists prompted me to abandon my initial idea of internally adding an InListResultSetNode to the user&apos;s FROM list (d47_engine_doNOTCommit_v1.patch).&lt;/p&gt;

&lt;p&gt;Instead I have been working on an alternate approach to the problem.  This second approach, like the first, is based on a comment made by someone else on this issue.  This time, though, the comment in question is from James Synge and is as follows:&lt;/p&gt;

&lt;p&gt;&amp;gt; The goal of the re-write is to avoid the source of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
&amp;gt; which is that we don&apos;t have a multi-probe index scan, only&lt;br/&gt;
&amp;gt; range index scans, and worse still, when there are parameters&lt;br/&gt;
&amp;gt; involved, the range is the entire index.&lt;/p&gt;

&lt;p&gt;In short, I decided to work with the execution-time result sets to see if it is possible to enforce some kind of &quot;multi-probing&quot; for indexes.  That is to say, instead of scanning a range of values on the index, we want to make it so that Derby probes the index N times, where N is the size of the IN-list.  For each probe, then, we&apos;ll get all rows for which the target column&apos;s value equals the N-th value in the IN-list.&lt;/p&gt;

&lt;p&gt;Effectively, this comes down to the &quot;Marker&quot; strategy in Derby47Performance.java, where we evaluate an equality predicate, &quot;column = ?&quot;, N times.  Except of course that, unlike with the Marker strategy, we do the N evaluations internally instead of making the user do it.  &lt;/p&gt;

&lt;p&gt;A high-level description of how this approach will work is as follows:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If any value in the IN-list is not a constant AND is not a parameter,&lt;br/&gt;
    then do processing as usual (no optimizations, no rewrite).  Notice&lt;br/&gt;
    that with this approach we &lt;b&gt;do&lt;/b&gt; still perform the optimization if&lt;br/&gt;
    IN-list values are parameters.  That is not the case for the current&lt;br/&gt;
    Derby rewrite (i.e. without any changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Otherwise:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;During preprocessing, replace the IN-list with an equality predicate of&lt;br/&gt;
    the form &quot;column = ?&quot;.  I.e. the right operand will be a parameter node,&lt;br/&gt;
    the left operand will be whatever column reference belongs to the IN-list&lt;br/&gt;
    (hereafter referred to as the &quot;target column&quot;).  We call this new, internal&lt;br/&gt;
    predicate an IN-list &quot;probe predicate&quot; because it will be the basis of&lt;br/&gt;
    the multi-probing logic at execution time.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;During costing, the equality predicate &quot;column = ?&quot; will be treated as&lt;br/&gt;
    a start/stop key by normal optimizer processing (no changes necessary).&lt;br/&gt;
    If the predicate is deemed a start/stop key for the &lt;b&gt;first&lt;/b&gt; column in&lt;br/&gt;
    an index, then we&apos;ll multiply the estimated cost of &quot;column = ?&quot; by&lt;br/&gt;
    the size of the IN-list, to account for the fact that we&apos;re actually&lt;br/&gt;
    evaluating the predicate N times (not just once).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If the predicate is not a start/stop key for the first column in&lt;br/&gt;
    the index, then we do not adjust the cost.  See below for why.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;After we have found the best plan (including a best conglomerate choice),&lt;br/&gt;
    check to see if the IN-list probe predicate is a start/stop key on the&lt;br/&gt;
    first column in the chosen conglomerate.  In order for that to be the&lt;br/&gt;
    case the conglomerate must be an index (because we don&apos;t have start/stop&lt;br/&gt;
    keys on table conglomerates).  If the probe predicate is not a&lt;br/&gt;
    start/stop key for the &lt;b&gt;first&lt;/b&gt; column in the index, then we &quot;revert&quot; the probe&lt;br/&gt;
    predicate back to its original IN-list form and evaluate it as a &quot;normal&quot;&lt;br/&gt;
    InListOperatorNode.  In this way we are effectively &quot;giving up&quot; on the multi-&lt;br/&gt;
    probing approach.  This is why we don&apos;t change the cost for such probe&lt;br/&gt;
    predicates (mentioned above).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If the probe predicate &lt;b&gt;is&lt;/b&gt; a start/stop key on the first column in&lt;br/&gt;
    the index conglomerate, then leave it as it is.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When it comes time to generate the byte code, look to see if we have&lt;br/&gt;
    a probe predicate that is a start/stop key on the first column in the&lt;br/&gt;
    chosen conglomerate.  If so, generate an array of DataValueDescriptors&lt;br/&gt;
    to hold the values from the corresponding IN-list and pass that array&lt;br/&gt;
    to the underlying execution-time result set (i.e. to TableScanResultSet).&lt;br/&gt;
    Then generate the probe predicate as a &quot;normal&quot; start/stop key for the&lt;br/&gt;
    scan.  This will serve as a &quot;place-holder&quot; for the IN-list values&lt;br/&gt;
    at execution time.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Finally, at execution time, instead of using a single start key and a&lt;br/&gt;
    single stop key to define a scan range, we iterate through the IN-list&lt;br/&gt;
    values and for each non-duplicate value V&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; (0 &amp;lt;= i &amp;lt; N) we treat V&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;&lt;br/&gt;
    as both a start key &lt;b&gt;and&lt;/b&gt; a stop key.  Or put another way, we plug&lt;br/&gt;
    V&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; into the &quot;column = ?&quot; predicate and retrieve all matching rows.&lt;br/&gt;
    In this way we are &quot;probing&quot; the index for all rows having value V&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;&lt;br/&gt;
    in the target column.  Once all rows matching V&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; have been returned,&lt;br/&gt;
    we then grab the next IN-list value, V&lt;span class=&quot;error&quot;&gt;&amp;#91;i+1&amp;#93;&lt;/span&gt;, and we reposition the&lt;br/&gt;
    scan (by calling &quot;reopenCore()&quot;), this time using V&lt;span class=&quot;error&quot;&gt;&amp;#91;i+1&amp;#93;&lt;/span&gt; as the start&lt;br/&gt;
    and stop key (i.e. plugging V&lt;span class=&quot;error&quot;&gt;&amp;#91;i+1&amp;#93;&lt;/span&gt; into &quot;column = ?&quot;).  This will&lt;br/&gt;
    return all rows having value V&lt;span class=&quot;error&quot;&gt;&amp;#91;1+1&amp;#93;&lt;/span&gt; in the target column.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Continue this process until all values in the IN-list have been&lt;br/&gt;
    exhausted.  When we reach that point, we are done.&lt;/p&gt;

&lt;p&gt;As a simple example, assume our query is of the form:&lt;/p&gt;

&lt;p&gt;  select ... from admin.changes where id in (1, 20000)&lt;/p&gt;

&lt;p&gt;During preprocessing we will effectively change this to be:&lt;/p&gt;

&lt;p&gt;  select ... from admin.changes where id = ?&lt;/p&gt;

&lt;p&gt;where &quot;id = ?&quot; is our IN-list &quot;probe predicate&quot;.  Note that we must make sure the optimizer recognizes &quot;id = ?&quot; as a disguised IN-list operator, as opposed to a true relational operator.  The reason is that, while we do treat the probe predicate as a &quot;fake&quot; relational operator so that it can be seen as a start/stop key for the relevant indexes, there are many operations (ex. transitive closure) that should &lt;b&gt;not&lt;/b&gt; be done on a probe predicate.  So we have to be able to distinguish a probe predicate from other relational predicates.&lt;/p&gt;

&lt;p&gt;With the probe predicate in place the optimizer will determine that it is a start/stop key for any index having column &quot;ID&quot; as the first column, and thus the optimizer is more likely to choose one of those indexes over a table scan.  If we assume the optimizer decides to use an index on ID for the query, then we&apos;ll generate the IN-list values (1, 20000) and we will pass them to the underlying index scan. We&apos;ll then generate the probe predicate &quot;column = ?&quot; as a start and stop key for the scan.  &lt;/p&gt;

&lt;p&gt;At execution, then, the scan will first open up the index by using &quot;1&quot; as the start and stop key for the scan (or put another way, by plugging &quot;1&quot; into the probe predicate, &quot;column = ?&quot;).  That will return all rows having ID equal to &quot;1&quot;. Then when that scan ends, we&apos;ll reopen the scan a second time, this time using &quot;20000&quot; as the start and stop key, therefore returning all the 20000&apos;s.  Meanwhile, all result sets higher up in the result set tree will just see a stream of rows from the index where ID only equals 1 or 20000.   &lt;/p&gt;

&lt;p&gt;This works for IN-lists with parameters, as well, because by the time execution starts we know what values the parameters hold.&lt;/p&gt;

&lt;p&gt;The first draft of code for implementing all of this is pretty much done, but I plan to post it in increments for ease of review.  If all goes well, nothing should change functionally until the final patch, which will be the preprocessing patch that does the actual creation of the &quot;probe predicate&quot;.  At that point all of the machinery should be in place to recognize the probe predicate and function accordingly.&lt;/p&gt;

&lt;p&gt;I ran Derby47PerformanceTest with this &quot;multi-probing&quot; approach and the numbers were similar to what I saw with the _v1 approach (more details coming later).  Unlike the _v1 approach, though, the multi-probing approach works with subqueries, left outer joins, and scrollable updatable result sets.  In addition, all of the test queries that I came up with involving multiple IN-lists run correctly with the multi-probing approach, and in many cases run quite a bit more quickly--neither of which was true for the _v1 approach.  And yes, I do hope to add those test cases to the nightlies as part of my work on this issue.&lt;/p&gt;

&lt;p&gt;Incremental patches are forthcoming.  In the meantime, if anyone has any comments/suggestions on the approach outlined above, I would appreciated the feedback...&lt;/p&gt;</comment>
                            <comment id="12475077" author="army" created="Thu, 22 Feb 2007 16:39:45 +0000"  >&lt;p&gt;Posting d47_mp_relOpPredCheck_v1.patch, which is the first patch for the multi-probing (&quot;mp&quot;) approach described in my previous comment.  As mentioned in that comment, we need to be able to distinguish between &quot;true&quot; relational predicates and &quot;probe predicates&quot; so that we do not incorrectly perform certain operations on probe predicates.  This first patch adds the logic to allow such distinction.  In particular it:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Adds a new method, &quot;isRelationalOpPredicate()&quot;, to Predicate.java that&lt;br/&gt;
    only returns true if the predicate is a &quot;true&quot; relational predicate; i.e.&lt;br/&gt;
    it will return &quot;false&quot; for probe predicates.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Updates several &quot;if&quot; statements in Predicate.java and PredicateList.java&lt;br/&gt;
    to use the new method.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Updates several utility methods in BinaryRelationalOperatorNode to distinguish&lt;br/&gt;
    &quot;true&quot; relational operators from ones that are created internally for probe&lt;br/&gt;
    predicates.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There should be no functional changes to Derby as a result of this patch, but just to make sure I ran derbyall and suites.All on Red Hat Linux with ibm142.  The only failure was a known issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2348&quot; title=&quot;testProtocol(org.apache.derbyTesting.functionTests.tests.derbynet.NetHarnessJavaTest)j  failed&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2348&quot;&gt;&lt;del&gt;DERBY-2348&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This is a pretty small patch so unless I hear otherwise I plan to commit it tomorrow (Friday Feb 23, PST).&lt;/p&gt;</comment>
                            <comment id="12475147" author="jmsynge" created="Thu, 22 Feb 2007 20:08:44 +0000"  >&lt;p&gt;Army, this sounds like great progress, thanks.&lt;/p&gt;

&lt;p&gt;Will this impact UPDATES?  I want to ensure that each row selected by the following WHERE clause gets updated only once:&lt;/p&gt;

&lt;p&gt;UPDATE t SET someColumn = 1 - someColumn WHERE someColumn IN (0, 1)&lt;/p&gt;

&lt;p&gt;This will change all 1&apos;s to 0&apos;s and 0&apos;s to 1&apos;s in t.someColumn, but only if this is &lt;b&gt;logically&lt;/b&gt; performed in a single pass over the table.  This is of course something which all DBMS&apos;s have to take care with, and I think Derby was already correct in this area (I vaguely recall reading that somewhere).&lt;/p&gt;

&lt;p&gt;Performance may benefit from sorting the parameter values during execution, prior to the probing (e.g. if the index is large, and the number of parameters is also large).  This sorting is done during compilation for literals.&lt;/p&gt;</comment>
                            <comment id="12475176" author="army" created="Thu, 22 Feb 2007 22:03:26 +0000"  >&lt;p&gt;Thank you very much for feedback, James.&lt;/p&gt;

&lt;p&gt;&amp;gt; Will this impact UPDATES? I want to ensure that each row selected by the following WHERE&lt;br/&gt;
&amp;gt; clause gets updated only once:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; UPDATE t SET someColumn = 1 - someColumn WHERE someColumn IN (0, 1)&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; This will change all 1&apos;s to 0&apos;s and 0&apos;s to 1&apos;s in t.someColumn, but only if this is &lt;b&gt;logically&lt;/b&gt;&lt;br/&gt;
&amp;gt; performed in a single pass over the table.&lt;/p&gt;

&lt;p&gt;That&apos;s an excellent question; thank you for bringing it up.  The best thing I could do to answer it was to try it out with  the code in my local codeline.  Does this example adequately reflect the scenario you are talking about?  And are these the results you would expect?  I think the answer to both of those questions is &quot;Yes&quot; but I just want to be safe.&lt;/p&gt;

&lt;p&gt;Here&apos; s what I did in my local codeline.  Note that lines beginning with &quot;&lt;del&gt;=&lt;/del&gt;&quot; are debug lines that I have in my codeline to indicate that we are in fact doing &quot;multi-probing&quot; with x number of IN-list values.&lt;/p&gt;

&lt;p&gt;create table t (inew int, iold int);&lt;br/&gt;
insert into t (iold) values 2, 1, -1, 0;&lt;br/&gt;
insert into t (iold) values 2, 1, -1, 0;&lt;br/&gt;
insert into t (iold) values 2, 1, -1, 0;&lt;br/&gt;
insert into t (iold) values 2, 1, -1, 0;&lt;br/&gt;
update t set inew = iold;&lt;/p&gt;

&lt;p&gt;create index t_ix1 on t(inew);&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from t order by iold;&lt;br/&gt;
INEW       |IOLD&lt;br/&gt;
-----------------------&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
0          |0&lt;br/&gt;
0          |0&lt;br/&gt;
0          |0&lt;br/&gt;
0          |0&lt;br/&gt;
1          |1&lt;br/&gt;
1          |1&lt;br/&gt;
1          |1&lt;br/&gt;
1          |1&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;/p&gt;

&lt;p&gt;16 rows selected&lt;/p&gt;

&lt;p&gt;ij&amp;gt; update t set inew  = 1 - inew where inew in (1, 0);&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt; org.apache.derby.impl.sql.execute.TableScanResultSet.openCore w/ 2 vals.&lt;br/&gt;
8 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t order by iold;&lt;br/&gt;
INEW       |IOLD&lt;br/&gt;
-----------------------&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
1          |0&lt;br/&gt;
1          |0&lt;br/&gt;
1          |0&lt;br/&gt;
1          |0&lt;br/&gt;
0          |1&lt;br/&gt;
0          |1&lt;br/&gt;
0          |1&lt;br/&gt;
0          |1&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;/p&gt;

&lt;p&gt;16 rows selected&lt;/p&gt;

&lt;p&gt;ij&amp;gt; update t set inew  = 1 - inew where inew in (1, 0);&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt; org.apache.derby.impl.sql.execute.TableScanResultSet.openCore w/ 2 vals.&lt;br/&gt;
8 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t order by iold;&lt;br/&gt;
INEW       |IOLD&lt;br/&gt;
-----------------------&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
-1         |-1&lt;br/&gt;
0          |0&lt;br/&gt;
0          |0&lt;br/&gt;
0          |0&lt;br/&gt;
0          |0&lt;br/&gt;
1          |1&lt;br/&gt;
1          |1&lt;br/&gt;
1          |1&lt;br/&gt;
1          |1&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;br/&gt;
2          |2&lt;/p&gt;

&lt;p&gt;16 rows selected&lt;/p&gt;

&lt;p&gt;I believe that is the correct behavior, esp. since that&apos;s what I see in a clean codeline, as well.&lt;/p&gt;

&lt;p&gt;&amp;gt; Performance may benefit from sorting the parameter values during execution, prior to the probing .&lt;/p&gt;

&lt;p&gt;Yes, my changes include an execution time sort of the IN-list values (on the condition that the sort was not done during compilation).  I have to admit, though, that I didn&apos;t make that decision for performance reasons; rather, I chose to sort the IN-list values to make it easier to detect (and skip over) duplicates in the IN-list...&lt;/p&gt;

&lt;p&gt;I greatly appreciate your feedback on this and hope you will continue ask any questions you might have.  The more eyes, the better...&lt;/p&gt;</comment>
                            <comment id="12475222" author="mikem" created="Fri, 23 Feb 2007 00:54:25 +0000"  >&lt;p&gt;The multiple probe approach always seemed the most natural to me - as the multiple probe support was already there&lt;br/&gt;
and used by the execution engine (for different reasons) already.  It is great that it looks like you have found an elegant way&lt;br/&gt;
to get the optimizer to cost the approach and throw out cases that approach does not support.  Part of that was that I understand the mechanics of the multiple probe and didn&apos;t understand the semantics of the query rewrite.&lt;/p&gt;

&lt;p&gt;Can you say something&lt;br/&gt;
why you chose to use x = ? predicate with special flag vs. just having a new multiple-probe inlist predicate (this question&lt;br/&gt;
may not make sense - I am talking from the outside of your description not from knowledge of internals).&lt;/p&gt;

&lt;p&gt;Also what happens to a query that is effectively an IN list that is hand written using OR&apos;s instead (ie, where i = 1 or i = 2 or ...).&lt;br/&gt;
Is that already changed to an IN list before we get to your new code here?&lt;/p&gt;

&lt;p&gt;This is probably food for a different discussion, but I was wondering about the costing.  What is the costing  % number of&lt;br/&gt;
rows for a where IN &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;   (ie. a parameter at compile time vs a constant, in a non-unique index)?  Is this just the cardinality&lt;br/&gt;
statistic if it exists?  What  is the default without the statistic?  Where I am going is that  it probably does not make sense&lt;br/&gt;
to have the estimate of the sum of terms be larger than the number of rows in the db.  And just want to understand how many&lt;br/&gt;
terms will it take before we give up on the multiple probe.&lt;/p&gt;</comment>
                            <comment id="12475227" author="jmsynge" created="Fri, 23 Feb 2007 01:05:09 +0000"  >&lt;p&gt;Army, yes that&apos;s the behavior I was hoping to see.  Thanks for double checking.&lt;/p&gt;</comment>
                            <comment id="12475414" author="army" created="Fri, 23 Feb 2007 17:44:04 +0000"  >&lt;p&gt;Thank you very much for your excellent questions, Mike.  My attempted answers are below...&lt;/p&gt;

&lt;p&gt;&amp;gt; Can you say something why you chose to use x = ? predicate with special flag vs. just having a new&lt;br/&gt;
&amp;gt; multiple-probe inlist predicate&lt;/p&gt;

&lt;p&gt;Good question. I guess the short answer is simply: code reuse.  All of the optimization, modification, generation, and execution-time logic for a single-sided predicate is already written and has (presumably) been working for years.  Among other things this includes the notion of &quot;start/stop&quot; keys to (re-)position an index scan, which is ultimately what we want and is something that store already knows about.  By using a flag we can slightly alter the behavior at key points of certain methods and then, for everything else, we just let Derby do what it already knows how to do.  Minimal code changes are required and if something breaks, odds are that it is in the &quot;slightly altered&quot; behavior (or lack thereof), of which there is far less than &quot;everything else&quot;.&lt;/p&gt;

&lt;p&gt;If anyone knows of how we could improve/simplify the logic and/or performance by creating a new multi-probe predicate then I am certainly open to investigating that path further.  But for now it seemed like the creation of &quot;x = ?&quot; with a flag was the simplest and quickest way to go, and it seems to provide the desired results.  So that&apos;s where I ended up...&lt;/p&gt;

&lt;p&gt;&amp;gt; Also what happens to a query that is effectively an IN list that is hand written using OR&apos;s instead&lt;br/&gt;
&amp;gt; (ie, where i = 1 or i = 2 or ...).  Is that already changed to an IN list before we get to your new&lt;br/&gt;
&amp;gt; code here? &lt;/p&gt;

&lt;p&gt;Yes, transformation of ORs into IN-lists occurs during preprocessing of the OR list.  In OrNode.preprocess() there is logic to recognize if an OR list is transformable into an IN-list and, if so, the IN-list is created and then the &quot;preprocess()&quot; method of the IN-list is called.  Since the creation of &quot;probe predicates&quot; occurs as part of IN-list preprocessing, this means that Yes, ORs are already converted to an IN-list before my new code takes effect.&lt;/p&gt;

&lt;p&gt;As a side note, if there is an OR clause which itself has an IN-list as one of its operands then OrNode preprocessing will, with my proposed changes, combine the existing IN-list with the newly-created IN-list.  For example:&lt;/p&gt;

&lt;p&gt;  select i, c from t1 where i in (1, 3, 5, 6) or i = 2 or i = 4&lt;/p&gt;

&lt;p&gt;will be changed to:&lt;/p&gt;

&lt;p&gt;  select i, c from t1 where i in (1, 3, 5, 6, 2, 4)&lt;/p&gt;

&lt;p&gt;This conversion will happen as part of OrNode.preprocess(), as well.&lt;/p&gt;

&lt;p&gt;&amp;gt; What is the costing % number of rows for a where IN &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; (ie. a parameter at compile time vs a&lt;br/&gt;
&amp;gt; constant, in a non-unique index)? Is this just the cardinality statistic if it exists?&lt;/p&gt;

&lt;p&gt;Generally speaking the way costing for a base table conglomerate works is that we figure out how many rows there are in the table before any predicates are applied.  Then, if we have a start/stop predicate &lt;b&gt;and&lt;/b&gt; we have statistics, we will calculate a percentage of the rows expected (called &quot;start/stop selectivity&quot;) based on the statistics.  This ultimately brings us to the &quot;selectivity(Object[]) method of StatisticsImpl, where there is the following code:&lt;/p&gt;

&lt;p&gt;    if (numRows == 0.0)&lt;br/&gt;
        return 0.1;&lt;/p&gt;

&lt;p&gt;    return (double)(1/(double)numUnique);&lt;/p&gt;

&lt;p&gt;I.e. the selectivity is 1 over the number of unique values in the conglomerate.  Is this what you mean by &quot;just the cardinality statistic if it exists?&quot;&lt;/p&gt;

&lt;p&gt;In any event we then multiply that percentage by the estimated row count to get a final estimated row count (I&apos;m leaving out lots of &quot;magic&quot; costing operations here to keep things simple (and because I don&apos;t really understand all of that magic myself...)).&lt;/p&gt;

&lt;p&gt;&amp;gt; What is the default without the statistic?&lt;/p&gt;

&lt;p&gt;If we do not have statistics for a specific conglomerate then we will simply default the start/stop selectivity to 1.0, i.e. the row count will not be adjusted (at least not as relates to this discussion).&lt;/p&gt;

&lt;p&gt;&amp;gt; Where I am going is that it probably does not make sense to have the estimate of the sum of terms&lt;br/&gt;
&amp;gt; be larger than the number of rows in the db. &lt;/p&gt;

&lt;p&gt;Yes, you&apos;re absolutely right.  This actually occurred to me yesterday, which is why I was poking around the stats code and thus was able to answer your previous question &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I agree that the estimated row count should not exceed the total number of rows.  I think we could just account for this by adding an explicit check to see if rowCount * sizeOfInList yields a number larger than the number of rows in the conglomerate.  If so then we set it to the number of rows in the conglomerate and that&apos;s that.&lt;/p&gt;

&lt;p&gt;&amp;gt; And just want to understand how many terms will it take before we give up on the multiple probe.&lt;/p&gt;

&lt;p&gt;Another great question.  The answer is that we do not ever give up on multi-probing as part of &quot;costing&quot; per se.  Rather, we calculate a cost and then we compare that cost with all of the other costs found so far; if it&apos;s cheaper we use it, otherwise we discard it.  Note that &quot;cheaper&quot; here encapsulates a lot of other logic and optimizer info that is far beyond the scope of this discussion.  &lt;/p&gt;

&lt;p&gt;So in the context of row counts, if the number of IN-list predicates multiplied by the estimated row count (after stat selectivity is applied) yields a high precentage row count (ex. all rows in the table) then the odds of the optimizer choosing to use that particular index are lower.  It &lt;b&gt;may&lt;/b&gt; still choose to use the index, in which case multi-probing will take effect, but it probably will not (it all depends).  Thus the point at which we give up on multi-probing is a factor of how unique the column values are and how many values are in the IN-list.  If you&apos;re just looking at the size of IN-list, then smaller lists are more likely to result in IN-list probing than larger ones--which I think is what we would expect.&lt;/p&gt;

&lt;p&gt;That&apos;s a bit of a vague answer but so much of it depends on the query and the data in question that I wouldn&apos;t want to say anything more specific than that...&lt;/p&gt;</comment>
                            <comment id="12476046" author="army" created="Tue, 27 Feb 2007 00:04:56 +0000"  >&lt;p&gt;Committed d47_relOpPredCheck_v1.patch with svn 512079 after getting the okay from Mike to do so (on derby-dev):&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=512079&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=512079&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Attaching the second incremental patch, d47_mp_CBO_MoAP_v1.patch, which updates the logic for cost-based optimization (CBO) and modification of access paths (MoAP) to recognize IN-list &quot;probe predicates&quot; and to handle them appropriately.  More specifically this patch adds code to do the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;During costing, recognize when we&apos;re using a probe predicate as a start/stop key&lt;br/&gt;
    and adjust the cost accordingly.  This means multiplying the estimated cost and&lt;br/&gt;
    row count for &quot;column = ?&quot; by the number of values in the IN-list (because we are&lt;br/&gt;
    effectively going to evaluate &quot;column = ?&quot; N times, where N is the size of the&lt;br/&gt;
    IN-list, and we could return one or more rows for each of the N evaluations).&lt;br/&gt;
    As mentioned in Mike&apos;s comment above, we also want to make sure that the resultant&lt;br/&gt;
    row count estimate is not greater than the total number of rows in the table.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When determining which predicates can be used as start/stop keys for the current&lt;br/&gt;
    conglomerate, only consider a probe predicate to be a start/stop key if it applies&lt;br/&gt;
    to the &lt;em&gt;first&lt;/em&gt; column in the conglomerate.  Otherwise the probe predicate would&lt;br/&gt;
    end up being generated as a store qualifier, which means we would only get rows&lt;br/&gt;
    for which &quot;column = ?&quot; was true when the parameter was set to the &lt;em&gt;first&lt;/em&gt; value&lt;br/&gt;
    in the IN-list.  That means we would end up with incorrect results (missing&lt;br/&gt;
    rows).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If cost-based optimization is complete and we are modifying access paths in&lt;br/&gt;
    preparation for code generation, then take any probe predicates that are &lt;b&gt;not&lt;/b&gt;&lt;br/&gt;
    going to be used as start/stop keys for the chosen conglomerate and &quot;revert&quot; them&lt;br/&gt;
    back to their original IN-list form (i.e. to the InListOperatorNodes from which&lt;br/&gt;
    they were built).  Those InListOpNodes will then be generated as normal IN-list&lt;br/&gt;
    restrictions on the rows returned from store.  If we did not do this reverting&lt;br/&gt;
    then the predicates would ultimately be ignored (since they are not valid&lt;br/&gt;
    qualifiers) and we would therefore end up with incorrect results (extra rows).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If we&apos;re modifying access paths and we have chosen to do multi-probing of an index&lt;br/&gt;
    then we disable bulk fetching for the target base table.  Logically this is not a&lt;br/&gt;
    requirement.  However, it turns out that bulk fetch can lead to poor performance&lt;br/&gt;
    when multi-probing an index if the number of probe values is high (several hundred&lt;br/&gt;
    or more) BUT that number is still just a small fraction of the total number of rows&lt;br/&gt;
    in the table.  An example of such a scenario is found in the Derby47PerformanceTest&lt;br/&gt;
    program attached to this issue.  If the total number of rows in the ADMIN.CHANGES&lt;br/&gt;
    table is 100,000 and there are 200 or more parameter markers in the IN-list, the&lt;br/&gt;
    performance of multi-probing with bulk fetch enabled is just as bad as a table&lt;br/&gt;
    scan--and actually gets worse as the number of parameters grows.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I cannot say with any certainty why bulk fetching performs so badly in this situation.  My guess (and it&apos;s just a guess) is that when we bulk fetch we end up reading a unnecessary pages from disk.  My (perhaps faulty) thinking is that for each probe we do of the index our start and stop keys are going to be the same value.  That means that we are probably going to be returning at most a handful of rows (more likely just a row or two).  But perhaps bulk fetching is somehow causing us to read more pages from disk than we need and the result is a slowdown in performance?&lt;/p&gt;

&lt;p&gt;Does anyone know if that actually makes any sense?  I could be completely wrong here so I&apos;d appreciate any correction.&lt;/p&gt;

&lt;p&gt;All of that said, I found that if I disable bulk fetch for multi-probing the performance returns to what I would expect (matching and even beating the &quot;Marker&quot; strategy posted by James), so that&apos;s what d47_mp_CBO_MoAP_v1.patch does.  At the very least I&apos;m hoping this is an acceptable step in the right direction.&lt;/p&gt;

&lt;p&gt;As with my previous patch, this CBO_MoAP patch should not change any existing functionality because all of the new behavior depends on the existence of &quot;probe predicates&quot;, which do not yet exist.&lt;/p&gt;

&lt;p&gt;Review comments are much appreciated (esp. w.r.t the bulk fetching changes)...&lt;/p&gt;</comment>
                            <comment id="12476475" author="army" created="Wed, 28 Feb 2007 01:01:25 +0000"  >&lt;p&gt;Attaching a patch, d47_mp_addlTestCases.patch, which adds some additional IN-list test cases to the lang/inbetween.sql test.  These test cases all currently behave correctly; by adding them to inbetween.sql we can ensure that they will continue to behave correctly once the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes have been completed.&lt;/p&gt;

&lt;p&gt;The underlying notion here is to make sure IN list behavior is correct when the left operand is a column reference that is a leading column in one or more indexes.  The &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes will ultimately make it so that most of the new test cases result in an index-probing execution plan, thus we want to make sure that we&apos;re testing as many of the various index-based use cases as possible.&lt;/p&gt;

&lt;p&gt;Note that these test cases are just testing correctness of results; additional tests will be added later to verify that indexes are in fact being chosen as a result of the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes.&lt;/p&gt;

&lt;p&gt;Patch committed with svn #512534: &lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=512534&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=512534&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12476489" author="bryanpendleton" created="Wed, 28 Feb 2007 02:01:42 +0000"  >&lt;p&gt;Something about this SQL statement just tickled my fancy and made me smile!&lt;/p&gt;

&lt;p&gt;update bt1 set de = cast (i/2.8 as decimal(4,1)) where i &amp;gt;= 10 and 2 * (cast (i as double) / 2.0) - (i / 2) = i / 2;&lt;/p&gt;</comment>
                            <comment id="12477358" author="army" created="Fri, 2 Mar 2007 16:57:27 +0000"  >&lt;p&gt;Committed d47_mp_CBO_MoAP_v1.patch with svn 513839:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=513839&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=513839&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12478211" author="army" created="Mon, 5 Mar 2007 23:45:17 +0000"  >&lt;p&gt;Attaching d47_mp_codeGen_v1.patch, which updates Derby code generation to account for the potential presence of IN-list probe predicates.  This patch does the following:&lt;/p&gt;

&lt;p&gt;  1 - Moves the code for generating a list of IN values into a new method, InListOperatorNode.generateListAsArray()&quot;.  The new method is then called from two places:&lt;/p&gt;

&lt;p&gt;     A. InListOperatorNode.generateExpression(): the &quot;normal&quot; code-path for&lt;br/&gt;
        generating IN-list bytecode (prior to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes).&lt;/p&gt;

&lt;p&gt;     B. PredicateList.generateInListValues(): new method for generating the IN-list&lt;br/&gt;
        values that will serve as the execution-time index &quot;probe&quot; values. This&lt;br/&gt;
        method also generates a boolean to indicate whether or not the values&lt;br/&gt;
        are already sorted (i.e. if we sorted them at compile time, which means&lt;br/&gt;
        they all must have been constants).&lt;/p&gt;

&lt;p&gt;  2 - Adds code to ParameterNode that allows generation of a &quot;place-holder&quot; value (instead of the ParameterNode itself) for probe-predicates.  This is required because a probe predicate has the form &quot;column = ?&quot; where the right operand is an internally generated parameter node that does not actually correspond to a user parameter.  Since that parameter node is &quot;fake&quot; we can&apos;t really generate it; instead we need to be able to generate a legitimate ValueNode-&lt;del&gt;either a constant node or a &quot;real&quot; parameter node&lt;/del&gt;-to serve as the place-holder.  The codeGen patch makes that possible.&lt;/p&gt;

&lt;p&gt;  3 - Updates the generateExpression() method of BinaryOperatorNode to account for situations where the optimizer chooses a plan for which a probe predicate is &lt;b&gt;not&lt;/b&gt; a useful start/stop key and thus is not being used for execution-time index probing.  In this case we simply &quot;revert&quot; the probe predicate back to the InListOperatorNode from which it was created.  Or put another way, we &quot;give up&quot; on index multi-probing and simply generate the original IN-list as a regular restriction.&lt;/p&gt;

&lt;p&gt;    In creating this patch I realized that having the &quot;revert&quot; code in BinaryOperatorNode.generateExpression() is a &quot;catch-all&quot; for any probe predicates that are not &quot;useful&quot; for the final access path.  So by doing the &quot;revert&quot; operation at code generation time we remove the need for the explicit &quot;revertToSourceInList()&quot; calls that I added to &quot;modification of access paths&quot; code in the previous patch (d47_CBO_MoAP).  Since I could not see any benefit to reverting during MoAP vs. reverting at code gen time, I opted to go with the latter.  So this patch also removes the now unnecessary &quot;revertToSourceInList()&quot; calls from PredicateList.java.&lt;/p&gt;

&lt;p&gt;  4 - Adds logic to NestedLoopJoinStrategy to generate a new type of result set, MultiProbeTableScanResultSet, for probing an index at execution time.  The new result set does not yet exist (incremental development) but the code to generate such a result set is added as part of this patch.  Note that we should never choose to do &quot;multi-probing&quot; for a hash join; comments explaining why are in the patch, along with a sanity assertion to catch any cases for which that might incorrectly happen.&lt;/p&gt;

&lt;p&gt;  5 - Adds a new method, &quot;getMultiProbeTableScanResultSet()&quot;, to the ResultSetFactory interface.  Also adds a corresponding stub method to GenericResultSetFactory.  The latter is just a dummy method and will be filled in with the appropriate code as part of a subsequent patch.&lt;/p&gt;

&lt;p&gt;I ran derbyall and suites.All on Red Hat Linux with ibm142 and there were no new failures.  Reviews are appreciated, as always.  If I hear no objections I will commit this patch in a couple of days.&lt;/p&gt;</comment>
                            <comment id="12478269" author="bryanpendleton" created="Tue, 6 Mar 2007 05:37:28 +0000"  >&lt;p&gt;Hi Army, just wanted to let you know that I&apos;ve been reading your notes and reading the patches. If I have any concrete comments or suggestions, I&apos;ll barge in, but so far it&apos;s all looked quite good to me. I particularly want to thank you for taking the time to comment the code so clearly and thoroughly; it makes the world of difference to us code-readers.&lt;/p&gt;</comment>
                            <comment id="12478927" author="army" created="Wed, 7 Mar 2007 22:16:04 +0000"  >&lt;p&gt;Committed d47_mp_codeGen_v1.patch with svn # 515795:&lt;/p&gt;

&lt;p&gt;    URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=515795&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=515795&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And now attaching d47_mp_exec_v1.patch, which is a patch to implement execution-time &quot;probing&quot; given a probe predicate &quot;place-holder&quot; and a list of IN values.  This patch creates a new execution-time result, MuliProbeTableScanResultSet, to perform the probing. Generally speaking the process is as follows, where &quot;probe list&quot; (aka &quot;probeValues&quot;) corresponds to the IN list in question.&lt;/p&gt;

&lt;p&gt;  0 - Open a scan using the first value in the (sorted) probe list as a start AND stop key.&lt;/p&gt;

&lt;p&gt;Then for each call to &quot;getNextRowCore()&quot;:&lt;/p&gt;

&lt;p&gt;  1 - See if we have a row to read from the current scan position. If so, return that row (done).&lt;/p&gt;

&lt;p&gt;  2 - If there are no more rows to read from the current scan position AND if there are more&lt;br/&gt;
    probe values to look at, then a) reopen the scan using the next probe value as the start/&lt;br/&gt;
    stop key and b) go back to step 1.  Otherwise proceed to step 3.&lt;/p&gt;

&lt;p&gt;  3 - Return null (no more rows).&lt;/p&gt;

&lt;p&gt;At a higher-level the changes in exec_v1.patch make it so that repeated calls to MultiProbeTableScanResultSet.getNextRowCore() will first return all rows matching probeValues&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, then all rows matching probeValues&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, and so on (duplicate probe values are ignored).  Once all matching rows for all values in probeValues have been returned, the call to getNextRowCore() will return null, thereby ending the scan.&lt;/p&gt;

&lt;p&gt;In order to accommodate the above behavior, the following changes were made to existing files:&lt;/p&gt;

&lt;p&gt; 1 - Add correct instantiation logic to the &quot;getMultiProbeTableScanResultSet()&quot;&lt;br/&gt;
   method of GenericResultSetFactory, which was just a stub method before this&lt;br/&gt;
   patch.&lt;/p&gt;

&lt;p&gt; 2 - Overloaded methods in TableScanResultSet to allow the passing of a &quot;probe value&quot;&lt;br/&gt;
   into the openScanController() and reopenScanController() methods.  The methods&lt;br/&gt;
   then use the probe value (if one exists) as the start/stop key for positioning&lt;br/&gt;
   a scan, instead of using the start/stop key passed into the result set constructor.&lt;/p&gt;

&lt;p&gt; 3 - Made the iapi.types.DataType class implement the java.lang.Comparable interface&lt;br/&gt;
   for the sake of easy sorting (just let the JVM do the sort).  Since DataType (the&lt;br/&gt;
   superclass of all datatypes and base implementation of the DataValueDescriptor&lt;br/&gt;
   interface) already has a &quot;compare()&quot; method that returns an integer to indicate&lt;br/&gt;
   less than, greater than, or equal, all we have to do is wrap that method inside&lt;br/&gt;
   a &quot;compareTo()&quot; method and we&apos;re done.&lt;/p&gt;

&lt;p&gt;   There are two issues worth mentioning regarding this sort.  First, the compareTo()&lt;br/&gt;
   method does not throw any exceptions, so if an error occurs while trying to compare&lt;br/&gt;
   two DataValueDescriptors, we will simply treat the values as &quot;equal&quot; when running&lt;br/&gt;
   in insane mode (in sane mode we will throw an assertion failure).  Is this&lt;br/&gt;
   acceptable?  If not, is there a better way to handle this, aside from writing my&lt;br/&gt;
   own sorting code? (which is doable but seems like overkill).&lt;/p&gt;

&lt;p&gt;   Second, for some strange reason sorting the probeValues array directly (i.e.&lt;br/&gt;
   in-place sort) leads to incorrect parameter value assignment when executing a&lt;br/&gt;
   prepared statement multiple times.  I was unable to figure out why that might&lt;br/&gt;
   be (maybe related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt;?).  To get around the problem I create clones&lt;br/&gt;
   of the IN values and then sort the clones.  That solves the problem but has&lt;br/&gt;
   the obvious drawback of extra memory requirements.  I&apos;m hoping that for now&lt;br/&gt;
   this is an okay workaround (progress, not perfection), but if anyone has any&lt;br/&gt;
   ideas as to what could be going on here, I&apos;d appreciate the input.&lt;/p&gt;

&lt;p&gt;   And of course, if there are any other reasons why it&apos;s bad to make DataType&lt;br/&gt;
   implement the Comparable interface, I hope that reviewers can speak up.  If&lt;br/&gt;
   it comes down to it I can always add a simple sort method to MultiProbeTSCRS&lt;br/&gt;
   and just use that.&lt;/p&gt;

&lt;p&gt;As with all preceding patches, this patch should not have any functional effect on Derby processing because the new behavior depends on probe predicates, which do not yet exist.  I have not yet had a chance to run derbyall as a sanity check, but plan to do so before committing.  In the meantime, questions/comments/feedback on exec_v1.patch as attached would be much appreciated.&lt;/p&gt;</comment>
                            <comment id="12479232" author="bryanpendleton" created="Thu, 8 Mar 2007 05:52:39 +0000"  >&lt;p&gt;I was reading through d47_mp_codeGen_v1.patch, and the &lt;br/&gt;
new getMultiProbeTableScanResultSet() method struck me as&lt;br/&gt;
somewhat awkward in having 26 arguments to the method. I see&lt;br/&gt;
you haven&apos;t actually implemented this method yet (or maybe you have;&lt;br/&gt;
I&apos;m a patch-or-two behind &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ), so maybe it&apos;s possible to explore why&lt;br/&gt;
we ended up with 26 arguments here?&lt;/p&gt;</comment>
                            <comment id="12479350" author="army" created="Thu, 8 Mar 2007 16:40:00 +0000"  >&lt;p&gt;&amp;gt; maybe it&apos;s possible to explore why we ended up with 26 arguments here?&lt;/p&gt;

&lt;p&gt;Good question, Bryan.  The relevant code in codeGen_v1.patch is as follows:&lt;/p&gt;

&lt;p&gt;+		/* If we&apos;re going to generate a list of IN-values for index probing&lt;br/&gt;
+		 * at execution time then we push TableScanResultSet arguments plus&lt;br/&gt;
+		 * two additional arguments: 1) the list of IN-list values, and 2)&lt;br/&gt;
+		 * a boolean indicating whether or not the IN-list values are already&lt;br/&gt;
+		 * sorted.&lt;br/&gt;
+		 */&lt;br/&gt;
+		if (genInListVals)&lt;br/&gt;
 		{&lt;br/&gt;
+			numArgs = 26;&lt;/p&gt;

&lt;p&gt;What that comment does not say is that the reason we use TableScanresultSet arguments plus 2 is that the new result set, MultiProbeTableScanResultSet, extends TableScanResultSet and depends on TableScanResultSet to do most of the work.  Therefore we need all of the usual (24) arguments for TableScanResultSet , plus two additional arguments for logic specific to multi-probing.  The latest patch, d47_mp_exec_v1.patch, includes the new MultiProbeTableScanResultSet class, which hopefully shows how things are expected to work.&lt;/p&gt;

&lt;p&gt;&amp;gt; (or maybe you have; I&apos;m a patch-or-two behind &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ),&lt;/p&gt;

&lt;p&gt;Oops!  My apologies.  For some reason I took your previous comment to mean that you had already looked at the various patches up to and including codeGen_v1, and that you didn&apos;t have any suggestions.  I see now that you were (perhaps?) indicating that you were in the &lt;b&gt;process&lt;/b&gt; of looking at the patches but were not yet done.&lt;/p&gt;

&lt;p&gt;Sorry for rushing on this one.  I&apos;ll let the exec_v1 patch sit for a while (at least until Monday) to give you (and any other developers who may be in a similar situation) ample review time.  I&apos;ll post again before I commit and if you have any feedback or else would like a few more days, feel free to say so.&lt;/p&gt;

&lt;p&gt;I appreciate you looking at these patches and didn&apos;t mean to hurry or otherwise overlook your comments.  Take all the time you need, and please continue to ask any questions you may have.&lt;/p&gt;

&lt;p&gt;Thanks again for your time!&lt;/p&gt;</comment>
                            <comment id="12479416" author="bryanpendleton" created="Thu, 8 Mar 2007 19:43:21 +0000"  >&lt;p&gt;Thanks Army for the good explanation. I didn&apos;t realize that the calls to this 26-argument &lt;br/&gt;
method are generated. That makes a bit difference; I was worried about the complexity&lt;br/&gt;
of human beings writing and maintaining code which called the 26-argument method, but&lt;br/&gt;
if it&apos;s only called by generated code it&apos;s a totally different story.&lt;/p&gt;

&lt;p&gt;I don&apos;t think you&apos;re rushing. Please keep on with the process as you&apos;ve been doing it; if I&lt;br/&gt;
come up with anything of substance we can take a look at it at that time.&lt;/p&gt;</comment>
                            <comment id="12479933" author="bryanpendleton" created="Sun, 11 Mar 2007 18:37:47 +0000"  >&lt;p&gt;Hi Army,&lt;/p&gt;

&lt;p&gt;I finally got around to reading through the patches. Sorry it took a while.&lt;br/&gt;
I haven&apos;t actually &lt;b&gt;run&lt;/b&gt; any of the code, just given the patches a close&lt;br/&gt;
reading, so some of these questions could have been answered that way, but&lt;br/&gt;
hopefully it&apos;s all still useful to you. Without further ado &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;By the way, all of these are &lt;b&gt;very&lt;/b&gt; minor things. These patches are excellent,&lt;br/&gt;
and I learned a lot from reading them. This is great work!&lt;/p&gt;

&lt;p&gt;1) In the relOpPredCheck patch, you made this change to PredicateList.java:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (relop == null || ! relop.isQualifier(optTable, false))&lt;br/&gt;
+			if (!pred.isRelationalOpPredicate() ||&lt;br/&gt;
+				!pred.getRelop().isQualifier(optTable, false))&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   I&apos;m concerned that this change may have a hole for a possible NPE. Is it&lt;br/&gt;
   possible that there could arise a case where we have an IN-list predicate&lt;br/&gt;
   at this point, such that relop is null but in-list is not null, and then&lt;br/&gt;
   pred.isRelationalOpPredicate() would return false, but pred.getRelop()&lt;br/&gt;
   would return null? &lt;/p&gt;

&lt;p&gt;2) I spent some time studying the code in PredicateList.java which manipulates&lt;br/&gt;
   IN list operator predicates, and got a bit twisted around. There seems to&lt;br/&gt;
   be a lot of code which looks, more or less, like the following:&lt;/p&gt;

&lt;p&gt;   RelationalOperator relop = pred.getRelop();&lt;br/&gt;
   InListOperatorNode inNode = pred.getSourceInList();&lt;br/&gt;
   boolean isIn = (inNode != null);&lt;/p&gt;

&lt;p&gt;    if (relop == null)&lt;br/&gt;
    {&lt;br/&gt;
        /* if it&apos;s &quot;in&quot; operator, we generate dynamic start and stop key&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;to improve index scan performance, beetle 3858.&lt;br/&gt;
         */&lt;br/&gt;
        if (pred.getAndNode().getLeftOperand() instanceof InListOperatorNode &amp;amp;&amp;amp;&lt;br/&gt;
            ! ((InListOperatorNode)pred.getAndNode().getLeftOperand()).getTransformed())
        {
            isIn = true;
            inNode = (InListOperatorNode) pred.getAndNode().getLeftOperand();
        }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  My naive reaction to code like this is &quot;shouldn&apos;t this be handled in&lt;br/&gt;
  pred.getSourceInList()&quot;?&lt;/p&gt;

&lt;p&gt;  That is, it seems like there&apos;s a lot of code in PredicateList.java which&lt;br/&gt;
  calls pred.getSourceInList, but then does this other complicated &quot;if&quot; test&lt;br/&gt;
  to get the InListOperatorNode a different way.&lt;/p&gt;

&lt;p&gt;  Can you help me understand why are there these two different ways to get&lt;br/&gt;
  the InListOperatorNode for a predicate (via getSourceInList() and via &lt;br/&gt;
  getAndNode.getLeftOperand() ), and what do you think about creating a&lt;br/&gt;
  &quot;helper&quot; function in Predicate.java, similar to getSourceInList, to clean up&lt;br/&gt;
  the 4 or 5 places in PredicateList.java where we have code like the above?&lt;/p&gt;

&lt;p&gt;3) The new method PredicateList.generateInListValues() seems to go to some&lt;br/&gt;
   pains to handle the case where it is called, but this predicate list&lt;br/&gt;
   actually doesn&apos;t have any in list values to generate. My reaction was:&lt;br/&gt;
   &quot;why is this routine getting called in this case?&quot; It seems like&lt;br/&gt;
   NestedLoopJoinStrategy never calls generateInListValues unless there are&lt;br/&gt;
   actually in-list values to generate, so why does generateInListValues&lt;br/&gt;
   need to handle the case where there is no InListOperatorNode?&lt;/p&gt;

&lt;p&gt;   That is, does the final &quot;else&quot; clause in generateInListValues ever actually&lt;br/&gt;
   occur?&lt;/p&gt;

&lt;p&gt;4) The code which traverses predicate lists seems to always traverse them&lt;br/&gt;
   in backwards order, e.g. this code from HashJoinStrategy.java:&lt;/p&gt;

&lt;p&gt;            for (int i = storeRestrictionList.size() - 1; i &amp;gt;= 0; i--)&lt;/p&gt;

&lt;p&gt;   Why do we always traverse these backwards? Is this just an optimization&lt;br/&gt;
   in order to call the size() method only once? Or is there something&lt;br/&gt;
   deeper going on?&lt;/p&gt;

&lt;p&gt;5) In InListOperatorNode, I at first thought that you had put this code in,&lt;br/&gt;
   but then after more study I saw that this was just an artifact of the&lt;br/&gt;
   patch program and you hadn&apos;t introduced this code, but just re-arranged it&lt;br/&gt;
   a bit. Still, the code showed up with &quot;+&quot; signs in the patch so I looked&lt;br/&gt;
   at it, and feel compelled to comment on it.&lt;/p&gt;

&lt;p&gt;   This is at about line 413 in InListOperatorNode.java:&lt;/p&gt;

&lt;p&gt;        //LocalField receiverField =&lt;br/&gt;
        //  acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);&lt;/p&gt;

&lt;p&gt;        leftOperand.generateExpression(acb, mb);&lt;br/&gt;
        mb.dup();&lt;br/&gt;
        //mb.putField(receiverField); // instance for method call&lt;br/&gt;
        /&lt;b&gt;mb.getField(receiverField);&lt;/b&gt;/ mb.upCast(leftInterfaceType); // first arg&lt;/p&gt;

&lt;p&gt;   Do you know what is going on here? What is this commented out code, and&lt;br/&gt;
   can we clean it up? The last line in particular is quite frustrating with&lt;br/&gt;
   its snippet of actual code sandwiched in between two comments on the line.&lt;/p&gt;

&lt;p&gt;6) I seem to recall some discussions on the mailing lists from people who&lt;br/&gt;
   had code generation systems which tended to generate horrific IN clauses&lt;br/&gt;
   with, for example, upwards of 1500 elements in the IN list. I think it would&lt;br/&gt;
   be nice to have a test or two which verified that we can actually compile&lt;br/&gt;
   and run such a SQL statement. You may have already done this, and I missed&lt;br/&gt;
   it, but most of the test cases in the addTestCases patch seemed to have&lt;br/&gt;
   IN list clauses with no more than 8-10 values in them.&lt;/p&gt;

&lt;p&gt;   A test case like this, while hideously ugly, would help to ensure that&lt;br/&gt;
   we didn&apos;t have some problematic N^2 or N! handling of the IN list values&lt;br/&gt;
   somewhere that would explode if we had too many IN list values.&lt;/p&gt;

&lt;p&gt;7) Generally speaking, I like the new convenience methods in Predicate.java,&lt;br/&gt;
   but I do worry about whether we need to start being concerned about&lt;br/&gt;
   overall efficiency in the optimizer. For example, consider a change like:&lt;/p&gt;

&lt;p&gt; 			RelationalOperator relop = pred.getRelop();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (relop != null)&lt;br/&gt;
+			if (pred.isRelationalOpPredicate())&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   since isRelationalOpPredicate may end up calling getRelop() two more times,&lt;br/&gt;
   and since getRelop() calls getLeftOperand() twice and does an instanceof&lt;br/&gt;
   check, we&apos;re incrementally adding a fair amount of code.&lt;/p&gt;

&lt;p&gt;   It&apos;s really important that the optimizer code be clear and easy to read,&lt;br/&gt;
   so I&apos;m not suggesting any drastic measures. I&apos;m just sort of thinking&lt;br/&gt;
   out loud about some concerns about how to write an optimizer which is&lt;br/&gt;
   simultaneously both&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;clear and easy to read and understand (this is the most important)&lt;/li&gt;
	&lt;li&gt;yet also efficient to run&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12480146" author="army" created="Mon, 12 Mar 2007 16:59:15 +0000"  >&lt;p&gt;Bryan Pendleton (JIRA) wrote:&lt;br/&gt;
&amp;gt; I finally got around to reading through the patches.  I haven&apos;t actually&lt;br/&gt;
&amp;gt; &lt;b&gt;run&lt;/b&gt; any of the code, just given the patches a close reading&lt;/p&gt;

&lt;p&gt;Thank you &lt;em&gt;very&lt;/em&gt; much for taking the time to do such a thorough review, Bryan.  I definitely appreciate the feedback.  My attempted answers are below, but if anything is still unclear, please do not hesitate to ask again.  Better to get this right the first time &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) In the relOpPredCheck patch, you made this change to PredicateList.java:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; -			if (relop == null || ! relop.isQualifier(optTable, false))&lt;br/&gt;
&amp;gt; +			if (!pred.isRelationalOpPredicate() ||&lt;br/&gt;
&amp;gt; +				!pred.getRelop().isQualifier(optTable, false))&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    I&apos;m concerned that this change may have a hole for a possible NPE. Is it&lt;br/&gt;
&amp;gt;    possible that there could arise a case where we have an IN-list predicate&lt;br/&gt;
&amp;gt;    at this point, such that relop is null but in-list is not null, and then&lt;br/&gt;
&amp;gt;    pred.isRelationalOpPredicate() would return false, but pred.getRelop()&lt;br/&gt;
&amp;gt;    would return null? &lt;/p&gt;

&lt;p&gt;If we assume that we do in fact have a situation where &quot;relop is null but in-list is not null&quot;, then pred.isRelationalOpPredicate() will, as you said, return false.  That means that &quot;!pred.isRelationalOpPredicate()&quot; will return true, and since we are using a short-circuited OR operator, I don&apos;t think we would ever get to the pred.getRelop() call in that case, would we?&lt;/p&gt;

&lt;p&gt;The intent was that we only get to the second part of the OR if we know for a fact that pred.getRelop() will return a non-null value.  And if &quot;pred&quot; is a relational op predicate (i.e. if the first part of the OR evaluates to &quot;false&quot;) then that should always be the case.  It is of course possible that I missed something and that the code doesn&apos;t follow the intent; please let me know if you can think of such a case...&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) I spent some time studying the code in PredicateList.java which manipulates&lt;br/&gt;
&amp;gt;    IN list operator predicates, and got a bit twisted around.&lt;/p&gt;

&lt;p&gt;[ snip code fragment ]&lt;/p&gt;

&lt;p&gt;&amp;gt;   My naive reaction to code like this is &quot;shouldn&apos;t this be handled in&lt;br/&gt;
&amp;gt;   pred.getSourceInList()&quot;?&lt;/p&gt;

&lt;p&gt;Good point.  When I was making the changes I wrote &quot;getSourceInList()&quot; specifically for the new probe predicates; I was just leaving the existing InListOperatorNode logic as it was.  But you&apos;re right, it&apos;s probably cleaner to expand that method to cover the &quot;old&quot; IN-list cases, as well.  I will look into this for a follow-up patch.&lt;/p&gt;

&lt;p&gt;&amp;gt;   Can you help me understand why are there these two different ways to get&lt;br/&gt;
&amp;gt;   the InListOperatorNode for a predicate (via getSourceInList() and via &lt;br/&gt;
&amp;gt;   getAndNode.getLeftOperand() ), &lt;/p&gt;

&lt;p&gt;The former (getSourceInList()) was added to handle &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; probe predicates while the latter (getAndNode.getLeftOperand()) was already there for handling the &quot;normal&quot; (pre &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;) InLists.  But you&apos;re right, it might be good to combine the two--I&apos;ll try to do that.&lt;/p&gt;

&lt;p&gt;&amp;gt; 3) The new method PredicateList.generateInListValues() seems to go to some&lt;br/&gt;
&amp;gt;    pains to handle the case where it is called, but this predicate list&lt;br/&gt;
&amp;gt;    actually doesn&apos;t have any in list values to generate. My reaction was:&lt;br/&gt;
&amp;gt;    &quot;why is this routine getting called in this case?&quot; It seems like&lt;br/&gt;
&amp;gt;    NestedLoopJoinStrategy never calls generateInListValues unless there are&lt;br/&gt;
&amp;gt;    actually in-list values to generate, so why does generateInListValues&lt;br/&gt;
&amp;gt;    need to handle the case where there is no InListOperatorNode?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    That is, does the final &quot;else&quot; clause in generateInListValues ever actually&lt;br/&gt;
&amp;gt;    occur?&lt;/p&gt;

&lt;p&gt;Great catch!  When I first wrote the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes I had all of the probing logic inside the TableScanResultSet class, and thus the additional arguments were always generated, even in cases where no probe predicates existed.  I later realized that this was too much overhead since most TableScanResultSets will probably &lt;b&gt;not&lt;/b&gt; be doing multi-probing.  So I refactored the code and created a new result set, MultiProbeTableScanResultSet, which is only generated when probe predicates exist.  But I forgot to remove the corresponding logic from the generateInListValues() method, hence the &quot;else&quot;.&lt;/p&gt;

&lt;p&gt;So you&apos;re absolutely right: the &quot;else&quot; clause can be removed here and the code can be cleaned up accordingly.  I&apos;ll address that in a follow-up patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; 4) The code which traverses predicate lists seems to always traverse them&lt;br/&gt;
&amp;gt;    in backwards order, e.g. this code from HashJoinStrategy.java:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;             for (int i = storeRestrictionList.size() - 1; i &amp;gt;= 0; i--)&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    Why do we always traverse these backwards? Is this just an optimization&lt;br/&gt;
&amp;gt;    in order to call the size() method only once? Or is there something&lt;br/&gt;
&amp;gt;    deeper going on?&lt;/p&gt;

&lt;p&gt;This is just habit more than anything.  A lot of the optimizer-related work that I&apos;ve been doing requires the removal of certain predicates from predicate lists at various points in the code, and in that case reverse traversal is better (because removal of elements from the rear does not require adjustments to the loop index).  So I often write loop iteration with backwards traversal out of sheer habit, even when removal of predicates is not happening.  If you think this makes the code more confusing or less intuitive I have no problems with switching to forward traversal.&lt;/p&gt;

&lt;p&gt;&amp;gt; 5) In InListOperatorNode, I at first thought that you had put this code in,&lt;br/&gt;
&amp;gt;    but then after more study I saw that this was just an artifact of the&lt;br/&gt;
&amp;gt;    patch program and you hadn&apos;t introduced this code, but just re-arranged it&lt;br/&gt;
&amp;gt;    a bit. Still, the code showed up with &quot;+&quot; signs in the patch so I looked&lt;br/&gt;
&amp;gt;    at it, and feel compelled to comment on it.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    This is at about line 413 in InListOperatorNode.java:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;         //LocalField receiverField =&lt;br/&gt;
&amp;gt;         //  acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;         leftOperand.generateExpression(acb, mb);&lt;br/&gt;
&amp;gt;         mb.dup();&lt;br/&gt;
&amp;gt;         //mb.putField(receiverField); // instance for method call&lt;br/&gt;
&amp;gt;         /&lt;b&gt;mb.getField(receiverField);&lt;/b&gt;/ mb.upCast(leftInterfaceType); // first arg&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    Do you know what is going on here? What is this commented out code, and&lt;br/&gt;
&amp;gt;    can we clean it up? The last line in particular is quite frustrating with&lt;br/&gt;
&amp;gt;    its snippet of actual code sandwiched in between two comments on the line.&lt;/p&gt;

&lt;p&gt;Short answer is that I don&apos;t know what the commented out code is for, and my guess is that Yes, it can (and should) be cleaned up.  But I frequently comment on other people&apos;s patches that they should refrain from making unrelated &quot;cleanup&quot; changes as it makes the patches harder to review, so I thought maybe I should follow my own advice &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Feel free to commit this two-line cleanup as a separate patch if you&apos;d like--or I can do it myself, as well.  Either way, so long as its a separate commit, I think that&apos;s a good idea.&lt;/p&gt;

&lt;p&gt;&amp;gt; 6) I seem to recall some discussions on the mailing lists from people who&lt;br/&gt;
&amp;gt;    had code generation systems which tended to generate horrific IN clauses&lt;br/&gt;
&amp;gt;    with, for example, upwards of 1500 elements in the IN list. I think it would&lt;br/&gt;
&amp;gt;    be nice to have a test or two which verified that we can actually compile&lt;br/&gt;
&amp;gt;    and run such a SQL statement. You may have already done this, and I missed&lt;br/&gt;
&amp;gt;    it, but most of the test cases in the addTestCases patch seemed to have&lt;br/&gt;
&amp;gt;    IN list clauses with no more than 8-10 values in them.&lt;/p&gt;

&lt;p&gt;There is an existing test case in lang/inbetween.sql that has such a test for &quot;normal&quot; (pre &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;) IN-list processing.  The query in that case has 4056 values (constants) in it.&lt;/p&gt;

&lt;p&gt;I was also looking at the repro attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, which generates and executes IN-lists with up to 2500 and more values.  I&apos;d like to pull out the relevant pieces and include them in a new JUnit test as a way to verify that thing works for large IN lists when multi-probing is in effect, as well.  That&apos;s still a forthcoming patch.  For the record, though, I ran the repro on a database with 100,000 rows in it and a single IN-list of 2500 values, and everything worked fine--even when multi-probing was in effect.  This is as I would expect since the code to generate the IN-list is the same before and after my changes.&lt;/p&gt;

&lt;p&gt;&amp;gt; 7) Generally speaking, I like the new convenience methods in Predicate.java,&lt;br/&gt;
&amp;gt;    but I do worry about whether we need to start being concerned about&lt;br/&gt;
&amp;gt;    overall efficiency in the optimizer. For example, consider a change like:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;  			RelationalOperator relop = pred.getRelop();&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; -			if (relop != null)&lt;br/&gt;
&amp;gt; +			if (pred.isRelationalOpPredicate())&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    since isRelationalOpPredicate may end up calling getRelop() two more times,&lt;br/&gt;
&amp;gt;    and since getRelop() calls getLeftOperand() twice and does an instanceof&lt;br/&gt;
&amp;gt;    check, we&apos;re incrementally adding a fair amount of code.&lt;/p&gt;

&lt;p&gt;Great observation.&lt;/p&gt;

&lt;p&gt;&amp;gt;    It&apos;s really important that the optimizer code be clear and easy to read,&lt;br/&gt;
&amp;gt;    so I&apos;m not suggesting any drastic measures. I&apos;m just sort of thinking&lt;br/&gt;
&amp;gt;    out loud about some concerns about how to write an optimizer which is&lt;br/&gt;
&amp;gt;    simultaneously both&lt;br/&gt;
&amp;gt;    - clear and easy to read and understand (this is the most important)&lt;br/&gt;
&amp;gt;    - yet also efficient to run&lt;/p&gt;

&lt;p&gt;This is a very valid point.  I&apos;ve been focusing on the first goal, but you&apos;re right, the above change is perhaps too costly.  I&apos;ll look into remedying this with a follow-up patch...&lt;/p&gt;

&lt;p&gt;Thank you again for these excellent review comments.  I really (really) appreciate the extra pair of the eyes and the great suggestions.  As I said above, if any of the above answers are unclear or unsatisfactory, please ask again--I&apos;ll try to explain whatever it is that may not make sense.&lt;/p&gt;

&lt;p&gt;PS I plan to commit the exec_v1.plan patch later today (Monday) unless I hear objections from anyone...&lt;/p&gt;</comment>
                            <comment id="12480231" author="army" created="Tue, 13 Mar 2007 00:03:43 +0000"  >&lt;p&gt;Committed d47_mp_exec_v1.patch with svn 517470:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=517470&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=517470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Attaching d47_mp_preprocess_v1.patch, which is (finally) the patch that actually creates &quot;probe predicates&quot; during preprocessing, thus allowing the code changes in all previous patches to take effect.  Once this patch is committed Derby will start re-writing IN lists as probe predicates and, if the optimizer thinks it is best to do so, will start doing index &quot;multi-probing&quot; at execution time to avoid excessive scanning.  The changes in this patch affect &quot;preprocessing&quot; logic as follow:&lt;/p&gt;

&lt;p&gt;  1. Replaces &quot;A&quot; with &quot;B&quot;, where &quot;A&quot; is existing logic that creates a BETWEEN&lt;br/&gt;
     node for IN-lists containing all constants, and &quot;B&quot; is new logic that&lt;br/&gt;
     creates a &quot;probe predicate&quot; for IN-lists containing all constants &lt;b&gt;and/or&lt;/b&gt;&lt;br/&gt;
     parameter nodes.  The probe predicates are then used throughout optimization,&lt;br/&gt;
     modification of access paths, code generation, and execution time (as&lt;br/&gt;
     appropriate) in the manner described by previous patches.&lt;/p&gt;

&lt;p&gt;  2. Adds some additional logic to OrNode preprocessing to allow the conversion&lt;br/&gt;
     of queries like:&lt;/p&gt;

&lt;p&gt;        select ... from T1 where i in (2, 3) or i in (7, 10)&lt;/p&gt;

&lt;p&gt;     into queries that look like:&lt;/p&gt;

&lt;p&gt;        select ... from T1 where i in (2, 3, 7, 10)&lt;/p&gt;

&lt;p&gt;     This is really just an extension of the existing logic to transform a&lt;br/&gt;
     chain of OR nodes into an IN-list.&lt;/p&gt;

&lt;p&gt;  3. Adds logic to PredicateList.pushExpressionsIntoSelect() to correctly&lt;br/&gt;
     copy &quot;probe predicates&quot; so that the left operand (column reference)&lt;br/&gt;
     is pointing to the correct place when we do static pushing of one-&lt;br/&gt;
     sided predicates (which is what a &quot;probe predicate&quot; is).&lt;/p&gt;

&lt;p&gt;  4. Adds a new method to ValueNodeList that is used for checking to see if&lt;br/&gt;
     a list of IN values consists solely of constant and/or parameter nodes&lt;br/&gt;
     (there are no other expressions or column references).&lt;/p&gt;

&lt;p&gt;I&apos;m also attaching a corresponding patch, d47_mp_masters_v1.patch, which contains all of the diffs caused by the new multi-probing functionality.  As is typical with tests that print out query plans, a simple change in the execution-time behavior can lead to massive diffs.  I manually looked at all of the diffs in the masters_v1.patch and it is my belief that all but one of them are acceptable and expected given the changes for this issue.  The one exception is for store/readlocks.sql, which is a test about which I know very little.  My guess (or perhaps more accurately, my &lt;em&gt;hope&lt;/em&gt;) is that this readlocks diff is okay, but it would be great if someone who knows more about it could verify.&lt;/p&gt;

&lt;p&gt;Note that I&apos;ve separated preprocess_v1.patch from masters_v1.patch for ease of review, but they both need to be committed at the same time in order to avoid failures in the nightly regression tests.&lt;/p&gt;

&lt;p&gt;As always, I&apos;d appreciate it if anyone has the time look these changes over and make comments.  If there are no objections I plan to commit these two patches Wednesday afternoon (March 14th, PST).&lt;/p&gt;

&lt;p&gt;Remaining tasks once preprocess_v1 is committed:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Address the (excellent) review comments raised by Bryan in one or more&lt;br/&gt;
    follow-up patches.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Add test cases to verify that Derby is now behaving as desired in the&lt;br/&gt;
    face of IN list restrictions on columns with useful indexes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Post some simple numbers to show the improvement that I see when running&lt;br/&gt;
    Derby47PerformanceTest.java (attached to this issue) before and after&lt;br/&gt;
    the changes for this issue.  Also, discuss a couple of areas to investigate&lt;br/&gt;
    post-&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; (i.e. things to consider as separate Jira issues).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m hoping to have most of this work posted by the end of the week, but of course that all depends on the feedback I receive and the amount of other &quot;stuff&quot; that comes up between now and then.&lt;/p&gt;</comment>
                            <comment id="12480448" author="army" created="Tue, 13 Mar 2007 15:55:39 +0000"  >&lt;p&gt;Atttaching the readlocks diff with more context to hopefully help in reviewing...&lt;/p&gt;</comment>
                            <comment id="12480534" author="bryanpendleton" created="Tue, 13 Mar 2007 20:11:19 +0000"  >&lt;p&gt;Hi Army, I had a look at the preprocess and master patches and they look&lt;br/&gt;
good to me. Here&apos;s a couple small thoughts I had which you might want to&lt;br/&gt;
consider down the road.&lt;/p&gt;

&lt;p&gt;0) You are right about the compound IF statement that we discussed in the&lt;br/&gt;
   previous set of comments. I misread the logic, and I agree that there is&lt;br/&gt;
   not any NPE hole there. Thanks for the further explanation.&lt;/p&gt;

&lt;p&gt;1) In one of the comments, you said:&lt;/p&gt;

&lt;p&gt;   We intentionally use a parameter node instead of a constant node &lt;br/&gt;
   because the IN-list has more than one value &lt;/p&gt;

&lt;p&gt;   It&apos;s not &lt;b&gt;always&lt;/b&gt; true that the IN-list has more than one value, right?&lt;br/&gt;
   That is, it would be legal, if not very useful, to write&lt;/p&gt;

&lt;p&gt;   SELECT * FROM t WHERE c IN (1)&lt;/p&gt;

&lt;p&gt;   As I read the code near that comment, it didn&apos;t seem that you were actually&lt;br/&gt;
   depending on the IN-list having more than one value. Rather, you were&lt;br/&gt;
   choosing a data structure which could handle multiple values, but which can&lt;br/&gt;
   handle a single value just as well.&lt;/p&gt;

&lt;p&gt;   But I thought I&apos;d mention it just to be sure.&lt;/p&gt;

&lt;p&gt;2) Do you have any test cases of the form&lt;/p&gt;

&lt;p&gt;   WHERE c IN (SELECT c_prime from t_prime)&lt;/p&gt;

&lt;p&gt;   That is, where the IN-list is neither a list of literal constants, nor a&lt;br/&gt;
   list of parameter markers, but is instead a subquery whose values will&lt;br/&gt;
   be used as the list.&lt;/p&gt;

&lt;p&gt;   Does such a query generate and use the new style Multi-Probe processing?&lt;/p&gt;

&lt;p&gt;3) Do you have any test cases in which the IN-list predicate references a&lt;br/&gt;
   column in a UNION or a UNION view, thus requiring pushing the IN-list&lt;br/&gt;
   predicate down and pulling it back up?&lt;/p&gt;

&lt;p&gt;4) In the change to OrNode.java, my eye was caught by the variable name &quot;beon&quot;.&lt;br/&gt;
   I&apos;ve seen that a common convention is to use an acronym, so maybe &quot;beon&quot;&lt;br/&gt;
   stood for Binary Equality Operator Node, or something like that, but the&lt;br/&gt;
   actual datatype is Binary*Relational*OperatorNode, so I would have&lt;br/&gt;
   expected to see a variable &quot;bron&quot;.&lt;/p&gt;

&lt;p&gt;   BinaryRelationalOperatorNode beon = null;&lt;/p&gt;

&lt;p&gt;   It&apos;s totally unimportant, but I saw it and thought I&apos;d mention it.&lt;/p&gt;

&lt;p&gt;5) I looked at the updated masters; to my eye they show that the new probe&lt;br/&gt;
   predicate is working, and the optimizer is choosing to use index-to-base&lt;br/&gt;
   processing for these predicates rather than the formerly-chosen table&lt;br/&gt;
   scans, so this looks great to me.&lt;/p&gt;

&lt;p&gt;6) I have no guidance to offer regarding the readlocks diff, sorry.&lt;/p&gt;

&lt;p&gt;7) For some reason, I expected to see something more vivid indicating the&lt;br/&gt;
   use of the new execution strategy in the query plans, I thought maybe I&apos;d&lt;br/&gt;
   see something like &quot;MultiProbeTableScanResultSet&quot; in query dumps? Is it&lt;br/&gt;
   just these tests that don&apos;t show that, and other query dumps would? Or is&lt;br/&gt;
   the only indication that the new probing code has been chosen the use of&lt;br/&gt;
   the index in place of the table scan?&lt;/p&gt;</comment>
                            <comment id="12480546" author="army" created="Tue, 13 Mar 2007 20:59:29 +0000"  >&lt;p&gt;&amp;gt; 1) In one of the comments, you said:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    We intentionally use a parameter node instead of a constant node &lt;br/&gt;
&amp;gt;    because the IN-list has more than one value &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    It&apos;s not &lt;b&gt;always&lt;/b&gt; true that the IN-list has more than one value, right?&lt;br/&gt;
&amp;gt;    That is, it would be legal, if not very useful, to write&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    SELECT * FROM t WHERE c IN (1)&lt;/p&gt;

&lt;p&gt;Yes, an IN-list can only have a single value.  However, if such an IN-list occurs we will convert it into an equality predicate as part of the first &quot;if&quot; branch in the preprocess() method:&lt;/p&gt;

&lt;p&gt;    /* Check for the degenerate case of a single element in the IN list.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;If found, then convert to &quot;=&quot;.&lt;br/&gt;
     */&lt;br/&gt;
    if (rightOperandList.size() == 1)&lt;br/&gt;
    ...&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Thus we won&apos;t ever get to the code referenced above.  But you&apos;re right, it might be good to add an explanatory comment to explain this.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) Do you have any test cases of the form&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    WHERE c IN (SELECT c_prime from t_prime)&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    That is, where the IN-list is neither a list of literal constants, nor a&lt;br/&gt;
&amp;gt;    list of parameter markers, but is instead a subquery whose values will&lt;br/&gt;
&amp;gt;    be used as the list.&lt;/p&gt;

&lt;p&gt;A few test cases for this kind of query already exist in lang/inbetween.sql and also in lang/subquery.sql.  So I did not add any new test cases with my changes.  Is there anything in particular you think could be problematic here?&lt;/p&gt;

&lt;p&gt;&amp;gt;    Does such a query generate and use the new style Multi-Probe processing?&lt;/p&gt;

&lt;p&gt;No, it does not.  Multi-probe processing only occurs if the IN-list is solely comprised of constant and/or parameter nodes.  A subquery is neither constant nor parameter, hence no multi-probing will occur.  The code for this is in the preprocess() method of InListOperatorNode:&lt;/p&gt;

&lt;p&gt;   else if ((leftOperand instanceof ColumnReference) &amp;amp;&amp;amp;&lt;br/&gt;
     rightOperandList.containsOnlyConstantAndParamNodes())&lt;/p&gt;
   {
        &amp;lt;create probe predicate&amp;gt;
    }

&lt;p&gt;&amp;gt; 3) Do you have any test cases in which the IN-list predicate references a&lt;br/&gt;
&amp;gt;    column in a UNION or a UNION view, thus requiring pushing the IN-list&lt;br/&gt;
&amp;gt;    predicate down and pulling it back up?&lt;/p&gt;

&lt;p&gt;I added a few, simplified test queries for this situation to lang/inbetween.sql as part of d47_mp_addlTestCases.patch (under the heading &quot;Nested queries with unions and top-level IN list&quot;).  There are also a handful of queries in lang/predicatePushdown.sql that include IN lists in addition to equality predicates.  Feel free to comment if you think more testing should be done here...&lt;/p&gt;

&lt;p&gt;&amp;gt; 4) In the change to OrNode.java, my eye was caught by the variable name &quot;beon&quot;.&lt;br/&gt;
&amp;gt;    I&apos;ve seen that a common convention is to use an acronym, so maybe &quot;beon&quot;&lt;br/&gt;
&amp;gt;    stood for Binary Equality Operator Node, or something like that, but the&lt;br/&gt;
&amp;gt;    actual datatype is Binary*Relational*OperatorNode, so I would have&lt;br/&gt;
&amp;gt;    expected to see a variable &quot;bron&quot;.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    BinaryRelationalOperatorNode beon = null;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    It&apos;s totally unimportant, but I saw it and thought I&apos;d mention it.&lt;/p&gt;

&lt;p&gt;Oops, good catch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Just a typo, I will try to fix this up.&lt;/p&gt;

&lt;p&gt;&amp;gt; 5) I looked at the updated masters; to my eye they show that the new probe&lt;br/&gt;
&amp;gt;    predicate is working, and the optimizer is choosing to use index-to-base&lt;br/&gt;
&amp;gt;    processing for these predicates rather than the formerly-chosen table&lt;br/&gt;
&amp;gt;    scans, so this looks great to me.&lt;/p&gt;

&lt;p&gt;Thank you for taking a look at these--this was an unexpected but very welcome review!&lt;/p&gt;

&lt;p&gt;&amp;gt; 7) For some reason, I expected to see something more vivid indicating the&lt;br/&gt;
&amp;gt;    use of the new execution strategy in the query plans, I thought maybe I&apos;d&lt;br/&gt;
&amp;gt;    see something like &quot;MultiProbeTableScanResultSet&quot; in query dumps? Is it&lt;br/&gt;
&amp;gt;    just these tests that don&apos;t show that, and other query dumps would? &lt;/p&gt;

&lt;p&gt;This had occurred to me, as well, but then I realized that in all of the test cases the MultiProbingTableScanResultSet shows up as the child of an IndexToBaseRowResultSet, which I think means it doesn&apos;t actually get printed in the query plans (only the info for the IndexToBaseRowResultSet is printed).  This is simliar, I think, to BulkTableScanResultSet, which is not printed in query plans, either (I don&apos;t think...I believe the only way to tell is by looking at the fetch size).&lt;/p&gt;

&lt;p&gt;&amp;gt; Or is the only indication that the new probing code has been chosen the&lt;br/&gt;
&amp;gt; use of the index in place of the table scan?&lt;/p&gt;

&lt;p&gt;Right now I think the only way to tell is to look at the use of index &lt;b&gt;and&lt;/b&gt; the number of rows visited/qualified: if we used an index but did not do multi-probing, we will probably see far more rows visited than if we used multi-probing (that won&apos;t always be the case, but is generally true).  Perhaps work to add an explicit indication of multi-probing to the query plan can be handled as a separate enhancement?&lt;/p&gt;

&lt;p&gt;These are great observations and great questions--thank you for posing them!  And if you have any others, please continue to ask.  I&apos;m definitely grateful for the feedback...&lt;/p&gt;</comment>
                            <comment id="12480562" author="mikem" created="Tue, 13 Mar 2007 22:10:43 +0000"  >&lt;p&gt;I took a look at the diffs in readlocks and I believe all are &quot;correct&quot; with respect to your changes.  It looks to me like there is an existing bug not affected by your code, see case 6 below.  The readlocks test runs the same set of tests through multiple &lt;br/&gt;
setups varying isolation level, rows size and unique vs. non-unique index.  In all cases the diffs you are seeing are due to &lt;br/&gt;
a test of locks gotten from walking a cursor down the result set from: select a from a where a = 5 or a = 7&apos; .  As described it is expected that you IN logic change should apply to this query when there is an index on a.  I have described what I think is happening in the diffs below, diff line numbers come from applying your master patch to a current codeline and then running svn diff.  &lt;/p&gt;

&lt;p&gt;Diff line notation is from a svn diff after applying the master patch&lt;br/&gt;
posted to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1) diff lines:4946,7 +4946,7 @@^M&lt;br/&gt;
    o diff ok&lt;br/&gt;
    o before change first next would bulk load all rows leaving a &quot;scan lock&quot;&lt;br/&gt;
      on the last page (3,1).   Now on first next code does a probe for the&lt;br/&gt;
      5 from the (a=5 or a=7), so first lock query shows scan lock on (2,1)&lt;br/&gt;
      associated with 5.  There are no real row locks as this is read&lt;br/&gt;
      uncommitted test.&lt;/p&gt;

&lt;p&gt;2) @@ -8103,6 +8103,7 @@^M&lt;br/&gt;
   @@ -8112,6 +8113,7 @@^M&lt;br/&gt;
    o diff ok, shows 1 more row lock after each next in an expected OR case&lt;br/&gt;
    o before change first next would bulk load all rows and by time lock&lt;br/&gt;
      query is executed all locks would be released due to read committed.&lt;br/&gt;
      Now because of probing we only get locks as we probe each value and&lt;br/&gt;
      test shows lock is held during next call and then released when we&lt;br/&gt;
      next to the next value.&lt;/p&gt;

&lt;p&gt;3) @@ -8956,6 +8958,7 @@^M&lt;br/&gt;
   @@ -8965,6 +8968,7 @@^M&lt;br/&gt;
   o diff ok, same reasoning as 2&lt;/p&gt;

&lt;p&gt;4) @@ -11255,7 +11259,8 @@^&lt;br/&gt;
   @@ -11265,6 +11270,7 @@^M&lt;br/&gt;
   o diff ok, same reasoning as 2 - row numbers are different from 2 because&lt;br/&gt;
     of different padding in test table.&lt;/p&gt;

&lt;p&gt;5) @@ -12101,6 +12107,7 @@^M&lt;br/&gt;
   @@ -12110,6 +12117,7 @@^M&lt;br/&gt;
   o diff ok, same reasoning as 4&lt;/p&gt;

&lt;p&gt;6) @@ -14746,7 +14754,6 @@^M&lt;br/&gt;
   o I think there is a bug in existing code, the incremental diff looks ok.&lt;br/&gt;
   o there should not be any locks left after the scan_cursor is closed in&lt;br/&gt;
     read committed but there at line 14762 of original test.&lt;/p&gt;

&lt;p&gt;7) @@ -15752,7 +15759,6 @@^M&lt;br/&gt;
   o same as 6&lt;/p&gt;

&lt;p&gt;8) @@ -18421,9 +18427,8 @@^M&lt;/p&gt;

&lt;p&gt;   o same as 6&lt;/p&gt;

&lt;p&gt;9) @@ -19421,7 +19426,6 @@^M&lt;br/&gt;
   o same as 6&lt;/p&gt;

&lt;p&gt;10) @@ -21779,8 +21783,6 @@^M]&lt;br/&gt;
   o diff ok!!&lt;br/&gt;
   o this is a good test that shows that the new code only visits the 2 rows&lt;br/&gt;
     of the or clause and does not get locks on any other rows under&lt;br/&gt;
     serializable with a unique index.&lt;br/&gt;
     Old change shows it scaning the range an unnecessarily&lt;br/&gt;
     locking an extra row.&lt;/p&gt;

&lt;p&gt;11) @@ -21791,7 +21793,6 @@^M&lt;br/&gt;
   o diff ok&lt;br/&gt;
   o same as 10&lt;/p&gt;

&lt;p&gt;12) @@ -21799,7 +21800,6 @@^&lt;br/&gt;
   o diff ok&lt;br/&gt;
   o same as 10&lt;/p&gt;

&lt;p&gt;13) @@ -22639,8 +22639,6 @@^M&lt;br/&gt;
   o diff ok&lt;br/&gt;
   o not as good a test as 10.  Because of previous key locking and the very&lt;br/&gt;
     small data set both before and after we lock the same number of rows.&lt;br/&gt;
     Diff does show difference in processing between before and after.  If&lt;br/&gt;
     there had been more than one row between 5 and 7 with the non-unique&lt;br/&gt;
     index it would have shown less rows locked under new code vs. old code.&lt;br/&gt;
     Adding a test for &quot;IN(1, 7)&quot; would show this off.  If you are going to&lt;br/&gt;
     add new test I would suggest checking in current set of diffs and then&lt;br/&gt;
     adding separate test  as it is easier to identify diffs from&lt;br/&gt;
     new tests.&lt;/p&gt;

&lt;p&gt;14) @@ -24974,11 +24972,9 @@^M&lt;br/&gt;
    o diff ok&lt;br/&gt;
    o same as 13&lt;/p&gt;

&lt;p&gt;15) @@ -25831,8 +25827,6 @@^M&lt;br/&gt;
    o same as 13&lt;/p&gt;</comment>
                            <comment id="12480617" author="mikem" created="Wed, 14 Mar 2007 00:52:53 +0000"  >&lt;p&gt;In my writeup on the diffs, ignore the comments about there being a possible bug.  I incorrectly thought those cases were&lt;br/&gt;
read committed cases but they actually were repeatable read cases.  I was searching for the wrong string to determine where I was in the test. &lt;/p&gt;

&lt;p&gt;All the diffs look fine and expected with army&apos;s changes.&lt;/p&gt;</comment>
                            <comment id="12480827" author="army" created="Wed, 14 Mar 2007 16:40:29 +0000"  >&lt;p&gt;Thanks again for the &lt;em&gt;excellent&lt;/em&gt; review, Mike.&lt;/p&gt;

&lt;p&gt;Unless I hear otherwise I plan to commit the preprocess patch later today, after incorporating Bryan&apos;s most recent comments.  I will then work on the follow-up patch(es) to address Bryan&apos;s original set of review comments (thanks Bryan!).&lt;/p&gt;

&lt;p&gt;And finally, I will try to add a new test to verify the functional changes.  That said, I was hoping to add a new test to the regression suite based on Derby47PerformanceTest.java as attached to this issue.  However, I just noticed that the attachment does &lt;b&gt;not&lt;/b&gt; grant license to ASF for inclusion in ASF works.&lt;/p&gt;

&lt;p&gt;James Synge, are you willing to grant such rights for the test program that you attached?  If so, can you re-attach the file and check the appropriate box on the &quot;Attach File&quot; screen?&lt;/p&gt;</comment>
                            <comment id="12480861" author="jmsynge" created="Wed, 14 Mar 2007 17:55:00 +0000"  >&lt;p&gt;This is the same as the file I attached on 2006-09-06, but now with the license granted to ASF.&lt;/p&gt;</comment>
                            <comment id="12480929" author="army" created="Wed, 14 Mar 2007 21:00:17 +0000"  >&lt;p&gt;I made some slight modifications to the preprocess patch in accordance with Bryan&apos;s review comments, and then committed with svn #518322:&lt;/p&gt;

&lt;p&gt;   URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=518322&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=518322&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;More specifically, preprocess_v2 differs from preprocess_v1 in that it:&lt;/p&gt;

&lt;p&gt;  1 - Adds a comment to help clarify what happens in the case of an IN-list with a single value in it.&lt;/p&gt;

&lt;p&gt;  2 - Renames &quot;beon&quot; to &quot;bron&quot; in OrNode.java to reflect the fact that it is a BinaryRelationalOperatorNode, not a BinaryEqualityOperatorNode.&lt;/p&gt;

&lt;p&gt;derbyall ran cleanly on Red Hat Linux with ibm142.&lt;/p&gt;

&lt;p&gt;Thanks again to Bryan and Mike for the reviews.&lt;/p&gt;</comment>
                            <comment id="12481675" author="army" created="Fri, 16 Mar 2007 16:34:41 +0000"  >&lt;p&gt;Attaching d47_mp_cleanup_v1.patch, which is a patch to address the review comments made by Bryan on 11/Mar/07 11:37 AM.  In particular this patch does the following:&lt;/p&gt;

&lt;p&gt;  1 - Changes Predicate.isRelationalOpPredicate() so that it just calls&lt;br/&gt;
      the already existing method &quot;isRelationalOperator()&quot; on the left&lt;br/&gt;
      operand of the predicate&apos;s AND node.  I.e.:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return ((getRelop() != null) &amp;amp;&amp;amp; (getSourceInList() == null));&lt;br/&gt;
+	return andNode.getLeftOperand().isRelationalOperator();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;      I completely forgot that the &quot;isRelationalOperator()&quot; method already&lt;br/&gt;
      existed, even though I myself made probe-predicate-based changes to&lt;br/&gt;
      that method as part of d47_mp_relOpPredCheck:&lt;/p&gt;

&lt;p&gt;	public boolean isRelationalOperator()&lt;/p&gt;
	{
-		return true;
+		/* If this rel op is for a probe predicate then we do not call
+		 * it a &quot;relational operator&quot;; it&apos;s actually a disguised IN-list
+		 * operator.
+		 */
+		return (inListProbeSource == null);
+	}

&lt;p&gt;      As a result of those changes we can now just call that method when&lt;br/&gt;
      checking to see if a predicate is a relational op predicate.  This&lt;br/&gt;
      ultimately comes down to a simple check for a null variable in&lt;br/&gt;
      BinaryRelationalOperatorNode, as seen above.&lt;/p&gt;

&lt;p&gt;      I believe this change addresses Bryan&apos;s comment #7, which pointed&lt;br/&gt;
      out that the old code:&lt;/p&gt;

&lt;p&gt;		return ((getRelop() != null) &amp;amp;&amp;amp; (getSourceInList() == null));&lt;/p&gt;

&lt;p&gt;      seemed a tad expensive since it was replacing a simple call to&lt;br/&gt;
      &quot;relop != null&quot;.  The new code (with this patch) is much more&lt;br/&gt;
      comparable to the &quot;relop != null&quot; check in terms of &quot;work&quot; that&lt;br/&gt;
      it does (we have an additional call to getLeftOperand(), but&lt;br/&gt;
      that&apos;s about it).&lt;/p&gt;

&lt;p&gt;  2 - Inspired by the &quot;isRelationalOperator()&quot; method defined in ValueNode&lt;br/&gt;
      and used above, I added a similar method, &quot;isInListProbeNode()&quot;,&lt;br/&gt;
      to ValueNode, as well.  The default case returns &quot;false&quot;, while&lt;br/&gt;
      BinaryRelationalOperatorNode returns true if it has a source IN-&lt;br/&gt;
      list associated with it:&lt;/p&gt;

&lt;p&gt;+	/** @see ValueNode#isInListProbeNode */&lt;br/&gt;
+	public boolean isInListProbeNode()&lt;br/&gt;
+	&lt;/p&gt;
{
+		return (inListProbeSource != null);
+	}

&lt;p&gt;      Then I added a corresponding method called &quot;isInListProbePredicate()&quot;&lt;br/&gt;
      to Predicate.java.  This method allows for simple (and relatively&lt;br/&gt;
      cheap) checking of a predicate to see if it is an IN-list probe&lt;br/&gt;
      predicate.  There are several places in the code where we would&lt;br/&gt;
      attempt to retrieve the underlying source IN-list (via a call to&lt;br/&gt;
      &quot;getSourceInList()&quot;) just to see if it was non-null.  All of those&lt;br/&gt;
      occurrences have now been replaced by a call to the new method on&lt;br/&gt;
      Predicate.java.  I think this is a cleaner and cheaper way to&lt;br/&gt;
      go about it.&lt;/p&gt;

&lt;p&gt;  3 - Modifies Predicate.getSourceInList() to return the underlying&lt;br/&gt;
      InListOperatorNode for probe predicates AND for &quot;normal&quot;&lt;br/&gt;
      IN-list predicates (i.e. an IN-list that could not be&lt;br/&gt;
      transformed into a &quot;probe predicate&quot; because it contains&lt;br/&gt;
      one or more non-parameter, non-constant values)&lt;/p&gt;

&lt;p&gt;      This then allowed for some cleanup of the code mentioned in&lt;br/&gt;
      Bryan&apos;s comment #2.  Some of the logic for that code was&lt;br/&gt;
      specifically targeted for the old rewrite algorithm (use&lt;br/&gt;
      of a BETWEEN operator), so I fixed it up and added comments&lt;br/&gt;
      as I felt appropriate.&lt;/p&gt;

&lt;p&gt;      I also added a second version of getSourceInList() that takes a&lt;br/&gt;
      boolean argument; if true, then it will only return the source&lt;br/&gt;
      IN list for a predicate &lt;b&gt;if&lt;/b&gt; that predicate is an IN-list&lt;br/&gt;
      probe predicate.&lt;/p&gt;

&lt;p&gt;  4 - Changes PredicateList.generateInListValues() to account for the&lt;br/&gt;
      fact that it only ever gets called when we know that there is&lt;br/&gt;
      a probe predicate in the list.  This addresses Bryan&apos;s review&lt;br/&gt;
      comment #3.&lt;/p&gt;

&lt;p&gt;  5 - Shortens a couple of lines in FromBaseTable that were added with&lt;br/&gt;
      earlier patches but were longer than 80 chars.  Also rewrites&lt;br/&gt;
      one Sanity check in that class to avoid construction of strings&lt;br/&gt;
      when no error occurs (per recent discussions on derby-dev).&lt;/p&gt;

&lt;p&gt;I ran derybyall and suites.All with ibm142 on Red Hat Linux with no new failures.  Feedback or further review of these changes is appreciated.  I&apos;ll plan to commit on Monday if I don&apos;t hear any objections.&lt;/p&gt;

&lt;p&gt;Many many thanks again to Bryan for his time and suggestions!&lt;/p&gt;</comment>
                            <comment id="12481760" author="bryanpendleton" created="Fri, 16 Mar 2007 21:02:19 +0000"  >&lt;p&gt;Thanks for all the attention to detail, Army! The mp_cleanup_v1 patch looks very clean to me.&lt;/p&gt;</comment>
                            <comment id="12481793" author="army" created="Sat, 17 Mar 2007 00:05:15 +0000"  >&lt;p&gt;Thank you for the review of the cleanup patch, Bryan!  I will continue with my plan to commit that patch before the end of day on Monday if no other comments come in.&lt;/p&gt;

&lt;p&gt;I&apos;m also attaching here a (final?) patch for this issue: d47_mp_junitTest_v1.patch, which creates a new JUnit test based on the repro program attached to this issue (thanks James Synge!).  The test creates the same kind of table and data that Derby47PerformanceTest.java creates, and then runs three types of queries with larger and larger IN lists.  The three types of queries are:&lt;/p&gt;

&lt;p&gt;  1 - &quot;Markers&quot; : same as in James&apos; program&lt;br/&gt;
  2 - &quot;Literals&quot; : same as in James&apos; program&lt;br/&gt;
  3 - &apos;MixedIds&quot;: IN list has a combination of parameter markers and literals.&lt;/p&gt;

&lt;p&gt;For each query we check to make sure the results are correct and then we look at the query plan to determine whether or not the optimizer chose to do multi-probing.  If the results are incorrect or if the optimizer did &lt;b&gt;not&lt;/b&gt; choose multi-probing then the test will fail.&lt;/p&gt;

&lt;p&gt;The test determines that &quot;multi-probing&quot; was in effect by looking at the query plan and verifying two things:&lt;/p&gt;

&lt;p&gt;  1. We did an index scan on the target table AND&lt;/p&gt;

&lt;p&gt;  2. The number of rows that &quot;qualified&quot; is equal to the number of rows that were actually returned for the query.  If we did &lt;b&gt;not&lt;/b&gt; do multi-probing then we would scan all or part of the index and then apply the IN-list restriction after reading the rows.  That means that the number of rows &quot;qualified&quot; for the scan would be greater than the number of rows returned from the query.  But if we do multi-probing we will just probe for rows that we know satsify the restriction, thus the number of rows that we &quot;fetch&quot; for the scan (i.e. &quot;rows qualified&quot;) should exactly match the number of rows in the result set.&lt;/p&gt;

&lt;p&gt;I ran the new test using ibm142, ibm15, jdk142, jdk15, jdk16, and weme6.1 and it passed in all cases.&lt;/p&gt;

&lt;p&gt;I also ran the new test against a build that I created before any of the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes were committed; as expected, the test failed because even though the optimizer did chose to use an index, it scanned a lot (thousands) of extra rows for that index.&lt;/p&gt;

&lt;p&gt;Any reviews/comments on the this new JUnit test are very much welcomed.  In the absence of any feedback to the contrary, I&apos;m thinking I&apos;ll commit this new test by the end of Monday, as well.  And of course, comments/suggestions can still be made after that, if needed...&lt;/p&gt;</comment>
                            <comment id="12481865" author="bryanpendleton" created="Sat, 17 Mar 2007 15:38:59 +0000"  >&lt;p&gt;InListMultiProbeTest applied and built and passed in my environment. Looks good!&lt;/p&gt;</comment>
                            <comment id="12482283" author="army" created="Tue, 20 Mar 2007 00:26:38 +0000"  >&lt;p&gt;Thank you, Bryan, for taking a look at the new JUnit test and for verifying that it runs.&lt;/p&gt;

&lt;p&gt;I committed the cleanup patch and the new JUnit tests with the following svn commits (respectively):&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=520188&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=520188&lt;/a&gt;&lt;br/&gt;
  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=520191&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=520191&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m marking the issue as &quot;Resolved&quot; in 10.3 since I believe this wraps up the changes for this issue.  I plan to run some (simple) before-and-after numbers and post them tomorrow.&lt;/p&gt;

&lt;p&gt;I will wait a few days to check for fallout and then I will close or re-open this issue accordingly.&lt;/p&gt;

&lt;p&gt;For any of the people &quot;watching&quot; this issue, if you are willing and able to sync up with the latest trunk for &lt;b&gt;testing&lt;/b&gt; only (do &lt;b&gt;not&lt;/b&gt; use the trunk in production, nor on production databases!) and provide feedback on whether or not the changes for this issue address your concerns, that&apos;d be great.  If you are still experiencing problems even after these changes, you may need to file one or more additional Jira issues to address those specific problems.  As it is, I think the work for this specific Jira issue is pretty much &quot;done&quot;...&lt;/p&gt;

&lt;p&gt;Follow-up comments and feedback are of course always-&lt;del&gt;and greatly&lt;/del&gt;-welcomed.&lt;/p&gt;</comment>
                            <comment id="12482614" author="army" created="Tue, 20 Mar 2007 23:58:24 +0000"  >&lt;p&gt;Attaching a very simple document with some straightforward &quot;before-and-after&quot; measurements based on the Derby47PerformanceTest attached to this issue.  I wrote this document pretty quickly so it&apos;s not very elegant, but it does show the improvement that I see from the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; changes.  Here&apos;s the conclusion, pasted from the document:&lt;/p&gt;

&lt;p&gt;&amp;lt;begin paste&amp;gt;&lt;/p&gt;

&lt;p&gt;Conclusion:&lt;/p&gt;

&lt;p&gt;From a &quot;multi-probing&quot; perspective these numbers show what we expect: namely, that we can save a lot of time by selectively probing an index for a list of values instead of scanning all (or large parts) of that index for a relatively small number of rows.&lt;/p&gt;

&lt;p&gt;But there are a couple of areas that could use follow-up work.  In particular:&lt;/p&gt;

&lt;p&gt;   1. As seen in this document, the compilation/optimization time for &quot;Literals&quot; is far larger than it is for &quot;Markers&quot;.  Since the &quot;probe predicate&quot; optimization in theory applies the same to both strategies, further investigation is needed to figure out what it is about &quot;Literals&quot; that makes for such a long compilation time.  I do not currently have any theories as to what could be at the root of this.  Note, though, that this relatively excessive compilation time was an issue even before the changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; were committed.&lt;/p&gt;

&lt;p&gt;   2. Not surprisingly, the costing logic for probing as implemented in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; is not perfect.  It works great in situations where the IN list is significantly smaller than the number of rows in the table--ex. we see good results for 100k rows.  However, I discovered that if we just run with 10,000 rows, then once we hit 1,000 values in the IN list the costing of probe predicates causes the optimizer to think that it would be too expensive, so it (the optimizer) ends up doing a table scan.  In truth the table scan is still far slower than index probing, but the relative size of the IN list with respect to the number of rows in the table throws the costing off.  To confirm this I just removed the probing cost logic (so that it effectively becomes the cost of a single &quot;col = ?&quot; predicate) and then the optimizer chose to do index probing for the 10,000 row scenario, which was much, much faster (as expected).&lt;/p&gt;

&lt;p&gt;My feeling is that any work related to investigation/resolution of these two issues can and should be completed as part of a new Jira...&lt;br/&gt;
&amp;lt;end paste&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12482797" author="army" created="Wed, 21 Mar 2007 15:22:53 +0000"  >&lt;p&gt;Updated copy of the before-and-after numbers.  This one actually tells what the numbers in the tables mean &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12483010" author="bryanpendleton" created="Thu, 22 Mar 2007 04:39:56 +0000"  >&lt;p&gt;Thanks for posting the measurement analysis, Army; it&apos;s good to see the numbers backing up&lt;br/&gt;
the results we hoped to see.&lt;/p&gt;

&lt;p&gt;I agree that the two follow-up issues that you uncovered should be logged and pursued separately.&lt;/p&gt;</comment>
                            <comment id="12484620" author="scotsmatrix" created="Tue, 27 Mar 2007 23:09:48 +0100"  >&lt;p&gt;Army - Just FYI &lt;br/&gt;
In the Tuning Guide, the IN operator is mentioned in the optimization and query sections, as shown below:&lt;/p&gt;

&lt;p&gt;DML statements and performance&lt;br/&gt;
      Performance and optimization&lt;br/&gt;
             Index use and access paths&lt;br/&gt;
             Joins and performance&lt;br/&gt;
             Derby&apos;s cost-based optimization&lt;br/&gt;
      Locking and performance&lt;br/&gt;
      Non-cost-based optimizations&lt;br/&gt;
             Non-cost-based sort avoidance (tuple filtering)&lt;br/&gt;
             The MIN() and MAX() optimizations&lt;br/&gt;
             Overriding the default optimizer behavior&lt;/p&gt;

&lt;p&gt;Internal language transformations&lt;br/&gt;
       Predicate transformations&lt;br/&gt;
              Static IN predicate transformations&lt;br/&gt;
      Subquery processing and transformations&lt;br/&gt;
               DISTINCT elimination in IN, ANY, and EXISTS subqueries&lt;br/&gt;
               IN/ANY subquery transformation&lt;/p&gt;

&lt;p&gt;It is not clear to me if the Optimization section needs to be updated with any info about improvements to the IN optimization.&lt;br/&gt;
But I wanted to provide you with this info so that you can decide.&lt;/p&gt;</comment>
                            <comment id="12484985" author="fuzzylogic" created="Wed, 28 Mar 2007 21:48:36 +0100"  >&lt;p&gt;Hi Army, I just checked in a converted JUnit test for the old distinct.sql. All the fixtures in the test had been working, until I updated to get the new RuntimeStatisticsParser so I could use it in the test, and then one fixture started failing with an ASSERT related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;. I was hoping if you have some spare time that you might be able to take a look at it and see if you can figure out what&apos;s going on a little quicker than I. Look for and uncomment the testResultSetInOrderWhenUsingIndex() in the new DistinctTest class. Pardon the confusing name, its taken directly from the comment that proceeds the old test in the .sql file, so I kept it as the method name for the test fixture.&lt;/p&gt;

&lt;p&gt;The really confusing thing to me is why the identical &apos;prepare as ...&apos; with an identical select statement isn&apos;t getting the assert when the .sql test is running under the old harness. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I&apos;ve probably just missed something subtle from the old test, and maybe another pair of eyes will help me spot what that is. &lt;/p&gt;</comment>
                            <comment id="12484994" author="army" created="Wed, 28 Mar 2007 22:22:47 +0100"  >&lt;p&gt;Hi Andrew,&lt;/p&gt;

&lt;p&gt;Thank you for reporting this!  My guess is that the difference between the JUnit test and the old distinct.sql is the specification of certain properties for the old test--namely:&lt;/p&gt;

&lt;p&gt;  derby.optimizer.optimizeJoinOrder=false&lt;br/&gt;
  derby.optimizer.noTimeout=true&lt;br/&gt;
  derby.optimizer.ruleBasedOptimization=true&lt;/p&gt;

&lt;p&gt;When I specified these three properties on the command line for the JUnit test, all fixtures ran as expected.  I then narrowed the failure that you&apos;re seeing down to the &quot;optimizeJoinOrder&quot; property: if it&apos;s not specified--i.e. if optimization of join orders occurs &quot;as normal&quot;, the test fails.  It only passes if optimizeJoinOrder is false.&lt;/p&gt;

&lt;p&gt;So that&apos;s good news for you--you know why the problem is occuring.  And I think it means you found a bug somewhere with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, too...so thank you!&lt;/p&gt;

&lt;p&gt;I will look into this...&lt;/p&gt;</comment>
                            <comment id="12485002" author="fuzzylogic" created="Wed, 28 Mar 2007 22:49:35 +0100"  >&lt;p&gt;Hah! I had already deleted all the properties files for the old tests in my client so it didn&apos;t occur to me to look there. A fortunate oversight, then, I suppose.&lt;/p&gt;

&lt;p&gt;Two questions then&lt;/p&gt;

&lt;p&gt;1. shall I open a new issue for the test failure? If so, I&apos;ll be glad to, or we can roll it in to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2491&quot; title=&quot;Convert distinct.sql to JUnit&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2491&quot;&gt;&lt;del&gt;DERBY-2491&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;2. should I add the other two properties to the new test run? Adding the noTimeout flag doesn&apos;t significantly increase the amount of time the test takes to run. I&apos;m not clear on what the ruleBasedOptimization flag does. Does that instruct the optimizer to not attempt the normal cost-based optimization and only do some rule-based optimization? The test runs (and passes) in a normal amount of time with or without this property set and noTimeout = true.&lt;/p&gt;</comment>
                            <comment id="12485008" author="army" created="Wed, 28 Mar 2007 23:04:05 +0100"  >&lt;p&gt;&amp;gt; 1. shall I open a new issue for the test failure?&lt;/p&gt;

&lt;p&gt;Yes, I think that&apos;d be good.  Note though that this is an actual engine bug, not just a test problem.  So it&apos;d be good to make that clear in the new issue.  The test case can serve as a repro for the engine bug.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2. should I add the other two properties to the new test run?&lt;/p&gt;

&lt;p&gt;First I should mention that the full list of properties for this test includes:&lt;/p&gt;

&lt;p&gt;  derby.infolog.append=true&lt;br/&gt;
  derby.optimizer.optimizeJoinOrder=false&lt;br/&gt;
  derby.optimizer.noTimeout=true&lt;br/&gt;
  derby.optimizer.ruleBasedOptimization=true&lt;br/&gt;
  derby.language.statementCacheSize=1000&lt;/p&gt;

&lt;p&gt;As for which of these are required, ummm....I don&apos;t know.  My assumption is that the properties were added for specific reasons, but without corresponding comments it&apos;s hard to tell.   Generally speaking any test for which we need to verify all or part of a query plan uses &quot;noTimeout=true&quot; to ensure that we get the same plan regardless of platform or machine speed.  So it might be worth it to keep that one.  But it&apos;ll have to be your call for the rest of them...&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m not clear on what the ruleBasedOptimization flag does. Does that instruct the optimizer to not attempt the normal&lt;br/&gt;
&amp;gt; cost-based optimization and only do some rule-based optimization?&lt;/p&gt;

&lt;p&gt;Yes, that&apos;s exactly what it does.  But that said, I know practically nothing about rule-based optimization, and I don&apos;t know why that particular property was added for the old distinct.sql test.  Maybe you can do some investigating there to figure it out....and if not...well, like I said, it&apos;s your call &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12485028" author="fuzzylogic" created="Thu, 29 Mar 2007 00:33:31 +0100"  >&lt;p&gt;Army&amp;gt; Note though that this is an actual engine bug, not just a test problem. So it&apos;d be good to make that clear in the new issue. &lt;/p&gt;

&lt;p&gt;Agreed. I have a (bad?) tendency to overload JIRA issues by fixing everything that comes along whilst working on that one issue. Opened &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2500&quot; title=&quot;Assertion failure preparing query with AND and OR in where clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2500&quot;&gt;&lt;del&gt;DERBY-2500&lt;/del&gt;&lt;/a&gt; for this new one.&lt;/p&gt;

&lt;p&gt;As for the other properties you listed, I can&apos;t see how any of those would affect how the test runs, with the exception of noTimeout and ruleBasedOptimization, since they might affect the query plans in the runtime statistics. But, since the tests complete in a reasonable amount of time with noTimeout=true I&apos;ll leave that in, and since all the tests pass with or without ruleBasedOptimization set to true, I&apos;ll leave that off. Not really worth investigating, since it seems to have no effect on the new test.&lt;/p&gt;
</comment>
                            <comment id="12487826" author="army" created="Tue, 10 Apr 2007 18:05:17 +0100"  >&lt;p&gt;The issue filed by Andrew (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2500&quot; title=&quot;Assertion failure preparing query with AND and OR in where clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2500&quot;&gt;&lt;del&gt;DERBY-2500&lt;/del&gt;&lt;/a&gt;) has been resolved with no apparent fallout.  I have also filed several Jiras for follow-up enhancements that can be done in the future, namely &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2482&quot; title=&quot;Improve optimizer costing for &amp;quot;probe predicates&amp;quot; so that index multi-probing is more likely to occur.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2482&quot;&gt;DERBY-2482&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2483&quot; title=&quot;Reduce compilation time for queries with large IN lists made up of literals.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2483&quot;&gt;DERBY-2483&lt;/a&gt;, and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2503&quot; title=&quot;Implement IN-list multi-probing logic for hash joins.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2503&quot;&gt;DERBY-2503&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As I have not heard anything (good nor bad) from the people &quot;watching&quot; this issue, and since other Jiras exist for related work, I think we should be able to close this issue now.&lt;/p&gt;

&lt;p&gt;Sunitha, if you agree can you mark this Jira as closed?&lt;/p&gt;</comment>
                            <comment id="12487841" author="skambha" created="Tue, 10 Apr 2007 18:44:55 +0100"  >&lt;p&gt;Thanks Army for all your great work on this.   Closing this issue now. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10020">
                    <name>Cloners</name>
                                                                <inwardlinks description="is cloned by">
                                        <issuelink>
            <issuekey id="12325761">DERBY-713</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12377755">DERBY-3061</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12366071">DERBY-2500</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12370654">DERBY-2740</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12383938">DERBY-3253</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12384686">DERBY-3279</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12628077">DERBY-6045</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12649208">DERBY-6226</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12762434">DERBY-6784</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12435691">DERBY-4376</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12353309" name="Derby47PerformanceTest.java" size="39220" author="jmsynge" created="Wed, 14 Mar 2007 17:55:00 +0000"/>
                            <attachment id="12340270" name="Derby47PerformanceTest.java" size="39220" author="jmsynge" created="Wed, 6 Sep 2006 15:52:58 +0100"/>
                            <attachment id="12340205" name="Derby47PerformanceTest.java" size="32649" author="jmsynge" created="Tue, 5 Sep 2006 18:30:34 +0100"/>
                            <attachment id="12347581" name="InListOperatorNode.java" size="24687" author="jmsynge" created="Wed, 20 Dec 2006 16:34:28 +0000"/>
                            <attachment id="12320702" name="QueryPlanUniqueIndexAndWordIndexOneTerm.txt" size="3384" author="kevinhore" created="Wed, 16 Nov 2005 00:30:58 +0000"/>
                            <attachment id="12320703" name="QueryPlanUniqueIndexAndWordIndexTwoTerms.txt" size="3975" author="kevinhore" created="Wed, 16 Nov 2005 00:31:37 +0000"/>
                            <attachment id="12320704" name="QueryPlanUniqueIndexOnlyOneTerm.txt" size="2811" author="kevinhore" created="Wed, 16 Nov 2005 00:32:37 +0000"/>
                            <attachment id="12320705" name="QueryPlanUniqueIndexOnlyTwoTerms.txt" size="3465" author="kevinhore" created="Wed, 16 Nov 2005 00:33:03 +0000"/>
                            <attachment id="12353854" name="d47_beforeAndAfter.html" size="115014" author="army" created="Wed, 21 Mar 2007 15:22:53 +0000"/>
                            <attachment id="12353802" name="d47_beforeAndAfter.html" size="114352" author="army" created="Tue, 20 Mar 2007 23:58:24 +0000"/>
                            <attachment id="12349480" name="d47_engine_doNotCommit_v1.patch" size="69161" author="army" created="Wed, 24 Jan 2007 00:36:47 +0000"/>
                            <attachment id="12349481" name="d47_engine_doNotCommit_v1.stat" size="1676" author="army" created="Wed, 24 Jan 2007 00:36:47 +0000"/>
                            <attachment id="12352071" name="d47_mp_CBO_MoAP_v1.patch" size="9938" author="army" created="Tue, 27 Feb 2007 00:04:56 +0000"/>
                            <attachment id="12352072" name="d47_mp_CBO_MoAP_v1.stat" size="215" author="army" created="Tue, 27 Feb 2007 00:04:56 +0000"/>
                            <attachment id="12352193" name="d47_mp_addlTestCases.patch" size="37572" author="army" created="Wed, 28 Feb 2007 01:01:21 +0000"/>
                            <attachment id="12353518" name="d47_mp_cleanup_v1.patch" size="17480" author="army" created="Fri, 16 Mar 2007 16:34:41 +0000"/>
                            <attachment id="12353519" name="d47_mp_cleanup_v1.stat" size="598" author="army" created="Fri, 16 Mar 2007 16:34:41 +0000"/>
                            <attachment id="12352685" name="d47_mp_codeGen_v1.patch" size="28168" author="army" created="Mon, 5 Mar 2007 23:45:17 +0000"/>
                            <attachment id="12352686" name="d47_mp_codeGen_v1.stat" size="901" author="army" created="Mon, 5 Mar 2007 23:45:17 +0000"/>
                            <attachment id="12352865" name="d47_mp_exec_v1.patch" size="23864" author="army" created="Wed, 7 Mar 2007 22:16:04 +0000"/>
                            <attachment id="12352866" name="d47_mp_exec_v1.stat" size="379" author="army" created="Wed, 7 Mar 2007 22:16:04 +0000"/>
                            <attachment id="12353556" name="d47_mp_junitTest_v1.patch" size="32603" author="army" created="Sat, 17 Mar 2007 00:05:14 +0000"/>
                            <attachment id="12353151" name="d47_mp_masters_v1.patch" size="60401" author="army" created="Tue, 13 Mar 2007 00:03:43 +0000"/>
                            <attachment id="12353150" name="d47_mp_preprocess_v1.patch" size="18369" author="army" created="Tue, 13 Mar 2007 00:03:43 +0000"/>
                            <attachment id="12353152" name="d47_mp_preprocess_v1.stat" size="857" author="army" created="Tue, 13 Mar 2007 00:03:43 +0000"/>
                            <attachment id="12353319" name="d47_mp_preprocess_v2.patch" size="20277" author="army" created="Wed, 14 Mar 2007 21:00:16 +0000"/>
                            <attachment id="12351823" name="d47_mp_relOpPredCheck_v1.patch" size="9217" author="army" created="Thu, 22 Feb 2007 16:39:45 +0000"/>
                            <attachment id="12351824" name="d47_mp_relOpPredCheck_v1.stat" size="230" author="army" created="Thu, 22 Feb 2007 16:39:45 +0000"/>
                            <attachment id="12340269" name="derby-47-performance-data.txt" size="3739" author="jmsynge" created="Wed, 6 Sep 2006 15:52:58 +0100"/>
                            <attachment id="12340206" name="derby-47-performance-data.txt" size="4300" author="jmsynge" created="Tue, 5 Sep 2006 18:31:34 +0100"/>
                            <attachment id="12349483" name="readlocks.diff" size="15587" author="army" created="Wed, 24 Jan 2007 00:53:42 +0000"/>
                            <attachment id="12353203" name="readlocks_withContext.diff" size="35324" author="army" created="Tue, 13 Mar 2007 15:55:39 +0000"/>
                            <attachment id="12349552" name="readlocks_withContext.diff" size="44485" author="army" created="Wed, 24 Jan 2007 22:12:46 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12366043">DERBY-2499</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>33.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 15 Nov 2005 01:02:44 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29371</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0rsn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38321</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>