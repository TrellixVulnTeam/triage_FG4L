<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:44:34 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1539/DERBY-1539.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1539] A  trigger should be dropped when a privilege required by the trigger is revoked.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1539</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;A trigger tracks its privileges requirements using Derby&apos;s Dependency Manager. If any one of those required privileges are revoked, the trigger should be dropped automatically. &lt;/p&gt;

&lt;p&gt;I am just creating a new jira entry here so it is easier to track sub items of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1330&quot; title=&quot;Provide runtime privilege checking for grant/revoke functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1330&quot;&gt;&lt;del&gt;DERBY-1330&lt;/del&gt;&lt;/a&gt;. Will link this Jira entry to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1330&quot; title=&quot;Provide runtime privilege checking for grant/revoke functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1330&quot;&gt;&lt;del&gt;DERBY-1330&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See the functional spec attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1330&quot; title=&quot;Provide runtime privilege checking for grant/revoke functionality&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1330&quot;&gt;&lt;del&gt;DERBY-1330&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12346301">DERBY-1539</key>
            <summary>A  trigger should be dropped when a privilege required by the trigger is revoked.</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="mamtas">Mamta A. Satoor</reporter>
                        <labels>
                    </labels>
                <created>Wed, 19 Jul 2006 22:48:44 +0100</created>
                <updated>Wed, 1 Jul 2009 01:34:35 +0100</updated>
                            <resolved>Wed, 30 Aug 2006 07:24:37 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12422446" author="mamtas" created="Thu, 20 Jul 2006 17:10:58 +0100"  >&lt;p&gt;This(DERBY1539V1hashCodeEqualsDiff.txt) is a mini patch in preparation for more revoke privilege work that I am still working on. &lt;/p&gt;

&lt;p&gt;PermissionsDescriptor has 2 methods. namely, hashCode and equals. In the initial stages of Grant Revoke functionality, there was no UUID associated with the PermissionsDescriptor and hence these methods did not need to worry about UUID.  But for revoke functionality, dependency manager is going to keep various object dependencies on PermissionsDescriptor using the UUID attached to the PermissionsDescriptor. Hence, when dependency manager works with PermissionsDescriptor, it only knows about UUID and doesn&apos;t know anything about tableUUID/routineUUID and hashCode &amp;amp; equals method need to be able to handle that. On the other hand, during compile state, when privilege requirements are collected for the statement, we only know of tableUUID/routineUUID and nothing about UUID of the PermissionsDescriptor. In order to handle these scenarios, I have made changes to the hashCode and equals method to look for tableUUID!=null or routineUUID!=null.&lt;/p&gt;

&lt;p&gt;I have added an extensive javadoc comment to hashCode method which explains the change in hashCode and equals method. I debated whether this comment should go as regular comment rather than javadoc comment. Let me know if anyone has any opinion about it.&lt;/p&gt;

&lt;p&gt;I am copying the comments from hashCode method here which hopefully will help understand the patch better&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;eg when will if condition below return true?&lt;/li&gt;
	&lt;li&gt;During sql statement execution time, one of the first things that&lt;/li&gt;
	&lt;li&gt;happen is the privilege checking. Every statement has a list of&lt;/li&gt;
	&lt;li&gt;privileges that should exist in order for the statement to execute&lt;/li&gt;
	&lt;li&gt;successfully. That list gets collected during statement compilation&lt;/li&gt;
	&lt;li&gt;time. During execution, the list knows of tableUUID of the table&lt;/li&gt;
	&lt;li&gt;on which the privilege is required but it doesn&apos;t know of the&lt;/li&gt;
	&lt;li&gt;UUID of the privilege. So, the if condition below for tableUUID!=null&lt;/li&gt;
	&lt;li&gt;will be true when privilege checking happens at statement execution&lt;/li&gt;
	&lt;li&gt;time.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;eg when will if condition below return false?&lt;/li&gt;
	&lt;li&gt;When the dependency manager looks for dependents for a permission&lt;/li&gt;
	&lt;li&gt;descriptor, it doesn&apos;t know what is the permission descriptor&apos;s&lt;/li&gt;
	&lt;li&gt;tableUUID but it does know the UUID of the permission descriptor.&lt;/li&gt;
	&lt;li&gt;So, the if condition below for tableUUID!=null will be false when&lt;/li&gt;
	&lt;li&gt;dependency manager is looking for permission descriptor&apos;s dependents.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;There are some instances where tableUUID and UUID are both known.&lt;/li&gt;
	&lt;li&gt;And it doesn&apos;t matter which code path gets picked up below&lt;/li&gt;
	&lt;li&gt;and hence I simply chose the tableUUID!=null as the catch bucket.&lt;/li&gt;
	&lt;li&gt;tableID and UUID will be both known when an existing permission&lt;/li&gt;
	&lt;li&gt;descriptor in the cache needs to be removed from cache because&lt;/li&gt;
	&lt;li&gt;a grant/revoke was issued and that has changed the allowed&lt;/li&gt;
	&lt;li&gt;permissions on the permission descriptor. This happens at the&lt;/li&gt;
	&lt;li&gt;end of DataDictionary.addRemovePermissionsDescriptor method.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Can someone please review this patch and commit if everything looks good? I ran the derbyall last night and it ran fine with no new diffs.&lt;/p&gt;</comment>
                            <comment id="12422643" author="djd" created="Fri, 21 Jul 2006 14:37:25 +0100"  >&lt;p&gt;WIll a Permissions descriptor now change its hashCode during its lifetime? From the code it looks like that&apos;s a possibility.&lt;br/&gt;
I think that is not typical behaviour for objects and will lead to bugs that are hard to track down. Fro example changing the&lt;br/&gt;
hashCode() return while an object is in a cache or hashtable is not supported, the object will become &quot;lost&quot; in the hash table.&lt;/p&gt;</comment>
                            <comment id="12422730" author="mamtas" created="Fri, 21 Jul 2006 18:58:41 +0100"  >&lt;p&gt;I want to start out by saying that this is my first time ever working with hashCode so I am new to this part of the code and hence new to the terminology. Having said that, I debugged through permissions caching and found that Permission Descriptor does not change its hashCode during its lifetime in the cache. I did my debugging for a TablePermissionsDescriptor and same logic should apply to ColPermsDescriptor and RoutinePermsDescriptor.&lt;/p&gt;

&lt;p&gt;Following are more details from debugging&lt;br/&gt;
1)When a statement such as create view is compiled, a list of privileges are collected for it. At this point, we only know of tableUUID and grantee and the required privilege type and know nothing about the Permission Descriptor&apos;s UUID since we haven&apos;t gone to system tables yet. &lt;br/&gt;
During the statement&apos;s execution phase, one required privilege is taken at a time. For each one of them, we first create a Permission Descriptor using the tableUUID, permission type and grantee as PUBLIC. We find if there is such a granted permission by going to system tables and if yes, then we get that permission&apos;s UUID and put it in the Permission Descriptor object and save it in the hash table using the tableUUID and grantee as the hash key(so the entry in the has table will have both UUID and tableUUID) and we move on to the next required privilege.  &lt;br/&gt;
If there is no PUBLIC level privilege found, then the Permission Descriptor with tableUUID, grantee as PUBLIC and no UUID is added to the hash table and we look for the privilege at the user specific level in the permissions system tables. &lt;br/&gt;
If we find a privilege granted at the user level, then we add a Permission Descriptor with the UUID for that privilege(found from the system table), tableUUID and grantee as the actual user in the hash table and we move on to the next required privilege. Ofcourse, if no privilege found at PUBLIC or user level, there will be an exception thrown.&lt;br/&gt;
So, at the end of the statement execution, the hash table would have permissions descriptors with or without UUIDs depending on whether a permission was granted at the PUBLIC or user level. But in both cases, the hashkey used is based on tableUUID and grantee.&lt;/p&gt;

&lt;p&gt;2)Next, when revoke privilege is called, dependency manager has access to the UUID of the privilege. It looks in the hashtable using UUID for the haskey(we do not know the tableUUID at this point and hence have to reply on UUID. This is the code change that I made in this patch). Since the earlier entries in hashtable is step 1) above were based on the hashcode of tableUUID and grantee, we will not find the entry in the hash table based on the UUID. The cahing code makes an entry in the hashtable using the hashkey based on UUID and as part of the remaining logic in the caching code for a new entry, we goto system tables and get the remaining information about Permission Descriptor which includes tableUUID, grantee, permission type etc. This happens in PermssionsCacheable.setIdentity. During this time, caching code finds that there is already an entry in the hashtable for the tableUUID and grantee(which were just found from the system table) and hence it uses the existing hashtable entry and removes the entry that was made using UUID as the hashkey. So, this is what ensures that a Permission Descriptor does not change its hashCode during its lifetime in the cache and we continue to use tableUUID and grantee to get stuff from the cache or to add stuff into the cache. &lt;/p&gt;

&lt;p&gt;The stack trace of where we abandon the hashentry made using UUID and reuse the existing hasttable entry based on tableUUID and grantee is as follows&lt;br/&gt;
	PermissionsCacheable.setIdentity(Object) line: 66&lt;br/&gt;
	CachedItem.takeOnIdentity(CacheManager, CacheableFactory, Object, boolean, Object) line: 235&lt;br/&gt;
	Clock.addEntry(CachedItem, Object, boolean, Object) line: 796&lt;br/&gt;
	Clock.find(Object) line: 301&lt;br/&gt;
	DataDictionaryImpl.getPermissions(PermissionsDescriptor) line: 9796&lt;br/&gt;
	DataDictionaryImpl.getTablePermissions(UUID) line: 9790&lt;br/&gt;
	DDdependableFinder.getDependable(DataDictionary, UUID) line: 354&lt;br/&gt;
	DDdependableFinder.getDependable(UUID) line: 180&lt;br/&gt;
	BasicDependencyManager.getDependencyDescriptorList(List) line: 1190&lt;br/&gt;
	BasicDependencyManager.getDependents(Provider) line: 1370&lt;br/&gt;
	BasicDependencyManager.coreInvalidateFor(Provider, int, LanguageConnectionContext) line: 247&lt;br/&gt;
	BasicDependencyManager.invalidateFor(Provider, int, LanguageConnectionContext) line: 224&lt;br/&gt;
	TablePermsDescriptor.sendInvalidationMessages(DependencyManager, LanguageConnectionContext) line: 194&lt;br/&gt;
	DataDictionaryImpl.addRemovePermissionsDescriptor(boolean, PermissionsDescriptor, String, TransactionController) line: 10004&lt;br/&gt;
	TablePrivilegeInfo.executeGrantRevoke(Activation, boolean, List) line: 131&lt;br/&gt;
	GrantRevokeConstantAction.executeConstantAction(Activation) line: 61&lt;br/&gt;
	MiscResultSet.open() line: 56&lt;br/&gt;
	GenericPreparedStatement.execute(Activation, boolean, long) line: 357&lt;br/&gt;
	EmbedStatement.executeStatement(Activation, boolean, boolean) line: 1181&lt;br/&gt;
	EmbedStatement.execute(String, boolean, boolean, int, int[], String[]) line: 584&lt;br/&gt;
	EmbedStatement.execute(String) line: 516&lt;br/&gt;
	ij.executeImmediate(String) line: 313&lt;br/&gt;
	utilMain14(utilMain).doCatch(String) line: 433&lt;br/&gt;
	utilMain14(utilMain).go(LocalizedInput[], LocalizedOutput, Properties) line: 310&lt;br/&gt;
	Main14(Main).go(LocalizedInput, LocalizedOutput, Properties) line: 207&lt;br/&gt;
	Main.mainCore(String[], Main) line: 173&lt;br/&gt;
	Main14.main(String[]) line: 55&lt;br/&gt;
	ij.main(String[]) line: 60&lt;/p&gt;


&lt;p&gt;Dan, I hope this answers your question.&lt;/p&gt;</comment>
                            <comment id="12422793" author="djd" created="Sat, 22 Jul 2006 00:38:25 +0100"  >&lt;p&gt;Thanks Mamta for looking into this - I&apos;m still concerned that the object has the ability to change its hashcode and it&apos;s worrying when you say:&lt;/p&gt;

&lt;p&gt;&quot;Since the earlier entries in hashtable is step 1) above were based on the hashcode of tableUUID and grantee, we will not find the entry in the hash table based on the UUID.&quot;&lt;/p&gt;

&lt;p&gt;Seems something is wrong when we do a lookup expecting to fail and then subsequent find the object during creation time. I&apos;m looking at the code to see what is going on.&lt;/p&gt;</comment>
                            <comment id="12422796" author="djd" created="Sat, 22 Jul 2006 00:40:46 +0100"  >&lt;p&gt;Could you explain more what you mean by:&lt;br/&gt;
&quot;Hence, when dependency manager works with PermissionsDescriptor, it only knows about UUID&quot;&lt;/p&gt;

&lt;p&gt;Why does the PermissionDescriptor the dependency manager is working with only have a UUID?&lt;/p&gt;</comment>
                            <comment id="12422810" author="mamtas" created="Sat, 22 Jul 2006 04:47:19 +0100"  >&lt;p&gt;Dan, the answer to your question &quot;Why does the PermissionDescriptor the dependency manager is working with only have a UUID? &quot; is that the Dependency Manager while working on finding dependents calls DDdependableFinder.getDependable with just the UUID of the PermissionDescriptor(BTW, this is generic logic and not specific to PermissionDescriptor). And from that UUID, DDdependableFinder gets the PermissionDescriptor using dd.getTablePermissions (dependableObjectID); on line 354. The code for dd.getTablePermissions(UUID) goes through the hashing code to find out if a PermissionDescriptor for UUID alreadys exists in the hashtable(at this point in the code path, we do not know tableUUID and that is why I had to change hashCode to use UUID for generating the hash key). &lt;/p&gt;

&lt;p&gt;One way to get around this hashing key issue for revoke privileges would be to bypass the hash table and go straight to the system tables to get the PermissionDescriptor using the UUID. So, we will bypass hash table only in case of revoke privilege statement when the dependency manager is working on sending revoke related actions to the PermissionDescriptor&apos;s dependents. &lt;/p&gt;

&lt;p&gt;This can be implemented by changing following method in DataDictionary&lt;br/&gt;
    public TablePermsDescriptor getTablePermissions( UUID tablePermsUUID)&lt;br/&gt;
    throws StandardException&lt;/p&gt;
	{
        TablePermsDescriptor key = new TablePermsDescriptor( this, tablePermsUUID);
        return (TablePermsDescriptor) getPermissions( key);
	}
&lt;p&gt;New implementation for the method above will look as follows&lt;br/&gt;
    public TablePermsDescriptor getTablePermissions( UUID tablePermsUUID)&lt;br/&gt;
    throws StandardException&lt;/p&gt;
	{
        TablePermsDescriptor key = new TablePermsDescriptor( this, tablePermsUUID);
        return getUncachedTablePermsDescriptor(key);
	}
&lt;p&gt;With this change, we will not need the changes suggested by me on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1539&quot; title=&quot;A  trigger should be dropped when a privilege required by the trigger is revoked.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1539&quot;&gt;&lt;del&gt;DERBY-1539&lt;/del&gt;&lt;/a&gt;, patch DERBY1539V1hashCodeEqualsDiff.txt &lt;br/&gt;
The good thing about this change would be that we will not use 2 different hash codes for the same object. The bad thing is that for revoke privilege, dependency manager will need to always goto system tables for PermissionDescriptor before it can send actions to dependents.&lt;/p&gt;</comment>
                            <comment id="12422815" author="mamtas" created="Sat, 22 Jul 2006 07:17:52 +0100"  >&lt;p&gt;While looking at DataDictionaryImpl for something else, I found that there are very few descriptor types that get cached (looks like TableDescriptor and SPSDescriptor and PermissionsDescriptor are the only ones). For all the rest of the descriptors, we always goto system tables.&lt;/p&gt;

&lt;p&gt;For TableDescriptor and SPSDescriptor, DataDictionary getter methods check to see if Derby is in compile mode and the descriptors are fetched from the cache only if Derby is in compile mode. If not in compile mode, Derby goes to system tables to get TableDescriptor and SPSDescriptor. I am not sure why caching is not used in execute mode for these 2 descriptors, but if we followed the same logic for PermissionDescriptors as well, we will not have the hash key code problem with PermissionDescriptors during the revoke privilege execute phase.&lt;/p&gt;

&lt;p&gt;Does anyone have any opinion about this? If so, please let me know in next couple days. If not, I will go ahead and mimic the cache bypassing behavior for PermissionDescriptors.&lt;/p&gt;</comment>
                            <comment id="12422842" author="djd" created="Sat, 22 Jul 2006 19:47:47 +0100"  >&lt;p&gt;Mamta, I understand  your general comments about the dependency manager and not knowing the tableUUID etc, but it doesn&apos;t clear up my confusion.&lt;br/&gt;
I&apos;m trying to understand  how executing a REVOKE statement like:&lt;/p&gt;

&lt;p&gt; REVOKE SELECT ON TABLE S1.T1 FROM dan&lt;/p&gt;

&lt;p&gt;relates to what you wrote initially:&lt;/p&gt;

&lt;p&gt;&quot;But for revoke functionality, dependency manager is going to keep various object dependencies on PermissionsDescriptor using the UUID attached to the PermissionsDescriptor. Hence, when dependency manager works with PermissionsDescriptor, it only knows about UUID and doesn&apos;t know anything about tableUUID/routineUUID and hashCode &amp;amp; equals method need to be able to handle that.&quot; &lt;/p&gt;

&lt;p&gt;Maybe my question is, at what point in time during the execution of a REVOKE do you end up with a PermissionsDescriptor  that only has been populated with its object UUID, and what permission does the PermissionsDescriptor  represent?&lt;/p&gt;

&lt;p&gt;I think I&apos;m still a little in the dark as to the overall  problem this patch is addressing, rather than the specific of a cache lookup not working.&lt;/p&gt;



</comment>
                            <comment id="12422925" author="djd" created="Sun, 23 Jul 2006 18:02:56 +0100"  >&lt;p&gt;Mamta &amp;amp; I had a quick IM discussion to align our understanding of the issue:&lt;/p&gt;

&lt;p&gt;I was confused as to why in a simple REVOKE statement the DependencyManager (DM) was trying to fetch the PermissionsDescriptor for the item being revoked during the invalidation of said item. Ie. The call to DM.invalidateFor() takes the PermissionsDescriptor as the provider so why would it need to load it again?&lt;/p&gt;

&lt;p&gt;Thanks to Mamta&apos;s patience with my questions we discovered that during the DM.invalidateFor() call, the DM loads the set of persistent dependencies  for the Provider (in this case the revoked permission) and then converts them to an in-memory form. In this conversion to an in-memory form the DM needs a Provider object to link it to the Dependent and loads the Dependent&apos;s Provider &lt;b&gt;each&lt;/b&gt; time from the DataDictionary (DD) through its UUID. This is the load by UUID from the DD that was causing Mamta&apos;s code to have problems. The issue with this code is that the Provider object is the same for all the Dependents (since the list is derived from those objects dependent on a singel Provider)  thus loading it multple times is inefficient,  &lt;b&gt;and&lt;/b&gt; it&apos;s the same Provider that was passed into invalidateFor() , thus no-need to load it from the DD at all.&lt;/p&gt;

&lt;p&gt;To verify this was indeed the case, I created a table T and created three views against the table.  When a DROP TABLE T was executed I did see three loads of the TableDescriptor for T and it matched the TTableDescriptor passed into DM.invalidateFor.&lt;/p&gt;

&lt;p&gt; Thus what is really happening is that Mamta  has un-earthed some inefficient behaviour in the DM implementation. I&apos;ll enter a separate bug for this and I have some code to address it, I need to run complete tests first. I&apos;m slowed down by the fact it&apos;s so hot at home (heatwave &amp;amp; no a/c) I can&apos;t leave my laptop on  too long otherwise it gets really hot.&lt;/p&gt;

&lt;p&gt;There may still be an issue with the permissions cache, I couldn&apos;t find any thing in the GRANT/REVOKE design spec or the code that  described its use and design.&lt;/p&gt;
</comment>
                            <comment id="12423406" author="mamtas" created="Tue, 25 Jul 2006 19:42:36 +0100"  >&lt;p&gt;I am attaching a patch (DERBY1539V2diffDropTriggerOnRevoke.txt) which supports basic revoke functionality for triggers. If revoke statement finds a trigger dependent on the table/column/routine on which privilege is being revoked, the trigger will be dropped automatically. &lt;/p&gt;

&lt;p&gt;I need to further fine tune this functionality with a subsequent patch, so that trigger will get dropped only if it depends on the particular privilege TYPE that is being revoked. For eg, a trigger might just need a SELECT privilege on a table(and doesn&apos;t depend on other kind of privileges on that table) but with this patch, the trigger will drop itself even when INSERT privilege is revoked on that same table.&lt;/p&gt;

&lt;p&gt;svn stat -q o/p is attached as DERBY1539V2statDropTriggerOnRevoke.txt&lt;/p&gt;

&lt;p&gt;Following changes are included in this patch&lt;br/&gt;
1)Add a new invalidation action called REVOKE_PRIVILEGE in BasicDependencyManager and DependencyManager&lt;br/&gt;
2)Had to make DropTriggerConstantAction.java and one of it&apos;s methods, dropTriggerDescriptor, public. This was required so that &lt;br/&gt;
TriggerDescriptor can call DropTriggerConstantAction.dropTriggerDescriptor when it gets a revoke privilege for one of the privileges that is required by the TriggerDescriptor. DropTriggerConstantAction and TriggerDescriptor are not in the same package.&lt;br/&gt;
3)DataDictionaryImpl - send invalidation messages when a revoke privilege is requested only if that privilege was really granted to that user. Currently, a user can revoke a privilege which was never granted. Derby will treat it as a no-op because there is nothing to revoke. That is why I moved the if condition in the patch to it&apos;s new location. With this change, invalidation will get sent only on the revoke privilege which revokes a granted privilege.&lt;br/&gt;
4)For now, let ConstraintDescriptor and ViewDescriptor ignore revoke action. Will get to them in subsequent patch.&lt;br/&gt;
5)TriggerDescriptor.java will drop the trigger if it receives the revoke action. This needs to be refined more in subsequent patch becasue with the current patch, the trigger will drop itself for any kind of privilege type revoke on a table. For eg, a trigger&lt;br/&gt;
might just need a SELECT privilege on a table but the trigger will drop itself when INSERT privilege is revoked on that same table.&lt;br/&gt;
6)Added more tests into  lang/grantRevokeDDL.sql&lt;br/&gt;
	1) +ve test case&lt;br/&gt;
	mamta1 &lt;br/&gt;
	create a table t11TriggerRevokeTest&lt;br/&gt;
	grant trigger on t11TriggerRevokeTest to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create a trigger on t11TriggerRevokeTest&lt;br/&gt;
	mamta1&lt;br/&gt;
	do some dmls&lt;br/&gt;
	revoke trigger on t11TriggerRevokeTest from mamta2 &amp;#8211; this will drop the dependent trigger&lt;br/&gt;
	mamta2&lt;br/&gt;
	attempt to recreate trigger on t11TriggerRevokeTest will fail. &lt;br/&gt;
	mamta1 &lt;br/&gt;
	grant trigger privilege on t11TriggerRevokeTest&lt;br/&gt;
	mamta2&lt;br/&gt;
	recreates the trigger&lt;br/&gt;
	mamta1&lt;br/&gt;
	drop t11TriggerRevokeTest &amp;#8211; drops dependent trigger&lt;br/&gt;
	2) -ve test case&lt;br/&gt;
	mamta1&lt;br/&gt;
	create a table t11TriggerRevokeTest&lt;br/&gt;
	grant select on t11TriggerRevokeTest to mamta2&lt;br/&gt;
	grant trigger on t11TriggerRevokeTest to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create a trigger on t11TriggerRevokeTest&lt;br/&gt;
	mamta1&lt;br/&gt;
	do some dmls&lt;br/&gt;
	&amp;#8211; following will drop the trigger eventhough trigger does not require SELECT privilege&lt;br/&gt;
	&amp;#8211; This is incorrect. Will fix this in the next patch&lt;br/&gt;
	revoke SELECT on t11TriggerRevokeTest from mamta2 &lt;br/&gt;
	mamta2&lt;br/&gt;
	attempt to recreate trigger on t11TriggerRevokeTest will pass because TRIGGER privilege is still in place. &lt;/p&gt;



</comment>
                            <comment id="12423411" author="mamtas" created="Tue, 25 Jul 2006 19:50:23 +0100"  >&lt;p&gt;BTW, the patch DERBY1539V1hashCodeEqualsDiff.txt should not be applied. Dan has checked in a fix for dependency manager so that we do not recreate the Provider object and hence there is no need for DERBY1539V1hashCodeEqualsDiff.txt. Dan&apos;s changes went in as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1581&quot; title=&quot;BasicDependencyManager re-loads the Provider multiple times from the DataDictionary when loading the stored dependencies for the Provider.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1581&quot;&gt;&lt;del&gt;DERBY-1581&lt;/del&gt;&lt;/a&gt; (Revision: 425479)&lt;/p&gt;</comment>
                            <comment id="12423412" author="mamtas" created="Tue, 25 Jul 2006 19:52:03 +0100"  >&lt;p&gt;Forgot to mention, I ran derbyall with DERBY1539V2diffDropTriggerOnRevoke.txt on Windows XP with Sun jdk1.4 and there were no new failures.&lt;/p&gt;</comment>
                            <comment id="12423480" author="djd" created="Tue, 25 Jul 2006 23:56:47 +0100"  >&lt;p&gt;The code in the patch seems generally ok, though it&apos;s not clear why you stopped resetting the UUID here and with changes below may still be required:&lt;/p&gt;

&lt;p&gt;             	//grant/revoke privilege didn&apos;t change anything and hence just&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;//return after resetting the uuid in the permission descriptor&lt;/li&gt;
	&lt;li&gt;perm.setUUID(null);&lt;br/&gt;
+            	//return&lt;br/&gt;
                 return;   &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As an aside, that  diff confused me for a while, I thought you were adding a commented out return statement, eventually I figured out it was a modified comment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;However two issues:&lt;/p&gt;

&lt;p&gt;1) the call to invalidateFor() in the DataDictionaryImpl is not correct, it needs to be moved higher, to the revoke constanct action that is driving the REVOKE. Most of the other existing calls to invalidateFor() are from the constant actions, and none are from within the data dictionary. Think of the data dictionary as the glue code between objects and the stored form, the system catalogs. Thus if one had a pure in-memory data dictionary one wouldn&apos;t want to duplicate the logic relating to revoking objects in it, much better to have it in a single place at the higher level.&lt;/p&gt;

&lt;p&gt;2) The actual drop of the trigger descriptor needs to be in the makeInvalid call, not the prepareToInvalidate call. See the earlier discussion on derby-dev.&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;As another aside, if code has an existing switch statement you should add to the switch, not ad dan extra if statement, like your code in prepareToInvalidate&amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="12423514" author="mamtas" created="Wed, 26 Jul 2006 05:10:34 +0100"  >&lt;p&gt;Dan, I have addressed your concerns in the patch DERBY1539V3diffDropTriggerOnRevoke.txt&lt;/p&gt;

&lt;p&gt;1)The invalidation messages are now sent by the caller rather than the method DataDictionary.addRemovePermissionsDescriptor.  DataDictionary.addRemovePermissionsDescriptor will return true if it has made changes to system tables such that the dependents need to be notified.&lt;/p&gt;

&lt;p&gt;2)I have moved the drop trigger code into makeInvalid call. &lt;/p&gt;

&lt;p&gt;3)Removed the if condition and used the existing switch. &lt;/p&gt;

&lt;p&gt;The grant revoke tests passed with these changes.&lt;/p&gt;

&lt;p&gt;Can someone please review/commit this patch? thanks&lt;/p&gt;</comment>
                            <comment id="12423648" author="djd" created="Wed, 26 Jul 2006 14:45:47 +0100"  >&lt;p&gt;Mamta wrote:&lt;br/&gt;
  2)I have moved the drop trigger code into makeInvalid call. &lt;/p&gt;

&lt;p&gt;The v3 patch still has the drop trigger code in TriggerDescriptor.prepareToInvalidate&lt;/p&gt;
</comment>
                            <comment id="12423654" author="mamtas" created="Wed, 26 Jul 2006 15:26:24 +0100"  >&lt;p&gt;Sorry about the mix up. This is what I get for staying up late.&lt;/p&gt;

&lt;p&gt;I have attached the patch as DERBY1539V4diffDropTriggerOnRevoke.txt and hopefully followed through all my claims. It is same as the earlier patch except that trigger drop has been moved into makeInvalid method. I ran the grant revoke tests and they ran fine.&lt;/p&gt;</comment>
                            <comment id="12423711" author="djd" created="Wed, 26 Jul 2006 21:35:54 +0100"  >&lt;p&gt;Patch DERBY1539V4diffDropTriggerOnRevoke.txt Committed revision 425836&lt;/p&gt;</comment>
                            <comment id="12424359" author="mamtas" created="Sun, 30 Jul 2006 08:03:53 +0100"  >&lt;p&gt;Recently, I had submitted a patch(DERBY1539V3diffDropTriggerOnRevoke.txt) for triggers which will drop the triggers if a revoke privilege is issued on a table/routine used by the trigger. That patch dropped the trigger even if the trigger didn&apos;t depend on the permission type/column on the table. And the patch dropped the trigger if the trigger depended on the routine.&lt;/p&gt;

&lt;p&gt;eg for current behavior on revoke table level privilege&lt;br/&gt;
	mamta1&lt;br/&gt;
	create table t1(c11 int, c12 int);&lt;br/&gt;
	grant select, update, trigger on t1 to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create a trigger on mamta1.t1 with action as select * from some other table&lt;br/&gt;
	&amp;#8211; notice that the trigger object above depends only on the trigger privilege on mamta1.t1&lt;br/&gt;
	mamta1&lt;br/&gt;
	revoke select on t1 from mamta2&lt;br/&gt;
	&amp;#8211; this revoke ends up dropping the trigger even though trigger doesnot rely on select permission&lt;/p&gt;

&lt;p&gt;eg for current behavior on revoke column level privilege&lt;br/&gt;
	mamta1&lt;br/&gt;
	create table t1(c11 int, c12 int);&lt;br/&gt;
	grant trigger on t1 to mamta2&lt;br/&gt;
	create table t2(c21 int, c22 int);&lt;br/&gt;
	grant select(c21, c22) on t2 to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create a trigger on mamta1.t1 with action as select c21 from mamta1.t2&lt;br/&gt;
	&amp;#8211; notice that the trigger object above depends only on the trigger privilege on mamta1.t1, and &lt;br/&gt;
                      &amp;#8211; select privilege on mamta1.t2.c21&lt;br/&gt;
	mamta1&lt;br/&gt;
	revoke select(c22) on t2 from mamta2&lt;br/&gt;
	&amp;#8211; this revoke ends up dropping the trigger even though trigger doesnot rely on select                   &lt;br/&gt;
                     &amp;#8211; permission on column c22 of table t2&lt;/p&gt;

&lt;p&gt;eg for current behavior on revoke column level privilege&lt;br/&gt;
	mamta1&lt;br/&gt;
	create function f1&lt;br/&gt;
	grant execute on f1 to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create table t1&lt;br/&gt;
	create trigger on t1 with action that executes mamta1.f1&lt;br/&gt;
	mamta1&lt;br/&gt;
	revoke execute on f1 from mamta2 RESTRICT&lt;br/&gt;
	&amp;#8211; this revoke ends up dropping the trigger even though revoke execute is supposed to have &lt;br/&gt;
                     &amp;#8211; RESTRICT behavior, which means that&lt;br/&gt;
	&amp;#8211; if there are dependent objects, then revoke execute should fail. Couldn&apos;t implement this in earlier 	&amp;#8211; patch because dependents didn&apos;t know what kind of revoke was issued. All they knew was revoke &lt;br/&gt;
                     &amp;#8211; issued against one of the objects that the dependent relied on.&lt;/p&gt;

&lt;p&gt;With the idea of working in incremental steps, I submitted the earlier patch as the first step towards implementing revoke privilege. As the next step, I am attaching another patch (DERBY1539V4diffDropTriggerOnRevokeRequiredPrivilege.txt ), which will fix the problem mentioned above in the egs. This patch currently only deals with triggers. The next steps are to implement similar behavior for views and constraints. The svn stat -q o/p for this patch is attached as DERBY1539V4statDropTriggerOnRevokeRequiredPrivilege.txt. Note that I have added a new file in this patch.&lt;/p&gt;

&lt;p&gt;The reason for implementing REVOKE EXECUTE ... RESTRICT in this patch is that prior to this patch, there was&lt;br/&gt;
no way of knowing what kind of revoke privilege is issued by the user and hence even on revoke execute, I was dropping the dependent objects. With this patch, now we know what kind of revoke privilege has been issued and when the dependent gets revoke execute action, it can now throw an exception.&lt;/p&gt;

&lt;p&gt;Grant revoke tests have run fine with this patch. I fired derbyall suite couple hrs back on my Windows XP machine with Sun&apos;d jdk1.4 and no errors so far.&lt;/p&gt;

&lt;p&gt;More information on the current patch&apos;s implementation details is as follows.&lt;br/&gt;
1)BasicDependencyManager, TriggerDescriptor&lt;br/&gt;
SYSTABLEPERMS has one row per table, grantee, grantor. That row has various fields to indicate what type of permissions(insert, trigger, update etc) are available for that key. The row is also uniquely identified by a UUID. Currently, when an object is created and it needs a particular pemission type on a given table, grantee, grantor, the dependency manager(DM) only tracks the dependency using UUID and it doesn&apos;t keep track of the exact permission type required. Because of this, currently, any permission type that gets revoked on table, grantee, grantor, it ends up dropping the dependent object, whether or not the dependent object really needs that permission type. &lt;br/&gt;
	eg(copying the eg from the beginning of this comment&lt;br/&gt;
	mamta1&lt;br/&gt;
	create table t1(c11 int, c12 int);&lt;br/&gt;
	grant select, update, trigger on t1 to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create a trigger on mamta1.t1 with action as select * from some other table&lt;br/&gt;
	&amp;#8211; notice that the trigger object above depends only on the trigger privilege on mamta1.t1&lt;br/&gt;
	mamta1&lt;br/&gt;
	revoke select on t1 from mamta2&lt;br/&gt;
	&amp;#8211; this revoke ends up dropping the trigger even though trigger doesnot rely on select permission&lt;/p&gt;

&lt;p&gt;The problem also exists for column level permissions. SYSCOLPERMS has one row per table, grantee, grantor, a permission type and a bit map for columns on which that permission is granted. The row is also uniquely identified by a UUID. Now, an object might need a permission on only a subset of table columns and if a revoke is done later on columns that are not used by the object, then we should not drop the object. Currently, Derby tracks dependency on column level permissions using just the UUID and does not keep track of exact column subset required by the dependent object. Because of this, any column that gets revoked for a given UUID, DM drops all the dependents on that UUID, even if the dependent object does not care about the column being revoked.&lt;br/&gt;
	eg(copying the eg from the beginning of this comment&lt;br/&gt;
	mamta1&lt;br/&gt;
	create table t1(c11 int, c12 int);&lt;br/&gt;
	grant trigger on t1 to mamta2&lt;br/&gt;
	create table t2(c21 int, c22 int);&lt;br/&gt;
	grant select(c21, c22) on t2 to mamta2&lt;br/&gt;
	mamta2&lt;br/&gt;
	create a trigger on mamta1.t1 with action as select c21 from mamta1.t2&lt;br/&gt;
	&amp;#8211; notice that the trigger object above depends only on the trigger privilege on mamta1.t1, and select privilege on mamta1.t2.c21&lt;br/&gt;
	mamta1&lt;br/&gt;
	revoke select(c22) on t2 from mamta2&lt;br/&gt;
	&amp;#8211; this revoke ends up dropping the trigger even though trigger doesnot rely on select permission on column c22 of table t2&lt;/p&gt;


&lt;p&gt;To fix both these problems, I have enhanced the DM such that when an object is created which needs a particular permission type on a given permission table&apos;s UUID, DM tracks the object&apos;s dependency on the permission type and the row in SYSTABLEPERM identified by it&apos;s UUID. Similarly, when an object is created which needs a particular permission type on a subset of table&apos;s column, the object&apos;s dependnecy is tracked on the column subset and the row in SYSCOLPERMS identified by it&apos;s UUID. Both of these solutions follow the existing model that we currently have to track view&apos;s dependency on a subset of a table&apos;s columns. &lt;/p&gt;

&lt;p&gt;I have implemented this kind of dependency for SYSTABLEPERMS by adding a new class called DDPrivilegeTypeDependableFinder.java  which saves the permission type part of the dependency tracking for an object. For SYSCOLPERMS, I implemented this by modifying existing class DDColumnDependableFinder.java. This class is currently used for tracking view&apos;s dependency on subset of a table&apos;s columns. Now, this class will also get used to track dependency on a subset of columns for column level privileges.&lt;/p&gt;

&lt;p&gt;The changes so far explained covers what happens when DM saves the dependencies. Later on, when a provider wants to notify it&apos;s dependents about an action, DM needs to use all the information that it collected while saving the dependencies. &lt;/p&gt;

&lt;p&gt;To be specific, later, when a permission is revoked, the DM needs to build a list of dependents that rely on that permission. For each of the dependents, DM needs to find the exact permission type or column subset required by that dependent.  That information then should be saved in the provider object and we should put the provider+dependent object pair into the list of dependents. Once the list building is finished, each of the dependent objects will get the revoke invalidation action. The dependent object will check the provider object to see if the permission type or column subset being revoked is one of  the things that it depends on. If yes, then it will drop itself. If not, then it will ignore the invalidation action. &lt;/p&gt;

&lt;p&gt;In order to implement this, amon other changes, I had to modify the code recently checked in by Dan for improving DM performance. Dan made changes to DM so that we do not recreate the provider object when building the dependents list for the provider because we already have access to the provider object. With my changes, while building the dependents list, if the provider is TablePermsDescriptor or ColPermsDescriptor, then for every dependent, I save into the provider object exactly what kind of permission type/column subset the dependent depends on. And I put the dependent and this modified Provider pair into the dependent list.&lt;/p&gt;

&lt;p&gt;With this change in dependency system, subsequently, when a permission type is revoked, the TablePermsDescriptor(Provider) will have the permission type being revoked and the permission type required by the dependent object. When the dependent object will receive the REVOKE action at table level, it will check the TablePermsDescriptor to see if the permission type being revoked is one of the permissions required by it, and if yes, then the dependent object will drop itself. Similar thing will happen for ColPermsDescriptor when it is the Provider of an invalidation action.&lt;/p&gt;

&lt;p&gt;2)CoreDDFinderClassInfo, DDPrivilegeTypeDependableFinder, DDColumnDependableFinder - &lt;br/&gt;
We need a special finder class for COLUMNS_PERMISSION_FINDER_V01_ID because along with the row in the SYSCOLPERMS, we also need to track the exact column list required for a given dependent object. This is same as what Derby currently does for views, where a view might require only a subset of columns in a table. And hence, when tracking the view dependency, we need to know not just the SYSTABLES row but also the subset of columns required by view. Since similar scheme is required for COLUMNS_PERMISSION_FINDER_V01_ID, I have used existing DDColumnDependableFinder with some modifications to support additional format id.&lt;/p&gt;

&lt;p&gt;For similar reasons, We need special finder class for TABLE_PERMISSION_FINDER_V01_ID because along with the row in the SYSTABLEPERMS, we also need to track the exact privilege type required on a table for a given dependent object. Unlike COLUMNS_PERMISSION_FINDER_V01_ID, where I could use the existing class, DDColumnDependableFinder, I had to add a new dependable finder class called DDPrivilegeTypeDependableFinder to track exact required privilege type for a given row in SYSTABLEPERMS.&lt;/p&gt;

&lt;p&gt;3)SPSDescriptor&lt;br/&gt;
For now, I am having SPSDescriptor ignore all the revoke invalidation actions. May need some work here when working on	query plan invalidation for revoke privilege.&lt;/p&gt;

&lt;p&gt;4)ViewDescriptor, ConstraintDescriptor - &lt;br/&gt;
For now, ignore all the revoke invalidation actions(except REVOKE_EXECUTE_PRIVILEGE). Derby supports only RESTRICT form of revoke execute and that means that if there are any dependent objects on execute permission on routine, revoke execute on that routine should fail. That is why, I have ViewDescriptor, ConstraintDescriptor catch REVOKE_EXECUTE_PRIVILEGE and throw exception. As for all the other revoke invalidation actions, I Will get to them in subsequent patch for ViewDescriptor, ConstraintDescriptor.&lt;/p&gt;

&lt;p&gt;5)PermissionsDescriptor, RoutinePermsDescriptor&lt;br/&gt;
Have each of the PermissionsDescriptor send appropriate revoke invalidation action. For instance, if SELECT privilege is being revoked, then send REVOKE_SELECT_PRIVILEGE and so on and so forth. The dependent objects can take desired action depending on the type of privilege being revoked. In addition, error messages will be more specific since 	for instance, rather than saying revoke privilege failed, they can say revoke execute privilege failed.&lt;/p&gt;

&lt;p&gt;6)RoutinePermsDescriptor, TablePermsDescriptor and ColPermDescriptor&lt;br/&gt;
Changed getObjectName method from &lt;br/&gt;
	return &quot;Routine Privilege on &quot; + routineName; &lt;br/&gt;
to &lt;br/&gt;
		return routineName; &lt;br/&gt;
This change in the method makes the error method from revoke execute more readable. With the original method, if the user tried to revoke the execute permission from the routine when there were dependent objects relying on that permission, the error message would be&lt;br/&gt;
ERROR X0Y25: Operation &apos;REVOKE EXECUTE PRIVILEGE&apos; cannot be performed on object &apos;Routine Privilege on SELECTFROMSPECIFICSCHEMA&apos; because TRIGGER &apos;TR31T31&apos; is dependent on that object.&lt;/p&gt;

&lt;p&gt;With the change in the method, user would get following message&lt;br/&gt;
ERROR X0Y25: Operation &apos;REVOKE EXECUTE PRIVILEGE&apos; cannot be performed on object &apos;SELECTFROMSPECIFICSCHEMA&apos; because TRIGGER &apos;TR31T31&apos; is dependent on that object.&lt;/p&gt;


&lt;p&gt;7)DependencyManager - describes all the invalidation actions for revoke.&lt;/p&gt;

&lt;p&gt;8)TablePermsDescriptor and ColPermDescriptor have changes to record speicifc privilege requirement of the dependent. These getter, setter and resetter methods are all called by the dependency manager to track object&apos;s dependency on specific privilege type and subset of table&apos;s columns.&lt;/p&gt;

&lt;p&gt;9)StatementTablePermission, StatementColumnPermission - &lt;br/&gt;
During the compile phase of a view, trigger, constraint, we collect what privileges are required by these objects. The information about the required privileges, privilege types, column list needs to be saved by dependency manager in the execute phase. The change to these classes are for collecting required information for dependency manager so that it can save the specific privilege type/column subset requirements in dependency system.&lt;/p&gt;

&lt;p&gt;10)RoutinePrivilegeInfo, TablePrivilegeInfo&lt;br/&gt;
Call methods on the PermissionDescriptors so that they can send specific revoke invalidation actions&lt;/p&gt;

&lt;p&gt;9)New Tests&lt;br/&gt;
1)revoke execute should fail if there are dependent objects on it&lt;br/&gt;
2)revoke will drop a trigger only if trigger depends on that specific privilege type.&lt;br/&gt;
3)create trigger which depends on the privileges on objects from different schemas. Revoke on any one those objects should drop the trigger.&lt;br/&gt;
4)create trigger which depends on both table and column level privileges. The trigger should get dropped only if the privileges gets revoked on specific columns required by the trigger or if privileges gets revoked on specific privilege type required by the trigger on a table. If not, then trigger should stay untouched.&lt;br/&gt;
3)I couldn&apos;t add any testing for trigger action as update on tables owned by a different schema. This is because Derby runs into a NPE. The Jira entry for this specific problem is &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1583&quot; title=&quot;With grant revoke enabled, defining a trigger whose actions updates a table (from different schema) results in NPE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1583&quot;&gt;&lt;del&gt;DERBY-1583&lt;/del&gt;&lt;/a&gt;. Once that bug is fixed, we should add tests like&lt;br/&gt;
set connection mamta3&lt;br/&gt;
create trigger tr11t11 after insert on mamta1.t11TriggerRevokeTest for each statement mode db2sql&lt;br/&gt;
        update mamta2.t21TriggerRevokeTest set c212 = 99;&lt;br/&gt;
and then revoke update privileges on mamta2.t21TriggerRevokeTest from mamta3.&lt;/p&gt;


&lt;p&gt;I will appreciate if someone can review, commit this patch for me.&lt;/p&gt;</comment>
                            <comment id="12424676" author="djd" created="Mon, 31 Jul 2006 22:59:52 +0100"  >&lt;p&gt;I&apos;m looking at this patch and need to study it more, but I think having the dependency manager take specific actions based upon the type of provider or dependent is not a good approach. I know the code does this already  for TableDescriptors (at least) and it&apos;s fair you copied that approach, but I&apos;d like to think about if it can be avoided.&lt;/p&gt;</comment>
                            <comment id="12424724" author="djd" created="Tue, 1 Aug 2006 04:43:08 +0100"  >&lt;p&gt;I&apos;m wondering if one could see the invalidation due to a revoke in a different light, more of a invalidation followed by a re-validate. Thus rather than having to carry around extra information about what exactly has changed, just have the trigger (dependent) receive notification that its privileges  have changed in some way and now it needs to re-validate and check all of its permissions. Thus which privilege has dropped  is no that important, just that fact that re-validation is required.&lt;/p&gt;

&lt;p&gt;I think a step like this is needed anyway if an object was dependent on a privilege granted to an individual that existed at create time but subsequently could be statisfied by the same privilege granted to PUBLIC.&lt;/p&gt;

&lt;p&gt;I assume that trigger re-compilation like this must work, say a trigger&apos;s action statement is defined as an INSERT, then that statement must need to be recompiled if an index is added or dropped from the table. Or with the various trigger re-compile bugs recently is trigger re-compilation not implemented at all?&lt;/p&gt;</comment>
                            <comment id="12424736" author="mamtas" created="Tue, 1 Aug 2006 06:07:09 +0100"  >&lt;p&gt;I am going to spend more time on your suggestion but from a quick look, I don&apos;t see any recompilation happening for triggers currently.  Seems like triggers currently just ignore all the invalidations that come their way except for drop table/drop synonym etc. For these specific drop actions, triggers just raise an error that they are dependent on the object being dropped. But no recompilation seem to happen for any invalidation.&lt;/p&gt;

&lt;p&gt;Also, we would need recompilation mechanism for views and constraints too because they are also dependent on privileges and hence will be notified of revoke actions. Don&apos;t think there is any code for views and constraints to get recompiled. Will investigate into this more to be sure what happens if recompilation is required.&lt;/p&gt;</comment>
                            <comment id="12424737" author="mamtas" created="Tue, 1 Aug 2006 06:17:59 +0100"  >&lt;p&gt;Another solution I am thinking is have the ViewDescriptor, ConstraintDescriptor and TriggerDescriptor keep the information about what privileges they require. This can be done when these objects get loaded from the data dictionary. Then when they get the specific revoke actions like what my patch sends, the dependent objects will check their privilege requirement against what is being revoked in the PermissionDescriptor and then drop themselves if their required privilege is being revoked. So, rather than contaminate the dependency manager code with special cases, have the dependent descriptors aware of their privilege requirements. This seems to sound more logical. This will not solve the problem of having the dependent object depend on the next available privilege when one of it&apos;s current privilege is revoked but may be it can be tackled later.&lt;/p&gt;

&lt;p&gt;Let me know if anyone has any opinion about this approach. Otherwise, I am thinking I am going to start looking at this approach.&lt;/p&gt;</comment>
                            <comment id="12424753" author="mamtas" created="Tue, 1 Aug 2006 06:55:48 +0100"  >&lt;p&gt;Thinking further about my proposed solution in the comment before this, I think it will be better for dependent descriptors to load their privilege requirements when they receive their first revoke invalidation action. This way, we don&apos;t unnecessarily have to load privilege requirements for all the triggers, constraints and view descriptors that get referenced in a database session. Especially, when the SQL Standard Authorization is not enabled, this list is not required at all. So, rather than loading the privilege requirements when the objects get loaded from the data dictionary, load the privilege requirements when the objects receive their first revoke invalidation action.&lt;/p&gt;

&lt;p&gt;This is all based on my thoughts in last hr or so and hence might have gottchas in them. If anyone catches anything in this solution, please let me know. In the mean time, I will continue to go this path.&lt;/p&gt;</comment>
                            <comment id="12424913" author="djd" created="Tue, 1 Aug 2006 17:16:21 +0100"  >&lt;p&gt;On the trigger re-compile issue it seems there is a serious problem currently (regardless of grant/revoke issues) with triggers. This may need to be fixed before  modifying the trigger -revoke interation any more.&lt;/p&gt;

&lt;p&gt;I wonder if you can make progress on the view &amp;amp; constraint dropping before completing the trigger? At least get them in to a similar state as triggers where a revoke wil drop the object, even if it drops it in too many situations.&lt;/p&gt;</comment>
                            <comment id="12426954" author="djd" created="Wed, 9 Aug 2006 17:15:10 +0100"  >&lt;p&gt;Cleaning the summary.&lt;/p&gt;</comment>
                            <comment id="12430687" author="yipng" created="Sat, 26 Aug 2006 04:37:21 +0100"  >&lt;p&gt;The trigger recompilation problem has been resolved by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1621&quot; title=&quot;Trigger action statement is not recompile when there is a change that would affect it.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1621&quot;&gt;&lt;del&gt;DERBY-1621&lt;/del&gt;&lt;/a&gt; and is already checked into the trunk.  So this jira can continue to proceed.&lt;/p&gt;</comment>
                            <comment id="12431487" author="mamtas" created="Wed, 30 Aug 2006 07:24:37 +0100"  >&lt;p&gt;Closing this issue since I am finished with the work targeted for 10.2 release. The remaining work for this issue is getting tracked in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1782&quot; title=&quot;When a privilege is revoked at table level, Derby should only drop objects that require that particular privilege and not all the objects that require some form of privilege on that table.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1782&quot;&gt;DERBY-1782&lt;/a&gt;. I will link the 2 issues so we can keep track of the correlation between the 2 jira entries.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12329481">DERBY-1057</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12343197">DERBY-1330</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12348900">DERBY-1782</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12337254" name="DERBY1539V1hashCodeEqualsDiff.txt" size="11144" author="mamtas" created="Thu, 20 Jul 2006 17:10:58 +0100"/>
                            <attachment id="12337255" name="DERBY1539V1hashCodeEqualsStat.txt" size="401" author="mamtas" created="Thu, 20 Jul 2006 17:10:58 +0100"/>
                            <attachment id="12337485" name="DERBY1539V2diffDropTriggerOnRevoke.txt" size="24285" author="mamtas" created="Tue, 25 Jul 2006 19:42:36 +0100"/>
                            <attachment id="12337484" name="DERBY1539V2statDropTriggerOnRevoke.txt" size="802" author="mamtas" created="Tue, 25 Jul 2006 19:42:36 +0100"/>
                            <attachment id="12337522" name="DERBY1539V3diffDropTriggerOnRevoke.txt" size="30971" author="mamtas" created="Wed, 26 Jul 2006 05:10:34 +0100"/>
                            <attachment id="12337521" name="DERBY1539V3statDropTriggerOnRevoke.txt" size="1037" author="mamtas" created="Wed, 26 Jul 2006 05:10:34 +0100"/>
                            <attachment id="12337561" name="DERBY1539V4diffDropTriggerOnRevoke.txt" size="31178" author="mamtas" created="Wed, 26 Jul 2006 15:26:24 +0100"/>
                            <attachment id="12337767" name="DERBY1539V4diffDropTriggerOnRevokeRequiredPrivilege.txt" size="79642" author="mamtas" created="Sun, 30 Jul 2006 08:03:53 +0100"/>
                            <attachment id="12337768" name="DERBY1539V4statDropTriggerOnRevokeRequiredPrivilege.txt" size="1637" author="mamtas" created="Sun, 30 Jul 2006 08:03:53 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 21 Jul 2006 13:37:25 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30041</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0sxz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38507</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>