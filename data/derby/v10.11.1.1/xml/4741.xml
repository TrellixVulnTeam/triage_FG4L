<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:16:28 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4741/DERBY-4741.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4741] Make embedded Derby work reliably in the presence of thread interrupts</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4741</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When not executing on a small device VM, Derby has been using the Java NIO classes java.nio.clannel.* for file io for extra concurrency.&lt;br/&gt;
If a thread is interrupted while executing blocking IO operations in NIO, the ClosedByInterruptException will get thrown. Unfortunately, Derby isn&apos;t current architected to retry and complete such operations (before passing on the interrupt), so the Derby database store can be left in an inconsistent state, although no data is corrupted, and we therefore have to return a database level error to perform shutdown and recovery. This means the applications can no longer access the database while a shutdown and reboot including a recovery is taking place.&lt;/p&gt;

&lt;p&gt;It would be nice if Derby could somehow detect and finish IO operations underway when thread interrupts happen before passing the exception on to the application. Derby embedded is sometimes embedded in applications that use Thread.interrupt to stop threads.&lt;/p&gt;

</description>
                <environment></environment>
        <key id="12469090">DERBY-4741</key>
            <summary>Make embedded Derby work reliably in the presence of thread interrupts</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="dagw">Dag H. Wanvik</reporter>
                        <labels>
                            <label>derby_backport_reject_10_7</label>
                            <label>derby_triage10_8</label>
                    </labels>
                <created>Mon, 12 Jul 2010 19:37:58 +0100</created>
                <updated>Mon, 17 Jun 2013 10:19:51 +0100</updated>
                            <resolved>Sat, 26 Feb 2011 03:44:16 +0000</resolved>
                                    <version>10.2.1.6</version>
                    <version>10.2.2.0</version>
                    <version>10.3.1.4</version>
                    <version>10.3.2.1</version>
                    <version>10.3.3.0</version>
                    <version>10.4.1.3</version>
                    <version>10.4.2.0</version>
                    <version>10.5.1.1</version>
                    <version>10.5.2.0</version>
                    <version>10.5.3.0</version>
                    <version>10.6.1.0</version>
                                    <fixVersion>10.8.1.2</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12910067" author="knutanders" created="Thu, 16 Sep 2010 10:42:41 +0100"  >&lt;p&gt;Since Derby used to handle interrupts in a better way before we switched to NIO, would it make sense to change the issue type to bug and flag it as a regression?&lt;/p&gt;</comment>
                            <comment id="12910135" author="dagw" created="Thu, 16 Sep 2010 13:57:10 +0100"  >&lt;p&gt;Yes, I agree, Knut. Just did it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12918258" author="dagw" created="Tue, 5 Oct 2010 23:18:21 +0100"  >&lt;p&gt;Uploading an experimental patch which upon seeing the container channel interrupted/closed, &lt;br/&gt;
closes and reopens the container to allow completion of the I/O.&lt;/p&gt;

&lt;p&gt;Using a modified Derby151Test, the trace on my box (OpenSolaris snv_148, Java 1.6) shows how&lt;br/&gt;
the RAFContainer4.java I/O code recovers. When an interrupt is detected (in the form of an interrupted channel),&lt;br/&gt;
the thread&apos;s interrupt flag is tucked away in a thread local variable for now, and the flag is reset, so the thread can continue and retry the I/O operation when the container has been resurrected. &lt;/p&gt;

&lt;p&gt;The idea is that the thread local variable might be checked &quot;higher up&quot; somewhere, where throwing an exception would not make the database go down.&lt;/p&gt;

&lt;p&gt;During this investigation, I have found numerous other locations at which an interrupt will make Derby go down, though, so RAFContainer4.java (or in deed NIO) is not the only weak spot we have.&lt;br/&gt;
Running the test on Windows, I see Derby choke on trying to switch log files, cf the enclosed derby.log file &quot;derby-4741-nio-container-2.log&quot; due to seeing a ChannelClosedException on the log file (NIO channel.force).&lt;/p&gt;</comment>
                            <comment id="12918508" author="dagw" created="Wed, 6 Oct 2010 14:21:48 +0100"  >&lt;p&gt;Uploading a modified version of the experimental patch, nio-container-2b, which also includes a standalone test I have been using to flush out effects of interrupts on threads.&lt;/p&gt;</comment>
                            <comment id="12918975" author="dagw" created="Thu, 7 Oct 2010 18:04:18 +0100"  >&lt;p&gt;Uploading derby-4741-nio-container+log, which builds on the previous&lt;br/&gt;
experimental patch in the following ways:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Adds logic to recover when switching the log file gets interrupted&lt;br/&gt;
  (seen on Windows using Derby151Test). The retry had to precolate up&lt;br/&gt;
  from the NIO code, so I use an internal exception (temporarily&lt;br/&gt;
  borrow an exisiting one; should make a new one later)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Makes RAFContainer4#getEmbryonicPage use a minion of readPage, so&lt;br/&gt;
  getEmbryonicPage can take advantage of the recovery machinery as&lt;br/&gt;
  well (it previously did a direct call to readFull, which made it&lt;br/&gt;
  vulnerable to being interrupted; this was also seen on Windows.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Unfortunately, the latter could lead to deadlocks, because when&lt;br/&gt;
  getEmbryonicPage is called from writeRAFHeader, the thread has a&lt;br/&gt;
  lock on &quot;this&quot;.  If another thread is has been interrupted and is&lt;br/&gt;
  about to do recovery, it would get stuck on waiting for the monitor&lt;br/&gt;
  on &quot;this&quot;, while the getEmbryonicPage reader would get stuck on&lt;br/&gt;
  waiting on recovery to finish. To solve this, I had to let reads&lt;br/&gt;
  from getEmbryonicPage throw an internal exception so it can back out&lt;br/&gt;
  and release the monitor on &quot;this&quot; (in RAFContainer#clean), and do a&lt;br/&gt;
  retry from that level.&lt;/p&gt;

&lt;p&gt;The patch is just a snapshot of my experiments, only intended so&lt;br/&gt;
people could comment on the approach. &lt;/p&gt;</comment>
                            <comment id="12918977" author="dagw" created="Thu, 7 Oct 2010 18:16:19 +0100"  >&lt;p&gt;Now, heading back to Solaris after having flushed out NIO issues on Windows, I see that Derby falls over when it gets interrupted&lt;br/&gt;
during transaction abort (XSTB0), as a result of receving an interrupt during a log flush wait(LogToFile.java:4048). I saw this using InterruptedTest in the patch. The test tries to reconnect (reboot), but eventually I can no longer get a connection, because I  hit a NullPointerException in BaseDataFileFactory.java:639 (containerCache empty??). Cf enclosed xsbt0.log.&lt;/p&gt;</comment>
                            <comment id="12919286" author="dagw" created="Fri, 8 Oct 2010 15:10:02 +0100"  >&lt;p&gt;Uploading a revised experimental patch, derby-4741-nio-container+log+waits, which intercepts and saves away interrupts in &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LogToFile#flush, when a thread is waiting for another thread to flush the log.&lt;/li&gt;
	&lt;li&gt;BasePage#setExclusive (2 places)&lt;/li&gt;
	&lt;li&gt;BasePage#setExclusiveNoWait&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It also fixes a bug in NIO getEmbryonicPage; the new implementation tried to decrypt when reading the embryonic page if the database were encrypted.&lt;/p&gt;

&lt;p&gt;With these changes in place, the next issue that I sometime see is that we can get interrupted waiting for a lock.&lt;/p&gt;

&lt;p&gt;java.lang.InterruptedException&lt;br/&gt;
	at java.lang.Object.wait(Native Method)&lt;br/&gt;
	at org.apache.derby.impl.services.locks.ActiveLock.waitForGrant(ActiveLock.java:118)&lt;br/&gt;
	at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(ConcurrentLockSet.java:469)&lt;/p&gt;

&lt;p&gt;In turn this led to continual failure because I hit this ASSERT:&lt;/p&gt;

&lt;p&gt;at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:147)&lt;br/&gt;
at org.apache.derby.impl.services.locks.LockControl.addLock(LockControl.java:276)&lt;/p&gt;

&lt;p&gt;Knut suggested to me we try to treat this situation similarly to how we handle lock time-outs and just throw an interrupted exception at safe place. Sounds good to me.&lt;/p&gt;</comment>
                            <comment id="12919335" author="mikem" created="Fri, 8 Oct 2010 18:51:51 +0100"  >&lt;p&gt;so far your approach seems fine to me, and I think will help a lot of customers.  I was wondering if&lt;br/&gt;
you have a high level goal.  Basically what should derby do when it encounters an interrupt.&lt;/p&gt;

&lt;p&gt;I think it should always throw some sort of error back to caller, and would be nice if the error or &lt;br/&gt;
the nested error indicated clearly that it is being thrown because of a thread interrupt.  Many times&lt;br/&gt;
when supporting this issue it takes awhile for the user to realize that they are the ones generating&lt;br/&gt;
the interrupt.&lt;/p&gt;

&lt;p&gt;I think the error should not be database level, and with your retry on I/O and log it seems like we&lt;br/&gt;
can avoid that.  I am not sure if it should be session or statement level,&lt;br/&gt;
I am leaning to it being session level, but would like to see a discussion.  I know often users are&lt;br/&gt;
doing the interrupt to stop a thread.  &lt;/p&gt;

&lt;p&gt;Ultimately do you plan on always reenabling the interrupt after retrying or getting to a safe place?&lt;/p&gt;

&lt;p&gt;We should definitely throw an error in the case of an interrupt during a lock wait, this seems like the&lt;br/&gt;
one valid case to send an interrupt to derby if a user thinks it is waiting too long.  Hopefully you can&lt;br/&gt;
code it to handle it, do processing, get to safe spot and then throw an error indicating a real user &lt;br/&gt;
interrupt during a wait.  &lt;/p&gt;

&lt;p&gt;Something to think about in the error throwing is the background thread.  What should we do if&lt;br/&gt;
it encounters an interrupt.  Throwing an error there might shutdown the db, i am not sure what it&lt;br/&gt;
does at top level with an error.&lt;/p&gt;
</comment>
                            <comment id="12919376" author="dagw" created="Fri, 8 Oct 2010 21:57:45 +0100"  >&lt;p&gt;Hi Mike, thanks for looking at this!&lt;/p&gt;

&lt;p&gt;&amp;gt; I was wondering if you have a high level&lt;br/&gt;
&amp;gt; goal. Basically what should derby do when it encounters an&lt;br/&gt;
&amp;gt; interrupt.&lt;/p&gt;

&lt;p&gt;I started off merely trying to make the new IO pieces stand up as well&lt;br/&gt;
as the old I/O, but I guess my ambitions grew a bit as I found many&lt;br/&gt;
things could bring Derby down..&lt;/p&gt;

&lt;p&gt;My thinking so far is that Derby should:&lt;/p&gt;

&lt;p&gt;a) avoid having to shut down if a thread has been interrupted&lt;/p&gt;

&lt;p&gt;b) throw &lt;b&gt;something&lt;/b&gt; when it finds the thread has been interrupted,&lt;br/&gt;
preferably as soon as possible, but not before the code has arrived at&lt;br/&gt;
a &quot;safe place&quot;, so we can avoid Derby shutting down.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think it should always throw some sort of error back to caller,&lt;br/&gt;
&amp;gt; and would be nice if the error or the nested error indicated clearly&lt;br/&gt;
&amp;gt; that it is being thrown because of a thread interrupt. Many times&lt;br/&gt;
&amp;gt; when supporting this issue it takes awhile for the user to realize&lt;br/&gt;
&amp;gt; that they are the ones generating the interrupt.&lt;/p&gt;

&lt;p&gt;Agreed. So far I have been thinking of just using the connection level error 08000,&lt;br/&gt;
wrapping the original NIO channel exception, or InterruptedException.&lt;br/&gt;
This should make it clear what has happened, and unwrapping the exception would &lt;br/&gt;
show where Derby detected it.&lt;/p&gt;


&lt;p&gt;&amp;gt; I think the error should not be database level, and with your retry&lt;br/&gt;
&amp;gt; on I/O and log it seems like we can avoid that. &lt;/p&gt;

&lt;p&gt;That&apos;s what I am trying to achieve, yes.&lt;/p&gt;

&lt;p&gt;&amp;gt; I am not sure if it should be session or statement level, I am&lt;br/&gt;
&amp;gt; leaning to it being session level, but would like to see a&lt;br/&gt;
&amp;gt; discussion. I know often users are doing the interrupt to stop a&lt;br/&gt;
&amp;gt; thread.&lt;/p&gt;

&lt;p&gt;The existing code throws session level error 08000 already in many&lt;br/&gt;
places, and I felt it&apos;s OK to require that the user reconnect when she&lt;br/&gt;
has done something as drastic as interrupting the thread &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; Ultimately do you plan on always reenabling the interrupt after&lt;br/&gt;
&amp;gt; retrying or getting to a safe place?&lt;/p&gt;

&lt;p&gt;I am still pondering this question. I &lt;b&gt;think&lt;/b&gt; that by the principle of&lt;br/&gt;
least surprise to the user, we should set the interrupted flag of the&lt;br/&gt;
thread again just before we throw the exception from the &quot;safe place&quot;.&lt;/p&gt;

&lt;p&gt;Note: the exisiting code does not resurrect the&lt;br/&gt;
thread&apos;s interrupted flag when it detects an interrupt of a wait and throws&lt;br/&gt;
StandardException.interrupt. (wait would have cleared the flag). &lt;/p&gt;

&lt;p&gt;An imminent problem is where would the &quot;safe place&quot; be? It would be&lt;br/&gt;
nice to &lt;b&gt;avoid&lt;/b&gt; having to check in all JDBC API methods before we&lt;br/&gt;
return if Derby has been interrupted during the API call, but I am not&lt;br/&gt;
yet sure if I am able to determine conclusively which API code paths&lt;br/&gt;
could lead to Derby being interrupted.. One approach would be to throw&lt;br/&gt;
as &quot;soon as possible&quot; from a &quot;safe place&quot; on the stack above the&lt;br/&gt;
method that saw the interrupt, but it may be hard to always determine&lt;br/&gt;
where that would be in all cases. I am open to suggestions here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The current experimental patch mostly doesn&apos;t throw yet (I didn&apos;t get&lt;br/&gt;
that far) - it just makes a note that an interrupt was detected. Nor&lt;br/&gt;
does it resurrect the interrupted flag when it does throw - since I&lt;br/&gt;
was still torn on this.&lt;/p&gt;

&lt;p&gt;&amp;gt; We should definitely throw an error in the case of an interrupt&lt;br/&gt;
&amp;gt; during a lock wait, this seems like the one valid case to send an&lt;br/&gt;
&amp;gt; interrupt to derby if a user thinks it is waiting too&lt;br/&gt;
&amp;gt; long. Hopefully you can code it to handle it, do processing, get to&lt;br/&gt;
&amp;gt; safe spot and then throw an error indicating a real user interrupt&lt;br/&gt;
&amp;gt; during a wait.&lt;/p&gt;

&lt;p&gt;Yes, I am trying to do exactly that, agreed. &lt;/p&gt;

&lt;p&gt;I also would like interrupts on queries to be detected no later that&lt;br/&gt;
at the place where we check for query time-outs already,&lt;br/&gt;
cf. BasicNoPutResultSetImpl#checkCancellationFlag.&lt;/p&gt;

&lt;p&gt;&amp;gt; Something to think about in the error throwing is the background&lt;br/&gt;
&amp;gt; thread. What should we do if it encounters an interrupt. Throwing an&lt;br/&gt;
&amp;gt; error there might shutdown the db, i am not sure what it does at top&lt;br/&gt;
&amp;gt; level with an error.&lt;/p&gt;

&lt;p&gt;Right. A priori, I thought the most common use case would be user&lt;br/&gt;
threads getting interrupted, but I&apos;ll look into that. One approach&lt;br/&gt;
could be to shutdown, or possibly try to make it impervious and ignore&lt;br/&gt;
all interrupts..&lt;/p&gt;</comment>
                            <comment id="12919402" author="dagw" created="Fri, 8 Oct 2010 23:46:12 +0100"  >&lt;p&gt;Uploading a new version of the experimental patch, derby-4741-nio-container+log+waits+locks,&lt;br/&gt;
which &lt;/p&gt;

&lt;p&gt;a) handles interrupts during lock wait&lt;br/&gt;
b) retries when LogToFile fails during call to switchLogFile#preAllocateNewLogFile&apos;s call to syncFile, which I also saw,&lt;br/&gt;
   but there are probably more places where logging can fail&lt;br/&gt;
 c) adds a &quot;lock&quot; argument to InterruptTest to test safe throws for a)&lt;/p&gt;

</comment>
                            <comment id="12919646" author="knutanders" created="Sun, 10 Oct 2010 20:06:07 +0100"  >&lt;p&gt;Thanks Dag. The proposed plan sounds good to me.&lt;/p&gt;

&lt;p&gt;As to what to do with the interrupt status after a retry, I&apos;d be happy as long as we always either fail or preserve the interrupt status. I don&apos;t have any strong opinions on whether or not we should set the interrupt flag when raising the exception. I see that the pre-NIO methods that may be interrupted (wait, sleep, join) will throw an exception and &lt;b&gt;clear&lt;/b&gt; the interrupt status, whereas the interruptible NIO methods will throw an exception and &lt;b&gt;set&lt;/b&gt; the interrupt status, so the precedence from the class library is ambiguous. I agree, though, that the user&apos;s intent is probably to stop the thread, and then preserving the interrupt status sounds reasonable in order to prevent that the thread just runs to the next blocking call and gets blocked there.&lt;/p&gt;</comment>
                            <comment id="12919805" author="dagw" created="Mon, 11 Oct 2010 13:47:52 +0100"  >&lt;p&gt;Thanks, Knut! I agree it&apos;s a bit weird that the JRE is a little schizophrenic about the interrupt flag. I think we should try to be consistent when we throw, no matter where/after which Java API call Derby detects it. If we do retain the interrupt flag, I think it adds to the argument for making the exception session-level, since the user would need to undertake some cleaning up anyway, or else the next Derby call would fail as well. Probably this would be the use case for connection pools. As to arguments for making the error statement level, I guess if one just wants to stop a run-away query, one would possibly prefer that just the statement failed.  A thing to consider here is the new JDBC 4.1 method Connection#abort:&lt;br/&gt;
This would be the future portable way of stopping a run-away transaction. It will also close the the connection.&lt;/p&gt;

&lt;p&gt;This patch passed regressions, for what it&apos;s worth.&lt;/p&gt;</comment>
                            <comment id="12920090" author="lilywei" created="Tue, 12 Oct 2010 06:00:42 +0100"  >&lt;p&gt;Thanks to Dag for fixing this bug. It will benefit a lot of customers. As for making the exception on either session-level or statement level, I will prefer to have it stop a run-away query and have the exception jut s statement failed. For most web application, it could be easier to rewrite the interrupt near statement than session perspective. &lt;br/&gt;
As test for nio+container+log+waits+locks, it also passed suites.all on my windows 7 machine. However, when running mailjdbc tests, the test got exception on Error 40XD1: Container was opened in read-only mode for Browsing thread, on Error &apos;-1:java.lang.ArrayIndexOutOfBoundsException&apos; for Backup Thread. &lt;br/&gt;
I am not totally sure why the different behavior for this patch. However, with derby-4741-nio-container+log patch, mailjdbc get deadlock exception. I am attach derby.log for reference point.&lt;/p&gt;</comment>
                            <comment id="12920177" author="dagw" created="Tue, 12 Oct 2010 13:55:58 +0100"  >&lt;p&gt;Hi Lily, thanks for test driving the patches &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Du you know if mailjdbc uses interrupts in any way? I&apos;ll try to run it myself, maybe some of the changes changed behavior even in the absence of interrupts. Btw, there are still many holes, I have found more places especially in the logging system that are vulnerable to&lt;br/&gt;
interrupts, so I am still building out the experimental patch.&lt;/p&gt;</comment>
                            <comment id="12920186" author="knutanders" created="Tue, 12 Oct 2010 14:33:38 +0100"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;There&apos;s some discussion about mailjdbc and interrupts on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3746&quot; title=&quot;java.sql.SQLException: The exception &amp;#39;java.lang.NullPointerException&amp;#39; was thrown while evaluating an expression.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3746&quot;&gt;DERBY-3746&lt;/a&gt;. The comments there seem to indicate that the test sometimes interrupts the worker threads.&lt;/p&gt;</comment>
                            <comment id="12920218" author="lilywei" created="Tue, 12 Oct 2010 15:24:27 +0100"  >&lt;p&gt;Hi Dag:&lt;br/&gt;
     Thank you. I am so exciting to help out testing and hope I can do more. Like Knut said, mailjdbc interrupts on Browse.java and more detail on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3746&quot; title=&quot;java.sql.SQLException: The exception &amp;#39;java.lang.NullPointerException&amp;#39; was thrown while evaluating an expression.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3746&quot;&gt;DERBY-3746&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4166&quot; title=&quot;improvements to the mailjdbc test&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4166&quot;&gt;&lt;del&gt;DERBY-4166&lt;/del&gt;&lt;/a&gt;, the portion of the code on Browse.java that call interrupt is: &lt;br/&gt;
				//Checking whether Refresh thread is running after doing Browse work&lt;br/&gt;
				//If Refresh is not running, interrupt the thread&lt;br/&gt;
				if (ThreadUtils.isThreadRunning(&quot;Refresh Thread&quot;)) &lt;/p&gt;
{
					MailJdbc.logAct.logMsg(&quot;******** Refresh is running&quot;);
				}
&lt;p&gt; else &lt;/p&gt;
{
					Refresh th = (Refresh) ThreadUtils
							.getThread(&quot;Refresh Thread&quot;);
					th.interrupt();
				}
&lt;p&gt;      Refresh thread and Brose thread are dealing with the same tables for mailjdbc application. I am also reading Derby151Test to see whether we should simplify the mailjdbc test to better fit testing this fix that will benefit a lot of customers. Thanks again. By the way, the read-only error on Browse thread and  ArrayIndexOutOfBoundsException from backup thread is from running mailjdbc with embedded server.&lt;/p&gt;</comment>
                            <comment id="12920225" author="dagw" created="Tue, 12 Oct 2010 15:51:52 +0100"  >&lt;p&gt;Thanks, Knut and Lily. &lt;br/&gt;
Ok, good to know that there is an interrupt involved when mailjdbc fails.  Lily, also please note that Derby151Test is its present form will probably change when I start to actually throw Derby exceptions when interrupts are detected. So far, they are mostly only noted in InterruptStatus (thread local) and normal operation continues. The latest patch has started to throw exceptions for interrupts while waiting for locks, though, cf. mods in LockSet.java/ConcurrentLockSet.java, since this seemed the obvious place to throw anyway.&lt;/p&gt;</comment>
                            <comment id="12920248" author="dagw" created="Tue, 12 Oct 2010 17:20:11 +0100"  >&lt;p&gt;Lily, I looked at derby.log: The stack trace you see first: &quot;ERROR 40XD1: Container was opened in read-only mode.&quot; seems to happen &lt;br/&gt;
while Derby is opening the conglomerate in the normal fashion and finds for some reason that it (or the directory) is not writable. It is not obvious to me that&lt;br/&gt;
this has to do with the patch, but it is not impossible, I suppose, since the patch does touch RAFContainer(4), e.g. by reopening the container if the channel has been closed by interrupts. But this seems to be a normal open, not a reopen called from RAFContainer4 (which is not on the stack).&lt;br/&gt;
Cf. RAFContainer#run, action OPEN_CONTAINER_ACTION, ca line 1447.&lt;/p&gt;

&lt;p&gt;I&apos;ll see if I can run the test myself and reproduced the error.&lt;/p&gt;</comment>
                            <comment id="12920357" author="dagw" created="Tue, 12 Oct 2010 22:35:25 +0100"  >&lt;p&gt;Attaching derby-4741-nio-container+log+waits+locks-2, which adds more interrupt recovery logic, mainly to LogToFile.java and LogAccessFile. With this version I have not yet been able to make crash the database (i.e. provoke a database level error) using the three run modes of InterruptedTest - default, i.e. write, read and lock, so we are gettting more resilient.&lt;/p&gt;

&lt;p&gt;Only interrupted lock waits are added as new Derby exception cases yet, I&apos;ll start looking into where to throw more seriously now. Indeed, some existing cases where we did throw in LogToFile, don&apos;t throw in the current patch, we just take a note and retry.&lt;/p&gt;</comment>
                            <comment id="12920751" author="dagw" created="Wed, 13 Oct 2010 21:24:35 +0100"  >&lt;p&gt;Lily, I ran mailjdbc test with my latest patch on Windows Vista for about 20 hours; I saw deadlocks, but not the read-only container error.&lt;br/&gt;
I did see several mysterious lines in derby.log, e.g.&lt;/p&gt;

&lt;p&gt;     &quot;not switching from an empty log file (870)&quot;&lt;/p&gt;

&lt;p&gt;similar to what you had in your derby.log. I have no experience with this test, so I don&apos;t know if this is normal for this test or a sign that something is wrong; I&apos;ll try to run the test without the patch and compare.&lt;/p&gt;</comment>
                            <comment id="12920769" author="dagw" created="Wed, 13 Oct 2010 22:16:06 +0100"  >&lt;p&gt;Re mailjdbc: It seems &quot;not switching from an empty log file&quot; in derby.log is normal for this test, at least I see it on trunk without the patch.&lt;/p&gt;</comment>
                            <comment id="12920790" author="lilywei" created="Wed, 13 Oct 2010 23:41:52 +0100"  >&lt;p&gt;Thanks Dag for spending time to look at mailjdbc. Yes, it is normal and I see it on trunk without the patch too. However, I haven&apos;t see the deadlock with the patch on my Windows 7 machine. I had been running 16 hours. It will be great for Derby if the deadlock is not normal. I will run more to see.&lt;/p&gt;</comment>
                            <comment id="12920830" author="dagw" created="Thu, 14 Oct 2010 03:11:37 +0100"  >&lt;p&gt;Uploading another experimental patch, derby-4741-nio-container+log+waits+locks+throws.&lt;/p&gt;

&lt;p&gt;The change now is &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;some further generalizing of recovery logic in RAFContainer4, the readPage logic was missing some stuff I had added for writePage&lt;/li&gt;
	&lt;li&gt;introduced InterruptTest#throwIf, which is a helper method to check &amp;amp; reset the thread&apos;s interrupt status and throw an SQLException (08000 for now) if set.&lt;/li&gt;
	&lt;li&gt;added throwIf next to Query timeout logic in BasicNoPutResultSetImpl#checkCancellationFlag&lt;/li&gt;
	&lt;li&gt;added throwIf before all returns in impl/jdbc/*.java in methods which call (directly or indirectly) handleException(t), typically this pattern:&lt;br/&gt;
       :&lt;br/&gt;
       InterruptTest#throwIf()&lt;br/&gt;
       return;&lt;br/&gt;
} catch (Throwable t) {&lt;br/&gt;
      throw handleException(t);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This will make sure Derby throws if it ever did see an interrupt during operation, which was intercepted for safety and postponed till a &quot;safe place&quot;. This is a &quot;catch-all&quot;, though, and I&apos;ll look for other  places closer to the&lt;br/&gt;
originating sites (container I/O, log I/O) so Derby could throw earlier. &lt;/p&gt;

&lt;p&gt;For example, commit can now throw if we see an interrupt during writing to log, cf. call to throwIf in EmbedConnection#commit.&lt;/p&gt;

&lt;p&gt;Currently all interrupts throw 08000 which is session level, and none yet set the thread&apos;s intr flag. I will go over all usages of 08000 and set the flag next if we agree that&apos;s the right thing to do. Note that Derby151Test fails now, but InterruptTest should work and report all interrupts Derby see (some interrupts happen while the test is in application code; this is called out in the test&apos;s results). Btw, InterruptTest is not yet a JUnit test..&lt;/p&gt;

&lt;p&gt;The patch is getting a bit large and unwieldy now, but not to worry, the patch is just a proof of concept, I&apos;ll break it down into smaller pieces before any proposed commit. Rerunning regressions.&lt;/p&gt;

&lt;p&gt;I see Lily would prefer statement level error, rather than session level. I am sticking to session level for now since that&apos;s what the exisiting 08000 currently is. I&apos;ll go over the remaining &lt;b&gt;existing&lt;/b&gt; usages of 08000 which I didn&apos;t already replace with &quot;InterruptStatus.setInterrupted&quot; + retry logic. If all are ok to replace, we could probably choose to change the exception to statement level rather than session level. If not, it might be confusing to have two kinds of SQLExceptions for interrupts, with different severity...&lt;/p&gt;
</comment>
                            <comment id="12920996" author="dagw" created="Thu, 14 Oct 2010 17:00:45 +0100"  >&lt;p&gt;Uploading the last patch again (derby-4741-nio-container+log+waits+locks+throws) - it had a small bug that broke LogSwitchFail.unit, fixed now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12920998" author="dagw" created="Thu, 14 Oct 2010 17:03:44 +0100"  >&lt;p&gt;A concern with additing the &quot;catch-all&quot; check is performance for fast API operations, like ResultSet#next, which usually only just fetches the next prefetched row (no I/O). I&apos;ll run some micro benchmarks to study if adding the interrupt check is too expensive in such a case.&lt;/p&gt;</comment>
                            <comment id="12921231" author="lilywei" created="Fri, 15 Oct 2010 06:08:47 +0100"  >&lt;p&gt;Thanks Dag for giving such details about each change. It definitely helps people like me to learn and understand more. The patch is getting big and complicated. However,  I run mailjdbc again the latest derby-4741-nio-container+log+waits+locks+throws, the test run into Error ERROR 40001: A lock could not be obtained due to a deadlock.  derby.log is attached for reference. Do we need InterruptException on synchronized (slaveRecoveryMonitor) in LogToFile.recover(...)?  Will change interrupt exception to statement level rather than session level require more code changes? Such as code in impl/store/raw/xact/* I was just thinking statement level is more user friendly to application users.&lt;/p&gt;</comment>
                            <comment id="12921418" author="dagw" created="Fri, 15 Oct 2010 17:00:10 +0100"  >&lt;p&gt;Hi Lily,&lt;/p&gt;

&lt;p&gt;thanks again for looking at this &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; However, I run mailjdbc again the latest&lt;br/&gt;
&amp;gt; derby-4741-nio-container+log+waits+locks+throws, the test run into&lt;br/&gt;
&amp;gt; Error ERROR 40001: A lock could not be obtained due to a&lt;br/&gt;
&amp;gt; deadlock. derby.log is attached for reference. &lt;/p&gt;

&lt;p&gt;Yes, I saw that such lock errors too after about 18 hours of so. I am&lt;br/&gt;
not yet sure they have anything to do with the patch changes, but I&lt;br/&gt;
can&apos;t rule it out. I don&apos;t know the test app well enough. If you have&lt;br/&gt;
any insight here which would indicate that locks should not occur&lt;br/&gt;
under normal operation, what would that be?  We could try to run the&lt;br/&gt;
patch without the changes I made to ActiveLock, ConcurrentLockSet and&lt;br/&gt;
LockSet, and see if the changes there have something to do with any&lt;br/&gt;
change of behaviour..&lt;/p&gt;

&lt;p&gt;&amp;gt; Do we need&lt;br/&gt;
&amp;gt; InterruptException on synchronized (slaveRecoveryMonitor) in&lt;br/&gt;
&amp;gt; LogToFile.recover(...)? &lt;/p&gt;

&lt;p&gt;I don&apos;t think I changed that part of the code. I see that an interrupt&lt;br/&gt;
is just ignored there, so I think we can safely add a call to&lt;br/&gt;
&quot;InterruptStatus.setInterrupted&quot; there as well, if that&apos;s what you&lt;br/&gt;
mean. &lt;/p&gt;

&lt;p&gt;Generally I have just been concentrating on &quot;normal operation&quot; yet, so&lt;br/&gt;
far I haven&apos;t yet looked into things like replication, backup,&lt;br/&gt;
export/import, or even LOB/CLOB streams yet. I suspect there may be&lt;br/&gt;
issues with interrupts happening during I/O in those areas as well.&lt;/p&gt;

&lt;p&gt;&amp;gt; Will change interrupt exception to statement&lt;br/&gt;
&amp;gt; level rather than session level require more code changes? Such as&lt;br/&gt;
&amp;gt; code in impl/store/raw/xact/* &lt;/p&gt;

&lt;p&gt;I don&apos;t know that for sure, but I suspected it might, the cleanup on&lt;br/&gt;
session termination just seemed safer and in line with what we already did&lt;br/&gt;
for interrupt exceptions. More investigation needed.&lt;/p&gt;

&lt;p&gt;&amp;gt; I was just thinking statement level is more user friendly to&lt;br/&gt;
&amp;gt; application users.&lt;/p&gt;

&lt;p&gt;Yes, I see that point. If we decide that&apos;s the way we would ultimately&lt;br/&gt;
like to go, I think I will still defer that to a next increment (maybe&lt;br/&gt;
a new JIRA issue?) of this work just to keep things simpler for now.&lt;/p&gt;</comment>
                            <comment id="12921420" author="dagw" created="Fri, 15 Oct 2010 17:06:40 +0100"  >&lt;p&gt;Running a micro benchmark to test the effect for adding InterruptStatus.throwIf to the APIs&lt;br/&gt;
were a bit inconclusive. With the latest patch, using the attached MicroAPITest.java (ca 6-7 runs), I saw a ca 2.5 &amp;amp; degradation of performance with just calls to ResultSet.next for a database that fits in memory.&lt;/p&gt;

&lt;p&gt;However, just adding the InterruptStatus.throwIf calls to the API &lt;b&gt;without&lt;/b&gt; the rest of the patch seemed to have no significant effect, so perhaps there are other parts of the patch that had made the operation somewhat slower, I&apos;ll try to incrementally remove parts of the patch and see what I find.&lt;/p&gt;</comment>
                            <comment id="12921740" author="knutanders" created="Sat, 16 Oct 2010 20:23:46 +0100"  >&lt;p&gt;I&apos;ve also tried the micro benchmark, but got somewhat different results. In 20 runs with a clean trunk and 20 runs with the derby-4741-nio-container+log+waits+locks+throws.diff patch in random order, clean trunk was on average 8.5% faster than the patched version (3.64 s/query vs 3.95 s/query).&lt;/p&gt;

&lt;p&gt;I ran the experiment with insane jars on OpenSolaris 2010.05 snv_134b and Java 1.6.0_18, and I had upped derby.storage.pageCacheSize to 12500.&lt;/p&gt;</comment>
                            <comment id="12921764" author="lilywei" created="Sat, 16 Oct 2010 22:35:55 +0100"  >&lt;p&gt;Thanks for the important finding. The result is hard on issues to keep Derby stand out from other Java database. I humbly believe Derby will keep on shining if performance can keep on improving. Do you have any suggestion in turn of fixing thread interrupts and keep performance no less than 3% slower than current clean trunk?&lt;/p&gt;</comment>
                            <comment id="12921987" author="knutanders" created="Mon, 18 Oct 2010 08:11:28 +0100"  >&lt;p&gt;Oops... Clean trunk wasn&apos;t 8.5% faster than the patched version. It was 7.8% faster. What I should have said, was that the patched version was 8.5% slower than clean trunk.&lt;/p&gt;

&lt;p&gt;I ran the micro benchmark through a profiler, but I didn&apos;t see anything there to explain a ~8% degradation. I did see more time spent in ThreadLocal.get() (no surprise there...), but only enough to explain one or two percent, roughly what Dag saw. I&apos;ll try to dig a little more.&lt;/p&gt;</comment>
                            <comment id="12922096" author="dagw" created="Mon, 18 Oct 2010 16:05:01 +0100"  >&lt;p&gt;Thanks for doing more measurements, Knut! It seems that even in the best case, the movePostion operation is negatively impacted with 1-2% due to the ThreadLocal access, which is not desirable.&lt;/p&gt;

&lt;p&gt;Knut mentioned that ContextService is already based on a ThreadLocal. I checked around a bit and found that we might be able to get rid of the InterruptStatus thread local check in the API methods in this way:&lt;/p&gt;

&lt;p&gt;If we were able to retrieve the lcc at the point where we detect the interrupts and save this fact in the lcc at that time, the cost of accessing a ThreadLocal variable would not be incurred unless AN INTERRUPT ACTUALLY HAPPENED.&lt;/p&gt;

&lt;p&gt;In the API methods, lcc is already available, and checking a boolean flag in the lcc instead of calling InterruptStatus#throwIf (which accesses a thread local) would be much cheaper.  I see we already sometimes do dig out the lcc in store level code, e.g. in store.access.DiskHashtable, in this way:&lt;/p&gt;

&lt;p&gt;    LanguageConnectionContext lcc   = (LanguageConnectionContext)&lt;br/&gt;
            ContextService.getContextOrNull(      // this call accesses a ThreadLocal&lt;br/&gt;
                LanguageConnectionContext.CONTEXT_ID);&lt;/p&gt;

&lt;p&gt;I&apos;ll look into this approach a bit.&lt;/p&gt;</comment>
                            <comment id="12922362" author="dagw" created="Tue, 19 Oct 2010 00:48:46 +0100"  >&lt;p&gt;The approach seems to work. This should take care of the performance worries for using InterruptStatus#throwIf in API methods.&lt;/p&gt;

&lt;p&gt;Sometimes there is no lcc, e.g when creating a new database; we could then fall back on the dedicated thread local variable, cf. during EmbedConnection constructor&apos;s call to createDatabase.&lt;/p&gt;

&lt;p&gt;Another note: undo is still vulnerable, e.g. an interrupt during rollback, usage of StorageRandomAccessFile in cf. Scan.java, cf.&lt;/p&gt;

&lt;p&gt;------------  BEGIN SHUTDOWN ERROR STACK -------------&lt;/p&gt;

&lt;p&gt;ERROR XSLA3: Log Corrupted, has invalid data in the log stream.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:279)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.log.Scan.getNextRecord(Scan.java:216)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.log.FileLogger.undo(FileLogger.java:939)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.xact.Xact.abort(Xact.java:949)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.xact.XactContext.cleanupOnError(XactContext.java:119)&lt;br/&gt;
	at org.apache.derby.iapi.services.context.ContextManager.cleanupOnError(ContextManager.java:333)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.cleanupOnError(TransactionResourceImpl.java:419)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:337)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2277)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1325)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1683)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(EmbedPreparedStatement.java:305)&lt;br/&gt;
	at InterruptTest$WorkerThread.run(InterruptTest.java:263)&lt;br/&gt;
Caused by: java.io.InterruptedIOException&lt;br/&gt;
	at java.io.RandomAccessFile.read(Native Method)&lt;br/&gt;
	at java.io.RandomAccessFile.readInt(RandomAccessFile.java:721)&lt;br/&gt;
	at java.io.RandomAccessFile.readLong(RandomAccessFile.java:758)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.log.Scan.getNextRecordBackward(Scan.java:394)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.log.Scan.getNextRecord(Scan.java:204)&lt;/p&gt;

&lt;p&gt;(roll-back happens here due to the test trying to insert a duplicate after a commit has been interrupted)&lt;/p&gt;</comment>
                            <comment id="12922370" author="dagw" created="Tue, 19 Oct 2010 01:01:12 +0100"  >&lt;p&gt;And we are vulnerable during (re)boot:&lt;/p&gt;

&lt;p&gt;java.sql.SQLException: Failed to start database &apos;interrupttest&apos; with class loader sun.misc.Launcher$AppClassLoader@2bbd86, see the next exception for details.&lt;br/&gt;
       :&lt;br/&gt;
Caused by: java.sql.SQLException: Failed to start database &apos;interrupttest&apos; with class loader sun.misc.Launcher$AppClassLoader@2bbd86, see the next exception for details.&lt;br/&gt;
       :&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;: java.io.InterruptedIOException&apos;.&lt;br/&gt;
       :&lt;br/&gt;
Caused by: java.io.InterruptedIOException&lt;br/&gt;
	at java.io.RandomAccessFile.readBytes(Native Method)&lt;br/&gt;
	at java.io.RandomAccessFile.read(RandomAccessFile.java:322)&lt;br/&gt;
	at java.io.RandomAccessFile.readFully(RandomAccessFile.java:381)&lt;br/&gt;
	at java.io.RandomAccessFile.readFully(RandomAccessFile.java:361)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.log.LogToFile.readControlFile(LogToFile.java:2693)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.log.LogToFile.boot(LogToFile.java:3398)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.boot(BaseMonitor.java:2020)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.TopService.bootModule(TopService.java:333)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.startModule(BaseMonitor.java:572)&lt;br/&gt;
	at org.apache.derby.iapi.services.monitor.Monitor.bootServiceModule(Monitor.java:427)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BaseDataFileFactory.bootLogFactory(BaseDataFileFactory.java:1747)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BaseDataFileFactory.setRawStoreFactory(BaseDataFileFactory.java:1235)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.RawStore.boot(RawStore.java:223)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.boot(BaseMonitor.java:2020)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.TopService.bootModule(TopService.java:333)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.startModule(BaseMonitor.java:572)&lt;br/&gt;
	at org.apache.derby.iapi.services.monitor.Monitor.bootServiceModule(Monitor.java:427)&lt;br/&gt;
	at org.apache.derby.impl.store.access.RAMAccessManager.boot(RAMAccessManager.java:1019)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.boot(BaseMonitor.java:2020)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.TopService.bootModule(TopService.java:333)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.startModule(BaseMonitor.java:572)&lt;br/&gt;
	at org.apache.derby.iapi.services.monitor.Monitor.bootServiceModule(Monitor.java:427)&lt;br/&gt;
	at org.apache.derby.impl.db.BasicDatabase.bootStore(BasicDatabase.java:760)&lt;br/&gt;
	at org.apache.derby.impl.db.BasicDatabase.boot(BasicDatabase.java:193)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.boot(BaseMonitor.java:2020)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.TopService.bootModule(TopService.java:333)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.bootService(BaseMonitor.java:1857)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.startProviderService(BaseMonitor.java:1723)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.findProviderAndStartService(BaseMonitor.java:1601)&lt;br/&gt;
	at org.apache.derby.impl.services.monitor.BaseMonitor.startPersistentService(BaseMonitor.java:1020)&lt;br/&gt;
	at org.apache.derby.iapi.services.monitor.Monitor.startPersistentService(Monitor.java:550)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.bootDatabase(EmbedConnection.java:2679)&lt;/p&gt;</comment>
                            <comment id="12922716" author="dagw" created="Tue, 19 Oct 2010 22:03:55 +0100"  >&lt;p&gt;I feel pretty confident the main approach will improve things  by now, so I&apos;ll upload a final version of the experimental patch, and the start producing incremental patches for commit roughly in the following order:&lt;/p&gt;

&lt;p&gt;a) hooks in the APIs to resurrect interrupt flags before we return to the user&apos;s app on the basis of info collected during operation, the new util class InterruptStatus, which is a collection of methods to save away and resurrect interrupt flags, and throw an interrupt SQLexception. I intend to &lt;b&gt;not&lt;/b&gt; throw any exception if the API method ran to completion, just resurrect the flag.&lt;br/&gt;
b) the modified RAFContainer4 stuff for reading and writing db cache pages safely with NIO.&lt;br/&gt;
c) the modified DirRandomAccessFile4 stuff + log retries for safe operation of log writing&lt;br/&gt;
d) stop execution if intr seen within a batch, when checking query timeout, and when seeing intr while waiting for locks&lt;br/&gt;
e) make undo safe&lt;br/&gt;
f) time permitting, make boot and recovery interrupt safe.&lt;/p&gt;

&lt;p&gt;Please let me know if there any objections or suggestions to this plan! Whether all this gets ready for 10.7 is a possible issue, but hopefully we should not behave worse the before at any step.&lt;/p&gt;
</comment>
                            <comment id="12922766" author="dagw" created="Tue, 19 Oct 2010 23:48:15 +0100"  >&lt;p&gt;A final version of the experimental patch, derby-4741-all+lenient+resurrect uploaded.&lt;br/&gt;
Main changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;use lcc to store interrupt status for a session thread. If not available fall back on a thread local.&lt;/li&gt;
	&lt;li&gt;resurrect the interrupt flag before returning to user app always, if we throw or not (see next item)&lt;/li&gt;
	&lt;li&gt;don&apos;t throw if an API operation ran to completion without trouble, even if we did see an interrupt flag&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The ad hoc InterruptTest and JUnit Derby151Test should run OK on both Solaris and Windows now.&lt;br/&gt;
The internal behavior is somewhat different since the JRE on Solaris throws InterrupedIOException in more cases, cf. &lt;a href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4385444&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4385444&lt;/a&gt;.&lt;/p&gt;

</comment>
                            <comment id="12923238" author="dagw" created="Thu, 21 Oct 2010 00:44:51 +0100"  >&lt;p&gt;Note to self: I have found a problem with the interrupt recovery of&lt;br/&gt;
RAFContainer4. Its call to openContainer needs to be protected by the&lt;br/&gt;
monitor on FileContainer#allocCache, because opening a container&lt;br/&gt;
evetually leads to a call on AllocationCache#reset. AllocCache javadoc&lt;br/&gt;
states that the the callers need to synchronize themselves since it is&lt;br/&gt;
itself not MT safe. &lt;/p&gt;

&lt;p&gt;Threads inside RAFContainer4#&lt;/p&gt;
{readPage, writePage}
&lt;p&gt; do not necessarily&lt;br/&gt;
own this monitor when recovery is attempted.&lt;/p&gt;

&lt;p&gt;I did once see a race condition due to this.  In the race condition, a&lt;br/&gt;
thread was trying to write to a new page and got a array out of bounds&lt;br/&gt;
exception inside AllocationCache.validate (numExtents was suddenly back to 0)&lt;br/&gt;
because another thread was doing interrupt recovery by calling&lt;br/&gt;
RAFContainer4#recoverContainerAfterInterrupt -&amp;gt;&lt;br/&gt;
openContainer -&amp;gt; ... -&amp;gt; AllocationCache#reset (unprotected).&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;edit add&amp;#93;&lt;/span&gt;:&lt;br/&gt;
Simply enveloping recoverContainerAfterInterrupt&apos;s call to openContainer in synchronized(allocCache) won&apos;t work: can lead to deadlock.&lt;/p&gt;</comment>
                            <comment id="12923367" author="knutanders" created="Thu, 21 Oct 2010 09:44:21 +0100"  >&lt;p&gt;I ran MicroAPITest with derby-4741-all+lenient+resurrect.diff (20 runs with each configuration, insane jars, pageCacheSize=12500). Now I only see a 1% degradation with the patch (p-value=0.07, according to the student t calculator at &lt;a href=&quot;http://www.bio.miami.edu/rob/Students_t.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.bio.miami.edu/rob/Students_t.html&lt;/a&gt;), so that definitely looks like a good improvement from the previous patch. I also modified the test so that it reused existing test data instead of creating it on every run. Then I didn&apos;t see any degradation. In fact, the results with the patch were 0.5% better than trunk when I ran the test that way.&lt;/p&gt;

&lt;p&gt;I also saw something similar with the previous patch. I saw an 8% degradation with the unmodified test, but the degradation was only about 2% with the modified test. This is also consistent with the findings Dag posted in the comment dated 15/Oct/10 12:06 PM, where he saw that the full patch gave a 2.5% degradation, whereas if he only applied the parts of the patch that were actually exercised during the data collection phase of the test, he didn&apos;t see any degradation.&lt;/p&gt;

&lt;p&gt;I don&apos;t know why the changes in the test setup code alters the result this way. The part of the test where we collect results should exercise the exact same code path with the two variants of the test. This reminds me of the effects we saw in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4233&quot; title=&quot;Lower tablescan performance right after database creation in 10.5&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4233&quot;&gt;&lt;del&gt;DERBY-4233&lt;/del&gt;&lt;/a&gt;, which were attributed to JIT at that time. I think the theory at that time was something like this: The just-in-time compiler collects statistics before it compiles the code and uses the statistics to optimize the generated native code. The more time we spend in the test setup code, the more the statistics will be biased towards the setup code. For this test, that could mean that the JIT-compiled native code is optimized for the insert code path, whereas we&apos;re really only interested in the select code path in the test. Furthermore, since the patch changes code on the insert code path, the collected statistics and the chosen optimizations may change, and that may ultimately affect how the select code is optimized, even if the select code path barely has been touched by the patch.&lt;/p&gt;</comment>
                            <comment id="12923457" author="lilywei" created="Thu, 21 Oct 2010 15:31:37 +0100"  >&lt;p&gt;I can confirm Knut&apos;s number for MicroAPITest .java in turn of 1-3% degradation or some case better with the derby-4741-all+lenient+resurrect.diff patch. Thanks for all the great work, Dag. A lot of customers will benefit from this.  Wow!!!&lt;/p&gt;

&lt;p&gt;It seems like we will throw an error back to the caller indicate they are the one generating the interrupt and we will throw an error in the case of an interrupt during a lock wait with this new approach. Will you elaborate on that in turn of the new patch behavior please? I am still having trouble understand the data flow perspective and would like to see some write out in turn of what exact error I will see from Derby . &lt;/p&gt;

&lt;p&gt;This is one of the comments you wrote to me. Sorry for getting back to you promptly.&lt;br/&gt;
&amp;gt;&amp;gt; Do we need  InterruptException on synchronized (slaveRecoveryMonitor) in &lt;br/&gt;
&amp;gt;&amp;gt; LogToFile.recover(...)? &lt;br/&gt;
&amp;gt;I don&apos;t think I changed that part of the code. I see that an interrupt &lt;br/&gt;
&amp;gt;is just ignored there, so I think we can safely add a call to &lt;br/&gt;
&amp;gt;&quot;InterruptStatus.setInterrupted&quot; there as well, if that&apos;s what you &lt;br/&gt;
&amp;gt;mean.&lt;br/&gt;
Yes, this is what I mean. And, I add it to my client space and run some tests. It seems not harming anything. I know you are concentrating on &quot;normal operation&quot; and it is &lt;b&gt;really&lt;/b&gt; a lot of work. Will we add a note somewhere about the code not cover for this interrupt handling? Such as: backup, &lt;br/&gt;
export/import, LOB/CLOB streams and replication for during I/O in those areas as well.&lt;/p&gt;

&lt;p&gt;I run Suites.all on windows and it is looking better than ever!!!&lt;/p&gt;</comment>
                            <comment id="12923678" author="dagw" created="Thu, 21 Oct 2010 23:48:09 +0100"  >&lt;p&gt;Hei Lily, thanks for your continued interest in this issue!&lt;/p&gt;

&lt;p&gt;&amp;gt; Will you elaborate on that in turn of the new patch behavior please?&lt;/p&gt;

&lt;p&gt;My present thinking is that the goal should be:&lt;br/&gt;
   a) the best user experience will be that for operations&lt;br/&gt;
      (technically JDBC API calls), which detect an interrupt, but&lt;br/&gt;
      manage to retry and continue the operation, and for which we do&lt;br/&gt;
      not cut the operation short, because there is no natural&lt;br/&gt;
      point at which to interrupt it, or we deem it to be so short in&lt;br/&gt;
      duration that we might as well see it through, we:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;do not throw an exception&lt;/li&gt;
	&lt;li&gt;restore the interruped status flag just prior to return from&lt;br/&gt;
        the operation (JDBC API call)&lt;br/&gt;
   b) for operations that we actually cut short due to the interrupt,&lt;br/&gt;
      see current enumeration below, we&lt;/li&gt;
	&lt;li&gt;throw SQLException 08000, session level (we might change this&lt;br/&gt;
        severity later as discussed)&lt;/li&gt;
	&lt;li&gt;also resurrect the interrupt status flag just prior to return&lt;br/&gt;
        from the operation (JDBC API call)&lt;br/&gt;
   c) for operations, which detect an interrupt, but&lt;br/&gt;
      manage to retry and continue the operation, but eventually throw&lt;br/&gt;
      an SQLException (not 08000, some other), we do as in a):&lt;/li&gt;
	&lt;li&gt;restore the interruped status flag just prior to return from&lt;br/&gt;
        the operation (JDBC API call)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   d) Operations that we  may currently cut short if we see an interrupt&lt;br/&gt;
      early enough:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;executeBatch (we check between each statement)&lt;/li&gt;
	&lt;li&gt;executeQuery (we check in the present&lt;br/&gt;
        BasicNoPutResultSetImpl#checkCancellationFlag in the same&lt;br/&gt;
        location that we check for timeout currently)&lt;/li&gt;
	&lt;li&gt;while waiting for a lock, cf. LockSet.java,&lt;br/&gt;
        ConcurrentLockSet.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Further suggestions for good places to check and throw are welcome &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; .. synchronized (slaveRecoveryMonitor): And, I add it to my client&lt;br/&gt;
&amp;gt; space and run some tests. It seems not harming anything.&lt;/p&gt;

&lt;p&gt;Good, we&apos;ll add it then.&lt;/p&gt;

&lt;p&gt;&amp;gt; Will we add a note somewhere about the code not cover for this&lt;br/&gt;
&amp;gt; interrupt handling? &lt;/p&gt;

&lt;p&gt;For the time being, we can make notes in this JIRA issue, but&lt;br/&gt;
eventually I suspect we will want to make a release note to describe&lt;br/&gt;
the improvements, and what remains to be done. You are right that&lt;br/&gt;
there is a lot of work, it is also hard to test, unfortunately.&lt;/p&gt;</comment>
                            <comment id="12923955" author="dagw" created="Fri, 22 Oct 2010 19:25:59 +0100"  >&lt;p&gt;Uploading a first rev of a patch for part a): derby-4741-a-01-api-interruptstatus&lt;br/&gt;
Regressions ran ok modulo a hang in BootLockTest.&lt;/p&gt;

&lt;p&gt;This patch contains the new helper class InterruptStatus and inserts calls to&lt;br/&gt;
restoreIntrFlagIfSeen in before API methods&apos; return and in the exception handling (TransactionResourceImpl#handleException).&lt;/p&gt;

&lt;p&gt;Execution of EmbedStatement#executeBatch check of interrupts and throws 08000 if seen between each statement in the batch.&lt;/p&gt;

&lt;p&gt;Note: Still, the machinery of InterruptStatus isn&apos;t used to save any interrupts, that follows in a later patch, so this patch doesn&apos;t change behavior. The focus here is on the correct placement of calls to&lt;br/&gt;
restoreIntrFlagIfSeen in the API.  Reviews appreciated!&lt;/p&gt;

&lt;p&gt;------------------------ Patch details:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;iapi.util.InterruptStatus: new helper class for keeping track of detected and&lt;br/&gt;
  postponed interrupts. See also its Javadoc.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LanguageConnectionContext&lt;br/&gt;
  GenericLanguageConnectionContext: &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Methods to set/reset threads interrupt status flag to allow us to clear the thread&apos;s actual flag temporarily, and to reset it when we return to the user application, possibly by throwing an interrupted SQLException (SQL state 08000) if we cut something short. It also contains methods to save and retrieve the stack frame at the point an interrupt was detected. This is used when we throw the interrupt exception. &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TransactionResourceImpl: resurrect the thread&apos;s interrupt status flag on SQL error (called from handleException). Use lcc if available, else thread local variable.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;EmbedBlob, for methods that call handleException inside synchronized on connection: use InterruptStatus.restoreIntrFlagIfSeen(lcc) before return&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;EmbedResultSet: for methods that call handleException inside synchronized on connection: use InterruptStatus.restoreIntrFlagIfSeen(lcc) before return&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;EmbedStatment: for methods that call handleException inside synchronized on connection: use InterruptStatus.restoreIntrFlagIfSeen(lcc) before return&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  In executeBatch, use throwIf between each statement in the batch: if we saw an interrupt, stop execution of batch. Note that if we do throw, restoreIntrFlagIfSeen will be called in the finally block, but it is idempotent, so no harm is done. It is necessary in case we saw an interrupt in the last statement of the batch.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;EmbedDatabaseMetaData: for methods that call handleException inside synchronized on connection: use InterruptStatus.restoreIntrFlagIfSeen(lcc) before return&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;EmbedPreparedStatement: for methods that call handleException inside synchronized on connection: use InterruptStatus.restoreIntrFlagIfSeen(lcc) before return&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;EmbedConnection.java: for methods that call handleException inside synchronized on connection: use InterruptStatus.restoreIntrFlagIfSeen(lcc) before return&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  For createDatabase, use InterruptStatus.restoreIntrFlagIfSeen() which inspects the thread local variable. This should catch I/O interrupts seen during the database creation phase.&lt;/p&gt;

&lt;p&gt;  Special handling in #close to make sure we access lcc while it is still available.&lt;/p&gt;</comment>
                            <comment id="12924451" author="lilywei" created="Mon, 25 Oct 2010 07:14:26 +0100"  >&lt;p&gt;Hi Dag:&lt;br/&gt;
     Thank you so much for the write out. All a, b, c, d points are very clear and straight forward. Personally, I like the fact we are checking interrupt at executeBatch, executeQuery, BasicNoPutResultSetImpl(same as timeout) and waiting for lock area. Thank you for add the synchronized (slaveRecoveryMonitor) and adding all the necessary release notes information.&lt;/p&gt;

&lt;p&gt;     I apply the derby-4741-a-01-api-interruptstatus. All the suites.all passed and timing for MicroAPITest is close to clean trunk. It also passed Derby151Test with interrupt check.  Mailjdbc is still having deadlock issue. However, like you said, it might or might not cause by the new change. I notice some of the interrupt code is in slight different places in Embed*.java with local initial null value. And, some of interrupt handling code are not in this patch than the previous patch. I am assuming those code are handling machinery of InterruptStatus that save interrupts and it will come in later patch.&lt;/p&gt;

&lt;p&gt;      I view this patch as it will benefit a lot of customers and love to help out if I can. Thank you so much for working so hard on this.&lt;/p&gt;</comment>
                            <comment id="12924571" author="dagw" created="Mon, 25 Oct 2010 15:23:57 +0100"  >&lt;p&gt;Hi Lily, thanks for test driving the patch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I really appreciate your help looking at this work. Having another set of eyes on this is good, the change are a bit cross cutting and affect much existing code, so it&apos;s good to have someone double checking the changes. Two comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if the mailjdbc test still deadlocks, I doubt it can be due to this patch, since it doesn&apos;t really change any behavior, it just installs the machinery for the behavior changes to come in later patches, as you presumed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the difference is EmbedBlob with local initial null is just some cruft from an experiment I did with trying to place restoreIntrFlagIfSeen in a finally block. This didn&apos;t work out since, error handling may close the connection and with it the lcc, so the check would happen too late. (The current method is to check before return and in the error handling code itself). I&apos;ll revert that change, thanks for noticing.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My main concern with this patch currently is to verify that I have found all the ways control can return to the user app after Derby code has had control, and possibly set the interrupt status flag. A case in point is the Blob methods that don&apos;t require a connection, e.g. EmbedBlob#getBytes if the lob is materialized, we call control.read: if we see an interrupt inside the read, the flag would get stored in a thread local variable, since there is no lcc, so I&apos;ll I need to add a call to no-args version of restoreIntrFlagIfSeen() there. EmbedClob needs analysis, too.&lt;/p&gt;</comment>
                            <comment id="12925452" author="dagw" created="Wed, 27 Oct 2010 18:00:09 +0100"  >&lt;p&gt;Uploading derby-4741-a-02-api-interruptstatus, an improved version of&lt;br/&gt;
a-01.&lt;/p&gt;

&lt;p&gt;I went over the usages of restoreIntrFlagIfSeen in the API and&lt;br/&gt;
reevaluated where it is possible to supply the lcc and where it is not&lt;br/&gt;
safe: the intention is that if we stored the interrupt status flag in&lt;br/&gt;
a lcc we should be recover it from there before returning to the user&lt;br/&gt;
app and, similarly, if we stored the interrupt status flag in a thread&lt;br/&gt;
local variable because an lcc was not available, we should recover it&lt;br/&gt;
from there. It turns out it is not always obvious to determine where to&lt;br/&gt;
look in the API methods.&lt;/p&gt;

&lt;p&gt;API methods vary with repect to whether they:&lt;/p&gt;

&lt;p&gt;    a) synchronize on the connection or not, cf. possible bugs&lt;br/&gt;
       see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4129&quot; title=&quot;jvm level Deadlock between 2 threads accessing the same connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4129&quot;&gt;DERBY-4129&lt;/a&gt;, even when accessing store.&lt;/p&gt;

&lt;p&gt;    b) call setupContextStack or not (this is what lets us find the&lt;br/&gt;
       lcc down in store using ContextService.getContextOrNull)&lt;/p&gt;

&lt;p&gt;    c) clean up when errors occur by calling handleInterrupt(t), cf my&lt;br/&gt;
       comment on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4129&quot; title=&quot;jvm level Deadlock between 2 threads accessing the same connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4129&quot;&gt;DERBY-4129&lt;/a&gt;, e.g. EmbedClob. The cleanup can lead to&lt;br/&gt;
       a connection closing if severity is high, setting its lcc to&lt;br/&gt;
       null.&lt;/p&gt;

&lt;p&gt;    d) even if an API method doesn&apos;t call setupContextStack, it may be&lt;br/&gt;
       called indirectly from a context that does set it up, cf.&lt;br/&gt;
       part of a trigger on an insert.&lt;/p&gt;

&lt;p&gt;When a connection (or database) is being closed down, we need to be&lt;br/&gt;
careful so that we catch the lcc while it is still available. When&lt;br/&gt;
cleaning up errors in TransactionResourceImpl#handleException we do&lt;br/&gt;
not directly know if an lcc is available or not.&lt;/p&gt;

&lt;p&gt;The upshot of all this is that unless we are sure we have a valid lcc&lt;br/&gt;
(i.e. we see statically that setupContextStack has been called), we&lt;br/&gt;
instead call restoreIntrFlagIfSeen &lt;b&gt;without&lt;/b&gt; an lcc argument. The&lt;br/&gt;
zero-arg variant calls getContextOrNull to see if a lcc is available&lt;br/&gt;
for the thread, falling back to the thread local if not. So, in&lt;br/&gt;
effect, the lcc variant is an optimization, but it does cover the&lt;br/&gt;
methods for which performance could be an issue, I think.&lt;/p&gt;

&lt;p&gt;The new patch covers LOB ands CLOB as well, and is ready for review.&lt;/p&gt;

&lt;p&gt;Regressions ran ok.&lt;/p&gt;</comment>
                            <comment id="12925674" author="dagw" created="Thu, 28 Oct 2010 04:34:49 +0100"  >&lt;p&gt;Uploading version a-03, minor and clerical changes only relative to a-02.&lt;/p&gt;</comment>
                            <comment id="12926841" author="lilywei" created="Mon, 1 Nov 2010 05:40:38 +0000"  >&lt;p&gt;When running MicroAPITest against a-03 patch, it is 45-48 seconds vs clean trunk 27-28 second. I noticed it is not using lcc but the earlier slower approach. Are you seeing the same slow windows performance again a-03 patch. &lt;/p&gt;</comment>
                            <comment id="12926998" author="dagw" created="Mon, 1 Nov 2010 14:54:54 +0000"  >&lt;p&gt;Thanks for test driving it, Lily. The new patch does use the lcc if available, it just falls back on the TL approach if not, so the performance drop was unexpected to me. I&apos;ll have a look, thanks for noticing. &lt;/p&gt;</comment>
                            <comment id="12927266" author="dagw" created="Tue, 2 Nov 2010 03:02:53 +0000"  >&lt;p&gt;Lily, did you with a sane or insane build? I see a large difference also (Solaris though) with sane (due to an expensive assert), but with insane is it very small (~&amp;lt;1%).&lt;/p&gt;</comment>
                            <comment id="12927284" author="lilywei" created="Tue, 2 Nov 2010 03:18:55 +0000"  >&lt;p&gt;Hi Dag: That is interesting. I was using sane build. Shouldn&apos;t sane build have similar performance as insane or they are usually having difference?&lt;/p&gt;</comment>
                            <comment id="12927345" author="knutanders" created="Tue, 2 Nov 2010 09:53:03 +0000"  >&lt;p&gt;The sane jars are not intended for production use, so I wouldn&apos;t worry too much about a performance loss that we only see with them. Unless it&apos;s getting so slow that it takes an unreasonably long time to run the regression tests with them, that is.&lt;/p&gt;

&lt;p&gt;I&apos;m guessing that the extra performance loss seen with sane jars is caused by the assert in InterruptStatus.restoreIntrFlagIfSeen(LanguageConnectionContext), which makes us look up the lcc in the context stack. Twice, actually. Perhaps it would help a little to store the result from getContextOrNull() in a local variable so that we get away with a single call. Or perhaps it&apos;s the unconditional string concatenation for the message text that&apos;s costly. In any case, that assert is the only place I can see that the patch would have a different performance impact on sane and insane.&lt;/p&gt;</comment>
                            <comment id="12927441" author="knutanders" created="Tue, 2 Nov 2010 14:45:23 +0000"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;I went through the a-03-api patch, and I couldn&apos;t spot anything that&lt;br/&gt;
you&apos;ve missed.&lt;/p&gt;

&lt;p&gt;There were quite a number of places to check the interrupt&lt;br/&gt;
status. More than what I had expected. But I cannot think of a better&lt;br/&gt;
place to short-circuit it, so... Except perhaps in EmbedConnection. It&lt;br/&gt;
looks to me like most of the calls to restoreIntrFlagIfSeen() happen&lt;br/&gt;
within try blocks right after calls to setupContextStack(). Did you&lt;br/&gt;
consider it as an option to move the restoreIntrFlagIfSeen() calls&lt;br/&gt;
into restoreContextStack(), which is already called in the finally&lt;br/&gt;
clauses at those places? That may make the code more contained, but&lt;br/&gt;
perhaps the LCC isn&apos;t easily available there?&lt;/p&gt;

&lt;p&gt;Apart from that, I only have some minor comments to the code in the&lt;br/&gt;
InterruptStatus class. Very minor, so feel free to ignore.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throwIf: Unnecessary return statement.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stackTrace: The initialValue() override does the same as the default&lt;br/&gt;
  implementation. So by just using a vanilla ThreadLocal object, we&apos;d&lt;br/&gt;
  get the exact same behaviour, and one less class in derby.jar +&lt;br/&gt;
  permgen. (If the footprint issue is important, the same might be&lt;br/&gt;
  said for receivedInterruptDuringIO if we change its usage from a&lt;br/&gt;
  TRUE/FALSE check to a null/non-null check. Actually, the presence of&lt;br/&gt;
  a stack trace is probably a good enough indicator in itself.)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Instead of creating an exception, fetching its stack trace and&lt;br/&gt;
  storing the trace, perhaps it would be easier just to store the&lt;br/&gt;
  exception? Then throwIf() could throw the stored exception instead&lt;br/&gt;
  of creating a new one and modifying its stack trace.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12927445" author="dagw" created="Tue, 2 Nov 2010 14:52:13 +0000"  >&lt;p&gt;Knut is right, that was the expensive assert I mentioned before (in sane builds). Since this is a micro benchmark that mainly measures the CPU neeeded to execute ResultSet.next when data is cached in memory, the effect of the assert shows up heavily. Running a profiling I saw the string concatenation there being dominant. No, I did not notice the regression test become slower, but if the turns out to be an issue, it is easy enough to comment out the asset. For now, I&apos;ll change the assert code to just call  getContextOrNull once.&lt;/p&gt;</comment>
                            <comment id="12927474" author="dagw" created="Tue, 2 Nov 2010 15:56:11 +0000"  >&lt;p&gt;Thanks for looking at the patch, Knut!&lt;/p&gt;

&lt;p&gt;&amp;gt; Except perhaps in EmbedConnection. It looks to me like most of the calls to restoreIntrFlagIfSeen() happen within try blocks right after calls to setupContextStack(). Did you consider it as an option to move the restoreIntrFlagIfSeen() calls into restoreContextStack(), which is already called in the finally clauses at those places?&lt;/p&gt;

&lt;p&gt;I did try to put the call into the finally,although not into restoreContextStack. I found that didn&apos;t always work, since during error handling &lt;b&gt;before&lt;/b&gt; we get to the finally block, calls to handleException(throwable) will depending on severity, potentially take down the connection (and database), causing us to lose the lcc.  Hence I had to move it back to just before normal return, and use the no-args variant of restoreIntrFlagIfSeen handling inside the error handling code (cf changes in TransactionResourceImpl#handleException).&lt;/p&gt;

&lt;p&gt;&amp;gt; - throwIf: Unnecessary return statement.&lt;/p&gt;

&lt;p&gt;Agreed, will fix that &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; - stackTrace: The initialValue() override does the same as the default implementation. So by just using a vanilla ThreadLocal object, we&apos;d get the exact same behaviour, and one less class in derby.jar + permgen.&lt;/p&gt;

&lt;p&gt;Agreed.&lt;/p&gt;

&lt;p&gt;&amp;gt;  (If the footprint issue is important, the same might be said for receivedInterruptDuringIO if we change its usage from a TRUE/FALSE check to a null/non-null check. Actually, the presence of a stack trace is probably a good enough indicator in itself.)&lt;/p&gt;

&lt;p&gt;Yes and yes. Originally I used the stacktrace just for debugging with sane, I think.&lt;/p&gt;

&lt;p&gt;&amp;gt; - Instead of creating an exception, fetching its stack trace and storing the trace, perhaps it would be easier just to store the exception? Then throwIf() could throw the stored exception instead of creating a new one and modifying its stack trace.&lt;/p&gt;

&lt;p&gt;That&apos;s good simplication, yes.&lt;/p&gt;</comment>
                            <comment id="12927588" author="dagw" created="Tue, 2 Nov 2010 20:54:32 +0000"  >&lt;p&gt;Uploading a revised patch, derby-4741-a-04-api-interruptstatus, which takes care of the comments. hopefully. Rerunning regressions.&lt;/p&gt;</comment>
                            <comment id="12927660" author="dagw" created="Tue, 2 Nov 2010 22:57:59 +0000"  >&lt;p&gt;Regressions ran ok. Will commit this version soon, if no misgivings emerge.&lt;/p&gt;</comment>
                            <comment id="12927797" author="knutanders" created="Wed, 3 Nov 2010 09:10:21 +0000"  >&lt;p&gt;Thanks for the changes and the explanations, Dag. I have no further comments to the a-04-api patch.&lt;/p&gt;

&lt;p&gt;One observation: After looking at the changes in EmbedBlob.getBytes(long,int) and EmbedBlob.position(), I understand why some people advocate that all methods should have a single exit point. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12927866" author="lilywei" created="Wed, 3 Nov 2010 14:41:23 +0000"  >&lt;p&gt;I test drive a-04-api patch as well. The sane MicroAPITest result is very good. I got result that is 5s - 7s. The insane result is similar to a-03-api which is around 45s--52s vs 27s-28s on clean trunk. However, like we discussed previous for MicroAPITest benchmark is only focus on CPU result and the slowdown is mostly on ASSERT. With so many things to take care of with 10.7 release. +1 to commit.&lt;/p&gt;</comment>
                            <comment id="12927970" author="dagw" created="Wed, 3 Nov 2010 19:42:21 +0000"  >&lt;p&gt;Committed derby-4741-a-04-api-interruptstatus as svn 1030630.&lt;/p&gt;</comment>
                            <comment id="12929885" author="dagw" created="Tue, 9 Nov 2010 01:56:13 +0000"  >&lt;p&gt;Uploading patch derby-4741-b-01-nio. This patch contains changes to&lt;br/&gt;
FileContainer/RAFContainer/RAFContainer4 to allow page IO to recover&lt;br/&gt;
from interrupts seen in RAFContainer4 (the NIO&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; version&lt;br/&gt;
specialization of RAFContainer). Additionally, some waits are changed&lt;br/&gt;
to retry after interrupts (yes, there are more of those in other&lt;br/&gt;
classes, that&apos;s for a later patch, but since I was in there anyway..)&lt;/p&gt;

&lt;p&gt;The main thrust of the patch is in RAFContainer4. Upon seeing&lt;br/&gt;
exceptions from IO (readPage/writePage), a thread will determine if it&lt;br/&gt;
is&lt;br/&gt;
        a) the thread that caused the channel to beclome closed, or&lt;br/&gt;
        b) it suffered an exceptions because another thread caused the&lt;br/&gt;
           channel to beclome closed.&lt;/p&gt;

&lt;p&gt;If a), the thread will recover by reopening the container before&lt;br/&gt;
reattempting IO, cf. the method recoverContainerAfterInterrupt. If b)&lt;br/&gt;
the thread will yield, wait and retry until the container has been&lt;br/&gt;
recovered, or a minute has passed. After a minute, we give up and&lt;br/&gt;
throw FILE_IO_INTERRUPTED. I chose a minute somewhat arbitrarily, it&lt;br/&gt;
is hopefully sufficient &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;The recovery thread and other waiting threads normally synchronize the&lt;br/&gt;
operations via variables protected by the channelCleanupMonitor&lt;br/&gt;
monitor (but see use of volatile and associated comments).&lt;/p&gt;

&lt;p&gt;The retry logic happens in one of three places, in increasing&lt;br/&gt;
closeness to RAFContainer4:&lt;/p&gt;

&lt;p&gt;    a) if the thread owns the monitor on allocCache and it is not the&lt;br/&gt;
       one that is doing recovery, it will back up to FileContainer&lt;br/&gt;
       before retrying the IO, since it has to release the lock on&lt;br/&gt;
       allocCache, because that monitor is needed by the thread doing&lt;br/&gt;
       recovery. Cf. changes in FileContainer.  If the thread holds&lt;br/&gt;
       allocCache, it goes into stealth mode in readPage/WritePage:&lt;br/&gt;
       this means that the recovery thread doesn&apos;t see it. We can&apos;t&lt;br/&gt;
       let a stealth mode thread grab channelCleanupMonitor, as this&lt;br/&gt;
       could cause a dead-lock. In c) the recovery thread keeps track&lt;br/&gt;
       of other threads, waking them up when recovery is done.&lt;/p&gt;

&lt;p&gt;    b) if the thread owns the monitor on &quot;this&quot;, again the thread goes&lt;br/&gt;
       into stealth mode. If it is not the one to clean up, it will&lt;br/&gt;
       back up to RAFContainer#clean&apos;s loop, since it has to release&lt;br/&gt;
       the lock on &quot;this&quot;, because that monitor is also needed by the&lt;br/&gt;
       thread doing recovery. This only ever happens for readPage (not&lt;br/&gt;
       writePage), cf. call to getEmbryonicPage in WriteRAFHeader&lt;br/&gt;
       called from RAFContainer#clean.&lt;/p&gt;

&lt;p&gt;    c) in other cases, the thread will call awaitRestoreChannel before&lt;br/&gt;
       reattempting IO.&lt;/p&gt;

&lt;p&gt;The logic of RAFContainer4#getEmbryonicPage has been folded into&lt;br/&gt;
readPage in order for it to be covered by the interrupt treatement.&lt;/p&gt;

&lt;p&gt;The test Derby151Test has been removed, since it is no longer&lt;br/&gt;
relevant. A new test, InterruptResilienceTest, fails without the&lt;br/&gt;
patch, but should work with the patch in place. It interrupts the&lt;br/&gt;
single app thread before doing IO, which will trip NIO and cause&lt;br/&gt;
recovery. Even though we have only one app thread, the test still&lt;br/&gt;
revealed concurrency issues during the development of this patch,&lt;br/&gt;
since RawStoreThread will also do IO on the container.&lt;/p&gt;

&lt;p&gt;A note on the implementation: Sun Java NIO code (including the&lt;br/&gt;
latest 1.6) has a bug which are worked around by the patch in two&lt;br/&gt;
places, cf. code comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;readFull/writeFull: if a thread has been interrupted,&lt;br/&gt;
         occasionally it closes the channel but does not throw,&lt;br/&gt;
         cf. &lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=6979009&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://bugs.sun.com/view_bug.do?bug_id=6979009&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;readPage/WritePage: sometimes the interrupted thread throws&lt;br/&gt;
         the wrong exception: AsynchronousCloseException instead of&lt;br/&gt;
         the more specialized ClosedByInterruptException.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Note: DirRandomAccessFile4 also contain use of NIO, I&apos;ll address&lt;br/&gt;
that in a later patch.&lt;/p&gt;

&lt;p&gt;I will also be adding more tests. A problem for making tests for&lt;br/&gt;
interrupts is to get coverage without making tests unstable, so I&apos;ll&lt;br/&gt;
wait until I have more holes plugged.&lt;/p&gt;

&lt;p&gt;Regressions worked earlier tonight in a slightly different version, rerunning now.&lt;/p&gt;
</comment>
                            <comment id="12930687" author="lilywei" created="Wed, 10 Nov 2010 18:10:13 +0000"  >&lt;p&gt;Hi Dag: Thank you so much for the continue effort to fix this issue. It will benefit a lot of customers and this is truly a hard bug/feature to fix. I am still trying to process the effect of FileContainer/RAFContainer/RAFContainer4. I don&apos;t quite understand it yet. The performance result for MicroAPITest is 5s-7s for insane build and 45s-47s for sane build. That&apos;s great. Regression can have failure on my windows environment: testPartialRowRTStats(Java exception: &apos;PermGen space: java.lang.OutOfMemoryError) or&lt;br/&gt;
 testReplicationt_Local_1_Indexing(java.sql.SQLException: DERBY SQL&lt;br/&gt;
 error: SQLCODE: -1, SQLSTATE: XJ041, SQLERRMC: Failed to create database &apos;c:\de&lt;br/&gt;
rby5\trunk\testall\db_master\wombat&apos;, see the next exception for details.::SQLST&lt;br/&gt;
ATE: XBM0JDirectory c:\derby5\trunk\testall\db_master\C:\derby5\trunk\testall\db&lt;br/&gt;
_master\wombat already exists. I run Suites.all three times, they all have similar failures. I can not reproduce if I run the test individually. Will this patch affect memory consumption? Will the timing change on cf cause java.sql.SQLException: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ041, SQLERRMC? I am not 100% sure. Or, they were just existing issues. For more multi thread purpose, I add to InterrupResilienceTest suite. If it is in the right direction, I can keep explore to make more other positive interrupt cases. Thanks Krisitan for the AbstractMTThread class.  I am so happy to work on this. Yeah!!!&lt;/p&gt;</comment>
                            <comment id="12930704" author="dagw" created="Wed, 10 Nov 2010 18:44:46 +0000"  >&lt;p&gt;Thanks, Lily, for looking at the latest patch. I agree the code is a bit tricky, so there could be bugs.  Feel free to ask detailed questions, I&apos;ll try to answer.&lt;/p&gt;

&lt;p&gt; I did not see any issue with testPartialRowRTStats when I ran the regressions, nor would I expect this patch for increase perm gen space since it doesn&apos;t add new classes. But we have seen that perm gen space can be an issue when running regressions. I think I recently upped my pergen space setting for suitesAll to 192m. I have also seen failures in the replication tests, there are some instabilities left, but I don&apos;t think they are due to this patch. &lt;/p&gt;

&lt;p&gt;You are right that the current test, InterruptResilienceTest, is pretty thin right now, but it does exercise the RAF recovery machinery with two concurrent threads (user thread and the raw store daemon).  &lt;/p&gt;

&lt;p&gt;I intend to make more tests; the trick is to make sure the tests actually exercise the code paths we want: just shooting interrupts at threads can land anywhere during execution, and Derby doesn&apos;t stand up to it in all places yet. I plan to use the SanityManager + a debug flag to simulate interrupt at selected places in the code. If  you have suggestions for good tests, please let&apos;s have them &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;</comment>
                            <comment id="12930913" author="lilywei" created="Thu, 11 Nov 2010 03:52:44 +0000"  >&lt;p&gt;For testing idea, SanityManager + a debug flag sound good. I am trying to picture how it can cover all the code we try to hit. I am assuming we want to hit code like RAFContainer4.readpage. The simple insert case to Blob and Clob data type can be hitting it like the InterruptResilienceTest does. Will BlobSetMethodTest or LobStreamTest do the trick? A far stretch will be utilizing CorruptRandomAccessFile. I am thinking out loud here. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12931129" author="knutanders" created="Thu, 11 Nov 2010 18:50:46 +0000"  >&lt;p&gt;I had a look at the b-01-nio patch, and it looked correct to me. The&lt;br/&gt;
stealth mode part wasn&apos;t entirely obvious, but the comments were&lt;br/&gt;
helpful and the code appears to be doing the right thing.&lt;/p&gt;

&lt;p&gt;As far as I can see, the code will behave the same way as before if no&lt;br/&gt;
interrupt is detected. So if there are problems with the code, they&lt;br/&gt;
will hopefully be limited to the case where the thread is&lt;br/&gt;
interrupted. There&apos;s an additional container-wide synchronization on&lt;br/&gt;
every page read/write, though, which may possibly have a negative&lt;br/&gt;
effect on performance in multi-threaded environments. If that turns&lt;br/&gt;
out to be an issue, would it be possible to change the code to only&lt;br/&gt;
check restoreChannelInProgress after an exception has been thrown,&lt;br/&gt;
similar to what we currently do in stealth mode?&lt;/p&gt;

&lt;p&gt;Some minor issues found in the patch:&lt;/p&gt;

&lt;p&gt;1) Thread.holdsLock() is a static method, but all calls to it are done&lt;br/&gt;
on Thread.currentThread().&lt;/p&gt;

&lt;p&gt;2) I think the checks for SQLState.INTERRUPT_DETECTED should use&lt;br/&gt;
getMessageId() instead of getSQLState(), since the SQLState interface,&lt;br/&gt;
despite its name, contains message ids and not SQLStates (although the&lt;br/&gt;
message id and the SQLState happen to be the same for this error).&lt;/p&gt;

&lt;p&gt;And since INTERRUPT_DETECTED is only intended to be used internally,&lt;br/&gt;
would it make sense, instead of giving INTERRUPT_DETECTED a proper&lt;br/&gt;
SQLState and also an entry in messages.xml (which will be picked up&lt;br/&gt;
and translated unnecessarily later), to create a subclass of&lt;br/&gt;
StandardException for this error? Something like what&apos;s done with&lt;br/&gt;
NoSpaceOnPage, I mean. That could also make the catch blocks used to&lt;br/&gt;
handle this condition a little bit tidier.&lt;/p&gt;

&lt;p&gt;3) Javadoc for RAFContainer4.readPage() should explain how the offset&lt;br/&gt;
parameter is supposed to be used (-1 for normal reads, actual offset&lt;br/&gt;
for embryonic pages)&lt;/p&gt;

&lt;p&gt;4) The variable &quot;whence&quot; in awaitRestoreChannel() does not seem to be&lt;br/&gt;
used. Nor is its &quot;pageNumber&quot; parameter, I think.&lt;/p&gt;</comment>
                            <comment id="12931137" author="knutanders" created="Thu, 11 Nov 2010 19:02:17 +0000"  >&lt;p&gt;And a note to others who consider reviewing the patch: I found that it was easier to see exactly what was being changed by running svn diff with the extra option &quot;--extensions=-bw&quot; to disregard whitespace changes in the parts of the code where an extra level of nesting was added.&lt;/p&gt;</comment>
                            <comment id="12931263" author="dagw" created="Thu, 11 Nov 2010 23:22:00 +0000"  >&lt;p&gt;Thanks for the review, Knut. Uploading a new version of the patch,&lt;br/&gt;
derby-4741-b-02-nio, details below, rerunning regressions.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In RAFContainer4, folded the cases for pageNumber == -1 (call from&lt;br/&gt;
  getEmbryonicPage) with the case Thread.holdsLock(this). This allows&lt;br/&gt;
  awaitRestoreChannel to throw the retry exception for all cases. I&lt;br/&gt;
  did both static and dynamic analysis to establish invariant, and&lt;br/&gt;
  added a sane check for it.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; As far as I can see, the code will behave the same way as before if no&lt;br/&gt;
&amp;gt; interrupt is detected. So if there are problems with the code, they&lt;br/&gt;
&amp;gt; will hopefully be limited to the case where the thread is&lt;br/&gt;
&amp;gt; interrupted. There&apos;s an additional container-wide synchronization on&lt;br/&gt;
&amp;gt; every page read/write, though, which may possibly have a negative&lt;br/&gt;
&amp;gt; effect on performance in multi-threaded environments. If that turns&lt;br/&gt;
&amp;gt; out to be an issue, would it be possible to change the code to only&lt;br/&gt;
&amp;gt; check restoreChannelInProgress after an exception has been thrown,&lt;br/&gt;
&amp;gt; similar to what we currently do in stealth mode?&lt;/p&gt;

&lt;p&gt;Yes, I believe we could do that, since it should do no harm to attempt&lt;br/&gt;
the IO even when recovery is in progress, because all calls to&lt;br/&gt;
getChannel are synchronized on &quot;this&quot; already, so either the thread&lt;br/&gt;
sees the old channel (closed), or the new reopened channel. I didn&apos;t&lt;br/&gt;
make this change yet, though, since the monitor hold should&lt;br/&gt;
short-lived (one boolean check and an integer increment) compared to&lt;br/&gt;
the IO.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Thread.holdsLock(): done&lt;/li&gt;
	&lt;li&gt;Created a new subclass of StandardException:&lt;br/&gt;
  InterruptDetectedException, good suggestion, indeed cleaner!&lt;/li&gt;
	&lt;li&gt;Javadoc for RAFContainer4.readPage: done&lt;/li&gt;
	&lt;li&gt;The variable &quot;whence&quot;: removed&lt;/li&gt;
	&lt;li&gt;Removed some commented out debugging cruft&lt;/li&gt;
	&lt;li&gt;Tuned the number of iterations in InterruptDetectedException to make&lt;br/&gt;
  sure we see a a concurrent thread (RawStoreDaemon) having to wait&lt;br/&gt;
  for cleanup before proceeding, at least on my box. Cf. the debug&lt;br/&gt;
  trace for derby.debug.true=RAF4Recovery, which I also added.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12931526" author="dagw" created="Fri, 12 Nov 2010 21:07:18 +0000"  >&lt;p&gt;Found that Derby uses interrupt to stop threads at shutdown&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;. The present logic in RAFContainer4 doesn&apos;t&lt;br/&gt;
take this into account, with the consequence that an application thread got stuck waiting for&lt;br/&gt;
a container recovery that never took place. We get an exception during execution of &lt;br/&gt;
                       closeContainer();&lt;br/&gt;
                        openContainer(currentIdentity);&lt;br/&gt;
If this exception is not due to an interrupt, we throw FILE_IO_INTERRUPTED. Unfortunately, in this case,&lt;br/&gt;
the present patch neglects to release any threads waiting for recovery to finish, so they are stuck waiting for &quot;restoreChannelInProgress&quot;.&lt;/p&gt;

&lt;p&gt;Saw this during suitesAll.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; BaseMonitor#shutdown &lt;del&gt;&amp;gt; notifyAllActiveThreads and in DatabaseContextImpl#cleanupOnError&lt;/del&gt;&amp;gt;notifyAllActiveThreads&lt;/p&gt;</comment>
                            <comment id="12931535" author="lilywei" created="Fri, 12 Nov 2010 21:39:52 +0000"  >&lt;p&gt;This might sound wired. I am so happy you got this. I woke up to a hanging test for Suites.All and now I know why. Thank you so much for posting this and looking into this. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12931984" author="lilywei" created="Mon, 15 Nov 2010 05:21:19 +0000"  >&lt;p&gt;Add the following code in ClosedChannelException block in RAFContainer4.java-&amp;gt;readPage and did not see any hang for Suites.All in Windows 7 enviornment:&lt;br/&gt;
               if (pageNumber != -1L) &lt;/p&gt;
{

                    // Recovery is in progress, wait for another interrupted thread
                    // to clean up.
                    awaitRestoreChannel(e, stealthMode);
                }
&lt;p&gt; else {&lt;br/&gt;
                    // Called from this.getEmbryonicPage.&lt;/p&gt;

&lt;p&gt;                    // Retry handled in RAFContainer#clean. This is&lt;br/&gt;
                    // necessary since recovery needs the monitor on &quot;this&quot;&lt;br/&gt;
                    // held by clean when it calls getEmbryonicPage via&lt;br/&gt;
                    // writeRAFHeader, so never call awaitRestoreChannel&lt;br/&gt;
                    // here, since then might be stuck on&lt;br/&gt;
                    // channelCleanupMonitor held by another thread&lt;br/&gt;
                    // cleaning up, while still hold onto &quot;this&quot;.&lt;/p&gt;

&lt;p&gt;                    if (stealthMode) &lt;/p&gt;
{
                        // don&apos;t touch threadsInPageIO
                    }
&lt;p&gt; else {&lt;br/&gt;
                        synchronized (channelCleanupMonitor) &lt;/p&gt;
{
                            threadsInPageIO--;
                        }
&lt;p&gt;                    }&lt;br/&gt;
                }&lt;/p&gt;</comment>
                            <comment id="12932148" author="dagw" created="Mon, 15 Nov 2010 19:01:14 +0000"  >&lt;p&gt;Uploading patch b-03 which adds logic to RAFContainer4 to handle&lt;br/&gt;
properly the fact that a container can&apos;t be reopened:&lt;/p&gt;

&lt;p&gt;    // In case the recovering thread can&apos;t successfully recover the container,&lt;br/&gt;
    // it will throw, so other waiting threads need to give up as well.  This&lt;br/&gt;
    // can happen at shutdown time when interrupts are used to stop threads.&lt;br/&gt;
    private boolean giveUpIO = false;&lt;br/&gt;
    private final Object giveUpIOm = new Object(); // its monitor&lt;/p&gt;

&lt;p&gt;We make sure to notify any waiting threads when the recovering thread gives up and throws FILE_IO_INTERRUPTED. The waiting threads will next see giveUpIO == true, and give up as well.&lt;/p&gt;

&lt;p&gt;This should make sure that threads not doing the recovery, will detect that recovery will not happen, and throw as well. SuitesAll finished successfully.&lt;/p&gt;</comment>
                            <comment id="12932150" author="dagw" created="Mon, 15 Nov 2010 19:06:59 +0000"  >&lt;p&gt;Lily, it seems you reintroduced some of the logic I folded into awaitRestoreChannel, but without throwing to get retry for the case pageNumber == 1 (throw INTERRUPT_DETECTED).  I don&apos;t think this is correct, not sure why this made a difference. Can you try the latest patch on Windows 7? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12933589" author="dagw" created="Thu, 18 Nov 2010 22:47:06 +0000"  >&lt;p&gt;I have now run regressions with patch b-03 on Windows Vista SP2 without errors. Since the 10.7 branch has been cut, I intend to commit this patch soon, and move on the the next piece of the puzzle.&lt;/p&gt;</comment>
                            <comment id="12933598" author="dagw" created="Thu, 18 Nov 2010 22:58:44 +0000"  >&lt;p&gt;For reviewers of b-03, it may be interesting note that running InterruptResilienceTest with the flag -Dderby.debug.true=RAF4Recovery&lt;br/&gt;
will likely give one or more instances of this trace in derby.log:&lt;/p&gt;

&lt;p&gt;DEBUG RAF4Recovery OUTPUT: derby.rawStoreDaemon thread needs to wait for container recovery: 0&lt;/p&gt;

&lt;p&gt;showing that this part of the multi threading synchronization is being exercised: The user that was interrupted is doing recovery on the channel so the&lt;br/&gt;
thread printing this (i.e. RawStoreDaemon) has to wait for recovery to complete to be able to move on.&lt;/p&gt;</comment>
                            <comment id="12933924" author="lilywei" created="Fri, 19 Nov 2010 19:18:15 +0000"  >&lt;p&gt;Hi Dag:&lt;br/&gt;
     Thank you so much for all the detail message. The code looks good to me. I don&apos;t see potential issue. When I run insane build, I got 5.8 second for MicroAPITest and 51.x second for sane build vs 5.07s(insane) and 47.xs(sane) build on clean trunk. It could be just Windows platform issue.  &lt;br/&gt;
      +1 to check in to trunk.&lt;/p&gt;</comment>
                            <comment id="12934082" author="dagw" created="Sat, 20 Nov 2010 02:26:30 +0000"  >&lt;p&gt;HI Lily! Thanks! I&apos;ll commit it soon after I have verified a debug trace for observing the effects of the giveUpIO logic.&lt;/p&gt;</comment>
                            <comment id="12935169" author="dagw" created="Wed, 24 Nov 2010 01:56:34 +0000"  >&lt;p&gt;Uploading b-04, which cleans up and adds some more debug tracing to RAFContainer4. &lt;/p&gt;</comment>
                            <comment id="12935172" author="dagw" created="Wed, 24 Nov 2010 02:03:25 +0000"  >&lt;p&gt;Committed b-04 as svn 1038440. Note: I changed the debug trace flag to &quot;RAF4&quot; to accommodate an exisiting trace not related to recovery.&lt;/p&gt;</comment>
                            <comment id="12964612" author="dagw" created="Mon, 29 Nov 2010 00:46:16 +0000"  >&lt;p&gt;This patch (derby-4741-c-01-nio) closes two corner cases I have&lt;br/&gt;
observed when stress testing the RAFContainer4 recovery mechanism. It&lt;br/&gt;
does some other small cleanups. Regressions ran OK.&lt;/p&gt;

&lt;p&gt;RAFContainer:&lt;/p&gt;

&lt;p&gt;If we receive an interrupt when the container is first being opened&lt;br/&gt;
(i.e. during RAFContainer.run (OPEN_CONTAINER_ACTION) -&amp;gt;&lt;br/&gt;
getEmbryonicPage), recovery will fail because currentIdentity needed&lt;br/&gt;
in RAFContainer4#recoverContainerAfterInterrupt hasn&apos;t yet been&lt;br/&gt;
set. &lt;/p&gt;

&lt;p&gt;RAFContainer4:&lt;/p&gt;

&lt;p&gt;If a stealthMode read is interrupted and is recovering the container,&lt;br/&gt;
it erroneously increments threadsInPageIO just before exiting to retry&lt;br/&gt;
IO. This leads to a break in the invariant that threadsInPageIO be 0&lt;br/&gt;
when all threads are done, causing issue (hang) down the line.  &lt;/p&gt;

&lt;p&gt;If, when we are reopening the container, the read being done during&lt;br/&gt;
that operation (getEmbryonicPage), that stealth mode read will also&lt;br/&gt;
lead to a (recursive) recovery. We have to catch this case by adding a&lt;br/&gt;
&quot;catch (InterruptDetectedException e)&quot; just after the call to&lt;br/&gt;
openContainer, not by testing the interrupt flag as presently done,&lt;br/&gt;
since the recovery inside the recursive call to&lt;br/&gt;
getEmbryonicPage/readPage will already have cleared the flag and done&lt;br/&gt;
recovery.&lt;/p&gt;

&lt;p&gt;When giving up reopening the container for some reason, we also forgot&lt;br/&gt;
to decrement threadsInPageIO.&lt;/p&gt;

&lt;p&gt;To guard against other hangs, I will make the while-true loops max out&lt;br/&gt;
in all cases. But before I commit that change, it would be nice to see&lt;br/&gt;
if this patch has any impact on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4920&quot; title=&quot;suites.All stuck in RAFContainer4.awaitRestoreChannel()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4920&quot;&gt;&lt;del&gt;DERBY-4920&lt;/del&gt;&lt;/a&gt; (I suspect not). The reason&lt;br/&gt;
I&apos;d like to hold off with that is that since &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4920&quot; title=&quot;suites.All stuck in RAFContainer4.awaitRestoreChannel()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4920&quot;&gt;&lt;del&gt;DERBY-4920&lt;/del&gt;&lt;/a&gt; occurs during&lt;br/&gt;
shutdown, that may mask the fact that recovery failed, cf. my comment&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4920?focusedCommentId=12936016&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12936016&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-4920?focusedCommentId=12936016&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12936016&lt;/a&gt;&lt;br/&gt;
So, I&apos;d rather wait with that till I get &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4920&quot; title=&quot;suites.All stuck in RAFContainer4.awaitRestoreChannel()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4920&quot;&gt;&lt;del&gt;DERBY-4920&lt;/del&gt;&lt;/a&gt;  out of the way.&lt;/p&gt;</comment>
                            <comment id="12964723" author="dagw" created="Mon, 29 Nov 2010 12:32:23 +0000"  >&lt;p&gt;Committed derby-4741-c-01-nio as svn 1040086. Please let me know if you still see the hang of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4920&quot; title=&quot;suites.All stuck in RAFContainer4.awaitRestoreChannel()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4920&quot;&gt;&lt;del&gt;DERBY-4920&lt;/del&gt;&lt;/a&gt; and, if possible, during execution which test it happens.&lt;/p&gt;</comment>
                            <comment id="12968724" author="kristwaa" created="Tue, 7 Dec 2010 13:31:25 +0000"  >&lt;p&gt;Happened to look at parts of the new code, and have a few questions/comments on code in RAF4Container:&lt;br/&gt;
 o in writeFull the variables beforeOpen and beforeInterrupt are unused. Can they be removed?&lt;br/&gt;
 o the same issue in readFull.&lt;br/&gt;
 o would it make sense to make the monitor object channelCleanupMonitor final?&lt;br/&gt;
 o redundant call to Thread.currentThread when invoking holdsLock.&lt;br/&gt;
 o missing JavaDoc for recoverContainerAfterInterrupt&lt;/p&gt;

&lt;p&gt;A more theoretical question at the end.&lt;br/&gt;
Is there a reason to explicitly define instance variables with the default value for the data type?&lt;br/&gt;
I.e., int i = 0, boolean b = false.&lt;br/&gt;
Just asking, as I find it annoying to step through these in the debugger &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12969019" author="dagw" created="Tue, 7 Dec 2010 21:40:14 +0000"  >&lt;p&gt;Thanks for looking at the new code, Kristian, I&apos;ll make a new patch to cater for your comments.&lt;/p&gt;

&lt;p&gt;&amp;gt; o in writeFull the variables beforeOpen and beforeInterrupt are unused. Can they be removed?&lt;br/&gt;
&amp;gt;  o the same issue in readFull.&lt;/p&gt;

&lt;p&gt;Absolutely, debugging cruft. Thanks for spotting those.&lt;/p&gt;

&lt;p&gt;&amp;gt;  o would it make sense to make the monitor object channelCleanupMonitor final?&lt;/p&gt;

&lt;p&gt;Absolutely.&lt;/p&gt;

&lt;p&gt;&amp;gt;  o redundant call to Thread.currentThread when invoking holdsLock.&lt;/p&gt;

&lt;p&gt;Thanks, thought I had cleaned out those, but there were two left!&lt;/p&gt;

&lt;p&gt;&amp;gt;  o missing JavaDoc for recoverContainerAfterInterrupt&lt;/p&gt;

&lt;p&gt;Added Javadoc for recoverContainerAfterInterrupt and awaitRestoreChannel.&lt;/p&gt;

&lt;p&gt;&amp;gt; A more theoretical question at the end.  Is there a reason to&lt;br/&gt;
&amp;gt; explicitly define instance variables with the default value for the&lt;br/&gt;
&amp;gt; data type?  I.e., int i = 0, boolean b = false.&lt;/p&gt;

&lt;p&gt;No. I tend to often use explicit initialization due to my paranoid&lt;br/&gt;
streak I guess. I see the data flow analysis barks if you use a local&lt;br/&gt;
variable uninitialized, although not for a class member, not clear to&lt;br/&gt;
me why Java differentiates here.&lt;/p&gt;

&lt;p&gt;public class Foo {&lt;br/&gt;
    public boolean bb;&lt;/p&gt;

&lt;p&gt;    public static void main(String[] args) {&lt;br/&gt;
        boolean b;&lt;/p&gt;

&lt;p&gt;        if (args.length &amp;gt; 0 &amp;amp;&amp;amp; args&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.equals(&quot;foo&quot;)) &lt;/p&gt;
{
            b = true;
        }

&lt;p&gt;        if (b) &lt;/p&gt;
{ // compiler barks
            System.err.println(&quot;b is true&quot;); 
        }

&lt;p&gt;        Foo f = new Foo();&lt;br/&gt;
        if (f.bb) &lt;/p&gt;
{ // OK
            System.err.println(&quot;bb is true&quot;);
        }

&lt;p&gt;    }&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;I guess I have tended to treat them the same. I&apos;ll try to improve &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

</comment>
                            <comment id="12969041" author="dagw" created="Tue, 7 Dec 2010 22:15:49 +0000"  >&lt;p&gt;Uploading derby-4741-kristians-01, running regressions.&lt;/p&gt;</comment>
                            <comment id="12969252" author="kristwaa" created="Wed, 8 Dec 2010 09:16:52 +0000"  >&lt;p&gt;Thanks, Dag.&lt;/p&gt;

&lt;p&gt;&amp;gt; I guess I have tended to treat them the same. I&apos;ll try to improve &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Not sure there is something to improve here, I guess this is a question about personal preference.&lt;br/&gt;
Explicit initialization of instance variables used to result in two assignments (first the default value for the type, and then the explicit value), which is kind of unnecessary if both assignments use the same value. I don&apos;t know if this is still the case.&lt;/p&gt;

&lt;p&gt;And I have become quite accustomed to use the &quot;Step over&quot; or &quot;Run to cursor&quot; in the debugger &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Finally, if the initial value isn&apos;t the default for the data type, then you have to assign the correct value anyway - either in the constructor or as an instance variable initializer (i.e. private int i = 3).&lt;/p&gt;


&lt;p&gt;Thanks for working on the interrupt issue! I think it is of great value for Derby to be able to handle interrupts better. This is especially important when/if other software products used together with Derby use Thread.interrupt() internally.&lt;/p&gt;</comment>
                            <comment id="12969530" author="dagw" created="Wed, 8 Dec 2010 22:24:45 +0000"  >&lt;p&gt;While I am looking for the Heisenbug in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4920&quot; title=&quot;suites.All stuck in RAFContainer4.awaitRestoreChannel()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4920&quot;&gt;&lt;del&gt;DERBY-4920&lt;/del&gt;&lt;/a&gt;, I am considering the next increment of this patch from the&lt;br/&gt;
prototype patch regarding the issues seen when interrupt hits the logging machinery (mostly not NIO, except for the case of DirRandomAccessFile#sync).&lt;br/&gt;
Now, it turns out that the vulnerability here only applies for Solaris. Other platforms&apos; &quot;non-NIO&quot; IO is not interruptible, so for those other platforms there is no need to do anything special. For Solaris, the behavior can be tweaked to be impervious to interrupts as well using the special switch: -XX:-UseVMInterruptibleIO on JVMs &amp;gt;= 1.5.0_12. This behavior will be default in 1.7 also on Solaris&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.&lt;br/&gt;
So the question becomes, would it be sufficient to advise users to run with this switch set, or should we make Derby tolerate&lt;br/&gt;
the interrupts on Solaris here also? &lt;/p&gt;

&lt;p&gt;I do think we should be able to run correctly with the default settings on all relevant platforms, but I would appricate your opinions.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4385444&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4385444&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12969576" author="dagw" created="Thu, 9 Dec 2010 00:36:22 +0000"  >&lt;p&gt;Committed derby-4741-kristians-01 as svn 1043802 (suitesAll ran ok).&lt;/p&gt;</comment>
                            <comment id="12969711" author="knutanders" created="Thu, 9 Dec 2010 12:16:04 +0000"  >&lt;p&gt;&amp;gt; So the question becomes, would it be sufficient to advise users to run with this switch set, or should we make Derby tolerate&lt;br/&gt;
&amp;gt; the interrupts on Solaris here also?&lt;/p&gt;

&lt;p&gt;How much code do you think will be needed to handle that case? Handling interrupts sent to the engine is somewhat of an edge case in itself. Since this particular problem only affects one platform, and that platform will start behaving the same way as the other platforms in the not so distant future, it sounds acceptable to just advise those who come across the problem to set the flag. Of course it would be nice if Derby was well-behaved by default on all platforms, but given the easy workaround and the expectation that the problem will soon go away by itself, I&apos;d say that it&apos;s probably not worth putting a lot of work into and/or adding more complexity to already complex code.&lt;/p&gt;</comment>
                            <comment id="12977533" author="dagw" created="Tue, 4 Jan 2011 23:38:53 +0000"  >&lt;p&gt;Thanks for your thoughts on this, Knut.&lt;/p&gt;

&lt;p&gt;Here is another issue: The NIO Channel#force call is used to implement sync when we flush the Derby log, cf. this call: &lt;/p&gt;

&lt;p&gt;LogToFile#flush -&amp;gt; LogAccessFile#syncLogAccessFile -&amp;gt; StorageRandomAccessFile#sync -&amp;gt; getChannel().force(false)&lt;/p&gt;

&lt;p&gt;The &quot;false&quot; here allows the skipping of flushing metadata, which makes this faster (at least on Solaris) than the non-NIO&lt;br/&gt;
implementation of StorageRandomAccessFile#sync, which uses getFD().sync().&lt;/p&gt;

&lt;p&gt;Unfortunately, an interrupt will make the getChannel().force call throw ClosedChannelException, and I can&apos;t see an easy way&lt;br/&gt;
to recover from this, except assuming the log is corrupt and shutting down the database instance, so we can recover on reboot.&lt;/p&gt;

&lt;p&gt;If we switch back to using &quot;getFD().sync()&quot;, we would lose the performance optimization, but be resilient to interrupts.&lt;/p&gt;

&lt;p&gt;So, unless somebody can see a way to finesse this problem, should be offer a knob to allow a user to trade this performance optimization for interrupt resilience?&lt;/p&gt;

&lt;p&gt;Aside: we also use StorageRandomAccessFile#sync in many other places, but in those situations I find I am able to recover by closing the RAF, reopening and writing over again, since the data to be written is known, e.g. in LogToFile#initLogFile. &lt;/p&gt;</comment>
                            <comment id="12977862" author="dagw" created="Wed, 5 Jan 2011 17:25:40 +0000"  >&lt;p&gt;I find that explicit file sync (i.e. not &quot;write sync&quot;) is only used if:&lt;/p&gt;

&lt;p&gt;a) NIO is not supported  (cf. WritableStorageFactory#supportsWriteSync), in which case we never use FileChannel#force&lt;br/&gt;
b) derby.storage.fileSyncTransactionLog is set to true&lt;br/&gt;
c) we are running on platforms/VMs that don&apos;t support opening a file with mask &quot;rws&quot; (write sync with metadata) and &quot;rwd&quot; (write sync without metadata), cf. check in LogToFile#openLogFileInWriteMode which calls checkJvmSyncError to determine this. The platforms mentioned are (e.g. early versions of 1.4.2 and 1.5 on Mac OS and FreeBSD).&lt;/p&gt;

&lt;p&gt;If this holds, it seems to be we can just skip using the NIO version of RAF#sync for those platforms. Other platforms do not use the explicit file sync for the log, cf. the test in LogToFile#flush (snip):&lt;/p&gt;

&lt;p&gt;    if (isWriteSynced)&lt;/p&gt;
    {
        //LogAccessFile.flushDirtyBuffers() will allow only one write
        //sync at a time, flush requests will get queued 
        logOut.flushDirtyBuffers();
    }
&lt;p&gt;    else&lt;/p&gt;
    {
        if (!logNotSynced)
        logOut.syncLogAccessFile();
    }

&lt;p&gt;On most platforms, isWriteSynced is true (cf above), meaning syncLogAccessFile is not used, so reverting to a interrupt safe, less performant non-NIO sync in syncLogAccessFile seems acceptable to me. Opinions?&lt;/p&gt;</comment>
                            <comment id="12977944" author="mikem" created="Wed, 5 Jan 2011 20:03:07 +0000"  >&lt;p&gt;I agree with the tradeoff you suggest concerning syncing the log file.  It seems to make the code easier and will not really affect most users running on modern platforms while still allowing those few to still work correctly on back releases.  This especially seems to make sense as I don&apos;t see us backporting this change so should only affect 10.8.&lt;/p&gt;</comment>
                            <comment id="12980163" author="dagw" created="Tue, 11 Jan 2011 16:21:49 +0000"  >&lt;p&gt;Thanks, Mike. Logged and fixed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4963&quot; title=&quot;Revert to FileDescriptor#sync from FileChannel#force to improve interrupt resilience&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4963&quot;&gt;&lt;del&gt;DERBY-4963&lt;/del&gt;&lt;/a&gt; to revert NIO version of RAF#sync.&lt;/p&gt;</comment>
                            <comment id="12980189" author="dagw" created="Tue, 11 Jan 2011 17:15:08 +0000"  >&lt;p&gt;Committed a followup patch as svn 1057733. Quoting the commit entry:&lt;/p&gt;

&lt;p&gt;&amp;gt; Followup to patch derby-4741-b-04-nio committed as svn 1038440:&lt;br/&gt;
&amp;gt; changed the string internal exception string &quot;nospc.U&quot; to &quot;intrp.U&quot;.&lt;/p&gt;</comment>
                            <comment id="12980831" author="dagw" created="Wed, 12 Jan 2011 17:56:23 +0000"  >&lt;p&gt;Uploading a patch derby-4741-sleeps-waits-1 which adds handling of some cases of interrupted monitor wait calls and Thread.sleep calls which I found needed changes to make my preliminary tests work. Running regressions.&lt;/p&gt;

&lt;p&gt;There are remaining places (i.e. usages for wait &amp;amp; sleep) in the code base which need to be inspected for modification.  I will be making one or more follow-up patches to handle those. With the current patch&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; this work is approaching a state where Derby embedded(**) is sufficiently robust against interrupts that I will move to buillding systematic as well as randomized tests, and plug remaining holes as we find them.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; After commits of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4967&quot; title=&quot;Handle interrupt received while waiting for database lock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4967&quot;&gt;&lt;del&gt;DERBY-4967&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4968&quot; title=&quot;Let query stop execution if an interrupt is seen, at same time as we check the query timeout&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4968&quot;&gt;&lt;del&gt;DERBY-4968&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
(**) the server code needs consideration too, as well as the client code and replication.&lt;/p&gt;</comment>
                            <comment id="12980984" author="dagw" created="Wed, 12 Jan 2011 22:50:08 +0000"  >&lt;p&gt;suites.All passed.&lt;/p&gt;</comment>
                            <comment id="12981932" author="dagw" created="Fri, 14 Jan 2011 21:29:14 +0000"  >&lt;p&gt;Some details on where patch derby-4741-sleeps-waits-1 changes things.&lt;/p&gt;

&lt;p&gt;The following locations where we earlier threw 08000 (CONN_INTERRUPT),&lt;br/&gt;
we now just note that an interrupt occurred:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;GenericStatement#prepare:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for another thread to complete the compilation of&lt;br/&gt;
    the statement&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;LogToFile&lt;br/&gt;
  #checkpointWithTran:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for another thread to complete a checkpoint&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #switchLogFile: &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for a semaphore needed to make sure the log switch&lt;br/&gt;
    can complete &quot;without having to give up the semaphore to a backup&lt;br/&gt;
    or another flusher&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #flush:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for the database to stop being frozen&lt;/li&gt;
	&lt;li&gt;while waiting for another thread flushing&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #syncFile&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting a bit before retrying a failed sync call&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #startLogBackup&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for a thread doing checkpointing before we start&lt;br/&gt;
    backup of log as part of online-backup&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The following locations previously silently swallowed the interrupt, we&lt;br/&gt;
now (also) note that an interrupt occurred:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;LogToFile&lt;br/&gt;
  #recover:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in slave replication mode, while waiting for fail-over. This code&lt;br/&gt;
    swallowed the interrupt&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #getLogFileAtBeginning:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in slave replication mode, while waiting for SlaveFactory to tell&lt;br/&gt;
    the thread to do recovery. This code swallowed the interrupt&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;BasePage:&lt;br/&gt;
  #setExclusive:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for an exclusive latch&lt;/li&gt;
	&lt;li&gt;while waiting for cleaner to finish&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #setExclusiveNoWait&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting for cleaner to finish&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12982135" author="lilywei" created="Sat, 15 Jan 2011 17:02:38 +0000"  >&lt;p&gt; #syncFile &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while waiting a bit before retrying a failed sync call&lt;br/&gt;
Should the comment change a little in turn of the &quot;does not matter...&quot;?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I run suites.all against ibm 1.6 jvm along with the LockInterruptTest.java (derby-4967-locking-2.diff) change, test run clean. &lt;/p&gt;</comment>
                            <comment id="12982189" author="dagw" created="Sun, 16 Jan 2011 00:06:45 +0000"  >&lt;p&gt;Thanks for test running the two patches, Lily.  Good to know these run on the IBM VM as well!&lt;br/&gt;
As for the comment, agreed. I have removed it in my next version of this patch, because it long longer seems to carry important information: earlier practice was to always throw, so then the comment highlighted &quot;unusual&quot; treatment. Now we mostly do not throw, just make a note, so this is code is no longer unusual as I see it. &lt;/p&gt;</comment>
                            <comment id="12983463" author="dagw" created="Wed, 19 Jan 2011 00:50:48 +0000"  >&lt;p&gt;Uploading a second version of derby-4741-sleeps-waits, rerunning regressions.&lt;/p&gt;

&lt;p&gt;Details on where patch derby-4741-sleeps-waits-2 adds things relative to version 1:&lt;/p&gt;

&lt;p&gt;The following locations previously silently swallowed the interrupt, we now (also) note that an interrupt occurred:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;LogAccessFile:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #flushDirtyBuffers:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting for another thread flushing&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #syncLogAccessFile:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While sleeping a bit before retrying after a failed sync&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  With the above, all the waits and sleeps in the package&lt;br/&gt;
  org.apache.derby.impl.store.raw.log have been made safe.&lt;/p&gt;

&lt;p&gt;The following locations where we earlier threw 08000 (CONN_INTERRUPT), we now just note that an interrupt occurred:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;XactFactory:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #blockBackup:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While doing backup blocking operations, we wait for backup to&lt;br/&gt;
    finish. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #blockBackupBlockingOperations:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting for all backup blocking operations to complete&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;BaseDataFileFactory:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #freezePersistentStore:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting for writes in progress to finishing before freezing.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #writeInProgress:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting for db thaw before we can start writing&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;CachedPage:&lt;br/&gt;
  #clean:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Waiting for another thread cleaning it&lt;/li&gt;
	&lt;li&gt;Waiting for state to become unlatched attempting to clean it&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;AsynchronousLogShipper:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #run:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If interrupted during the shipping interval wait, shipping sooner doesn&apos;t hurt&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #forceFlush:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting a bit after having flushed the master to ship log records to slave to free up buffer space&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ReplicationMessageReceive:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #isConnectedToMaster:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting for result from the ping thread (the &quot;pong&quot;). Since we may have been interrupted before the result is ready, we try again unless the connection is confirmed up.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  #SlavePingThread#run:  &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;While waiting for wakeup to do a ping.  I had to introduce an extra state variable here to decide whether after we receive an interrupt, a ping request has also been lodged.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12983697" author="knutanders" created="Wed, 19 Jan 2011 13:11:02 +0000"  >&lt;p&gt;Second revision of sleeps-waits looks good to me. A couple of questions:&lt;/p&gt;

&lt;p&gt;XactFactory.blockBackupBlockingOperations(): Remove RuntimeException from throws clause? The explanation added to the javadoc is probably enough for documentation purposes.&lt;/p&gt;

&lt;p&gt;RAFContainer4.java:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Why the change from noteAndClearInterrupt() to setInterrupted()?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Whitespace diff @@ -825,7 +819,7 @@ looks unintended&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ReplicationMessageReceive.java: The while loops are only retried if the wait() calls are interrupted, and not if the wait() calls experience spurious wakeups. Any reason for that? (Probably still an improvement compared to the original code, which didn&apos;t retry the wait call in any event.)&lt;/p&gt;</comment>
                            <comment id="12983935" author="dagw" created="Wed, 19 Jan 2011 23:38:52 +0000"  >&lt;p&gt;&amp;gt; XactFactory.blockBackupBlockingOperations(): Remove RuntimeException from throws clause? The explanation added to the javadoc is probably enough for documentation purposes.&lt;/p&gt;

&lt;p&gt;I&apos;m ok with that, I was torn on this.&lt;/p&gt;

&lt;p&gt;&amp;gt; RAFContainer4.java: Why the change from noteAndClearInterrupt() to setInterrupted()?&lt;/p&gt;

&lt;p&gt;Just simplification, since in these two locations we know that an interrupt actually did happen, there is no need to test for the flag as noteAndClearInterrupt does.&lt;/p&gt;

&lt;p&gt;&amp;gt;     - Whitespace diff @@ -825,7 +819,7 @@ looks unintended&lt;/p&gt;

&lt;p&gt;Indeed, thanks.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; ReplicationMessageReceive.java: The while loops are only retried if the wait() calls are interrupted, and not if the wait() calls experience spurious wakeups. Any reason for that? (Probably still an improvement compared to the original code, which didn&apos;t retry the wait call in any event.)&lt;/p&gt;

&lt;p&gt;Yes, I agree the original code is deficient in this repect, I have the code changed to handle this as well.&lt;/p&gt;</comment>
                            <comment id="12983937" author="dagw" created="Wed, 19 Jan 2011 23:47:22 +0000"  >&lt;p&gt;Uploading rev #3 of sleeps-waits, rerunning regressions.&lt;/p&gt;</comment>
                            <comment id="12984405" author="dagw" created="Thu, 20 Jan 2011 21:13:03 +0000"  >&lt;p&gt;Committed rev #3 as svn 1061516. This completes the cleanup of interrupt handling in Object#wait and Thread.sleep inside store.&lt;/p&gt;</comment>
                            <comment id="12984852" author="myrna" created="Fri, 21 Jan 2011 18:37:49 +0000"  >&lt;p&gt;I think the latest check-in has caused the following tinderbox failure:&lt;/p&gt;

&lt;p&gt;derbyall/storeall/storeall.fail:unit/T_RawStoreFactory.unit&lt;/p&gt;

&lt;p&gt;see: &lt;a href=&quot;http://dbtg.foundry.sun.com/derby/test/tinderbox_trunk16/jvm1.6/testing/testlog/SunOS-5.10_i86pc-i386/1061516-derbyall_diff.txt:&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dbtg.foundry.sun.com/derby/test/tinderbox_trunk16/jvm1.6/testing/testlog/SunOS-5.10_i86pc-i386/1061516-derbyall_diff.txt:&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;
					&lt;ul&gt;
						&lt;li&gt;
						&lt;ul&gt;
							&lt;li&gt;
							&lt;ul&gt;
								&lt;li&gt;
								&lt;ul&gt;
									&lt;li&gt;Diff file derbyall/storeall/storeunit/T_RawStoreFactory.diff&lt;/li&gt;
								&lt;/ul&gt;
								&lt;/li&gt;
							&lt;/ul&gt;
							&lt;/li&gt;
						&lt;/ul&gt;
						&lt;/li&gt;
					&lt;/ul&gt;
					&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
			&lt;li&gt;Start: T_RawStoreFactory jdk1.6.0_18 storeall:storeunit 2011-01-20 23:22:23 ***&lt;br/&gt;
2 del&lt;br/&gt;
&amp;lt; &amp;#8211; Unit Test T_RawStoreFactory finished&lt;br/&gt;
2 add&lt;br/&gt;
&amp;gt; ran out of time&lt;br/&gt;
&amp;gt; Exit due to time bomb&lt;br/&gt;
Test Failed.&lt;/li&gt;
			&lt;li&gt;End:   T_RawStoreFactory jdk1.6.0_18 storeall:storeunit 2011-01-21 00:22:54 ***&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It failed in the nightly runs with ibm 1.6 also (and 1.4.2 and 1.5).&lt;br/&gt;
Do we need a separate jira?&lt;/p&gt;</comment>
                            <comment id="12985033" author="dagw" created="Sat, 22 Jan 2011 01:58:43 +0000"  >&lt;p&gt;Uploading *-raf-stresstest-1, which adds a multi-threaded read/write test under an interrupt shower.&lt;br/&gt;
This exercises primarily the random access file recovery  (RAFContainer4#recoverContainerAfterInterrupt), but since the interrupt can arrive at any time during query execution, other parts of the code are also exposed. &lt;/p&gt;

&lt;p&gt;The new test case is InterruptResilienceTest#testRAFReadWriteMultipleThreads.&lt;/p&gt;

&lt;p&gt;Running regressions.&lt;/p&gt;

&lt;p&gt;The patch is not for commit yet, since I worry that the test takes too long to be included in the regression suite. During development I had to let it run this long to expose all the corner cases I have seen, but adding 250 seconds may be too much. I could comment out the client/server suite, since it doesn&apos;t add much value: the interrupt all happen on the server side. That  would cut the time down to ca half. Also, the test may not be entirely reliable yet, since there are remaining parts of the code yet to vetted wrt interrupt handling, but it runs reliably in my environment. I will at least run it on some more platforms before I suggest any commit.&lt;/p&gt;

&lt;p&gt;Please note that due to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4431&quot; title=&quot;implement INFORMATION_SCHEMA (ISO/IEC 9075-11)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4431&quot;&gt;DERBY-4431&lt;/a&gt;, the IBM VMs will not yet be covered by these additional tests.&lt;/p&gt;</comment>
                            <comment id="12985034" author="dagw" created="Sat, 22 Jan 2011 01:59:44 +0000"  >&lt;p&gt;Myrna, I will look into it. Filed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4982&quot; title=&quot;Retrying after interrupts in store pops a bug in derbyall/storeall/storeunit/T_RawStoreFactory in some cases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4982&quot;&gt;&lt;del&gt;DERBY-4982&lt;/del&gt;&lt;/a&gt; for this.&lt;/p&gt;
</comment>
                            <comment id="12986212" author="dagw" created="Tue, 25 Jan 2011 04:30:36 +0000"  >&lt;p&gt;Regrressions for *-raf-stresstest-1, and I verified that the modified InterruptResilienceTest works on Windows as well. For some reason it executed much more quickly under Windows, ca 50s (the reported 250 above was on Solaris). I&apos;ll see I can figure out why.&lt;/p&gt;</comment>
                            <comment id="12986347" author="knutanders" created="Tue, 25 Jan 2011 11:40:30 +0000"  >&lt;p&gt;Perhaps the difference is whether or not the OS will force changes to disk when doing synchronous writes?&lt;/p&gt;</comment>
                            <comment id="12986365" author="knutanders" created="Tue, 25 Jan 2011 12:42:49 +0000"  >&lt;p&gt;The use of the static field thisTest may have some consequences that are not entirely obvious:&lt;/p&gt;

&lt;p&gt;The field is set when the test suite is created, so when the tests start running it will always point to the last test case that was created, not necessarily to the running test case. That is, it will always point to a client test case. Because of this, one may be led to believe that the test that calls thisTest.openDefaultConnection() always uses client connections. However, BaseJDBCTestCase.openDefaultConnection() calls TestConfiguration.getCurrent() to get the current test configuration, so the connection type should be chosen dynamically based on the active decorators. But this assumption is also not quite true. The decorators only affect the TestConfiguration for the main thread, so when running inside a stored procedure in a server thread, the decorators will have no effect, and an embedded connection will be opened even if the test case is actually running within a client/server decorator.&lt;/p&gt;

&lt;p&gt;I think the intention is to always use embedded connections inside the stored procedure, and that&apos;s also what the code does (so, as mentioned in an earlier comment, there&apos;s probably not much point in running this test in client/server mode?). But it takes some effort to convince oneself that that&apos;s what it actually does. Do you think it&apos;s possible to make it more explicit that the worker threads always use embedded connections?&lt;/p&gt;

&lt;p&gt;And some little nits:&lt;/p&gt;

&lt;p&gt;+            if (w.e != null) &lt;/p&gt;
{
+                fail(&quot;WorkerThread &quot; + i + &quot; saw exception &quot; + w.e);
+            }

&lt;p&gt;Use the fail() method that takes an exception to preserve the stack trace?&lt;/p&gt;

&lt;p&gt;+        ResultSet rs = s.executeQuery(&quot;select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from mtTab&quot;);&lt;br/&gt;
+        rs.next();&lt;br/&gt;
+        assertEquals(&quot;too few rows inserted&quot;,&lt;br/&gt;
+                     rs.getLong(1), NO_OF_THREADS * NO_OF_MT_OPS);&lt;br/&gt;
+        rs.close();&lt;/p&gt;

&lt;p&gt;How do you know it must be too few and not too many? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; JDBC.assertSingleValueResultSet() could simplify this code.&lt;/p&gt;</comment>
                            <comment id="12986601" author="dagw" created="Tue, 25 Jan 2011 18:53:42 +0000"  >&lt;p&gt;Thanks for looking at this, Knut!&lt;br/&gt;
You are right, it got a bit convoluted. The intention is, as you suggest, to always embedded connections inside the stored procedure.&lt;br/&gt;
I&apos;ll see if I can simplify this a bit! I&lt;/p&gt;

&lt;p&gt; always agonize about whether to include c/s tests or not when the changes are seemingly embedded/server-side only, maybe we should try to establish some criteria to help us decide when to, and when not to do that.&lt;/p&gt;

&lt;p&gt;Thanks also for spotting the nits, I converted this from a stand-alone test outside JUnit, so it can be further simplied as you suggest.&lt;/p&gt;</comment>
                            <comment id="12986676" author="dagw" created="Tue, 25 Jan 2011 20:35:51 +0000"  >&lt;p&gt;Uploaded *raf_stresstest-2 which supersedes #1. In addition to fixing Knut&apos;s nits,&lt;br/&gt;
the server side code now uses a thread&apos;s default test configuration directly, and I also added a comment explaining this. I think I will commit the patch with the long running time for now. I&apos;d rather flush out any bugs here sooner rather than later. &lt;/p&gt;</comment>
                            <comment id="12986710" author="knutanders" created="Tue, 25 Jan 2011 21:58:20 +0000"  >&lt;p&gt;&amp;gt; I think I will commit the patch with the long running time for now. I&apos;d rather flush out any bugs here sooner rather than later.&lt;/p&gt;

&lt;p&gt;Sounds good. +1&lt;/p&gt;

&lt;p&gt;&amp;gt; I always agonize about whether to include c/s tests or not when the changes are seemingly embedded/server-side only&lt;/p&gt;

&lt;p&gt;I don&apos;t have a general rule, but in this particular case it looks like we run the entire test inside a stored procedure in order to make sure that only embedded is tested. Sounds like a good indication that embedded only would suffice... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; We could probably simplify the test somewhat and remove the stored procedure indirection too if we made it embedded only.&lt;/p&gt;</comment>
                            <comment id="12986809" author="dagw" created="Wed, 26 Jan 2011 01:47:48 +0000"  >&lt;p&gt;Uploading a revised version #3 which makes use of derby.system.durability=testing to cut down on the&lt;br/&gt;
running time on Solaris, I found it will still get to the corner cases.&lt;/p&gt;</comment>
                            <comment id="12987348" author="dagw" created="Thu, 27 Jan 2011 01:55:53 +0000"  >&lt;p&gt;Uploading version #4 (derby-4741-raf-stresstest-4). This lets the test run with its own database since we use durability=test: just to be on the safe side, so other tests don&apos;t get impacted by the fact that the database is thus marked, cf. message in derby.log:&lt;/p&gt;

&lt;p&gt;&quot;WARNING: The database is booted with derby.system.durability=test. In this mode, it is possible that database may not be able to recover, committed transactions may be lost, database may be in an inconsistent state. Please use this mode only when these consequences are acceptable&quot; (sic: no final period)&lt;/p&gt;

&lt;p&gt;I has to add a class.forName to DriverManagerConnector#getConnectionByAttributes and a new public method BasicJDBCTestCase#openDefaultConnection(TestConfiguration). The latter makes it possible use the main thread&apos;s test configuration in the server threads, cf. &quot;thisConfig&quot; member in InterruptResilienceTest.&lt;/p&gt;

&lt;p&gt;I also added derby.infolog.append=true to SystemPropertyTestSetup, so the c/s run doesn&apos;t clobber the embedded run&apos;s derby.log.&lt;/p&gt;

&lt;p&gt;Rerunning regressions.&lt;/p&gt;</comment>
                            <comment id="12987620" author="dagw" created="Thu, 27 Jan 2011 16:11:36 +0000"  >&lt;p&gt;Regressions ran ok, committed derby-4741-raf-stresstest-4 as svn 1064174.&lt;/p&gt;</comment>
                            <comment id="12987853" author="dagw" created="Fri, 28 Jan 2011 00:29:31 +0000"  >&lt;p&gt;Uploading a functional specification for this work to summarize what we have so far: &quot;interrupts-fs.html&quot;&lt;/p&gt;</comment>
                            <comment id="12989336" author="dagw" created="Tue, 1 Feb 2011 19:07:28 +0000"  >&lt;p&gt;Uploading a patch, *-testQueryInterrupt, which:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;adds a new test case: InterruptResilienceTest#testLongQueryInterrupt&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;which tests that a query will check for the interrupt flag and throw 08000 (CONN_INTERRUPT) at the same time is checks for query time-out.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;adds a missing test in InterruptStatus#throwIf&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I also adjusted an existing test (for RAF recovery) to handle the case that we could see 08000 (CONN_INTERRUPT) when performing a query as part of that test, depending on when the interrupt happens.&lt;/p&gt;

&lt;p&gt;Regressions passed.&lt;/p&gt;</comment>
                            <comment id="12989385" author="dagw" created="Tue, 1 Feb 2011 21:18:31 +0000"  >&lt;p&gt;Uploading a new version of the draft functional specification, version 0.2. Please have a look!&lt;/p&gt;</comment>
                            <comment id="12989410" author="dagw" created="Tue, 1 Feb 2011 22:15:27 +0000"  >&lt;p&gt;Uploading another patch *-testBatchInterrupt, which adds another fixture to InterruptResilienceTest: #testInterruptBatch, rerunning regressions.&lt;/p&gt;

&lt;p&gt;It tests that an interrupt will stop a batch of statements by throwing just before we execute the next statement in the batch.&lt;/p&gt;

&lt;p&gt;Note that this patch includes all of *.testQueryInterrupt also for logistics reason (that patch is not yet committed), but I will post a slimmed down version of this as soon as that one is in.&lt;/p&gt;</comment>
                            <comment id="12989913" author="dagw" created="Thu, 3 Feb 2011 00:09:38 +0000"  >&lt;p&gt;Committed patch derby-4741-testQueryInterrupt as svn 1066701.&lt;/p&gt;</comment>
                            <comment id="12989914" author="dagw" created="Thu, 3 Feb 2011 00:17:55 +0000"  >&lt;p&gt;Uploading version a slimmed-down version of *-testBatchInterrupt: derby-4741-testBatchInterrupt-b.&lt;/p&gt;</comment>
                            <comment id="12989916" author="dagw" created="Thu, 3 Feb 2011 00:21:03 +0000"  >&lt;p&gt;Committed derby-4741-testBatchInterrupt-b as svn 1066707.&lt;/p&gt;</comment>
                            <comment id="12991441" author="knutanders" created="Mon, 7 Feb 2011 16:21:46 +0000"  >&lt;p&gt;Thanks for writing up the functional spec, Dag. I found that it clearly explained the behaviour, and as far as I could see it matched what was actually implemented. It doesn&apos;t mention anything about how to handle the Solaris interruptible I/O issue on JVMs later than 1.6 (in which case there won&apos;t be an issue, right?), but that&apos;s probably intentional since 1.7 is still only available as early access?&lt;/p&gt;</comment>
                            <comment id="12991678" author="dagw" created="Mon, 7 Feb 2011 22:51:26 +0000"  >&lt;p&gt;Yes, you are right, Knut. I did omit reference to the 1.7 behavior on Solaris, but it might be good to include it in any case for completeness. After all Java 1.7 should be available before too long &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Thanks for reviewing the specification.&lt;/p&gt;</comment>
                            <comment id="12992159" author="rhillegas" created="Tue, 8 Feb 2011 20:29:34 +0000"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;Thanks for the functional spec. I am trying to wrap my mind around what application writers can expect. Is the following a fair summary?&lt;/p&gt;

&lt;p&gt;1) If the Thread is interrupted while running outside Derby (that is, not inside a JDBC call), then Derby does not field the interrupt. The Connection remains alive and Thread.isInterrupted() will not be touched by Derby.&lt;/p&gt;

&lt;p&gt;2) On the other hand, if the Thread is interrupted while running inside a Derby JDBC call...&lt;/p&gt;

&lt;p&gt;a) The Connection may be killed and have to be restarted. If the Connection is killed, then Thread.isInterrupted() will be true. &lt;/p&gt;

&lt;p&gt;b) Alternatively, it is also possible that the interrupt will not kill the Connection. In this case, the state of Thread.isInterrupted() is unclear to me. I am having a hard time reconciling &quot;will be still be set...when exiting from the Derby API method&quot; with &quot;it is not deterministic whether the flag will remain set or be cleared on return&quot;.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="12992279" author="dagw" created="Wed, 9 Feb 2011 01:32:40 +0000"  >&lt;p&gt;Thanks for reading the spec, Rick.&lt;/p&gt;

&lt;p&gt;1) Not true. If the flag is set at the time the Derby API call, Derby may throw. Derby can&apos;t know exactly when the thread was interrupted, it can only notice it by either a) seeing Java API methods return exceptions, or b) testing the flag explicitly. We do not test the flag on Derby API method entry. We heed (i.e. throw) interrupts in the specified situations enumerated in the spec.&lt;/p&gt;

&lt;p&gt;2b) The flag will remain set when exitting from in all cases. The note about deterministic only applies if the flag &lt;b&gt;is attemped cleared&lt;/b&gt; by another thread while the Derby API call is still executing. If we ever saw an interrupt and had to clear it to make execution continue, e.g. for NIO, we set it again at Derby API method exit, whether we throw or not. This means that any attempt to clear it while Derby is executing could be lost, depending on exactly when the clearing attempt was made, hence &quot;non-deterministic&quot;.&lt;/p&gt;</comment>
                            <comment id="12992498" author="rhillegas" created="Wed, 9 Feb 2011 14:26:03 +0000"  >&lt;p&gt;Thanks, Dag. Some follow-on questions:&lt;/p&gt;

&lt;p&gt;1) Suppose my application has two threads T1 and T2, each with its own Connection. T1 is busy interacting with the user and is NOT stalled inside a JDBC call. T2 is running inside a JDBC call. Now T2 is interrupted. Can this kill T1&apos;s Connection?&lt;/p&gt;

&lt;p&gt;2) Does this give rise to any advice for application writers?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12992811" author="dagw" created="Thu, 10 Feb 2011 00:36:21 +0000"  >&lt;p&gt;Hi Rick, &lt;br/&gt;
1) The answer is no. Only T2 risk seeing 08000. Nor would T1 risk it if it were inside a JDBC call, since this thread is not being interrupted.&lt;br/&gt;
2) Applications that expect to interrupt threads while they are executing JDBC calls should be prepared to receive a session level error with SQLState 08000, and so would need to reconnect in order to get more work done.&lt;/p&gt;</comment>
                            <comment id="12993182" author="rhillegas" created="Thu, 10 Feb 2011 19:29:23 +0000"  >&lt;p&gt;Thanks, Dag. Here is another attempt to summarize the user-visible behavior after these improvements.&lt;/p&gt;

&lt;p&gt;If an application experiences Thread interrupts, its designer should plan for the following behavior:&lt;/p&gt;

&lt;p&gt;1) If a Thread is interrupted inside a Derby JDBC call, then the Connection experiencing the interrupt MAY be terminated. If the Connection is terminated, the application will experience the following consequences:&lt;/p&gt;

&lt;p&gt;a) The JDBC call will raise a 08000 (CONN_INTERRUPT) exception.&lt;/p&gt;

&lt;p&gt;b) Outstanding transactional work on that Connection will be rolled back and all of its locks will be released.&lt;/p&gt;

&lt;p&gt;c) The Connection will not execute any further JDBC calls.&lt;/p&gt;

&lt;p&gt;d) On return from the interrupted JDBC call, the Thread&apos;s isInterrupted() method will report &quot;true&quot;.&lt;/p&gt;

&lt;p&gt;2) All other Connections will remain active. This includes other Connections which the interrupted Thread may be using.&lt;/p&gt;

&lt;p&gt;3) Application designers are advised to catch these 08000 exceptions, discard the dead Connection, and restart their transaction in a new Connection.&lt;/p&gt;</comment>
                            <comment id="12993282" author="dagw" created="Fri, 11 Feb 2011 00:38:18 +0000"  >&lt;p&gt;&amp;gt; 1) If a Thread is interrupted inside a Derby JDBC call, then the Connection experiencing the interrupt MAY be terminated. If the Connection is terminated, the application will experience the following consequences:&lt;/p&gt;

&lt;p&gt;To be even more precise: &quot;If a Thread is interrupted and the flag is not cleared before entering a Derby JDBC call &lt;b&gt;or&lt;/b&gt; the thread is interrupted while inside a Derby JDBC call, then the Connection experiencing the interrupt MAY be terminated. If the Connection is terminated, the application will experience the following consequences:&quot;&lt;/p&gt;

&lt;p&gt;&amp;gt; a) The JDBC call will raise a 08000 (CONN_INTERRUPT) exception.&lt;/p&gt;

&lt;p&gt;Yes&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; b) Outstanding transactional work on that Connection will be rolled back and all of its locks will be released.&lt;/p&gt;

&lt;p&gt;Yes&lt;/p&gt;

&lt;p&gt;&amp;gt; c) The Connection will not execute any further JDBC calls.&lt;/p&gt;

&lt;p&gt;Yes&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; d) On return from the interrupted JDBC call, the Thread&apos;s isInterrupted() method will report &quot;true&quot;.&lt;/p&gt;

&lt;p&gt;Yes. &lt;/p&gt;

&lt;p&gt;If Derby does not throw, the Thread&apos;s isInterrupted() method will also report &quot;true&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) All other Connections will remain active. This includes other Connections which the interrupted Thread may be using.&lt;/p&gt;

&lt;p&gt;Yes, at least until such time as the thread, still having its interrupted flag set, tries to use another connection, in which case, this connection is also subject to termination.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 3) Application designers are advised to catch these 08000 exceptions, discard the dead Connection, and restart their transaction in a new Connection. &lt;/p&gt;

&lt;p&gt;&lt;b&gt;And&lt;/b&gt; clear the interrupted flag of the thread before proceeding with another Derby connection, preferably!&lt;/p&gt;

&lt;p&gt;The &quot;MAY&quot; presently means: &lt;br/&gt;
    if a query fetches rows from a base table &lt;b&gt;after&lt;/b&gt; the interrupt has occurred, or&lt;br/&gt;
    a new element in a batched statement is attempted executed &lt;b&gt;after&lt;/b&gt; the interrupt has occurred, or&lt;br/&gt;
    an interrupt is received &lt;b&gt;while&lt;/b&gt; waiting for a lock.&lt;/p&gt;

&lt;p&gt;In other cases, it is ignored.&lt;br/&gt;
.&lt;br/&gt;
Note the slight difference above, between &lt;b&gt;after&lt;/b&gt; and &lt;b&gt;while&lt;/b&gt;. I have clarified this in a new revision.&lt;/p&gt;
</comment>
                            <comment id="12993283" author="dagw" created="Fri, 11 Feb 2011 00:44:13 +0000"  >&lt;p&gt;Uploading a new version of the func spec.&lt;/p&gt;</comment>
                            <comment id="12993494" author="rhillegas" created="Fri, 11 Feb 2011 14:01:56 +0000"  >&lt;p&gt;Thanks for the extra clarification, Dag. That will be useful for programmers who want to understand the code. I think we have a clear enough picture of the user experience that we can document this feature now. Thanks. &lt;/p&gt;</comment>
                            <comment id="12994415" author="mikem" created="Mon, 14 Feb 2011 18:49:53 +0000"  >&lt;p&gt;triaged for 10.8.&lt;/p&gt;

&lt;p&gt;A lot of progress has been made on this issue, and it looks ready for 10.8.  Work is being done incrementally, probably soon should close this one based on checked in work, and log a new one to track possible work post 10.8.&lt;/p&gt;</comment>
                            <comment id="12994578" author="dagw" created="Tue, 15 Feb 2011 00:03:08 +0000"  >&lt;p&gt;Uploading patch derby-4741-sleeps-waits-more. This patch contains the&lt;br/&gt;
rest of the code locations containg calls to Object#wait and&lt;br/&gt;
Thread#sleep that I intend to make interrupt proof for this issue. It&lt;br/&gt;
is not ready for commit, but please have a look. (I am still&lt;br/&gt;
considering a few more, including occurences in BasicDaemon.java).&lt;/p&gt;

&lt;p&gt;Also uploading the list of occurences I used as input:&lt;br/&gt;
wait-0-usages.txt, wait-1-usages.txt, sleep-1-usages.txt, annotated as&lt;br/&gt;
follows: &quot;v&quot; fixed or not relevant (e.g. test code), &quot;-&quot; I will not&lt;br/&gt;
change (not embedded Derby, cf. functional specification) and &quot;?&quot;&lt;br/&gt;
still pondering what to do (BasicDaemon).&lt;/p&gt;

&lt;p&gt;Regressions ran ok, although it doesn&apos;t say much, since most of the&lt;br/&gt;
changes only apply when interrupts happen.&lt;/p&gt;</comment>
                            <comment id="12996077" author="dagw" created="Thu, 17 Feb 2011 21:07:24 +0000"  >&lt;p&gt;Uploading version 0.4 of the functional specification. Adds items to the list of unmodified behavior.&lt;/p&gt;</comment>
                            <comment id="12996083" author="dagw" created="Thu, 17 Feb 2011 21:13:04 +0000"  >&lt;p&gt;Dev guide:&lt;/p&gt;

&lt;p&gt;&amp;gt; Do not use interrupt calls to notify threads that are accessing a&lt;br/&gt;
&amp;gt; database, because Derby will catch the interrupt call and close the&lt;br/&gt;
&amp;gt; connection to the database. Use wait and notify calls instead.&lt;/p&gt;

&lt;p&gt;This advice stands still, I think. The modal verb &quot;will&quot; is slightly&lt;br/&gt;
inaccurate here, it would be more correct to use &quot;could&quot; or&lt;br/&gt;
&quot;might&quot;. The functional specification spells this out in detail when&lt;br/&gt;
this can happen. &lt;/p&gt;

&lt;p&gt;Interrupts can now be used to stop long-running queries, batches and&lt;br/&gt;
statements that wait for database locks. In all cases, the connection&lt;br/&gt;
will be closed along with the exception seen (state 08000), cf the specification.&lt;/p&gt;</comment>
                            <comment id="12996091" author="chaase3" created="Thu, 17 Feb 2011 21:28:20 +0000"  >&lt;p&gt;Thanks! Does &quot;long-running&quot; apply to all three nouns (&quot;queries, batches and statements that...&quot;) or just the first?&lt;/p&gt;</comment>
                            <comment id="12998161" author="dagw" created="Wed, 23 Feb 2011 05:08:20 +0000"  >&lt;p&gt;Committed derby-4741-sleeps-waits-more as svn 1073595:&lt;/p&gt;

&lt;p&gt;Commit message:&lt;br/&gt;
Patch derby-4741-sleeps-waits-more, which &quot;regularizes&quot; a few more&lt;br/&gt;
instances of interrrupt handling to follow the idiom established in&lt;br/&gt;
this issue&apos;s patches. &lt;/p&gt;

&lt;p&gt;This leaves a few instances in BasicDaemon.java (as far as embedded&lt;br/&gt;
code is concerned), which will need more consideration. In any case,&lt;br/&gt;
interrupting the demon threads is less of a valid use case I believe,&lt;br/&gt;
i.e. Derby&apos;s ability to tolerate that is less crucial that tolerating&lt;br/&gt;
interrupts to the user&apos;s connection threads.&lt;/p&gt;</comment>
                            <comment id="12998165" author="dagw" created="Wed, 23 Feb 2011 05:11:49 +0000"  >&lt;p&gt;(reposting my answer from email here, since it didnt seem to make it to the JIRA issue)&lt;/p&gt;

&lt;p&gt;Kim&amp;gt; Does &quot;long-running&quot; apply to all three nouns (&quot;queries, batches and statements that...&quot;) or just the first?&lt;/p&gt;

&lt;p&gt;Good question. All: I guess the definition of &quot;long&quot; here is relative to&lt;br/&gt;
the applications expectations. The third one (locks) is limited upward&lt;br/&gt;
to the lock timeout for a single lock grab, but that may not be the&lt;br/&gt;
whole story since the statement may need further locks to complete. So&lt;br/&gt;
&quot;longer than expected&quot; is perhaps more to the point..&lt;/p&gt;</comment>
                            <comment id="12998246" author="knutanders" created="Wed, 23 Feb 2011 08:47:18 +0000"  >&lt;p&gt;The last commit (#1073595) seems to have introduced some dependency that breaks the build in the Tinderbox: &lt;a href=&quot;http://dbtg.foundry.sun.com/derby/test/tinderbox_trunk16/UpdateInfo/1073598-buildDetails.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dbtg.foundry.sun.com/derby/test/tinderbox_trunk16/UpdateInfo/1073598-buildDetails.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I am able to reproduce it if I explicitly point the jsr169compile.classpath property to Foundation + JSR-169 jars. I&apos;m not sure exactly what&apos;s causing it, but it looks like the iapi.types package now is compiled via the compile_mbeans target. That target uses compile.classpath, which is set to jsr169compile.classpath in build.xml, whereas the target that normally compiles SqlXmlUtil requires some extra XML libraries on the compile classpath.&lt;/p&gt;</comment>
                            <comment id="12998471" author="dagw" created="Wed, 23 Feb 2011 17:52:49 +0000"  >&lt;p&gt;I backed out a change to TopService.java until we understand how to make it build correctly in those circumstances.&lt;br/&gt;
svn 1073846. &lt;/p&gt;</comment>
                            <comment id="12998620" author="dagw" created="Wed, 23 Feb 2011 23:56:37 +0000"  >&lt;p&gt;Uploading a patch which reintroduces the fix that was backed out with changes to the build. Essentially it moves the compilation of MBeans out till after the iapis have been built. Thanks to Knut for pinpointing the feact that compilation of MBeans depends on Monitor, but is in fact compiled before the iapi currently. Setting the sourcepath for javac to &quot;&quot; for mbeans-compile highlighted the issue, cf this comment: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4845?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&amp;amp;focusedCommentId=12998479#comment-12998479&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-4845?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&amp;amp;focusedCommentId=12998479#comment-12998479&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Still,exactly why this makes it compile with explicit setting of jsr169compile.classpath now, whereas it did not before, is still a bit unclear to me. It seems to work now, though. Running regressions.&lt;/p&gt;</comment>
                            <comment id="12998923" author="lilywei" created="Thu, 24 Feb 2011 16:31:19 +0000"  >&lt;p&gt;It is not totally clear to me why setting for the sourcepath and jsr169compile.classpath make the build work on all the platforms. More explanation will help people like me. :-&lt;br/&gt;
Suites.all and derbyall run clean with derby-4741-fix-compilation.diff patch on my Windows 7. +1 for me to commit. Cheers and Thanks!&lt;/p&gt;</comment>
                            <comment id="12999701" author="dagw" created="Sat, 26 Feb 2011 03:08:40 +0000"  >&lt;p&gt;Hi Lily, it is not clear to me either &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; The dependencies in our&lt;br/&gt;
present compile is partly hard coded in the build.xml files, but that&lt;br/&gt;
is not the whole story. It seems that if the compiler notices it lacks&lt;br/&gt;
a class, it can check for it in the source path and compile it outside&lt;br/&gt;
the normal order to fulfill the dependency. Setting the classpath to&lt;br/&gt;
&quot;&quot; denies the compiler task this ability, forcing the hard coded&lt;br/&gt;
dependencies to be the unique determinants of compilation order. Knut&lt;br/&gt;
did an experiment to do that for most compiles, but it quickly turned&lt;br/&gt;
messy as far as I understood.&lt;/p&gt;

&lt;p&gt;Cf this quote from the javac task doc (&lt;a href=&quot;http://www.jajakarta.org/ant/ant-1.6.1/docs/en/manual/CoreTasks/javac.html):&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.jajakarta.org/ant/ant-1.6.1/docs/en/manual/CoreTasks/javac.html):&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&quot;If you wish to compile only files explicitly specified and disable&lt;br/&gt;
javac&apos;s default searching mechanism then you can unset the sourcepath&lt;br/&gt;
attribute:&lt;/p&gt;

&lt;p&gt;  &amp;lt;javac sourcepath=&quot;&quot; srcdir=&quot;$&lt;/p&gt;
{src}&quot;&lt;br/&gt;
         destdir=&quot;${build}&quot; &amp;gt;&lt;br/&gt;
    &amp;lt;include name=&quot;*&lt;b&gt;/&lt;/b&gt;.java&quot; /&amp;gt;&lt;br/&gt;
    &amp;lt;exclude name=&quot;**/Example.java&quot; /&amp;gt;&lt;br/&gt;
  &amp;lt;/javac&amp;gt;&lt;br/&gt;
&lt;br/&gt;
That way the javac will compile all java source files under &quot;${src}
&lt;p&gt;&quot;&lt;br/&gt;
directory but skip the examples. The compiler will even produce errors&lt;br/&gt;
if some of the non-example files refers to them. &quot;&lt;/p&gt;

&lt;p&gt;So far so good. I can&apos;t explain why setting jsr169compile.classpath&lt;br/&gt;
explicitly made things break though. I just fiddled with the placement&lt;br/&gt;
of the compilation of mbeans till it worked... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But in general, it&lt;br/&gt;
matters under which javac tash a class is compiled in Derby, since we&lt;br/&gt;
use so many tweaks for classpath handling to enable seperate Java&lt;br/&gt;
versions, jsr169, JDBC3, 4... I think it woul dbe good if we could&lt;br/&gt;
move to having the dependencies better understood and encoded in the&lt;br/&gt;
build files, cf. Knut&apos;s experiment, so we can untangle all these&lt;br/&gt;
intricate dependencies, and suffer less every time anything changes..&lt;/p&gt;</comment>
                            <comment id="12999710" author="dagw" created="Sat, 26 Feb 2011 03:43:53 +0000"  >&lt;p&gt;Committed 1074789 (derby-4741-fix-compilation). I don&apos;t plan more work on this feature now, resolving.&lt;/p&gt;</comment>
                            <comment id="13000021" author="lilywei" created="Sun, 27 Feb 2011 18:24:28 +0000"  >&lt;p&gt;Thank you so much, Dag. I couldn&#8217;t agree more. We should define the dependencies better and move toward to more fine rule in the build files and have easier life every time we need to change thing to make Derby better. A lot of things appear to be easy but take a lot of time to do once you get all the details. :-  The devil is always in the detail. &lt;/p&gt;</comment>
                            <comment id="13685379" author="knutanders" created="Mon, 17 Jun 2013 10:19:51 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12494893">DERBY-4960</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12495640">DERBY-4974</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12496358">DERBY-4982</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12506629">DERBY-5223</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12507184">DERBY-5233</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12512855">DERBY-5312</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12513487">DERBY-5325</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12502376">DERBY-5152</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12514078">DERBY-5333</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12495149">DERBY-4963</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12495293">DERBY-4967</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12495296">DERBY-4968</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12498366">DERBY-5024</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12399349">DERBY-3746</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="30281">DERBY-151</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12480747">DERBY-4911</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12459264" name="InterruptResilienceTest.java" size="9451" author="lilywei" created="Wed, 10 Nov 2010 18:10:13 +0000"/>
                            <attachment id="12457271" name="MicroAPITest.java" size="2212" author="dagw" created="Fri, 15 Oct 2010 17:07:35 +0100"/>
                            <attachment id="12457855" name="derby-4741-a-01-api-interruptstatus.diff" size="39686" author="dagw" created="Fri, 22 Oct 2010 19:25:59 +0100"/>
                            <attachment id="12457856" name="derby-4741-a-01-api-interruptstatus.stat" size="728" author="dagw" created="Fri, 22 Oct 2010 19:25:59 +0100"/>
                            <attachment id="12458171" name="derby-4741-a-02-api-interruptstatus.diff" size="46454" author="dagw" created="Wed, 27 Oct 2010 18:00:09 +0100"/>
                            <attachment id="12458172" name="derby-4741-a-02-api-interruptstatus.stat" size="989" author="dagw" created="Wed, 27 Oct 2010 18:00:09 +0100"/>
                            <attachment id="12458227" name="derby-4741-a-03-api-interruptstatus.diff" size="45098" author="dagw" created="Thu, 28 Oct 2010 04:34:49 +0100"/>
                            <attachment id="12458228" name="derby-4741-a-03-api-interruptstatus.stat" size="989" author="dagw" created="Thu, 28 Oct 2010 04:34:49 +0100"/>
                            <attachment id="12458672" name="derby-4741-a-04-api-interruptstatus.diff" size="43798" author="dagw" created="Tue, 2 Nov 2010 20:54:32 +0000"/>
                            <attachment id="12458673" name="derby-4741-a-04-api-interruptstatus.stat" size="989" author="dagw" created="Tue, 2 Nov 2010 20:54:32 +0000"/>
                            <attachment id="12457615" name="derby-4741-all+lenient+resurrect.diff" size="119138" author="dagw" created="Tue, 19 Oct 2010 23:48:15 +0100"/>
                            <attachment id="12457616" name="derby-4741-all+lenient+resurrect.stat" size="2068" author="dagw" created="Tue, 19 Oct 2010 23:48:15 +0100"/>
                            <attachment id="12459128" name="derby-4741-b-01-nio.diff" size="62544" author="dagw" created="Tue, 9 Nov 2010 01:56:12 +0000"/>
                            <attachment id="12459129" name="derby-4741-b-01-nio.stat" size="696" author="dagw" created="Tue, 9 Nov 2010 01:56:13 +0000"/>
                            <attachment id="12459404" name="derby-4741-b-02-nio.diff" size="62467" author="dagw" created="Thu, 11 Nov 2010 23:23:17 +0000"/>
                            <attachment id="12459405" name="derby-4741-b-02-nio.stat" size="646" author="dagw" created="Thu, 11 Nov 2010 23:23:17 +0000"/>
                            <attachment id="12459626" name="derby-4741-b-03-nio.diff" size="64975" author="dagw" created="Mon, 15 Nov 2010 19:01:14 +0000"/>
                            <attachment id="12459627" name="derby-4741-b-03-nio.stat" size="646" author="dagw" created="Mon, 15 Nov 2010 19:01:14 +0000"/>
                            <attachment id="12460329" name="derby-4741-b-04-nio.diff" size="66341" author="dagw" created="Wed, 24 Nov 2010 01:56:34 +0000"/>
                            <attachment id="12460330" name="derby-4741-b-04-nio.stat" size="646" author="dagw" created="Wed, 24 Nov 2010 01:56:34 +0000"/>
                            <attachment id="12464822" name="derby-4741-c-01-nio.diff" size="6694" author="dagw" created="Mon, 29 Nov 2010 00:46:16 +0000"/>
                            <attachment id="12464823" name="derby-4741-c-01-nio.stat" size="151" author="dagw" created="Mon, 29 Nov 2010 00:46:16 +0000"/>
                            <attachment id="12471789" name="derby-4741-fix-compilation.diff" size="2044" author="dagw" created="Wed, 23 Feb 2011 23:56:36 +0000"/>
                            <attachment id="12471790" name="derby-4741-fix-compilation.stat" size="159" author="dagw" created="Wed, 23 Feb 2011 23:56:37 +0000"/>
                            <attachment id="12465744" name="derby-4741-kristians-01.diff" size="4458" author="dagw" created="Tue, 7 Dec 2010 22:15:49 +0000"/>
                            <attachment id="12457164" name="derby-4741-nio-container+log+waits+locks+throws.diff" size="102653" author="dagw" created="Thu, 14 Oct 2010 17:00:45 +0100"/>
                            <attachment id="12457119" name="derby-4741-nio-container+log+waits+locks+throws.stat" size="1861" author="dagw" created="Thu, 14 Oct 2010 03:11:37 +0100"/>
                            <attachment id="12457011" name="derby-4741-nio-container+log+waits+locks-2.diff" size="81688" author="dagw" created="Tue, 12 Oct 2010 22:35:25 +0100"/>
                            <attachment id="12457012" name="derby-4741-nio-container+log+waits+locks-2.stat" size="1364" author="dagw" created="Tue, 12 Oct 2010 22:35:25 +0100"/>
                            <attachment id="12456744" name="derby-4741-nio-container+log+waits+locks.diff" size="74457" author="dagw" created="Fri, 8 Oct 2010 23:46:12 +0100"/>
                            <attachment id="12456745" name="derby-4741-nio-container+log+waits+locks.stat" size="1160" author="dagw" created="Fri, 8 Oct 2010 23:46:12 +0100"/>
                            <attachment id="12456704" name="derby-4741-nio-container+log+waits.diff" size="64218" author="dagw" created="Fri, 8 Oct 2010 15:10:02 +0100"/>
                            <attachment id="12456705" name="derby-4741-nio-container+log+waits.stat" size="865" author="dagw" created="Fri, 8 Oct 2010 15:10:02 +0100"/>
                            <attachment id="12456608" name="derby-4741-nio-container+log.diff" size="60900" author="dagw" created="Thu, 7 Oct 2010 18:04:17 +0100"/>
                            <attachment id="12456609" name="derby-4741-nio-container+log.stat" size="794" author="dagw" created="Thu, 7 Oct 2010 18:04:18 +0100"/>
                            <attachment id="12456441" name="derby-4741-nio-container-2.diff" size="25761" author="dagw" created="Tue, 5 Oct 2010 23:18:21 +0100"/>
                            <attachment id="12456443" name="derby-4741-nio-container-2.log" size="56051" author="dagw" created="Tue, 5 Oct 2010 23:18:21 +0100"/>
                            <attachment id="12456442" name="derby-4741-nio-container-2.stat" size="383" author="dagw" created="Tue, 5 Oct 2010 23:18:21 +0100"/>
                            <attachment id="12456500" name="derby-4741-nio-container-2b.diff" size="39533" author="dagw" created="Wed, 6 Oct 2010 14:21:47 +0100"/>
                            <attachment id="12456501" name="derby-4741-nio-container-2b.stat" size="410" author="dagw" created="Wed, 6 Oct 2010 14:21:47 +0100"/>
                            <attachment id="12469023" name="derby-4741-raf-stresstest-1.diff" size="17261" author="dagw" created="Sat, 22 Jan 2011 01:58:43 +0000"/>
                            <attachment id="12469024" name="derby-4741-raf-stresstest-1.stat" size="176" author="dagw" created="Sat, 22 Jan 2011 01:58:43 +0000"/>
                            <attachment id="12469328" name="derby-4741-raf-stresstest-2.diff" size="17538" author="dagw" created="Tue, 25 Jan 2011 20:35:51 +0000"/>
                            <attachment id="12469329" name="derby-4741-raf-stresstest-2.stat" size="250" author="dagw" created="Tue, 25 Jan 2011 20:35:51 +0000"/>
                            <attachment id="12469370" name="derby-4741-raf-stresstest-3.diff" size="20803" author="dagw" created="Wed, 26 Jan 2011 01:47:48 +0000"/>
                            <attachment id="12469371" name="derby-4741-raf-stresstest-3.stat" size="250" author="dagw" created="Wed, 26 Jan 2011 01:47:48 +0000"/>
                            <attachment id="12469503" name="derby-4741-raf-stresstest-4.diff" size="23373" author="dagw" created="Thu, 27 Jan 2011 01:55:53 +0000"/>
                            <attachment id="12469504" name="derby-4741-raf-stresstest-4.stat" size="402" author="dagw" created="Thu, 27 Jan 2011 01:55:53 +0000"/>
                            <attachment id="12468142" name="derby-4741-sleeps-waits-1.diff" size="5333" author="dagw" created="Wed, 12 Jan 2011 17:56:23 +0000"/>
                            <attachment id="12468143" name="derby-4741-sleeps-waits-1.stat" size="210" author="dagw" created="Wed, 12 Jan 2011 17:56:23 +0000"/>
                            <attachment id="12468707" name="derby-4741-sleeps-waits-2.diff" size="19735" author="dagw" created="Wed, 19 Jan 2011 00:50:48 +0000"/>
                            <attachment id="12468708" name="derby-4741-sleeps-waits-2.stat" size="855" author="dagw" created="Wed, 19 Jan 2011 00:50:48 +0000"/>
                            <attachment id="12468796" name="derby-4741-sleeps-waits-3.diff" size="19382" author="dagw" created="Wed, 19 Jan 2011 23:47:22 +0000"/>
                            <attachment id="12468797" name="derby-4741-sleeps-waits-3.stat" size="855" author="dagw" created="Wed, 19 Jan 2011 23:47:22 +0000"/>
                            <attachment id="12471034" name="derby-4741-sleeps-waits-more.diff" size="7995" author="dagw" created="Tue, 15 Feb 2011 00:03:08 +0000"/>
                            <attachment id="12471035" name="derby-4741-sleeps-waits-more.stat" size="533" author="dagw" created="Tue, 15 Feb 2011 00:03:08 +0000"/>
                            <attachment id="12470092" name="derby-4741-testBatchInterrupt-b.diff" size="3016" author="dagw" created="Thu, 3 Feb 2011 00:17:55 +0000"/>
                            <attachment id="12469986" name="derby-4741-testBatchInterrupt.diff" size="10417" author="dagw" created="Tue, 1 Feb 2011 22:15:27 +0000"/>
                            <attachment id="12469970" name="derby-4741-testQueryInterrupt.diff" size="8055" author="dagw" created="Tue, 1 Feb 2011 19:07:28 +0000"/>
                            <attachment id="12469971" name="derby-4741-testQueryInterrupt.stat" size="168" author="dagw" created="Tue, 1 Feb 2011 19:07:28 +0000"/>
                            <attachment id="12457234" name="derby.log" size="4398" author="lilywei" created="Fri, 15 Oct 2010 06:08:47 +0100"/>
                            <attachment id="12456935" name="derby.log" size="27715" author="lilywei" created="Tue, 12 Oct 2010 06:00:42 +0100"/>
                            <attachment id="12471333" name="interrupts-fs.html" size="8613" author="dagw" created="Thu, 17 Feb 2011 21:07:24 +0000"/>
                            <attachment id="12470815" name="interrupts-fs.html" size="7919" author="dagw" created="Fri, 11 Feb 2011 00:44:13 +0000"/>
                            <attachment id="12469981" name="interrupts-fs.html" size="6881" author="dagw" created="Tue, 1 Feb 2011 21:18:31 +0000"/>
                            <attachment id="12469614" name="interrupts-fs.html" size="6484" author="dagw" created="Fri, 28 Jan 2011 00:29:31 +0000"/>
                            <attachment id="12471036" name="sleep-1-usages.txt" size="1898" author="dagw" created="Tue, 15 Feb 2011 00:06:04 +0000"/>
                            <attachment id="12471038" name="wait-0-usages.txt" size="4637" author="dagw" created="Tue, 15 Feb 2011 00:06:04 +0000"/>
                            <attachment id="12471037" name="wait-1-usages.txt" size="1039" author="dagw" created="Tue, 15 Feb 2011 00:06:04 +0000"/>
                            <attachment id="12456610" name="xsbt0.log.gz" size="23241" author="dagw" created="Thu, 7 Oct 2010 18:20:31 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>70.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 16 Sep 2010 09:42:41 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24438</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy087r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35149</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>