<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:53:34 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2921/DERBY-2921.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2921] Replication: Add a network service that connects the master and slave Derby instances</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2921</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;A network connection is required between the master and slave Derby instances of a replicated database. The connection will be used to send many kinds of messages, including:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;log records&lt;/li&gt;
	&lt;li&gt;the database (when replication is started)&lt;/li&gt;
	&lt;li&gt;master -&amp;gt; slave commands (like &quot;stop replication&quot;)&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12373496">DERBY-2921</key>
            <summary>Replication: Add a network service that connects the master and slave Derby instances</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12372418">DERBY-2872</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="narayanan">V.Narayanan</assignee>
                                    <reporter username="jorgenlo">J&#248;rgen L&#248;land</reporter>
                        <labels>
                    </labels>
                <created>Wed, 11 Jul 2007 11:55:59 +0100</created>
                <updated>Fri, 21 Jan 2011 18:17:11 +0000</updated>
                            <resolved>Sat, 22 Sep 2007 09:45:23 +0100</resolved>
                                    <version>10.4.1.3</version>
                                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>Services</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12511764" author="narayanan" created="Wed, 11 Jul 2007 15:06:28 +0100"  >&lt;p&gt;The Proof of concept attached to 2872 achieves the most basic level of tranfer that might&lt;br/&gt;
be required, namely the transfer of individual log records using RMI.&lt;/p&gt;

&lt;p&gt;This needs to be built into a framework for generic message transfer between the master and&lt;br/&gt;
the slave&lt;/p&gt;

&lt;p&gt;I believe lot of considerations would go into such a communication channel&lt;/p&gt;

&lt;p&gt;A few already pointed out by Rick in the previous discussion in Derby-2872 like handling&lt;br/&gt;
Man in the middle attacks and the associated security precautions that we will take for the&lt;br/&gt;
same etc.&lt;/p&gt;

&lt;p&gt;But as a first step I believe that we should look into building the basic communication&lt;br/&gt;
system, and plan in such a way that we are able to plug in security seamlessly later, (i.e.)&lt;br/&gt;
concentrate on building the functionality first ,documenting and appropriately coding for the&lt;br/&gt;
enhancements that may be required later.&lt;/p&gt;

&lt;p&gt;Here are a few random thoughts towards this&lt;/p&gt;

&lt;p&gt;1) we need a socket server on the slave to listen to incoming log records and other&lt;br/&gt;
    information from the master&lt;br/&gt;
2) The master connects to this socket server that will be running on the slave.&lt;br/&gt;
3) Decide on the data structure that will be sent to this socket server and ensure that&lt;br/&gt;
    it is able to accomodate not only logRecords but also other messages that may be required.&lt;br/&gt;
4) would SSL need to be enabled in the communication between the master and slave?&lt;br/&gt;
    if yes,&lt;br/&gt;
    Should the sockets be created the same way it is being done in  &lt;br/&gt;
    org.apache.derby.client.net.OpenSocketAction and NetworkServerControlImpl &lt;br/&gt;
    supporting only SSL_OFF in the first version and the other SSL modes later?&lt;br/&gt;
5) How do we write the communication data structures such that encryption &lt;br/&gt;
    IF NECESSARY can be plugged in at a later stage?&lt;br/&gt;
6) Would we need to support any other authentication mechanishms?&lt;/p&gt;

&lt;p&gt;Any additional cases that need to be handled and views in the direction of this issue&lt;br/&gt;
will be highly appreciated.&lt;/p&gt;</comment>
                            <comment id="12512003" author="jorgenlo" created="Thu, 12 Jul 2007 09:06:13 +0100"  >&lt;p&gt;Hi Narayanan&lt;/p&gt;

&lt;p&gt;I noticed that the code attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2852&quot; title=&quot;Derby: Replication and Availability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2852&quot;&gt;&lt;del&gt;DERBY-2852&lt;/del&gt;&lt;/a&gt; contains a network communication service. If I remember correctly, it can be used to send any kind of object by wrapping it in a NetworkPayload object. I think you should have a look at these files and see if they can be used here with some modification:&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/net&lt;br/&gt;
A      java/engine/org/apache/derby/impl/services/net/NetworkPayload.java&lt;br/&gt;
A      java/engine/org/apache/derby/impl/services/net/receiver/LogReceiver.java&lt;br/&gt;
A      java/engine/org/apache/derby/impl/services/net/shipper/LogShipper.java&lt;/p&gt;

&lt;p&gt;I agree that you should focus on the basic functionality for now. But SSL will very likely be required at some point, so you should definately have that in mind when working on this. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2852&quot; title=&quot;Derby: Replication and Availability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2852&quot;&gt;&lt;del&gt;DERBY-2852&lt;/del&gt;&lt;/a&gt; does not use SSL, and I am not sure if it is easily pluggable either. &lt;/p&gt;

&lt;p&gt;A lot of issues regarding the network communication were discussed in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2872&quot; title=&quot;Add Replication functionality to Derby&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2872&quot;&gt;&lt;del&gt;DERBY-2872&lt;/del&gt;&lt;/a&gt;; make sure you are up to date on these. Especially the need for a handshake phase before the slave accepts incoming log records. It may also be the case that a master/slave connection is lost at some point in time. The network code should probably try to reconnect when this happens. Of course, the slave will have to understand that this is the same master that tries to reconnect.&lt;/p&gt;</comment>
                            <comment id="12512542" author="dagw" created="Fri, 13 Jul 2007 18:18:13 +0100"  >&lt;p&gt;J&#248;rgen &amp;gt; I noticed that the code attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2852&quot; title=&quot;Derby: Replication and Availability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2852&quot;&gt;&lt;del&gt;DERBY-2852&lt;/del&gt;&lt;/a&gt; contains a&lt;/p&gt;

&lt;p&gt;You may want to be careful about reusing this code until we have the&lt;br/&gt;
licencing issues settled. Is there a software grant in place for this&lt;br/&gt;
contribution?&lt;/p&gt;</comment>
                            <comment id="12512909" author="narayanan" created="Mon, 16 Jul 2007 11:51:39 +0100"  >&lt;p&gt;Thank you for looking at this Dag. I shall keep this in mind while working on&lt;br/&gt;
the coding for the Network Interfaces.&lt;/p&gt;</comment>
                            <comment id="12516290" author="narayanan" created="Mon, 30 Jul 2007 07:13:28 +0100"  >&lt;p&gt;This patch contains the implementation of the Socket &lt;br/&gt;
server and the socket client that will be used to &lt;br/&gt;
communicate between the Master and the slave, during &lt;br/&gt;
replication.&lt;/p&gt;

&lt;p&gt;The code will not be in derby.jar for now, but will &lt;br/&gt;
be compiled in the classes directory. The class will &lt;br/&gt;
be used by the replication master service which will &lt;br/&gt;
contain a reference to these network classes. This will &lt;br/&gt;
automatically be picked up and bundled into derby.jar once&lt;br/&gt;
the master service is in place. The dependency detection &lt;br/&gt;
is at present being done by a class called classlister.java. &lt;br/&gt;
This class takes care of building the file derby.list that &lt;br/&gt;
contains the list of all the classes that will be in derby.jar.&lt;/p&gt;

&lt;p&gt;Pls find below a file by file explanation of the classes that &lt;br/&gt;
have been added or modified.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication&lt;br/&gt;
A      java/engine/org/apache/derby/impl/services/replication/net&lt;/p&gt;

&lt;p&gt;The directory that contains the Network classes. As pointed &lt;br/&gt;
out in Derby-2977 a Replication Master controller will be &lt;br/&gt;
started as a service. This replication service and all the &lt;br/&gt;
related classes will be placed in the services package under &lt;br/&gt;
a sub-package called replication.&lt;/p&gt;

&lt;p&gt;Since this issue basically handles the network utility classes &lt;br/&gt;
that will be used by the replication framework, this is placed &lt;br/&gt;
under a sub-package of replication called net.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication/net/ReplicationMessageTransmit.java&lt;/p&gt;

&lt;p&gt;The Transmitter is basically a client socket that takes care of sending &lt;br/&gt;
the messages to the receiver. This will be used by the master to send &lt;br/&gt;
log records and other messages to the slave.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication/net/ReplicationMessageReceive.java&lt;/p&gt;

&lt;p&gt;The Receiver is a server socket that takes care of receiving the messages &lt;br/&gt;
that are sent by the transmitter. This will be used in the slave for&lt;br/&gt;
receiving the log records and other messages. This will receive the messages&lt;br/&gt;
and pass them on to the other classes that will perform appropriate&lt;br/&gt;
action with them.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication/net/OpenSocketAction.java&lt;/p&gt;

&lt;p&gt;This class has been designed along the same lines as &lt;br/&gt;
org.apache.derby.client.net.OpenSocketAction the only difference being&lt;br/&gt;
that it does not have ssl enabled socket creation ability for now.&lt;br/&gt;
If this is required this can be added in the same lines of the original&lt;br/&gt;
class at a later stage.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication/net/ReplicationMessage.java&lt;/p&gt;

&lt;p&gt;The generic message unit that is sent between the master and the slave.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/loc/messages.xml&lt;br/&gt;
M      java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/p&gt;

&lt;p&gt;The SQLState for the exceptions that are thrown when a exception&lt;br/&gt;
occurs during Replication and their corresponding messages.&lt;/p&gt;</comment>
                            <comment id="12516291" author="narayanan" created="Mon, 30 Jul 2007 07:14:11 +0100"  >&lt;p&gt;ome Questions for which I do not have an answer in this implementation&lt;/p&gt;

&lt;p&gt;1) Replication would by default use the port number 8001 if the user&lt;br/&gt;
   does not specify the port number. The number 8001 was chosen&lt;br/&gt;
   randomly. Is it OK to do it this way? If no how should the&lt;br/&gt;
   port be chosen?&lt;/p&gt;

&lt;p&gt;2) When a error occurs in the Transmitter or the Receiver it is&lt;br/&gt;
   bundled in a StandardException and thrown with a SQLState of&lt;br/&gt;
   XR001, XR002 etc.&lt;/p&gt;

&lt;p&gt;   The logic behind choosing this was &lt;/p&gt;

&lt;p&gt;   X - Means derby specific. I understood this from a scan of&lt;br/&gt;
       SQLState.java&lt;br/&gt;
   R - Replication specific.&lt;/p&gt;

&lt;p&gt;   The last three digits would be sequential.&lt;/p&gt;

&lt;p&gt;   Is this the correct way of assigning the SQLState?&lt;/p&gt;

&lt;p&gt;   Is it OK to bundle the exceptions in a StandardException and&lt;br/&gt;
   throw them.&lt;/p&gt;

&lt;p&gt;3) In the receiver the accept() method on the socket is called&lt;br/&gt;
   from the run method. &lt;/p&gt;

&lt;p&gt;   We cannot throw checked exceptions from a run method. This has been&lt;br/&gt;
   handled this by bundling the exception thrown in a RuntimeException&lt;br/&gt;
   and throwing it.&lt;/p&gt;

&lt;p&gt;   The way it is done in impl/drda/ClientThread.java does not offer a&lt;br/&gt;
   clue as to how this is to be done as there we print console messages&lt;br/&gt;
   which would not be possible in this case.&lt;/p&gt;

&lt;p&gt;   Is RuntimeException the way out here? Is there a better way of doing&lt;br/&gt;
   this?&lt;/p&gt;</comment>
                            <comment id="12516292" author="narayanan" created="Mon, 30 Jul 2007 07:18:35 +0100"  >&lt;p&gt;The previous comment should have started as &quot;Some questions for which...&quot;.&lt;br/&gt;
Sorry about the typo.&lt;/p&gt;</comment>
                            <comment id="12517632" author="rhillegas" created="Fri, 3 Aug 2007 21:50:01 +0100"  >&lt;p&gt;Thanks for the patch, Naryanan. I have an initial question about ReplicationMessage. It appears to implement Serializable. That means that the exchange protocol relies on both ends of the connection being at the same rev level of Derby and perhaps even compiled by the same machine. I&apos;m not sure this is what you want, particularly since the architecture allows for large webs of Derby nodes, each of which may host both slaves and masters. I think that the functional spec should address the topic of version agreement between nodes. For instance, do you envision that newly upgraded masters will propagate the new Derby rev to their slaves?&lt;/p&gt;</comment>
                            <comment id="12518400" author="narayanan" created="Wed, 8 Aug 2007 11:04:56 +0100"  >&lt;p&gt;&amp;gt;Thanks for the patch, Naryanan.&lt;/p&gt;

&lt;p&gt;Thank you for taking a look at the patch Rick and giving me your comments.&lt;/p&gt;

&lt;p&gt;&amp;gt;I have an initial question about ReplicationMessage. &lt;br/&gt;
&amp;gt;It appears to implement Serializable. &lt;/p&gt;

&lt;p&gt;&amp;gt;That means that the exchange protocol relies on both ends of the &lt;br/&gt;
&amp;gt;connection being at the same rev level of Derby and perhaps even &lt;br/&gt;
&amp;gt;compiled by the same machine. &lt;/p&gt;

&lt;p&gt;I learnt some of the  nuances of ensuring proper versions for the &lt;br/&gt;
serializable objects here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-02-2006/jw-0227-control.html?page=1&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.javaworld.com/javaworld/jw-02-2006/jw-0227-control.html?page=1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pls find below the way I think serialization would impact this issue and a&lt;br/&gt;
possible resolution.&lt;/p&gt;

&lt;p&gt;when replication is attempted between two different versions of Derby.&lt;br/&gt;
The incompatibilities caused between releases due to serialization can&lt;br/&gt;
be classified into the following&lt;/p&gt;

&lt;p&gt;1) Store and retrieve&lt;br/&gt;
2) Mixed-release&lt;/p&gt;

&lt;p&gt;The store and retrieve happens when a serialized object is stored into a&lt;br/&gt;
database and retrieved. This would not be relevant to us. The mixed-release&lt;br/&gt;
is what is relevant to us here.&lt;/p&gt;

&lt;p&gt;The mixed-release occurs when the two classes on the master and the slave are&lt;br/&gt;
at different value of the &lt;b&gt;suid&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&quot;Before a serialized object is read, the ObjectInputStream class first computes the &lt;br/&gt;
suid of the local class&#8212;the serializable class. It then matches this suid value &lt;br/&gt;
against the one stored in the serialized object stream. When these two values match, &lt;br/&gt;
ObjectInputStream reads off the fields in the stream and maps the values into the &lt;br/&gt;
instantiated object. If these two values do not match, ObjectInputStream raises the &lt;br/&gt;
InvalidClassException.&quot;&lt;/p&gt;

&lt;p&gt;An suid is calculated based on the following factors&lt;/p&gt;

&lt;p&gt;1) serializable class&apos;s name&lt;br/&gt;
2) sorted field names &lt;br/&gt;
3) method names of methods and interfaces&lt;br/&gt;
4) modifiers. &lt;/p&gt;

&lt;p&gt;If I have got it right the the &lt;b&gt;derby rev&lt;/b&gt; or the &lt;b&gt;machine&lt;/b&gt; will not impact the suid.&lt;br/&gt;
By machine I mean the &lt;b&gt;JVM&lt;/b&gt;. I do not think the &lt;b&gt;machine architecture&lt;/b&gt; would impact &lt;br/&gt;
the compatibility here since the JVM would take care of that.&lt;/p&gt;

&lt;p&gt;The incompatibility will rather be due to class incompatibility (i.e.) the message class&lt;br/&gt;
changing between versions.&lt;/p&gt;

&lt;p&gt;There are two things that must be done here if any changes are planned in the subsequent&lt;br/&gt;
releases&lt;/p&gt;

&lt;p&gt;1) Override the suid.&lt;br/&gt;
2) Ensure that changes in subsequent versions are compatible.&lt;/p&gt;

&lt;p&gt;As part of addressing the issue pointed out I intend to&lt;/p&gt;

&lt;p&gt;1) Override the serialVersionUID&lt;/p&gt;

&lt;p&gt;Doing this should should be enough for compatible changes in subsequent versions. For the&lt;br/&gt;
incompatible changes a handshake should suffice but I think this can be delayed until an&lt;br/&gt;
incompatible change is introduced.&lt;/p&gt;

&lt;p&gt;&amp;gt;I&apos;m not sure this is what you want, particularly &lt;br/&gt;
&amp;gt;since the architecture allows for large webs of Derby nodes, each of which may host&lt;br/&gt;
&amp;gt;both slaves and masters. I think that the functional spec should address the topic &lt;br/&gt;
&amp;gt;of version agreement between nodes. For instance, do you envision that newly upgraded &lt;br/&gt;
&amp;gt;masters will propagate the new Derby rev to their slaves?&lt;/p&gt;</comment>
                            <comment id="12518573" author="rhillegas" created="Thu, 9 Aug 2007 00:09:15 +0100"  >&lt;p&gt;Thanks for looking into this issue, Narayanan. Some more discussion follows.&lt;/p&gt;

&lt;p&gt;The machine issue has to do with the machine that compiles the Derby release, not the machine which runs Derby in production. The serialVersionUUID can change from release to release even if there are no changes to replication. This depends on who steps up to be release manager and what environment they use to build the release. Of course, hard-coding the serialVersionUUID patches around this problem.&lt;/p&gt;

&lt;p&gt;However, hard-coding the serialVersionUUID will not solve the larger issue of how replication will behave in a mixed-release environment. Between releases, we may need to make changes to the structure of the ReplicationMessage or the log record. In my experience, version upgrade needs to be designed into the first release of a feature. It is generally a disaster when you try to retrofit upgrade into version 2 of a product.&lt;/p&gt;

&lt;p&gt;But there are much larger issues here than serialization. For the sake of framing this issue, I introduce the following definition:&lt;/p&gt;

&lt;p&gt;ReplicationClosure &amp;#8211; This is the  set of all Derby instances which are linked by replication. You compute the ReplicationClosure by starting with one of the systems, then add all systems that it replicates to and from. Then you repeat for each of those added systems, etc..&lt;/p&gt;

&lt;p&gt;1) Are we requiring that all Derby instances in a ReplicationClosure be at the same rev level?&lt;/p&gt;

&lt;p&gt;2) If not, what happens when one system in the ReplicationClosure is upgraded to a new rev of Derby independently of the others?&lt;/p&gt;

&lt;p&gt;3) On the other hand, if the answer to (1) is &quot;yes&quot;, then what is our plan for propagating Derby (and application) upgrades across the ReplicationClosure?&lt;/p&gt;

&lt;p&gt;Consider the following problem: A 10.5 master replicates to a 10.5 slave. Later on, the 10.5 master is hard-upgraded to 10.6. Quite likely, hard-upgrade will do transactional work which must be replayed at the slave. But now, what is the state of the slave? It has a 10.5 version of Derby on its classpath, but the actual tables think they are at rev level 10.6. Fail-over is not going to work well.&lt;/p&gt;

&lt;p&gt;I suspect that where you want to end up is that all systems in the ReplicationClosure must be at the same Derby rev level. You need to have some plan for propagating new Derby releases across the ReplicationClosure. Maybe the answer is this: Replication fails if the master and slave are at different Derby rev levels and it is the System Administrator&apos;s responsibility to upgrade all Derby installations in the ReplicationClosure at the same time. The functional spec needs to spell out what the behavior is. Then I can reason about whether this patch fits into the spec&apos;d model.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;
</comment>
                            <comment id="12520471" author="narayanan" created="Fri, 17 Aug 2007 07:51:01 +0100"  >&lt;p&gt;Thank you for looking into this issue and giving your comments Rick. &lt;br/&gt;
Your comments have helped highlight critical issues that would have&lt;br/&gt;
risen in the development process.&lt;/p&gt;

&lt;p&gt;My proposal to handle the issues pointed out are as follows.&lt;/p&gt;

&lt;p&gt;1) Hard-code the SerialVersionUUID. This will help overcome the problem of&lt;br/&gt;
   incompatibilities that arise due to difference in the machine that compiles&lt;br/&gt;
   the derby release.&lt;/p&gt;

&lt;p&gt;2) Place a restriction that all Derby instances in the Relication Closure are at the&lt;br/&gt;
   same rev level &lt;/p&gt;

&lt;p&gt;   For this &lt;/p&gt;

&lt;p&gt;   a) Exchange Derby revision levels during the handshake. If the master and the&lt;br/&gt;
      slave are at different rev levels replication will not be allowed.&lt;/p&gt;

&lt;p&gt;   b) As you suggest update the functional spec to say that Replication fails if &lt;br/&gt;
      the master and slave are at different Derby rev levels and it is the System &lt;br/&gt;
      Administrator&apos;s responsibility to upgrade all Derby installations in &lt;br/&gt;
      the ReplicationClosure at the same time.&lt;/p&gt;

&lt;p&gt;   This will handle the issue of incompatible changes made to ReplicationMessage and&lt;br/&gt;
   also the case where an upgrade is done to the master.&lt;/p&gt;

&lt;p&gt;These restrictions will be removed in subsequent revisions.&lt;/p&gt;

&lt;p&gt;I will produce an updated functional spec for this.&lt;/p&gt;</comment>
                            <comment id="12520567" author="rhillegas" created="Fri, 17 Aug 2007 15:13:09 +0100"  >&lt;p&gt;Thanks, Narayanan. I think that this solution is adequate for a first rev. The version handshake will let replication fail gracefully as necessary at upgrade time. Just to be clear, I think that the version id in question is the version of the code (the Derby jar files), not the version level of the data. If you have to get your hands on the version level of the data, then you may have to tackle some tricky soft-upgrade issues.&lt;/p&gt;</comment>
                            <comment id="12520574" author="oysteing" created="Fri, 17 Aug 2007 15:40:38 +0100"  >&lt;p&gt;If I understand correctly, hard-coding the SerialVersionUUID, will mean that when one later change the serialization form, one will have to manually update the  SerialVersionUUID.  Would not that imply that as long as the format of the message does not change, running different versions of the master and the slave will work?&lt;/p&gt;

&lt;p&gt;I think the suggested approach is good.  It is not necessary to support protocol upgrades before an on-line upgrade is actually required.   At that time, the upgrade will need to happen in two steps.  First, the software is upgraded and then when all nodes are running the new version, the protocol can be upgraded.  (Maybe the first step could be part of soft upgrade, and the second hard upgrade.)&lt;/p&gt;

&lt;p&gt;Since it is log records that are replicated, I would think that one will also have to deal with the version level of log records and data.&lt;/p&gt;</comment>
                            <comment id="12520588" author="rhillegas" created="Fri, 17 Aug 2007 16:32:08 +0100"  >&lt;p&gt;&#216;ystein&amp;gt; If I understand correctly, hard-coding the SerialVersionUUID, will mean that when one later change the serialization form, one will have to manually update the SerialVersionUUID.&lt;/p&gt;

&lt;p&gt;If I were coding this myself, my instinct would be to use Externalizable rather than Serializable. As its very first task, writeExternal() would stamp a version id on the serialization stream. Symmetrically, as its very first task, readExternal() would read the stamped version id-&lt;del&gt;and switch based on the actual version id. I find this approach is very flexible. And you are right, the version id has to change when the serialized form is altered&lt;/del&gt;-regardless of whether the solution is programmed using Serializable or Externalizable.&lt;/p&gt;

&lt;p&gt;&#216;ystein&amp;gt; Would not that imply that as long as the format of the message does not change, running different versions of the master and the slave will work?&lt;/p&gt;

&lt;p&gt;I&apos;m not following you. How would you handle the problem described in my comment on August 8: The master hard-uprades and the transactional work done as part of hard upgrade is replayed into the down-rev slave database. Now the slave database thinks that it is at a higher rev than the actual Derby code on the slave machine. What will happen if you have to failover to this inconsistent slave?&lt;/p&gt;
</comment>
                            <comment id="12521040" author="narayanan" created="Mon, 20 Aug 2007 10:42:41 +0100"  >&lt;p&gt;Thank you for the comments Rick and Oystein. I am working on converting the&lt;br/&gt;
patch to use Externalizable instead of Serializable and also to hard-code the SerialVersionUID. &lt;br/&gt;
I shall submit a patch with the same. I shall also update the functional specification.&lt;/p&gt;</comment>
                            <comment id="12521046" author="oysteing" created="Mon, 20 Aug 2007 11:15:26 +0100"  >&lt;p&gt;Rick Hillegas (JIRA) wrote:&lt;br/&gt;
&amp;gt; &#216;ystein&amp;gt; Would not that imply that as long as the format of the&lt;br/&gt;
&amp;gt; message does not change, running different versions of the master&lt;br/&gt;
&amp;gt; and the slave will work?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;m not following you. How would you handle the problem described in&lt;br/&gt;
&amp;gt; my comment on August 8: The master hard-uprades and the&lt;br/&gt;
&amp;gt; transactional work done as part of hard upgrade is replayed into the&lt;br/&gt;
&amp;gt; down-rev slave database. Now the slave database thinks that it is at&lt;br/&gt;
&amp;gt; a higher rev than the actual Derby code on the slave machine. What&lt;br/&gt;
&amp;gt; will happen if you have to failover to this inconsistent slave?&lt;/p&gt;

&lt;p&gt;I agree that hard upgrade is a challenge.  However, we need to&lt;br/&gt;
distinguish between software version and database version here.  The&lt;br/&gt;
requirement will be that the database is not upgraded to a version&lt;br/&gt;
that is higher than the software versions of any of the two Derby&lt;br/&gt;
instances hosting the master and the slave.  The master and the slave&lt;br/&gt;
does not have to have the exact same version number.  This also means&lt;br/&gt;
that it will be possible to do an on-line upgrade of the software by&lt;br/&gt;
restarting the nodes one at a time.&lt;/p&gt;

&lt;p&gt;It does not seem to me that it will be possible to upgrade the version&lt;br/&gt;
of the database on-line.  In order to upgrade, one will have to shut&lt;br/&gt;
down and restart the master.  During this process one can not do&lt;br/&gt;
fail-over to the slave since the old master will have to remain master&lt;br/&gt;
when it is booted in order to do the hard upgrade operation.  This&lt;br/&gt;
will create a (small) window of unavailability while the hard upgrade&lt;br/&gt;
is performed.&lt;/p&gt;

&lt;p&gt;What I suggest is that the version of the replication protocol is&lt;br/&gt;
decided by the database version.  That is, before hard upgrade is&lt;br/&gt;
done, new software will still use the old protocol.  This means that&lt;br/&gt;
if a Derby instance is master for two databases, it may use different&lt;br/&gt;
different protocol versions to talk to the slaves, depending on the&lt;br/&gt;
version of the database.  This way, I do not think we need to be&lt;br/&gt;
concerned about ReplicationClosure.&lt;/p&gt;</comment>
                            <comment id="12521055" author="narayanan" created="Mon, 20 Aug 2007 12:28:36 +0100"  >&lt;p&gt;I have updated the patch to use Externalizable instead of Serializable. I have also hard-coded the serialVersionUID. I shall run tests on this patch and revert back. Please consider this patch for reviews and comments.&lt;/p&gt;</comment>
                            <comment id="12522746" author="narayanan" created="Sat, 25 Aug 2007 14:43:46 +0100"  >&lt;p&gt;Changes from v2 of the patch&lt;br/&gt;
----------------------------&lt;/p&gt;

&lt;p&gt;Introduction of a initiator message sent from the master to the&lt;br/&gt;
slave.&lt;br/&gt;
---------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;The initator contains the UID of the message that is sent&lt;br/&gt;
from the master to the slave. The slave upon reception of&lt;br/&gt;
the initiator message checks the UID to ensure that the&lt;br/&gt;
value is equal to the UID of its message class.&lt;/p&gt;

&lt;p&gt;If it is not equal it throws sends a message tagged as a&lt;br/&gt;
error to the slave and throws an IOException and fails to&lt;br/&gt;
startup.&lt;/p&gt;

&lt;p&gt;If it is equal it sends a message tagged as an acknowledgment&lt;br/&gt;
to the master.&lt;/p&gt;

&lt;p&gt;readExternal() and writeExternal() now recognize a version&lt;br/&gt;
number that is marshalled between the slave and the master&lt;br/&gt;
----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;This would be useful at a later stage when we decide that&lt;br/&gt;
a master and a slave that is at different UID of messages&lt;br/&gt;
can still be allowed to exchange messages with a switch on&lt;br/&gt;
the version number that is passed.&lt;/p&gt;

&lt;p&gt;Slave now defaults to localhost and 8001&lt;br/&gt;
----------------------------------------&lt;/p&gt;

&lt;p&gt;If the slave is started without mentioning the hostname&lt;br/&gt;
and the port number then it defaults to using localhost&lt;br/&gt;
and 8001 port number. This was missed out in v2.&lt;/p&gt;</comment>
                            <comment id="12522947" author="jorgenlo" created="Mon, 27 Aug 2007 09:02:43 +0100"  >&lt;p&gt;Hi Narayanan&lt;/p&gt;

&lt;p&gt;Thanks for submitting the patch. It looks good for the most part, but I have a few nits:&lt;/p&gt;

&lt;p&gt;1) The AccessController.doPrivileged lines have more than 80 chars, but I notice that you have already tried to break this up by e.g. having &quot;(Socket)&quot; on a separate line (see line 483 in the v3 diff). Feel free to ignore this...&lt;/p&gt;

&lt;p&gt;2) I wonder if defaulting to localhost is a good idea - replicating a db back to the same host seems to be little worth. Maybe we should require the host to be specified? Further, the defaultNetworkValues method in both transmitter and receiver sets both host and port to default even if only one of these are not specified. &lt;/p&gt;

&lt;p&gt;3) I would add the following info to the javadoc somewhere, possibly in the class descriptions: If the network connection is lost for some reason, both readExternal and writeExternal will get an exception (IOException?). This means that neither of these methods will loop infinitely if something is wrong with the connection.&lt;/p&gt;

&lt;p&gt;4) The variable ReplicationMessage answer = null; in ReplicationMessageTransmit#send is not used&lt;/p&gt;</comment>
                            <comment id="12523199" author="narayanan" created="Tue, 28 Aug 2007 10:09:29 +0100"  >&lt;p&gt;Thank you for the comments Jorgen!&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) I wonder if defaulting to localhost is a good idea - &lt;br/&gt;
&amp;gt; replicating a db back to the same host seems to be &lt;br/&gt;
&amp;gt; little worth. Maybe we should require the host to be &lt;br/&gt;
&amp;gt; specified? &lt;/p&gt;

&lt;p&gt;I was thinking along the lines of the NetworkServer. It was defaulting to&lt;br/&gt;
localhost. I agree that replicating to the same host seems little worth.&lt;br/&gt;
(except while testing I guess! localhost replication would be very useful&lt;br/&gt;
while writing tests that integrate into the junit tests.)&lt;/p&gt;

&lt;p&gt;But it seems harmless to me to allow it to default to localhost. Currently&lt;br/&gt;
no message is printed though. Maybe the message addition should be done&lt;br/&gt;
as part of the NetworkServer command that starts replication.&lt;/p&gt;

&lt;p&gt;&amp;gt; Further, the defaultNetworkValues method &lt;br/&gt;
&amp;gt; in both transmitter and receiver sets both host and port to default &lt;br/&gt;
&amp;gt;even if only one of these are not specified.&lt;/p&gt;

&lt;p&gt;I agree! I shall modify this.&lt;/p&gt;

&lt;p&gt;I shall fix 1), 3) and 4) also in the follow-up patch I will be submitting.&lt;/p&gt;

&lt;p&gt;Thanks once again for the comments&lt;/p&gt;</comment>
                            <comment id="12524568" author="oysteing" created="Mon, 3 Sep 2007 19:31:53 +0100"  >&lt;p&gt;Narayanan, thanks for the patch.  Here are my comments:&lt;/p&gt;

&lt;p&gt;1. ReplicationMessageTransmit and ReplicationMessageReceive has much&lt;br/&gt;
   in common, but the organization of the code differs in several&lt;br/&gt;
   places.  Examples: &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The ...Transmit constructor calls a private function which&lt;br/&gt;
        does the necessary work while ...Receive has much of the code&lt;br/&gt;
        in the constructor.&lt;/li&gt;
	&lt;li&gt;...Tramsmit has a separate class for the privileged operation,&lt;br/&gt;
        ...Receive does not.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   I think it would be better if the code was more uniform.  Maybe&lt;br/&gt;
   some of it could even be shared?  (E.g., member variables and code&lt;br/&gt;
   to resolve defaults.)&lt;/p&gt;

&lt;p&gt;2. Only part of the code in the ReplicationMessage... classes is&lt;br/&gt;
   particular to replication.  For example,&lt;br/&gt;
   ReplicationMessageTransmit#sendAndReceiveAck is the only method in&lt;br/&gt;
   that class that has any replication specific code.  I think you&lt;br/&gt;
   should consider to factor out the replication specific code to&lt;br/&gt;
   separate classes that use your Transmit and Receive classes.&lt;/p&gt;

&lt;p&gt;3. It is not clear to me what the user contract is for the&lt;br/&gt;
   ReplicationMessage... classes.  I think you need to add Javadoc&lt;br/&gt;
   that describe how they are supposed to be used, and how they behave&lt;br/&gt;
   in the normal case (e.g., it needs to be mentioned that&lt;br/&gt;
   ReplicationMessageReceive#receive does not return until an error&lt;br/&gt;
   occurs) and in a failure situation (e.g., will they try to&lt;br/&gt;
   reconnect automatically?).&lt;/p&gt;

&lt;p&gt;4. I do not think you need ReplicationMessageTransmit#s.  The socket&lt;br/&gt;
   is only referred directly in getSocketAndInputOutputStreams() and&lt;br/&gt;
   might as well be local to that method.&lt;/p&gt;

&lt;p&gt;5. I think it would be good with more meaningful names for oos and&lt;br/&gt;
   ois.  Such names are ok for local variables, but for class members&lt;br/&gt;
   I think you should use something more self-explanatory.&lt;/p&gt;

&lt;p&gt;6. The check for default values does not have to be done on every&lt;br/&gt;
   connect so I suggest it can be moved to the constructor.&lt;/p&gt;

&lt;p&gt;7. ReplicationMessageTransmit#getSocketAndInputOutputStreams has two&lt;br/&gt;
   occurences of comments where only one of ObjectOutputStream and&lt;br/&gt;
   ObjectInputStream is mentioned, but I think both should.  (javadoc&lt;br/&gt;
   and last comment).&lt;/p&gt;

&lt;p&gt;8. ReplicationMessageTransmit#send: Local variable &apos;answer&apos; is not&lt;br/&gt;
   needed.&lt;/p&gt;

&lt;p&gt;9. ReplicationMessageTransmit#send: Last sentence of comment is a bit&lt;br/&gt;
   misleading.  This code does not throw an exception if a connection&lt;br/&gt;
   is not established.  (However, I guess the underlying code will&lt;br/&gt;
   throw such an exception)&lt;/p&gt;

&lt;p&gt;10. ReplicationMessageReceive constructor takes a host address, and&lt;br/&gt;
    not a host name.  This means that the caller need to do the&lt;br/&gt;
    mapping between hostname and host address.  Would it not be better&lt;br/&gt;
    to do this mapping within the class.  That would also make the&lt;br/&gt;
    interfaces of ...Transmit and ...Receive more similar.&lt;/p&gt;

&lt;p&gt;11. ReplicationMessageReceive#createServerSocket tests whether&lt;br/&gt;
    hostname is null.  I think it should be hostAddress.&lt;/p&gt;

&lt;p&gt;12. Why is ReplicationMessageReceive#blockingRead public?  Can one&lt;br/&gt;
    call this directly instead of going through #receive?&lt;/p&gt;

&lt;p&gt;13. ReplicationMessageReceive#parseInitiatorMessage: Why check the&lt;br/&gt;
    version here?  It seems to already have been done in&lt;br/&gt;
    ReplicationMessage#readExternal.&lt;/p&gt;

&lt;p&gt;14. ReplicationMessageReceive javadoc: &quot;receives the message from &lt;br/&gt;
    the slave ...&quot;.  Is this class only to be used by the master?&lt;/p&gt;

&lt;p&gt;15. ReplicationMessage javadoc:  Should say that this is for&lt;br/&gt;
    replication.&lt;/p&gt;

&lt;p&gt;16. ReplicationMessage: I think it needs to be explicitly defined what&lt;br/&gt;
    kind of object the different types of messages will take.  (e.g.,&lt;br/&gt;
    TYPE_LOG is followed by a log record, TYPE_INITIATE is followed&lt;br/&gt;
    by a string)&lt;/p&gt;

&lt;p&gt;17. Have you considered to use SQL states instead of general text for&lt;br/&gt;
    TYPE_ERROR messages?&lt;/p&gt;

&lt;p&gt;18. I think it would be good with a unit test that tests the basic&lt;br/&gt;
    capabilities of this service.&lt;/p&gt;

&lt;p&gt;19. Nit: The code is a bit inconsistent with respect to spaces before&lt;br/&gt;
    left paranthesis.  Most Derby code does not use space after&lt;br/&gt;
    function names in declarations and calls, while space is used&lt;br/&gt;
    after reserved words like if, while, for etc.  &lt;/p&gt;</comment>
                            <comment id="12524673" author="narayanan" created="Tue, 4 Sep 2007 11:57:45 +0100"  >&lt;p&gt;Thank you for the detailed responses Oystein,&lt;/p&gt;

&lt;p&gt;I have addressed comments 4-19 and am working &lt;br/&gt;
on the comments 1, 2 and 3. I will address 1, 2 and 3&lt;br/&gt;
and post a follow up again.&lt;/p&gt;

&lt;p&gt;Some related responses&lt;/p&gt;

&lt;p&gt;-19&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Removed the spaces between the names of the functions and the parenthesis.&lt;br/&gt;
  The space between the parenthesis and the keywords however remain.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-18&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Will it be OK if I write unit test in a follow-up patch to this issue. This&lt;br/&gt;
  code is not being used for now and I feel it is harmless for now.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-17&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;For now TYPE_ERROR messages are used only during the initial exchange while&lt;br/&gt;
  exchanging UID versions. This did not contain a SQLState to be transmitted.&lt;br/&gt;
  I think this is a good idea and I will use this when a SQLException is actually&lt;br/&gt;
  thrown.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-16&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I take this comment as to mean that the javadoc should explicitly define what&lt;br/&gt;
  kind of object needs to be transmitted as part of this ReplicationMessage. I&lt;br/&gt;
  will update the javadoc to indicate what type flag corresponds to what type&lt;br/&gt;
  of message. I shall also update the type flag definitions to define what type&lt;br/&gt;
  of message each of them signify&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  For example&lt;/p&gt;

&lt;p&gt;  public static final int TYPE_LOG = 0;&lt;/p&gt;

&lt;p&gt;  will be modified to&lt;/p&gt;

&lt;p&gt;  //This flag will be used for all messages will carry LogRecords.&lt;br/&gt;
  public static final int TYPE_LOG = 0;&lt;/p&gt;

&lt;p&gt;  If any other action was expected of me here I sincerely apologize and request&lt;br/&gt;
  further elucidation of the action suggested.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;15&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I have modified the class level comment to say the following&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  This message is used for the communication between the master and the &lt;br/&gt;
  slave during Replication.&lt;/p&gt;

&lt;p&gt;  Please do mention if you think this is not good enough, I will change it&lt;br/&gt;
  again and post as per your suggestion.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;14&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ReplicationMessageReceive javadoc: &quot;receives the message from&lt;br/&gt;
  the slave ...&quot;.  Is this class only to be used by the master?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Although the class might serve a more generic purpose after the suggested&lt;br/&gt;
  factoring out of the generic network related code and the replication code&lt;br/&gt;
  in the current context the comment is correct since the intention was to use&lt;br/&gt;
  it only as a receiver of messages on the master.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;13&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I planned to use the version check in ReplicationMessage#readExternal at a later&lt;br/&gt;
  stage to be able to handle a heterogenous collection of Derby version code.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  I did not want to do version checking here during initiation because I need to be&lt;br/&gt;
  able to inform the master that it suffers from an incompatibility with the slave. I&lt;br/&gt;
  do not want to abruptly fail the slave without informing the master and if I start&lt;br/&gt;
  to inform the master for every message received it would be too much communication &lt;br/&gt;
  overload.&lt;/p&gt;

&lt;p&gt;  I thought this initiator message would allow me to establish message incompatibilities at&lt;br/&gt;
  startup and also&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;12&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I have changed the method to private.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;11&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;10&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I have changed ReplicationMessageReceive to accept a hostName. So this would take care of both 11 and 10.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;9&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Since the underlying code will throw this exception do you want me to change this comment?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;8&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Removed the local variable send.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;7&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Modified the javadoc to mention both ObjectInputStream and ObjectOuputStream&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;changed oos to objOuputStream and ois to objInputStream in both the receiver and the transmitter.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Moved the declarations as suggested.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12524721" author="oysteing" created="Tue, 4 Sep 2007 14:28:51 +0100"  >&lt;p&gt;V.Narayanan (JIRA) wrote:&lt;br/&gt;
&amp;gt; I have addressed comments 4-19 and am working &lt;br/&gt;
&amp;gt; on the comments 1, 2 and 3. I will address 1, 2 and 3&lt;br/&gt;
&amp;gt; and post a follow up again.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Thanks you for your quick response to my comments.  Generally, the&lt;br/&gt;
changes look good.  I have a few follow-up comments below.&lt;/p&gt;

&lt;p&gt;&amp;gt; -18&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * Will it be OK if I write unit test in a follow-up patch to this issue. This&lt;br/&gt;
&amp;gt;   code is not being used for now and I feel it is harmless for now.&lt;/p&gt;

&lt;p&gt;That is certainly OK.  I think that by writing tests you get&lt;br/&gt;
experience in using the interface you have created, and you may&lt;br/&gt;
realize that parts of interface should be changed.  Hence, it is good&lt;br/&gt;
to write the tests before too much code has been written that rely on&lt;br/&gt;
the current interface.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; -17&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * For now TYPE_ERROR messages are used only during the initial&lt;br/&gt;
&amp;gt;   exchange while exchanging UID versions. This did not contain a&lt;br/&gt;
&amp;gt;   SQLState to be transmitted.  I think this is a good idea and I&lt;br/&gt;
&amp;gt;   will use this when a SQLException is actually thrown.&lt;/p&gt;

&lt;p&gt;Currently, you always generate a specific SQLState&lt;br/&gt;
(REPLICATION_MASTER_SLAVE_VERSION_MISMATCH) on the master when you get&lt;br/&gt;
any error on the initial message.  Instead, this SQLState could be&lt;br/&gt;
sent by the slave when it detects a version mismatch.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; -16&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * I take this comment as to mean that the javadoc should explicitly&lt;br/&gt;
&amp;gt;   define what kind of object needs to be transmitted as part of this&lt;br/&gt;
&amp;gt;   ReplicationMessage. I will update the javadoc to indicate what&lt;br/&gt;
&amp;gt;   type flag corresponds to what type of message. I shall also update&lt;br/&gt;
&amp;gt;   the type flag definitions to define what type of message each of&lt;br/&gt;
&amp;gt;   them signify&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   For example&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   public static final int TYPE_LOG = 0;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   will be modified to&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   //This flag will be used for all messages will carry LogRecords.&lt;br/&gt;
&amp;gt;   public static final int TYPE_LOG = 0;&lt;/p&gt;

&lt;p&gt;I would like to see the object type defined (e.g., LogRecord, String)&lt;br/&gt;
for each message type.&lt;/p&gt;

&lt;p&gt;&amp;gt; - 14&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * ReplicationMessageReceive javadoc: &quot;receives the message from &lt;br/&gt;
&amp;gt;   the slave ...&quot;.  Is this class only to be used by the master?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   Although the class might serve a more generic purpose after the suggested&lt;br/&gt;
&amp;gt;   factoring out of the generic network related code and the replication code&lt;br/&gt;
&amp;gt;   in the current context the comment is correct since the intention was to use&lt;br/&gt;
&amp;gt;   it only as a receiver of messages on the master.&lt;/p&gt;

&lt;p&gt;So the slave will not use this code to listen for messages?  &lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; - 13&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * I planned to use the version check in&lt;br/&gt;
&amp;gt;   ReplicationMessage#readExternal at a later stage to be able to&lt;br/&gt;
&amp;gt;   handle a heterogenous collection of Derby version code.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   I did not want to do version checking here during initiation&lt;br/&gt;
&amp;gt;   because I need to be able to inform the master that it suffers&lt;br/&gt;
&amp;gt;   from an incompatibility with the slave. I do not want to abruptly&lt;br/&gt;
&amp;gt;   fail the slave without informing the master and if I start to&lt;br/&gt;
&amp;gt;   inform the master for every message received it would be too much&lt;br/&gt;
&amp;gt;   communication overload.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   I thought this initiator message would allow me to establish&lt;br/&gt;
&amp;gt;   message incompatibilities at startup and also&lt;/p&gt;

&lt;p&gt;But if there is a mismatch, the check in readExternal will throw an&lt;br/&gt;
IOException before you are able to inspect the content of the message.&lt;br/&gt;
Or have I misunderstood something?&lt;/p&gt;


&lt;p&gt;&amp;gt; - 11&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; - 10&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * I have changed ReplicationMessageReceive to accept a hostName. So&lt;br/&gt;
&amp;gt;   this would take care of both 11 and 10.&lt;/p&gt;

&lt;p&gt;Looks good, but note that the getLocalHost in defaultNetworkValues is&lt;br/&gt;
not necessary anymore since AFAIK this will have already been done&lt;br/&gt;
when getByName is called by the constructor and the supplied hostName&lt;br/&gt;
is null.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; - 9&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * Since the underlying code will throw this exception do you want me&lt;br/&gt;
&amp;gt;   to change this comment?&lt;/p&gt;

&lt;p&gt;Yes, I think the comment is a bit misleading.&lt;/p&gt;


&lt;p&gt;&amp;gt; - 7&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * Modified the javadoc to mention both ObjectInputStream and ObjectOuputStream&lt;/p&gt;

&lt;p&gt;What about the comment in the catch block?  Cannot an error also happen&lt;br/&gt;
in the initialization of ObjectOutputStream?&lt;/p&gt;
</comment>
                            <comment id="12526038" author="narayanan" created="Mon, 10 Sep 2007 02:31:06 +0100"  >&lt;p&gt;&amp;gt;That is certainly OK. I think that by writing tests you get&lt;br/&gt;
&amp;gt;experience in using the interface you have created, and you may&lt;br/&gt;
&amp;gt;realize that parts of interface should be changed. Hence, it is good&lt;br/&gt;
&amp;gt;to write the tests before too much code has been written that rely on&lt;br/&gt;
&amp;gt;the current interface.&lt;/p&gt;

&lt;p&gt;The current code is not used in any part of the codebase for now.&lt;br/&gt;
I find it difficult to factor in tests which would use the code.&lt;br/&gt;
I humbly request that this code be allowed to remain for now and&lt;br/&gt;
promise to write comprehensive tests that shall cover all the&lt;br/&gt;
capabilities of this code once the features that use this code are&lt;br/&gt;
put in.&lt;/p&gt;

&lt;p&gt;&amp;gt;Currently, you always generate a specific SQLState&lt;br/&gt;
&amp;gt;(REPLICATION_MASTER_SLAVE_VERSION_MISMATCH) on the master when you get&lt;br/&gt;
&amp;gt;any error on the initial message. Instead, this SQLState could be&lt;br/&gt;
&amp;gt;sent by the slave when it detects a version mismatch.&lt;/p&gt;

&lt;p&gt;Modified to sending SQLState instead of generic message.&lt;/p&gt;

&lt;p&gt;&amp;gt;I would like to see the object type defined (e.g., LogRecord, String)&lt;br/&gt;
&amp;gt;for each message type.&lt;/p&gt;

&lt;p&gt;done!&lt;/p&gt;

&lt;p&gt;Eg.&lt;/p&gt;

&lt;p&gt;// This flag is used to send an acknowledgment of successful completion &lt;br/&gt;
// of a requested operation. It will however not be used to signify &lt;br/&gt;
// reception for every message transmission. The object this message&lt;br/&gt;
// type contains will be a &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt;.&lt;br/&gt;
public static final int TYPE_ACK = 1;&lt;/p&gt;

&lt;p&gt;&amp;gt;So the slave will not use this code to listen for messages?&lt;/p&gt;

&lt;p&gt;No the communication will only be through the streams obtained from&lt;br/&gt;
the socket after the initial connection has been established.&lt;/p&gt;

&lt;p&gt;&amp;gt;But if there is a mismatch, the check in readExternal will throw an&lt;br/&gt;
&amp;gt;IOException before you are able to inspect the content of the message.&lt;br/&gt;
&amp;gt;Or have I misunderstood something?&lt;/p&gt;

&lt;p&gt;You are correct. I have removed the check in readExternl.&lt;/p&gt;

&lt;p&gt;&amp;gt;Looks good, but note that the getLocalHost in defaultNetworkValues is&lt;br/&gt;
&amp;gt;not necessary anymore since AFAIK this will have already been done&lt;br/&gt;
&amp;gt;when getByName is called by the constructor and the supplied hostName&lt;br/&gt;
&amp;gt;is null.&lt;/p&gt;

&lt;p&gt;Since I now use a new class that contains all the attributes and&lt;br/&gt;
initializations common to the network classes I have allowed this to&lt;br/&gt;
remain in the common initializer class. I will remove this if it is felt &lt;br/&gt;
that this is not OK.&lt;/p&gt;

&lt;p&gt;&amp;gt;Yes, I think the comment is a bit misleading.(related to comment no 9)&lt;/p&gt;

&lt;p&gt;I have removed this.&lt;/p&gt;

&lt;p&gt;&amp;gt;What about the comment in the catch block? Cannot an error also happen&lt;br/&gt;
&amp;gt;in the initialization of ObjectOutputStream? &lt;/p&gt;

&lt;p&gt;fixed this comment.&lt;/p&gt;

&lt;p&gt;&amp;gt;1. ReplicationMessageTransmit and ReplicationMessageReceive has much&lt;br/&gt;
&amp;gt;   in common, but the organization of the code differs in several&lt;br/&gt;
&amp;gt;   places. Examples:&lt;br/&gt;
&amp;gt;      - The ...Transmit constructor calls a private function which&lt;br/&gt;
&amp;gt;        does the necessary work while ...Receive has much of the code&lt;br/&gt;
&amp;gt;        in the constructor.&lt;br/&gt;
&amp;gt;      - ...Tramsmit has a separate class for the privileged operation,&lt;br/&gt;
&amp;gt;        ...Receive does not.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   I think it would be better if the code was more uniform. Maybe&lt;br/&gt;
&amp;gt;   some of it could even be shared? (E.g., member variables and code&lt;br/&gt;
&amp;gt;   to resolve defaults.)&lt;/p&gt;

&lt;p&gt;I have factored the common attributes and methods into a class&lt;br/&gt;
ClientServerSocketCommon.&lt;/p&gt;

&lt;p&gt;&amp;gt;2. Only part of the code in the ReplicationMessage... classes is&lt;br/&gt;
&amp;gt;   particular to replication. For example,&lt;br/&gt;
&amp;gt;   ReplicationMessageTransmit#sendAndReceiveAck is the only method in&lt;br/&gt;
&amp;gt;   that class that has any replication specific code. I think you&lt;br/&gt;
&amp;gt;   should consider to factor out the replication specific code to&lt;br/&gt;
&amp;gt;   separate classes that use your Transmit and Receive classes.&lt;/p&gt;

&lt;p&gt;The transmit class is now broken into &lt;/p&gt;

&lt;p&gt;ReplicationClientSocketUtil - That contains the Network related methods&lt;br/&gt;
ReplicationMessageTransmit  - That handles the actual transmission of the&lt;br/&gt;
                              messages and the setting up of the connection.&lt;/p&gt;

&lt;p&gt;I could not do the same with ReplicationMessageReceive because the receive class&lt;br/&gt;
actually would be receiving on the client socket and then on the Input Stream obtained&lt;br/&gt;
from this socket. Hence now we would have once class that listens on a socket upon&lt;br/&gt;
receiving a message relinquishes control to another which would handle this message&lt;br/&gt;
and again take back control from this class.&lt;/p&gt;

&lt;p&gt;We cannot have multi-threading here because we need the log records to be written in the&lt;br/&gt;
log file in the same order in which they are received. If we use threading we would need&lt;br/&gt;
to schedule these threads appropriately which would again become cumbersome.&lt;/p&gt;

&lt;p&gt;&amp;gt;3. It is not clear to me what the user contract is for the&lt;br/&gt;
&amp;gt;   ReplicationMessage... classes. I think you need to add Javadoc&lt;br/&gt;
&amp;gt;   that describe how they are supposed to be used, and how they behave&lt;br/&gt;
&amp;gt;   in the normal case (e.g., it needs to be mentioned that&lt;br/&gt;
&amp;gt;   ReplicationMessageReceive#receive does not return until an error&lt;br/&gt;
&amp;gt;   occurs) and in a failure situation (e.g., will they try to&lt;br/&gt;
&amp;gt;   reconnect automatically?). &lt;/p&gt;

&lt;p&gt;I have added method specifics to the javadocs of all the related methods and shall add&lt;br/&gt;
more information if you think this is not sufficient.&lt;/p&gt;</comment>
                            <comment id="12526153" author="oysteing" created="Mon, 10 Sep 2007 13:34:50 +0100"  >&lt;p&gt;V.Narayanan (JIRA) wrote:&lt;br/&gt;
&amp;gt;&amp;gt; That is certainly OK. I think that by writing tests you get&lt;br/&gt;
&amp;gt;&amp;gt; experience in using the interface you have created, and you may&lt;br/&gt;
&amp;gt;&amp;gt; realize that parts of interface should be changed. Hence, it is good&lt;br/&gt;
&amp;gt;&amp;gt; to write the tests before too much code has been written that rely on&lt;br/&gt;
&amp;gt;&amp;gt; the current interface.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The current code is not used in any part of the codebase for now.&lt;br/&gt;
&amp;gt; I find it difficult to factor in tests which would use the code.&lt;br/&gt;
&amp;gt; I humbly request that this code be allowed to remain for now and&lt;br/&gt;
&amp;gt; promise to write comprehensive tests that shall cover all the&lt;br/&gt;
&amp;gt; capabilities of this code once the features that use this code are&lt;br/&gt;
&amp;gt; put in.&lt;/p&gt;

&lt;p&gt;As I said, it is OK for me to commit this without tests. However, I do&lt;br/&gt;
not see that it should be very difficult to write a small test program&lt;br/&gt;
that opens a connection and sends a message using you new interfaces.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; So the slave will not use this code to listen for messages?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; No the communication will only be through the streams obtained from&lt;br/&gt;
&amp;gt; the socket after the initial connection has been established.&lt;/p&gt;

&lt;p&gt;Either you did not understand my question, or I did not understand&lt;br/&gt;
your answer.  I was asking why the class javadoc only talk about&lt;br/&gt;
receiving messages from the slave, which you confirmed meant that the&lt;br/&gt;
class is only to be used by the master.  So what code will the slave&lt;br/&gt;
use to listen for messages?  Will there be another class for that?&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt; 1. ReplicationMessageTransmit and ReplicationMessageReceive has much&lt;br/&gt;
&amp;gt;&amp;gt;   in common, but the organization of the code differs in several&lt;br/&gt;
&amp;gt;&amp;gt;   places. Examples:&lt;br/&gt;
&amp;gt;&amp;gt;      - The ...Transmit constructor calls a private function which&lt;br/&gt;
&amp;gt;&amp;gt;        does the necessary work while ...Receive has much of the code&lt;br/&gt;
&amp;gt;&amp;gt;        in the constructor.&lt;br/&gt;
&amp;gt;&amp;gt;      - ...Tramsmit has a separate class for the privileged operation,&lt;br/&gt;
&amp;gt;&amp;gt;        ...Receive does not.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;   I think it would be better if the code was more uniform. Maybe&lt;br/&gt;
&amp;gt;&amp;gt;   some of it could even be shared? (E.g., member variables and code&lt;br/&gt;
&amp;gt;&amp;gt;   to resolve defaults.)&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I have factored the common attributes and methods into a class&lt;br/&gt;
&amp;gt; ClientServerSocketCommon.&lt;/p&gt;

&lt;p&gt;Great, I will look at your new patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; 2. Only part of the code in the ReplicationMessage... classes is&lt;br/&gt;
&amp;gt;&amp;gt;   particular to replication. For example,&lt;br/&gt;
&amp;gt;&amp;gt;   ReplicationMessageTransmit#sendAndReceiveAck is the only method in&lt;br/&gt;
&amp;gt;&amp;gt;   that class that has any replication specific code. I think you&lt;br/&gt;
&amp;gt;&amp;gt;   should consider to factor out the replication specific code to&lt;br/&gt;
&amp;gt;&amp;gt;   separate classes that use your Transmit and Receive classes.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The transmit class is now broken into &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; ReplicationClientSocketUtil - That contains the Network related methods&lt;br/&gt;
&amp;gt; ReplicationMessageTransmit  - That handles the actual transmission of the&lt;br/&gt;
&amp;gt;                               messages and the setting up of the connection.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I could not do the same with ReplicationMessageReceive because the&lt;br/&gt;
&amp;gt; receive class actually would be receiving on the client socket and&lt;br/&gt;
&amp;gt; then on the Input Stream obtained from this socket. Hence now we&lt;br/&gt;
&amp;gt; would have once class that listens on a socket upon receiving a&lt;br/&gt;
&amp;gt; message relinquishes control to another which would handle this&lt;br/&gt;
&amp;gt; message and again take back control from this class.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; We cannot have multi-threading here because we need the log records&lt;br/&gt;
&amp;gt; to be written in the log file in the same order in which they are&lt;br/&gt;
&amp;gt; received. If we use threading we would need to schedule these&lt;br/&gt;
&amp;gt; threads appropriately which would again become cumbersome.&lt;/p&gt;

&lt;p&gt;I did not quite follow this, but note that separate classes does not&lt;br/&gt;
necessarily mean separate threads.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; 3. It is not clear to me what the user contract is for the&lt;br/&gt;
&amp;gt;&amp;gt;   ReplicationMessage... classes. I think you need to add Javadoc&lt;br/&gt;
&amp;gt;&amp;gt;   that describe how they are supposed to be used, and how they behave&lt;br/&gt;
&amp;gt;&amp;gt;   in the normal case (e.g., it needs to be mentioned that&lt;br/&gt;
&amp;gt;&amp;gt;   ReplicationMessageReceive#receive does not return until an error&lt;br/&gt;
&amp;gt;&amp;gt;   occurs) and in a failure situation (e.g., will they try to&lt;br/&gt;
&amp;gt;&amp;gt;   reconnect automatically?). &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I have added method specifics to the javadocs of all the related&lt;br/&gt;
&amp;gt; methods and shall add more information if you think this is not&lt;br/&gt;
&amp;gt; sufficient.&lt;/p&gt;

&lt;p&gt;Great, I will look at it, and report back.&lt;/p&gt;</comment>
                            <comment id="12526373" author="narayanan" created="Tue, 11 Sep 2007 08:27:36 +0100"  >&lt;p&gt;&amp;gt;As I said, it is OK for me to commit this without tests. However, I do&lt;br/&gt;
&amp;gt;not see that it should be very difficult to write a small test program&lt;br/&gt;
&amp;gt;that opens a connection and sends a message using you new interfaces.&lt;/p&gt;

&lt;p&gt;I will factor in tests for this code. I will reattach a patch containing tests&lt;br/&gt;
for this code.&lt;/p&gt;

&lt;p&gt;&amp;gt;Either you did not understand my question, or I did not understand&lt;br/&gt;
&amp;gt;your answer. I was asking why the class javadoc only talk about&lt;br/&gt;
&amp;gt;receiving messages from the slave, which you confirmed meant that the&lt;br/&gt;
&amp;gt;class is only to be used by the master. So what code will the slave&lt;br/&gt;
&amp;gt;use to listen for messages? Will there be another class for that?&lt;/p&gt;

&lt;p&gt;I am very sorry for this. It is me who is wrong. The slave receives messages&lt;br/&gt;
from the master and it will use the ReplicationMessageReceive to receive messages&lt;br/&gt;
from the master. The comment in the class&lt;br/&gt;
&quot;It receives the message from the slave&quot;  is wrong and is mis-leading.&lt;br/&gt;
I will correct this. Thank you for pointing this out.&lt;/p&gt;</comment>
                            <comment id="12527884" author="narayanan" created="Sun, 16 Sep 2007 19:01:12 +0100"  >&lt;p&gt;Pls find attached the patch contains the Network part of the replication code changed to conform to the class diagrams attached in Derby-2872. Also pls find attached a text file that explains the summary of the changes.&lt;/p&gt;

&lt;p&gt;I tested the network code with standalone programs for now. The following&lt;br/&gt;
code snipet would start the receiver.&lt;/p&gt;

&lt;p&gt;        ReplicationMessageReceive rec = new ReplicationMessageReceive(null, -1);&lt;br/&gt;
        rec.initConnection();&lt;/p&gt;

&lt;p&gt;and the following would start the transmitter and cause it to send the&lt;br/&gt;
initiator message breaking the accept wait of the receiver.&lt;/p&gt;

&lt;p&gt;        ReplicationMessageTransmit send = new &lt;br/&gt;
            ReplicationMessageTransmit(null, -1);&lt;br/&gt;
        send.initConnection();&lt;/p&gt;

&lt;p&gt;The code helps to check that the transmission and the reception of messages and the &lt;br/&gt;
parsing of the initiator message is happening correctly. Pls note that in this case &lt;br/&gt;
the network classes would use the default values for the host name and the port number.&lt;/p&gt;

&lt;p&gt;This code can be further extended to test the Receiver and the transmitter for other&lt;br/&gt;
type of replication messages, but I am hoping that this exercise can wait for creation&lt;br/&gt;
of further interfaces that actually use the network code.&lt;/p&gt;

&lt;p&gt;I am running tests on this code and shall revert back with results as soon as the tests&lt;br/&gt;
complete.&lt;/p&gt;

&lt;p&gt;I request for this patch to be considered for reviews and comments.&lt;/p&gt;</comment>
                            <comment id="12528060" author="oysteing" created="Mon, 17 Sep 2007 14:37:50 +0100"  >&lt;p&gt;Patch is starting to look very good, Narayanan!  Most of my comments are minor nits:&lt;/p&gt;

&lt;p&gt;1. The javadoc for public classes and methods should focus on how it&lt;br/&gt;
   is to be used, not on its implementation. Some of the javadoc for&lt;br/&gt;
   fields just says the obvious, instead of what it represents. (E.g.,&lt;br/&gt;
   &quot;Stores an instance of the SlaveAddress class&quot;.  If you know Java,&lt;br/&gt;
   you know this.  No need to tell people that. Instead, you should&lt;br/&gt;
   tell that slaveAddress contains the address to the slave to&lt;br/&gt;
   replicate to.)&lt;/p&gt;

&lt;p&gt;2. In javadoc, I think @throws needs to be repeated for each&lt;br/&gt;
   exception. &lt;/p&gt;

&lt;p&gt;3. ReplicationMessageTransmit#sendAndReceiveAck: If an error is&lt;br/&gt;
   returned, why not use ack.getMessage() to get the SQLState?&lt;/p&gt;

&lt;p&gt;4. SlaveAddress: I suggest to drop &apos;Slave&apos; from getSlaveHostAddress()&lt;br/&gt;
   and getSlavePortNumber() since that should be implicit from the&lt;br/&gt;
   name of the class.&lt;/p&gt;

&lt;p&gt;5. ReplicationMessageReceive: It seems unecessary to have serverSocket&lt;br/&gt;
   as a member field when it is only used by one method.  I think it&lt;br/&gt;
   could be local to initConnection().&lt;/p&gt;

&lt;p&gt;6. SocketConnection:  I think you should deal with Objects in this&lt;br/&gt;
   class and let the replication specific casting be done by the&lt;br/&gt;
   ReplicationMessage... classes.&lt;/p&gt;

&lt;p&gt;7. SocketConnection#writeMessage: The previous version did reset&lt;br/&gt;
   before writing and flush after.  Have you decided that this is not&lt;br/&gt;
   necessary?&lt;/p&gt;

&lt;p&gt;8. ReplicationMessage:&lt;/p&gt;

&lt;p&gt;   a) I thought messages of type TYPE_LOG, would contain LogRecord&lt;br/&gt;
      objects, not byte arrays.&lt;/p&gt;

&lt;p&gt;   b) Why not use Integer or Long instead of String for the UID part&lt;br/&gt;
      of TYPE_INITIATE?&lt;/p&gt;

&lt;p&gt;   c) VERSION_MISMATCH does not seem to be used.&lt;/p&gt;

&lt;p&gt;   d) If you are able to cast the UID to int, why not store it as an&lt;br/&gt;
      integer instead of as a long?&lt;/p&gt;



</comment>
                            <comment id="12528677" author="narayanan" created="Wed, 19 Sep 2007 08:03:08 +0100"  >&lt;p&gt;Thank you for the detailed reviews and comments Oystein!&lt;/p&gt;

&lt;p&gt;1 - I did a scan of all the javadoc in the current patch and have modified&lt;br/&gt;
    them to comply to the suggestions. &lt;/p&gt;

&lt;p&gt;2 - I have added @throws tag to all the exceptions.&lt;/p&gt;

&lt;p&gt;3 - I have changed the Initator to accept a long do the following now,&lt;/p&gt;

&lt;p&gt;    ReplicationMessage initiatorMsg = new ReplicationMessage&lt;br/&gt;
    (ReplicationMessage.TYPE_INITIATE, new Long(&lt;br/&gt;
    ReplicationMessage.serialVersionUID));&lt;/p&gt;

&lt;p&gt;    I have also changed the name of the method to sendInitiatorAndReceiveAck&lt;br/&gt;
    since it first sends a initiator messages and receives a ack corresponding&lt;br/&gt;
    to that.&lt;/p&gt;

&lt;p&gt;4 - The method names have been changed to getHostAddress() and getPortNumber().&lt;/p&gt;

&lt;p&gt;5 - I have made serverSocket local.&lt;/p&gt;

&lt;p&gt;6 - The methods in SocketConnection do not cast anymore. The casts are instead&lt;br/&gt;
    done in the place where these methods are used.&lt;/p&gt;

&lt;p&gt;7 - I have changed the methods to do the reset and the flush.&lt;/p&gt;

&lt;p&gt;8 - TYPE_LOG - changed to LogRecord&lt;/p&gt;

&lt;p&gt;    TYPE_INITIATE - uses a Long now.&lt;/p&gt;

&lt;p&gt;    VERSION_MISMATCH has been removed.&lt;/p&gt;</comment>
                            <comment id="12528678" author="narayanan" created="Wed, 19 Sep 2007 08:04:58 +0100"  >&lt;p&gt;3 - I meant that I have added @throws tags to all the javadocs corresponding to&lt;br/&gt;
     the exceptions&lt;/p&gt;</comment>
                            <comment id="12528681" author="narayanan" created="Wed, 19 Sep 2007 08:27:50 +0100"  >&lt;p&gt;I am running tests on v7 and shall revert back with the results as soon as the tests finish.&lt;/p&gt;</comment>
                            <comment id="12528697" author="narayanan" created="Wed, 19 Sep 2007 09:53:22 +0100"  >&lt;p&gt;&amp;gt; I thought messages of type TYPE_LOG, would contain LogRecord&lt;br/&gt;
&amp;gt; objects, not byte arrays. &lt;/p&gt;

&lt;p&gt;LogRecords are sent as a chunk in the form of byte arrays. In my previous patch I had changed the object to be of type LogRecord, this was wrong. I am changing it back to byte array.&lt;/p&gt;</comment>
                            <comment id="12528723" author="oysteing" created="Wed, 19 Sep 2007 11:07:40 +0100"  >&lt;p&gt;Thanks for the new patch Narayanan, the changes look good.  I have a&lt;br/&gt;
few minor comments that I did not detect the previous time around:&lt;/p&gt;

&lt;p&gt;9. SlaveAddress: Why since it is the address that will be returned,&lt;br/&gt;
   why not store the address instead of the hostname?&lt;/p&gt;

&lt;p&gt;10. SocketConnection: &lt;/p&gt;

&lt;p&gt;    a) socket could be local to the constructor since it is not used&lt;br/&gt;
       in other methods.&lt;/p&gt;

&lt;p&gt;    b) I would like an explanation for why writeMessage does reset()&lt;br/&gt;
       and flush().&lt;/p&gt;

&lt;p&gt;    c) I suggest to refer all references to replication messages in&lt;br/&gt;
       comments and use message objects instead.&lt;/p&gt;

&lt;p&gt;11. ReplicationMessageTransmit#sendInitiatorAndReceiveAck:  The cast&lt;br/&gt;
    to ReplicationMessage is redundant.&lt;/p&gt;

&lt;p&gt;12. The added files no longer end with a newline.&lt;/p&gt;</comment>
                            <comment id="12529002" author="narayanan" created="Thu, 20 Sep 2007 07:52:36 +0100"  >&lt;p&gt;Thank you for the comments and reviews Oystein. I have addressed all the issues pointed out by you.&lt;/p&gt;

&lt;p&gt;For the following&lt;/p&gt;

&lt;p&gt;&amp;gt;I would like an explanation for why writeMessage does reset()&lt;br/&gt;
&amp;gt;and flush(). &lt;/p&gt;

&lt;p&gt;I had earlier added these methods for the following reason&lt;/p&gt;

&lt;p&gt;reset() - to ensure that any previously existing data is deleted before a&lt;br/&gt;
              new replication message is sent. Since flush() would send all the&lt;br/&gt;
              data from a stream the existing of previous data in a stream would  &lt;br/&gt;
              mean a wrong data is present. Hence I thought reset() would take&lt;br/&gt;
              care of this.&lt;/p&gt;

&lt;p&gt;              But I think this would be unnecessary since this situation can &lt;br/&gt;
              happen only if there is an error in the previous transmission and&lt;br/&gt;
              tcp should throw an error in this situation&lt;/p&gt;

&lt;p&gt;flush() - I had added to ensure that all the data is sent from the stream &lt;br/&gt;
             amd have added a comment for the same.&lt;/p&gt;

&lt;p&gt;In addition to this I have also fixed some more comments and javadoc&lt;br/&gt;
that I found could be improved when I did a scan on the patch.&lt;/p&gt;

&lt;p&gt;I am running tests on this patch and shall revert back with results as&lt;br/&gt;
soon as the tests finish.&lt;/p&gt;

&lt;p&gt;Thanks once again for the detailed reviews and comments.&lt;/p&gt;</comment>
                            <comment id="12529023" author="oysteing" created="Thu, 20 Sep 2007 09:41:48 +0100"  >&lt;p&gt;Thanks for the new patch.  It looks very good.  I will commit it later today if no problems show up when running tests.&lt;/p&gt;

&lt;p&gt;I have a minor nit that you may consider to include if there is a later update in this area:  I think it could be enlightening if it was explained in the SlaveAddress constructor that InetAddress#getByName will return the default (localhost) if no host name is given.  Hence, no explicit handling of default is necessary for the host address.&lt;/p&gt;</comment>
                            <comment id="12529035" author="narayanan" created="Thu, 20 Sep 2007 10:28:41 +0100"  >&lt;p&gt;&amp;gt;I think it could be enlightening if it was explained in the SlaveAddress &amp;gt;constructor that InetAddress#getByName will return the default &amp;gt;(localhost) if no host name is given. Hence, no explicit handling of default &amp;gt;is necessary for the host address.&lt;/p&gt;

&lt;p&gt;done!&lt;/p&gt;</comment>
                            <comment id="12529360" author="oysteing" created="Fri, 21 Sep 2007 10:53:14 +0100"  >&lt;p&gt;Committed patch, Replication_Network_v10.diff, with revison 577731&lt;/p&gt;</comment>
                            <comment id="12530660" author="knutanders" created="Thu, 27 Sep 2007 10:00:18 +0100"  >&lt;p&gt;Shouldn&apos;t ReplicationMessage.readExternal() throw an exception if the version is incorrect? As it is now, it checks the version and just leaves all fields as null values if it is incorrect. I think the appropriate exception is java.io.InvalidClassException (sub-class of IOException).&lt;/p&gt;

&lt;p&gt;I&apos;m not sure the version check in parseInitiatorMessage() works. If the version is incorrect, ReplicationMessage.getMessage() will return null. That means this line fails with a NullPointerException:&lt;/p&gt;

&lt;p&gt;        //Get the UID of the master&lt;br/&gt;
        long masterVersion = ((Long)initiatorMessage.getMessage()).longValue();&lt;/p&gt;

&lt;p&gt;So we never get to the point where we actually check the version.&lt;/p&gt;

&lt;p&gt;By the way, do we need 8 bytes (a long) to represent the version, or would a smaller data type suffice?&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12382576">DERBY-3206</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12365949" name="Replication_Network_expln_v6.txt" size="3079" author="narayanan" created="Sun, 16 Sep 2007 19:01:12 +0100"/>
                            <attachment id="12362745" name="Replication_Network_v1.diff" size="24806" author="narayanan" created="Mon, 30 Jul 2007 07:13:28 +0100"/>
                            <attachment id="12362746" name="Replication_Network_v1.stat" size="628" author="narayanan" created="Mon, 30 Jul 2007 07:13:28 +0100"/>
                            <attachment id="12366268" name="Replication_Network_v10.diff" size="34324" author="narayanan" created="Thu, 20 Sep 2007 10:28:41 +0100"/>
                            <attachment id="12366269" name="Replication_Network_v10.stat" size="650" author="narayanan" created="Thu, 20 Sep 2007 10:28:41 +0100"/>
                            <attachment id="12364137" name="Replication_Network_v2.diff" size="26597" author="narayanan" created="Mon, 20 Aug 2007 12:28:36 +0100"/>
                            <attachment id="12364138" name="Replication_Network_v2.stat" size="628" author="narayanan" created="Mon, 20 Aug 2007 12:28:36 +0100"/>
                            <attachment id="12364555" name="Replication_Network_v3.diff" size="32352" author="narayanan" created="Sat, 25 Aug 2007 14:43:46 +0100"/>
                            <attachment id="12364556" name="Replication_Network_v3.stat" size="566" author="narayanan" created="Sat, 25 Aug 2007 14:43:46 +0100"/>
                            <attachment id="12365056" name="Replication_Network_v4.diff" size="34451" author="narayanan" created="Tue, 4 Sep 2007 11:57:45 +0100"/>
                            <attachment id="12365057" name="Replication_Network_v4.stat" size="566" author="narayanan" created="Tue, 4 Sep 2007 11:57:45 +0100"/>
                            <attachment id="12365437" name="Replication_Network_v5.diff" size="40000" author="narayanan" created="Mon, 10 Sep 2007 02:31:06 +0100"/>
                            <attachment id="12365438" name="Replication_Network_v5.stat" size="761" author="narayanan" created="Mon, 10 Sep 2007 02:31:06 +0100"/>
                            <attachment id="12365947" name="Replication_Network_v6.diff" size="33743" author="narayanan" created="Sun, 16 Sep 2007 19:01:12 +0100"/>
                            <attachment id="12365948" name="Replication_Network_v6.stat" size="650" author="narayanan" created="Sun, 16 Sep 2007 19:01:12 +0100"/>
                            <attachment id="12366157" name="Replication_Network_v7.diff" size="33431" author="narayanan" created="Wed, 19 Sep 2007 08:02:49 +0100"/>
                            <attachment id="12366158" name="Replication_Network_v7.stat" size="650" author="narayanan" created="Wed, 19 Sep 2007 08:02:58 +0100"/>
                            <attachment id="12366164" name="Replication_Network_v8.diff" size="33453" author="narayanan" created="Wed, 19 Sep 2007 09:53:21 +0100"/>
                            <attachment id="12366165" name="Replication_Network_v8.stat" size="650" author="narayanan" created="Wed, 19 Sep 2007 09:53:22 +0100"/>
                            <attachment id="12366260" name="Replication_Network_v9.diff" size="34130" author="narayanan" created="Thu, 20 Sep 2007 07:52:36 +0100"/>
                            <attachment id="12366261" name="Replication_Network_v9.stat" size="650" author="narayanan" created="Thu, 20 Sep 2007 07:52:36 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 11 Jul 2007 14:06:28 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30656</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0jyf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37051</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>