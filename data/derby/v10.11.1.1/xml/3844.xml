<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:33:41 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3844/DERBY-3844.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3844] ASSERT failure in BasePage.unlatch() when running LobStreamsTest</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3844</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I saw this failure when running suites.All to test the patch nested_transaction_v2.diff which is posted on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3693&quot; title=&quot;Deadlocks accessing DB metadata&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3693&quot;&gt;&lt;del&gt;DERBY-3693&lt;/del&gt;&lt;/a&gt;. The failure did not occur when I reran the test, and I don&apos;t believe the patch should have any effect on the code that failed. The ASSERT that is triggered is this one (which indicates that we&apos;re trying to unlatch a page that&apos;s not latched):&lt;/p&gt;

&lt;p&gt;		if (SanityManager.DEBUG) &lt;/p&gt;
{
			SanityManager.ASSERT(isLatched());
		}

&lt;p&gt;Here&apos;s the full stack trace and thread dump:&lt;/p&gt;

&lt;p&gt;1) testBlobWrite3Param(org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest)org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED&lt;br/&gt;
	at org.apache.derby.shared.common.sanity.SanityManager.ASSERT(SanityManager.java:98)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BasePage.unlatch(BasePage.java:1319)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.OverflowInputStream.fillByteHolder(OverflowInputStream.java:152)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BufferedByteHolderInputStream.read(BufferedByteHolderInputStream.java:44)&lt;br/&gt;
	at java.io.DataInputStream.read(DataInputStream.java:132)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.PositionedStoreStream.read(PositionedStoreStream.java:106)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.AutoPositioningStream.read(AutoPositioningStream.java:113)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.UpdatableBlobStream.read(UpdatableBlobStream.java:194)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest.readBytesFromStream(LobStreamsTest.java:463)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest.compareLob2File(LobStreamsTest.java:488)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest.testBlobWrite3Param(LobStreamsTest.java:130)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:104)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
---------------&lt;br/&gt;
Stack traces for all live threads:&lt;br/&gt;
Thread name=derby.antiGC id=280 priority=1 state=WAITING isdaemon=true&lt;br/&gt;
	java.lang.Object.wait(Native Method)&lt;br/&gt;
	java.lang.Object.wait(Object.java:485)&lt;br/&gt;
	org.apache.derby.impl.services.monitor.AntiGC.run(BaseMonitor.java:2217)&lt;br/&gt;
	java.lang.Thread.run(Thread.java:619)&lt;/p&gt;

&lt;p&gt;Thread name=Signal Dispatcher id=4 priority=9 state=RUNNABLE isdaemon=true&lt;/p&gt;

&lt;p&gt;Thread name=main id=1 priority=5 state=RUNNABLE isdaemon=false&lt;br/&gt;
	java.lang.Thread.dumpThreads(Native Method)&lt;br/&gt;
	java.lang.Thread.getAllStackTraces(Thread.java:1477)&lt;br/&gt;
	org.apache.derby.shared.common.sanity.ThreadDump.getStackDumpString(ThreadDump.java:34)&lt;br/&gt;
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	org.apache.derby.shared.common.sanity.AssertFailure$1.run(AssertFailure.java:165)&lt;br/&gt;
	java.security.AccessController.doPrivileged(Native Method)&lt;br/&gt;
	org.apache.derby.shared.common.sanity.AssertFailure.dumpThreads(AssertFailure.java:159)&lt;br/&gt;
	org.apache.derby.shared.common.sanity.AssertFailure.&amp;lt;init&amp;gt;(AssertFailure.java:82)&lt;br/&gt;
	org.apache.derby.shared.common.sanity.SanityManager.ASSERT(SanityManager.java:98)&lt;br/&gt;
	org.apache.derby.impl.store.raw.data.BasePage.unlatch(BasePage.java:1319)&lt;br/&gt;
	org.apache.derby.impl.store.raw.data.OverflowInputStream.fillByteHolder(OverflowInputStream.java:152)&lt;br/&gt;
	org.apache.derby.impl.store.raw.data.BufferedByteHolderInputStream.read(BufferedByteHolderInputStream.java:44)&lt;br/&gt;
	java.io.DataInputStream.read(DataInputStream.java:132)&lt;br/&gt;
	org.apache.derby.impl.jdbc.PositionedStoreStream.read(PositionedStoreStream.java:106)&lt;br/&gt;
	org.apache.derby.impl.jdbc.AutoPositioningStream.read(AutoPositioningStream.java:113)&lt;br/&gt;
	org.apache.derby.impl.jdbc.UpdatableBlobStream.read(UpdatableBlobStream.java:194)&lt;br/&gt;
	org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest.readBytesFromStream(LobStreamsTest.java:463)&lt;br/&gt;
	org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest.compareLob2File(LobStreamsTest.java:488)&lt;br/&gt;
	org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest.testBlobWrite3Param(LobStreamsTest.java:130)&lt;br/&gt;
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:104)&lt;br/&gt;
	junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;/p&gt;

&lt;p&gt;Thread name=derby.rawStoreDaemon id=941 priority=5 state=TIMED_WAITING isdaemon=true&lt;br/&gt;
	java.lang.Object.wait(Native Method)&lt;br/&gt;
	org.apache.derby.impl.services.daemon.BasicDaemon.rest(BasicDaemon.java:571)&lt;br/&gt;
	org.apache.derby.impl.services.daemon.BasicDaemon.run(BasicDaemon.java:388)&lt;br/&gt;
	java.lang.Thread.run(Thread.java:619)&lt;/p&gt;

&lt;p&gt;Thread name=Timer-3 id=281 priority=5 state=WAITING isdaemon=true&lt;br/&gt;
	java.lang.Object.wait(Native Method)&lt;br/&gt;
	java.lang.Object.wait(Object.java:485)&lt;br/&gt;
	java.util.TimerThread.mainLoop(Timer.java:483)&lt;br/&gt;
	java.util.TimerThread.run(Timer.java:462)&lt;/p&gt;

&lt;p&gt;Thread name=Finalizer id=3 priority=8 state=WAITING isdaemon=true&lt;br/&gt;
	java.lang.Object.wait(Native Method)&lt;br/&gt;
	java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:116)&lt;br/&gt;
	java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:132)&lt;br/&gt;
	java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)&lt;/p&gt;

&lt;p&gt;Thread name=Reference Handler id=2 priority=10 state=WAITING isdaemon=true&lt;br/&gt;
	java.lang.Object.wait(Native Method)&lt;br/&gt;
	java.lang.Object.wait(Object.java:485)&lt;br/&gt;
	java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)&lt;/p&gt;

&lt;p&gt;Thread name=derby.rawStoreDaemon id=933 priority=5 state=TIMED_WAITING isdaemon=true&lt;br/&gt;
	java.lang.Object.wait(Native Method)&lt;br/&gt;
	org.apache.derby.impl.services.daemon.BasicDaemon.rest(BasicDaemon.java:571)&lt;br/&gt;
	org.apache.derby.impl.services.daemon.BasicDaemon.run(BasicDaemon.java:388)&lt;br/&gt;
	java.lang.Thread.run(Thread.java:619)&lt;/p&gt;


&lt;p&gt;---------------&lt;/p&gt;</description>
                <environment>Solaris 10, AMD Opteron with 2 CPUs, Java(TM) SE Runtime Environment (build 1.6.0_06-b02), Derby trunk revision 686755</environment>
        <key id="12402790">DERBY-3844</key>
            <summary>ASSERT failure in BasePage.unlatch() when running LobStreamsTest</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kristwaa">Kristian Waagan</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Thu, 21 Aug 2008 13:50:11 +0100</created>
                <updated>Mon, 12 Jul 2010 23:47:51 +0100</updated>
                            <resolved>Mon, 12 Jul 2010 23:47:51 +0100</resolved>
                                    <version>10.5.1.1</version>
                    <version>10.6.1.0</version>
                                    <fixVersion>10.5.3.1</fixVersion>
                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12726859" author="kristwaa" created="Fri, 3 Jul 2009 10:59:19 +0100"  >&lt;p&gt;Triaged July 3, 2009: Assigned normal urgency.&lt;/p&gt;</comment>
                            <comment id="12779436" author="kristwaa" created="Wed, 18 Nov 2009 13:03:46 +0000"  >&lt;p&gt;Attaching a repro for the bug.&lt;br/&gt;
Even though generating the junk data seems to trigger garbage collection, I added calls to do gc and finalization for good measure (I&apos;m aware that the call to do gc may be a no-op).&lt;/p&gt;

&lt;p&gt;The trouble in this case is the use of the pattern rs.getBlob(1).blobMethod(), followed by another operation on the same BLOB field, and combined with gc/finalization. The result set generates a new Blob object for each call to getBlob, and this object has a finalize-method closing the source stream (and unlatching the source page).&lt;/p&gt;

&lt;p&gt;Without having studied this in detail, I think there are two main lines of fixing this:&lt;br/&gt;
 1) Disallow calling getBlob multiple times on the same column (and the same row).&lt;br/&gt;
 2) Make the result set smarter, or somehow make sure the source stream isn&apos;t closed too early.&lt;/p&gt;

&lt;p&gt;(1) is the simplest, but may break existing applications (including some of our own tests for sure). I have not consulted the JDBC spec on this.&lt;br/&gt;
(2) is probably harder, may have performance impacts and we run the risk of introducing resource leaks (this may be cleaned up in commit/rollback anyway). I think it should be possible to get this right, but it will make the result set slightly fatter.&lt;/p&gt;

&lt;p&gt;The discussion about calling various result set methods multiple times seems familiar, but I&apos;m not sure we reached consensus the last time...&lt;br/&gt;
The Java SE 6 JavaDoc isn&apos;t very authoritative:&lt;br/&gt;
&quot;For maximum portability, result set columns within each row should be read in left-to-right order, and each column should be read only once.&quot;&lt;/p&gt;

&lt;p&gt;Having gotten this far in my post, won&apos;t this be a problem anyway if the user calls Blob.free?&lt;br/&gt;
Assuming obtaining multiple Blob-objects for the same BLOB field is allowed, should a Blob.free affect the other &quot;instances&quot;?&lt;/p&gt;


&lt;p&gt;I fear we are about to wander off into the tall weeds, and in my opinion we should try to improve the situation such that it is clear to the user what is allowed and what isn&apos;t when it comes to LOBs and streams. I don&apos;t know how much stricter we would have to be, and I&apos;m willing to postpone this until 11.0, but I&apos;d rather do it earlier.&lt;br/&gt;
I&apos;m far from having the overview, but note that other situations get us into trouble too. We already have Jiras logged where queries like &quot;select blob as b1, blob as b2&quot;  cause errors.&lt;/p&gt;</comment>
                            <comment id="12779480" author="bryanpendleton" created="Wed, 18 Nov 2009 15:10:47 +0000"  >&lt;p&gt;The two separate calls to getBlob() share the same underlying stream, and the finalizer for the first blob&lt;br/&gt;
object closes the stream out from underneath the second blob? Is that correct?&lt;/p&gt;

&lt;p&gt;Could we use a reference-counted wrapper around the stream so that each blob could record&lt;br/&gt;
its own &quot;interest&quot; in the blob, and would know when it was the last blob to release the stream,&lt;br/&gt;
and thus it was safe to close it?&lt;/p&gt;</comment>
                            <comment id="12779935" author="kristwaa" created="Thu, 19 Nov 2009 11:04:27 +0000"  >&lt;p&gt;Your understanding is correct, Bryan.&lt;/p&gt;

&lt;p&gt;Something along the lines you describe will most probably work, but may require changes to the stream class down in store. You have one real source stream, but other streams may be &quot;spliced off&quot; from it. Add another couple of layers and you&apos;re up into the outer JDBC realm &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, I think we have issues we cannot address at this level. I don&apos;t have a deep enough understanding of what&apos;s going on yet, but I hope to spend some more time investigating soon.&lt;br/&gt;
One thing we have to do, is to agree on what is going to be allowed. From the realm of Blobs, consider these pieces of pseudo-code:&lt;/p&gt;

&lt;p&gt;1) select blob as b1, blob as b2 from blobtable&lt;/p&gt;

&lt;p&gt;2) // Pattern where the Blob references aren&apos;t kept. GC has side-effects currently.&lt;br/&gt;
    stream = rs.getBlob(1).getBinaryStream()&lt;br/&gt;
    length = rs.getBlob(1).length()&lt;br/&gt;
    // Do something here, assume GC / finalization will take place.&lt;br/&gt;
    // Now read from the stream.&lt;br/&gt;
    stream.read(buf) // &amp;lt;-- fails&lt;/p&gt;

&lt;p&gt;3) Blob b1 = rs.getBlob(1)&lt;br/&gt;
    // Process b1.&lt;br/&gt;
    // Note sure if b2 will be invalid if b1.free() is called here, or if obtaining b2 will latch/lock the resources again.&lt;br/&gt;
    // If you obtain b1 and b2 at the same time, and then call free on one of them, the other will be invalidated.&lt;br/&gt;
    Blob b2 = rs.getBlob(1)&lt;br/&gt;
    // Process b2.&lt;/p&gt;

&lt;p&gt;4) Blob b1 = rs.getBlob(1)&lt;br/&gt;
    stream1 = b1.getBinaryStream(1024, 4096)&lt;br/&gt;
    stream2 = b1.getBinaryStream(10240, 2048)&lt;br/&gt;
    // Process both streams &quot;concurrently&quot;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1) is definitely allowed by SQL. This is the simple example, a cross join is more complex and may end up referencing the same Blob multiple times (in different rows of the result).&lt;/li&gt;
	&lt;li&gt;In (2), should it be forbidden to call getBlob(1) multiple times, should we return the same Blob object, or should the two Blobs be independent on each other? This gets worse if updates come into play...&lt;/li&gt;
	&lt;li&gt;Case (3) is much like (2), but the effects on the two Blob objects are caused by explicit method calls only.&lt;/li&gt;
	&lt;li&gt;(4) adds yet another level, and here we support update-aware streams currently. In this case I believe we&apos;re talking about changes to this specific Blob-instance.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think (1) and (4) may be the more natural use-cases, whereas (2) and (3) can be categorized as corner cases &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. All issues here are related to having several handles to the same source data.&lt;br/&gt;
With the exception of class (1), the user can work around these issues by changing the application code (unless a framework generates / uses code that trigger these issues). The whole thing would just be simpler to deal with if there were clear rules &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Related Jiras: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3645&quot; title=&quot;Insert into selecting BLOB column twice leads to SQLException: Restore of a serializable or SQLData object of class error selecting from the table&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3645&quot;&gt;&lt;del&gt;DERBY-3645&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3646&quot; title=&quot;Embedded returns wrong results when selecting a blob column twice and using getBinaryStream()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3646&quot;&gt;&lt;del&gt;DERBY-3646&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3650&quot; title=&quot;internal multiple references from different rows to a single BLOB/CLOB stream leads to various errors when second reference used.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3650&quot;&gt;&lt;del&gt;DERBY-3650&lt;/del&gt;&lt;/a&gt; (there are probably more)&lt;/p&gt;</comment>
                            <comment id="12805855" author="kristwaa" created="Thu, 28 Jan 2010 10:07:02 +0000"  >&lt;p&gt;We should address this issue, as it is rather confusing for the user and it might also be hard to debug (timing dependent).&lt;/p&gt;

&lt;p&gt;I propose tightening the rules, such that it is only allowed to access a LOB column once (per row) with the ResultSet.get-methods. This will be very much like what we do for the getXStream-methods already.&lt;br/&gt;
The JDBC standard doesn&apos;t say much about this, but this sentence from the Java SE 6 API JavaDoc does apply:&lt;br/&gt;
&quot;For maximum portability, result set columns within each row should be read in left-to-right order, and each column should be read only once.&quot;&lt;br/&gt;
In the list above this means that usages (2) and (3) will be disallowed.&lt;/p&gt;

&lt;p&gt;Implementing this restriction includes at least the following work:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;add code to track column access (for LOB-columns) in the result set implementations&lt;/li&gt;
	&lt;li&gt;write a release note, as this change may break existing applications&lt;/li&gt;
	&lt;li&gt;rewrite a few of our tests (got 41 errors in total for suites.All, but some of these were caused by resources not being cleaned up after the first failure caused by the change)&lt;br/&gt;
   For instance: testClobCharacterWrite1Char(org.apache.derbyTesting.functionTests.tests.jdbcapi.LobStreamsTest)java.sql.SQLException: Complex column value (stream or LOB) in result cannot be retrieved twice&lt;br/&gt;
   In this case I just reused the message for streams and modified it to fit both. Should there be two different messages or can the example text above be improved?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As an experiment I also tried using the cloning methods added in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4520&quot; title=&quot;Refactor and extend data type cloning facilities&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4520&quot;&gt;&lt;del&gt;DERBY-4520&lt;/del&gt;&lt;/a&gt;. This seemed to work, the repro passed. This suggests that we can add support for retrieving a LOB twice at a later time if we get such requests.&lt;br/&gt;
However, I haven&apos;t investigated fully, and I don&apos;t know if there are situations where we have to serve data from non-store streams that aren&apos;t implementing CloneableStream.&lt;/p&gt;

&lt;p&gt;What do people think about the suggested restriction?&lt;/p&gt;</comment>
                            <comment id="12805897" author="knutanders" created="Thu, 28 Jan 2010 12:48:34 +0000"  >&lt;p&gt;I think it sounds like a reasonable restriction to only allow LOB values to be accessed once. Failing gracefully sounds like a much better option than the current behaviour with intermittent assert failures and Java-level deadlocks. Of course, it would be nice to have a more liberal implementation, but that could be added later if someone finds it useful and feels like implementing it.&lt;/p&gt;</comment>
                            <comment id="12805905" author="knutanders" created="Thu, 28 Jan 2010 13:01:49 +0000"  >&lt;p&gt;&amp;gt; java.sql.SQLException: Complex column value (stream or LOB) in&lt;br/&gt;
&amp;gt; result cannot be retrieved twice&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; In this case I just reused the message for streams and modified it&lt;br/&gt;
&amp;gt; to fit both. Should there be two different messages or can the&lt;br/&gt;
&amp;gt; example text above be improved?&lt;/p&gt;

&lt;p&gt;I think it&apos;s fine to share the message between these two cases, since&lt;br/&gt;
they are so similar. I&apos;d remove &quot;complex column value&quot;, I think, and&lt;br/&gt;
just say&lt;/p&gt;

&lt;p&gt;  Stream or LOB value cannot be retrieved more than once&lt;/p&gt;</comment>
                            <comment id="12832051" author="kristwaa" created="Wed, 10 Feb 2010 16:29:48 +0000"  >&lt;p&gt;Patch 1a disallows accessing a LOB column more than once.&lt;br/&gt;
High level patch description:&lt;br/&gt;
 o modified message XCL18, and deleted all the translations of it&lt;br/&gt;
 o added DataValueDescriptor.hasStream, which makes it clearer where we actually want to fetch the stream and where we just want to check if there is a stream or not&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;currently only SQLBlob and SQLClob override the default implementation&lt;br/&gt;
 o replaced several dvd.getStream() != null  with dvd.hashStream()&lt;/li&gt;
	&lt;li&gt;as part of this I also refactored some code in  EmbedBlob&lt;br/&gt;
 o renamed variables and methods for checking if a column has already been accessed&lt;br/&gt;
 o added checks if the LOB column has already been accessed in getBlob and getBlob, both in the embedded and the client driver&lt;/li&gt;
	&lt;li&gt;also added some more comments&lt;/li&gt;
	&lt;li&gt;made the boolean array (columnUsedFlags_) be lazily initialized in the client driver (this included basically rewriting two small methods)&lt;br/&gt;
 o modified a few tests failing because of the new restriction&lt;br/&gt;
 o added two regression tests in LobStreamsTest&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will also have to write a release note for this fix, as existing applications may be affected by it.&lt;/p&gt;

&lt;p&gt;I&apos;m running the full regression tests now, will post the result when they&apos;re done.&lt;br/&gt;
Patch ready for review.&lt;/p&gt;</comment>
                            <comment id="12832895" author="kristwaa" created="Fri, 12 Feb 2010 08:53:48 +0000"  >&lt;p&gt;Patch 1b fixes errors in jdbcapi.ClosedObjectTest discovered when running the full regression tests by moving the call to useStreamOrLOB to after the check for if the result set is open (failed with NPE because the meta data is cleared when closing).&lt;/p&gt;

&lt;p&gt;Patch ready for review, re-running tests.&lt;/p&gt;</comment>
                            <comment id="12833754" author="kristwaa" created="Mon, 15 Feb 2010 10:40:59 +0000"  >&lt;p&gt;I overlooked an error in the compatibility suite. Again, the JDBCDriverTest fails because it fetched LOBs several times from the same column on a single row.&lt;br/&gt;
Patch 2a rewrites the test, basically be iterating over the different types and coercions instead of iterating over the rows. The query is executed once per check.&lt;br/&gt;
Note that I deleted some unused methods in JDBCDriverTest. There were no comments indicating they would be useful for debugging, so I assumed they were left-overs from the test development phase.&lt;/p&gt;

&lt;p&gt;I compared the output from the original test and the new test to make sure that no tests were lost during the rewrite (to see the output you have to run with drb.tests.debug=true).&lt;/p&gt;

&lt;p&gt;Patch 1b depends on 2a to run cleanly.&lt;br/&gt;
Patch ready for review.&lt;/p&gt;</comment>
                            <comment id="12833788" author="kristwaa" created="Mon, 15 Feb 2010 12:37:23 +0000"  >&lt;p&gt;First take on a release note.&lt;/p&gt;</comment>
                            <comment id="12834169" author="kristwaa" created="Tue, 16 Feb 2010 11:30:08 +0000"  >&lt;p&gt;Committed patch 2a to trunk with revision 910481.&lt;br/&gt;
I&apos;ll await at least one successful test run in the nightly regression test before considering committing patch 1a.&lt;/p&gt;</comment>
                            <comment id="12835736" author="kristwaa" created="Fri, 19 Feb 2010 12:58:23 +0000"  >&lt;p&gt;Attached patch 1c.&lt;br/&gt;
I pulled out the cleanup code, as it just cluttered up the patch too much (will address the issue in a separate Jira).&lt;/p&gt;

&lt;p&gt;Committed patch 1c to trunk with revision 911793.&lt;/p&gt;

&lt;p&gt;I think this concludes the code work on this issue. Feel free to review the release note.&lt;/p&gt;</comment>
                            <comment id="12837784" author="knutanders" created="Wed, 24 Feb 2010 13:38:38 +0000"  >&lt;p&gt;The release note looks good to me. (One small typo, though: Applications which obtains -&amp;gt; Applications which obtain)&lt;/p&gt;</comment>
                            <comment id="12838252" author="kristwaa" created="Thu, 25 Feb 2010 08:55:42 +0000"  >&lt;p&gt;Thank you, Knut Anders.&lt;/p&gt;

&lt;p&gt;I fixed the typo and uploaded the release note again.&lt;/p&gt;</comment>
                            <comment id="12838264" author="kristwaa" created="Thu, 25 Feb 2010 09:17:55 +0000"  >&lt;p&gt;Resolving issue.&lt;/p&gt;

&lt;p&gt;This fix could be back-ported to 10.5 (maybe even 10.4), but that may break existing applications using get&lt;span class=&quot;error&quot;&gt;&amp;#91;BC&amp;#93;&lt;/span&gt;lob. The problem can / must be fixed in the application code. No changes to the Derby source code is required, but without the changes in patch 1a it is up to the application programmer to do the right thing (Derby won&apos;t scream).&lt;/p&gt;

&lt;p&gt;I&apos;m not sure how likely it is that existing applications calling get&lt;span class=&quot;error&quot;&gt;&amp;#91;BC&amp;#93;&lt;/span&gt;lob multiple times work, but since the bug is timing dependent there is a slight chance.&lt;br/&gt;
One argument for back-porting the fix is that one of the symptoms of the underlying problem is a Java deadlock (the other is an exception being raised).&lt;/p&gt;

&lt;p&gt;Please advice.&lt;/p&gt;</comment>
                            <comment id="12838270" author="knutanders" created="Thu, 25 Feb 2010 09:25:28 +0000"  >&lt;p&gt;I think it&apos;s fine not to back-port the fix, since there&apos;s a known workaround if someone experiences the bug.&lt;/p&gt;</comment>
                            <comment id="12884460" author="lilywei" created="Thu, 1 Jul 2010 23:13:09 +0100"  >&lt;p&gt;Reopen to 10.5 back port&lt;/p&gt;</comment>
                            <comment id="12887409" author="kmarsden" created="Mon, 12 Jul 2010 17:25:39 +0100"  >&lt;p&gt;Assigned to myself for 10.5 backport&lt;/p&gt;</comment>
                            <comment id="12887574" author="kmarsden" created="Mon, 12 Jul 2010 23:47:50 +0100"  >&lt;p&gt;completed 10.5 back port&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12440282">DERBY-4440</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12417271">DERBY-4102</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                                                <inwardlinks description="is required by">
                                        <issuelink>
            <issuekey id="12468384">DERBY-4728</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12435456" name="derby-3844-1a-disallow_multiple_accesses.diff" size="59698" author="kristwaa" created="Wed, 10 Feb 2010 16:29:48 +0000"/>
                            <attachment id="12435457" name="derby-3844-1a-disallow_multiple_accesses.stat" size="1955" author="kristwaa" created="Wed, 10 Feb 2010 16:29:48 +0000"/>
                            <attachment id="12425335" name="derby-3844-1a-repro_test.diff" size="2931" author="kristwaa" created="Wed, 18 Nov 2009 13:03:46 +0000"/>
                            <attachment id="12435676" name="derby-3844-1b-disallow_multiple_accesses.diff" size="59982" author="kristwaa" created="Fri, 12 Feb 2010 08:53:48 +0000"/>
                            <attachment id="12436320" name="derby-3844-1c-disallow_multiple_accesses.diff" size="49642" author="kristwaa" created="Fri, 19 Feb 2010 12:58:23 +0000"/>
                            <attachment id="12435858" name="derby-3844-2a-jdbcdriver_test_rewrite.diff" size="11269" author="kristwaa" created="Mon, 15 Feb 2010 10:40:59 +0000"/>
                            <attachment id="12436979" name="releaseNote.html" size="4642" author="kristwaa" created="Thu, 25 Feb 2010 08:55:42 +0000"/>
                            <attachment id="12435862" name="releaseNote.html" size="4643" author="kristwaa" created="Mon, 15 Feb 2010 12:37:23 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 3 Jul 2009 09:59:19 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23873</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0pm7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37968</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>