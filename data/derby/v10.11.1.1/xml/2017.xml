<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:51:20 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2017/DERBY-2017.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2017] Client driver can insert and commit partial data when a LOB stream throws IOException or does not match the specified length</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2017</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When a LOB stream throws an exception or does not match the specified length, the client driver does not raise an exception until it has finished executing the statement. Therefore, the statement will be executed (and possibly committed) on the server even though the client reports that the statement failed.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12354260">DERBY-2017</key>
            <summary>Client driver can insert and commit partial data when a LOB stream throws IOException or does not match the specified length</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kristwaa">Kristian Waagan</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Mon, 30 Oct 2006 08:55:23 +0000</created>
                <updated>Fri, 6 Sep 2013 22:20:26 +0100</updated>
                            <resolved>Sat, 24 Apr 2010 18:44:22 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>JDBC</component>
                    <component>Network Client</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12445522" author="knutanders" created="Mon, 30 Oct 2006 09:02:06 +0000"  >&lt;p&gt;Attached a repro which shows the problem when using PreparedStatement.setCharacterStream() with a stream that is longer than the specified length.&lt;/p&gt;

&lt;p&gt;The embedded driver aborts the query and throws &quot;java.sql.SQLException: An IOException was thrown when reading a &apos;java.sql.String&apos; from an InputStream.&quot;&lt;/p&gt;

&lt;p&gt;The client driver completes the query (inserts a row) and throws &quot;java.sql.SQLException: Network protocol error: the specified size of the InputStream, parameter #1, is less than the actual InputStream length.&quot;&lt;/p&gt;

&lt;p&gt;The client driver should abort the the query and not insert the row.&lt;/p&gt;</comment>
                            <comment id="12445568" author="knutanders" created="Mon, 30 Oct 2006 12:00:57 +0000"  >&lt;p&gt;When this issue has been fixed, jdbcapi/CharacterStreamsTest should be updated so that it runs with the client driver.&lt;/p&gt;</comment>
                            <comment id="12456412" author="sv204098" created="Thu, 7 Dec 2006 13:46:45 +0000"  >&lt;p&gt;When an error occurs, rolling back the transaction in network mode so as the database remains consistent.&lt;br/&gt;
Handling the scenario in the same way its done in org.apache.derby.client.am.Statement.checkForStoredProcResultSetCount() which rolls back the transaction on error.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;also modified the test CharacterStreamsTest to run under client mode.&lt;/li&gt;
	&lt;li&gt;derbyall &amp;amp; Junit tests runs fine.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12456414" author="sv204098" created="Thu, 7 Dec 2006 13:51:13 +0000"  >&lt;p&gt;Adding fixed version to 10.2.2 also&lt;/p&gt;</comment>
                            <comment id="12456452" author="bryanpendleton" created="Thu, 7 Dec 2006 15:33:41 +0000"  >&lt;p&gt;Hi Saurabh,&lt;/p&gt;

&lt;p&gt;After the discussion on the mailing list regarding this issue I&apos;m still&lt;br/&gt;
confused. Does your change proposal make the network client configuration&apos;s&lt;br/&gt;
behavior match the embedded system behavior? Or do the two configurations&lt;br/&gt;
behave differently? See this part of the discussion:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/forum/ViewPost.jtp?post=7735323&amp;amp;framed=y&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/forum/ViewPost.jtp?post=7735323&amp;amp;framed=y&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m worried that it is incorrect to roll back the entire transaction for&lt;br/&gt;
this error; that only the statement that caused the LOB problem should&lt;br/&gt;
be rolled back.&lt;/p&gt;</comment>
                            <comment id="12456523" author="sv204098" created="Thu, 7 Dec 2006 18:41:09 +0000"  >&lt;p&gt;Well with this approach, the two configurations will behave differently. In embedded mode, in case of error, only the erroneous statement will make no effect on database and rest of the statements in transaction will remain unaffected by the error. Whereas in network mode, in case of error, the complete transaction will be rolled back so that the database can remain in consistent state (which is not handled currently as pointed out in repro).&lt;/p&gt;

&lt;p&gt;I tried searching options from DRDA specifications but the DO_NOT_CONTINUE_ON_ERROR flag provided in DSS header will not be of any use as the error is at client side. Thanks to Julo for pointing this out.&lt;/p&gt;

&lt;p&gt;Apart, as mentioned by Knut also, the closest we can get as long as we&apos;re using DRDA. Can we try any other approach for this.&lt;br/&gt;
Comments/Suggestions.&lt;/p&gt;</comment>
                            <comment id="12457921" author="rhillegas" created="Tue, 12 Dec 2006 22:29:58 +0000"  >&lt;p&gt;Unknown release vehicle.&lt;/p&gt;</comment>
                            <comment id="12465791" author="kristwaa" created="Thu, 18 Jan 2007 15:48:16 +0000"  >&lt;p&gt;Clearing patch available flag.&lt;br/&gt;
The issue seems to be stalled. I think we need another round of effort to decide what is an acceptable approach.&lt;br/&gt;
If the community reaches consensus on using the approach implemented by the existing patch, please set the patch available flag again.&lt;/p&gt;</comment>
                            <comment id="12466994" author="sv204098" created="Wed, 24 Jan 2007 11:18:49 +0000"  >&lt;p&gt;Thanks Kristian for bringing this issue to attention and another round of discussion over it.&lt;/p&gt;

&lt;p&gt;Till now, according to my approach, While an error occurs, in the network mode, the complete transaction will be rolled back. This is to make sure that Data is in consistent state, but this approach also rollbacks some correct operations on database (all insert, updates &amp;amp;  delete prior to the erroneous statement). This behavior is is different from that of the embedded mode.&lt;/p&gt;

&lt;p&gt;To make the consistent behavior for both embedded &amp;amp; network mode, there should be an mechanism by which the client should be able to communicate to server that the last operation is invalid &amp;amp; only this operation has to be reverted. This implies that at the time of error rather than ignoring the read error, the client need to fire another statement to revert the current changes done at server (currently client calls connection_.writeCommitSubstitute_(); ). So how should we go ahead for this approach ?&lt;/p&gt;</comment>
                            <comment id="12500076" author="sv204098" created="Wed, 30 May 2007 10:26:35 +0100"  >&lt;p&gt;I will not be working on this anymore, so un-assigning myself&lt;/p&gt;</comment>
                            <comment id="12501138" author="mayureshnirhali" created="Mon, 4 Jun 2007 09:23:57 +0100"  >&lt;p&gt;This is a HIGH VALUE FIX CANDIDATE.&lt;/p&gt;

&lt;p&gt;I did some more investigation to understand the exact difference in client behavior compared to the embedded.&lt;br/&gt;
In embedded mode, the stream is checked for its data by ReadertoUTF8Stream to see if the length specified is matching with the number of characters in the stream. An exception is raised if the length is not matched, hence we see the exception in the repro.&lt;/p&gt;

&lt;p&gt;Client does not check for stream data before hand and reads the stream data only when that is needed to pass onto to the server. So, by the time the lenght matching errors are caught, the DSS header  and the full/partial data is sent to the server.&lt;/p&gt;

&lt;p&gt;I tried a different approach (attached patch) to fix this bug. The stream is read (like in embedded mode) to validate the length much before the DSS header is sent to the server.&lt;/p&gt;

&lt;p&gt;The patch is not  ready for commit, but it solves the problem. I feel, validation of stream should be done even before the place in attached patch, something like in LocatorStream which is under development. Like in embedded, a new method &apos;checkSufficientData&apos; should be implemented in a class that is equivalent to ReaderToUTF8Stream in embedded.&lt;/p&gt;

&lt;p&gt;I would like to see comments on this approach from experts.&lt;/p&gt;</comment>
                            <comment id="12501161" author="narayanan" created="Mon, 4 Jun 2007 10:25:07 +0100"  >&lt;p&gt;I have a few questions, pls feel free to ignore them if you think they are unrelated.&lt;/p&gt;

&lt;p&gt;1) By &quot;The stream is read (like in embedded mode) to validate the length&quot; is it meant that the&lt;br/&gt;
    Stream should be materialized completely  in tempChars (the array used in the patch &lt;br/&gt;
    attached)? &lt;/p&gt;

&lt;p&gt;    If this is true wouldn&apos;t it result in OutOfMemory problems when the stream is too large?&lt;/p&gt;

&lt;p&gt;2) The logic used to see that the exception must be thrown is&lt;br/&gt;
     a) Read length bytes (InputStream.read(byte[] b, int off, int len))&lt;br/&gt;
     b) Read one more byte (read()) if this returns -1 means that the stream has&lt;br/&gt;
          no more data.&lt;/p&gt;

&lt;p&gt;     If the above two steps is the algorithm for the logic the following&lt;br/&gt;
     snippet from the API doc of InputStream.read(byte[] b, int off, int len) might be&lt;br/&gt;
     relevant &quot;An attempt is made to read as many as len bytes, but a smaller &lt;br/&gt;
     number may be read, possibly zero. The number of bytes actually read is returned &lt;br/&gt;
     as an integer.&quot;&lt;/p&gt;

&lt;p&gt;3)  Also in derby2017_try1.diff bytesToRead is no longer used. bytesToRead is&lt;br/&gt;
     set to the minimum of DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount.&lt;br/&gt;
     I think this is the maximum chunk size that can be sent. Has derby2017_try1.diff&lt;br/&gt;
     been tried with a stream of size greater than 32767?&lt;/p&gt;

&lt;p&gt;Sorry if the above seem like random thoughts.&lt;/p&gt;</comment>
                            <comment id="12501179" author="narayanan" created="Mon, 4 Jun 2007 12:27:56 +0100"  >&lt;p&gt;Some thoughts on this issue.&lt;/p&gt;

&lt;p&gt;The solution for this is difficult because of the following reason&lt;/p&gt;

&lt;p&gt;The idea of not causing an OutOfMemory error in the client is that &lt;br/&gt;
you should transmit the data without materializing it. &lt;/p&gt;

&lt;p&gt;But how would you get the length then? This would be necessary to&lt;br/&gt;
throw the stream truncation exception that is thrown.&lt;/p&gt;

&lt;p&gt;I somehow feel that the trick of not writing this data should lie in the server&lt;br/&gt;
and the client rather than in the client alone.&lt;/p&gt;

&lt;p&gt;a) The server should keep with it the data it gets from the stream sent as chunks&lt;br/&gt;
   without writing it into the database. &lt;/p&gt;

&lt;p&gt;b) When the client reaches the end of the stream it comes to know that the &lt;br/&gt;
   truncation has happened it would inform the server that truncation has&lt;br/&gt;
   happened and the server does not write the data.&lt;/p&gt;

&lt;p&gt;The above outlined steps would be possible if the PreparedStatement were&lt;br/&gt;
converted to use locators. So when a setBinaryStream is called&lt;/p&gt;

&lt;p&gt;a) create a locator value&lt;/p&gt;

&lt;p&gt;b) write the stream to the locator value(using CLOBSETSTRING or BLOBSETBYTES)&lt;/p&gt;

&lt;p&gt;c) If truncation happens Call CLOBRELEASELOCATOR and release this value.&lt;br/&gt;
   Note: here we have not gone to the PreparedStatement execute as yet.&lt;/p&gt;

&lt;p&gt;d) If there is not truncation do what happens in locators attach the stream&lt;br/&gt;
   to the PreparedStatement as happens for locators now.&lt;/p&gt;

&lt;p&gt;Drawbacks&lt;br/&gt;
---------&lt;/p&gt;

&lt;p&gt;1) This implementation would mean not using Layer-B streaming for Prepared Statements. &lt;br/&gt;
   Layer-B streaming is a better way to transmit this stream data than locators&lt;br/&gt;
   which was the reason that during locator work the decision was taken to &lt;br/&gt;
   retain Layer-B implementation here. See Derby-2529.&lt;/p&gt;

&lt;p&gt;2) Locators involve building a temporary LOB on the server. This would again&lt;br/&gt;
   make it less efficient than Layer-B streaming.&lt;/p&gt;</comment>
                            <comment id="12501180" author="mayureshnirhali" created="Mon, 4 Jun 2007 12:29:38 +0100"  >&lt;p&gt;Thanks narayanan for your comments.&lt;/p&gt;

&lt;p&gt;As I mentioned earlier, this patch is incomplete. I was aware of 2) and 3) from your comments, but wanted to put up a prototype for this different approach, so that it is clear; hence the patch. &lt;/p&gt;

&lt;p&gt;But, with 1) that I missed, I see the challenges with this approach. Materializing large streams at client side is not preferred at all. &lt;/p&gt;

&lt;p&gt;However, length must be known in order to construct appropriate DSS. JDBC 3.0 spec hints that the length specified in setBinaryStream should be equal to the length of the stream. Validating this is preferred at Client side to avoid the cost of data transfer in such error cases.&lt;/p&gt;

&lt;p&gt;Making the behavior consistent with the embedded is tricky here due to the client-server nature.&lt;/p&gt;

&lt;p&gt;... looking for more inputs.&lt;/p&gt;</comment>
                            <comment id="12501214" author="knutanders" created="Mon, 4 Jun 2007 14:40:06 +0100"  >&lt;p&gt;I think what Narayanan proposed sounds interesting. It would solve both the OutOfMemoryError problem and the problems with invalid length or errors when reading the stream, and it would make the commit/rollback behaviour identical on client and embedded.&lt;/p&gt;

&lt;p&gt;Of the drawbacks he mentioned, I agree that (2) probably would reduce the performance. Not sure how much, though. However, I&apos;m not sure drawback (1) is such a big issue. If I remember correctly, Tomohito tested the performance of layer A vs layer B streaming once and didn&apos;t notice any improvement with layer B.&lt;/p&gt;</comment>
                            <comment id="12502750" author="mayureshnirhali" created="Fri, 8 Jun 2007 11:58:31 +0100"  >&lt;p&gt;Thanks a lot Narayanan and Knut.&lt;/p&gt;

&lt;p&gt;After some more investigation, I figured that the Locator support needed to implement the suggested solution is not yet complete on the trunk.&lt;/p&gt;

&lt;p&gt;Also, regarding the drawbacks narayanan mentioned, I feel drawback 2) could degrade the performance considerably because of more number of round-trips even before the execution.&lt;/p&gt;

&lt;p&gt;I think, It make sense to revisit this issue later (probably after 10.3).&lt;br/&gt;
Comments are welcome!&lt;/p&gt;</comment>
                            <comment id="12537365" author="kmarsden" created="Wed, 24 Oct 2007 18:24:54 +0100"  >&lt;p&gt;Mayuresh, are you actively working on this issue?&lt;/p&gt;</comment>
                            <comment id="12537622" author="mayureshnirhali" created="Thu, 25 Oct 2007 15:55:09 +0100"  >&lt;p&gt;Cathey, I am not working on this issue.&lt;br/&gt;
Currently, I am tied up with something and hence un-assigning myself.&lt;/p&gt;

</comment>
                            <comment id="12611949" author="narayanan" created="Wed, 9 Jul 2008 10:05:02 +0100"  >&lt;p&gt;One of the solutions proposed in the discussions above is converting Prepared/Callable&lt;br/&gt;
statements to use locators. Has this solution been rejected?&lt;/p&gt;</comment>
                            <comment id="12612863" author="knutanders" created="Fri, 11 Jul 2008 13:38:27 +0100"  >&lt;p&gt;No, it hasn&apos;t been rejected, but it was indicated that it might have negative impact on the performance. One alternative is to add a product-specific code point so that we have a way to indicate to the server that an error has happened. See &quot;Developing Product-Unique Extensions&quot; in DRDA, Version 4, Volume 3, Section 2.5.5.4 for details.&lt;/p&gt;</comment>
                            <comment id="12728625" author="knutanders" created="Wed, 8 Jul 2009 11:51:51 +0100"  >&lt;p&gt;Triaged for 10.5.2.&lt;/p&gt;</comment>
                            <comment id="12832890" author="kristwaa" created="Fri, 12 Feb 2010 08:36:27 +0000"  >&lt;p&gt;(cleared the in-progress flag, had to assign the issue to myself to do this)&lt;/p&gt;</comment>
                            <comment id="12835771" author="kristwaa" created="Fri, 19 Feb 2010 15:15:30 +0000"  >&lt;p&gt;I haven&apos;t looked into the details, but DRDA has a mechanism for interrupting DRDA requests. However, this requires that the client opens a new connection to the server to issue the request.&lt;br/&gt;
Without knowing how hard this will be to implement, does this sound as a viable solution?&lt;/p&gt;

&lt;p&gt;Interrupting the server is an exceptional case, so I guess the performance of the mentioned solution isn&apos;t critical (i.e. create new connection, send the request,  receive reply, throw exception and do cleanup on the client side will take a while compared to sending something on the existing connection). I suppose we can use the same mechanism if we need to be able to interrupt the server in other states.&lt;/p&gt;

&lt;p&gt;For those interested, see DRDA vol 1 -  4.4.14 Interrupting a Running DRDA Request.&lt;br/&gt;
As I said, I haven&apos;t yet studied the spec, nor Derby&apos;s DRDA implementation, so I can&apos;t say for sure this will work.&lt;/p&gt;</comment>
                            <comment id="12835836" author="rhillegas" created="Fri, 19 Feb 2010 17:21:48 +0000"  >&lt;p&gt;Hi Kristian,&lt;/p&gt;

&lt;p&gt;I may not be understanding the solution you are proposing. However, I wonder if it might not be air-tight. It seems to me that there might be a race condition. Wrong results might still be committed if the statement manages to complete before the client can open a second connection and interrupt the server.&lt;/p&gt;</comment>
                            <comment id="12837265" author="kristwaa" created="Tue, 23 Feb 2010 14:57:52 +0000"  >&lt;p&gt;Hi Rick,&lt;/p&gt;

&lt;p&gt;I agree that in the general case there might be race conditions, but that shouldn&apos;t be a problem in this specific case. To cancel truly running requests I understand that a second connection is needed, since the existing one is stuck waiting for the server reply.&lt;br/&gt;
I think we can control when the statement completes, since we are controlling when we send data to the server. Be holding back data, the server thread will be stuck.&lt;/p&gt;

&lt;p&gt;However, when prototyping this, it seems to me that the complexity of this approach is a lot higher than adding a product specific code point.&lt;br/&gt;
We would need to handle the following issues:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;creating a new connection based on an existing connection. Here we would need to have things like the user name and password available.&lt;/li&gt;
	&lt;li&gt;introducing an interrupt token (sent to the client on ACCRDB, sent back to the server to identify which session to interrupt)&lt;/li&gt;
	&lt;li&gt;looking up session based on interrupt token on the server side&lt;/li&gt;
	&lt;li&gt;interrupt logic on the server side&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We might get away with one thread on the client side, but on the server side we need two threads / connections to communicate with each other. The overall process would be something like this (there are several variations):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client sends data&lt;/li&gt;
	&lt;li&gt;client detects problem (too much data or too little data)&lt;/li&gt;
	&lt;li&gt;client creates a second connection (the server session is currently stuck in a read loop awaiting more data, or maybe the last piece of data)&lt;/li&gt;
	&lt;li&gt;the second thread on the server (new connection) signals that a DRDA interrupt has been requested&lt;/li&gt;
	&lt;li&gt;the client sends valid data (wrt the DRDA protocol) to the server session to wake it up&lt;/li&gt;
	&lt;li&gt;the server reads data, detects interrupt request and aborts the current statement&lt;/li&gt;
	&lt;li&gt;the second thread on the server sends a reply to the interrupt request itself&lt;/li&gt;
	&lt;li&gt;the client reads the reply (second connection)&lt;/li&gt;
	&lt;li&gt;the first server thread informs that the running request was interrupted and canceled&lt;/li&gt;
	&lt;li&gt;the client reads reply from the original connection and throws exception&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In addition to the code complexity, we must also make sure we obey the DRDA protocol rules to avoid network protocol errors.&lt;/p&gt;


&lt;p&gt;As a side note, the code in org.apache.derby.impl.drda.DRDAConnThread.convertAsByteArrayInputStream can cause OOME on the server for if more than one large LOB is transferred from the client in the same statement. &lt;/p&gt;</comment>
                            <comment id="12837776" author="kristwaa" created="Wed, 24 Feb 2010 13:15:41 +0000"  >&lt;p&gt;Attached a first revision of a regression test as patch 2a.&lt;/p&gt;</comment>
                            <comment id="12841251" author="kristwaa" created="Thu, 4 Mar 2010 13:40:33 +0000"  >&lt;p&gt;I think I may have a feasible solution for this bug. I have investigated a few different approaches, and I will soon post some patches and approach descriptions.&lt;/p&gt;</comment>
                            <comment id="12845885" author="kristwaa" created="Tue, 16 Mar 2010 12:37:59 +0000"  >&lt;p&gt;Attaching a preview patch, where a Derby specific trailing status flag is sent as the last byte. The status flag is appended to the user data.&lt;br/&gt;
I think this solution is the simplest approach, and it should also be easy to deal with the compatibility issue. The status flag is stripped away, it isn&apos;t saved to disk.&lt;/p&gt;

&lt;p&gt;The idea is to make the statement fail on the server side, and let the embedded driver deal with the clean-up. The error will then be reported to the client driver as any other error that may occur during statement execution.&lt;br/&gt;
In the case of multiple stream sources and an error in the first one, I figured it is easier to continue with the statement execution rather than to abort early on. This is because one would otherwise need recovery logic in both the client driver and the network server. As a possible optimization I thought of adding a status called STREAM_SKIPPED. This, possibly together with a single &quot;fake&quot; data byte, will be sent to the server for any remaining data sources. Doing this avoids having to read and send potentially large values when we know that the statement will fail.&lt;/p&gt;

&lt;p&gt;The various statuses are modeled after the current code in the client code. We don&apos;t need all of them (we really only need SUCCESS and FAILURE), but maybe they can be helpful for debugging? Having many status values doesn&apos;t add overhead to the network protocol (we always send one byte).&lt;br/&gt;
Here&apos;s the current list:&lt;br/&gt;
  STREAM_OK&lt;br/&gt;
  STREAM_UNKNOWN_LENGTH  (used with layer-B streaming and in an assert)&lt;br/&gt;
  STREAM_READ_ERROR&lt;br/&gt;
  STREAM_READ_ERROR_ON_LEN_VAL&lt;br/&gt;
  STREAM_TOO_SHORT&lt;br/&gt;
  STREAM_TOO_LONG&lt;br/&gt;
  STREAM_SKIPPED&lt;/p&gt;

&lt;p&gt;I&apos;m considering removing at least STREAM_UNKNOWN_LENGTH and STREAM_READ_ERROR_ON_LEN_VAL (effectively merging them with STREAM_OK and  STREAM_READ_ERROR, respectively).&lt;/p&gt;

&lt;p&gt;Remaining work on the patch:&lt;br/&gt;
  o layer-B streaming code&lt;br/&gt;
  o encryption code &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;br/&gt;
  o error handling on the client (I don&apos;t think we need to use the accumulated error mechanism when sending the status byte)&lt;/p&gt;

&lt;p&gt;I&apos;ll continue work on finalizing the patch, but feel free to ask questions and comment on the proposed approach.&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; We are currently materializing the value here, and I won&apos;t improve this as part of this issue.&lt;/p&gt;</comment>
                            <comment id="12845991" author="knutanders" created="Tue, 16 Mar 2010 16:52:49 +0000"  >&lt;p&gt;Hi Kristian,&lt;/p&gt;

&lt;p&gt;This sounds like a good approach to me. Also, +1 to keeping the code simple and not optimizing for possible failure scenarios. Exhausting all streams, even if the first one fails, sounds perfectly acceptable.&lt;/p&gt;

&lt;p&gt;One question: If the user stream fails with an exception on the client side, will the original exception be the one that&apos;s reported to the user, or will it be the synthetic exception produced on the server?&lt;/p&gt;</comment>
                            <comment id="12846476" author="kristwaa" created="Wed, 17 Mar 2010 17:12:25 +0000"  >&lt;p&gt;Thanks for having a look, Knut Anders.&lt;/p&gt;

&lt;p&gt;Knut Anders wrote:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;One question: If the user stream fails with an exception on the client side, will the original exception be the one that&apos;s reported to the user, or will it be the synthetic exception produced on the server? &lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;With the current code (preview with some changes), where nothing has been done to the exception handling, the following exceptions are produced for the embedded and the client driver:&lt;/p&gt;

&lt;p&gt;---------&amp;gt; Client&lt;/p&gt;

&lt;p&gt;----- SQLException -----&lt;br/&gt;
  SQLState:   XN015&lt;br/&gt;
  Error Code: 20000&lt;br/&gt;
  Message:    Network protocol error: the specified size of the InputStream, parameter #1, is less than the actual InputStream length.&lt;br/&gt;
java.sql.SQLException: Network protocol error: the specified size of the InputStream, parameter #1, is less than the actual InputStream length.&lt;br/&gt;
	at org.apache.derby.client.am.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:96)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:358)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdate(PreparedStatement.java:399)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.test(StreamErrRepro.java:38)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.main(StreamErrRepro.java:21)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Network protocol error: the specified size of the InputStream, parameter #1, is less than the actual InputStream length.&lt;br/&gt;
	at org.apache.derby.client.net.Request.writePlainScalarStream(Request.java:540)&lt;br/&gt;
	at org.apache.derby.client.net.Request.writeScalarStream(Request.java:264)&lt;br/&gt;
	at org.apache.derby.client.net.Request.writeScalarStream(Request.java:679)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementRequest.buildEXTDTA(NetStatementRequest.java:1011)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementRequest.writeExecute(NetStatementRequest.java:147)&lt;br/&gt;
	at org.apache.derby.client.net.NetPreparedStatement.writeExecute_(NetPreparedStatement.java:178)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.writeExecute(PreparedStatement.java:1855)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.flowExecute(PreparedStatement.java:2085)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdateX(PreparedStatement.java:404)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdate(PreparedStatement.java:390)&lt;br/&gt;
	... 2 more&lt;/p&gt;

&lt;p&gt;----- SQLException -----&lt;br/&gt;
  SQLState:   XCL30&lt;br/&gt;
  Error Code: -1&lt;br/&gt;
  Message:    An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;br/&gt;
java.sql.SQLException: An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;br/&gt;
	at org.apache.derby.client.am.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:96)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:358)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:367)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdate(PreparedStatement.java:399)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.test(StreamErrRepro.java:38)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.main(StreamErrRepro.java:21)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeExecute(Statement.java:1601)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseEXCSQLSTTreply(NetStatementReply.java:322)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.readExecute(NetStatementReply.java:71)&lt;br/&gt;
	at org.apache.derby.client.net.StatementReply.readExecute(StatementReply.java:55)&lt;br/&gt;
	at org.apache.derby.client.net.NetPreparedStatement.readExecute_(NetPreparedStatement.java:189)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.readExecute(PreparedStatement.java:1865)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.flowExecute(PreparedStatement.java:2162)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdateX(PreparedStatement.java:404)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdate(PreparedStatement.java:390)&lt;br/&gt;
	... 2 more&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
	... 11 more&lt;/p&gt;

&lt;p&gt;----- SQLException -----&lt;br/&gt;
  SQLState:   XJ001&lt;br/&gt;
  Error Code: 99999&lt;br/&gt;
  Message:    Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
java.sql.SQLNonTransientConnectionException: Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
	at org.apache.derby.client.am.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:358)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:367)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:367)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdate(PreparedStatement.java:399)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.test(StreamErrRepro.java:38)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.main(StreamErrRepro.java:21)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeExecute(Statement.java:1601)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseEXCSQLSTTreply(NetStatementReply.java:322)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.readExecute(NetStatementReply.java:71)&lt;br/&gt;
	at org.apache.derby.client.net.StatementReply.readExecute(StatementReply.java:55)&lt;br/&gt;
	at org.apache.derby.client.net.NetPreparedStatement.readExecute_(NetPreparedStatement.java:189)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.readExecute(PreparedStatement.java:1865)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.flowExecute(PreparedStatement.java:2162)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdateX(PreparedStatement.java:404)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeUpdate(PreparedStatement.java:390)&lt;br/&gt;
	... 2 more&lt;/p&gt;



&lt;p&gt;---------&amp;gt; Embedded&lt;/p&gt;

&lt;p&gt;java.sql.SQLException: An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;/p&gt;

&lt;p&gt;----- SQLException -----&lt;br/&gt;
  SQLState:   XCL30&lt;br/&gt;
  Error Code: 20000&lt;br/&gt;
  Message:    An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;br/&gt;
java.sql.SQLException: An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.seeNextException(Util.java:278)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:398)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2269)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1321)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1673)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(EmbedPreparedStatement.java:303)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.test(StreamErrRepro.java:38)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.main(StreamErrRepro.java:22)&lt;br/&gt;
Caused by: java.sql.SQLException: An IOException was thrown when reading a &apos;java.lang.String&apos; from an InputStream.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	... 11 more&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
	... 9 more&lt;br/&gt;
Caused by: org.apache.derby.iapi.services.io.DerbyIOException: Input stream did not have exact amount of data as the requested length.&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.checkSufficientData(ReaderToUTF8Stream.java:420)&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.fillBuffer(ReaderToUTF8Stream.java:378)&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.read(ReaderToUTF8Stream.java:197)&lt;br/&gt;
	at java.io.DataInputStream.readUnsignedShort(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.readExternal(SQLChar.java:1050)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.getString(SQLChar.java:695)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLVarchar.normalize(SQLVarchar.java:148)&lt;br/&gt;
	at org.apache.derby.iapi.types.DataTypeDescriptor.normalize(DataTypeDescriptor.java:648)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeColumn(NormalizeResultSet.java:329)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeRow(NormalizeResultSet.java:373)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.getNextRowCore(NormalizeResultSet.java:188)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:127)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:494)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:436)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:317)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	... 4 more&lt;/p&gt;

&lt;p&gt;----- SQLException -----&lt;br/&gt;
  SQLState:   XJ001&lt;br/&gt;
  Error Code: 0&lt;br/&gt;
  Message:    Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
java.sql.SQLException: Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:95)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:142)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.javaException(Util.java:299)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:398)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2269)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1321)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1673)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(EmbedPreparedStatement.java:303)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.test(StreamErrRepro.java:38)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.jdbcapi.StreamErrRepro.main(StreamErrRepro.java:22)&lt;br/&gt;
Caused by: java.sql.SQLException: Java exception: &apos;Input stream did not have exact amount of data as the requested length.: org.apache.derby.iapi.services.io.DerbyIOException&apos;.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:119)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:70)&lt;br/&gt;
	... 12 more&lt;br/&gt;
Caused by: org.apache.derby.iapi.services.io.DerbyIOException: Input stream did not have exact amount of data as the requested length.&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.checkSufficientData(ReaderToUTF8Stream.java:420)&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.fillBuffer(ReaderToUTF8Stream.java:378)&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.read(ReaderToUTF8Stream.java:197)&lt;br/&gt;
	at java.io.DataInputStream.readUnsignedShort(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.readExternal(SQLChar.java:1050)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.getString(SQLChar.java:695)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLVarchar.normalize(SQLVarchar.java:148)&lt;br/&gt;
	at org.apache.derby.iapi.types.DataTypeDescriptor.normalize(DataTypeDescriptor.java:648)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeColumn(NormalizeResultSet.java:329)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeRow(NormalizeResultSet.java:373)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.getNextRowCore(NormalizeResultSet.java:188)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:127)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:494)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:436)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:317)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	... 4 more&lt;/p&gt;


&lt;p&gt;When using the client driver, the following stack trace is written to derby.log:&lt;br/&gt;
============= begin nested exception, level (1) ===========&lt;br/&gt;
org.apache.derby.iapi.services.io.DerbyIOException: Input stream did not have exact amount of data as the requested length.&lt;br/&gt;
	at org.apache.derby.impl.drda.EXTDTAReaderInputStream.checkStatus(EXTDTAReaderInputStream.java:173)&lt;br/&gt;
	at org.apache.derby.impl.drda.StandardEXTDTAReaderInputStream.read(StandardEXTDTAReaderInputStream.java:146)&lt;br/&gt;
	at sun.nio.cs.StreamDecoder.readBytes(Unknown Source)&lt;br/&gt;
	at sun.nio.cs.StreamDecoder.implRead(Unknown Source)&lt;br/&gt;
	at sun.nio.cs.StreamDecoder.read(Unknown Source)&lt;br/&gt;
	at sun.nio.cs.StreamDecoder.read0(Unknown Source)&lt;br/&gt;
	at sun.nio.cs.StreamDecoder.read(Unknown Source)&lt;br/&gt;
	at java.io.InputStreamReader.read(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.services.io.LimitReader.read(LimitReader.java:57)&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.fillBuffer(ReaderToUTF8Stream.java:352)&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.read(ReaderToUTF8Stream.java:197)&lt;br/&gt;
	at java.io.DataInputStream.readUnsignedShort(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.readExternal(SQLChar.java:1050)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.getString(SQLChar.java:695)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLVarchar.normalize(SQLVarchar.java:148)&lt;br/&gt;
	at org.apache.derby.iapi.types.DataTypeDescriptor.normalize(DataTypeDescriptor.java:648)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeColumn(NormalizeResultSet.java:329)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeRow(NormalizeResultSet.java:373)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.getNextRowCore(NormalizeResultSet.java:188)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:127)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:494)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:436)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:317)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1232)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1673)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(EmbedPreparedStatement.java:1328)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAStatement.execute(DRDAStatement.java:672)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.parseEXCSQLSTTobjects(DRDAConnThread.java:4262)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.parseEXCSQLSTT(DRDAConnThread.java:4085)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.processCommands(DRDAConnThread.java:1004)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.run(DRDAConnThread.java:291)&lt;br/&gt;
============= end nested exception, level (1) ===========&lt;/p&gt;


&lt;p&gt;If we disable the use of the accumulated exception mechanism on the client (when sending the status byte, i.e. server and client at 10.6+), we get the same SQL states (XCL30 and XJ001) in both drivers. Looking at the traces, I do see DerbyIOException. This was introduced to make Derby able to rewrite IOException to SQLException with the correct state, but this is obviously not done for this code path. For instance, we may want to differentiate between a generic read error from a user stream and an error thrown by Derby due to a mismatch between the specified and the actual stream length.&lt;/p&gt;

&lt;p&gt;I would prefer to throw a different exception than the generic XJ001, but I think this can be handled under a different Jira. For instance, XJ023 may be better suited.&lt;/p&gt;</comment>
                            <comment id="12846609" author="knutanders" created="Wed, 17 Mar 2010 21:53:12 +0000"  >&lt;p&gt;I agree that it would be good to get the same error on both drivers for the situations above.&lt;/p&gt;

&lt;p&gt;The situation I had in mind was slightly different. I was thinking of the case where the user stream throws an exception when it&apos;s read. In the current code, I believe that both the client driver and the embedded driver will expose the original exception thrown by the user stream. If we disable the accumulation of exceptions, will we then instead see the below exception on the client?&lt;/p&gt;

&lt;p&gt;+            case DRDAConstants.STREAM_READ_ERROR:&lt;br/&gt;
+            case DRDAConstants.STREAM_READ_ERROR_ON_LEN_VAL:&lt;br/&gt;
+                throw new IOException(&quot;Read error on client side when &quot; +&lt;br/&gt;
+                        &quot;reading user stream&quot;);&lt;/p&gt;

&lt;p&gt;My preference would be that we continued to report the original exception in such a situation.&lt;/p&gt;</comment>
                            <comment id="12848650" author="kristwaa" created="Tue, 23 Mar 2010 10:44:59 +0000"  >&lt;p&gt;Attached an updated version of the regression test patch, which adds another test class (for layer B).&lt;/p&gt;

&lt;p&gt;I plan to commit this shortly, and I will do a few changes once the matter of exception handling in the drivers has been settled.&lt;br/&gt;
Run on trunk 5+3 failures should be seen. There are a few cases where the client driver currently does ok (because a combination of no auto-commit and rollback is used), and most of the tests are also run with the embedded driver as verification.&lt;/p&gt;</comment>
                            <comment id="12849271" author="kristwaa" created="Wed, 24 Mar 2010 16:37:04 +0000"  >&lt;p&gt;Committed patch 2b to trunk with revision 927114.&lt;/p&gt;</comment>
                            <comment id="12849274" author="kristwaa" created="Wed, 24 Mar 2010 16:53:38 +0000"  >&lt;p&gt;Attached a fix as patch 3a.&lt;/p&gt;

&lt;p&gt;Ready for review.&lt;br/&gt;
I&apos;ll describe/explain a few things tomorrow (no time now, just wanted to get the patch out there).&lt;/p&gt;</comment>
                            <comment id="12849693" author="kristwaa" created="Thu, 25 Mar 2010 12:56:06 +0000"  >&lt;p&gt;Description of patch 3a:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;iapi/reference/DRDAConstants&lt;br/&gt;
Constants for the various error conditions. There are currently four different conditions: OK, READ_ERROR, TOO_SHORT and TOO_LONG.&lt;br/&gt;
Two would be enough, but having more may help debugging / tracing (from the server side) and it doesn&apos;t add much complexity / overhead.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/StandardEXTDTAReaderInputStream&lt;br/&gt;
Extended the stream reading &quot;normal&quot; EXTDTA to handle the Derby-specific status byte.&lt;br/&gt;
See comment under drda/EXTDTAReaderInputStream.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/LayerBStreamedEXTDTAReaderInputStream&lt;br/&gt;
Extended the stream reading layer B streamed EXTDTA to handle the Derby-specific status byte.&lt;br/&gt;
Slightly more complex than the normal case, as we don&apos;t know up front when we read the last data byte.&lt;br/&gt;
First I tried to make the stream check the status when it read the last byte, but the code got too complex due to buffer boundary issues (i.e. I had to deal with a &quot;carry-over&quot; byte etc). The stream now requires that it is properly drained to guarantee that the status byte is read (i.e. read in a loop until you get -1). This is the normal operational mode, so it shouldn&apos;t cause problems.&lt;br/&gt;
To my knowledge this stream is always passed directly into the embedded driver, which means it should thrown an exception instead of saving the status byte.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/EXTDTAReaderInputStream&lt;br/&gt;
Extended the class to deal with the Derby-specific status byte.&lt;br/&gt;
Contains the logic determining if something went wrong when reading the stream on the client side. If so, either an exception is thrown or the status if saved for later inspection.&lt;br/&gt;
Seems I removed some required functionality here, as I think we have to be able to explicitly tell if an error condition should cause an exception to be thrown or not. The reason is that sometimes Derby reads the value off the network before executing the statement. I want the statement itself to fail, as this simplifies the clean-up and error handling.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/FailingEXTDTAInputStream&lt;br/&gt;
Dummy stream that will throw an exception as soon as a read request is made.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/AppRequester&lt;br/&gt;
Added method that tells if the client supports EXTDTA aborts or not.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/DRDAConnThread&lt;br/&gt;
Fixed some suboptimal logic in convertAsByteArrayInputStream, where the buffer size could be set to poorly chosen values (very small or too large).&lt;br/&gt;
In the case of normal EXTDTAs, added logic to pass in a stream that will fail instead of the stream containing padded or truncated data.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;drda/DDMReader&lt;br/&gt;
Modified the code creating the streams reading data off the wire to tell whether a Derby-specific status byte is expected or not.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;tests/jdbc4/PreparedStatementTest&lt;br/&gt;
Removed special code that was added due to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2017&quot; title=&quot;Client driver can insert and commit partial data when a LOB stream throws IOException or does not match the specified length&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2017&quot;&gt;&lt;del&gt;DERBY-2017&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;client/net/NetDatabaseMetaData&lt;br/&gt;
Added code to tell if the server supports EXTDTA aborts.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;client/net/NetConnection&lt;br/&gt;
Added method calling code added in NetDatabaseMetaData.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;client/net/Request&lt;br/&gt;
The changes required to send the status byte (both for layer A and layer B streaming).&lt;br/&gt;
Note that I suspect that the method writeEncryptedScalarStream is dead code. There are several major problems with it, suggesting that it isn&apos;t used. I may remove this code in a later patch, added a comment for now.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;I&apos;ll add some more JavaDoc for some of the existing methods in Request, add some tests for binary data (as opposed to character data) and verify that all code paths in DRDAConnThread.readAndSetExtParam are covered.&lt;/p&gt;</comment>
                            <comment id="12850069" author="knutanders" created="Fri, 26 Mar 2010 10:32:39 +0000"  >&lt;p&gt;Hi Kristian,&lt;/p&gt;

&lt;p&gt;I downloaded the 3a patch and tested it, and it only seems to address the layer B case (as can be seen by running Derby2017LayerATest or the original repro which still fail). Was layer A supposed to work with this patch?&lt;/p&gt;</comment>
                            <comment id="12850077" author="knutanders" created="Fri, 26 Mar 2010 10:52:21 +0000"  >&lt;p&gt;The subclasses of EXTDTAReaderInputStream implement both read() and read(byte[],int,int). Those methods have become rather complex now, since they handle both switching of buffers and the new status byte. To reduce the complexity of these classes, do you think it would make sense to define read() in terms of read(byte[],int,int) so that buffer switching and reading the status byte only need to be implemented once per class?&lt;/p&gt;</comment>
                            <comment id="12850264" author="kristwaa" created="Fri, 26 Mar 2010 18:05:05 +0000"  >&lt;p&gt;Hi Knut Anders,&lt;/p&gt;

&lt;p&gt;Here&apos;s another version. 3a had a bug in the checkState-method (I removed some functionality I thought was unnecessary), which is why Derby2017LayerATest failed.&lt;br/&gt;
I have also made some additional changes in DRDAConnThread (refactoring). See DRDAConnThread.convertAsByteArrayInputStream for the use of the exception suppress mechanism in the streaming classes.&lt;br/&gt;
Added some more JavaDoc to the methods in Request.&lt;/p&gt;

&lt;p&gt;I also made the change you suggested - to implement read() using read(byte[], int, int). It does reduce the complexity, and I know that the normal access pattern for these stream classes is to read data into a buffer (we&apos;re currently using a 8 KB buffer). I considered keeping the one-byte array as an instance variable, but chose not to.&lt;/p&gt;

&lt;p&gt;I just started the regression tests, and will report back later with the results.&lt;br/&gt;
More tests are coming (using setBinaryStream).&lt;/p&gt;

&lt;p&gt;Patch 3b ready for further review.&lt;/p&gt;</comment>
                            <comment id="12850868" author="knutanders" created="Mon, 29 Mar 2010 11:07:18 +0100"  >&lt;p&gt;Thanks, Kristian. The new patch looks fine to me. My only further comments are (I don&apos;t think you need to hold the commit, though):&lt;/p&gt;

&lt;p&gt;1) New error messages in EXTDTAReaderInputStream.getStatus()/checkStatus() and FailingEXTDTAInputStream.read() are not internationalized.&lt;/p&gt;

&lt;p&gt;2) Could the two JUnit tests for this issue also be enabled now?&lt;/p&gt;

&lt;p&gt;By the way, I noticed that the layer B test ran in just 6 seconds on my laptop, whereas the layer A test needed 2 minutes to complete. I haven&apos;t studied the details of the tests, but perhaps you could tell if this difference is expected?&lt;/p&gt;</comment>
                            <comment id="12859889" author="kristwaa" created="Thu, 22 Apr 2010 17:49:56 +0100"  >&lt;p&gt;Attached patch 3a.&lt;br/&gt;
Committed the fix to trunk with revision 936950.&lt;/p&gt;

&lt;p&gt;Thanks for looking at the patch, Knut.&lt;br/&gt;
I rewrote it slightly, adding a static method instead of duplicating the logic to throw the exception. I also one of the messages to MessageId. The others shouldn&apos;t be seen by users...&lt;/p&gt;

&lt;p&gt;I will post a follow-up patch for the tests. It will add some tests for binary data, and also enable the tests.&lt;br/&gt;
The time difference you see between the two tests is expected. The layer A test runs a buffer boundary test, which is not run in the layer B test (the two tests exercise the same code path when it comes to the buffer boundary issue).&lt;/p&gt;

&lt;p&gt;If there are additional comments, I&apos;ll incorporate the necessary changes in a new patch.&lt;/p&gt;</comment>
                            <comment id="12860151" author="knutanders" created="Fri, 23 Apr 2010 08:12:22 +0100"  >&lt;p&gt;There were two failures in the Tinderbox after this check-in. Do you think they are related?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dbtg.foundry.sun.com/derby/test/tinderbox_trunk16/jvm1.6/testing/testlog/SunOS-5.10_i86pc-i386/936985-org.apache.derbyTesting.functionTests.suites.All_diff.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dbtg.foundry.sun.com/derby/test/tinderbox_trunk16/jvm1.6/testing/testlog/SunOS-5.10_i86pc-i386/936985-org.apache.derbyTesting.functionTests.suites.All_diff.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;org.apache.derbyTesting.functionTests.suites.All fail *************************************************************&lt;br/&gt;
1) testBlobExceptionDoesNotRollbackOtherStatements(org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest)junit.framework.AssertionFailedError&lt;br/&gt;
2) testBlobExceptionDoesNotRollbackOtherStatements(org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest)junit.framework.AssertionFailedError&lt;/p&gt;
</comment>
                            <comment id="12860188" author="kristwaa" created="Fri, 23 Apr 2010 10:07:16 +0100"  >&lt;p&gt;Absolutely.&lt;/p&gt;

&lt;p&gt;Going from 3b to 3c the test fix got lost.&lt;br/&gt;
Attached as patch 4a, committed to trunk with revision 937198.&lt;/p&gt;</comment>
                            <comment id="12860232" author="kristwaa" created="Fri, 23 Apr 2010 13:16:26 +0100"  >&lt;p&gt;Attached patch 5a, which adds tests of binary data values (slightly different code path on the server) and enables the tests as part of their respective suites.&lt;/p&gt;

&lt;p&gt;Patch ready for review.&lt;br/&gt;
Will commit shortly.&lt;/p&gt;</comment>
                            <comment id="12860556" author="kristwaa" created="Sat, 24 Apr 2010 18:42:41 +0100"  >&lt;p&gt;Committed patch 5a to trunk with revision 937655.&lt;/p&gt;</comment>
                            <comment id="12860557" author="kristwaa" created="Sat, 24 Apr 2010 18:44:22 +0100"  >&lt;p&gt;Although the error reporting could have been cleaned up somehow (change error message text, make states consistent between the drivers), I don&apos;t expect to do more work on this issue for 10.6.&lt;/p&gt;

&lt;p&gt;Fix ready for verification.&lt;/p&gt;</comment>
                            <comment id="12995584" author="kmarsden" created="Wed, 16 Feb 2011 23:39:01 +0000"  >&lt;p&gt;I looked at this issue for possible backport to 10.5 and think it is not appropriate because there were pretty extensive changes and protocol changes.  From the commit message of r936950:&lt;/p&gt;

&lt;p&gt;&quot;Made the client tell the server (if supported) if the EXTDTA transfer was&lt;br/&gt;
successful or not, by appending a Derby-specific status byte to the user data.&quot;&lt;/p&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12430835">DERBY-4315</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12347633">DERBY-1658</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12354628">DERBY-2034</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12513038">DERBY-5317</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12346656" name="Derby_2017_v1.diff" size="2395" author="sv204098" created="Thu, 7 Dec 2006 13:46:45 +0000"/>
                            <attachment id="12346657" name="Derby_2017_v1.stat" size="233" author="sv204098" created="Thu, 7 Dec 2006 13:46:45 +0000"/>
                            <attachment id="12343871" name="StreamErrRepro.java" size="1573" author="knutanders" created="Mon, 30 Oct 2006 09:02:06 +0000"/>
                            <attachment id="12436844" name="derby-2017-2a-regression_test.diff" size="9332" author="kristwaa" created="Wed, 24 Feb 2010 13:15:40 +0000"/>
                            <attachment id="12439562" name="derby-2017-2b-regression-test.diff" size="37346" author="kristwaa" created="Tue, 23 Mar 2010 10:44:59 +0000"/>
                            <attachment id="12439673" name="derby-2017-3a-fix.diff" size="42097" author="kristwaa" created="Wed, 24 Mar 2010 16:53:38 +0000"/>
                            <attachment id="12439674" name="derby-2017-3a-fix.stat" size="877" author="kristwaa" created="Wed, 24 Mar 2010 16:53:38 +0000"/>
                            <attachment id="12439895" name="derby-2017-3b-fix.diff" size="57500" author="kristwaa" created="Fri, 26 Mar 2010 18:05:05 +0000"/>
                            <attachment id="12442590" name="derby-2017-3c-fix.diff" size="57920" author="kristwaa" created="Thu, 22 Apr 2010 17:49:56 +0100"/>
                            <attachment id="12442660" name="derby-2017-4a-remove_test_workaround.diff" size="1110" author="kristwaa" created="Fri, 23 Apr 2010 10:07:16 +0100"/>
                            <attachment id="12442670" name="derby-2017-5a-binary_tests.diff" size="22753" author="kristwaa" created="Fri, 23 Apr 2010 13:16:26 +0100"/>
                            <attachment id="12438916" name="derby-2017-stream_status_preview.diff" size="45703" author="kristwaa" created="Tue, 16 Mar 2010 12:37:59 +0000"/>
                            <attachment id="12358834" name="derby2017_try1.diff" size="2871" author="mayureshnirhali" created="Mon, 4 Jun 2007 09:23:57 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>13.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10364"><![CDATA[Data corruption]]></customfieldvalue>
    <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 7 Dec 2006 13:46:45 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22839</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0i3j:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36750</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>