<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:24:52 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3310/DERBY-3310.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3310] ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3310</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The following code &lt;/p&gt;

&lt;p&gt;CREATE TABLE U (SNAME VARCHAR(32000), TNAME VARCHAR(32000), C1 BIGINT);&lt;br/&gt;
&amp;#8211; This triggers an ASSERT (because 2 is INTEGER and not BIGINT)&lt;br/&gt;
INSERT INTO U(SNAME, TNAME, C1) SELECT DISTINCT SCHEMANAME, TABLENAME, 2&lt;br/&gt;
 FROM SYS.SYSTABLES T JOIN SYS.SYSSCHEMAS S ON T.SCHEMAID = S.SCHEMAID;&lt;/p&gt;

&lt;p&gt;gives&lt;/p&gt;

&lt;p&gt;ERROR XJ001: Java exception: &apos;ASSERT FAILED col1.getClass() (class org.apache.derby.iapi.types.SQLInteger) expected to be the same as col2.getClass() (class org.apache.derby.iapi.types.SQLLongint): org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12385890">DERBY-3310</key>
            <summary>ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kmarsden">Kathey Marsden</assignee>
                                    <reporter username="dyret">Dyre Tjeldvoll</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 Jan 2008 16:05:07 +0000</created>
                <updated>Fri, 21 Jan 2011 17:51:16 +0000</updated>
                            <resolved>Thu, 20 Mar 2008 04:52:53 +0000</resolved>
                                    <version>10.4.1.3</version>
                                    <fixVersion>10.4.1.3</fixVersion>
                    <fixVersion>10.5.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12557301" author="dyret" created="Wed, 9 Jan 2008 16:06:27 +0000"  >&lt;p&gt;Attaching a repro in the form of an ij-script&lt;/p&gt;</comment>
                            <comment id="12557571" author="dyret" created="Thu, 10 Jan 2008 09:05:49 +0000"  >&lt;p&gt;This issue was first seen while trying to reproduce &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3221&quot; title=&quot;&amp;quot;java.sql.SQLException: The conglomerate (-5) requested does not exist.&amp;quot; from Derby 10.3.1.4 embedded within Eclipse 3.3 and RAD 7.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3221&quot;&gt;&lt;del&gt;DERBY-3221&lt;/del&gt;&lt;/a&gt; in sane mode.&lt;/p&gt;</comment>
                            <comment id="12557632" author="dyret" created="Thu, 10 Jan 2008 12:52:32 +0000"  >&lt;p&gt;Marking this as a regression since it worked fine in rev 540921, and possibly later.&lt;/p&gt;</comment>
                            <comment id="12557946" author="dyret" created="Fri, 11 Jan 2008 09:34:00 +0000"  >&lt;p&gt;Seems like this was introduced by &lt;br/&gt;
------------------------------------------------------------------------&lt;br/&gt;
r554012 | djd | 2007-07-06 21:40:07 +0200 (Fri, 06 Jul 2007) | 4 lines&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2775&quot; title=&quot;DataTypeDescriptor should be immutable so that multiple ValueNode referring to the same DTD do not have unexpected state changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2775&quot;&gt;DERBY-2775&lt;/a&gt; (partial) Clarify some type handling for ResultColumn and its expression by making&lt;br/&gt;
callers explictly get the expression&apos;s type from the expression, rather than having&lt;br/&gt;
a method in ResultColumn that doesn&apos;t do what it indicates it did.&lt;br/&gt;
Make VirtualColumnNode&apos;s type just refect its source node.&lt;br/&gt;
------------------------------------------------------------------------&lt;/p&gt;
</comment>
                            <comment id="12566679" author="kmarsden" created="Thu, 7 Feb 2008 16:40:14 +0000"  >&lt;p&gt;I wonder if the assertion in MergeSort should just be removed or is there a better assertion that could be used to make sure the types are assignable?&lt;br/&gt;
From MergeSort ...&lt;br/&gt;
                if (col1.getClass() != col2.getClass())&lt;/p&gt;
                {
                    SanityManager.THROWASSERT(
                        &quot;col1.getClass() (&quot; + col1.getClass() +
                        &quot;) expected to be the same as col2.getClass() (&quot; +
                        col2.getClass() + &quot;)&quot;);
                }
</comment>
                            <comment id="12566686" author="djd" created="Thu, 7 Feb 2008 16:53:49 +0000"  >&lt;p&gt;Before changing the assert it would be good to understand why the types are different. I thought that if the types were different then a cast node is required to make the types the same when assigning one value to another.&lt;/p&gt;</comment>
                            <comment id="12566832" author="kmarsden" created="Thu, 7 Feb 2008 22:51:45 +0000"  >&lt;p&gt;I looked a little at the change that introduced the assertion, and narrowed it to this change in VirtualColumnNode.java, specifically the override of the setType method to set  the type of the source column.&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java?p2=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;p1=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;r1=554012&amp;amp;r2=554011&amp;amp;view=diff&amp;amp;pathrev=554012&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java?p2=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;p1=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;r1=554012&amp;amp;r2=554011&amp;amp;view=diff&amp;amp;pathrev=554012&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Before this change the types when passing through the assertion code were both SQLInteger, now one is SQLInteger and the other is SQLLongInt.&lt;/p&gt;

&lt;p&gt;I am not clear yet whether both should be SQLInteger or SQLLongInt at this point.&lt;/p&gt;</comment>
                            <comment id="12567206" author="kmarsden" created="Fri, 8 Feb 2008 21:11:42 +0000"  >&lt;p&gt;So things seem to work ok without the assert because SQLLongint.setValue()&lt;br/&gt;
calls getLong() on the value it is being set from so we get a compatible value.&lt;/p&gt;

&lt;p&gt;protected void setFrom(DataValueDescriptor theValue) throws StandardException &lt;/p&gt;
{

		setValue(theValue.getLong());
	}

&lt;p&gt;Here is the trace where it is called.&lt;/p&gt;

&lt;p&gt;Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 94 in SQLInteger))	&lt;br/&gt;
	SQLInteger.getLong() line: 94	&lt;br/&gt;
	SQLLongint.setFrom(DataValueDescriptor) line: 440	&lt;br/&gt;
	SQLLongint(DataType).setValue(DataValueDescriptor) line: 490	&lt;br/&gt;
	SQLLongint(DataType).normalize(DataTypeDescriptor, DataValueDescriptor) line: 662	&lt;br/&gt;
	DataTypeDescriptor.normalize(DataValueDescriptor, DataValueDescriptor) line: 469	&lt;br/&gt;
	NormalizeResultSet.normalizeRow(ExecRow) line: 330	&lt;br/&gt;
	NormalizeResultSet.getNextRowCore() line: 189	&lt;br/&gt;
	InsertResultSet(DMLWriteResultSet).getNextRowCore(NoPutResultSet) line: 127	&lt;br/&gt;
	InsertResultSet.open() line: 496	&lt;br/&gt;
	GenericPreparedStatement.execute(Activation, boolean, long) line: 370	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).executeStatement(Activation, boolean, boolean) line: 1203	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 596	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String) line: 528	&lt;br/&gt;
	ij.executeImmediate(String) line: 330	&lt;br/&gt;
	utilMain14(utilMain).doCatch(String) line: 522	&lt;br/&gt;
	utilMain14(utilMain).runScriptGuts() line: 364	&lt;br/&gt;
	utilMain14(utilMain).go(LocalizedInput[], LocalizedOutput, Properties) line: 262	&lt;br/&gt;
	Main14(Main).go(LocalizedInput, LocalizedOutput, Properties) line: 215	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 181	&lt;br/&gt;
	Main14.main(String[]) line: 56	&lt;br/&gt;
	ij.main(String[]) line: 71	&lt;/p&gt;

&lt;p&gt;Is a cast still needed?&lt;/p&gt;</comment>
                            <comment id="12567247" author="djd" created="Fri, 8 Feb 2008 23:56:13 +0000"  >&lt;p&gt;In this &lt;b&gt;specific&lt;/b&gt; case a cast is not needed, but I&apos;m thinking more about the general case, so if it had been a case where conversion was needed&lt;br/&gt;
would the behaviour be correct?&lt;/p&gt;

&lt;p&gt;So:&lt;br/&gt;
   is the assert wrong because the normalize node is doing the correct thing (e.g it knows INT -&amp;gt; IBIGNT is a safe conversion, no cast node needed),&lt;br/&gt;
   or is the assert correct and the normalize node is not putting in conversion code&lt;br/&gt;
   or is the normalize node and assert not related (my guess)&lt;/p&gt;

&lt;p&gt;We are trying to insert a value of type A  into a column of type B, but there is the additional distinct step.&lt;br/&gt;
so the query is doing something like:&lt;/p&gt;

&lt;p&gt;sort of (rows with value of type A)  ==&amp;gt; insert into table with column of type B&lt;/p&gt;

&lt;p&gt;The assert is saying that at some point some types must match during a merge sort, which seems reasonable, but this would&lt;br/&gt;
be in the step before the normalize (which is the insert step). So why are the types different there?&lt;/p&gt;</comment>
                            <comment id="12567761" author="kmarsden" created="Mon, 11 Feb 2008 19:12:29 +0000"  >&lt;p&gt;So for our specific case we have&lt;br/&gt;
sort of (rows with value of type INTEGER) ==&amp;gt; insert into table with column of type BIGINT&lt;/p&gt;

&lt;p&gt;So it makes sense to me that at the sort  phase, both the row and the &quot;template&quot; should be INTEGER as was the case prior to the change for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2775&quot; title=&quot;DataTypeDescriptor should be immutable so that multiple ValueNode referring to the same DTD do not have unexpected state changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2775&quot;&gt;DERBY-2775&lt;/a&gt;. Now the template column type is BIGINT and the row column type is INTEGER.  &lt;br/&gt;
Could you explain what the template is in this context and whether you think it should be INTEGER or BIGINT at this point in the processing?&lt;/p&gt;

</comment>
                            <comment id="12567799" author="djd" created="Mon, 11 Feb 2008 20:16:54 +0000"  >&lt;p&gt;What do you mean by template, which field in which class?&lt;/p&gt;

&lt;p&gt;A template row for the store is a row that contains the correct DataValueDescriptor objects for the desired type of the row,&lt;br/&gt;
so what it should be depends on context.&lt;/p&gt;

&lt;p&gt;E.g. &lt;b&gt;if&lt;/b&gt; this is true:&lt;/p&gt;

&lt;p&gt;sort of (rows with value of type INTEGER) ==&amp;gt; insert into table with column of type BIGINT &lt;/p&gt;

&lt;p&gt;then the template for the sort would have a SQLInteger,  a template for the table corresponding to the insert would have an SQLLongint.&lt;/p&gt;

&lt;p&gt;However, I don&apos;t know enough about the details of language to know if the sort and insert are treated as logically separate items or if they&lt;br/&gt;
are merged in some way.&lt;/p&gt;</comment>
                            <comment id="12568250" author="kmarsden" created="Tue, 12 Feb 2008 17:45:31 +0000"  >&lt;p&gt;I was referring to the template field in the MergeSort class.&lt;/p&gt;

&lt;p&gt;If  &quot;the template for the sort would have a SQLInteger,&quot; then I take it our pre &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2775&quot; title=&quot;DataTypeDescriptor should be immutable so that multiple ValueNode referring to the same DTD do not have unexpected state changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2775&quot;&gt;DERBY-2775&lt;/a&gt; behavior was &lt;br/&gt;
correct that the template was a SQLInteger and not a SQLLongInt.&lt;/p&gt;

&lt;p&gt;Is the change for VirtualColumnNode getting its type from its source node flawed in some way?&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java?p2=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;p1=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;r1=554012&amp;amp;r2=554011&amp;amp;view=diff&amp;amp;pathrev=554012&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java?p2=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;p1=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;r1=554012&amp;amp;r2=554011&amp;amp;view=diff&amp;amp;pathrev=554012&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12568659" author="mikem" created="Wed, 13 Feb 2008 18:35:20 +0000"  >&lt;p&gt;I think the assert code is correctly testing for what it assumes to be true - ie. that class types of the sort template will exactly match subsequent rows fed to the sort.  It may work without the assert in this case but I am not sure that will always be true.&lt;br/&gt;
Basically the sort interface requires a &quot;template&quot; of what rows will look like when fed into the sort.  So column&lt;span class=&quot;error&quot;&gt;&amp;#91;N&amp;#93;&lt;/span&gt; of each row fed into the sort should be the exact same type as template&lt;span class=&quot;error&quot;&gt;&amp;#91;N&amp;#93;&lt;/span&gt;.  &lt;/p&gt;

&lt;p&gt;One could build a sorter that compared different types in the same column but I didn&apos;t think Derby currently required that.&lt;/p&gt;</comment>
                            <comment id="12568679" author="kmarsden" created="Wed, 13 Feb 2008 19:08:28 +0000"  >&lt;p&gt;I think then we get back to my question of  whether both template and row data should be SQLInteger or both should be SQLLongint at the time of the sort.&lt;/p&gt;

&lt;p&gt;BTW this is the trace from the point where we now change the type of the sourceColumn from INTEGER NOT NULL to BIGINT.&lt;br/&gt;
I think I need to better understand the VirtualColumnNode change and why it was made.  &lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 284 in VirtualColumnNode))	&lt;br/&gt;
	VirtualColumnNode.setType(DataTypeDescriptor) line: 284	&lt;br/&gt;
	ResultColumnList.copyTypesAndLengthsToSource(ResultColumnList) line: 1645	&lt;br/&gt;
	InsertNode.bindStatement() line: 426	&lt;br/&gt;
	GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 314	&lt;br/&gt;
	GenericStatement.prepare(LanguageConnectionContext, boolean) line: 88	&lt;br/&gt;
	GenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 768	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 607	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String) line: 556	&lt;br/&gt;
	ij.executeImmediate(String) line: 330	&lt;br/&gt;
	utilMain.doCatch(String) line: 508	&lt;br/&gt;
	utilMain.runScriptGuts() line: 350	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput, Properties) line: 215	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 181	&lt;br/&gt;
	Main.main(String[]) line: 73	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;/p&gt;</comment>
                            <comment id="12570696" author="kmarsden" created="Wed, 20 Feb 2008 14:13:56 +0000"  >&lt;p&gt;I was hoping to pick up this issue, but must admit I am quite stuck.  I am really not sure at the time of the sort whether both template and row data should be SQLInteger or SQLLongInt.  If someone could explain which and why, I might better understand my destination and be able to make some progress on the issue.  Before the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2775&quot; title=&quot;DataTypeDescriptor should be immutable so that multiple ValueNode referring to the same DTD do not have unexpected state changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2775&quot;&gt;DERBY-2775&lt;/a&gt; both were SQLInteger but I don&apos;t know that that was correct.  It may have been wrong for both values.  Any help or hints would be greatly appreciated.&lt;/p&gt;

&lt;p&gt;Thanks&lt;br/&gt;
Kathey&lt;/p&gt;
</comment>
                            <comment id="12570713" author="bryanpendleton" created="Wed, 20 Feb 2008 15:15:08 +0000"  >&lt;p&gt;Hi Kathey,&lt;/p&gt;

&lt;p&gt;Beware, you&apos;re getting a WAG here. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But my opinion is that&lt;br/&gt;
SQLInteger is the correct datatype, and SQLLongInt is incorrect.&lt;/p&gt;

&lt;p&gt;I&apos;m guessing that the overall query tree looks something like:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InsertNode&lt;/li&gt;
	&lt;li&gt;NormalizeResultSetNode&lt;/li&gt;
	&lt;li&gt;SelectNode / ProjectRestrictNode&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It seems to me that the data being sorted is the SELECT data,&lt;br/&gt;
and that data uses the constant 2, and so that data should have&lt;br/&gt;
been sorted as simple integers.&lt;/p&gt;

&lt;p&gt;Then, the NormalizeResultSetNode should have generated&lt;br/&gt;
a CAST operation to convert the integer to a biginit when the&lt;br/&gt;
data is retrieved from the sorter.&lt;/p&gt;

&lt;p&gt;And, the VirtualColumnNodes used by the InsertNode should&lt;br/&gt;
have pointed to the values returned by the NormalizeResultSetNode,&lt;br/&gt;
so it seems correct that the VCN instance that the InsertNode&lt;br/&gt;
references should be working with a SQLLongInt.&lt;/p&gt;

&lt;p&gt;So I&apos;d suggest investigating the NormalizeResultSetNode, and&lt;br/&gt;
whether it is generating the proper buffering CAST operations.&lt;/p&gt;</comment>
                            <comment id="12570748" author="kmarsden" created="Wed, 20 Feb 2008 16:57:55 +0000"  >&lt;p&gt;VirtualColumnNode has this comment&lt;br/&gt;
	/* A VirtualColumnNode contains a pointer to the immediate child result&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;that is materializing the virtual column and the ResultColumn&lt;/li&gt;
	&lt;li&gt;that represents that materialization.&lt;br/&gt;
	 */&lt;br/&gt;
	private ResultSetNode	sourceResultSet;&lt;br/&gt;
	private ResultColumn	sourceColumn;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;The &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2775&quot; title=&quot;DataTypeDescriptor should be immutable so that multiple ValueNode referring to the same DTD do not have unexpected state changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2775&quot;&gt;DERBY-2775&lt;/a&gt; change overrode the setType from  ValueNode:&lt;br/&gt;
public void setType(DataTypeDescriptor dataTypeServices) throws StandardException&lt;/p&gt;
	{
		this.dataTypeServices = dataTypeServices;
	}

&lt;p&gt;with&lt;/p&gt;

&lt;p&gt;  public void setType(DataTypeDescriptor dtd) throws StandardException&lt;/p&gt;
    {
        sourceColumn.setType(dtd);
    }

&lt;p&gt;Doesn&apos;t this end up incorrectly end up affecting the child result, changing it from &lt;br/&gt;
SQLInteger to SQLLongInt?&lt;/p&gt;
</comment>
                            <comment id="12570761" author="bryanpendleton" created="Wed, 20 Feb 2008 17:17:12 +0000"  >&lt;p&gt;If the &quot;immediate child result&quot; of the InsertNode is a Normalize node,&lt;br/&gt;
then I think the VCN instances for the columns in the InsertNode&lt;br/&gt;
should have sourceResultSet pointing to a NormalizeResultSet,&lt;br/&gt;
and sourceColumn pointing to a column in the NRS&apos;s ResultColumnList.&lt;/p&gt;

&lt;p&gt;In that case, it seems correct for that sourceColumn to be of type longint,&lt;br/&gt;
because it represents the &lt;b&gt;result&lt;/b&gt; of the normalization.&lt;/p&gt;

&lt;p&gt;That is:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the PRN should sort values with integer type, and feed them up to the NRSN&lt;/li&gt;
	&lt;li&gt;the NRS should invoke normalizeRow() to convert the int to a long&lt;/li&gt;
	&lt;li&gt;the InsertNode should pull long values from the NRS and insert them&lt;br/&gt;
   into the target table.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;However, it looks like maybe this was the intent of the design, but&lt;br/&gt;
never completed? Here&apos;s a snip from a comment in NormalizeResultSet.java:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Normalize a row.  For now, this means calling constructors through&lt;/li&gt;
	&lt;li&gt;the type services to normalize a type to itself.  For example,&lt;/li&gt;
	&lt;li&gt;if you&apos;re putting a char(30) value into a char(15) column, it&lt;/li&gt;
	&lt;li&gt;calls a SQLChar constructor with the char(30) value, and the&lt;/li&gt;
	&lt;li&gt;constructor truncates the value and makes sure that no non-blank&lt;/li&gt;
	&lt;li&gt;characters are truncated.&lt;br/&gt;
        *&lt;/li&gt;
	&lt;li&gt;In the future, this mechanism will be extended to do type conversions&lt;/li&gt;
	&lt;li&gt;as well.  I didn&apos;t implement type conversions yet because it looks&lt;/li&gt;
	&lt;li&gt;like a lot of work, and we needed char and varchar right away.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As I said before, though, I&apos;m just guessing. It would be good to have some more&lt;br/&gt;
eyes and thoughts on how this is supposed to behave.&lt;/p&gt;</comment>
                            <comment id="12570848" author="kmarsden" created="Wed, 20 Feb 2008 22:02:07 +0000"  >&lt;p&gt;Thank you so much Bryan for your help with this issue.&lt;br/&gt;
I am a bit of a novice in this area so forgive if my questions&lt;br/&gt;
are basic.  You said:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the PRN should sort values with integer type, and feed them up to the NRSN&lt;/li&gt;
	&lt;li&gt;the NRS should invoke normalizeRow() to convert the int to a long&lt;/li&gt;
	&lt;li&gt;the InsertNode should pull long values from the NRS and insert them&lt;br/&gt;
   into the target table. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;and also said in an earlier comment.&lt;br/&gt;
&amp;gt;So I&apos;d suggest investigating the NormalizeResultSetNode, and&lt;br/&gt;
whether it is generating the proper buffering CAST operations. &lt;/p&gt;

&lt;p&gt;If the sort happens before normalization, how could CAST operations in &lt;br/&gt;
NormalizeResultSetNode  have an effect on the sort?&lt;/p&gt;</comment>
                            <comment id="12570893" author="bryanpendleton" created="Wed, 20 Feb 2008 23:57:14 +0000"  >&lt;p&gt;By itself, CAST operations in NormalizeResultSet would not fix&lt;br/&gt;
the sort problem you are seeing, I agree. &lt;/p&gt;

&lt;p&gt;My comments are with respect to your earlier question:&lt;br/&gt;
&amp;gt; I am really not sure at the time of the sort whether both template and row data &lt;br/&gt;
&amp;gt; should be SQLInteger or SQLLongInt. If someone could explain which and why&lt;/p&gt;

&lt;p&gt;I think I am trying to propose a two-part theory:&lt;br/&gt;
1) at the time of the sort, both template and row data should be SQLInteger.&lt;br/&gt;
2) Since the Insert requires a SQLLongInteger, I think the conversion from&lt;br/&gt;
Int to LongInt should occur in NormalizeResultSet, rather than in the sort.&lt;/p&gt;

&lt;p&gt;So working on NormalizeResultSet by itself would be only part of the solution,&lt;br/&gt;
it still would also be necessary to change things so that the sort doesn&apos;t see&lt;br/&gt;
the type mismatch.&lt;/p&gt;

&lt;p&gt;Does that make more sense?&lt;/p&gt;

&lt;p&gt;thanks,&lt;/p&gt;

&lt;p&gt;bryan&lt;/p&gt;</comment>
                            <comment id="12570901" author="kmarsden" created="Thu, 21 Feb 2008 00:14:18 +0000"  >&lt;p&gt;Thanks Bryan, that makes sense to me.  My primary focus &lt;br/&gt;
is to change the sort so it doesn&apos;t see the type mismatch.&lt;/p&gt;

&lt;p&gt;From what you say, the change to VirtualColumnNode &lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java?p2=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;p1=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;r1=554012&amp;amp;r2=554011&amp;amp;view=diff&amp;amp;pathrev=554012&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java?p2=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;p1=%2Fdb%2Fderby%2Fcode%2Ftrunk%2Fjava%2Fengine%2Forg%2Fapache%2Fderby%2Fimpl%2Fsql%2Fcompile%2FVirtualColumnNode.java&amp;amp;r1=554012&amp;amp;r2=554011&amp;amp;view=diff&amp;amp;pathrev=554012&lt;/a&gt;&lt;br/&gt;
should not have affected the sort phase, but clearly it did.&lt;/p&gt;

&lt;p&gt;I think it would help a lot to understand why this change was made.  Dan could you elaborate?&lt;/p&gt;</comment>
                            <comment id="12571003" author="knutanders" created="Thu, 21 Feb 2008 10:41:05 +0000"  >&lt;p&gt;Perhaps this modified repro better illustrates that the sort should&lt;br/&gt;
use SQLInteger and not SQLLongint in the original repro:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table d3310 (x bigint);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into d3310 select distinct * from (values 2.0, 2.1, 2.2) v;&lt;br/&gt;
ERROR XJ001: Java exception: &apos;ASSERT FAILED col1.getClass() (class org.apache.derby.iapi.types.SQLDecimal) expected to be the same as col2.getClass() (class org.apache.derby.iapi.types.SQLLongint): org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;/p&gt;

&lt;p&gt;If the cast to BIGINT happened in or before the sort, the above insert&lt;br/&gt;
statement might end up inserting a single row instead of three rows,&lt;br/&gt;
since the values would no longer be distinct.&lt;/p&gt;</comment>
                            <comment id="12571069" author="djd" created="Thu, 21 Feb 2008 15:19:12 +0000"  >&lt;p&gt;For the rationale to the change to VirtualColumnNode (554012) &lt;/p&gt;

&lt;p&gt;From the description of VirtualColumnNode it is a representation of a base column from a view or a table in another part of a query.&lt;br/&gt;
If this is the case then the type of the VirtualColumnNode must be the type of the underlying column. It&apos;s role is not as a type&lt;br/&gt;
changer. If it is meant to have that role as well, which would seem to overload its purpose, then that should be clearly documented in the class.&lt;br/&gt;
I think keeping the roles of the various nodes to be clear and simple is the best approach.&lt;/p&gt;


</comment>
                            <comment id="12571209" author="kmarsden" created="Thu, 21 Feb 2008 22:16:58 +0000"  >&lt;p&gt;Thanks again everyone for the help.  &lt;br/&gt;
In InsertNode.bindStatement we have:&lt;br/&gt;
			resultSet = resultSet.genNormalizeResultSetNode(resultSet, false);&lt;br/&gt;
			resultColumnList.copyTypesAndLengthsToSource(resultSet.getResultColumns());&lt;/p&gt;


&lt;p&gt;ResultSetNode.genNormalizeResultSetNode makes a shallow copy of the resultColumnList and&lt;br/&gt;
 replaces the expressions with VirtualColumnNodes which still point at the source column:&lt;br/&gt;
So ultimately we hit this line in ResultColumnList.copyTypesAndLengthsToSource &lt;/p&gt;

&lt;p&gt;	sourceRC.getExpression().setType(resultColumn.getTypeServices());&lt;/p&gt;

&lt;p&gt;which ends up changing the underlying source column type with the new setType method.&lt;/p&gt;

&lt;p&gt;As an experiment, I tried commenting that  line in copyTypesAndLengthsToSource &lt;br/&gt;
out, to find out why it is needed and I found that suites.All and derbyall  passed with the line &lt;br/&gt;
commented out as did the repro for this issue.  I wonder if/why it is needed.&lt;/p&gt;

&lt;p&gt;Below is the experimental patch:&lt;br/&gt;
Index: java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java (revision 629575)&lt;br/&gt;
+++ java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java (working copy)&lt;br/&gt;
@@ -1642,7 +1642,7 @@&lt;br/&gt;
                        ResultColumn sourceRC = (ResultColumn) sourceRCL.elementAt(index);&lt;br/&gt;
                        ResultColumn resultColumn = (ResultColumn) elementAt(index);&lt;br/&gt;
                        sourceRC.setType(resultColumn.getTypeServices());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;sourceRC.getExpression().setType(resultColumn.getTypeServices());&lt;br/&gt;
+                       //sourceRC.getExpression().setType(resultColumn.getTypeServices());&lt;br/&gt;
                }&lt;br/&gt;
        }&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12571543" author="kmarsden" created="Fri, 22 Feb 2008 19:22:16 +0000"  >&lt;p&gt;Attached is my initial attempt at fixing this issue.  I am not quite sure this is the right approach.  The fix removes the line call setType on the underlying expressions from  copyTypesAndLengthsToSource, to avoid changing the type of the source column of VirtualColumnNodes.&lt;/p&gt;

&lt;p&gt;I haven&apos;t been able to find any cases that this change affects adversely, but perhaps this is not the right approach.  Maybe the problem is that genNormalizeResultSetNode puts the VirtualColumnNodes in the normalized resultset in the first place.  Perhaps they should be CastNodes? &lt;br/&gt;
Then perhaps copyTypesAndLengthsToSource wouldn&apos;t be necessary.&lt;br/&gt;
Anyway I would appreciate comments on the patch and possible alternatives.&lt;/p&gt;


&lt;p&gt;Just for some historical background, I traced copyLengthsAndTypesToSource back to its origin.&lt;br/&gt;
It was put in to address a case that is no longer valid with Derby, but I&apos;ll put it here just in case it helps:&lt;/p&gt;

&lt;p&gt;&amp;#8211; the following gets an exception trying to convert &apos;11.4&apos; to &lt;br/&gt;
an integer&lt;br/&gt;
create table trash(c1 real check(c1 &amp;gt; 2));&lt;br/&gt;
insert into trash values &apos;11.4&apos;;&lt;/p&gt;


&lt;p&gt;Thanks &lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;

</comment>
                            <comment id="12571557" author="djd" created="Fri, 22 Feb 2008 19:42:39 +0000"  >&lt;p&gt;Nice find.&lt;/p&gt;

&lt;p&gt;To me the whole method seems very strange, why does the type of the source node need to be changed?&lt;br/&gt;
I wonder if the whole method should be removed, as you say a CAST node might be better.&lt;br/&gt;
Changing the type of the source node could be a potential for a huge source of bugs, if the implementation&lt;br/&gt;
of the node is expecting its type to match its contents.&lt;/p&gt;

&lt;p&gt;Of course the existing comment in the javadoc for the method is one of those useless comments:&lt;/p&gt;

&lt;p&gt;   &amp;gt;&amp;gt;&amp;gt; This is useful when adding a NormalizeResultSetNode.&lt;/p&gt;

&lt;p&gt;The missing part is &lt;b&gt;why&lt;/b&gt; is it useful. An example of why I try to request good comments during code reviews,&lt;br/&gt;
why is the most important part of any comment.&lt;/p&gt;</comment>
                            <comment id="12571618" author="kmarsden" created="Fri, 22 Feb 2008 22:19:50 +0000"  >&lt;p&gt;Thanks Dan for looking at the patch.  Do you think this is a &lt;br/&gt;
sufficient incremental improvement to resolve the regression? &lt;br/&gt;
then I can file a separate issue to investgate the wisdom and future&lt;br/&gt;
of copyLengthsAndTypesToSource.&lt;/p&gt;

&lt;p&gt;Simply  removing it lead to all sorts of unpleasantness, such as&lt;br/&gt;
ij&amp;gt; insert into d3310 select distinct * from (values 2.0, 2.1, 2.2) v;&lt;br/&gt;
3 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from d3310;&lt;br/&gt;
X&lt;br/&gt;
--------------------&lt;br/&gt;
ERROR XSDA7: Restore of a serializable or SQLData object of class , attempted to read more data than was originally stor&lt;br/&gt;
ed&lt;br/&gt;
ERROR XJ001: Java exception: &apos;: java.io.EOFException&apos;.&lt;br/&gt;
ij&amp;gt; exit;&lt;/p&gt;

&lt;p&gt;I am going to attach a diff file of the original change that inserted the method.&lt;br/&gt;
I am not sure I understand all the code that was there before but I think&lt;br/&gt;
it was perhaps superior to the fix.&lt;/p&gt;</comment>
                            <comment id="12571624" author="djd" created="Fri, 22 Feb 2008 22:41:46 +0000"  >&lt;p&gt;&amp;gt; Do you think this is a sufficient incremental improvement to resolve the regression? &lt;/p&gt;

&lt;p&gt;In my opinion not at the moment, I&apos;m uncomfortable with fixes that can&apos;t be explained. At the moment it&apos;s a case&lt;br/&gt;
of :&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if I do this then it appears to work but I don&apos;t know why.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It&apos;s good that you&apos;ve found the likely source of the problem, but it&apos;s just a starting point.&lt;br/&gt;
I&apos;ll spend some time trying to understand what that method is trying to do, it probably has to&lt;br/&gt;
do with some comments in ResultSetNode.genNormalizeResultSetNode:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Put a NormalizeResultSetNode on top of the specified ResultSetNode.&lt;/li&gt;
	&lt;li&gt;ColumnReferences must continue to point to the same ResultColumn, so&lt;/li&gt;
	&lt;li&gt;that ResultColumn must percolate up to the new PRN.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Not sure what that means exactly, but it seems related.&lt;/p&gt;
</comment>
                            <comment id="12571629" author="djd" created="Fri, 22 Feb 2008 22:57:28 +0000"  >&lt;p&gt;ResultSetNode.genNormalizeResultSetNode() is a little strange:&lt;/p&gt;

&lt;p&gt;Its purpose is to push a normalize result set node on-top of a ResultSetNode.&lt;/p&gt;

&lt;p&gt;The passed in child node is always the node is actually invoked on, so it&apos;s always operating on this.&lt;br/&gt;
(I&apos;ll attach a simple patch for that, it simplifies the code a little, otherwise it appears the method is operating on&lt;br/&gt;
two result set nodes instead of just itself.&lt;/p&gt;

&lt;p&gt;What&apos;s strange to me is that even though it is wrapping itself with a normalize node, the code ends up modifying&lt;br/&gt;
its own resultColumns. A normal, expected pattern for such a situation is that the node to be wrapped would&lt;br/&gt;
be unmodified by pushing a normalize node on top of it. This could be related to this issue, the source nodes and&lt;br/&gt;
target nodes might be being mixed up.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;sorry if this appears unclear, it&amp;#39;s just something I noticed and wanted to quickly throw out there&amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="12571637" author="djd" created="Fri, 22 Feb 2008 23:17:20 +0000"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;more rambling&amp;#93;&lt;/span&gt;&lt;br/&gt;
The pattern of modifying the node being wrapped when wrapping it seems a common theme in ResultSetNode:&lt;/p&gt;

&lt;p&gt;  genProjectRestrictForReordering &amp;amp; genProjectRestrict also do it.&lt;/p&gt;

&lt;p&gt;Have to say it&apos;s a very counter-intuitive coding style and likely to lead to bugs.&lt;/p&gt;</comment>
                            <comment id="12571647" author="djd" created="Fri, 22 Feb 2008 23:59:18 +0000"  >&lt;p&gt;Looking at NormalizeResultSet I now see that cast nodes are not needed. NormalizeResultSet performs type&lt;br/&gt;
conversions itself without any need for cast nodes.&lt;/p&gt;

&lt;p&gt;It needs a set of DataTypeDescriptors that represent the intended types. SO I&apos;m guessing the layout should be&lt;br/&gt;
something like to say convert our INT into a  BIGINT&lt;/p&gt;

&lt;p&gt;NormalizeNode&lt;br/&gt;
    ResultColumn(BIGINT) -&amp;gt; VirtualColumnNode (??) -&amp;gt; A (below)&lt;/p&gt;

&lt;p&gt;    source result set node&lt;br/&gt;
         A - ResultColumn (INT) -&amp;gt; constant (INT)&lt;/p&gt;


&lt;p&gt;That&apos;s a rough guess, but I think it&apos;s beginning to show why the fix works. I think without the change&lt;br/&gt;
the type of A would be set to BIGINT and with the change it would remain at INT.&lt;/p&gt;

&lt;p&gt;Not saying I fully understand it yet, but just throwing more info out there from looking at the code.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;edit to have conversion (INT TO BIGINT) correct&amp;#93;&lt;/span&gt;&lt;/p&gt;
</comment>
                            <comment id="12571652" author="djd" created="Sat, 23 Feb 2008 00:11:02 +0000"  >&lt;p&gt;Cleanup of ResultSetNode.genNormalizeResultSetNode() so that it always operates in itself (ie. it returns a NormalizeResultSetNode that wraps itself. This was the usage of the method in every case, thus make it the only possible behaviour to make the code clearer.&lt;/p&gt;</comment>
                            <comment id="12571929" author="djd" created="Sun, 24 Feb 2008 19:06:10 +0000"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;yet more rambling&amp;#93;&lt;/span&gt;&lt;br/&gt;
A ResultSetNode has a set of ResultColumns and each ResultColumn has an expression under it.&lt;/p&gt;

&lt;p&gt;A NormalizeResultSetNode is added above a ResultSetNode (wraps it) when the type of at least one of its&lt;br/&gt;
ResultColumn does not match the type of its expression,&lt;br/&gt;
ResultColumn indicates this can be the case &amp;amp; I added some more comments to that.&lt;/p&gt;

&lt;p&gt;Once the decision is made to add a NormalizeResultSetNode  there is some processing of ResultColumns and ResultColumnLists&lt;br/&gt;
that I haven&apos;t understood yet, this includes the call copyLengthsAndTypesToSource() that Kathey modified.&lt;/p&gt;

&lt;p&gt;Setting up a NormalizeResultSetNode  is spread over three locations, the class itself (very little, it&apos;s almost acting like a C struct),&lt;br/&gt;
the genNormalizeResultSetNode method and then copyLengthsAndTypesToSource. A good O-O implementation would have&lt;br/&gt;
the logic to create a NormalizeResultSetNode  self-contained in NormalizeResultSetNode.&lt;/p&gt;

&lt;p&gt;Since the ResultColumnList of the original ResultSetNode correctly describes the desired outcome, it&apos;s not clear to&lt;br/&gt;
me why NormalizeResultSetNode  can&apos;t just refer to the same list and use it for its processing. They may be some chance&lt;br/&gt;
that this would cause recursion at some point, where a NormalizeResultSetNode  would think it needed to be wrapped&lt;br/&gt;
in a NormalizeResultSetNode  since the types of its columns and expression don&apos;t match (i.e. when it is handled as a regular ResultSetNode).&lt;/p&gt;

&lt;p&gt;I think moving the setup of a NormalizeResultSetNode  into the class itself, so that its inputs are just the ResultSetNode to wrap&lt;br/&gt;
would help clear up the code, especially if comments were added indicating why certain actions were being taken.&lt;/p&gt;


</comment>
                            <comment id="12573487" author="kmarsden" created="Thu, 28 Feb 2008 22:13:08 +0000"  >&lt;p&gt;The attached patch derby-3310_remove_genNormalizeResultSetNode_diff.txt moves the contents of ResultSetNode.genNormalizeResultSetNode into NormalizeResultSetNode.init() method.  The method still copies the ResultColumnList as before.&lt;/p&gt;

&lt;p&gt;I had a harder time with getting rid of copyTypesAndLengthsToSource, so decided to wait for a second patch for removing that method. I&apos;ll post some questions about that after this patch gets committed.&lt;/p&gt;
</comment>
                            <comment id="12573800" author="kmarsden" created="Fri, 29 Feb 2008 15:56:49 +0000"  >&lt;p&gt;I should probably mention that I am not convinced that moving the &lt;br/&gt;
genNormalizeResultSetNode code into the NormalizeResultSetNode init method&lt;br/&gt;
makes things much clearer.  It seems to bury the modification of the ResultSetNode&lt;br/&gt;
deeper IMHO.  Anyway I would appreciate a second opinion on this and review of &lt;br/&gt;
the patch.&lt;/p&gt;

&lt;p&gt;Thanks &lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;
</comment>
                            <comment id="12573805" author="djd" created="Fri, 29 Feb 2008 16:04:04 +0000"  >&lt;p&gt;I haven&apos;t looked at the patch yet, but I agree modifying the ResultSetNode (R) to be wrapped inside NormalizeResultSetNode (NR) would be really unclear,&lt;br/&gt;
but I don&apos;t think the ResultSetNode R should be modified. It&apos;s a very unnatural coding style, subject to bugs, e.g. with the code as-is any other node that thinks&lt;br/&gt;
 it is pointing to R&apos;s ResultColumns silently gets changed to be pointing to NR&apos;s ResultColumns.&lt;/p&gt;</comment>
                            <comment id="12573813" author="kmarsden" created="Fri, 29 Feb 2008 16:18:15 +0000"  >&lt;p&gt;I think then I misinterpreted your suggestion:&lt;br/&gt;
&amp;gt;Setting up a NormalizeResultSetNode is spread over three locations, the class itself (very little, it&apos;s almost acting like a C struct),&lt;br/&gt;
&amp;gt;the genNormalizeResultSetNode method and then copyLengthsAndTypesToSource. A good O-O implementation would have&lt;br/&gt;
&amp;gt;the logic to create a NormalizeResultSetNode self-contained in NormalizeResultSetNode.&lt;/p&gt;

&lt;p&gt;I was endeavoring to move the existing logic into NormalizeResultSetNode.  Perhaps some &lt;br/&gt;
other first steps are more appropriate.  Any advice is appreciated.  I do feel however that&lt;br/&gt;
I am getting further away, not closer to resolving &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3310&quot; title=&quot;ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3310&quot;&gt;&lt;del&gt;DERBY-3310&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12574618" author="kmarsden" created="Mon, 3 Mar 2008 17:33:32 +0000"  >&lt;p&gt;Unmarking patch available. It seems that it does not make sense to move the logic into NormalizeResultSetNode until we can avoid changing the underlying ResultSetNode. Dan suggested I try to make a write up of the current behaviour and what is being modified.  I will try to do that.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;</comment>
                            <comment id="12575071" author="kmarsden" created="Tue, 4 Mar 2008 17:47:42 +0000"  >&lt;p&gt;genNormalizeResultSetNode() has this code:&lt;br/&gt;
		/* We get a shallow copy of the ResultColumnList and its &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ResultColumns.  (Copy maintains ResultColumn.expression for now.)&lt;br/&gt;
		 */&lt;br/&gt;
                ResultColumnList prRCList = resultColumns;&lt;br/&gt;
		resultColumns = resultColumns.copyListAndObjects();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;               ... &lt;br/&gt;
	      Change prRCList to remove generatedGroupingColumns and add &lt;br/&gt;
	      VirtualColumnNodes, get NormalizeResultSetNode &lt;/p&gt;


&lt;p&gt;I wanted to understand the difference between doing this and just leaving &lt;br/&gt;
resultColumns alone and working on the copy for prRCList  so I changed it to just&lt;br/&gt;
                ResultColumnList prRCList = resultColumns.copyListAndObjects();&lt;br/&gt;
       ... &lt;br/&gt;
	      Change prRCList to remove generatedGroupingColumns and add &lt;br/&gt;
	      VirtualColumnNodes, get NormalizeResultSetNode &lt;/p&gt;

&lt;p&gt;This led to a NullPointerException in the generated code for views.sql doing a select &lt;br/&gt;
from a view.&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
        at org.apache.derby.exe.acaa7ac093x0118x781cx2bb1xffffc28339b210.e3(Unkn&lt;br/&gt;
own Source)&lt;br/&gt;
        at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGener&lt;br/&gt;
atedClass.java:145)&lt;br/&gt;
        ... 17 more&lt;/p&gt;

&lt;p&gt;I am not sure I understand the difference in my new code and the old and why the &lt;br/&gt;
new doesn&apos;t work.  If anyone has an immediate ideas that would be most helpful. &lt;br/&gt;
 I&apos;ll try to debug the NPE to see if that sheds any light.  &lt;/p&gt;


</comment>
                            <comment id="12575453" author="kmarsden" created="Wed, 5 Mar 2008 18:43:53 +0000"  >&lt;p&gt;Unassigning myself from this issue for now while I focus on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3494&quot; title=&quot;Move the setup of NormalizeResultSetNode into the NormalizeResultSetNode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3494&quot;&gt;&lt;del&gt;DERBY-3494&lt;/del&gt;&lt;/a&gt; to reorganize the code. I am not sure that that is necessary to resolve this issue.  Perhaps someone has a more straight forward solution and can get this regression fixed for 10.4.&lt;/p&gt;

&lt;p&gt;Status of the issue as I leave it is:&lt;/p&gt;

&lt;p&gt;I submitted a patch derby-3310_try1_diff.txt that resolves the issue and passes regression tests. That patch removes the change of the underlying expression of the NormalizeResultSetNode, so that it does not affect the sort.  ResultSetNode  expects the type of the column to be different from the expression in this case, so the patch seems to resolve the issue.  Dan had some concerns with the patch however, since the Normalization code is not clear, we are not sure if it is ok to remove the change of the expresion type.&lt;/p&gt;

&lt;p&gt;Dan thought reorganizing the normalization code to avoid changing the underlying result set would make things clearer (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3494&quot; title=&quot;Move the setup of NormalizeResultSetNode into the NormalizeResultSetNode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3494&quot;&gt;&lt;del&gt;DERBY-3494&lt;/del&gt;&lt;/a&gt;), so I am looking at that now.&lt;/p&gt;</comment>
                            <comment id="12576453" author="army" created="Sat, 8 Mar 2008 00:15:08 +0000"  >&lt;p&gt;Dan&amp;gt; I don&apos;t think the ResultSetNode R should be modified. It&apos;s a very unnatural coding style,&lt;br/&gt;
Dan&amp;gt; subject to bugs, e.g. with the code as-is any other node that thinks it is pointing to R&apos;s&lt;br/&gt;
Dan&amp;gt; ResultColumns silently gets changed to be pointing to NR&apos;s ResultColumns.&lt;/p&gt;

&lt;p&gt;After doing a bit of investigation for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3494&quot; title=&quot;Move the setup of NormalizeResultSetNode into the NormalizeResultSetNode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3494&quot;&gt;&lt;del&gt;DERBY-3494&lt;/del&gt;&lt;/a&gt;, I think this &quot;silent update&quot; effect is precisely&lt;br/&gt;
&lt;b&gt;why&lt;/b&gt; ResultSetNode R is being modified.  That is, if there is some column reference pointing&lt;br/&gt;
to R&apos;s ResultColumns and then additional nodes are generated on top of R, it appears that&lt;br/&gt;
those column references &lt;b&gt;must&lt;/b&gt; point to the &quot;top&quot; of the newly-generated nodes instead of&lt;br/&gt;
to R.  At least, that appears to be what execution-time logic expects (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3494&quot; title=&quot;Move the setup of NormalizeResultSetNode into the NormalizeResultSetNode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3494&quot;&gt;&lt;del&gt;DERBY-3494&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;So the execution code &lt;em&gt;expects&lt;/em&gt; that any ColumnReference node which thinks it is pointing&lt;br/&gt;
to R&apos;s ResultColumns &lt;em&gt;is&lt;/em&gt; silently changed to point to the NR&apos;s result columns.  It may be&lt;br/&gt;
&quot;unnatural&quot; and &quot;subject to bugs&quot;, but this particular &quot;side effect&quot; looks to be intentional.  Not&lt;br/&gt;
good, necessarily, but intentional...&lt;/p&gt;

&lt;p&gt;I&apos;m not saying anything else about this particular issue (I still need to catch up on the discussion),&lt;br/&gt;
but I thought I&apos;d throw that out there.  Apologies if it&apos;s irrelevant.&lt;/p&gt;</comment>
                            <comment id="12577562" author="army" created="Tue, 11 Mar 2008 19:07:46 +0000"  >&lt;p&gt;I did some tracing through the various compilation stages for the short reproduction provided by&lt;br/&gt;
Knut Anders in his February 21st comment.  Attached is d3310_writeup_1.html, which is an attempt&lt;br/&gt;
to describe my findings.  Hopefully this is helpful...&lt;/p&gt;</comment>
                            <comment id="12577604" author="kmarsden" created="Tue, 11 Mar 2008 21:13:05 +0000"  >&lt;p&gt;Thank you Army for your detailed write up and articulating what&lt;br/&gt;
I could not for the proposed change for this issue.  Dan given &lt;br/&gt;
Army&apos;s analysis, do you think there is now sufficient reasoning for&lt;br/&gt;
the derby-3310_try1_diff.txt change.&lt;/p&gt;</comment>
                            <comment id="12577980" author="kmarsden" created="Wed, 12 Mar 2008 18:59:11 +0000"  >&lt;p&gt;Attached is a revision of the try1 patch (derby-3310_diff.txt) that adds some comments to the changed method.  Since Army confirmed that this change the right thing to do, I would like to commit this patch to get rid of this regression for 10.4.  I welcome comments on the comments and the patch.&lt;/p&gt;

&lt;p&gt;Ultimately with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3494&quot; title=&quot;Move the setup of NormalizeResultSetNode into the NormalizeResultSetNode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3494&quot;&gt;&lt;del&gt;DERBY-3494&lt;/del&gt;&lt;/a&gt; I would like to try to roll this method into NormalizeResultSetNode, but for this fix I think it best not to combine it with code reorg.&lt;/p&gt;
</comment>
                            <comment id="12577981" author="kmarsden" created="Wed, 12 Mar 2008 19:04:31 +0000"  >&lt;p&gt;had an extraneous file in the diff&lt;/p&gt;</comment>
                            <comment id="12578442" author="kmarsden" created="Thu, 13 Mar 2008 18:49:14 +0000"  >&lt;p&gt;I plan to commit &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3310&quot; title=&quot;ASSERT in MergeSort.checkColumnTypes() disallow legal type conversions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3310&quot;&gt;&lt;del&gt;DERBY-3310&lt;/del&gt;&lt;/a&gt;_diff.txt this afternoon.&lt;br/&gt;
Please let me know if you have any concerns.&lt;/p&gt;
</comment>
                            <comment id="12578482" author="djd" created="Thu, 13 Mar 2008 20:38:55 +0000"  >&lt;p&gt;It would be good to get the contents of Army&apos;s analysis into the code, rather than just hanging off a jira issue.&lt;/p&gt;</comment>
                            <comment id="12578496" author="kmarsden" created="Thu, 13 Mar 2008 21:18:36 +0000"  >&lt;p&gt;I wasn&apos;t so sure where to hang it in the code where it would make sense, especially after&lt;br/&gt;
the change was made,  so I added a short summary to copyTypesAndLengthsToSource &lt;br/&gt;
and referenced the full document.  Where in the code would be a good place to put it?  I could add it as &lt;br/&gt;
part of the commit log or ...&lt;/p&gt;</comment>
                            <comment id="12578498" author="djd" created="Thu, 13 Mar 2008 21:31:27 +0000"  >&lt;p&gt;The commit log is not the correct place.&lt;/p&gt;

&lt;p&gt;I don&apos;t know where the correct place is, but it seems to be explaining how various nodes work together etc.,&lt;br/&gt;
so appropriate comments in the javadoc for nodes and/or their methods seems the best. I&apos;m sure it&apos;s not just&lt;br/&gt;
a matter of taking the text and placing it in one location. It just seems a shame for the information Army worked hard&lt;br/&gt;
to produce not to be in the most useful place.&lt;/p&gt;

&lt;p&gt;If anyone gains understanding of any piece of code during development or bug-fixing then it&apos;s best for the community&lt;br/&gt;
if that knowledge is kept, typically by adding comments to the code.&lt;/p&gt;

&lt;p&gt;Another option is the language how-it-works section on the wiki, there it probably could be as a single document.&lt;/p&gt;</comment>
                            <comment id="12580660" author="kmarsden" created="Thu, 20 Mar 2008 04:52:53 +0000"  >&lt;p&gt;Resolving for 10.5 and 10.4. Thanks so much Army for your  help with this issue.  I still plan to post some form of Army&apos;s document on the Wiki.&lt;/p&gt;
</comment>
                            <comment id="12583229" author="bryanpendleton" created="Fri, 28 Mar 2008 23:06:12 +0000"  >&lt;p&gt;A little late on this, but I finally got around to having a close read&lt;br/&gt;
of Army&apos;s writeup and it seems 100% accurate to me. It&apos;s a&lt;br/&gt;
wonderful document, and it really helped me understand how &lt;br/&gt;
the Normalize node works, as well as the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2775&quot; title=&quot;DataTypeDescriptor should be immutable so that multiple ValueNode referring to the same DTD do not have unexpected state changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2775&quot;&gt;DERBY-2775&lt;/a&gt; changes interacted&lt;br/&gt;
to exhibit this behavior.&lt;/p&gt;

&lt;p&gt;I think that the document would be quite valuable in the&lt;br/&gt;
class-level javadoc for NormalizeResultSetNode.java, as it&lt;br/&gt;
really does an excellent job of explaining how NRSN is intended to work.&lt;br/&gt;
It&apos;s a clear example, and quite carefully worded and thorough.&lt;/p&gt;

&lt;p&gt;I also think that the document would be quite useful in the wiki, &lt;br/&gt;
if that proves to be easier.&lt;/p&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12388009">DERBY-3395</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12371145">DERBY-2775</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12390220">DERBY-3494</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12383008">DERBY-3221</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12372808" name="cast-repro.sql" size="610" author="dyret" created="Wed, 9 Jan 2008 16:06:27 +0000"/>
                            <attachment id="12377633" name="d3310_writeup_1.html" size="101539" author="army" created="Tue, 11 Mar 2008 19:07:46 +0000"/>
                            <attachment id="12377721" name="derby-3310_diff.txt" size="4383" author="kmarsden" created="Wed, 12 Mar 2008 19:04:31 +0000"/>
                            <attachment id="12377720" name="derby-3310_diff.txt" size="5457" author="kmarsden" created="Wed, 12 Mar 2008 18:59:11 +0000"/>
                            <attachment id="12376772" name="derby-3310_remove_genNormalizeResultSetNode_diff.txt" size="8376" author="kmarsden" created="Thu, 28 Feb 2008 22:13:08 +0000"/>
                            <attachment id="12376257" name="derby-3310_try1_diff.txt" size="3642" author="kmarsden" created="Fri, 22 Feb 2008 19:22:15 +0000"/>
                            <attachment id="12376285" name="derby3310_rsn_cleanup_1.txt" size="6078" author="djd" created="Sat, 23 Feb 2008 00:11:02 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 7 Feb 2008 16:40:14 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23564</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10102"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ltj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37353</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>