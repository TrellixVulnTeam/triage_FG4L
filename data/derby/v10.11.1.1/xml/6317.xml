<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:49:44 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-6317/DERBY-6317.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-6317] Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6317</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The optimizer can chose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0.  &lt;/p&gt;

&lt;p&gt;Assume that you have two tables that are being joined like:&lt;/p&gt;


&lt;p&gt;SELECT * FROM T1, T0&lt;br/&gt;
WHERE T1.ID = T0.F_ID and&lt;br/&gt;
T0.ID = 3;&lt;/p&gt;

&lt;p&gt;Also assume that T0 has two columns, ID and F_ID and F_ID is a foreign key on T1.ID.   Assume that T1.ID is the primary key of T1 and (T0.F_ID, T0.ID) is the primary key on T0.  Assume that there is a non-unique index on T0.ID.&lt;/p&gt;

&lt;p&gt;The correct query plan for this should be to query T0 using the non-unique index on T0.ID and then use the foreign key value in those rows to do query T1 using the primary key on T1.&lt;/p&gt;

&lt;p&gt;With some values of T0.ID in the above query this query plan is chosen and works.  With other values of T0.ID , the query plan does an query on T0 using the non-unique index on T0.ID and then does a table scan on T1.&lt;/p&gt;

&lt;p&gt;For example, in my case the query:&lt;/p&gt;

&lt;p&gt;SELECT * FROM T1, T0&lt;br/&gt;
WHERE T1.ID = T0.F_ID and&lt;br/&gt;
T0.ID = 22112129;&lt;/p&gt;

&lt;p&gt;has this query plan.   &lt;/p&gt;

&lt;p&gt;The problem appears to be in BTreeCostController.java.  When this returns the same value for the &quot;left_of_start&quot; and the &quot;left_of_stop&quot; (which is being used to estimate the number of rows and cost), then the estimate cost and row count becomes 0.0.   When this is used in the join order of T0, T1, then the cost of the table scan for T1 becomes 0.0 as well.&lt;/p&gt;</description>
                <environment>Derby 10.8.2.2 on Oracle Solaris 10 </environment>
        <key id="12665641">DERBY-6317</key>
            <summary>Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mikem">Mike Matrigali</assignee>
                                    <reporter username="bbergquist">Brett Bergquist</reporter>
                        <labels>
                    </labels>
                <created>Tue, 27 Aug 2013 03:25:59 +0100</created>
                <updated>Wed, 21 Jan 2015 00:22:55 +0000</updated>
                            <resolved>Wed, 18 Sep 2013 17:48:04 +0100</resolved>
                                    <version>10.8.2.2</version>
                                    <fixVersion>10.8.3.3</fixVersion>
                    <fixVersion>10.9.2.2</fixVersion>
                    <fixVersion>10.10.2.0</fixVersion>
                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13750905" author="bbergquist" created="Tue, 27 Aug 2013 03:28:17 +0100"  >&lt;p&gt;When BTreeCostController.java returns the same value for &quot;left_of_start&quot; and &quot;left_of_stop&quot;, this conceptually means that very few rows are going to be returned using the index but it does not mean that 0 (zero rows) are going to be returned which is what the code currently does.&lt;/p&gt;</comment>
                            <comment id="13751398" author="mikem" created="Tue, 27 Aug 2013 17:27:49 +0100"  >&lt;p&gt;The following email thread has critical info for this bug:&lt;br/&gt;
I think i found were the issue occurs.  I am able to reproduce the problem with Derby 10.8.2.2.   The database has about 7 million records in APP.CONFIGURATION_BUNDLES3 and about 48 million records in COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3.   On  COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3, there is a non-unique index on COSEDDROPPROFILEDSCPTABLEENTRY_ID.&lt;/p&gt;

&lt;p&gt;Sometimes on the same query with specific values, the query works correctly in that the query plan chooses to do an index lookup on COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 using the index and then an index lookup on APP.CONFIGURATION_BUNDLES3.   Other times on the same query with another query value, the query plan chooses to do an index lookup on APP.CONFIGURATION_BUNDLES3 and then a table scan on APP.CONFIGURATION_BUNDLES3 which is incorrect.   The problem occurs because of the cost and row estimate on COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 for specific values.&lt;/p&gt;

&lt;p&gt;Here is a query that works correctly:&lt;/p&gt;

&lt;p&gt;SELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,&lt;br/&gt;
APP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0&lt;br/&gt;
WHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and&lt;br/&gt;
t0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 3;&lt;/p&gt;

&lt;p&gt;and here is the same query with a different value that fails with the table scan:&lt;/p&gt;

&lt;p&gt;SELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,&lt;br/&gt;
APP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0&lt;br/&gt;
WHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and&lt;br/&gt;
t0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 22112129;&lt;/p&gt;

&lt;p&gt;Note that both of these values will exist, the number of rows in the first will be 42 and the second will be 1.  Also note that the values of COSEDDROPPROFILEDSCPTABLEENTRY_ID are pretty spaced out so the value 22112129 is at about 7% of the sequence of values in order.  Also note that there is a non-unique index on  COSEDDROPPROFILEDSCPTABLEENTRY_ID as I said above.&lt;/p&gt;

&lt;p&gt;   In BTreeCostController.java, we have:&lt;/p&gt;

&lt;p&gt;        public void getScanCost(&lt;br/&gt;
    int                     scan_type,&lt;br/&gt;
    long                    row_count,&lt;br/&gt;
    int                     group_size,&lt;br/&gt;
    boolean                 forUpdate,&lt;br/&gt;
    FormatableBitSet                 scanColumnList,&lt;br/&gt;
    DataValueDescriptor[]   template,&lt;br/&gt;
    DataValueDescriptor[]   startKeyValue,&lt;br/&gt;
    int                     startSearchOperator,&lt;br/&gt;
    DataValueDescriptor[]   stopKeyValue,&lt;br/&gt;
    int                     stopSearchOperator,&lt;br/&gt;
    boolean                 reopen_scan,&lt;br/&gt;
    int                     access_type,&lt;br/&gt;
    StoreCostResult         cost_result)&lt;br/&gt;
        throws StandardException&lt;br/&gt;
    {&lt;br/&gt;
        float       left_of_start;&lt;br/&gt;
        float       left_of_stop;&lt;br/&gt;
        ControlRow  control_row = null;&lt;br/&gt;
        long        input_row_count = (row_count &amp;lt; 0 ? num_rows : row_count);&lt;/p&gt;

&lt;p&gt;        try&lt;br/&gt;
        {&lt;br/&gt;
            // Find the starting page and row slot.&lt;br/&gt;
            if (startKeyValue == null)&lt;/p&gt;
            {
                left_of_start = 0;
            }
&lt;p&gt;            else&lt;/p&gt;
            {
                // Search for the starting row.

                SearchParameters sp = new SearchParameters(
                    startKeyValue,
                    ((startSearchOperator == ScanController.GE) ?
                        SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH :
                        SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
                    template, this, true);

                control_row =
                    ControlRow.get(this, BTree.ROOTPAGEID).search(sp);

                control_row.release();
                control_row = null;

                left_of_start = sp.left_fraction;
            }

&lt;p&gt;            if (stopKeyValue == null)&lt;/p&gt;
            {
                left_of_stop = 1;
            }
&lt;p&gt;            else&lt;/p&gt;
            {
                // Search for the stopping row.

                SearchParameters sp =
                    new SearchParameters(
                        stopKeyValue,
                        ((stopSearchOperator == ScanController.GE) ?
                          SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH :
                          SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),
                        template, this, true);

                control_row =
                    ControlRow.get(this, BTree.ROOTPAGEID).search(sp);

                control_row.release();
                control_row = null;

                left_of_stop = sp.left_fraction;
            }

&lt;p&gt;            // System.out.println(&lt;br/&gt;
              //   &quot;\n\tleft_of_start = &quot; + left_of_start +&lt;br/&gt;
                // &quot;\n\tleft_of_stop  = &quot; + left_of_stop);&lt;/p&gt;

&lt;p&gt;            // what percentage of rows are between start and stop?&lt;/p&gt;

&lt;p&gt;            float ret_fraction = left_of_stop - left_of_start;&lt;/p&gt;

&lt;p&gt;            // If for some reason the stop position comes before the start&lt;br/&gt;
            // position, assume 0 rows will return from query.&lt;br/&gt;
            if (ret_fraction &amp;lt; 0)&lt;br/&gt;
                ret_fraction = 0;&lt;/p&gt;

&lt;p&gt;            // Never return estimate of more rows than exist, sometimes&lt;br/&gt;
            // the recursive estimation through the btree may return a number&lt;br/&gt;
            // like 1.00001.&lt;br/&gt;
            if (ret_fraction &amp;gt; 1)&lt;br/&gt;
                ret_fraction = 1;&lt;/p&gt;

&lt;p&gt;            float estimated_row_count = input_row_count * ret_fraction;&lt;/p&gt;

&lt;p&gt;            // first the base cost of positioning on the first row in the scan.&lt;br/&gt;
            double cost =&lt;br/&gt;
                getFetchFromFullKeyCost(scanColumnList, access_type);&lt;/p&gt;

&lt;p&gt;            // add the base cost of bringing each page for the first time into&lt;br/&gt;
            // the cache.  This is basically the cost of bringing each leaf&lt;br/&gt;
            // uncached into the cache and reading the control row off of it.:&lt;br/&gt;
            cost +=&lt;br/&gt;
                (num_pages * ret_fraction) * BASE_UNCACHED_ROW_FETCH_COST;&lt;/p&gt;

&lt;p&gt;            // Now some magic to try and figure out the cost of doing a&lt;br/&gt;
            // scan along the leaf level of the tree.  Mostly just assume&lt;br/&gt;
            // the costs are the same as the heap, and ignore qualifier&lt;br/&gt;
            // processing and stop row comparisons for now.&lt;/p&gt;

&lt;p&gt;            // the base cost of getting each of the rows from a page assumed&lt;br/&gt;
            // to already be cached (by the scan fetch) - this is only for all&lt;br/&gt;
            // rows after the initial row on the page has been accounted for&lt;br/&gt;
            // under the BASE_UNCACHED_ROW_FETCH_COST cost.:&lt;br/&gt;
            long cached_row_count = ((long) estimated_row_count) - num_pages;&lt;br/&gt;
            if (cached_row_count &amp;lt; 0)&lt;br/&gt;
                cached_row_count = 0;&lt;/p&gt;

&lt;p&gt;            if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)&lt;br/&gt;
                cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;&lt;br/&gt;
            else&lt;br/&gt;
                cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;&lt;/p&gt;

&lt;p&gt;            // finally add the cost associated with the number of bytes in row:&lt;br/&gt;
            long row_size =&lt;br/&gt;
                (input_row_count == 0) ?&lt;br/&gt;
                    4 : (num_pages * page_size) / input_row_count;&lt;/p&gt;

&lt;p&gt;            cost +=&lt;br/&gt;
                (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;&lt;/p&gt;

&lt;p&gt;            if (SanityManager.DEBUG)&lt;/p&gt;
            {
                if (cost &amp;lt; 0)
                    SanityManager.THROWASSERT(&quot;cost &quot; + cost);

                if (estimated_row_count &amp;lt; 0)
                    SanityManager.THROWASSERT(
                        &quot;estimated_row_count = &quot; + estimated_row_count);
            }

&lt;p&gt;            // return the cost&lt;br/&gt;
            cost_result.setEstimatedCost(cost);&lt;/p&gt;

&lt;p&gt;            // RESOLVE - should we make sure this number is &amp;gt; 0?&lt;br/&gt;
            cost_result.setEstimatedRowCount(Math.round(estimated_row_count));&lt;br/&gt;
        }&lt;br/&gt;
        finally&lt;/p&gt;
        {
            if (control_row != null)
                control_row.release();
        }

&lt;p&gt;        // System.out.println(&quot;BTreeCostController.getScanCost():&quot; +&lt;br/&gt;
          //   &quot;\n\t cost = &quot; + cost_result.getEstimatedCost() +&lt;br/&gt;
            // &quot;\n\t rows = &quot; + cost_result.getEstimatedRowCount());&lt;/p&gt;

&lt;p&gt;        return;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;The problem that I am seeing is that on certain queries coming in the &quot;left_of_start&quot; and the &quot;left_of_stop&quot; can be the same value.   When this occurs, the &quot;ret_fraction&quot; becomes 0.0 and the estimated row count becomes &quot;0.0&quot; and the estimated cost becomes &quot;0.0&quot;.&lt;/p&gt;

&lt;p&gt;When this occurs in the query plan and the join order is APP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 and then APP.CONFIGURATION_BUNDLE3, this outer cost of &quot;0.0&quot; has the effect of causing the cost of the table scan of APP.CONFIGURATION_BUNDLE3 appear to be the lowest cost.   This is incorrect.&lt;/p&gt;

&lt;p&gt;For discrete values that are unique within a large index, it seems to me (and is observed), that the rows left of the start value and rows left of the stop value could very well be the same when the starting and stopping values are the same as in this case.&lt;/p&gt;

&lt;p&gt;As a test, I modified the above code to estimate the rows as 1 when this is the case and ran the code and it immediately pick the access path that it should.  Probably 1 row is not correct but I am having a little trouble to come up with the value that it should be when the starting and stopping row percentage are exactly the same (in this case left_of_stop and right_of_stop is 0.07715294 and the number of rows in the table are 48248128).&lt;/p&gt;

&lt;p&gt;Below I have the output of the optimizer trace for the two queries that I label CORRECT and iNCORRECT in which this can be seen.&lt;/p&gt;

&lt;p&gt;&amp;#8211; CORRECT OPTIMIZER TRACE &amp;#8212;&lt;/p&gt;

&lt;p&gt;&quot;SELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,&lt;br/&gt;
APP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0&lt;br/&gt;
WHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and&lt;br/&gt;
t0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 3&lt;br/&gt;
Optimization started at time 1377549782052 using optimizer 1655768029&lt;/p&gt;


&lt;p&gt;Considering join order:  0 with assignedTableMap = {}&lt;/p&gt;


&lt;p&gt;Calling nextAccessPath() for base table T1 with 0 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Adding unordered optimizable, # of predicates = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;/p&gt;

&lt;p&gt;Remembering join strategy NESTEDLOOP as best for table 0&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy HASH for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Adding unordered optimizable, # of predicates = 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{ID} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}
&lt;p&gt; for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{ID} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 1540600.81, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}
&lt;p&gt; for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{BUNDLE_NAME} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME}
&lt;p&gt; for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{BUNDLE_NAME} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME}
&lt;p&gt; for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{DTYPE} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE}
&lt;p&gt; for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{DTYPE} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE}
&lt;p&gt; for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
No more conglomerates to consider for table 0&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;/p&gt;


&lt;p&gt;Considering join order:  0 1 with assignedTableMap = &lt;/p&gt;
{0}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 2, extra qualifier selectivity is : 0.010000000000000002&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 482481.3300000001, singleScanRowCount == 482481.3300000001 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 8.750136837956523E13, rowCount == 7003486.0, singleScanRowCount == 482481.3300000001 for table 1&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 482481.33 for table 1&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Guaranteed to match a single row - cost is: 7.8575 for table 1&lt;br/&gt;
Lock mode set to MODE_RECORD because all start and stop positions are constant&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0 for table 1&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 0.1&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 1, statistics start/stop selectivity is : 1.3264763349989454E-6&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Cost including extra statistics for index being considered start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 24.802827036771248, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 128.99483567478512, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 64.00000530590533 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 6.400000530590534 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.4915061182000002E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.010000000000000002&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 9.346302007800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 8.544554508045316, rowCount == 4.0, singleScanRowCount == 4.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.0544836870533226E8, rowCount == 7003486.0, singleScanRowCount == 4.0 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.0544836870533226E8, rowCount == 7003486.0, singleScanRowCount == 0.4 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
No more conglomerates to consider for table 1&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0&lt;br/&gt;
We have a complete join order.&lt;br/&gt;
This is the cheapest plan so far.&lt;br/&gt;
Plan is a normal plan.&lt;br/&gt;
Cost of cheapest plan is Level2CostEstimateImpl: at 70394772, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 69248303, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 69248303, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table 0 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2067575494, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2067575494, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Remembering join order as best:  0 1 with assignedTableMap = {0, 1}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Considering join order:  1 with assignedTableMap = {}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Adding unordered optimizable, # of predicates = 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Selectivity from statistics found. It is 2.3194399498852528E-8&lt;br/&gt;
Cost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 1.11908647187577, singleScanRowCount == 1.11908647187577 for table 1&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Adding unordered optimizable, # of predicates = 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Selectivity from statistics found. It is 2.3194399498852528E-8&lt;br/&gt;
Cost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Selectivity from statistics found. It is 2.3194399498852528E-8&lt;br/&gt;
Cost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 997551539, cost == 8.544554508045316, rowCount == 4.0, singleScanRowCount == 4.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0 for table 1&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
No more conglomerates to consider for table 1&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Considering join order:  1 0 with assignedTableMap = {1}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 700348.6000000001, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Cost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.733707864E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 0&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 3&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 3&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 4470393.76, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 4470393.76, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 4470393.76, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
Guaranteed to match a single row - cost is: 6.286 for table 0&lt;br/&gt;
Lock mode set to MODE_RECORD because all start and stop positions are constant&lt;br/&gt;
Cost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 25.144, rowCount == 4.0, singleScanRowCount == 1.0 for table 0&lt;br/&gt;
Index does not cover query - cost including base row fetch is: 7.84 for table 0&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 0&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 1679861.03, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.540669359E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.540669359E7, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 1.540669359E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 6.4345659848000005E7, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 6.4345659848000005E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 457048813, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 6.5446505688E7, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 6.5446505688E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
No more conglomerates to consider for table 0&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 48.04055450804531, rowCount == 4.0, singleScanRowCount == 1.0&lt;br/&gt;
We have a complete join order.&lt;br/&gt;
This is the cheapest plan so far.&lt;br/&gt;
Plan is a normal plan.&lt;br/&gt;
Cost of cheapest plan is Level2CostEstimateImpl: at 70394772, cost == 48.04055450804531, rowCount == 4.0, singleScanRowCount == 1.0&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 726246088, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 726246088, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}, costEstimate == Level2CostEstimateImpl: at 1868435115, cost == 32.983999999999995, rowCount == 4.0, singleScanRowCount == 1.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}, costEstimate == Level2CostEstimateImpl: at 1868435115, cost == 32.983999999999995, rowCount == 4.0, singleScanRowCount == 1.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 0 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Remembering join order as best:  1 0 with assignedTableMap = {0, 1}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Modifying access paths using optimizer 1655768029&lt;br/&gt;
Changing access path for table 1&lt;br/&gt;
Changing access path for table 0&lt;br/&gt;
&quot;&lt;br/&gt;
&lt;br/&gt;
&amp;#8212; INCORRECT OPTIMIZER TRACE &amp;#8212;&lt;br/&gt;
&lt;br/&gt;
&quot;SELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,&lt;br/&gt;
APP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0&lt;br/&gt;
WHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and&lt;br/&gt;
t0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 22112129&lt;br/&gt;
Optimization started at time 1377549702099 using optimizer 2101481450&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Considering join order:  0 with assignedTableMap = {}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Adding unordered optimizable, # of predicates = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 0&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Adding unordered optimizable, # of predicates = 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 1540600.81, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 0 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
No more conglomerates to consider for table 0&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Considering join order:  0 1 with assignedTableMap = {0}


&lt;p&gt;Calling nextAccessPath() for base table T0 with 2 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 2, extra qualifier selectivity is : 0.010000000000000002&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 482481.3300000001, singleScanRowCount == 482481.3300000001 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 8.750136837956523E13, rowCount == 7003486.0, singleScanRowCount == 482481.3300000001 for table 1&lt;/p&gt;

&lt;p&gt;Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy HASH for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 482481.33 for table 1&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Considering join strategy NESTEDLOOP for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Guaranteed to match a single row - cost is: 7.8575 for table 1&lt;br/&gt;
Lock mode set to MODE_RECORD because all start and stop positions are constant&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0 for table 1&lt;/p&gt;

&lt;p&gt;Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy HASH for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 0.1&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 1, statistics start/stop selectivity is : 1.3264763349989454E-6&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Cost including extra statistics for index being considered start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 24.802827036771248, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 128.99483567478512, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 64.00000530590533 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 6.400000530590534 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.4915061182000002E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.010000000000000002&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 9.346302007800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 15.715, rowCount == 2.0, singleScanRowCount == 2.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 18.971, rowCount == 2.0, singleScanRowCount == 2.0 for table 1&lt;br/&gt;
Cost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.32863132906E8, rowCount == 7003486.0, singleScanRowCount == 2.0 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.32863132906E8, rowCount == 7003486.0, singleScanRowCount == 0.2 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 2 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
No more conglomerates to consider for table 1&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0&lt;br/&gt;
We have a complete join order.&lt;br/&gt;
This is the cheapest plan so far.&lt;br/&gt;
Plan is a normal plan.&lt;br/&gt;
Cost of cheapest plan is Level2CostEstimateImpl: at 245104354, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 2063323644, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 2063323644, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table 0 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt;, costEstimate == Level2CostEstimateImpl: at 714552952, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;/p&gt;

&lt;p&gt;Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 714552952, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Remembering join order as best:  0 1 with assignedTableMap = {0, 1}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Considering join order:  1 with assignedTableMap = {}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Adding unordered optimizable, # of predicates = 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1&lt;br/&gt;
Selectivity from statistics found. It is 2.3194399498852528E-8&lt;br/&gt;
Cost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 1.11908647187577, singleScanRowCount == 1.11908647187577 for table 1&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1&lt;br/&gt;
Adding unordered optimizable, # of predicates = 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Selectivity from statistics found. It is 2.3194399498852528E-8&lt;br/&gt;
Cost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy HASH for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1&lt;br/&gt;
Selectivity from statistics found. It is 2.3194399498852528E-8&lt;br/&gt;
Cost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 1&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :&lt;br/&gt;
Level2CostEstimateImpl: at 572153096, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0 for table 1&lt;br/&gt;
Cost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0 for table 1&lt;br/&gt;
&lt;br/&gt;
Remembering join strategy NESTEDLOOP as best for table 1&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 1&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt; for table 1&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T0 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 1&lt;br/&gt;
No more conglomerates to consider for table 1&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0&lt;/p&gt;


&lt;p&gt;Considering join order:  1 0 with assignedTableMap = &lt;/p&gt;
{1}


&lt;p&gt;Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 700348.6000000001, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Cost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0&lt;/p&gt;

&lt;p&gt;Remembering join strategy NESTEDLOOP as best for table 0&lt;br/&gt;
in best access path&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy HASH for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Scanning heap, but we have a full match on a unique key.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 3&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 3&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 4470393.76, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Cost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 4470393.76, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 4470393.76, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{ID} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}
&lt;p&gt; for table 0&lt;br/&gt;
Guaranteed to match a single row - cost is: 6.286 for table 0&lt;br/&gt;
Lock mode set to MODE_RECORD because all start and stop positions are constant&lt;br/&gt;
Cost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 1.0 for table 0&lt;br/&gt;
Index does not cover query - cost including base row fetch is: 0.0 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy HASH for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{ID} for table 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
&lt;br/&gt;
# hash key columns = 1hashKeyColumns&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}
&lt;p&gt; for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{ID}
&lt;p&gt; scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 1679861.03, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.540669359E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.540669359E7, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 1.540669359E7, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Skipping access path due to excess memory usage, maximum is 1048576&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{BUNDLE_NAME} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME}
&lt;p&gt; for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{BUNDLE_NAME} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME}
&lt;p&gt; for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;/p&gt;

&lt;p&gt;Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{DTYPE} for table 0&lt;br/&gt;
Estimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE}
&lt;p&gt; for table 0&lt;br/&gt;
Cost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{DTYPE} scan for table number 0 is :&lt;br/&gt;
Level2CostEstimateImpl: at 1625417063, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0&lt;br/&gt;
        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0&lt;br/&gt;
        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0&lt;br/&gt;
        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0&lt;br/&gt;
        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0&lt;br/&gt;
        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1&lt;br/&gt;
Lock mode set to MODE_TABLE because no start or stop position&lt;br/&gt;
Index does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0&lt;br/&gt;
Cost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;br/&gt;
&lt;br/&gt;
Considering join strategy HASH for table 0&lt;br/&gt;
&lt;br/&gt;
Considering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE}
&lt;p&gt; for table 0&lt;br/&gt;
Skipping HASH JOIN because there are no hash key columns&lt;br/&gt;
Calling nextAccessPath() for base table T1 with 1 predicates.&lt;/p&gt;

&lt;p&gt;Considering join strategy NESTEDLOOP for table 0&lt;br/&gt;
No more conglomerates to consider for table 0&lt;br/&gt;
Total cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 700348.6000000001&lt;br/&gt;
We have a complete join order.&lt;br/&gt;
This is the cheapest plan so far.&lt;br/&gt;
Plan is a normal plan.&lt;br/&gt;
Cost of cheapest plan is Level2CostEstimateImpl: at 245104354, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 700348.6000000001&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = &lt;/p&gt;
{COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2057836940, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;br/&gt;
&lt;br/&gt;
Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}
&lt;p&gt;, costEstimate == Level2CostEstimateImpl: at 2057836940, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal&lt;/p&gt;

&lt;p&gt;Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 959713667, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table -1 for plan type  normal&lt;/p&gt;

&lt;p&gt;Remembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 959713667, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table 0 for plan type  normal&lt;/p&gt;



&lt;p&gt;Remembering join order as best:  1 0 with assignedTableMap = &lt;/p&gt;
{0, 1}


&lt;p&gt;Modifying access paths using optimizer 2101481450&lt;br/&gt;
Changing access path for table 1&lt;br/&gt;
Changing access path for table 0&lt;br/&gt;
&quot;&lt;/p&gt;


&lt;p&gt;On Aug 24, 2013, at 8:00 AM, &quot;Bergquist, Brett&quot; &amp;lt;BBergquist@canoga.com&amp;gt; wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Derby developers (Mike, Manta, Bryan, Rick ,Knut, and if I forgot anyone that has help me in the past), I just want to thank you for your help!   I realize that you guys have day jobs just like me an taking the time out to give me some pointers is really appreciated!&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I am trying to produce reduced size and readily reproducible case but would you knot know it, the symptoms change    I saved a database that was working with 10.8.2.2 with (after shutting down) tar cvEf - db | compress &amp;gt;db.8.tar.Z earlier.   So just to verify again that this did indeed work correctly, I restored this database and the 10.8.2.2 libraries performed the queue and darn if the 10.8.2.2 did not exhibit the same problem.    So then last night I deleted the database and created it fresh again from the same exact script that allowed 10.8.2.2 to work and again it still has the same problem.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; So now I have no confidence of my test setup and also don&apos;t think the issue is confined to 10.9.1.1.   So I will be quiet until I get a case where it works and then understand why and what triggers it to not work.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; On Aug 23, 2013, at 6:39 PM, mike matrigali &amp;lt;mikemapp1@gmail.com&amp;gt; wrote:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; On 8/23/2013 2:55 PM, Bergquist, Brett wrote:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; Mike I would love to open a Jira but having a reproducible case is important as I realize.  Right now, the reproducible database is 2Gb compressed which is really not practical to upload.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; My goal right now is to fix the problem.  The problem is in production, a large telecomm company, and the real database is about 200Gb.  The database has been hard upgraded and has been in use for about 2 weeks so rolling back to backup before the hard upgrade is not possible.  Only going forward is possible.   So I have the debugger connected up right now and am going through the code.  I am also comparing 10.8.2.2 version 10.9.1.0 to look for any suspicious differences.  I have to fix this now, not months from now.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; What would be really useful would be to:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; 1. understand how to turn on the optimizer tracing facility that I see in the 10.9.1.0 source.  For example:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;             optimizerTrace = lcc.getOptimizerTrace();&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;   I can figure this out, but if anyone can point to a wiki page or some other resource to enable the magic, sharing it will be most welcome.&lt;br/&gt;
&amp;gt;&amp;gt; I have not used the following but have been pointed at it by those who do:&lt;br/&gt;
&amp;gt;&amp;gt; &lt;a href=&quot;http://wiki.apache.org/db-derby/OptimizerTracing&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/OptimizerTracing&lt;/a&gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; 2. understand if it would be possible to access my test database that has been hard upgraded to 10.9.1.0 with 10.8.2.2.  I know that when I boot the database it will complain and not boot but if I am just doing a read-only query on the database with 10.8.2.2 and the query works, this will give me real confidence that the problem is in the code changes from 10.8.2.2 to 10.9.1.1 and not something related to the structure now stored in the database.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; So I am working on this, am looking for pointers of where to look in the code, and will open a Jira also supply a patch when I have this fixed.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; this one is hard, definitely nothing is supported to to do this, and no&lt;br/&gt;
&amp;gt;&amp;gt; magic property is coming to mind.  If it does not take days to load your&lt;br/&gt;
&amp;gt;&amp;gt; test db, I would just build a 10.8 db and load it.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Mostly catalog issues are what happen in hard upgrade, so doing a query&lt;br/&gt;
&amp;gt;&amp;gt; with old code on a new hard upgrade db &quot;probably&quot; works.  But even&lt;br/&gt;
&amp;gt;&amp;gt; booting might write stuff that would then be a problem using it later,&lt;br/&gt;
&amp;gt;&amp;gt; even if your intent is only to run read-only queries.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; You could build your own 10.8 and just change the code to skip the&lt;br/&gt;
&amp;gt;&amp;gt; checks that don&apos;t allow it to boot.  This might work or it might corrupt&lt;br/&gt;
&amp;gt;&amp;gt; the db during the boot process.  If you are trying this I would make&lt;br/&gt;
&amp;gt;&amp;gt; a copy of the test db to try i on.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;/p&gt;


</comment>
                            <comment id="13751406" author="mikem" created="Tue, 27 Aug 2013 17:34:34 +0100"  >&lt;p&gt;I think there are multiple things going wrong here, as you point out.  If you have the time can you answer the following&lt;br/&gt;
with you repro case (hopefully someone can come up with a program to create a test case now that we know underlying issue).&lt;/p&gt;

&lt;p&gt;1) can you try the query on some value where there are exactly 2 values, maybe just add another row to the value you know there is&lt;br/&gt;
   only one of?  Just wondering if this is an off by 1 bug somewhere.&lt;/p&gt;

&lt;p&gt;2) Do you ever get a bad query plan if you use &quot;?&quot; parameters rather than exact values?  I would expect not as it should travel&lt;br/&gt;
   a whole different path through the optimizer.&lt;/p&gt;

&lt;p&gt;3) you mention a cost of 0.0 (vs. row count of 0).  Where are you getting that from?  It seems like the btree method is trying &lt;br/&gt;
   to always return a non-zero cost.  Just wondering if it is getting lost in the optimizer or if some print routine is not &lt;br/&gt;
   printing enough decimals.&lt;/p&gt;</comment>
                            <comment id="13751411" author="mikem" created="Tue, 27 Aug 2013 17:36:10 +0100"  >&lt;p&gt;I don&apos;t have a lot of experience reading the optimizer cost output.  It seems like cost of scanning millions of &lt;br/&gt;
rows should be huge even if you think you are going to get &quot;0&quot; rows, so would like to understand if there is a&lt;br/&gt;
bug there also.&lt;/p&gt;</comment>
                            <comment id="13751421" author="mikem" created="Tue, 27 Aug 2013 17:44:54 +0100"  >&lt;p&gt;From a &quot;get it done&quot; perspective, making the routine return 1 row rather than 0 matches similar instances in other&lt;br/&gt;
parts of the code (and there is a RESOLVE in the code that asks even if that should be the case).  It is still an&lt;br/&gt;
estimate even though it is using real data, so there is always part that is a guess and since we know &quot;0&apos;s&quot; seem&lt;br/&gt;
to cause problems it seem reasonable to me to make it 1.  It matches current assumptions about unique key indexes where&lt;br/&gt;
we return estimates of 1 row for matching key scan, when it could really return either 0 or 1 row.&lt;/p&gt;

&lt;p&gt;It may hide other&lt;br/&gt;
bugs in optimizer costing but seems like a reasonable incremental fix if it seems to fix your bug and passes existing&lt;br/&gt;
tests.  &lt;/p&gt;

&lt;p&gt;Your app is definitely exploring areas that have not been tested in Derby.  When that code was written, it is likely no&lt;br/&gt;
disk existed in development that could have held your db.&lt;/p&gt;</comment>
                            <comment id="13751474" author="bbergquist" created="Tue, 27 Aug 2013 18:29:36 +0100"  >&lt;p&gt;Mike&apos;s request:&lt;/p&gt;

&lt;p&gt;   1) can you try the query on some value where there are exactly 2 values, maybe just add another row to the value you know there is &lt;br/&gt;
only one of? Just wondering if this is an off by 1 bug somewhere.&lt;/p&gt;

&lt;p&gt;I added a new row which has the same value being queried on (22112129) and the left_of_start and right_of_start still return the same value even though there are now two rows that will be returned in the query.   So it does not look like a off by 1 bug.   I surmise that since it it dealing with percentages and these are floating point, non-exact values, that what is happening is that sometimes the percentage of the result space starting and stopping regions are so close that the percentages become equivalent.&lt;/p&gt;

&lt;p&gt;   3) The BtreeCostController is probably never returning a 0.0 cost, but in FromBaseTable.java, we have:&lt;/p&gt;


&lt;p&gt;			/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Let the join strategy decide whether the cost of the base&lt;/li&gt;
		&lt;li&gt;scan is a single scan, or a scan per outer row.&lt;/li&gt;
		&lt;li&gt;NOTE: The multiplication should only be done against the&lt;/li&gt;
		&lt;li&gt;total row count, not the singleScanRowCount.&lt;br/&gt;
			*/&lt;br/&gt;
			double newCost = costEstimate.getEstimatedCost();&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;			if (currentJoinStrategy.multiplyBaseCostByOuterRows())&lt;/p&gt;
			{
				newCost *= outerCost.rowCount();
			}

&lt;p&gt;			costEstimate.setCost(&lt;br/&gt;
				newCost,&lt;br/&gt;
				costEstimate.rowCount() * outerCost.rowCount(),&lt;br/&gt;
				costEstimate.singleScanRowCount());&lt;/p&gt;

&lt;p&gt;So if the row count of the outer table of the join is 0.0, the newCost can end up being 0.0, even though the cost for the table being processed is very large.&lt;/p&gt;</comment>
                            <comment id="13751549" author="bbergquist" created="Tue, 27 Aug 2013 19:24:09 +0100"  >&lt;p&gt;Mikes request:&lt;/p&gt;

&lt;p&gt;   2) Do you ever get a bad query plan if you use &quot;?&quot; parameters rather than exact values? I would expect not as it should travel&lt;br/&gt;
a whole different path through the optimizer.&lt;/p&gt;

&lt;p&gt;I tried this and what happens is that BtreeCostController.getScanCost is called with null values for startKeyValue and stopKeyValue.  This causes the left_of_start to be set to 0.0 and left_of_stop to be set to 1.0, effectively causing this to estimate that the complete range of index values are going to be processed.&lt;/p&gt;

&lt;p&gt;Then the selectivity as defined by the statistics take more effect.&lt;/p&gt;</comment>
                            <comment id="13751616" author="mikem" created="Tue, 27 Aug 2013 20:25:03 +0100"  >&lt;p&gt;for question #2, is the query plan &quot;correct&quot; when you use &quot;?&quot; parameter?&lt;/p&gt;</comment>
                            <comment id="13751678" author="bbergquist" created="Tue, 27 Aug 2013 21:26:22 +0100"  >&lt;p&gt;It does choose a valid and optimal one but because the BtreeCostController is really not coming into play.  That is returning all rows as the estimate row count.  So for example, for a 7M row table, the estimate row count is 7M and the cost is very high because of the other calculations done in there (ie. cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST).&lt;/p&gt;

&lt;p&gt;Then FromBaseTable uses the statistics selectivity in the final cost computation.&lt;/p&gt;

&lt;p&gt;So the answer is yes it gets a &quot;correct&quot; plan, but though a different computation of the cost.&lt;/p&gt;</comment>
                            <comment id="13751680" author="mikem" created="Tue, 27 Aug 2013 21:28:34 +0100"  >&lt;p&gt;i do see a lot of cost *= cost and rowcount = rowcount1 * rowcount2 kinds of code in the optimizer, so even more&lt;br/&gt;
reason not to return 0 out of the store costs.  &lt;/p&gt;

&lt;p&gt;I guess the optmizer model might not be wrong if it is actually the case that if there were 0 rows in the outer table that&lt;br/&gt;
it would actually not do the full scan.  But since these are all estimates seems like there always should be some cost that&lt;br/&gt;
is linearly related to number of rows scanned if there are actually not 0 rows.  better to be a little pessimistic and return&lt;br/&gt;
1 row rather 0.  &lt;/p&gt;

&lt;p&gt;There may be ways to make that btree code be smarter when it is returning a very small number of rows, especially if the&lt;br/&gt;
start search and stop search are actually the same page.&lt;/p&gt;</comment>
                            <comment id="13751708" author="mikem" created="Tue, 27 Aug 2013 21:53:07 +0100"  >&lt;p&gt;&amp;gt;It does choose a valid and optimal one but because the BtreeCostController is really not coming into play. That is returning all rows as the &amp;gt;estimate row count. So for example, for a 7M row table, the estimate row count is 7M and the cost is very high because of the other &amp;gt;calculations done in there (ie. cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST).&lt;/p&gt;

&lt;p&gt;&amp;gt;Then FromBaseTable uses the statistics selectivity in the final cost computation.&lt;/p&gt;

&lt;p&gt;&amp;gt;So the answer is yes it gets a &quot;correct&quot; plan, but though a different computation of the cost.&lt;/p&gt;

&lt;p&gt;good, just wanted to make sure that there was not a bug in that area also.  I believe this is working as designed, picking&lt;br/&gt;
a correct plan for the &quot;average&quot; possible value - since this compiled plan then can be used over and over by different values.&lt;br/&gt;
This is what we usually recommend to users to avoid a recompile cost on every execution, which may be why this bug has &lt;br/&gt;
existed for a long time.&lt;/p&gt;</comment>
                            <comment id="13751906" author="mikem" created="Wed, 28 Aug 2013 00:43:48 +0100"  >&lt;p&gt;Here is a patch against trunk to get some feedback for &lt;br/&gt;
the discussion.  It simply always returns &lt;br/&gt;
at least one row as the estimated rows returned whenever store is asked how many rows qualify for a particular range of an&lt;br/&gt;
index scan (in store asking for 1 key is still a range scan where the start is &amp;gt;= key and stop is &amp;gt; key).&lt;/p&gt;

&lt;p&gt;I have no repro at this point, but would like to check one in with any fix.  If the&lt;br/&gt;
repro really needs 47 million rows would likely not include it in nightly tests, and instead add it to the large data tests.&lt;/p&gt;

&lt;p&gt;Running existing tests now to see if this causes any problems with existing tests.  All tests passed on this initial patch,&lt;br/&gt;
and Brett reports it fixed the issue in his database.&lt;/p&gt;</comment>
                            <comment id="13752338" author="bbergquist" created="Wed, 28 Aug 2013 13:25:39 +0100"  >&lt;p&gt;I have the patch applied and it fixes the estimated row cost.  &lt;/p&gt;

&lt;p&gt;But if you look farther above, the estimated_row_count is computed from the ret_fraction (which can end up as 0.0 if the left_of_start and left_of_stop are the same) and this is used in computing the initial cost and later used in computed the cached_row_count which is also used in computing the cost.&lt;/p&gt;

&lt;p&gt;Might it not be useful to have the estimated_row_count be set to &quot;1&quot; when the ret_fraction is 0.0 so that these other calculations are based the one row?  This is nearly what would happen if in the example above with 48 million rows, that the left_of_start returned 0.07715294 and the left_of_stop returned 0.07715295, the estimated_row_count would be .48 rows.  That way the cost does not become 0.0 when the left_of_start and left_of_stop are the same.&lt;/p&gt;
</comment>
                            <comment id="13752645" author="mikem" created="Wed, 28 Aug 2013 19:07:10 +0100"  >&lt;p&gt;This second patch addresses brett&apos;s comment about making cost return based on 1 row.  This version moves the default setting of a minimum of 1 row returned up in the routine so that all other calculations are based on at least 1 row being returned.&lt;/p&gt;

&lt;p&gt;Will run full tests on this version.  This patch also passed full tests on trunk.&lt;/p&gt;</comment>
                            <comment id="13753303" author="mamtas" created="Thu, 29 Aug 2013 05:48:43 +0100"  >&lt;p&gt;I am trying to see if I can reproduce the problem. I am trying it right now with 8million rows in the table which I think looks like the table Brett has but with 48million rows. When I tried 800,000 rows, the problem did not reproduce. I will post the result of that run when it is finished but I wanted to share the test code to make sure I am mimicking Brett&apos;s tables and indexes correctly. Please let me know if the test code needs to be changed to match the problem schema. I have also added a println in BTreeCostController.getScanCost as follows&lt;br/&gt;
            if (ret_fraction &amp;lt; 0) &lt;/p&gt;
{
                //added following println
            	System.out.println(&quot;In engine code with ret_fraction&amp;lt;0&quot;);
                ret_fraction = 0;
            }
&lt;p&gt;I think when the test runs into estimated row count of 0, we will hit the piece of code above and will see the println printed.&lt;/p&gt;

&lt;p&gt;Run the program as follows&lt;br/&gt;
java  org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC  &amp;gt; dellater.txt&lt;/p&gt;

&lt;p&gt;The output from the program will look as follows&lt;br/&gt;
Testing embedded&lt;br/&gt;
finished creating tables&lt;br/&gt;
Table1 -    done inserting data&lt;br/&gt;
Table3 - done inserting data&lt;br/&gt;
Table2 - done inserting data&lt;br/&gt;
done inserting data&lt;br/&gt;
t0.Table3_ID =0&lt;br/&gt;
t0.Table3_ID =1&lt;br/&gt;
t0.Table3_ID =2&lt;br/&gt;
.....&lt;/p&gt;

&lt;p&gt;And hopefully at some point, we will see &quot;In engine code with ret_fraction&amp;lt;0&quot; in the output printed by the test program.&lt;/p&gt;



&lt;p&gt;package org.apache.derbyTesting.functionTests.tests.lang;&lt;/p&gt;

&lt;p&gt;import java.net.*; &lt;br/&gt;
import java.io.*; &lt;br/&gt;
import java.sql.*;&lt;/p&gt;

&lt;p&gt;/** &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Client template starts its own NetworkServer and runs some SQL against it.&lt;/li&gt;
	&lt;li&gt;The SQL or JDBC API calls can be modified to reproduce issues&lt;/li&gt;
	&lt;li&gt;&lt;p&gt; */&lt;br/&gt;
public class MamtaJDBC { &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    public static void main(String[] args) throws Exception {&lt;br/&gt;
    	//Make Derby use index&lt;br/&gt;
    	Connection conn=null;&lt;br/&gt;
    	Statement s;&lt;br/&gt;
    	PreparedStatement ps;&lt;br/&gt;
        	System.out.println(&quot;Testing embedded&quot;);&lt;br/&gt;
            Class.forName(&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;);&lt;br/&gt;
            try&lt;/p&gt;
{
                conn = DriverManager.getConnection(&quot;jdbc:derby:c:/dellater/ClobTest3;create=true&quot;);
            }
&lt;p&gt;catch(Exception ex){}&lt;br/&gt;
    	s = conn.createStatement();&lt;br/&gt;
        try &lt;/p&gt;
{ 
            s.executeUpdate(&quot;DROP TABLE Table2&quot;); 
        }
&lt;p&gt; catch (SQLException se) &lt;/p&gt;
{ 
            if (!se.getSQLState().equals(&quot;42Y55&quot;)) 
                throw se; 
        } &lt;br/&gt;
        try { 
            s.executeUpdate(&quot;DROP TABLE Table1&quot;); 
        } catch (SQLException se) { 
            if (!se.getSQLState().equals(&quot;42Y55&quot;)) 
                throw se; 
        }
&lt;p&gt; &lt;br/&gt;
        try &lt;/p&gt;
{ 
            s.executeUpdate(&quot;DROP TABLE Table3&quot;); 
        }
&lt;p&gt; catch (SQLException se) &lt;/p&gt;
{ 
            if (!se.getSQLState().equals(&quot;42Y55&quot;)) 
                throw se; 
        }
&lt;p&gt;        //equivalent to Bret&apos;s table &quot;CORE_V1&quot;.&quot;CONFIGURATION_BUNDLE&quot;&lt;br/&gt;
        s.executeUpdate(&quot;CREATE TABLE Table1 (&quot;+&lt;br/&gt;
        		&quot;ID int PRIMARY KEY NOT NULL)&quot;); &lt;br/&gt;
        //equivalent to Bret&apos;s table &quot;PKG_9145E_V1&quot;.&quot;COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY&quot;&lt;br/&gt;
        s.executeUpdate(&quot;CREATE TABLE Table2 (&quot;+&lt;br/&gt;
        		&quot;Table1_ID int NOT NULL,&quot;+&lt;br/&gt;
        		&quot;Table3_ID int NOT NULL,&quot;+&lt;br/&gt;
        		&quot;CONSTRAINT TABLE2_PK PRIMARY KEY &quot;+&lt;br/&gt;
        		&quot;(Table1_ID,Table3_ID))&quot;);&lt;br/&gt;
        //equivalent to Bret&apos;s table &quot;PKG_9145E_V1&quot;.&quot;COS_ED_DROP_PROFILE_DSCP_QMAPPING&quot;&lt;br/&gt;
        s.executeUpdate(&quot;CREATE TABLE Table3 (&quot;+&lt;br/&gt;
        		&quot;ID int PRIMARY KEY NOT NULL)&quot;); &lt;/p&gt;

&lt;p&gt;        s.executeUpdate(&quot;ALTER TABLE table2 &quot;+&lt;br/&gt;
        		&quot;ADD CONSTRAINT TABLE2_FK_1 &quot;+&lt;br/&gt;
        		&quot;FOREIGN KEY (Table1_ID) &quot;+&lt;br/&gt;
        		&quot;REFERENCES TABLE1(ID)&quot;);&lt;br/&gt;
        s.executeUpdate(&quot;ALTER TABLE table2 &quot;+&lt;br/&gt;
        		&quot;ADD CONSTRAINT TABLE2_FK_2 &quot;+&lt;br/&gt;
        		&quot;FOREIGN KEY (Table3_ID) &quot;+&lt;br/&gt;
        		&quot;REFERENCES TABLE3(ID)&quot;);&lt;br/&gt;
        System.out.println(&quot;finished creating tables&quot;);&lt;br/&gt;
	      int count = 1000000; &lt;br/&gt;
	      ps = conn.prepareStatement(&quot;INSERT INTO table1 VALUES &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&quot;);&lt;br/&gt;
  	      for (int i = 0; i &amp;lt; count; i++) &lt;/p&gt;
{ 
  	    	  ps.setInt(1,i);
  	        ps.execute();
	      }
&lt;p&gt; &lt;br/&gt;
  	      System.out.println(&quot;Table1 -    done inserting data&quot;);&lt;br/&gt;
	      count = 8000000; &lt;br/&gt;
	      ps = conn.prepareStatement(&quot;INSERT INTO table3 VALUES &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&quot;);&lt;br/&gt;
  	      for (int i = 0; i &amp;lt; count; i++) &lt;/p&gt;
{ 
  	    	  ps.setInt(1,i);
    	        ps.execute();
	      }
&lt;p&gt; &lt;br/&gt;
  	      System.out.println(&quot;Table3 - done inserting data&quot;);&lt;br/&gt;
	      count = 1000000; &lt;br/&gt;
	      ps = conn.prepareStatement(&quot;INSERT INTO table2 VALUES (?,?)&quot;);&lt;br/&gt;
  	      for (int i = 0; i &amp;lt; count; i++) { &lt;br/&gt;
	  	    	  ps.setInt(1,i);&lt;br/&gt;
  	    	  int j=0;&lt;br/&gt;
  	    	  for (int k=0; k&amp;lt;8; k+&lt;ins&gt;,j&lt;/ins&gt;+) &lt;/p&gt;
{
  	    		  ps.setInt(2,j);
  	              ps.execute();
  	    	  }
&lt;p&gt;	      } &lt;br/&gt;
  	      System.out.println(&quot;Table2 - done inserting data&quot;);&lt;br/&gt;
  	      System.out.println(&quot;done inserting data&quot;);&lt;br/&gt;
	      count = 8000000; &lt;br/&gt;
  	      for (int i = 0; i &amp;lt; count; i++) &lt;/p&gt;
{ 
  	    	  System.out.println(&quot;t0.Table3_ID =&quot;+i);
  	    	  s.execute(&quot;SELECT * FROM &quot;+
  	    	    	  &quot;Table1 T1,&quot;+
     			  &quot;Table2 t0 &quot;+
  	    	    	  &quot;WHERE t1.ID = t0.Table1_ID and &quot;+
     			  &quot;t0.Table3_ID = &quot;+i);
  	      }
&lt;p&gt;  	      System.out.println(&quot;done testing&quot;);&lt;br/&gt;
    }&lt;br/&gt;
}&lt;/p&gt;</comment>
                            <comment id="13753553" author="bbergquist" created="Thu, 29 Aug 2013 13:21:14 +0100"  >&lt;p&gt;Mamta, just confirming that what you have represents the real tables that I have. &lt;/p&gt;</comment>
                            <comment id="13753682" author="mamtas" created="Thu, 29 Aug 2013 15:48:07 +0100"  >&lt;p&gt;Thanks for looking at the program, Brett.&lt;/p&gt;</comment>
                            <comment id="13753732" author="mikem" created="Thu, 29 Aug 2013 16:33:26 +0100"  >&lt;p&gt;not sure exactly where you are putting your code in BTreeCostController but what you posted may not catch&lt;br/&gt;
all the cases we are looking for.  I think there are some cases where the ret_fraction is very small such&lt;br/&gt;
that ret_fraction * number of rows gives back a number of rows &amp;gt; 0 but less than 0.5 and the code then&lt;br/&gt;
rounds the number of rows to 0. I would suggest instrumenting the code near the end of the routine looking&lt;br/&gt;
for estimated_row_count &amp;lt; 0.5&lt;/p&gt;</comment>
                            <comment id="13753739" author="mikem" created="Thu, 29 Aug 2013 16:40:29 +0100"  >&lt;p&gt;also if you want to significantly improve the performance of your load I suggest turning off autocommit and  &lt;br/&gt;
commit every so often.  maybe every 10k or 100k inserts.&lt;/p&gt;

&lt;p&gt;I am not sure of this suggestion, but it might be worth trying 3 queries, that vary i.  Try:&lt;br/&gt;
i = 0&lt;br/&gt;
i = some value in the middle of the range&lt;br/&gt;
i = largest value in range ( i think this is the one you are trying).&lt;/p&gt;</comment>
                            <comment id="13753824" author="bbergquist" created="Thu, 29 Aug 2013 18:17:17 +0100"  >&lt;p&gt;I ended up doing both, returning 1 as the estimated_row_count after detecting ret_fraction == 0 and then at the bottom, I made sure that the rounding did not end up causing an estimated row count == 0.   I saw this happen in my testing even when I did the first change after the ret_fraction and saw table scans in my logging which prompted me to go back in and put in the test after rounding.&lt;/p&gt;</comment>
                            <comment id="13755348" author="mamtas" created="Sat, 31 Aug 2013 02:56:19 +0100"  >&lt;p&gt;I had to make a change to the earlier test program since that program was inserting duplicate values in non-unique foreign key on Table2. It now inserts all unique values in foreign key corresponding to Table3 and I have been able to reproduce the problem. I have attached the repro test case as testRepro_v1.txt. The program creates threee tables as shown below&lt;br/&gt;
        CREATE TABLE Table1 (ID int PRIMARY KEY NOT NULL);&lt;br/&gt;
        CREATE TABLE Table2 (Table1_ID int NOT NULL, Table3_ID int NOT NULL,&lt;br/&gt;
		CONSTRAINT TABLE2_PK PRIMARY KEY (Table1_ID,Table3_ID));&lt;br/&gt;
        CREATE TABLE Table3 (ID int PRIMARY KEY NOT NULL); &lt;/p&gt;

&lt;p&gt;        ALTER TABLE table2 ADD CONSTRAINT TABLE2_FK_1 FOREIGN KEY (Table1_ID) REFERENCES TABLE1(ID);&lt;br/&gt;
        ALTER TABLE table2 ADD CONSTRAINT TABLE2_FK_2 FOREIGN KEY (Table3_ID) REFERENCES TABLE3(ID);&lt;/p&gt;

&lt;p&gt;The program inserts 1million rows in Table1 and 8 million rows in both Table2 and Table3. After the data is loaded, it selects each of the 8 million rows from Table2 individually with a query like following(the constant assigned to&lt;br/&gt;
t0.Table3_ID iterates from 0 to 8million-1).&lt;br/&gt;
SELECT count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM &lt;br/&gt;
	Table1 T1,&lt;br/&gt;
	Table2 t0 &lt;br/&gt;
	WHERE t1.ID = t0.Table1_ID and &lt;br/&gt;
		t0.Table3_ID = 0;&lt;/p&gt;

&lt;p&gt;Additionally, I have two printlns in BTreeCostController.getScanCost towards the bottom of the method. I have attached svn diff for changes in BTreeCostController.getScanCost as DERBY_6317_temp_changes_for_debugging.txt. The method will also have the changes suggested by Mike in his second patch but those changes are commented out.&lt;br/&gt;
		.....&lt;br/&gt;
		//Added this println and if statement with println. The rest of the code is unchanged&lt;br/&gt;
        	System.out.println(&quot;In engine estimated row count is &quot; + estimated_row_count);&lt;br/&gt;
        	if (estimated_row_count &amp;lt; 0.5)&lt;br/&gt;
	            	System.out.println(&quot;We are going to round estimated row count to 0&quot;);&lt;br/&gt;
            // RESOLVE - should we make sure this number is &amp;gt; 0?&lt;br/&gt;
            cost_result.setEstimatedRowCount(Math.round(estimated_row_count));&lt;br/&gt;
        }&lt;br/&gt;
        finally&lt;/p&gt;

&lt;p&gt;Run the test program after making the changes in BTreeCostController.getScanCost as follows.&lt;br/&gt;
java org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC &amp;gt; dellater.txt&lt;br/&gt;
It will produce a really large dellater.txt. notepad couldn&apos;t open the file because of it&apos;s size. I did grep on the file to look for string &quot;We are going to round estimated row count to 0&quot; and found number of occurences of it. An example of the string were as follows&lt;br/&gt;
./dellater2.txt:51892862:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892866:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892904:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892908:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892946:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892950:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892988:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51892992:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51893030:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51893034:We are going to round estimated row count to 0&lt;br/&gt;
./dellater2.txt:51893072:We are going to round estimated row count to 0&lt;br/&gt;
.....&lt;/p&gt;

&lt;p&gt;I picked the first line from grep output above and used that line number to find the value of the constant in the SELECT query that resulted in estimated row count to be rounded to 0 and found following&lt;br/&gt;
$ head -n 51892862 dellater2.txt | tail -n 10&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.9536743&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
t0.Table3_ID =5189284&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.47683716&lt;br/&gt;
We are going to round estimated row count to 0&lt;/p&gt;

&lt;p&gt;Next, I tried that t0.Table3_ID =5189284 value directly in ij with log query plan on and could see in derby.log that we are doing table scan for the inner(right) resultset. I tried value one higher than the problem ID value and saw that we use index scan for that SELECT query.&lt;br/&gt;
$ java -Dderby.language.logQueryPlan=true -Dij.exceptionTrace=true org.apache.derby.tools.ij&lt;br/&gt;
ij version 10.11&lt;br/&gt;
ij&amp;gt; connect &apos;jdbc:derby:clobtest3&apos;;&lt;br/&gt;
ij&amp;gt; SELECT count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM&lt;br/&gt;
        Table1 T1,&lt;br/&gt;
        Table2 t0&lt;br/&gt;
        WHERE t1.ID = t0.Table&amp;gt; 1_ID and&lt;br/&gt;
                t0.Tabl&amp;gt; e3_ID = 5189284 ;&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.47683716&lt;br/&gt;
We are going to round estimated row count to 0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.47683716&lt;br/&gt;
We are going to round estimated row count to 0&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
1&lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; SELECT count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM&lt;br/&gt;
        Table1 T1,&lt;br/&gt;
        Table2 t0&lt;br/&gt;
        WHERE t1.ID = t0.Table1_ID and&lt;br/&gt;
              t0.Table3_ID = 5189285;&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.9536743&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.9536743&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
1&lt;/p&gt;

&lt;p&gt;1 row selected&lt;/p&gt;


&lt;p&gt;I applied Mike&apos;s 2nd patch which check if estimated row count is less than &amp;lt;.5 and if so, it assigns value 1 to estimated row count. With that patch, I ran the 2 queries again in ij against the database and saw that we are indeed using index scan for both the queries. So, the patch definitely fixed the problem with the repro db I have created.&lt;/p&gt;

&lt;p&gt;The test program takes over 4-5hours to load the data and run 8millions selects.&lt;/p&gt;</comment>
                            <comment id="13755556" author="mikem" created="Sat, 31 Aug 2013 18:11:14 +0100"  >&lt;p&gt;It turns out most of the time in the test is taken in executing the selects.  For a sane classes run I got the following&lt;br/&gt;
times for the load:&lt;br/&gt;
finished creating tables&lt;br/&gt;
Table1 - done inserting data, num rows = 1000000&lt;br/&gt;
Table1 -    inserting data executed in ms: 44513&lt;br/&gt;
Table3 - done inserting data, num rows = 8000000&lt;br/&gt;
Table3 -    inserting data executed in ms: 399121&lt;br/&gt;
Table2 - done inserting data, num rows = 1000000&lt;br/&gt;
Table2 -    inserting data executed in ms: 1272520&lt;/p&gt;


&lt;p&gt;so a total of around 10 minutes to load 1 million + 8 million + 1 million rows.  The load time could likely&lt;br/&gt;
be reduced by first creating the tables with no primary keys, constraints, or indexes and adding them after&lt;br/&gt;
the data has been loaded.  &lt;/p&gt;

&lt;p&gt;I was not running with all the prints, as it is likely that was also slowing down the system.&lt;/p&gt;
</comment>
                            <comment id="13757977" author="mamtas" created="Wed, 4 Sep 2013 18:10:41 +0100"  >&lt;p&gt;I have been working on a junit test for this jira and for some strange reason, the problem does not reproduce yet. The test is based on the stand alone test case. I had made one optimization in the junit test case to create the indexes after the database was loaded and that is when the problem did not reproduce. Since then, I have removed the optimization so now the junit test looks similar to stand alone test case and I have fired that junit run this morning. Will post the results when the test is over. I did want to mention that the data load takes close to 45minutes with the test. Mike mentioned in his case it took only 10 minutes. I am attaching a patch for junit test DERBY_6317_junit_test_v1_diff.txt. May be Mike or some one else can see why the load in my case is taking much longer. This patch is not ready for commit. The patch has some changes to largedata suite, please ignore it. I commented out other largedata tests so I can focus on just my junit repro.&lt;/p&gt;

&lt;p&gt;I am running on Windows 7 machine with IBM jdk 1.6&lt;/p&gt;</comment>
                            <comment id="13758140" author="mikem" created="Wed, 4 Sep 2013 19:34:40 +0100"  >&lt;p&gt;you are right mamta i had not timed the load, just did the printouts above.  I did not notice that the Table2 load&lt;br/&gt;
had a loop of 1mill and an inner loop of 8.  So the num rows printed was wrong, and I missed a decimal point when&lt;br/&gt;
I was adding the time in my head.  The Table2 load took 1272 seconds, more like 20 minutes for it + 10 minutes for Table 3 and 1 minute&lt;br/&gt;
for table 1.  So 34 minutes which is a lot closer to what you  were getting.&lt;/p&gt;</comment>
                            <comment id="13758166" author="mamtas" created="Wed, 4 Sep 2013 19:50:36 +0100"  >&lt;p&gt;Thanks for double checking Mike. &lt;/p&gt;</comment>
                            <comment id="13758169" author="mamtas" created="Wed, 4 Sep 2013 19:53:09 +0100"  >&lt;p&gt;I realized I have not posted the query plans for the index scan vs table scan cases. I will post them in next two comments for easier read.&lt;/p&gt;</comment>
                            <comment id="13758172" author="mamtas" created="Wed, 4 Sep 2013 19:55:01 +0100"  >&lt;p&gt;The following query plan is when we are doing table scan of TABLE1 instead of index scan. Note the value in SELECT for indexed column is 5189284&lt;/p&gt;

&lt;p&gt;Wed Sep 04 11:47:25 PDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 767109), (SESSIONID = 1), SELECT count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM &lt;br/&gt;
	Table1 T1,&lt;br/&gt;
	Table2 t0 &lt;br/&gt;
	WHERE t1.ID = t0.Table1_ID and &lt;br/&gt;
		t0.Table3_ID = 5189284 ******* Project-Restrict ResultSet (7):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 1&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 1.00&lt;br/&gt;
	optimizer estimated cost: 6.33&lt;br/&gt;
Source result set:&lt;br/&gt;
	Scalar Aggregate ResultSet:&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows input = 1&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 0.00&lt;br/&gt;
		optimizer estimated cost: 6.33&lt;br/&gt;
	Index Key Optimization = false&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Project-Restrict ResultSet (6):&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 1&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		restriction = false&lt;br/&gt;
		projection = true&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			restriction time (milliseconds) = 0&lt;br/&gt;
			projection time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 0.00&lt;br/&gt;
			optimizer estimated cost: 6.33&lt;br/&gt;
		Source result set:&lt;br/&gt;
			Nested Loop Join ResultSet:&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen from the left = 1&lt;br/&gt;
			Rows seen from the right = 1&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Rows returned = 1&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 0.00&lt;br/&gt;
				optimizer estimated cost: 6.33&lt;br/&gt;
			Left result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for TABLE2:&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 1&lt;br/&gt;
				Columns accessed from heap = &lt;/p&gt;
{0, 1}
&lt;p&gt;					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 0.00&lt;br/&gt;
					optimizer estimated cost: 6.33&lt;br/&gt;
					Index Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 1&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;					scan information:&lt;br/&gt;
						Bit set of columns fetched=All&lt;br/&gt;
						Number of columns fetched=2&lt;br/&gt;
						Number of deleted rows visited=0&lt;br/&gt;
						Number of pages visited=4&lt;br/&gt;
						Number of rows qualified=1&lt;br/&gt;
						Number of rows visited=2&lt;br/&gt;
						Scan type=btree&lt;br/&gt;
						Tree height=-1&lt;br/&gt;
						start position:&lt;br/&gt;
							&amp;gt;= on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						stop position:&lt;br/&gt;
							&amp;gt; on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						qualifiers:&lt;br/&gt;
							None&lt;br/&gt;
						optimizer estimated row count: 0.00&lt;br/&gt;
						optimizer estimated cost: 6.33&lt;/p&gt;

&lt;p&gt;			Right result set:&lt;br/&gt;
				Table Scan ResultSet for TABLE1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 1&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				Fetch Size = 16&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;				scan information:&lt;br/&gt;
					Bit set of columns fetched=All&lt;br/&gt;
					Number of columns fetched=1&lt;br/&gt;
					Number of pages visited=7300&lt;br/&gt;
					Number of rows qualified=1&lt;br/&gt;
					Number of rows visited=1000000&lt;br/&gt;
					Scan type=heap&lt;br/&gt;
					start position:&lt;br/&gt;
						null&lt;br/&gt;
					stop position:&lt;br/&gt;
						null&lt;br/&gt;
					qualifiers:&lt;br/&gt;
						Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
						Operator: =&lt;br/&gt;
						Ordered nulls: false&lt;br/&gt;
						Unknown return value: false&lt;br/&gt;
						Negate comparison result: false&lt;br/&gt;
					optimizer estimated row count: 0.00&lt;br/&gt;
					optimizer estimated cost: 0.00&lt;/p&gt;</comment>
                            <comment id="13758183" author="mamtas" created="Wed, 4 Sep 2013 19:58:12 +0100"  >&lt;p&gt;The following query plan is when we are doing index scan of TABLE1 which is the correct behavior. Note the value in SELECT for indexed column is 5189285 (just one higher than the 5189284 where we use table scan)&lt;br/&gt;
----------------------------------------------------------------&lt;br/&gt;
Wed Sep 04 11:55:19 PDT 2013:&lt;br/&gt;
Booting Derby version The Apache Software Foundation - Apache Derby - 10.11.0.0 alpha - (1): instance a816c00e-0140-ea54-2a4c-00000022b220 &lt;br/&gt;
on database directory C:\p4clients\svnmain\client3\trunk\systest\del\ClobTest3 with class loader sun.misc.Launcher$AppClassLoader@53745374 &lt;br/&gt;
Loaded from &lt;a href=&quot;file:/C:/p4clients/svnmain/client3/trunk/classes/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;file:/C:/p4clients/svnmain/client3/trunk/classes/&lt;/a&gt;&lt;br/&gt;
java.vendor=IBM Corporation&lt;br/&gt;
java.runtime.version=pwi3260sr14-20130705_01 (SR14)&lt;br/&gt;
java.fullversion=JRE 1.6.0 IBM J9 2.4 Windows 7 x86-32 jvmwi3260sr14-20130704_155156 (JIT enabled, AOT enabled)&lt;br/&gt;
J9VM - 20130704_155156&lt;br/&gt;
JIT  - r9_20130517_38390&lt;br/&gt;
GC   - GA24_Java6_SR14_20130704_1138_B155156&lt;br/&gt;
user.dir=C:\p4clients\svnmain\client3\trunk\systest\del&lt;br/&gt;
os.name=Windows 7&lt;br/&gt;
os.arch=x86&lt;br/&gt;
os.version=6.1 build 7601 Service Pack 1&lt;br/&gt;
derby.system.home=null&lt;br/&gt;
Database Class Loader started - derby.database.classpath=&apos;&apos;&lt;br/&gt;
Wed Sep 04 11:55:24 PDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 767118), (SESSIONID = 1), SELECT count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM &lt;br/&gt;
	Table1 T1,&lt;br/&gt;
	Table2 t0 &lt;br/&gt;
	WHERE t1.ID = t0.Table1_ID and &lt;br/&gt;
		t0.Table3_ID = 5189285 ******* Project-Restrict ResultSet (7):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 1&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
	restriction time (milliseconds) = 0&lt;br/&gt;
	projection time (milliseconds) = 0&lt;br/&gt;
	optimizer estimated row count: 1.00&lt;br/&gt;
	optimizer estimated cost: 12.72&lt;br/&gt;
Source result set:&lt;br/&gt;
	Scalar Aggregate ResultSet:&lt;br/&gt;
	Number of opens = 1&lt;br/&gt;
	Rows input = 1&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		optimizer estimated row count: 1.00&lt;br/&gt;
		optimizer estimated cost: 12.72&lt;br/&gt;
	Index Key Optimization = false&lt;br/&gt;
	Source result set:&lt;br/&gt;
		Project-Restrict ResultSet (6):&lt;br/&gt;
		Number of opens = 1&lt;br/&gt;
		Rows seen = 1&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		restriction = false&lt;br/&gt;
		projection = true&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
			restriction time (milliseconds) = 0&lt;br/&gt;
			projection time (milliseconds) = 0&lt;br/&gt;
			optimizer estimated row count: 1.00&lt;br/&gt;
			optimizer estimated cost: 12.72&lt;br/&gt;
		Source result set:&lt;br/&gt;
			Nested Loop Exists Join ResultSet:&lt;br/&gt;
			Number of opens = 1&lt;br/&gt;
			Rows seen from the left = 1&lt;br/&gt;
			Rows seen from the right = 1&lt;br/&gt;
			Rows filtered = 0&lt;br/&gt;
			Rows returned = 1&lt;br/&gt;
				constructor time (milliseconds) = 0&lt;br/&gt;
				open time (milliseconds) = 0&lt;br/&gt;
				next time (milliseconds) = 0&lt;br/&gt;
				close time (milliseconds) = 0&lt;br/&gt;
				optimizer estimated row count: 1.00&lt;br/&gt;
				optimizer estimated cost: 12.72&lt;br/&gt;
			Left result set:&lt;br/&gt;
				Index Row to Base Row ResultSet for TABLE2:&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 1&lt;br/&gt;
				Columns accessed from heap = &lt;/p&gt;
{0, 1}
&lt;p&gt;					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					optimizer estimated row count: 1.00&lt;br/&gt;
					optimizer estimated cost: 8.01&lt;br/&gt;
					Index Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
					Number of opens = 1&lt;br/&gt;
					Rows seen = 1&lt;br/&gt;
					Rows filtered = 0&lt;br/&gt;
					Fetch Size = 16&lt;br/&gt;
						constructor time (milliseconds) = 0&lt;br/&gt;
						open time (milliseconds) = 0&lt;br/&gt;
						next time (milliseconds) = 0&lt;br/&gt;
						close time (milliseconds) = 0&lt;br/&gt;
						next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;					scan information:&lt;br/&gt;
						Bit set of columns fetched=All&lt;br/&gt;
						Number of columns fetched=2&lt;br/&gt;
						Number of deleted rows visited=0&lt;br/&gt;
						Number of pages visited=4&lt;br/&gt;
						Number of rows qualified=1&lt;br/&gt;
						Number of rows visited=2&lt;br/&gt;
						Scan type=btree&lt;br/&gt;
						Tree height=-1&lt;br/&gt;
						start position:&lt;br/&gt;
							&amp;gt;= on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						stop position:&lt;br/&gt;
							&amp;gt; on first 1 column(s).&lt;br/&gt;
							Ordered null semantics on the following columns: &lt;br/&gt;
							0 &lt;br/&gt;
						qualifiers:&lt;br/&gt;
							None&lt;br/&gt;
						optimizer estimated row count: 1.00&lt;br/&gt;
						optimizer estimated cost: 8.01&lt;/p&gt;

&lt;p&gt;			Right result set:&lt;br/&gt;
				Index Scan ResultSet for TABLE1 using constraint SQL130829215951000 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
				Number of opens = 1&lt;br/&gt;
				Rows seen = 1&lt;br/&gt;
				Rows filtered = 0&lt;br/&gt;
				Fetch Size = 1&lt;br/&gt;
					constructor time (milliseconds) = 0&lt;br/&gt;
					open time (milliseconds) = 0&lt;br/&gt;
					next time (milliseconds) = 0&lt;br/&gt;
					close time (milliseconds) = 0&lt;br/&gt;
					next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;				scan information:&lt;br/&gt;
					Bit set of columns fetched=&lt;/p&gt;
{0}
&lt;p&gt;					Number of columns fetched=1&lt;br/&gt;
					Number of deleted rows visited=0&lt;br/&gt;
					Number of pages visited=3&lt;br/&gt;
					Number of rows qualified=1&lt;br/&gt;
					Number of rows visited=1&lt;br/&gt;
					Scan type=btree&lt;br/&gt;
					Tree height=3&lt;br/&gt;
					start position:&lt;br/&gt;
						&amp;gt;= on first 1 column(s).&lt;br/&gt;
						Ordered null semantics on the following columns: &lt;br/&gt;
						0 &lt;br/&gt;
					stop position:&lt;br/&gt;
						&amp;gt; on first 1 column(s).&lt;br/&gt;
						Ordered null semantics on the following columns: &lt;br/&gt;
						0 &lt;br/&gt;
					qualifiers:&lt;br/&gt;
						None&lt;br/&gt;
					optimizer estimated row count: 1.00&lt;br/&gt;
					optimizer estimated cost: 4.71&lt;/p&gt;
</comment>
                            <comment id="13758192" author="mamtas" created="Wed, 4 Sep 2013 20:01:41 +0100"  >&lt;p&gt;Wanted to point out that with my repro db, out of the 8 million rows, the first row that picks table scan in following query is 5189284.&lt;br/&gt;
SELECT count FROM&lt;br/&gt;
Table1 T1,&lt;br/&gt;
Table2 t0&lt;br/&gt;
WHERE t1.ID = t0.Table1_ID and&lt;br/&gt;
t0.Table3_ID = 5189284&lt;/p&gt;</comment>
                            <comment id="13758208" author="mikem" created="Wed, 4 Sep 2013 20:10:29 +0100"  >&lt;p&gt;do you have any idea how many of the values in your repro db caused issue to reproduce?  &lt;/p&gt;

&lt;p&gt;Do you see any patttern to the estimated row count?  Maybe just grepping for the key line and where&lt;br/&gt;
estimate row count is 0.* would be interesting.  Obviously visually seeing a pattern in 5 million&lt;br/&gt;
rows is hard.  &lt;/p&gt;</comment>
                            <comment id="13758369" author="mamtas" created="Wed, 4 Sep 2013 22:25:06 +0100"  >&lt;p&gt;I believe there are atleast 212082 rows which cause us to table scan rather than index scan.&lt;/p&gt;

&lt;p&gt;Just some additional info on the output of the stand alone repro&lt;br/&gt;
The output from my repro stand alone case is extremely large(3.17GB) so I did a grep on it for the problem case identification string &quot;We are going to round estimated row count to 0&quot;. I redirected the grep output a file and that file is also pretty big(29.1MB). For a typical wrong query plan case, we print something like following&lt;br/&gt;
t0.Table3_ID =6035610&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.47683716&lt;br/&gt;
We are going to round estimated row count to 0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 8000005.0&lt;br/&gt;
In engine estimated row count is 0.47683716&lt;br/&gt;
We are going to round estimated row count to 0&lt;br/&gt;
In engine estimated row count is 1000005.0&lt;/p&gt;

&lt;p&gt;ie &quot;We are going to round estimated row count to 0&quot; gets printed twice for every SELECT which results in table scan rather than index scan.&lt;/p&gt;
</comment>
                            <comment id="13759809" author="mamtas" created="Fri, 6 Sep 2013 04:07:22 +0100"  >&lt;p&gt;Attaching patch DERBY_6317_junit_test_v2_diff.txt which has junit reproducible test for this jira. There are handful of fixtures. The longest running fixture is testDERBY_6317 since it does select on each of the 8 million rows individually and checks if we are using index scan for getting the row. Without Mike&apos;s patch, this test fixture can take about 6hrs. This test fixture will fail along with couple other test fixtures(testDERBY_6317_value1, testDERBY_6317_value2, testDERBY_6317_value3) without Mike&apos;s changes because they will detect that we are using table scan. Once Mike&apos;s patch is applied, all of the test fixtures should pass. I am running the junit test right now with Mike&apos;s changes and the test has not finished yet after 9 hours of run. I will post a comment once this test run is over. Because of the length of the time the testDERBY_6317 fixture takes, we obviously won&apos;t want this to be running as part of junit complete suite. Even without this test fixture, the test can take over an hr because it has to load 3 tables with 1million, 8million and 8million rows respectively and these tables have indexes defined on them. The indexes need to be defined before the data load in order to reproduce the problem.&lt;/p&gt;</comment>
                            <comment id="13759848" author="mamtas" created="Fri, 6 Sep 2013 05:20:25 +0100"  >&lt;p&gt;The new junit test from the earlier patch finished successfully with Mike&apos;s patch. It took close to 10hrs to finish.&lt;/p&gt;</comment>
                            <comment id="13759849" author="mikem" created="Fri, 6 Sep 2013 05:25:10 +0100"  >&lt;p&gt;It should be noted that it makes sense that test took longer with the fix.  Without the fix the loop trying to run 8 million selects will fail&lt;br/&gt;
and stop when it hits the first problem, at around row 5 million.  With the fix it has to run 3 million more selects.&lt;/p&gt;</comment>
                            <comment id="13760324" author="mamtas" created="Fri, 6 Sep 2013 17:24:25 +0100"  >&lt;p&gt;Uploading a new patch for the junit test. I accidentally uploaded older version of the junit test with the previous patch.&lt;/p&gt;</comment>
                            <comment id="13760375" author="mamtas" created="Fri, 6 Sep 2013 18:19:06 +0100"  >&lt;p&gt;Attaching another patch DERBY_6317_junit_test_v4_diff.txt which now has 3 test fixtures testing for values in SELECT which will cause Derby to use table scan without &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; fix. It also has 3 test fixtures testing for values in SELECT which will cause Derby to use index scan even without &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; fix. And lastly, it has the very time consuming test fixture(testDERBY_6317) which does SELECT individually for each of the 8 million rows. This test fixture passes for all 8 million rows with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; fix but it stops at row 5189284 without &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; fix because that&apos;s the first row that does a table scan rather than an index scan.&lt;/p&gt;</comment>
                            <comment id="13762432" author="jira-bot" created="Mon, 9 Sep 2013 23:59:52 +0100"  >&lt;p&gt;Commit 1521310 from mikem@apache.org in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1521310&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1521310&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0 &lt;/p&gt;

&lt;p&gt;The Optimizer estimates do not handle well 0 row counts coming out of store.&lt;br/&gt;
These estimates end up getting multiplied by other estimates and the resulting&lt;br/&gt;
0 costs caused the incorrect plan to be picked in the repro included with&lt;br/&gt;
this fix.  This fix changes store cost to always return at least a minimum&lt;br/&gt;
of one row when asked to estimate the number of rows in an exact range of&lt;br/&gt;
keys from an index.  This minimum is consistent with the optimizer assumption&lt;br/&gt;
that an exact key match on a unique index will also return 1 row.&lt;/p&gt;

&lt;p&gt;Thanks to Brett Bergquist for debugging and suggesting a fix and to mamta &lt;br/&gt;
satoor for providing a reproducible test case for the bug.&lt;/p&gt;</comment>
                            <comment id="13763097" author="jira-bot" created="Tue, 10 Sep 2013 16:03:54 +0100"  >&lt;p&gt;Commit 1521517 from mikem@apache.org in branch &apos;code/branches/10.10&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1521517&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1521517&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&lt;/p&gt;

&lt;p&gt;backported change #1521310 from trunk to 10.10 branch.&lt;/p&gt;

&lt;p&gt;The Optimizer estimates do not handle well 0 row counts coming out of store.&lt;br/&gt;
These estimates end up getting multiplied by other estimates and the resulting&lt;br/&gt;
0 costs caused the incorrect plan to be picked in the repro included with&lt;br/&gt;
this fix.  This fix changes store cost to always return at least a minimum&lt;br/&gt;
of one row when asked to estimate the number of rows in an exact range of&lt;br/&gt;
keys from an index.  This minimum is consistent with the optimizer assumption&lt;br/&gt;
that an exact key match on a unique index will also return 1 row.&lt;/p&gt;

&lt;p&gt;Thanks to Brett Bergquist for debugging and suggesting a fix and to mamta&lt;br/&gt;
satoor for providing a reproducible test case for the bug.&lt;/p&gt;</comment>
                            <comment id="13764479" author="jira-bot" created="Wed, 11 Sep 2013 17:49:24 +0100"  >&lt;p&gt;Commit 1521931 from mikem@apache.org in branch &apos;code/branches/10.9&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1521931&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1521931&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&lt;/p&gt;

&lt;p&gt;backported change #1521310 from trunk to 10.9 branch.&lt;/p&gt;

&lt;p&gt;The Optimizer estimates do not handle well 0 row counts coming out of store.&lt;br/&gt;
These estimates end up getting multiplied by other estimates and the resulting&lt;br/&gt;
0 costs caused the incorrect plan to be picked in the repro included with&lt;br/&gt;
this fix.  This fix changes store cost to always return at least a minimum&lt;br/&gt;
of one row when asked to estimate the number of rows in an exact range of&lt;br/&gt;
keys from an index.  This minimum is consistent with the optimizer assumption&lt;br/&gt;
that an exact key match on a unique index will also return 1 row.&lt;/p&gt;

&lt;p&gt;Thanks to Brett Bergquist for debugging and suggesting a fix and to mamta&lt;br/&gt;
satoor for providing a reproducible test case for the bug.&lt;/p&gt;</comment>
                            <comment id="13764898" author="jira-bot" created="Wed, 11 Sep 2013 23:46:47 +0100"  >&lt;p&gt;Commit 1522084 from mikem@apache.org in branch &apos;code/branches/10.8&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1522084&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1522084&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6317&quot; title=&quot;Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6317&quot;&gt;&lt;del&gt;DERBY-6317&lt;/del&gt;&lt;/a&gt; Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0&lt;/p&gt;

&lt;p&gt;backported change #1521310 from trunk to 10.8 branch.&lt;/p&gt;

&lt;p&gt;The Optimizer estimates do not handle well 0 row counts coming out of store.&lt;br/&gt;
These estimates end up getting multiplied by other estimates and the resulting&lt;br/&gt;
0 costs caused the incorrect plan to be picked in the repro included with&lt;br/&gt;
this fix.  This fix changes store cost to always return at least a minimum&lt;br/&gt;
of one row when asked to estimate the number of rows in an exact range of&lt;br/&gt;
keys from an index.  This minimum is consistent with the optimizer assumption&lt;br/&gt;
that an exact key match on a unique index will also return 1 row.&lt;/p&gt;

&lt;p&gt;Thanks to Brett Bergquist for debugging and suggesting a fix and to mamta&lt;br/&gt;
satoor for providing a reproducible test case for the bug.&lt;/p&gt;</comment>
                            <comment id="13770951" author="mikem" created="Wed, 18 Sep 2013 17:48:04 +0100"  >&lt;p&gt;Fixed in trunk, backported to 10.10, 10.9, 10.8.  Fix is applicable to previous releases and can be backported if anyone is interested.  I don&apos;t plan on backporting it any further right now.&lt;/p&gt;</comment>
                            <comment id="14284716" author="myrna" created="Wed, 21 Jan 2015 00:22:55 +0000"  >&lt;p&gt;bulk change to close all issues resolved but not closed and not changed since June 1, 2014.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12601405" name="DERBY_6317_junit_test_v1_diff.txt" size="8537" author="mamtas" created="Wed, 4 Sep 2013 18:10:41 +0100"/>
                            <attachment id="12601755" name="DERBY_6317_junit_test_v2_diff.txt" size="19008" author="mamtas" created="Fri, 6 Sep 2013 04:07:22 +0100"/>
                            <attachment id="12601844" name="DERBY_6317_junit_test_v3_diff.txt" size="19011" author="mamtas" created="Fri, 6 Sep 2013 17:24:25 +0100"/>
                            <attachment id="12601851" name="DERBY_6317_junit_test_v4_diff.txt" size="19489" author="mamtas" created="Fri, 6 Sep 2013 18:19:06 +0100"/>
                            <attachment id="12600911" name="DERBY_6317_temp_changes_for_debugging.txt" size="1947" author="mamtas" created="Sat, 31 Aug 2013 02:56:19 +0100"/>
                            <attachment id="12600291" name="derby6317.diff" size="1482" author="mikem" created="Wed, 28 Aug 2013 00:43:48 +0100"/>
                            <attachment id="12600424" name="derby6317_2.diff" size="1762" author="mikem" created="Wed, 28 Aug 2013 19:07:10 +0100"/>
                            <attachment id="12600912" name="testRepro_v1.txt" size="4024" author="mamtas" created="Sat, 31 Aug 2013 02:56:19 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    <customfieldvalue key="10421"><![CDATA[Seen in production]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 27 Aug 2013 16:27:49 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>345581</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hzhfr3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>345882</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10051"><![CDATA[Urgent]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>