<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:41:36 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3603/DERBY-3603.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3603] &apos;IN&apos; clause ignores valid results, incorrect qualifier handling suspected</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3603</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Derbys&apos; &apos;IN&apos; clause is returning different results depending on which side of a joined table&lt;br/&gt;
I am doing my &apos;IN&apos; comparison against. This only occurs when the number of items within the &apos;IN&apos; clause is greater then 1.&lt;/p&gt;

&lt;p&gt;This behaviour was also confirmed by Bryan Pendleton in this thread:&lt;br/&gt;
&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/db-derby-user/200804.mbox/%3c47FA5974.2060705@amberpoint.com%3e&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/db-derby-user/200804.mbox/%3c47FA5974.2060705@amberpoint.com%3e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Using the test database attatched the following 2 queries produce the issue:&lt;/p&gt;

&lt;p&gt;ij&amp;gt;  select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM spike.accounts account, spike.admin_units admin_unit,&lt;br/&gt;
    spike.bookings booking&lt;br/&gt;
    WHERE booking.child_id = 2 AND&lt;br/&gt;
    admin_unit.admin_unit_id IN (1,21) AND&lt;br/&gt;
    booking.booking_date_time_out &amp;gt;= 20080331000000 AND&lt;br/&gt;
    booking.booking_date_time_in &amp;lt;= 20080406235900 AND&lt;br/&gt;
    account.account_id = booking.account_id AND&lt;br/&gt;
    admin_unit.admin_unit_id = account.admin_unit_id;&lt;br/&gt;
1          &lt;br/&gt;
-----------&lt;br/&gt;
2          &lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM spike.accounts account, spike.admin_units admin_unit,&lt;br/&gt;
    spike.bookings booking&lt;br/&gt;
    WHERE booking.child_id = 2 AND&lt;br/&gt;
    account.admin_unit_id IN (1,21) AND&lt;br/&gt;
    booking.booking_date_time_out &amp;gt;= 20080331000000 AND&lt;br/&gt;
    booking.booking_date_time_in &amp;lt;= 20080406235900 AND&lt;br/&gt;
    account.account_id = booking.account_id AND&lt;br/&gt;
    admin_unit.admin_unit_id = account.admin_unit_id;&lt;br/&gt;
1          &lt;br/&gt;
-----------&lt;br/&gt;
3          &lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; &lt;/p&gt;

&lt;p&gt;The only difference between the 2 statements is which side of a join the &apos;IN&apos; clause is matched against.&lt;/p&gt;

&lt;p&gt;Bryan performed some initial testing and stated the following:&lt;/p&gt;

&lt;p&gt;--------------------- SNIP ------------------------&lt;/p&gt;

&lt;p&gt;Interestingly, although the actual results do NOT contain any values&lt;br/&gt;
for admin_unit_id = 21, if I change the query to:&lt;/p&gt;

&lt;p&gt;    admin_unit.admin_unit_id IN (1)&lt;br/&gt;
or&lt;br/&gt;
    account.admin_unit_id IN (1)&lt;/p&gt;

&lt;p&gt;then the problem disappears &amp;#8211; I get 3 rows for both queries.&lt;/p&gt;

&lt;p&gt;I also ran query plans for both the queries (in the IN (1,21) case)&lt;br/&gt;
and have pasted the (simplified) query plans at the end of this message.&lt;/p&gt;

&lt;p&gt;I notice that in the case where the query gives 2 rows, which is&lt;br/&gt;
when we specify admin_unit.admin_unit_id in (1,21), the admin_unit_id&lt;br/&gt;
index scan output in the query plan contains:&lt;/p&gt;

&lt;p&gt;           qualifiers:&lt;br/&gt;
Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
Operator: =&lt;br/&gt;
Ordered nulls: false&lt;br/&gt;
Unknown return value: false&lt;br/&gt;
Negate comparison result: false&lt;/p&gt;

&lt;p&gt;However, in the case where the query gives 3 rows, which is&lt;br/&gt;
when we specify account.admin_unit_id in (1,21), the admin_unit_id&lt;br/&gt;
index scan output in the query plan contains:&lt;/p&gt;

&lt;p&gt;           qualifiers:&lt;br/&gt;
None&lt;/p&gt;

&lt;p&gt;I think it is the presence/absence of this qualifier on the query&lt;br/&gt;
scan which is causing the different results in the query, as in&lt;br/&gt;
the first case we see:&lt;/p&gt;

&lt;p&gt;           Number of rows qualified=2&lt;br/&gt;
           Number of rows visited=3&lt;/p&gt;

&lt;p&gt;but in the second case we see:&lt;/p&gt;

&lt;p&gt;           Number of rows qualified=3&lt;br/&gt;
           Number of rows visited=3&lt;/p&gt;

&lt;p&gt;I definitely don&apos;t have any explanation for why you are getting&lt;br/&gt;
this odd behavior; it certainly seems like a bug to me.&lt;/p&gt;

&lt;p&gt;-------------END SNIP -----------------------&lt;/p&gt;</description>
                <environment></environment>
        <key id="12393362">DERBY-3603</key>
            <summary>&apos;IN&apos; clause ignores valid results, incorrect qualifier handling suspected</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="bryanpendleton">Bryan Pendleton</assignee>
                                    <reporter username="eldavio">David Butterworth</reporter>
                        <labels>
                    </labels>
                <created>Tue, 8 Apr 2008 03:14:51 +0100</created>
                <updated>Fri, 21 Jan 2011 17:51:51 +0000</updated>
                            <resolved>Wed, 16 Apr 2008 17:05:48 +0100</resolved>
                                    <version>10.3.2.1</version>
                    <version>10.4.1.3</version>
                                    <fixVersion>10.3.3.0</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12586816" author="thomanie" created="Tue, 8 Apr 2008 15:29:12 +0100"  >&lt;p&gt;This is a regression introduced between 10.3.1.4 and 10.3.2.1.&lt;/p&gt;

&lt;p&gt;I ran the queries on 10.3.1.4 with the provided database snapshot, and they both return 3 rows on 10.3.1.4, but 2 rows for 10.3.2.1.&lt;/p&gt;

&lt;p&gt;&amp;#8212; &lt;span class=&quot;error&quot;&gt;&amp;#91;10.3.1.4&amp;#93;&lt;/span&gt; snip snip &amp;#8212;&lt;br/&gt;
ij&amp;gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM spike.accounts account, spike.admin_units admin_unit,&lt;br/&gt;
    spike.bookings booking&lt;br/&gt;
    WHERE booking.child_id = 2 AND&lt;br/&gt;
    admin_unit.admin_unit_id IN (1,21) AND&lt;br/&gt;
    booking.booking_date_time_out &amp;gt;= 20080331000000 AND&lt;br/&gt;
    booking.booking_date_time_in &amp;lt;= 20080406235900 AND&lt;br/&gt;
    account.account_id = booking.account_id AND&lt;br/&gt;
    admin_unit.admin_unit_id = account.admin_unit_id;&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
3&lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM spike.accounts account, spike.admin_units admin_unit,&lt;br/&gt;
    spike.bookings booking&lt;br/&gt;
    WHERE booking.child_id = 2 AND&lt;br/&gt;
    account.admin_unit_id IN (1,21) AND&lt;br/&gt;
    booking.booking_date_time_out &amp;gt;= 20080331000000 AND&lt;br/&gt;
    booking.booking_date_time_in &amp;lt;= 20080406235900 AND&lt;br/&gt;
    account.account_id = booking.account_id AND&lt;br/&gt;
    admin_unit.admin_unit_id = account.admin_unit_id;&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
3&lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
&amp;#8212; snip snip &amp;#8212;&lt;/p&gt;

&lt;p&gt;Hopefully someone with more historical insight may know what issue could have caused this sideeffect?&lt;/p&gt;</comment>
                            <comment id="12586850" author="army" created="Tue, 8 Apr 2008 16:35:11 +0100"  >&lt;p&gt;&amp;gt; This is a regression introduced between 10.3.1.4 and 10.3.2.1.&lt;/p&gt;

&lt;p&gt;I wonder if this was caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt;, which was an IN list change that went into 10.3.2.1 (and 10.4) but was not in 10.3.1.4?  I don&apos;t have a lot of time on my hands right now, but perhaps I can investigate later this evening (PST).  That said, if anyone else has more cycles to investigate, that&apos;d be great....&lt;/p&gt;</comment>
                            <comment id="12586863" author="kmarsden" created="Tue, 8 Apr 2008 17:00:09 +0100"  >&lt;p&gt;Unchecking Existing Application Impact, because that means the solution will impact existing applications.&lt;/p&gt;</comment>
                            <comment id="12586916" author="kmarsden" created="Tue, 8 Apr 2008 19:09:44 +0100"  >&lt;p&gt;I verified on the 10.3 branch that this was indeed related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; (svn 574730).  Prior to that change, both queries return &quot;3&quot;.&lt;/p&gt;</comment>
                            <comment id="12587030" author="bryanpendleton" created="Wed, 9 Apr 2008 02:48:13 +0100"  >&lt;p&gt;Just for completeness, I repeated Kathey&apos;s experiment on the trunk;&lt;br/&gt;
I backed out the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; change and the query then returns 3 rows.&lt;br/&gt;
So that&apos;s more evidence that &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt;&apos;s change is relevant, but I&apos;m&lt;br/&gt;
afraid I don&apos;t have any theories to contribute about why that is.&lt;/p&gt;

&lt;p&gt;I do notice that in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt;, the query in question has two conditions&lt;br/&gt;
on the same column, where one is clearly &quot;stronger&quot; than the other:&lt;/p&gt;

&lt;p&gt;   where mytable.id &amp;lt; 100&lt;br/&gt;
   and mytable.id in ( 2, 15, 19, 20, 21, 48, 49 );&lt;/p&gt;

&lt;p&gt;However, in this issue, the query in question has two conditions on the&lt;br/&gt;
same column, where both conditions should (apparently) be of the same&lt;br/&gt;
&quot;strength&quot;, since both are (according to the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; changes) to be&lt;br/&gt;
treated as equality:&lt;/p&gt;

&lt;p&gt;   WHERE   admin_unit.admin_unit_id IN (1,21) AND&lt;br/&gt;
      admin_unit.admin_unit_id = account.admin_unit_id; &lt;/p&gt;

&lt;p&gt;This similarity in query structure appears to explain why the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
changes are relevant.&lt;/p&gt;
</comment>
                            <comment id="12587138" author="thomanie" created="Wed, 9 Apr 2008 11:54:39 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; adds a check for &quot;otherPred.isInListProbePredicate()&quot;. This again checks andNode.leftOperand.isInListProbePredicate().&lt;br/&gt;
It is a possibility that in this case we neglect that there is a equivalent rightOperand (it&apos;s not simply a true as might be expected) - but I haven&apos;t verified this yet.&lt;/p&gt;

&lt;p&gt;The idea is that certain ordering of the elements effectively place the join on either the left or right side, causing it to be incorrectly evaluated if it ends up on the wrong side - which ever side that may be.&lt;/p&gt;</comment>
                            <comment id="12587193" author="thomanie" created="Wed, 9 Apr 2008 14:56:48 +0100"  >&lt;p&gt;Ran the queries through the debugger to see if there were any obvious errors.&lt;/p&gt;

&lt;p&gt;The only obvious difference I see is that the 2-row result query (S2), enters the procedure changed by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; a total of 4 times during optimization, while the 3-row result query (S3) only enters a single time. The callstacks are identical for the S2 and S3 queries in all 5 invocations. This could mean part of the IN list is optimized away in S2. If one optimizer path in S2 does not take all rows into consideration it will probably be a lot cheaper, and will be used, resulting in an incomplete result.&lt;/p&gt;</comment>
                            <comment id="12587196" author="bryanpendleton" created="Wed, 9 Apr 2008 15:00:11 +0100"  >&lt;p&gt;&amp;gt; the join on either the left or right side, causing it to be incorrectly evaluated if it ends up on the wrong side&lt;/p&gt;

&lt;p&gt;That&apos;s a very intriguing theory, seems quite plausible, and worth following up. Interesting!&lt;/p&gt;

&lt;p&gt;The other thing I was thinking about is that if I change the query to just IN (1) rather&lt;br/&gt;
than IN (1,21), then the problem does not occur. So I was wondering if the problem&lt;br/&gt;
might be that Predicate.java is now comparing the two predicates as &lt;b&gt;exactly&lt;/b&gt; equal,&lt;br/&gt;
rather than just &quot;equal enough for sorting during optimization&quot;, and hence was seeing&lt;br/&gt;
the IN (1,21) predicate, at some point, as being redundant with the join criterion and&lt;br/&gt;
was optimizing it entirely away.&lt;/p&gt;

&lt;p&gt;Normally, erroneously optimizing away an entire predicate would cause us to get&lt;br/&gt;
more results, not fewer, but in this case the IN (1,21) predicate is effectively an &quot;OR&quot;&lt;br/&gt;
clause and so if we lost it, or maybe lost one &quot;branch&quot; of it, the result might have&lt;br/&gt;
fewer rows than we expected.&lt;/p&gt;

&lt;p&gt;However, I tried breaking the &quot;bad&quot; query (the one that returns 2 rows) into 2 queries, &lt;br/&gt;
one with IN (1) and one with IN (21), and got the following results:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;query stating IN (1): count = 3&lt;/li&gt;
	&lt;li&gt;query stating IN (21): count = 0&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So rows with admin_unit_id = 21 don&apos;t appear to be relevant to the actual results of&lt;br/&gt;
this query. I think that probably means this theory is not worth pursuing, but I&lt;br/&gt;
figured I&apos;d post it anyway in case it was useful to others.&lt;/p&gt;</comment>
                            <comment id="12587239" author="army" created="Wed, 9 Apr 2008 16:37:22 +0100"  >&lt;p&gt;Thanks for the investigation, Bryan and Thomas!  I was hoping to look more into this last night but was hit by a freak migraine that knocked me out early.  It&apos;s great to see that some work is still happening, though.&lt;/p&gt;

&lt;p&gt;bryan&amp;gt; The other thing I was thinking about is that if I change the query to just IN (1) rather&lt;br/&gt;
bryan&amp;gt; than IN (1,21), then the problem does not occur. &lt;/p&gt;

&lt;p&gt;Just a quick note that when the IN list only has a single value, it is transformed into a normal equality predicate.  See InListOperatorNode.preprocess(...).  So in that case IN-list &quot;multi-probing&quot; processing, which appears to be where the underlying bug resides, does not come into play.  That could be why things work correctly in that case...&lt;/p&gt;

&lt;p&gt;thomas&amp;gt; It is a possibility that in this case we neglect that there is a equivalent rightOperand&lt;br/&gt;
thomas&amp;gt; (it&apos;s not simply a true as might be expected)&lt;/p&gt;

&lt;p&gt;Without having done any tracing myself, I agree with both of you: this seems worth pursuing...&lt;/p&gt;</comment>
                            <comment id="12587243" author="kmarsden" created="Wed, 9 Apr 2008 16:45:04 +0100"  >&lt;p&gt;Attaching jarred up db for easier access.&lt;/p&gt;</comment>
                            <comment id="12587894" author="thomanie" created="Fri, 11 Apr 2008 10:17:05 +0100"  >&lt;p&gt;Looking at the queryplans I see something quite interesting.&lt;/p&gt;

&lt;p&gt;Both queries S2 and S3 end up with the same query plan. The top looking like this:&lt;/p&gt;

&lt;p&gt;                              Scalar&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;                                 PRN&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;                     NestedLoop ExistsJoin&lt;br/&gt;
                              /                     \&lt;br/&gt;
NestedLoopExistsJoin        IndexScanResultSet&lt;br/&gt;
   /         \                                          |&lt;br/&gt;
...           ...                                      ...&lt;/p&gt;

&lt;p&gt;The interesting stuff happens in the lower, right-hand IndexScanResultSet (let&apos;s call it ISR1)&lt;/p&gt;

&lt;p&gt;In the correct 3-row query S3, ISR1 sees 3 rows and qualifies 3 rows.&lt;br/&gt;
In the incorrect 2-row query S2, ISR1 seens 3 rows, but only qualifies 2 of them.&lt;/p&gt;

&lt;p&gt;So for S2, this becomes&lt;br/&gt;
                              Scalar&lt;br/&gt;
                                 (&quot;2&quot;)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;                                 PRN&lt;br/&gt;
                               (2 rows)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;                     NestedLoop ExistsJoin&lt;br/&gt;
                    (3 rows L, 2 rows R)&lt;br/&gt;
                              /                     \&lt;br/&gt;
NestedLoopExistsJoin        IndexScanResultSet&lt;br/&gt;
(3 rows L, 3 rows R)             (sees 3 rows, qualifies 2 rows)&lt;br/&gt;
   /         \                                          |&lt;br/&gt;
...           ...                                      ...&lt;/p&gt;

&lt;p&gt;The query plan for both S2 and S3 state that ISR1 is an&lt;br/&gt;
&quot;Index Scan ResultSet for ADMIN_UNITS using constraint ADMIN_UNIT_ID_PK at read committed isolation level using share row locking chosen by the optimizer&quot;.&lt;/p&gt;

&lt;p&gt;Next task would be to find out why ISR1 rejects/discards the third row in S2, and not in S3.&lt;/p&gt;</comment>
                            <comment id="12587919" author="thomanie" created="Fri, 11 Apr 2008 11:41:28 +0100"  >&lt;p&gt;Seems my comment formatting was messed up - doesn&apos;t really matter &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In the debugger I can see that the problem is actually located in the uppermost NestedLoopExistsJoin of the queryplan (which really is a NestedLoopJoinResultSet), having its oneRowRightSide incorrectly set to true. We are looking for the set (1,21), so the right hand side should not have a single result row in this particular case. Changing this to false in the debugger cause the query to return the correct 3 rows for S2.&lt;/p&gt;

&lt;p&gt;Next question should then be - why was oneRowRightSide incorrectly set to true?&lt;/p&gt;
</comment>
                            <comment id="12587926" author="thomanie" created="Fri, 11 Apr 2008 12:06:30 +0100"  >&lt;p&gt;oneRowRightSide is set during code generation for NestedLoopJoinResultSet.&lt;/p&gt;

&lt;p&gt;This happens in JoinNode.generateCore(), which ends up with the following callstack:&lt;br/&gt;
  org.apache.derby.impl.sql.compile.FromBaseTable.isOneRowResultSet(FromBaseTable.java:4405)&lt;br/&gt;
  org.apache.derby.impl.sql.compile.FromBaseTable.isOneRowResultSet(FromBaseTable.java:3825)&lt;br/&gt;
  org.apache.derby.impl.sql.compile.IndexToBaseRowNode.isOneRowResultSet(IndexToBaseRowNode.java:316)&lt;br/&gt;
  org.apache.derby.impl.sql.compile.SingleChildResultSetNode.isOneRowResultSet(SingleChildResultSetNode.java:531)&lt;br/&gt;
  org.apache.derby.impl.sql.compile.JoinNode.oneRowRightSide(JoinNode.java:1691)&lt;br/&gt;
  org.apache.derby.impl.sql.compile.JoinNode.getJoinArguments(JoinNode.java:1639)&lt;br/&gt;
  org.apache.derby.impl.sql.compile.JoinNode.generateCore(JoinNode.java:1555)&lt;br/&gt;
  ...&lt;/p&gt;

&lt;p&gt;At this point both the restrictionList and predicateList only have a single entry, forcing us to return true.&lt;br/&gt;
Seems we missed a predicate somewhere along the path...&lt;/p&gt;</comment>
                            <comment id="12588035" author="army" created="Fri, 11 Apr 2008 18:16:24 +0100"  >&lt;p&gt;The fact that &quot;oneRowRightSide&quot; is true for the NestedLoop join does indeed appear to be important here. Good find, Thomas!  With that in mind I did some tracing of the execution path.  My findings are below.&lt;/p&gt;

&lt;p&gt;The query I used for tracing is as follows:&lt;/p&gt;

&lt;p&gt;  select account.admin_unit_id, account.account_id,&lt;br/&gt;
    booking.booking_id, cast (admin_unit.admin_unit_name as varchar(30))&lt;br/&gt;
  from spike.accounts account, spike.bookings booking,&lt;br/&gt;
  spike.admin_units admin_unit&lt;br/&gt;
  where account.account_id = booking.account_id&lt;br/&gt;
    and admin_unit.admin_unit_id = account.admin_unit_id&lt;br/&gt;
    and admin_unit.admin_unit_id in (1, 21)&lt;br/&gt;
    and booking.child_id = 2;&lt;/p&gt;

&lt;p&gt;When I run this query the execution plan shows a join order of:&lt;/p&gt;

&lt;p&gt;  (ACCOUNTS x BOOKINGS) x ADMIN_UNITS&lt;/p&gt;

&lt;p&gt;That is, we join ACCOUNTS and BOOKINGS to get a row R, then for each row R from that join, we join it (R) with a row from ADMIN_UNITS.  Due to the presence of the IN list the optimizer chooses to do multi-probing on ADMIN_UNITS, which means the probe predicate that represents &quot;admin_unit.admin_unit_id IN (1, 21)&quot; becomes the start and stop key.  Since we only allow a single start/stop key for any column, the join predicate between ACCOUNTS and ADMIN_UNITS is relegated to being a store qualifier.  This is notable for two reasons: 1) this explains the additional qualifier seen by Bryan in the query plan, and 2) as seen below, this qualifier is what causes the &quot;oneRowRightSide&quot; variable to get set to TRUE for ADMIN_UNITS.&lt;/p&gt;

&lt;p&gt;Also note: before the change for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; the optimizer always sorted the join predicate as &quot;stronger&quot; than the probe predicate, and thus always chose the join predicate as the start/stop key.  That in turn meant that the probe predicate, which can only be used for probing if it is the start/stop key, was &quot;reverted&quot; back to a normal IN list qualifier.  So the problem described below did not show up.  But with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3061&quot; title=&quot;Wrong results from query with two conjuncts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3061&quot;&gt;&lt;del&gt;DERBY-3061&lt;/del&gt;&lt;/a&gt; the probe predicate and the join predicate have the same &quot;strength&quot; and thus the optimizer is free to use either one as the start/stop key. In this example it chooses the probe predicate.&lt;/p&gt;

&lt;p&gt;All of that said, let&apos;s take a step back and note that the join between ACCOUNTS and BOOKINGS returns three rows:&lt;/p&gt;

&lt;p&gt;select account.admin_unit_id, account.account_id, booking.booking_id&lt;br/&gt;
 from spike.accounts account, spike.bookings booking&lt;br/&gt;
 where account.account_id = booking.account_id&lt;br/&gt;
 and booking.child_id = 2;&lt;/p&gt;

&lt;p&gt;ADMIN_UNIT&amp;amp;|ACCOUNT_ID |BOOKING_ID&lt;br/&gt;
-----------------------------------&lt;br/&gt;
1          |10         |1&lt;br/&gt;
1          |10         |3&lt;br/&gt;
1          |10         |4&lt;/p&gt;

&lt;p&gt;So now, for &lt;b&gt;each&lt;/b&gt; of the above three rows we want to fetch the matching row from ADMIN_UNITS.  So far so good.&lt;/p&gt;

&lt;p&gt;The &quot;oneRowRightSide&quot; variable that Thomas mentioned comes into play because the optimizer thinks that for every outer row, i.e. for each of the three rows shown above, we will have at MOST one matching row from ADMIN_UNITS.  At first I thought this was incorrect--but upon further inspection it turns out be true.  The optimizer deduced this because the predicate refers to a primary key column, which has to be unique. So when we try to fetch a row such that the ADMIN_UNIT_ID column of ADMIN_UNITS equals some value, we will get at most one row back.  And since we have the join predicate as a store qualifier (mentioned above), we know that we &lt;em&gt;will&lt;/em&gt; in fact be trying &quot;to get a row such that the ADMIN_UNIT_ID column of ADMIN_UNITS equals some value&quot;, where &quot;some value&quot; will be the ADMIN_UNIT_ID column from the intermediate join table shown above. (Note: the intermediate join table doesn&apos;t actually exist, it&apos;s just shown as such for discussion).&lt;/p&gt;

&lt;p&gt;So at this point things are still working as expected.  We&apos;ll take the first row from the intermediate join, i.e. &quot;(1, 10, 1)&quot;, and we&apos;ll do two things.  First we&apos;ll get the &quot;next&quot; probe value in the list of values.  Since the probe list is &quot;(1, 21)&quot;, the next value is &quot;1&quot;.  Second, we will see if there is a row in ADMIN_UNITS such that: &lt;/p&gt;

&lt;p&gt;  a) the ADMIN_UNIT_ID column of the row equals the current probe&lt;br/&gt;
     value, which is &quot;1&quot;, AND&lt;/p&gt;

&lt;p&gt;  b) the ADMIN_UNIT_ID column of the row equals the ADMIN_UNIT_ID of&lt;br/&gt;
     the outer row, which is &quot;(1, 10, 1)&quot;.&lt;/p&gt;

&lt;p&gt;Since both of these conditions are true, we&apos;ll return the first row as expected.  So our result at this point is:&lt;/p&gt;

&lt;p&gt;ADMIN_UNIT&amp;amp;|ACCOUNT_ID |BOOKING_ID&lt;br/&gt;
-----------------------------------&lt;br/&gt;
1          |10         |1&lt;/p&gt;

&lt;p&gt;Now we attempt to fetch the &quot;next&quot; row from ADMIN_UNITS that matches the outer row &quot;(1, 10, 1)&quot;.  But as mentioned earlier, the NestedLoop result set that would do so has &quot;oneRowRightSide&quot; set to TRUE.  This means that the NestedLoop &lt;em&gt;knows&lt;/em&gt; it will not find any more rows in ADMIN_UNITS that satsify conditions &quot;a&quot; and &quot;b&quot; shown above.  So instead of going to the table, &amp;gt;&amp;gt;&amp;gt; it just QUITS the scan &amp;lt;&amp;lt;&amp;lt;.  See the following in NestedLoopJoinResultSet:&lt;/p&gt;

&lt;p&gt;        if (oneRowRightSide &amp;amp;&amp;amp; returnedRowMatchingRightSide)&lt;/p&gt;
        {
            rightRow = null;
            returnedRowMatchingRightSide = false;
        }

&lt;p&gt;So we quit the inner scan of ADMIN_UNITS, which leads us to get the next &quot;outer&quot; row from the intermediate join rows shown earlier.  I.e.  we&apos;ll now set our outer row to be &quot;(1, 10, 3)&quot;.  Then we&apos;ll execute:&lt;/p&gt;

&lt;p&gt;        if (leftRow == null)&lt;/p&gt;
        {
            closeRight();
        }
&lt;p&gt;        else&lt;/p&gt;
        {
            rowsSeenLeft++;
            openRight();
        }

&lt;p&gt;&quot;leftRow&quot; here is the same as &quot;outer&quot; row, so it is &quot;(1, 10, 3)&quot; at this point.  Since it&apos;s not null we&apos;ll re-open the scan on ADMIN_UNITS, per the &quot;else&quot; branch.  Then, similar to what we did with the first outer row, we&apos;ll get the &quot;next&quot; probe value in the list of values for ADMIN_UNITS.&lt;/p&gt;

&lt;p&gt;But this is where the problem occurs.  When we &quot;quit&quot; the scan in the above IF statement we left the MultiProbe result set in the middle of a scan.  So when we make the call to re-open the scan, we need to RESET the probing state.  But the code in MultiProbeTableScanResultSet does not currently do that.  More on that below.&lt;/p&gt;

&lt;p&gt;For the current codeline we do &lt;b&gt;not&lt;/b&gt; reset the probe scan, and thus the next probe value we see is &quot;21&quot;, from the list (1, 21).  With that we will then try to get a row from ADMIN_UNIT_ID such that:&lt;/p&gt;

&lt;p&gt;  a) the ADMIN_UNIT_ID column of the row equals the current probe&lt;br/&gt;
     value, which is &amp;gt;&amp;gt;&amp;gt; &quot;21&quot; &amp;lt;&amp;lt;&amp;lt;, AND&lt;/p&gt;

&lt;p&gt;  b) the ADMIN_UNIT_ID column of the row equals the ADMIN_UNIT_ID of&lt;br/&gt;
     the outer row, which is &quot;(1, 10, 3)&quot;.&lt;/p&gt;

&lt;p&gt;But ADMIN_UNITS does not contain any rows which satisfy condition &quot;a&quot;, so we will not return a row. Having no row from ADMIN_UNITS, we go on to fetch the next &quot;outer&quot; row from the intermediate join table, meaning we end up with &quot;(1, 10, 4)&quot;.  So we&apos;ll use that outer row and do what we did with the others: i.e. First we&apos;ll get the next probe value in the list of values.  The logic in MultiProbeTableScan result set sees that we have exhaused the probe list at this point, so &lt;b&gt;NOW&lt;/b&gt; it RESETS the probing state.  After that it gets the &quot;next&quot; probe value, which is the first value in the list (again), and thus we end up with a probe value of &quot;1&quot;.  Second, we will see if there is a row in ADMIN_UNITS such that:&lt;/p&gt;

&lt;p&gt;  a) the ADMIN_UNIT_ID column of the row equals the current probe&lt;br/&gt;
     value, which is &quot;1&quot;, AND&lt;/p&gt;

&lt;p&gt;  b) the ADMIN_UNIT_ID column of the row equals the ADMIN_UNIT_ID of&lt;br/&gt;
     the outer row, which is &quot;(1, 10, 4)&quot;.&lt;/p&gt;

&lt;p&gt;Since both of these conditions are true, we&apos;ll return the row as expected.  So our result at this point is:&lt;/p&gt;

&lt;p&gt;ADMIN_UNIT&amp;amp;|ACCOUNT_ID |BOOKING_ID&lt;br/&gt;
-----------------------------------&lt;br/&gt;
1          |10         |1&lt;br/&gt;
1          |10         |4&lt;/p&gt;

&lt;p&gt;And that&apos;s how the query ends--missing a row.&lt;/p&gt;

&lt;p&gt;So what&apos;s going on with MultiProbeTableScanResultSet?  There are some comments in the &quot;reopenCore()&quot; method of that class which explain a) why we do NOT reset the probe state in some cases, and b) why we DO reset the probe state in others.  For reference the comment is:&lt;/p&gt;

&lt;p&gt;     /* There are two scenarios for which we reopen this kind of scan:&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A - The first is for join processing.  In this case we have&lt;/li&gt;
	&lt;li&gt;a(nother) row from some outer table and we want to reopen this&lt;/li&gt;
	&lt;li&gt;scan to look for rows matching the new outer row.&lt;br/&gt;
      *&lt;/li&gt;
	&lt;li&gt;B - The second is for multi-probing.  Here we want to reopen&lt;/li&gt;
	&lt;li&gt;the scan on this table to look for rows matching the next value&lt;/li&gt;
	&lt;li&gt;in the probe list.&lt;br/&gt;
      *&lt;/li&gt;
	&lt;li&gt;If we are reopening the scan for scenario A (join processing)&lt;/li&gt;
	&lt;li&gt;then we need to reset our position within the probe list.&lt;/li&gt;
	&lt;li&gt;If we are reopening the scan for scenario B then we do &lt;b&gt;not&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;want to reset our position within the probe list because that&lt;/li&gt;
	&lt;li&gt;position tells us where to find the next probe value.&lt;br/&gt;
      *&lt;/li&gt;
	&lt;li&gt;The way we tell the difference between the two scenarios is&lt;/li&gt;
	&lt;li&gt;by looking at our current position in the probe list (i.e. the&lt;/li&gt;
	&lt;li&gt;value of probeValIndex): if our current position is beyond the&lt;/li&gt;
	&lt;li&gt;length of the probe list then we know that we are reopening the&lt;/li&gt;
	&lt;li&gt;scan for scenario A.  Or put another away, we should never get&lt;/li&gt;
	&lt;li&gt;here for scenario B if probeValIndex is greater than or equal&lt;/li&gt;
	&lt;li&gt;to the length of the probe list.  The reason is that the call&lt;/li&gt;
	&lt;li&gt;to reopenCore() for scenario B will only ever happen when&lt;/li&gt;
	&lt;li&gt;moreInListVals() returns true--and in that case we know that&lt;/li&gt;
	&lt;li&gt;probeValIndex will be less than the length of the probeValues.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This comment states one thing and assumes another. First it states (correctly) that if our current position is beyond the length of the probe list then we must be seeing scenario A.  It then goes on to assume (incorrectly) that if the current position is LESS than the length of the probe list we must be seeing scenario B.  It turns out that this is &lt;b&gt;NOT&lt;/b&gt; true.  The reason it is not true is because of the &quot;oneRowRightSide&quot; processing described above: when that flag is set to true we quit the scan early, meaning that the current probe position will in fact be less than the length of the probe list.  Then we later come back with a(nother) row from the outer table (i.e. the intermediate join table shown above) and &quot;we want to reopen this scan to look for rows matching the new outer row&quot;.  That means we need to reset the probe state: but due to the incorrect assumption, we don&apos;t reset it.  The result is incorrect results as described above.&lt;/p&gt;

&lt;p&gt;I&apos;m attaching a first attempt at a fix, d3603_v1.patch.  With this patch applied the repro case correctly returns three rows.  The patch does not include a test case and I don&apos;t know yet if it passes the regression tests.  I&apos;m running them now but they won&apos;t complete for several more hours.  So far the lang/subqueryFlattening test has failed with a plan diff, which may require some investigation...&lt;/p&gt;

&lt;p&gt;I&apos;m still quite limited on time so if it is agreed that this is the correct fix (or at least, the right direction), it&apos;d be great if someone could add the test and take it to completion--esp. if it could happen before the next 10.4 release candidate.  If no one picks it up I&apos;ll try to get to it sometime next week, but probably not in time for the second RC...&lt;/p&gt;

&lt;p&gt;Regardless of whether or not this writeup proves correct, many thanks again to Bryan and Thomas for their investigation and comments.  As no one officially assigned the issue to him/herself I spent some time investigating, as written above.  I hope I didn&apos;t step on anyone&apos;s toes in the process.&lt;/p&gt;</comment>
                            <comment id="12588404" author="bryanpendleton" created="Sun, 13 Apr 2008 17:49:41 +0100"  >&lt;p&gt;Thanks Thomas and Army for all the analysis and explanation; it is &lt;b&gt;very&lt;/b&gt; helpful!&lt;/p&gt;

&lt;p&gt;If I am understanding it all correctly, then I believe this script reproduces the problem.&lt;br/&gt;
Without Army&apos;s patch the first 2 queries return (a) count=1, and (b) 1 row, but &lt;b&gt;with&lt;/b&gt;&lt;br/&gt;
Army&apos;s patch all three queries return a result of 2 rows (count = 2), which I believe&lt;br/&gt;
is the correct result.&lt;/p&gt;

&lt;p&gt;I&apos;ll see if I can turn Army&apos;s patch and this repro script into a complete patch and run&lt;br/&gt;
the tests, etc.&lt;/p&gt;

&lt;p&gt;drop table a;&lt;br/&gt;
drop table c;&lt;/p&gt;

&lt;p&gt;create table a (a_id integer, c_id integer);&lt;br/&gt;
create table c (c_id integer not null, primary key(c_id),&lt;br/&gt;
                d_id integer, t_o bigint, t_i bigint);&lt;/p&gt;

&lt;p&gt;insert into a (a_id, c_id) values (1, 1);&lt;br/&gt;
insert into a (a_id, c_id) values (2, 2);&lt;br/&gt;
insert into a (a_id, c_id) values (3, 1);&lt;br/&gt;
insert into c (c_id, d_id, t_o, t_i) values (1, 1, 1, 1);&lt;br/&gt;
insert into c (c_id, d_id, t_o, t_i) values (2, 2, 1, 1);&lt;br/&gt;
insert into c (c_id, d_id, t_o, t_i) values (21, 1, 1, 1);&lt;/p&gt;

&lt;p&gt;select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
select a.a_id from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
select a.a_id,c.d_id from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;/p&gt;

&lt;p&gt;Results without the patch:&lt;br/&gt;
ij&amp;gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
1&lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select a.a_id from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
A_ID&lt;br/&gt;
-----------&lt;br/&gt;
1&lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select a.a_id,c.d_id from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
A_ID       |D_ID&lt;br/&gt;
-----------------------&lt;br/&gt;
1          |1&lt;br/&gt;
3          |1&lt;/p&gt;

&lt;p&gt;Results with the patch:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
2&lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select a.a_id from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
A_ID&lt;br/&gt;
-----------&lt;br/&gt;
1&lt;br/&gt;
3&lt;/p&gt;

&lt;p&gt;2 rows selected&lt;br/&gt;
ij&amp;gt; select a.a_id,c.d_id from a, c where a.a_id &amp;lt;&amp;gt; 2 and c.c_id in (1, 21)&lt;br/&gt;
       and a.c_id = c.c_id;&lt;br/&gt;
A_ID       |D_ID&lt;br/&gt;
-----------------------&lt;br/&gt;
1          |1&lt;br/&gt;
3          |1&lt;/p&gt;
</comment>
                            <comment id="12588468" author="bryanpendleton" created="Mon, 14 Apr 2008 04:08:01 +0100"  >&lt;p&gt;Attached is &apos;patch_with_test.diff&apos;, which expands on Army&apos;s&lt;br/&gt;
original test by adding a simple reproduction script to&lt;br/&gt;
InListMultiProbeTest.java.&lt;/p&gt;

&lt;p&gt;With this patch in place, &lt;b&gt;almost&lt;/b&gt; all the tests pass.&lt;/p&gt;

&lt;p&gt;However, I&apos;m seeing a diff in subqueryFlattening.sql in&lt;br/&gt;
the derbyall/derbylang suite. I&apos;ve attached the diff that I get.&lt;/p&gt;</comment>
                            <comment id="12588469" author="bryanpendleton" created="Mon, 14 Apr 2008 04:09:18 +0100"  >&lt;p&gt;At a quick glance, it looks like the subqueryFlattening diff might be OK,&lt;br/&gt;
and perhaps I just need to update the master output.&lt;/p&gt;

&lt;p&gt;But it would be nice to have more eyes on this.&lt;/p&gt;</comment>
                            <comment id="12588492" author="thomanie" created="Mon, 14 Apr 2008 07:41:17 +0100"  >&lt;p&gt;No toes feeling stepped on Army - again an excellent writeup!&lt;/p&gt;

&lt;p&gt;I agree with Bryan that the subqueryFlattening.diff seems OK - it does produce the correct results but the filtering seems to happen at slightly different levels. I&apos;ll give the patch a spin too.&lt;/p&gt;</comment>
                            <comment id="12588591" author="bryanpendleton" created="Mon, 14 Apr 2008 15:27:06 +0100"  >&lt;p&gt;The 2 queries in subqueryFlattening.sql which get the different runtime statistics are:&lt;/p&gt;

&lt;p&gt;SELECT count(ID) FROM DOCS WHERE ID &amp;lt;&amp;gt; ANY (SELECT ID FROM COLLS WHERE COLLID IN (-2,1) );&lt;br/&gt;
and&lt;br/&gt;
SELECT count(ID) FROM DOCS WHERE ID &amp;gt; ANY (SELECT ID FROM COLLS WHERE COLLID IN (-2,1) );&lt;/p&gt;

&lt;p&gt;The queries get the correct final results, and the overall shape of the query&lt;br/&gt;
plans is the same, but the precise details of which rows are processed&lt;br/&gt;
at what stage of the query plan changes slightly.&lt;/p&gt;</comment>
                            <comment id="12588661" author="army" created="Mon, 14 Apr 2008 18:54:45 +0100"  >&lt;p&gt;Thank you very much for picking this one up, Bryan.  I greatly appreciate it.&lt;/p&gt;

&lt;p&gt;On the subqueryFlattening.diff:&lt;/p&gt;

&lt;p&gt;To see why the diff occurs, I stepped through the following exercise.  I did not actually trace through the code, but I walked through what I &lt;b&gt;think&lt;/b&gt; should be happening and it seems to have explained the diff...&lt;/p&gt;

&lt;p&gt;At the time of the statements in question the data in the DOCS and COLLS tables is as follows:&lt;/p&gt;

&lt;p&gt;DOCS: ID (VARCHAR) =&amp;gt;&lt;br/&gt;
  (&apos;124&apos;), (&apos;24&apos;), (&apos;25&apos;), (&apos;27&apos;), (&apos;36&apos;), (&apos;567&apos;)&lt;/p&gt;

&lt;p&gt;COLLS: ID (VARCHAR), COLLID (SMALLINT) =&amp;gt;&lt;br/&gt;
  (&apos;123&apos;, 2), (&apos;124&apos;, -5), (&apos;24&apos;, 1), (&apos;26&apos;, -2), (&apos;36&apos;, 1), (&apos;37&apos;, 8)&lt;/p&gt;

&lt;p&gt;Now assume the query in question is:&lt;/p&gt;

&lt;p&gt;  SELECT count(ID) FROM DOCS&lt;br/&gt;
    WHERE ID &amp;lt;&amp;gt; ANY (SELECT ID FROM COLLS WHERE COLLID IN (-2,1))&lt;/p&gt;

&lt;p&gt;The ANY will be flattened giving us something to the effect of:&lt;/p&gt;

&lt;p&gt;  SELECT count(ID) FROM DOCS, COLLS&lt;br/&gt;
    WHERE DOCS.ID &amp;lt;&amp;gt; COLLS.ID AND COLLS.COLLID IN (-2, 1)&lt;/p&gt;

&lt;p&gt;The IN list for the queries that we&apos;re talking about is (-2, 1). So per the explanation I posted on Friday, we&apos;d end up with something like the following withOUT the change.&lt;/p&gt;

&lt;p&gt;Note: Lines preceded by &quot;+&quot; indicate that we read a row from the inner table, COLLS.  Lines preced by &quot;*&apos; indicate that what we do for the line changes with the proposed patch for this issue.  Lines preceded by an &quot;x&quot; indicate that we &quot;filter&quot; a row from COLLS, meaning we read it but then we discard it.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Get DOCS row (&apos;124&apos;).&lt;/li&gt;
	&lt;li&gt;Get first IN list value, -2.&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, -2).&lt;/li&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;124&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;124&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;24&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Get next IN list value, 1.&lt;br/&gt;
  + Get row from COLLS where COLLID is 1, i.e. (&apos;24&apos;, 1).&lt;br/&gt;
  x See if ID column of (&apos;24&apos;, 1) is NOT EQUAL to &apos;24&apos;.  They&lt;br/&gt;
    are EQUAL so we skip the row (&apos;24&apos;, 1) and continuing our&lt;br/&gt;
    scan of COLLS.&lt;br/&gt;
  + Get next row from COLLS where COLLID is 1, i.e. (&apos;36&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;36&apos;, 1) is NOT EQUAL to &apos;24&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;24&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;25&apos;).&lt;/li&gt;
	&lt;li&gt;Implicitly RESET the probe state, then get the &quot;next&quot; IN&lt;br/&gt;
    list value, which will be -2.&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, -2).&lt;/li&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;25&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;25&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;27&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Get next IN list value, 1.&lt;br/&gt;
  + Get row from COLLS where COLLID is 1, i.e. (&apos;24&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;24&apos;, 1) is NOT EQUAL to &apos;27&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;27&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;36&apos;).&lt;/li&gt;
	&lt;li&gt;Implicitly RESET the probe state, then get the &quot;next&quot; IN&lt;br/&gt;
    list value, which will be -2.&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, -2).&lt;/li&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;36&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;36&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;567&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Get next IN list value, 1.&lt;br/&gt;
  + Get row from COLLS where COLLID is 1, i.e. (&apos;24&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;24&apos;, 1) is NOT EQUAL to &apos;567&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;567&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;No more rows from DOCS, so done.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We can see from this that we get a row from COLLS a total of 7 times. In the process we &quot;filtered&quot; one row out, i.e. the row (&apos;24&apos;, 1), because that row has the same ID has a row in DOCS.  Or put in terms of the scan statistics, we have 7 &quot;rows seen&quot; and one (1) row filtered.  And the query returns a count total of 6 rows from DOCS.&lt;/p&gt;

&lt;p&gt;But now if we do the same exercise with the patch applied, we see the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Get DOCS row (&apos;124&apos;).&lt;/li&gt;
	&lt;li&gt;Get first IN list value, -2.&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, -2).&lt;/li&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;124&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;124&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;24&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;RESET probe state, then get &quot;next&quot; IN list value, which&lt;br/&gt;
    is -2 (again).&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;24&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;24&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;25&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;RESET probe state, then get &quot;next&quot; IN list value, which&lt;br/&gt;
    is -2 (again).&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;25&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;25&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;27&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;RESET probe state, then get &quot;next&quot; IN list value, which&lt;br/&gt;
    is -2 (again).&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;27&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;27&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;36&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;RESET probe state, then get &quot;next&quot; IN list value, which&lt;br/&gt;
    is -2 (again).&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;36&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;36&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;Get DOCS row (&apos;567&apos;).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;RESET probe state, then get &quot;next&quot; IN list value, which&lt;br/&gt;
    is -2 (again).&lt;br/&gt;
  + Get row from COLLS where COLLID is -2, i.e. (&apos;26&apos;, 1).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;See if ID column of (&apos;26&apos;, -2) is NOT EQUAL to &apos;567&apos;.  They&lt;br/&gt;
    are not equal so count the &apos;567&apos; row from DOCS and quit the&lt;br/&gt;
    scan of COLLS.&lt;/li&gt;
	&lt;li&gt;No more rows from DOCS, so done.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now the total number of rows we &quot;see&quot; from COLLS is 6 instead of 7.  This is because we never fetched the row (&apos;24&apos;, 1) from the table.  Instead, we only had to fetch the one row, (&apos;26&apos;, -2), over and over.  Then, since we never fetched row (&apos;24&apos;, 1) from the table we didn&apos;t have to filter it out.  So we end up with a total of 6 &quot;rows seen&quot; and 0 rows filtered. Meanwhile the query still returns a count total of 6 rows from DOCS.&lt;/p&gt;

&lt;p&gt;I didn&apos;t run through this exercise for the other cases, but I imagine (hope!) things would work out in a similar fashion...Does that seem like a reasonable explanation to you?  If so, then I think it&apos;s okay to update the master file for subqueryFlattening.sql for this issue.&lt;/p&gt;

&lt;p&gt;Oh, and thanks for writing the standalone repro, as well!&lt;/p&gt;</comment>
                            <comment id="12589380" author="bryanpendleton" created="Wed, 16 Apr 2008 02:23:01 +0100"  >&lt;p&gt;Thanks Army for the clear and detailed description of the subquery processing.&lt;/p&gt;

&lt;p&gt;To confirm it, I introduced some crude print statements into the MultiProbe&lt;br/&gt;
code and:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;without the patch I can see it ping-ponging back and forth between -2 and 1&lt;/li&gt;
	&lt;li&gt;with the patch I can see that it simply uses the -2 row over and over,&lt;br/&gt;
   as you suggest.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Based on that evidence, and on a close read of Army&apos;s description,&lt;br/&gt;
I&apos;m comfortable updating the subqueryFlattening.out file.&lt;/p&gt;

&lt;p&gt;Attached is updateSubquerymaster.diff, which I believe is ready for review.&lt;/p&gt;

&lt;p&gt;I intend to commit this patch to the trunk tonight or tomorrow morning,&lt;br/&gt;
and I&apos;m also intending to merge it to 10.4, assuming no additional&lt;br/&gt;
concerns are raised via review or testing.&lt;/p&gt;</comment>
                            <comment id="12589397" author="bryanpendleton" created="Wed, 16 Apr 2008 04:38:18 +0100"  >&lt;p&gt;Committed the change to the trunk as revision 648492.&lt;/p&gt;</comment>
                            <comment id="12589599" author="bryanpendleton" created="Wed, 16 Apr 2008 16:24:46 +0100"  >&lt;p&gt;Committed the change to the 10.4 branch as revision 648722.&lt;/p&gt;

&lt;p&gt;I&apos;ll investigate merging this change back to the 10.3 branch as well.&lt;/p&gt;</comment>
                            <comment id="12589624" author="dyret" created="Wed, 16 Apr 2008 17:05:48 +0100"  >&lt;p&gt;Resolving with fixversion 10.4.0.0 (since there is no 10.4.1.3 yet) just to get it on the list of fixed bugs.&lt;/p&gt;</comment>
                            <comment id="12590145" author="bryanpendleton" created="Thu, 17 Apr 2008 19:46:05 +0100"  >&lt;p&gt;Committed to the 10.3 branch as revision 649226.&lt;/p&gt;

&lt;p&gt;Updated fix version to reflect that.&lt;/p&gt;

&lt;p&gt;Thanks again Army and Thomas for the help and reviews!&lt;/p&gt;</comment>
                            <comment id="12590194" author="army" created="Thu, 17 Apr 2008 21:15:28 +0100"  >&lt;p&gt;And thanks to you, Bryan, for taking this one to completion!&lt;/p&gt;</comment>
                            <comment id="12590457" author="knutanders" created="Fri, 18 Apr 2008 14:56:42 +0100"  >&lt;p&gt;Changed fix version from 10.4.0.0 to 10.4.1.3.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12379935" name="d3603_v1.patch" size="4794" author="army" created="Fri, 11 Apr 2008 18:16:24 +0100"/>
                            <attachment id="12380036" name="d3603_with_test.diff" size="7686" author="bryanpendleton" created="Mon, 14 Apr 2008 04:08:01 +0100"/>
                            <attachment id="12379740" name="derbydb.jar" size="435269" author="kmarsden" created="Wed, 9 Apr 2008 16:45:04 +0100"/>
                            <attachment id="12379620" name="derbydb.tar.bz2" size="237761" author="eldavio" created="Tue, 8 Apr 2008 03:17:45 +0100"/>
                            <attachment id="12380037" name="subqueryFlattening.diff" size="1602" author="bryanpendleton" created="Mon, 14 Apr 2008 04:08:01 +0100"/>
                            <attachment id="12380236" name="updateSubqueryMaster.diff" size="11951" author="bryanpendleton" created="Wed, 16 Apr 2008 02:23:01 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 8 Apr 2008 14:29:12 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23739</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0lhb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37298</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10051"><![CDATA[Urgent]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>