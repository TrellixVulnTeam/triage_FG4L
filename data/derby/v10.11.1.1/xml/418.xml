<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:12:45 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-418/DERBY-418.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-418] outofmemory error when running large query in autocommit=false mode</title>
                <link>https://issues.apache.org/jira/browse/DERBY-418</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;On the derby-user list,  Chris reported tihs problem with his application and also a repro for the problem.  I am logging the jira issue so it doesnt get lost in all the mail.  (&lt;a href=&quot;http://www.mail-archive.com/derby-user@db.apache.org/msg01258.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.mail-archive.com/derby-user@db.apache.org/msg01258.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;-----&lt;del&gt;from chris&apos;s post&lt;/del&gt;---------&lt;br/&gt;
I&apos;m running a set of ~50000 queries on one table, using inserts and updates, and i want to be able to roll them back so i turned off autocommit using setAutoCommit(false).  As the update runs, the memory used by the JVM increases continually until i get the following exception about 20% of the way through:&lt;/p&gt;

&lt;p&gt;ERROR 40XT0: An internal error was identified by RawStore module.&lt;br/&gt;
   at org.apache.derby.iapi.error.StandardException.newException(StandardException.java)&lt;br/&gt;
   at org.apache.derby.impl.store.raw.xact.Xact.setActiveState(Xact.java)&lt;br/&gt;
   at org.apache.derby.impl.store.raw.xact.Xact.openContainer(Xact.java)&lt;br/&gt;
   at org.apache.derby.impl.store.access.conglomerate.OpenConglomerate.init(OpenConglomerate.java)&lt;br/&gt;
   at org.apache.derby.impl.store.access.heap.Heap.open(Heap.java)&lt;br/&gt;
   at org.apache.derby.impl.store.access.RAMTransaction.openConglomerate(RAMTransaction.java)&lt;br/&gt;
   at org.apache.derby.impl.store.access.RAMTransaction.openConglomerate(RAMTransaction.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.getDescriptorViaIndex(DataDictionaryImpl.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.locateSchemaRow(DataDictionaryImpl.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.getSchemaDescriptor(DataDictionaryImpl.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.QueryTreeNode.getSchemaDescriptor(QueryTreeNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.QueryTreeNode.getSchemaDescriptor(QueryTreeNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.FromBaseTable.bindTableDescriptor(FromBaseTable.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.FromBaseTable.bindNonVTITables(FromBaseTable.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.FromList.bindTables(FromList.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.SelectNode.bindNonVTITables(SelectNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.DMLStatementNode.bindTables(DMLStatementNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.DMLStatementNode.bind(DMLStatementNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.ReadCursorNode.bind(ReadCursorNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.compile.CursorNode.bind(CursorNode.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java)&lt;br/&gt;
   at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java)&lt;br/&gt;
   at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java)&lt;br/&gt;
   at org.apache.derby.impl.jdbc.EmbedStatement.executeQuery(EmbedStatement.java)&lt;br/&gt;
   at vi.hotspot.database.DataInterface._query(DataInterface.java:181)&lt;br/&gt;
   at vi.hotspot.database.DataInterface.query(DataInterface.java:160)&lt;br/&gt;
   at vi.hotspot.database.UpdateManager.updatePartialTable(UpdateManager.java:518)&lt;br/&gt;
   at vi.hotspot.database.UpdateManager.updatePartialTables(UpdateManager.java:619)&lt;br/&gt;
   at vi.hotspot.database.UpdateManager.run(UpdateManager.java:924)&lt;br/&gt;
   at java.lang.Thread.run(Thread.java:534)&lt;br/&gt;
vi.hotspot.exception.ServerTransactionException&lt;br/&gt;
   at vi.hotspot.database.UpdateManager.updatePartialTable(UpdateManager.java:555)&lt;br/&gt;
   at vi.hotspot.database.UpdateManager.updatePartialTables(UpdateManager.java:619)&lt;br/&gt;
   at vi.hotspot.database.UpdateManager.run(UpdateManager.java:924)&lt;br/&gt;
   at java.lang.Thread.run(Thread.java:534)&lt;/p&gt;

&lt;p&gt;Derby is running in standalone mode. &lt;/p&gt;</description>
                <environment>I can reproduce this problem on Win2k/ T42 laptop. jdk141. </environment>
        <key id="12311840">DERBY-418</key>
            <summary>outofmemory error when running large query in autocommit=false mode</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mayureshnirhali">Mayuresh Nirhali</assignee>
                                    <reporter username="skambha">Sunitha Kambhampati</reporter>
                        <labels>
                    </labels>
                <created>Fri, 1 Jul 2005 06:35:06 +0100</created>
                <updated>Wed, 5 May 2010 12:06:47 +0100</updated>
                            <resolved>Fri, 1 Sep 2006 12:58:43 +0100</resolved>
                                    <version>10.1.1.0</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12314814" author="skambha" created="Fri, 1 Jul 2005 06:37:19 +0100"  >&lt;p&gt;This repro was given by Chris.  &lt;a href=&quot;http://www.mail-archive.com/derby-user@db.apache.org/msg01258.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.mail-archive.com/derby-user@db.apache.org/msg01258.html&lt;/a&gt;.   &lt;br/&gt;
To run &lt;br/&gt;
java -Xmx64M AutoCommitTest&lt;/p&gt;</comment>
                            <comment id="12422407" author="mayureshnirhali" created="Thu, 20 Jul 2006 13:24:02 +0100"  >&lt;p&gt;I was able to reproduce this issue on my Sol10 x86 jdk1.5 platform.&lt;/p&gt;

&lt;p&gt;I ran with following option,&lt;br/&gt;
-verbosegc (java option)&lt;br/&gt;
--Xmx16m (preferred this option to avoid large output file n reproduce the error in less time for the analysis)&lt;br/&gt;
-Dderby.debug.true=memoryLeakTrace&lt;/p&gt;

&lt;p&gt;Following are the observations from the output of this command,&lt;/p&gt;

&lt;p&gt;memoryLeakTrace:GenericLanguageContext:activations 1917 (memoryLeak is reported after activations grow &amp;gt; 20)&lt;br/&gt;
memoryLeakTrace:BasicDependencyManager:table 1966 (memoryLeak is reported after table size grow &amp;gt; 100)&lt;br/&gt;
memoryLeakTrace:BasicDependencyManager:deps 1966 (memoryLeak is reported after dependencies grow &amp;gt; 50)&lt;br/&gt;
memoryLeakTrace:LockSet: 1908 (mem leak reported after lock objects grow &amp;gt; 1000)&lt;/p&gt;

&lt;p&gt;I have not gotten any further on this issue and do not plan to work on this until atleast the week after next.&lt;br/&gt;
HTH!&lt;/p&gt;</comment>
                            <comment id="12427480" author="mayureshnirhali" created="Fri, 11 Aug 2006 10:30:01 +0100"  >&lt;p&gt;I used the JHAT (jdk1.6) to dump the java heap and observed that large number of generated objects of type CursorActivation exist on the heap. The expected behavior here is to have not more than 1 Activation when the statement is being executed. Further investigation showed that these generated objects are not getting closed for only the &quot;select&quot; kind statements. &lt;br/&gt;
The GenericPreparedStatement fires activation.execute method and gets the result in a ResultSet object. It then checks if the singleExecution flag for activation is true and the returned resultSet is closed. If both are true then the activation is closed. For the &quot;select&quot; statements in the reproducible testcase, the returned resultSet is not closed and hence the activation is NOT closed. Thus causing the memory leak.&lt;/p&gt;

&lt;p&gt;The code for activation.execute is dynamically generated code. I need some help to understand how this can be debugged.&lt;br/&gt;
Before that, I would like to understand if the returned resultSet should really be closed for &quot;select&quot; statement ?? If Yes, then when the activation is expected to be closed for such case ?? &lt;/p&gt;</comment>
                            <comment id="12427844" author="mayureshnirhali" created="Mon, 14 Aug 2006 10:40:13 +0100"  >&lt;p&gt;In the reproducible testbase, autoCommit is set to FALSE, and more important, the resultSet returned by select query is not closed. So, the generated Activation objects stay on the heap resulting in OOME.&lt;/p&gt;

&lt;p&gt;I modified the testcase to close the ResultSet in each iteration and program runs fine.&lt;/p&gt;

&lt;p&gt;Unless someone disagrees with the analysis, I think this JIRA can be closed with &quot;Not a bug&quot;.&lt;/p&gt;</comment>
                            <comment id="12427891" author="mayureshnirhali" created="Mon, 14 Aug 2006 15:10:40 +0100"  >&lt;p&gt;Thanks to Andreas and Oystein for pointing out another possibilty that when the statement objects are GC&apos;d, the activations associated with them are not closed which could be causing the leak.&lt;/p&gt;

&lt;p&gt;I shall work further on this and have assigned this one to myself.&lt;/p&gt;</comment>
                            <comment id="12427899" author="djd" created="Mon, 14 Aug 2006 15:22:12 +0100"  >&lt;p&gt;I think this is the same case as described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt;, comment towards end has a couple of possible solutions.&lt;br/&gt;
&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1142#action_12420461&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1142#action_12420461&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12429259" author="mayureshnirhali" created="Sun, 20 Aug 2006 12:15:45 +0100"  >&lt;p&gt;I tried modifying the finalize method of embedResultSet to close singleuseActivation and that seems to have worked for good reasons. So, when GC operations clean up resultset objects the associated activation objects will be closed, thus freeing up some more memory. But, for the reproducible case, this is not the complete solution. This change differs the leak for a long period but does not completely fix it.&lt;/p&gt;

&lt;p&gt;I tried the same fix for the repro in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt; (without resultset.close statement) and did not see any leak there.&lt;/p&gt;

&lt;p&gt;I think, this can be a good fix for now until the extreme case is tracked down.&lt;/p&gt;

&lt;p&gt;I will run derbyall with this fix and produce a patch soon.&lt;/p&gt;</comment>
                            <comment id="12429264" author="djd" created="Sun, 20 Aug 2006 15:17:11 +0100"  >&lt;p&gt;Closing the activation directly in the finalize method will lead to problems. The close of the activation requires obtaining synchronization which is not recommended for the finalizer thread, it can lead to deadlocks with the thread that owns the connection and its synchronization. That&apos;s why the activations are closed indirectly through the set inactive state mechanism.&lt;/p&gt;</comment>
                            <comment id="12429361" author="andreask" created="Mon, 21 Aug 2006 09:46:38 +0100"  >&lt;p&gt;I think that the lack of synchronization when calling singleUseActivation.markUnused() may cause that other threads do not see that the field inUse has been modified in the activation. Since it is the finalizer thread which calls this, it could mean that the thread which checks the inUse flag to close the activation, will not see that it has been modified to false.&lt;/p&gt;</comment>
                            <comment id="12429386" author="andreask" created="Mon, 21 Aug 2006 11:52:35 +0100"  >&lt;p&gt;The finalizer thread is as pr javadoc guaranteed to not hold any user-visible synchronization locks when finalize is invoked. If the finalizer synchronizes in the same order as the other methods, it should not introduce any dead-locks (you may get lock-waiting, but not dead-lock).&lt;/p&gt;</comment>
                            <comment id="12429430" author="djd" created="Mon, 21 Aug 2006 15:54:25 +0100"  >&lt;p&gt;I don&apos;t think there is any guarantee about the order of finalization, therefore it is impossible to guarantee the same order of synchronization by the finalizer threads as the main code path, so obtaining synchronization within  a finlize method is subject to deadlocks.&lt;/p&gt;</comment>
                            <comment id="12429438" author="andreask" created="Mon, 21 Aug 2006 16:41:13 +0100"  >&lt;p&gt;I am not sure what you mean. &lt;/p&gt;

&lt;p&gt;Could you give an example ?&lt;/p&gt;

&lt;p&gt;I agree that it is possible to get a deadlock in the finalize() method if it obtains its locks in a different order than another user thread or another finalizer thread. If it obtains the locks in the same order, the condition for a deadlock is not there. If there are multiple objects being garbage collected, sharing mutexes, they need to set the locks in the same order - or else you may get deadlock.&lt;/p&gt;</comment>
                            <comment id="12429442" author="djd" created="Mon, 21 Aug 2006 17:02:26 +0100"  >&lt;p&gt;The alternate way to phrase it  is:&lt;/p&gt;

&lt;p&gt;Can you guarantee no deadlocks from using synchronization in the finalize method?&lt;/p&gt;

&lt;p&gt;Closing an activation in the finalize() methods is going to hit a lot of synchronized blocks, there just seems endless potential&lt;br/&gt;
for deadlocks, especially when the connection may be in any state, not being used, rolling back, preparing a statement, executing a statement, being shutdown by an unrelated error, being finalized itself, etc. etc.. This is then further compilcated by the fact the the order of execution within finalization is not guaranteed, if I have a chain of objects A,B,C the order they are finalized is not guaranteed, could be BAC, could be CBA, could be by different finalize threads.&lt;/p&gt;

&lt;p&gt;So given that, how easy is it to show the locking ordering is consistent?&lt;/p&gt;

&lt;p&gt;If you prove there is no possible chance of deadlocks, how is this enforced going forward? Does every change to any sycnhronized block have to go through a full review of possible implications with a single finalize method in EmbededResultSet?&lt;/p&gt;

&lt;p&gt;Maybe it&apos;s just me, but getting no synchronization in a finalize() method seems to be a nice simple rule, that doesn&apos;t require a proof for on-going changes in the engine. I suggested some possible changes to fix this in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt; and noted them above, are there any issues with those?&lt;/p&gt;
</comment>
                            <comment id="12429473" author="andreask" created="Mon, 21 Aug 2006 18:47:55 +0100"  >&lt;p&gt;Assuming the Derby embedded JDBC driver is thread-safe, it should be safe for a result set to call its own close() method in its finalizer. If you get a dead-lock in the finalizer, it proves that it is also possible to write a multithreaded program which gets deadlocks when calling ResultSet.close, and derby then is not really MT-safe.&lt;/p&gt;

&lt;p&gt;If this happens, I think it is better to fix the embedded driver so that it really becomes MT-safe, than avoiding synchronization in the finalizer threads.&lt;/p&gt;

&lt;p&gt;As for the suggested change in 1142, I would note that If there is no synchronization in the finalizer, and you set a field in a object from it, there is no guarantee that other threads will see the modification of the field (unless, I think, it is volatile). However, I think Mayuresh has been working on this issue, so maybe he has tried that approach?&lt;/p&gt;

&lt;p&gt;Another approach could be to use a WeakHashMap to store the activations in, instead of a Vector. If all objects referring to the activation have been garbage collected, the activation will be removed from the WeakHashMap.&lt;/p&gt;</comment>
                            <comment id="12429483" author="djd" created="Mon, 21 Aug 2006 19:18:00 +0100"  >&lt;p&gt;I&apos;d assumed that you were going to go in at a lower level than ResultSet.close(). ResultSet.close() is thread safe, but think of the consequences of calling ResultSet.close() from a finalizer.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The finalizer thread will block until the application thread executing a JDBC method on another object in the same connection completes the call. Worst case is the application thread is executing a query that takes several hours. Now the synchronization in the finalize method has resulted in the finalize thread stalling for a few hours, not good for the VM.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;What if the garbage collector thread is running because the application thread, using the same connection, requires memory, now you have created a deadlock , the application thread is waiting on the JVM to get memory, the vm finalizer thread is waiting on the application thread to complete its JDBC method call.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Not sure of the guarantee of the unsynchronized field being set. Are you saying that field will never be seen as set, or that the setting may not be seen for some time?&lt;/p&gt;

&lt;p&gt;The activation being in the Vector is not an issue, so replacing it with a WeakHashMap doesn&apos;t help. Code needs to be executed against the activation in order to clean it up, just letting it be garbage collected is not enough.  The current scheme was set up to be simple, only a single thread active in a connection at a single time, and to avoid the jvm deadlocks that wer seen when the activations were cleaned up directly in the finalize thread (since it breaks the simple rule, only a single thread active in a connection).&lt;/p&gt;</comment>
                            <comment id="12429668" author="mayureshnirhali" created="Tue, 22 Aug 2006 11:43:11 +0100"  >&lt;p&gt;I tried the approach suggested by Dan in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt;, and my version of change looks like as below,&lt;/p&gt;

&lt;p&gt;In GenericLanguageConnectionContext,&lt;/p&gt;

&lt;p&gt;	public void addActivation(Activation a) {&lt;br/&gt;
		acts.addElement(a);&lt;/p&gt;

&lt;p&gt;+              try {&lt;br/&gt;
+                  if (acts.size() &amp;gt; 20) &lt;/p&gt;
{
+                       resetActivations(false);
+                   }
&lt;p&gt;+              } catch(StandardException e) &lt;/p&gt;
{
+              }
&lt;p&gt;+&lt;br/&gt;
		if (SanityManager.DEBUG) {&lt;/p&gt;

&lt;p&gt;			if (SanityManager.DEBUG_ON(&quot;memoryLeakTrace&quot;)) &lt;/p&gt;
{

				if (acts.size() &amp;gt; 20)
					System.out.println(&quot;memoryLeakTrace:GenericLanguageContext:activations &quot; + acts.size());
			}
&lt;p&gt;		}&lt;br/&gt;
	}&lt;/p&gt;


&lt;p&gt;I thought it will be better to use the method resetActivations as it is meant to do the desired business for us. ( let me know if there are any negative implications of using this method here)&lt;/p&gt;

&lt;p&gt;This approach did not solve the OOME but differed it for sometime. The effect of this change is equal to the effect of having singleUseActivation.close in the finalize method of EmbedRS, as suggested earlier.&lt;/p&gt;

&lt;p&gt;Further, and importantly, I found that there still exist some Activation objects with inUse=true. I guess there is a synchronization issue here due to which EmbedRS.finalize is not called for all the objects, thus not marking them unused. On several runs, the worst case I found is that for 100 such select queries about 10% activation objects still stay on the heap. So, as the finalize method is not executed for many objects, the activation objects are not freed. Here, it is irrelevent if they are closed directly from within the finalize method or indirectly by first just marking them unused.&lt;/p&gt;

&lt;p&gt;I ran these tests on both jdk1.6 and jdk1.5.&lt;/p&gt;

&lt;p&gt;any thoughts on behaviour of finalizer thread in this context.&lt;br/&gt;
any inputs on synchronizing the markunused operation ??&lt;/p&gt;</comment>
                            <comment id="12429674" author="knutanders" created="Tue, 22 Aug 2006 12:31:54 +0100"  >&lt;p&gt;Hi Mayuresh,&lt;/p&gt;

&lt;p&gt;I&apos;m afraid your fix has some unwanted consequences. First of all, the OutOfMemoryError is still there. Secondly, resetActivations() will also reset activations that are still open and in use. Take for instance this code:&lt;/p&gt;

&lt;p&gt;        c.setAutoCommit(false);&lt;br/&gt;
        c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);&lt;br/&gt;
        Statement[] ss = new Statement&lt;span class=&quot;error&quot;&gt;&amp;#91;21&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        ResultSet[] rss = new ResultSet&lt;span class=&quot;error&quot;&gt;&amp;#91;ss.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        for (int i = 0; i &amp;lt; ss.length; i++) &lt;/p&gt;
{
            ss[i] = c.createStatement();
            rss[i] = ss[i].executeQuery(&quot;values 1&quot;);
        }
&lt;p&gt;        rss&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.next();&lt;/p&gt;

&lt;p&gt;Without your changes, it runs successfully. With your fix applied, rss&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.next() fails with java.sql.SQLException: ResultSet not open. Operation &apos;next&apos; not permitted. Verify that autocommit is OFF.&lt;/p&gt;</comment>
                            <comment id="12429709" author="mayureshnirhali" created="Tue, 22 Aug 2006 14:50:34 +0100"  >&lt;p&gt;Thanks Knut for pointing that out.&lt;/p&gt;

&lt;p&gt;I did not mean to provide a patch for this JIRA, but just wanted to try out a suggested approach. &lt;br/&gt;
I have corrected this error and now the trial piece of code looks like, &lt;/p&gt;

&lt;p&gt;    public void addActivation(Activation a) {&lt;br/&gt;
        acts.addElement(a);&lt;br/&gt;
        try {&lt;br/&gt;
                if (acts.size() &amp;gt; 20) {&lt;br/&gt;
		for (int i = acts.size() - 1; i &amp;gt;= 0; i--) {&lt;br/&gt;
			Activation a1 = (Activation) acts.elementAt&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/p&gt;

&lt;p&gt;			if (!a1.isInUse())&lt;/p&gt;
			{
				a1.close();
                        }

&lt;p&gt;                } //for&lt;br/&gt;
                }&lt;br/&gt;
                } catch(StandardException e) {&lt;br/&gt;
                }&lt;/p&gt;

&lt;p&gt;		if (SanityManager.DEBUG) {&lt;/p&gt;

&lt;p&gt;			if (SanityManager.DEBUG_ON(&quot;memoryLeakTrace&quot;)) &lt;/p&gt;
{

				if (acts.size() &amp;gt; 20)
					System.out.println(&quot;memoryLeakTrace:GenericLanguageContext:activations &quot; + acts.size());
			}
&lt;p&gt;		}&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;I have tried your code snippet with this along with the repro and did not see any regressions.&lt;/p&gt;

&lt;p&gt;However, the OOME is still seen. As mentioned in my earlier comment, the main issue seems to be with the Finalizer thread behaviour.&lt;br/&gt;
I guess there are 2 parts to this issue. &lt;br/&gt;
1. Make sure the inUse field is synchronized&lt;br/&gt;
2. Close activation objects either directly from EmbedRS.finalize method or indirectly as per the change in GenLCC.addActivation method.&lt;/p&gt;</comment>
                            <comment id="12429712" author="knutanders" created="Tue, 22 Aug 2006 15:13:58 +0100"  >&lt;p&gt;Did you try to declare BaseActivation.inUse as volatile?&lt;/p&gt;</comment>
                            <comment id="12429721" author="djd" created="Tue, 22 Aug 2006 15:28:30 +0100"  >&lt;p&gt;Any change must not ignore exceptions thrrown during an activation.close().&lt;/p&gt;

&lt;p&gt;                } catch(StandardException e) {&lt;br/&gt;
                } &lt;/p&gt;

&lt;p&gt;-1 on any change that includes that.&lt;/p&gt;</comment>
                            <comment id="12429725" author="knutanders" created="Tue, 22 Aug 2006 15:34:19 +0100"  >&lt;p&gt;Mayuresh, with your latest changes, I don&apos;t see the memory leak any more (neither &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; nor &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="12429997" author="mayureshnirhali" created="Wed, 23 Aug 2006 14:20:10 +0100"  >&lt;p&gt;Thanks Knut,&lt;/p&gt;

&lt;p&gt;Making BaseActivation.inUse volatile does solve the synchronization problem between the threads.&lt;br/&gt;
I do not see OOME with the above change along with the fix suggested in previous comments.&lt;/p&gt;

&lt;p&gt;I have attached a patch now. I shall run derbyall with this change.&lt;br/&gt;
I would appreciate if someone can take a look at the way the exception is handled in this patch and could point out if there is something that I am missing out.&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;</comment>
                            <comment id="12430028" author="djd" created="Wed, 23 Aug 2006 16:36:01 +0100"  >&lt;p&gt;The change ignores the exception:&lt;/p&gt;

&lt;p&gt;+                } catch(StandardException e) &lt;/p&gt;
{
+                    StandardException.plainWrapException(e);
+                }

&lt;p&gt;That code just creates an exception (in the call to plainWrapException)  and then throws it away.&lt;/p&gt;
</comment>
                            <comment id="12430232" author="mayureshnirhali" created="Thu, 24 Aug 2006 13:50:13 +0100"  >&lt;p&gt;posting another version of the patch here.&lt;/p&gt;

&lt;p&gt;I have corrected the catch block and now throwing the wrapped exception. This change has introduced some method declaration changes as well. Let me know if there are any concerns with this change.&lt;/p&gt;

&lt;p&gt;Also, the added code block now checks if the acts size is more than 20 before closing the unused activations, this will save some cost of  identifying unused activations everytime the addActivation is called.&lt;/p&gt;</comment>
                            <comment id="12430420" author="knutanders" created="Fri, 25 Aug 2006 08:25:23 +0100"  >&lt;p&gt;+                } catch(StandardException e) &lt;/p&gt;
{
+                    throw StandardException.plainWrapException(e);
+                }

&lt;p&gt;Since e already is a StandardException, there&apos;s no need to catch it and wrap it in a StandardException.&lt;/p&gt;

&lt;p&gt;It would also be good if there were a comment in addActivation() explaining why we&apos;re iterating over the activations vector, and a comment in BaseActivation saying that inUse is declared volatile to ensure it is visible when it has been modified by the finalizer thread.&lt;/p&gt;

&lt;p&gt;Have you considered the option where you set a volatile flag in GenericLanguageConnectionContext from BaseActivation.markUnused() so that you don&apos;t have to scan the activations vectors when there is no unused activation? It would require adding a method to the LanguageConnectionContext interface (for instance notifyUnusedActivation), but I think it is worth it since it would remove the performance penalty that some (odd) applications could experience with the current patch.&lt;/p&gt;</comment>
                            <comment id="12430454" author="mayureshnirhali" created="Fri, 25 Aug 2006 10:08:22 +0100"  >&lt;p&gt;Thanks Knut for your suggestions.&lt;/p&gt;

&lt;p&gt;Iterating over Activations vector only when we know that at least one activation is marked unused will save some cycles in case of non-singleUse activations. I have included another flag as you suggested and the patch is attached.&lt;/p&gt;

&lt;p&gt;The fix also includes detailed comments and exception correction.&lt;/p&gt;

&lt;p&gt;I have started a derbyall testrun.&lt;br/&gt;
Let me know if you have any further comments.&lt;/p&gt;</comment>
                            <comment id="12430497" author="knutanders" created="Fri, 25 Aug 2006 14:09:47 +0100"  >&lt;p&gt;Two more comments, and I&apos;ll stop complaining. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1. No need for a try/catch when the catch block only rethrows the exception:&lt;/p&gt;

&lt;p&gt;try &lt;/p&gt;
{
    ....
}
&lt;p&gt; catch (StandardException e) &lt;/p&gt;
{
    throw e;
}

&lt;p&gt;2. In the Derby code, tabs are four characters wide. Apparently, your editor displays tabs as eight characters, so the indentation doesn&apos;t match the surrounding code when viewed in an editor which shows tabs as four characters. Please update your tab settings and reindent the changes.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="12430504" author="mayureshnirhali" created="Fri, 25 Aug 2006 14:34:52 +0100"  >&lt;p&gt;Thanks knut and apologies for missing out on indentation guidelines.&lt;/p&gt;

&lt;p&gt;I have attached another patch integrating both the comments from Knut.&lt;br/&gt;
Comments welcome. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12430512" author="djd" created="Fri, 25 Aug 2006 15:07:58 +0100"  >&lt;p&gt;I think your loop that closes activations needs to include similar logic to htis, from cleanupOnError&lt;/p&gt;

&lt;p&gt;				// it maybe the case that a reset()/close() ends up closing&lt;br/&gt;
				// one or more activation leaving our index beyond&lt;br/&gt;
				// the end of the array&lt;br/&gt;
				if (i &amp;gt;= acts.size())&lt;br/&gt;
					continue;&lt;/p&gt;


&lt;p&gt;Also there is a chance that you clear the unusedActs flag when you shouldn&apos;t. Basically if more activations are marked unused during the time you are closing the others then you will clear the flag when it should be kept set. The clearing of the flag should be before you process the loop.&lt;/p&gt;

&lt;p&gt;E.g. &lt;/p&gt;

&lt;p&gt;    if ( unusedActs )&lt;/p&gt;
     {
       unusedActs  = false;
       close loop
      }

&lt;p&gt;I would also remove the check for size() &amp;gt; 20, I think it&apos;s of no value once you have the unusedActs flag.&lt;/p&gt;</comment>
                            <comment id="12430517" author="knutanders" created="Fri, 25 Aug 2006 15:19:35 +0100"  >&lt;p&gt;Thank you for addressing my comments, Mayuresh!&lt;/p&gt;

&lt;p&gt;I think you misunderstood what I meant with the indentation (you&apos;re not the first one to have problems with this). The files you have changed use tabs to indent the code. The people who created the files used editors with tab stops at four characters. Since your editor has tab stops at eight characters, and you use space as indentation character, you end up indenting the code twice as much as the surrounding code.&lt;/p&gt;

&lt;p&gt;For instance, BaseActivation.java has this diff:&lt;/p&gt;

&lt;p&gt;@@ -787,6 +791,7 @@&lt;br/&gt;
 	public final void markUnused()&lt;/p&gt;
 	{
 		inUse = false;
+                lcc.notifyUnusedActivation();
 	}

&lt;p&gt;The line with inUse = false is indented with two tabs, which should be equivalent to eight spaces. However, the line with lcc.notifyUnusedActivation() is indented with 16 spaces, whereas it should have been on the same indentation level as the previous line. This seems to be the case for all the changed lines.&lt;/p&gt;

&lt;p&gt;Solution: Change the tab settings in your editor and reduce the indentation level of the changed code. Since the surrounding code uses tabs, it would be preferable that the changes used tabs as well, but if you choose to use spaces, one tab character should match four spaces.&lt;/p&gt;

&lt;p&gt;I&apos;m sorry that I didn&apos;t comment on this before, but mixing of tabs and spaces with incorrect tab width is one of those issues that you don&apos;t see when you inspect the patch, only after you have applied the patch and read the source in an editor.&lt;/p&gt;</comment>
                            <comment id="12430982" author="mayureshnirhali" created="Mon, 28 Aug 2006 15:16:02 +0100"  >&lt;p&gt;Thanks Dan for great suggestions.&lt;/p&gt;

&lt;p&gt;I have integrated your suggestions in this latest patch. Regarding the acts.size() &amp;gt; 20 clause, I think it could still be beneficial. With this clause, we can prevent the overhead of iterating through the entire activation vector everytime an activation is marked unused. Since this is a clean up activity, defering the close of unused activations by some time should not cause extra overhead for every such object. let me know if there is anything I am missing here. This clause is not removed in the latest patch.&lt;/p&gt;

&lt;p&gt;I have also reindentated the changed code and it should look fine now.&lt;/p&gt;</comment>
                            <comment id="12431148" author="knutanders" created="Tue, 29 Aug 2006 07:23:29 +0100"  >&lt;p&gt;Thanks Mayuresh. I think the patch looks good. If there are no more comments, I will run some tests and commit the patch tomorrow.&lt;/p&gt;</comment>
                            <comment id="12431170" author="mayureshnirhali" created="Tue, 29 Aug 2006 09:29:16 +0100"  >&lt;p&gt;I have run derbyall on latest trunk with v5 patch, and found 2 failures as below,&lt;/p&gt;

&lt;p&gt;derbyall/derbynetmats/derbynetmats.fail:jdbcapi/blobclob4BLOB.java&lt;br/&gt;
derbyall/derbyall.fail:tools/derbyrunjartest.java&lt;/p&gt;
</comment>
                            <comment id="12431510" author="knutanders" created="Wed, 30 Aug 2006 09:37:17 +0100"  >&lt;p&gt;Derbyall ran cleanly. However, when running the repro for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt; (without rs.close()), I noticed that markUnused() was often called twice for the same activation. This happens because both EmbedPreparedStatement and EmbedResultSet call markUnused() in their finalizers. I think it would be a good idea to wrap the body of markUnused() with &quot;if (isInUse()) &lt;/p&gt;
{ ... }
&lt;p&gt;&quot; to avoid false calls to lcc.notifyUnusedActivation().&lt;/p&gt;</comment>
                            <comment id="12431519" author="mayureshnirhali" created="Wed, 30 Aug 2006 10:51:07 +0100"  >&lt;p&gt;Thanks Knut, for catching that!&lt;/p&gt;

&lt;p&gt;I have attached a new patch with changes suggested by Knut, derby418_v6.diff.&lt;/p&gt;</comment>
                            <comment id="12432127" author="knutanders" created="Fri, 1 Sep 2006 12:58:43 +0100"  >&lt;p&gt;Thank you, Mayuresh! Committed v6 into trunk (rev 439279) and 10.2 (rev 439281).&lt;/p&gt;</comment>
                            <comment id="12864271" author="kristwaa" created="Wed, 5 May 2010 12:06:47 +0100"  >&lt;p&gt;Closing issue.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12370141">DERBY-2689</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12311039" name="AutoCommitTest.java" size="8636" author="skambha" created="Fri, 1 Jul 2005 06:37:19 +0100"/>
                            <attachment id="12339411" name="derby418_v1.diff" size="1529" author="mayureshnirhali" created="Wed, 23 Aug 2006 14:20:10 +0100"/>
                            <attachment id="12339481" name="derby418_v2.diff" size="3636" author="mayureshnirhali" created="Thu, 24 Aug 2006 13:50:13 +0100"/>
                            <attachment id="12339553" name="derby418_v3.diff" size="4887" author="mayureshnirhali" created="Fri, 25 Aug 2006 10:08:22 +0100"/>
                            <attachment id="12339569" name="derby418_v4.diff" size="4624" author="mayureshnirhali" created="Fri, 25 Aug 2006 14:34:52 +0100"/>
                            <attachment id="12339698" name="derby418_v5.diff" size="4327" author="mayureshnirhali" created="Mon, 28 Aug 2006 15:16:02 +0100"/>
                            <attachment id="12339851" name="derby418_v6.diff" size="4378" author="mayureshnirhali" created="Wed, 30 Aug 2006 10:51:07 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 20 Jul 2006 12:24:02 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21947</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0qif:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38113</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>