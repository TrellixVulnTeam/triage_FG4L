<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:31:29 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3253/DERBY-3253.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3253] NullPointer Exception (NPE) from query with IN predicate containing two values and joining a view with a large table.  ERROR 38000: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3253</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;With a single value in the IN clause the query does not fail.&lt;br/&gt;
 &amp;gt; Run the following query in the attached database (v 10.3 db).  &lt;/p&gt;

&lt;p&gt;SELECT A.TIMESTAMP, B.F_NAMEADDR, B.TOTAL_F,&lt;br/&gt;
B.TOTAL_FS, B.TOTAL_FT, B.TOTAL_FX&lt;br/&gt;
FROM  TIME A, THE_VIEW B&lt;br/&gt;
WHERE B.T_ID = A.T_ID AND B.F_NAMEADDR IN (&apos;one.two.three.oscar&apos;,&apos;one.two.three.kathy&apos;)&lt;br/&gt;
ORDER BY A.TIMESTAMP ASC;&lt;/p&gt;

&lt;p&gt;&amp;gt; result&lt;/p&gt;

&lt;p&gt;ERROR 38000: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.&lt;br/&gt;
ERROR XJ001: Java exception: &apos;: java.lang.NullPointerException&apos;.&lt;/p&gt;

&lt;p&gt;Stack trace:&lt;br/&gt;
 Failed Statement is: SELECT A.TIMESTAMP, B.F_NAMEADDR, B.TOTAL_F,&lt;br/&gt;
B.TOTAL_FS, B.TOTAL_FT, B.TOTAL_FX&lt;br/&gt;
FROM  TIME A, THE_VIEW B&lt;br/&gt;
WHERE B.T_ID = A.T_ID AND B.F_NAMEADDR IN (&apos;one.two.three.oscar&apos;,&apos;one.two.three.kathy&apos;)&lt;br/&gt;
ORDER BY A.TIMESTAMP ASC&lt;br/&gt;
ERROR 38000: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.unexpectedUserException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.getRowFromResultSet(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.getNextRowFromRS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.loadSorter(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.openCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main14.main(Unknown Source)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(Unknown Source)&lt;br/&gt;
Caused by: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.exe.ac601a400fx0116xa813xc2f7x00000010a3602.e8(Unknown Source)&lt;br/&gt;
	... 21 more&lt;br/&gt;
============= begin nested exception, level (1) ===========&lt;br/&gt;
java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.exe.ac601a400fx0116xa813xc2f7x00000010a3602.e8(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.getRowFromResultSet(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.getNextRowFromRS(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.loadSorter(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.openCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main14.main(Unknown Source)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(Unknown Source)&lt;br/&gt;
============= end nested exception, level (1) ===========&lt;/p&gt;

&lt;p&gt;Schema info:&lt;/p&gt;

&lt;p&gt;CREATE TABLE TIME (&quot;T_ID&quot; BIGINT NOT NULL, &quot;TIMESTAMP&quot; TIMESTAMP NOT NULL, &quot;DAY&quot; INTEGER NOT NULL, &quot;WEEK&quot; INTEGER NOT NULL, &quot;MONTH&quot; INTEGER NOT NULL, &quot;YEAR_COL&quot; INTEGER NOT NULL);&lt;/p&gt;

&lt;p&gt;CREATE TABLE F  (&quot;F_ID&quot; BIGINT NOT NULL, &quot;T_ID&quot; BIGINT NOT NULL, &quot;F_NAMEADDR&quot; VARCHAR(250) NOT NULL, &quot;TOTAL_F&quot; BIGINT NOT NULL, &quot;TOTAL_FS&quot; BIGINT NOT NULL, &quot;TOTAL_FT&quot; BIGINT NOT NULL, &quot;TOTAL_FX&quot; BIGINT NOT NULL);&lt;/p&gt;

&lt;p&gt;CREATE VIEW the_view AS SELECT  T.T_ID  AS T_ID ,   T.F_NAMEADDR AS F_NAMEADDR,&lt;br/&gt;
 T.TOTAL_F AS TOTAL_F,  T.TOTAL_FS AS TOTAL_FS,  T.TOTAL_FT AS TOTAL_FT  , T.TOTAL_FX AS TOTAL_FX &lt;br/&gt;
   FROM    F AS T &lt;br/&gt;
    WHERE   T.T_ID = (SELECT MAX(T_ID) FROM F);&lt;/p&gt;</description>
                <environment></environment>
        <key id="12383938">DERBY-3253</key>
            <summary>NullPointer Exception (NPE) from query with IN predicate containing two values and joining a view with a large table.  ERROR 38000: The exception &apos;java.lang.NullPointerException&apos; was thrown while evaluating an expression.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="stan">Stan Bradbury</reporter>
                        <labels>
                    </labels>
                <created>Wed, 5 Dec 2007 02:18:51 +0000</created>
                <updated>Tue, 30 Jun 2009 16:55:42 +0100</updated>
                            <resolved>Wed, 19 Dec 2007 17:04:57 +0000</resolved>
                                    <version>10.3.1.4</version>
                    <version>10.3.2.1</version>
                    <version>10.4.1.3</version>
                                    <fixVersion>10.3.3.0</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12548515" author="stan" created="Wed, 5 Dec 2007 02:22:26 +0000"  >&lt;p&gt;The database with two tables and view definition needed to demonstrate this bug.&lt;/p&gt;</comment>
                            <comment id="12548720" author="army" created="Wed, 5 Dec 2007 16:38:47 +0000"  >&lt;p&gt;Based on a quick test it looks like this is a regression caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12549191" author="army" created="Thu, 6 Dec 2007 20:59:38 +0000"  >&lt;p&gt;Not sure if this a direct result of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, or if &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; just changed execution plans such that another problem is now exposed, see esp. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3097&quot; title=&quot;Unnecessary if statement can be removed from BaseActivation.getColumnFromNow&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3097&quot;&gt;&lt;del&gt;DERBY-3097&lt;/del&gt;&lt;/a&gt; and related discussion.&lt;/p&gt;</comment>
                            <comment id="12551682" author="army" created="Fri, 14 Dec 2007 04:01:07 +0000"  >&lt;p&gt;A surprisingly simple repro of this NPE can be created as follows:&lt;/p&gt;

&lt;p&gt;  create table t1 (i int, vc varchar(10));&lt;br/&gt;
  insert into t1 values (1, &apos;one&apos;), (2, &apos;two&apos;), (3, &apos;three&apos;), (1, &apos;un&apos;);&lt;/p&gt;

&lt;p&gt;  select * from t1, (select * from t1) x&lt;br/&gt;
    where t1.i = x.i and x.vc in (&apos;un&apos;, &apos;trois&apos;);&lt;/p&gt;

&lt;p&gt;The key here is that the IN list&apos;s left operand points to a column from the subselect, X.VC.  As part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;, the IN list will be changed into a BinaryRelationalOperatorNode of the form &quot;X.VC = ?&quot;, and that node, which we call a &quot;probe predicate&quot;, will serve to represent the IN list operator throughout the various phases of optimization.&lt;/p&gt;

&lt;p&gt;That said, as part of preprocessing Derby will look at the query and realize that the sub-select can be flattened.  When flattening the subquery, any references to the subquery&apos;s RCL will be remapped to point to the underlying expression.  That means the left operand of the probe predicate &quot;X.VC = ?&quot; will be changed to point directly to column &quot;VC&quot; of table T1.  The code where this happens is in the &quot;flatten&quot; method of FromSubquery:&lt;/p&gt;

&lt;p&gt;        /* Remap all ColumnReferences from the outer query to this node.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;(We replace those ColumnReferences with clones of the matching&lt;/li&gt;
	&lt;li&gt;expression in the SELECT&apos;s RCL.&lt;br/&gt;
         */&lt;br/&gt;
        rcl.remapColumnReferencesToExpressions();&lt;br/&gt;
        outerPList.remapColumnReferencesToExpressions();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For the example query above, outerPList holds the two predicates &quot;T1.I = X.I&quot; and &quot;X.VC = ?&quot;, so we will attempt to remap the column references in those two predicates.  That brings us to the remapColumnReferencesToExpressions() method of BinaryOperatorNode, where we have:&lt;/p&gt;

&lt;p&gt;    public ValueNode remapColumnReferencesToExpressions()&lt;br/&gt;
        throws StandardException&lt;/p&gt;
    {
        leftOperand = leftOperand.remapColumnReferencesToExpressions();
        rightOperand = rightOperand.remapColumnReferencesToExpressions();
        return this;
    }

&lt;p&gt;Notice how the leftOperand can change here--and in the above query, it &lt;b&gt;will&lt;/b&gt; change to point directly to T1 instead of indirectly to the subquery.  So now the probe predicate&apos;s left operand is different from the left operand of the original InListOperatorNode that the probe predicate replaced. That in it itself is fine, but it causes problems later.&lt;/p&gt;

&lt;p&gt;Namely, when it comes time to generate the final tree for the query, we realize that the probe predicate is not &quot;useful&quot; for probing because it references &quot;VC&quot;, which is the second column in table T1.  Since probe predicates are only useful if they reference the first column in the table, per &quot;orderUsefulPredicates(...)&quot; of PredicateList.java: &lt;/p&gt;

&lt;p&gt;            else if (pred.isInListProbePredicate()&lt;br/&gt;
                    &amp;amp;&amp;amp; (indexPosition &amp;gt; 0))&lt;br/&gt;
            {&lt;br/&gt;
                /* If the predicate is an IN-list probe predicate&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;then we only consider it to be useful if the&lt;/li&gt;
	&lt;li&gt;referenced column is the &lt;b&gt;first&lt;/b&gt; one in the&lt;/li&gt;
	&lt;li&gt;index (i.e. if (indexPosition == 0)).  Otherwise&lt;/li&gt;
	&lt;li&gt;the predicate would be treated as a qualifier&lt;/li&gt;
	&lt;li&gt;for store, which could lead to incorrect&lt;/li&gt;
	&lt;li&gt;results.&lt;br/&gt;
                 */&lt;br/&gt;
             ....&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;the probe predicate is not useful.  That in turn means that when it comes time to generate the IN list operator, we&apos;ll &quot;revert&quot; back to the original InListOperatorNode--i.e. we will generate the InListOperatorNode &lt;b&gt;instead of&lt;/b&gt; generating the probe predicate.  This is found in the generateExpression() method of BinaryOperatorNode:&lt;/p&gt;

&lt;p&gt;            if (ilon != null)&lt;/p&gt;
            {
                ilon.generateExpression(acb, mb);
                return;
            }

&lt;p&gt;But there&apos;s a problem here: as mentioned above, ilon (the InListOperatorNode) still has a left operand that points to a column from the &lt;b&gt;subquery&lt;/b&gt;.  Since we flattened the subquery out, that left operand is no longer valid--and that ultimately causes an execution time NPE because we try to apply the IN list restriction to a column from a subquery that does not exist.&lt;/p&gt;

&lt;p&gt;I tried a one-line fix to this code that seems to have resolved the issue:&lt;/p&gt;

&lt;p&gt;            if (ilon != null)&lt;/p&gt;
            {
                ilon.setLeftOperand(this.leftOperand); // Added this line
                ilon.generateExpression(acb, mb);
                return;
            }

&lt;p&gt;(with appropriate code comments, of course).&lt;/p&gt;

&lt;p&gt;This has the effect of making sure that when we &quot;revert&quot; back to the original InListOperatorNode generation, we&apos;ll still generate the correct leftOperand--i.e. the left operand as it exists in the &quot;probe predicate&quot; upon completion of optimization.&lt;/p&gt;

&lt;p&gt;I&apos;m attaching this small fix as d3253_v1.patch.  I have yet to run the regression tests (they are running now), but I thought I&apos;d post my findings for early review in the interim...&lt;/p&gt;</comment>
                            <comment id="12551824" author="bryanpendleton" created="Fri, 14 Dec 2007 15:13:08 +0000"  >&lt;p&gt;Hi Army, thanks for taking the time to explain this in detail.&lt;/p&gt;

&lt;p&gt;Restating what I think I heard you say:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;when we remap the predicate&apos;s column references during flattening,&lt;br/&gt;
   we modify the leftOperand of the InListOperatorNode, but when we&lt;br/&gt;
   generate the InListOperatorNode&apos;s expression (rather than the probe&lt;br/&gt;
   predicate&apos;s expression), we &quot;recover&quot; the InListOperatorNode&apos;s&lt;br/&gt;
   leftOperand from its BinaryOperatorNode&apos;s parent.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Did I follow your explanation correctly?&lt;/p&gt;

&lt;p&gt;If so, it seems like it might be (slightly) cleaner if the logic were&lt;br/&gt;
centralized in the InListOperatorNode itself, perhaps by defining an&lt;br/&gt;
extra field in the node to hold the &quot;before remapping&quot; version of&lt;br/&gt;
the leftOperand so that we can use that value rather than the remapped&lt;br/&gt;
leftOperand during generateExpression.&lt;/p&gt;

&lt;p&gt;I&apos;m just trying to avoid having code where BinaryOperatorNode corrects&lt;br/&gt;
for a problem that is occuring in a child node; I always worry when I&lt;br/&gt;
see class A having code that corrects the behavior of class B.&lt;/p&gt;</comment>
                            <comment id="12551848" author="army" created="Fri, 14 Dec 2007 16:23:58 +0000"  >&lt;p&gt;&amp;gt; Did I follow your explanation correctly? &lt;/p&gt;

&lt;p&gt;Sorry, I think I messed up the explanation slightly.  The order of events is:&lt;/p&gt;

&lt;p&gt;  &amp;#8211; Preprocess InListOperatorNode, which has some left operand OP_0, and convert it&lt;br/&gt;
    into a &quot;probe predicate&quot;, which is a BinaryRelationalOperatorNode.  That probe&lt;br/&gt;
    predicate does two things: 1) assumes its left operand from InListOperatorNode,&lt;br/&gt;
    i.e. the probe predicate&apos;s left operand is OP_0, as well; and 2) stores a pointer&lt;br/&gt;
    to the InListOperatorNode so that, if needed, the probe predicate can &quot;revert&quot; back&lt;br/&gt;
    to the InListOperatorNode at generation time.  Upon completion of the preprocess&lt;br/&gt;
    phase for InListOperatorNode, the new probe predicate and the original InListOperatorNode&lt;br/&gt;
    both have the same left operand (OP_0)&lt;/p&gt;

&lt;p&gt;  &amp;#8211; Preprocess the subquery node, which involves flattening it.  As part of flattening&lt;br/&gt;
    the &lt;b&gt;probe predicate&lt;/b&gt;&apos;s left operand (&lt;b&gt;not&lt;/b&gt; the InListOperatorNode&apos;s left operand) &lt;br/&gt;
    changes to OP_1; this is because it (the probe predicate) now represents the&lt;br/&gt;
    IN operation for the query tree, not the InListOperatorNode. So the InListOperatorNode &lt;br/&gt;
    remains the same after flattening--i.e. its left operand is still OP_0.  That&lt;br/&gt;
    means the probe predicate and the InListOperatorNode have now different&lt;br/&gt;
    left operands.&lt;/p&gt;

&lt;p&gt;  &amp;#8211; Optimization completes, we decide that the probe predicate is not useful.&lt;/p&gt;

&lt;p&gt;  &amp;#8211; During code generation, we see that the probe predicate is not useful so we &quot;revert&quot;&lt;br/&gt;
    back to the original InListOperatorNode by calling &quot;generate&quot; on that node (which we&lt;br/&gt;
    stored inside the probe predicate (BinaryRelationalOperatorNode) at the beginning,&lt;br/&gt;
    per #2 of the first bullet above).  But since the InListOperatorNode still has the old&lt;br/&gt;
    operand OP_0, it generates the wrong column reference.&lt;/p&gt;

&lt;p&gt;&amp;gt; If so, it seems like it might be (slightly) cleaner if the logic were&lt;br/&gt;
&amp;gt; centralized in the InListOperatorNode itself,&lt;/p&gt;

&lt;p&gt;I don&apos;t think this is possible-&lt;del&gt;or at least, not straightforward&lt;/del&gt;&lt;del&gt;because once the probe predicate comes into the picture, it (the probe predicate) becomes the focus of all method calls related to the IN list&lt;/del&gt;-so the only way to keep the InListOperatorNode up to date would be to add logic in BinaryRelationalOperatorNode that sends all method calls relating to leftOperand on down to the InListOperatorNode, as well.  Note that doing so would require that the logic go into BinaryRelationalOperatorNode, not into InListOperatorNode.&lt;/p&gt;

&lt;p&gt;That was the way I was leaning when I first started, but a) that would require more logic in more places in BinaryRelationalOperatorNode to propagate operations down to the InListOperatorNode, and b) it seemed like the odds of missing some leftOperand operation could be non-neglible for very compilcated queries (just a theory, I didn&apos;t actually investigate this further).  That said, it seemed like doing a single &quot;setLeftOperand()&quot; call at generation time was the preferable mechanism.&lt;/p&gt;

&lt;p&gt;I am of course open to change if you think this there is a better approach?&lt;/p&gt;

&lt;p&gt;Thanks for the feedback!&lt;/p&gt;</comment>
                            <comment id="12551860" author="bryanpendleton" created="Fri, 14 Dec 2007 17:07:54 +0000"  >&lt;p&gt;The flow of execution makes more sense now, thanks for filling it in more completely.&lt;/p&gt;

&lt;p&gt;So when we revert from the probe predicate back to the original in-list-op, the problem&lt;br/&gt;
is that the original in-list-op reflects the unflattened query, and since we&apos;ve decided&lt;br/&gt;
to flatten the query, it refers to a result set that no longer exists?&lt;/p&gt;

&lt;p&gt;Then I think when we perform the flattening, the probe predicate should ensure&lt;br/&gt;
that it not only re-maps its own column references, but also calls the in-list that&lt;br/&gt;
it&apos;s stashed away, and gives the in-list a chance to re-map its column references.&lt;/p&gt;

&lt;p&gt;That is: perform flatten remapping for &lt;b&gt;both&lt;/b&gt; predicates, so that whichever one we&lt;br/&gt;
eventually decide to use, it correctly matches the overall query tree.&lt;/p&gt;

&lt;p&gt;I guess that is basically the approach you were describing when you said &lt;/p&gt;

&lt;p&gt;   &quot;the only way to keep the InListOperatorNode up to date would be to add logic in &lt;br/&gt;
    BinaryRelationalOperatorNode that sends all method calls relating to&lt;br/&gt;
     leftOperand on down to the InListOperatorNode, as well.&quot;&lt;/p&gt;

&lt;p&gt;It seems like the &quot;probe predicate&quot; is this nifty shape-shifting operator that&lt;br/&gt;
says: &quot;I&apos;d like to be a multi-probe index operator, but if it turns out I can&apos;t be,&lt;br/&gt;
then I&apos;ll switch back and be an IN list instead. Until we decide, I&apos;ll retain enough&lt;br/&gt;
information that I can be either operator.&quot; Given that perspective, to me&lt;br/&gt;
it seems valid that the code has to be routinely passing method calls to both&lt;br/&gt;
variants of the operator, since in a sense it &lt;b&gt;is&lt;/b&gt; both variants of the operator,&lt;br/&gt;
simultaneously, until at some crucial instant the optimizer determines that&lt;br/&gt;
it can finalize the decision as to which variant to use.&lt;/p&gt;</comment>
                            <comment id="12552317" author="army" created="Mon, 17 Dec 2007 03:06:00 +0000"  >&lt;p&gt;Hi Bryan,&lt;/p&gt;

&lt;p&gt;Thank you for your continued feedback.&lt;/p&gt;

&lt;p&gt;I&apos;m attaching two files.  The first is d3253_v2_incomplete.patch, which was my first attempt at addressing the issue in the &quot;other&quot; way, i.e.:&lt;/p&gt;

&lt;p&gt;&amp;gt; add logic in BinaryRelationalOperatorNode that sends all method calls&lt;br/&gt;
&amp;gt; relating to leftOperand on down to the InListOperatorNode, as well.&lt;/p&gt;

&lt;p&gt;I tried the obvious places where this had to be done and the error reported for this issue did indeed disappear.  However, running more complicated queries with that approach leads to &lt;b&gt;other&lt;/b&gt; execution-time NullPointerExceptions, plus a few changed query plans.  When I applied the patch and ran derbyall there were four test failures, all of which suffered from at least one execution-time NPE:&lt;/p&gt;

&lt;p&gt;  derbyall/derbyall.fail:lang/inbetween.sql&lt;br/&gt;
  derbyall/derbyall.fail:lang/predicatePushdown.sql&lt;br/&gt;
  derbyall/derbyall.fail:lang/predicatesIntoViews.sql&lt;br/&gt;
  derbyall/derbyall.fail:lang/subquery.sql&lt;/p&gt;

&lt;p&gt;I looked briefly into this to try to figure out what the problem was, but I admit that I gave up pretty quickly.  In order to be sure that this approach works, I think we&apos;d have to 1) look through all of the code to find any place that retrieved the left operand of a BinaryRelationalOperatorNode, 2) check to see if that place made any changes to the left operand in any way (direct or indirect), and 3) if changes were made, add logic to propagate those changes down to left operand of the InListOperatorNode that is tucked away inside the BinaryRelationalOperatorNode (if there is one).  Does that sound correct to you?  Or am I making this too complicated?&lt;/p&gt;

&lt;p&gt;The fact that just hitting what I thought to be the &quot;basics&quot; causes failures leads me back to my original assessment of this approach: &lt;/p&gt;

&lt;p&gt;&amp;gt; a) that would require more logic in more places in BinaryRelationalOperatorNode&lt;br/&gt;
&amp;gt; to propagate operations down to the InListOperatorNode, and b) it seems like&lt;br/&gt;
&amp;gt; the odds of missing some leftOperand operation could be non-neglible for very&lt;br/&gt;
&amp;gt; complicated queries.&lt;/p&gt;

&lt;p&gt;You mentioned:&lt;/p&gt;

&lt;p&gt;&amp;gt; it seems valid that the code has to be routinely passing method calls to both&lt;br/&gt;
&amp;gt; variants of the operator, since in a sense it &lt;b&gt;is&lt;/b&gt; both variants of the operator,&lt;br/&gt;
&amp;gt; simultaneously, until at some crucial instant the optimizer determines that&lt;br/&gt;
&amp;gt; it can finalize the decision as to which variant to use.&lt;/p&gt;

&lt;p&gt;Is this in some way saying that instead of &quot;do the work once and apply the result to the correct place&quot;, we&apos;d be opting for &quot;do the work twice and then throw one of the results away&quot;?  Given the fact the doing the work a &quot;second&quot; time affects more code and is more error-prone, I wonder if that is really the best approach?  Regardless of which &quot;version&quot; of the operator we use, there should only be one correct form for the left operand when it comes time to generate code--and that should be exactly same between the two &quot;versions&quot;.  So if we have the operand in its correct form, it seems reasonable to just push it to the right place for code generation...&lt;/p&gt;

&lt;p&gt;I fully admit that I may be biased here and that my bias may be keeping from seeing a silly mistake (or omission) in my attempt at this approach.  So I&apos;ve attached my changes to this issue (d3253_v2_incomplete.patch); please feel free to look at it and to clean it up if there&apos;s anything obvious I missed.  My apologies in advance if that proves to be the case.&lt;/p&gt;

&lt;p&gt;I&apos;m also attaching a second file, d3253_v3.patch, which is a slight variation of the _v1 patch.  With this approach we still use the &quot;setLeftOperand(this.leftOperand)&quot; approach seen in _v1, but instead of doing it once at code generation time, we do it as part of the BinaryRelationalOperatorNode.getInListOp() method.  That is to say, any time any caller tries to access the InListOperatorNode that sits beneath a &quot;probe predicate&quot;, we ensure that the InListOperatorNode has a valid, up-to-date left operand-&lt;del&gt;which comes from the probe predicate itself&lt;/del&gt;-before returning it to the caller.  This solves the issue, and passes all regression tests.&lt;/p&gt;

&lt;p&gt;I feel like _v3 is the best of the three approaches.  It has more changes than _v1 but unlike _v1, it ensures that &lt;b&gt;any&lt;/b&gt; code which accesses the underlying InListOperatorNode will see a left operand that has the correct information.  It also seems a tad more maintainable than _v2 since the latter requires that any future code which directly or indirectly changes a BinaryRelationalOperatorNode&apos;s left operand must also account for the possibility that such a node is a probe predicate with an underlying InListOperatorNode.&lt;/p&gt;

&lt;p&gt;I&apos;d like to proceed with the _v3 patch as my proposed solution.  If it is still generally felt that _v2 is the best overall approach, then perhaps I can go ahead with the _v3 approach for now and anyone who is so inclined can implement the _v2 approach as a longer term solution.  Does that seem like an acceptable proposal, or do you think that _v3 is in itself an incorrect or un-commitable fix?&lt;/p&gt;</comment>
                            <comment id="12552607" author="bryanpendleton" created="Tue, 18 Dec 2007 03:00:20 +0000"  >&lt;p&gt;I think the _v3 patch is a good one; I like the approach of the patch. Thank you&lt;br/&gt;
for adding the comments, they are quite clear. I think that the manipulation&lt;br/&gt;
of the leftOperand field is well encapsulated with this approach.&lt;/p&gt;

&lt;p&gt;I downloaded and reviewed the _v3 patch against the current trunk.&lt;br/&gt;
In my environment, the new regression test fails as expected without the&lt;br/&gt;
code changes from the patch, and passes with the code changes applied.&lt;/p&gt;

&lt;p&gt;Thank you again for taking the time to explore the various alternatives&lt;br/&gt;
in detail, and for explaining how the processing works, it has been quite&lt;br/&gt;
illuminating and I&apos;ve learned a lot from observing your work.&lt;/p&gt;

&lt;p&gt;+1 to commit from me!&lt;/p&gt;</comment>
                            <comment id="12553404" author="army" created="Wed, 19 Dec 2007 17:04:57 +0000"  >&lt;p&gt;Committed d3253_v3.patch with svn #605616:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=605616&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=605616&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Many thanks (again) to Bryan for the review and discussion--I appreciate your time!  I ran the svn merge command to port this back to 10.3 and it merged with no errors:&lt;/p&gt;

&lt;p&gt;  svn merge -r 605615:605616 &lt;a href=&quot;https://svn.apache.org/repos/asf/db/derby/code/trunk&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/repos/asf/db/derby/code/trunk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&apos;ll kick off the 10.3 regression tests today.  If they pass and if no issues arise in trunk for the new couple of days, I plan to commit to 10.3 by the end of the week...&lt;/p&gt;</comment>
                            <comment id="12554004" author="army" created="Fri, 21 Dec 2007 19:23:25 +0000"  >&lt;p&gt;Update Fix Version to reflect that this has now been ported back to 10.3, as of:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=606277&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=606277&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12559983" author="dyret" created="Thu, 17 Jan 2008 16:37:57 +0000"  >&lt;p&gt;Stan, do you think we can close this now?&lt;/p&gt;</comment>
                            <comment id="12562285" author="stan" created="Thu, 24 Jan 2008 23:07:58 +0000"  >&lt;p&gt;Catching up on Closing my reported issues.  Thanks to Dyre for the workflow reminder today.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12389532">DERBY-3464</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="27899">DERBY-47</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12370993" name="3253ReproDB.zip" size="2277741" author="stan" created="Wed, 5 Dec 2007 02:22:26 +0000"/>
                            <attachment id="12371649" name="d3253_v1.patch" size="4769" author="army" created="Fri, 14 Dec 2007 04:01:02 +0000"/>
                            <attachment id="12371772" name="d3253_v2_incomplete.patch" size="10490" author="army" created="Mon, 17 Dec 2007 03:06:00 +0000"/>
                            <attachment id="12371773" name="d3253_v3.patch" size="9230" author="army" created="Mon, 17 Dec 2007 03:06:00 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 5 Dec 2007 16:38:47 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23525</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0uz3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38836</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>