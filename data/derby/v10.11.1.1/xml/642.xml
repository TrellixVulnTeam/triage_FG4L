<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:39:12 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-642/DERBY-642.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-642] SELECT MAX doesn&apos;t use indices optimally</title>
                <link>https://issues.apache.org/jira/browse/DERBY-642</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I tried running SELECT MAX on an indexed column in a big (8 GB)&lt;br/&gt;
table. It took 12 minutes, which is about 12 minutes more than I&lt;br/&gt;
expected.&lt;/p&gt;

&lt;p&gt;After a bit of investigation, I found out that a full index scan was&lt;br/&gt;
performed because all the rows referenced from the rightmost B-tree&lt;br/&gt;
node were actually deleted.&lt;/p&gt;

&lt;p&gt;Possible improvements:&lt;/p&gt;

&lt;p&gt;  1. Implement backwards scan in the B-trees (this is also suggested&lt;br/&gt;
     in the comments in BTreeMaxScan).&lt;/p&gt;

&lt;p&gt;  2. Go up to the parent node and down to the next leaf node on the&lt;br/&gt;
     left side, and continue until a valid max value is found. In&lt;br/&gt;
     Derby, traversing up in a B-tree is not allowed, but would it be&lt;br/&gt;
     ok to go up if the latches were kept on the higher-level nodes in&lt;br/&gt;
     the tree? Of course, this would have negative impact on&lt;br/&gt;
     concurrency.&lt;/p&gt;

&lt;p&gt;  3. Right-to-left traversal on the leaf level is possible (using&lt;br/&gt;
     ControlRow.getLeftSibling()), but will throw an exception if the&lt;br/&gt;
     page cannot be latched without waiting. It is therefore possible&lt;br/&gt;
     to try a right-to-left search for the max value, and only fall&lt;br/&gt;
     back to the left-to-right approach if a conflict arises.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12324975">DERBY-642</key>
            <summary>SELECT MAX doesn&apos;t use indices optimally</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 25 Oct 2005 00:54:10 +0100</created>
                <updated>Thu, 30 Jun 2011 10:21:44 +0100</updated>
                            <resolved>Mon, 7 Mar 2011 13:27:40 +0000</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.8.1.2</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12355642" author="mikem" created="Tue, 25 Oct 2005 02:52:15 +0100"  >&lt;p&gt;The current  implementation was done as  a way to get 90% for a very small amount of work - it was not a technical decision, simply a scheduling one.&lt;/p&gt;

&lt;p&gt;Option 1 would be the best technical decision, but is the hardest. &amp;#8211; but the&lt;br/&gt;
store work is not extremely hard just some care needs to be taken to handle&lt;br/&gt;
the messy case of when latching going backward needs to wait.  Basically&lt;br/&gt;
when going right to left you must request the latch NOWAIT, and if you can&apos;t&lt;br/&gt;
get the latch you need to code a way to save your current position in the&lt;br/&gt;
tree, release all current latches, and wait for the desired latch.  Once you&lt;br/&gt;
have the latch then you have to refind your current position as it may have&lt;br/&gt;
moved (but I believe it can only have moved right of the page you are on in the&lt;br/&gt;
current btree implementation - implementer would need to verify that).&lt;/p&gt;

&lt;p&gt;If a real backward scan were implemented, then the next obvious step would&lt;br/&gt;
be to teach the optimizer about it so that it could use it in plans.  Doing it &lt;br/&gt;
first for max would be a reasonable 1st step in a phased implementation&lt;br/&gt;
approach.  The second step would be to change the store interfaces to allow for a backward scan, and then finally change the language layer to actually&lt;br/&gt;
use the backward scans.&lt;/p&gt;

&lt;p&gt;Option 3 would be an interesting extension to the &quot;do what is easy&quot; approach, &lt;br/&gt;
it would be significantly easier than option 1.  &lt;/p&gt;

&lt;p&gt;Not sure about option 2, it sounds deadlock prone - but  could work if you &lt;br/&gt;
paid the cost of more latches and less concurrency.  &lt;/p&gt;</comment>
                            <comment id="12424233" author="kmarsden" created="Sat, 29 Jul 2006 00:58:59 +0100"  >&lt;p&gt;removing from 10.2. see:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/10.2-High-Value-Fix-Candidates-and-Fix-Version-Adjustments-tf2007999.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/10.2-High-Value-Fix-Candidates-and-Fix-Version-Adjustments-tf2007999.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12984126" author="knutanders" created="Thu, 20 Jan 2011 10:34:21 +0000"  >&lt;p&gt;This issue doesn&apos;t only affect the case where all the values in the rightmost leaf of the B-tree are deleted. Since NULL values sort higher than non-NULL values in Derby&apos;s B-trees, and NULL values are not considered by the MAX function, if there are enough rows with NULL in the indexed column to fill one page, the MAX scan won&apos;t find a maximum value in the rightmost leaf and will have to fall back to scanning the B-tree from the beginning.&lt;/p&gt;</comment>
                            <comment id="12992626" author="knutanders" created="Wed, 9 Feb 2011 18:11:26 +0000"  >&lt;p&gt;Here&apos;s a patch that attempts to solve this issue by scanning the&lt;br/&gt;
B-tree backwards to find the maximum value, along the lines sketched&lt;br/&gt;
out in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-884&quot; title=&quot;allow and use backward scans on indexes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-884&quot;&gt;DERBY-884&lt;/a&gt;. The patch is not ready for commit yet since it&lt;br/&gt;
contains no tests and some comments in the BTreeMaxScan still describe&lt;br/&gt;
the old behaviour. There are also some parts that need a little more&lt;br/&gt;
investigation, see more below.&lt;/p&gt;

&lt;p&gt;The patch passes suites.All and derbyall, and I have been able to&lt;br/&gt;
exercise most of the new code in manual tests and it seems to be&lt;br/&gt;
well-behaved. Some of the code paths are very difficult to test&lt;br/&gt;
reliably, though, since they&apos;re so timing dependent.&lt;/p&gt;

&lt;p&gt;The patch changes the code the following way:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;BTreeScan.java:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added a new method positionAtPreviousPage(), which is similar to&lt;br/&gt;
positionAtNextPage() except that it moves in the opposite direction&lt;br/&gt;
and that it throws a WaitError instead of waiting for a latch in case&lt;br/&gt;
of a conflict.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Another difference is that positionAtPreviousPage() skips empty leaf&lt;br/&gt;
pages. This is to avoid the problem with saving the current position&lt;br/&gt;
when there is no key to save on the current page. When scanning in the&lt;br/&gt;
forward direction, we only save the position when we have to wait for&lt;br/&gt;
a row lock or we have filled the internal fetch buffer. In both cases&lt;br/&gt;
we are positioned on a row when we save the position, and then we just&lt;br/&gt;
need to store the key on the current row in order to save the&lt;br/&gt;
position.&lt;/p&gt;

&lt;p&gt;When scanning in the backward direction, however, we may also have to&lt;br/&gt;
save the position when moving from one leaf page to its sibling page,&lt;br/&gt;
if the sibling page cannot be latched immediately. Leaf pages can be&lt;br/&gt;
empty, and then there is no key on the page that we can store and use&lt;br/&gt;
for repositioning later. So in order to be sure that we have a&lt;br/&gt;
position to save in the case where we have to wait for a latch,&lt;br/&gt;
positionAtPreviousPage() holds the latch on the current page until it&lt;br/&gt;
finds the first non-empty leaf page on its left side.&lt;/p&gt;

&lt;p&gt;BTreeMaxScan.java:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed the method fetchMaxRowFromBeginning(), since the code now&lt;br/&gt;
always fetches the max row from the end.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Made fetchMax() continue on the previous page instead of giving up&lt;br/&gt;
and starting from the beginning in case no qualifying row is found on&lt;br/&gt;
the last page.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Made fetchMax() reposition using the saved position in case of a&lt;br/&gt;
lock conflict. Previously, it would have started a full scan from the&lt;br/&gt;
beginning of the index in that case.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added new method moveToLeftSibling(), used by fetchMax() to move to&lt;br/&gt;
the logically next page. This method saves the current position if&lt;br/&gt;
positionAtPreviousPage() throws a WaitError so that fetchMax() can&lt;br/&gt;
release all latches and reposition on the exact same spot.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Some things that differ between repositioning in the forward direction&lt;br/&gt;
and in the backward direction:&lt;/p&gt;

&lt;p&gt;a) As mentioned above, we may need to save the position when moving&lt;br/&gt;
from one page to another, and saving the position by key value isn&apos;t&lt;br/&gt;
possible if the current page is empty. positionAtPreviousPage() skips&lt;br/&gt;
empty pages so that we won&apos;t have to save the position on an empty&lt;br/&gt;
page mid-scan. However, the rightmost leaf page may be empty, in which&lt;br/&gt;
case the scan starts on an empty page. If we need to wait for a latch&lt;br/&gt;
when moving from the rightmost leaf and that leaf is empty, we don&apos;t&lt;br/&gt;
attempt to save the position. Instead of repositioning the scan, we&lt;br/&gt;
will restart it completely, which should be a safe thing to do since&lt;br/&gt;
we haven&apos;t seen any rows yet.&lt;/p&gt;

&lt;p&gt;b) After repositioning, we should be positioned on the exact same row&lt;br/&gt;
as where we were when the position was saved. However, if the row has&lt;br/&gt;
been purged in the meantime, reposition() will place us immediately to&lt;br/&gt;
the left of where the row should have been. This is fine for forward&lt;br/&gt;
scans, but not for backward scans. Backward scans should be positioned&lt;br/&gt;
immediately to the right of that position (an issue also raised by&lt;br/&gt;
Mike in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-884&quot; title=&quot;allow and use backward scans on indexes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-884&quot;&gt;DERBY-884&lt;/a&gt;). I didn&apos;t find any existing code to position us on&lt;br/&gt;
the right side of the purged row (there&apos;s code to do that for partial&lt;br/&gt;
key scans, but repositioning uses full keys). So in the case where&lt;br/&gt;
reposition() can&apos;t position on the exact same key as the one we saved,&lt;br/&gt;
the patch now adds one to the current slot number, which moves the&lt;br/&gt;
position one slot to the right.&lt;/p&gt;


&lt;p&gt;Some issues that could need improvement or more investigation:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When a latch conflict is detected, the position is saved, all&lt;br/&gt;
latches released, and the operation is retried immediately. If the&lt;br/&gt;
other thread hasn&apos;t released the latch yet, we&apos;ll run into the same&lt;br/&gt;
latch conflict again, and we may loop a couple of times, saving the&lt;br/&gt;
position and reposititioning each time, before we can successfully&lt;br/&gt;
latch the previous page. If we want to avoid this active waiting, we&lt;br/&gt;
could refine this approach by doing an ordinary getPage() to latch the&lt;br/&gt;
sibling page after we have released the latch on the current page, and&lt;br/&gt;
wait until the page can be latched (and unlatched again) before we&lt;br/&gt;
reposition. Since we don&apos;t hold the latch on the current page while&lt;br/&gt;
waiting for the latch on the previous page, waiting here shouldn&apos;t&lt;br/&gt;
cause any deadlocks.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The current implementation of fetchMax(), also before the patch,&lt;br/&gt;
doesn&apos;t call unlockScanRecordAfterRead() to release read locks on&lt;br/&gt;
unqualified records once we&apos;ve moved past them. Other scans do that,&lt;br/&gt;
and we should probably do that in max scans as well, but the current&lt;br/&gt;
patch doesn&apos;t change this.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;positionAtPreviousPage() was placed in the BTreeScan class since&lt;br/&gt;
that&apos;s where positionAtNextPage() was. Probably these methods would be&lt;br/&gt;
better placed in sub-classes for backward scan and forward scan. I&lt;br/&gt;
think the reason why positionAtNextPage() was in that class, was that&lt;br/&gt;
BTreeMaxScan used it when doing a max scan from the beginning of the&lt;br/&gt;
index. Since the patch removed that code, the methods could be moved&lt;br/&gt;
now. But I suppose that could rather be done as a cleanup after on.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Testing. We need tests that exercise the code paths that handle the&lt;br/&gt;
latch conflicts. Some of these are very hard to test, especially the&lt;br/&gt;
cases where the row on the current position has been purged in the&lt;br/&gt;
small window between the saving of the current position and the&lt;br/&gt;
repositioning. I have been able to exercise that code path by using a&lt;br/&gt;
debugger to coordinate a forward scanner, a backward scanner and the&lt;br/&gt;
B-tree post commit thread so that the row disappeared at the exact&lt;br/&gt;
right moment to make the backward scanner take that path. I have only&lt;br/&gt;
been able to trigger this path for repositioning after a latch&lt;br/&gt;
conflict, though.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To exercise the corresponding path for lock conflicts, I think the&lt;br/&gt;
backward scanner needs to be timed so that it ends up waiting for a&lt;br/&gt;
lock held by the B-tree post commit thread. That&apos;s the only way I can&lt;br/&gt;
see how a row can have been purged when the scanner wakes up after&lt;br/&gt;
having been granted the lock on the row, but perhaps someone sees&lt;br/&gt;
other ways this could happen? Apart from the obvious timing problem of&lt;br/&gt;
getting the scanner queued up right behind the post commit thread, I&lt;br/&gt;
think the window where the post commit thread holds locks without&lt;br/&gt;
holding the latch on the page it&apos;s working on, is extremely small. The&lt;br/&gt;
backward scanner would have to access the page in this small window,&lt;br/&gt;
otherwise it would be blocked by the latch and not by the lock.&lt;/p&gt;


&lt;p&gt;Next, I will write some JUnit tests that exercise the new code, and&lt;br/&gt;
also add some tracing so that we can verify that the code actually has&lt;br/&gt;
been exercised.&lt;/p&gt;

&lt;p&gt;Feedback about the suggested approach would be greatly appreciated.&lt;/p&gt;</comment>
                            <comment id="12994876" author="knutanders" created="Tue, 15 Feb 2011 16:53:18 +0000"  >&lt;p&gt;Attaching an updated patch (1b) with the following changes from 1a:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Changed class javadoc for BTreeMaxScan to describe the new approach&lt;br/&gt;
  instead of the old one.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added a debug flag to allow tracing latch conflicts in sane builds.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added a new test (BTreeMaxScanTest) with test cases that exercise&lt;br/&gt;
  the code that handles some of the latch conflict scenarios.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If the test is run with derby.tests.trace=true, and a sane build is&lt;br/&gt;
used, a message will be printed to derby.log each time a latch&lt;br/&gt;
conflict that results in the need for repositioning is experienced by&lt;br/&gt;
a BTreeMaxScan. This can be used to verify that the test actually&lt;br/&gt;
exercised the code path we&apos;re interested in. For example, the test&lt;br/&gt;
that verifies that backward scans don&apos;t deadlock with backward scans,&lt;br/&gt;
will print something like this to derby.log:&lt;/p&gt;

&lt;p&gt;DEBUG BTreeMaxScan.latchConflict OUTPUT: Enable tracing for testOppositeScanDirections&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Couldn&apos;t get latch nowait, will retry&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Couldn&apos;t get latch nowait, will retry&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Disable tracing for testOppositeScanDirections&lt;/p&gt;

&lt;p&gt;And the test that verifies that the scan is restarted after a latch&lt;br/&gt;
conflict when moving from an empty page, will print something like&lt;br/&gt;
this:&lt;/p&gt;

&lt;p&gt;DEBUG BTreeMaxScan.latchConflict OUTPUT: Enable tracing for testEmptyRightmostLeaf&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Couldn&apos;t get latch nowait, will retry&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Restart scan from rightmost leaf&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Couldn&apos;t get latch nowait, will retry&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Restart scan from rightmost leaf&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
DEBUG BTreeMaxScan.latchConflict OUTPUT: Disable tracing for testEmptyRightmostLeaf&lt;/p&gt;

&lt;p&gt;Since latch conflicts are hard to test reliably, the test runs many&lt;br/&gt;
iterations to increase the likelihood of a conflict, but there&apos;s no&lt;br/&gt;
guarantee that it actually has been tested. That&apos;s why the tracing is&lt;br/&gt;
added. Currently, the test takes almost a minute to run. This could be&lt;br/&gt;
reduced by cutting down on the number of iterations, and we should&lt;br/&gt;
probably do that when the feature has been stabilized, but I&apos;ll keep&lt;br/&gt;
the high number of iterations for now.&lt;/p&gt;

&lt;p&gt;Although there still are some issues that need to be resolved, and&lt;br/&gt;
more tests need to be written, I intend to commit this patch soon so&lt;br/&gt;
that we can get as much testing as possible before the next release.&lt;br/&gt;
If we haven&apos;t gained enough confidence in it by then, we can always&lt;br/&gt;
back out the changes.&lt;/p&gt;

&lt;p&gt;As to the issues I think need to be resolved, or at least investigated&lt;br/&gt;
further, I&apos;m particularly thinking about what&apos;s the right way to do&lt;br/&gt;
the repositioning after waiting for a lock. The old code would give up&lt;br/&gt;
and start from the beginning of the B-tree in that case, whereas the&lt;br/&gt;
new code will reposition on the row we had to wait for and continue&lt;br/&gt;
there.&lt;/p&gt;

&lt;p&gt;I think that may be too simple, at least for serializable&lt;br/&gt;
transactions. Since we&apos;re moving backwards, the previous key locking&lt;br/&gt;
works a bit different. While we&apos;re waiting for the lock on the current&lt;br/&gt;
row, the range between the row we&apos;re waiting for and the (deleted)&lt;br/&gt;
record that we just saw is not protected. So when we get the lock, a&lt;br/&gt;
row with a higher value may have been inserted. We won&apos;t see this row&lt;br/&gt;
after the repositioning, and it will turn up as a phantom read&lt;br/&gt;
(thereby breaking the requirements for the serializable isolation&lt;br/&gt;
level) if we re-execute select max in the same transaction.&lt;/p&gt;

&lt;p&gt;Now this doesn&apos;t seem to cause any problem in practise, because in all&lt;br/&gt;
the tests I&apos;ve run, B-tree max scans in serializable transactions take&lt;br/&gt;
table locks, preventing any concurrent modification. However, it would&lt;br/&gt;
be good to get this right, especially so that the backward max scan&lt;br/&gt;
can be extended to a full-featured backward scan implementation in&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-884&quot; title=&quot;allow and use backward scans on indexes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-884&quot;&gt;DERBY-884&lt;/a&gt;, and also so that max scans at some point can safely be&lt;br/&gt;
performed without table locks in serializable transactions.&lt;/p&gt;

&lt;p&gt;One possible solution may be to change BTreeScan.savePosition() to&lt;br/&gt;
save the position immediately to the right of the current position&lt;br/&gt;
when we scan backwards. That should prevent skipping rows that were&lt;br/&gt;
inserted while we waited for the lock on the current position, since&lt;br/&gt;
the range from the last visited row and up to infinity should be&lt;br/&gt;
protected by the locks already acquired. Moving one step to the left&lt;br/&gt;
from that saved position should get us back to the same position if no&lt;br/&gt;
rows were inserted, or to the newly inserted row with the highest&lt;br/&gt;
value otherwise.&lt;/p&gt;</comment>
                            <comment id="12995093" author="dagw" created="Wed, 16 Feb 2011 00:41:15 +0000"  >&lt;p&gt;Thanks for the explanation! So, if I read this correctly, you will repostion to the position to the immediate right of the one we had to wait for, instead of repositioning to the one we had to wait for? This would seem to protect against the phantom anomaly, I agree.&lt;/p&gt;</comment>
                            <comment id="12995216" author="knutanders" created="Wed, 16 Feb 2011 08:38:28 +0000"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;Yes, that&apos;s what I was thinking. To be precise, we reposition to the row that was immediately to the right when we started waiting. When we wake up, there may be many rows between the row we waited for and the row we reposition to. In the current patch, we reposition on the row we&apos;re waiting for and then move one row to the right. These two approaches should be equivalent in the case where no potential phantom rows have been inserted while we were waiting.&lt;/p&gt;

&lt;p&gt;There may be a simpler solution, though. The existing code doesn&apos;t take previous key locks in the max scan, with comments saying that previous key locks aren&apos;t necessary for a max scan (which is true as long as the scan is restarted once we have to wait for a lock, like the existing code does). But it should be possible to perform previous key locking while moving backwards too by always locking the row immediately to the left of the one we&apos;re interested in. Then we&apos;d always be one row ahead with the locking in serializable transactions, and even if we have to wait for a lock, the current position will be protected by the lock we acquired in the previous iteration, so it should be safe to reposition back to that position.&lt;/p&gt;

&lt;p&gt;Unfortunately, it&apos;s somewhat difficult to test whether this works as long as the optimizer insists on table locking for BTreeMaxScan in serializable transactions. I haven&apos;t yet found out exactly where this decision is made.&lt;/p&gt;</comment>
                            <comment id="12995217" author="knutanders" created="Wed, 16 Feb 2011 08:46:25 +0000"  >&lt;p&gt;Committed the 1b patch to trunk with revision 1071171.&lt;/p&gt;</comment>
                            <comment id="12995383" author="knutanders" created="Wed, 16 Feb 2011 16:53:46 +0000"  >&lt;p&gt;As to the suggestion with previous key locking for serializable, we still have the problem that we need to save another position than the one we&apos;re trying to lock. When we have to wait for the previous key lock, it&apos;s the current key we want to save, whereas the locking code will save the key we&apos;re trying to lock (that is, the previous key). So even if we use previous key lock calls to solve this problem, we&apos;ll need to get the code to save the position immediately to the right of the row that we&apos;re waiting for.&lt;/p&gt;</comment>
                            <comment id="12998917" author="knutanders" created="Thu, 24 Feb 2011 16:13:15 +0000"  >&lt;p&gt;Attaching a patch (2a) which adds a test for the repositioning logic after waiting for a lock in serializable transactions. The test doesn&apos;t reveal any problems, but that&apos;s because the B-tree max scans are currently always performed with table locks in serializable transactions.&lt;/p&gt;

&lt;p&gt;The test case does expose the phantom read problem discussed above if we switch to record locking for those scans. That can be achieved by disabling the following code in FromBaseTable:&lt;/p&gt;

&lt;p&gt;			/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Figure out whether to do row locking or table locking.&lt;br/&gt;
			**&lt;/li&gt;
		&lt;li&gt;If there are no start/stop predicates, we&apos;re doing full&lt;/li&gt;
		&lt;li&gt;conglomerate scans, so do table locking.&lt;br/&gt;
			*/&lt;br/&gt;
			if (! startStopFound)
			{
				currentAccessPath.setLockMode(
											TransactionController.MODE_TABLE);

				optimizer.trace(Optimizer.TABLE_LOCK_NO_START_STOP,
							    0, 0, 0.0, null);
			}&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m not planning to switch to record locking for max scans as part of this issue, but I&apos;d like to have a test case for it in any case.&lt;/p&gt;

&lt;p&gt;Committed revision 1074196.&lt;/p&gt;</comment>
                            <comment id="12999339" author="knutanders" created="Fri, 25 Feb 2011 12:48:31 +0000"  >&lt;p&gt;Attaching derby-642-3a-waitBeforeRetry.diff which implements an optimization mentioned in an earlier comment, and also discussed in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-884&quot; title=&quot;allow and use backward scans on indexes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-884&quot;&gt;DERBY-884&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When the left sibling cannot be latched immediately, and we get a WaitError, we now try to get the latch on the left sibling again, possibly waiting for it, before we reposition in the B-tree. We save the position and release the latch on the current page before we do this, so waiting for the latch shouldn&apos;t be causing any deadlocks. We also release the latch we&apos;ve just obtained on the left sibling before we do the repositioning, since we don&apos;t know if that&apos;s still the page we want to move to (anything may have happened while we didn&apos;t hold any latches).&lt;/p&gt;

&lt;p&gt;This change avoids the case where a scan gets a WaitError, then immediately retries just to get a new WaitError. It may need to try many times before it&apos;s actually able to reposition and move to the left sibling. The changes in the patch makes the scan wait until the other thread has released the latch, and then it&apos;s much more likely that it&apos;ll be able to retry the operation without getting a WaitError.&lt;/p&gt;

&lt;p&gt;Running BTreeMaxScanTest with the patch and tracing turned on, I see that the amount of log produced by the tracing is reduced by about 80%, which indicates that the scans spend less time on unsuccessful retries.&lt;/p&gt;</comment>
                            <comment id="13000182" author="knutanders" created="Mon, 28 Feb 2011 09:14:50 +0000"  >&lt;p&gt;Committed the 3a patch with revision 1075248.&lt;/p&gt;</comment>
                            <comment id="13003348" author="knutanders" created="Mon, 7 Mar 2011 13:27:40 +0000"  >&lt;p&gt;I&apos;m marking this issue as fixed in 10.8 so that it turns up in the release notes.&lt;/p&gt;

&lt;p&gt;There&apos;s still the unaddressed issue with how to prevent phantom reads in serializable transactions with row lock granularity. Since BTreeMaxScan always uses table locks when the isolation level is serializable, it won&apos;t cause any problems currently, so I believe it is sufficient to address this issue when we add full support for backward scans. I&apos;ll add a comment about it in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-884&quot; title=&quot;allow and use backward scans on indexes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-884&quot;&gt;DERBY-884&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13004201" author="rhillegas" created="Tue, 8 Mar 2011 20:43:50 +0000"  >&lt;p&gt;Attaching Timestamper.java, max.sql, and max2.sql. Together these form a test which verifies the value of this improvement. Timestamper is a Derby function which reports the number of seconds since it was called last. The max.sql script creates a table which has 3M rows and then indexes it. One out of every 100 rows contains a null. The max2.sql script selects the max value from the table and reports how long the aggregate took. When run on Derby 10.7.1, the aggregate takes 10 seconds. When run on 10.8.1, the aggregate returns the correct value immediately. Note that there is some instability in Derby which affects the max.sql script. I have noticed that sometimes the index creation dies on an OOM error. This happens as far back as 10.5.3.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12328192">DERBY-884</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12473043" name="Timestamper.java" size="377" author="rhillegas" created="Tue, 8 Mar 2011 20:43:50 +0000"/>
                            <attachment id="12470692" name="derby-642-1a.diff" size="21551" author="knutanders" created="Wed, 9 Feb 2011 18:11:26 +0000"/>
                            <attachment id="12471088" name="derby-642-1b-withTests.diff" size="43294" author="knutanders" created="Tue, 15 Feb 2011 16:53:18 +0000"/>
                            <attachment id="12471846" name="derby-642-2a-test-serializable.diff" size="3587" author="knutanders" created="Thu, 24 Feb 2011 16:13:15 +0000"/>
                            <attachment id="12471926" name="derby-642-3a-waitBeforeRetry.diff" size="2000" author="knutanders" created="Fri, 25 Feb 2011 12:48:31 +0000"/>
                            <attachment id="12473044" name="max.sql" size="1680" author="rhillegas" created="Tue, 8 Mar 2011 20:43:50 +0000"/>
                            <attachment id="12473045" name="max2.sql" size="167" author="rhillegas" created="Tue, 8 Mar 2011 20:43:50 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 25 Oct 2005 01:52:15 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29640</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ftb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36380</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10053"><![CDATA[Low]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>