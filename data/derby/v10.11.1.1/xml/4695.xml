<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:16:20 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4695/DERBY-4695.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4695] Internal assignment of tablenumer, columnnumber looks wrong in query tree, although no ill effects are seen.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4695</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;While looking into derby-4679, I also looked at the query in&lt;br/&gt;
derby-2526 to validate that my changes also worked for that variant of&lt;br/&gt;
the problem.&lt;/p&gt;

&lt;p&gt;During inspection of the query trees after the bind phase, I found one&lt;br/&gt;
instance in which the pair (tablenumber, columnnumber) of a column&lt;br/&gt;
reference was wrong. Although it did not seem to impact the query&lt;br/&gt;
result, I note it here as as something we should probably investiate&lt;br/&gt;
as it may be a symptom an underlying problem, or a potential for&lt;br/&gt;
future problems.&lt;/p&gt;

&lt;p&gt;The query looks like this:&lt;/p&gt;

&lt;p&gt;select b3.* from b3 join bvw on (b3.c8 = bvw.c5) join b4 on (bvw.c1 = b4.c7) where b4.c4 = 42&quot;&lt;/p&gt;

&lt;p&gt;and the underlying DDL is this:&lt;/p&gt;

&lt;p&gt;create table b2 (c1 int, c2 int, c3 char(1), c4 int, c5 int, c6 int);&lt;br/&gt;
create table b4 (c7 int, c4 int, c6 int);&lt;br/&gt;
create table b3 (c8 int, c9 int, c5 int, c6 int);&lt;br/&gt;
create table b (c1 int, c2 int, c3 char(1), c4 int, c5 int, c6 int);&lt;br/&gt;
create view bvw (c5, c1 ,c2 ,c3 ,c4) as&lt;br/&gt;
select c5, c1 ,c2 ,c3 ,c4 from b2 union&lt;br/&gt;
select c5, c1 ,c2 ,c3 ,c4 from b;&lt;br/&gt;
create view bvw2 (c1 ,c2 ,c3 ,c4 ,c5) as&lt;/p&gt;

&lt;p&gt;After the bind phase, the join clause &quot;bvw.c1 = b4.c7&quot; has the&lt;br/&gt;
following entry for the column reference bvw.C1:&lt;/p&gt;

&lt;p&gt;          tableNumber: 1&lt;br/&gt;
          columnNumber: 6&lt;/p&gt;

&lt;p&gt;The problem is that the node with tablenumber 1 is bvw, which is the&lt;br/&gt;
view with the subquery for the union, which has only 5 resulting&lt;br/&gt;
columns, so 6 must be wrong. Although both the view participant tables&lt;br/&gt;
(b, b2) both have six column, the view does not. In any case, C1 is&lt;br/&gt;
column 2 in the view and column 2 in the two union selects from both b&lt;br/&gt;
and b2.&lt;/p&gt;

&lt;p&gt;C1 is however, column 6 of the join node resulting from &quot;select b3.*&lt;br/&gt;
from b3 join bvw on (b3.c8 = bvw.c5)&quot;, but the correct table number for&lt;br/&gt;
that would be 5, not 1.&lt;/p&gt;

&lt;p&gt;So, it would seem the table number has been bound to the bvw view&apos;s&lt;br/&gt;
result set, but the column number has been bound to the innermost join&lt;br/&gt;
node&apos;s result set. This looks worrying to me.&lt;/p&gt;

&lt;p&gt;See derby.log attached for the full dump of the query tree after the&lt;br/&gt;
bind phase.&lt;/p&gt;

&lt;p&gt;sourceResultSet:                                    &lt;br/&gt;
    org.apache.derby.impl.sql.compile.FromSubquery@12789d2&lt;br/&gt;
    correlation Name: BVW&lt;br/&gt;
    null&lt;br/&gt;
    tableNumber 1 &amp;lt;------------------------------------------- Note!&lt;br/&gt;
    level 0&lt;br/&gt;
    resultSetNumber: 0&lt;br/&gt;
    referencedTableMap: null&lt;br/&gt;
    statementResultSet: false&lt;br/&gt;
    resultColumns:                                      &lt;br/&gt;
        org.apache.derby.impl.sql.compile.ResultColumnList@c943d1&lt;br/&gt;
        indexRow: false&lt;br/&gt;
        orderBySelect: 0&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;:                                        &lt;br/&gt;
        org.apache.derby.impl.sql.compile.ResultColumn@d3c6a3&lt;br/&gt;
        **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;:                                        &lt;br/&gt;
        org.apache.derby.impl.sql.compile.ResultColumn@18352d8&lt;br/&gt;
        exposedName: C1&lt;br/&gt;
        name: C1&lt;br/&gt;
        tableName: null&lt;br/&gt;
        isDefaultColumn: false&lt;br/&gt;
        wasDefaultColumn: false&lt;br/&gt;
        isNameGenerated: false&lt;br/&gt;
        sourceTableName: B2&lt;br/&gt;
        type: INTEGER&lt;br/&gt;
        columnDescriptor: null&lt;br/&gt;
        isGenerated: false&lt;br/&gt;
        isGeneratedForUnmatchedColumnInInsert: false&lt;br/&gt;
        isGroupingColumn: false&lt;br/&gt;
        isReferenced: true&lt;br/&gt;
        isRedundant: false&lt;br/&gt;
        virtualColumnId: 2&lt;br/&gt;
        resultSetNumber: -1&lt;br/&gt;
        dataTypeServices: INTEGER&lt;br/&gt;
        expression:                                         &lt;br/&gt;
            org.apache.derby.impl.sql.compile.VirtualColumnNode@b40ec4&lt;br/&gt;
            dataTypeServices: null&lt;br/&gt;
            sourceColumn:                                               &lt;br/&gt;
                org.apache.derby.impl.sql.compile.ResultColumn@1d95da8&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
            sourceResultSet:                                                &lt;br/&gt;
                org.apache.derby.impl.sql.compile.UnionNode@14d7745&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;:                                        &lt;br/&gt;
        org.apache.derby.impl.sql.compile.ResultColumn@13576a2&lt;br/&gt;
        exposedName: C2&lt;br/&gt;
        name: C2&lt;br/&gt;
        tableName: null&lt;br/&gt;
        isDefaultColumn: false&lt;br/&gt;
        wasDefaultColumn: false&lt;br/&gt;
        isNameGenerated: false&lt;br/&gt;
        sourceTableName: B2&lt;br/&gt;
        type: INTEGER&lt;br/&gt;
        columnDescriptor: null&lt;br/&gt;
        isGenerated: false&lt;br/&gt;
        isGeneratedForUnmatchedColumnInInsert: false&lt;br/&gt;
        isGroupingColumn: false&lt;br/&gt;
        isReferenced: true&lt;br/&gt;
        isRedundant: false&lt;br/&gt;
        virtualColumnId: 3&lt;br/&gt;
        resultSetNumber: -1&lt;br/&gt;
        dataTypeServices: INTEGER&lt;br/&gt;
        expression:                                         &lt;br/&gt;
            org.apache.derby.impl.sql.compile.VirtualColumnNode@ff8c74&lt;br/&gt;
            dataTypeServices: null&lt;br/&gt;
            sourceColumn:                                               &lt;br/&gt;
                org.apache.derby.impl.sql.compile.ResultColumn@61736e&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
            sourceResultSet:                                                &lt;br/&gt;
                org.apache.derby.impl.sql.compile.UnionNode@14d7745&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt;:                                        &lt;br/&gt;
        org.apache.derby.impl.sql.compile.ResultColumn@15e2ccd&lt;br/&gt;
        exposedName: C3&lt;br/&gt;
        name: C3&lt;br/&gt;
        tableName: null&lt;br/&gt;
        isDefaultColumn: false&lt;br/&gt;
        wasDefaultColumn: false&lt;br/&gt;
        isNameGenerated: false&lt;br/&gt;
        sourceTableName: B2&lt;br/&gt;
        type: CHAR(1)&lt;br/&gt;
        columnDescriptor: null&lt;br/&gt;
        isGenerated: false&lt;br/&gt;
        isGeneratedForUnmatchedColumnInInsert: false&lt;br/&gt;
        isGroupingColumn: false&lt;br/&gt;
        isReferenced: true&lt;br/&gt;
        isRedundant: false&lt;br/&gt;
        virtualColumnId: 4&lt;br/&gt;
        resultSetNumber: -1&lt;br/&gt;
        dataTypeServices: CHAR(1)&lt;br/&gt;
        expression:                                         &lt;br/&gt;
            org.apache.derby.impl.sql.compile.VirtualColumnNode@1cf7491&lt;br/&gt;
            dataTypeServices: null&lt;br/&gt;
            sourceColumn:                                               &lt;br/&gt;
                org.apache.derby.impl.sql.compile.ResultColumn@11946c2&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
            sourceResultSet:                                                &lt;br/&gt;
                org.apache.derby.impl.sql.compile.UnionNode@14d7745&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;4&amp;#93;&lt;/span&gt;:    &amp;lt;----------------------------------------- highest column number is 5 (index is zero-based)&lt;br/&gt;
        org.apache.derby.impl.sql.compile.ResultColumn@edf730&lt;br/&gt;
        exposedName: C4&lt;br/&gt;
        name: C4&lt;br/&gt;
        tableName: null&lt;br/&gt;
        isDefaultColumn: false&lt;br/&gt;
        wasDefaultColumn: false&lt;br/&gt;
        isNameGenerated: false&lt;br/&gt;
        sourceTableName: B2&lt;br/&gt;
        type: INTEGER&lt;br/&gt;
        columnDescriptor: null&lt;br/&gt;
        isGenerated: false&lt;br/&gt;
        isGeneratedForUnmatchedColumnInInsert: false&lt;br/&gt;
        isGroupingColumn: false&lt;br/&gt;
        isReferenced: true&lt;br/&gt;
        isRedundant: false&lt;br/&gt;
        virtualColumnId: 5&lt;br/&gt;
        resultSetNumber: -1&lt;br/&gt;
        dataTypeServices: INTEGER&lt;br/&gt;
        expression:                                         &lt;br/&gt;
            org.apache.derby.impl.sql.compile.VirtualColumnNode@ff94b1&lt;br/&gt;
            dataTypeServices: null&lt;br/&gt;
            sourceColumn:                                               &lt;br/&gt;
                org.apache.derby.impl.sql.compile.ResultColumn@17a4989&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
            sourceResultSet:                                                &lt;br/&gt;
                org.apache.derby.impl.sql.compile.UnionNode@14d7745&lt;br/&gt;
                **&lt;b&gt;truncated&lt;/b&gt;**&lt;br/&gt;
    subquery:                                       &lt;br/&gt;
        org.apache.derby.impl.sql.compile.UnionNode@14d7745&lt;br/&gt;
        **&lt;b&gt;truncated&lt;/b&gt;**&lt;/p&gt;</description>
                <environment></environment>
        <key id="12466382">DERBY-4695</key>
            <summary>Internal assignment of tablenumer, columnnumber looks wrong in query tree, although no ill effects are seen.</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="dagw">Dag H. Wanvik</reporter>
                        <labels>
                    </labels>
                <created>Mon, 7 Jun 2010 21:37:52 +0100</created>
                <updated>Tue, 25 Sep 2012 16:46:13 +0100</updated>
                            <resolved>Mon, 23 Aug 2010 19:18:00 +0100</resolved>
                                    <version>10.7.1.1</version>
                                    <fixVersion>10.7.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12879075" author="dagw" created="Tue, 15 Jun 2010 20:09:55 +0100"  >&lt;p&gt;Investigating this, I see that initially, the result column is correctly identified tow BVW.C1, which corresponds to&lt;br/&gt;
tableNumber 1 and columnNumber 2 (in JoinNode#getMatchingColumn&apos;s call:&lt;/p&gt;

&lt;p&gt;    rightRC = logicalRightRS.getMatchingColumn(columnReference);&lt;/p&gt;

&lt;p&gt;which makes sense, since BVW is on the right hand side of the first&lt;br/&gt;
join. So far, so good.  In this step, the column reference&apos;s&lt;br/&gt;
tablenumber 1 is set, but the column number is not yet set. The table&lt;br/&gt;
number here is set in logicalRightRS alias&lt;br/&gt;
FromSubquery#getMatchingColumn ca line 335. &lt;span class=&quot;error&quot;&gt;&amp;#91;It is a subquery due to BVW being a view.&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Now, later in JoinNode#getMatchingColumn I see a block of code which essentially rebinds the result column &lt;b&gt;again&lt;/b&gt;. now to&lt;br/&gt;
the RC in the joins concatenated list of result column, in which C1&apos;s position is 6 as I noted before. &lt;br/&gt;
This block of code has this interesting comment:&lt;/p&gt;

&lt;p&gt;    /* Insert will bind the underlying result sets which have&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;tables twice. On the 2nd bind, resultColumns != null,&lt;/li&gt;
	&lt;li&gt;we must return the RC from the JoinNode&apos;s RCL which is above&lt;/li&gt;
	&lt;li&gt;the RC that we just found above.  (Otherwise, the source&lt;/li&gt;
	&lt;li&gt;for the ColumnReference will be from the wrong ResultSet&lt;/li&gt;
	&lt;li&gt;at generate().)&lt;br/&gt;
     */&lt;br/&gt;
     if (resultColumns != null)
     {
        &amp;lt;rebind column reference to RC in concatenated list of RC&apos;s of the
        join&amp;gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Next, we set the column number based on this &lt;b&gt;newly&lt;/b&gt; bound RC, with&lt;br/&gt;
the result that the CR of the join predicate&apos;s &quot;BVW.C1&quot; has table&lt;br/&gt;
number and column number with contributions from two &lt;b&gt;different&lt;/b&gt;&lt;br/&gt;
RCs... Not good. &lt;/p&gt;

&lt;p&gt;[The column number is set at the end of ColumnReference#bindExpression&lt;br/&gt;
near the end of that method based on the bound RC.]&lt;/p&gt;

&lt;p&gt;If I comment out the above block of code, the column references ends&lt;br/&gt;
up with the correct table and column number (1,2), and the query still&lt;br/&gt;
executes correctly.&lt;/p&gt;

&lt;p&gt;It would seem that this block of code is only intended for INSERTs,&lt;br/&gt;
but even for INSERT we could have a similar query with similar join&lt;br/&gt;
flattening and rewrite needs, and so the error would persist for&lt;br/&gt;
INSERTS even if we disabled this block for non-INSERT statements.&lt;/p&gt;

&lt;p&gt;In sum, the source of the problem seems to be that the assignment of&lt;br/&gt;
table number and column number happens in different places, and in the&lt;br/&gt;
meantime, the bound RC has changed..&lt;/p&gt;</comment>
                            <comment id="12879102" author="dagw" created="Tue, 15 Jun 2010 21:01:54 +0100"  >&lt;p&gt;My primary interest in persuing this issue is that the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; now relies&lt;br/&gt;
on (tablenumber, columnnumber) for the remapping in &lt;br/&gt;
ColumnReference#remapColumnReferencesToExpressions, only falling back to map via&lt;br/&gt;
column name strings when at the BaseColumnNode level.&lt;/p&gt;

&lt;p&gt;Theoretically, if assignment of (tablenumber, columnnumber) is sometimes wrong, as seen in this&lt;br/&gt;
issue, one could end up with a wrong remap. Actually what happens for the query under investigation here&lt;br/&gt;
is that given the wrong column pair (1,6),  &lt;/p&gt;

&lt;p&gt;     ftRC = rcl.getResultColumn(&lt;br/&gt;
                    tableNumberBeforeFlattening,&lt;br/&gt;
                    columnNumberBeforeFlattening)&lt;/p&gt;

&lt;p&gt;fails to find such a column and falls back to the column string method used solely prior to&lt;br/&gt;
the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If correctly bound to (1,2), the test in the beginning of ColumnReference#remapColumnReferencesToExpressions:&lt;/p&gt;

&lt;p&gt;   /* Nothing to do if we are not pointing to a redundant RC */&lt;br/&gt;
   if (! source.isRedundant())&lt;/p&gt;
   {
      return this;
   }

&lt;p&gt;hits in since the column reference is already bound correctly. The fact that the wrong pair exists is masked by the saving grace of the column name based lookup and thus corrected. This is pure luck, though, another combination of numbers could&lt;br/&gt;
have made the (tn, cn) based lookup find the wrong column.&lt;/p&gt;

&lt;p&gt;This is also why this problem has not been seen in practice, perhaps.&lt;/p&gt;

&lt;p&gt;In summary, the presence of the wrong (tn,cn) assignment is a fact, so there is a small chance that the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; could break existing working queries (which work only due to luck, as shown above). Therefore, I would like to fix this issue&lt;br/&gt;
before back-porting the fix of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; to the 10.6 branch. &lt;/p&gt;</comment>
                            <comment id="12879158" author="dagw" created="Tue, 15 Jun 2010 23:41:50 +0100"  >&lt;p&gt;Commenting out the block described earlier breaks lots of (all?) (left) outer joins, too (NPE in BaseActivation#getColumnFromRow).&lt;br/&gt;
This fits the description about wrong ResultSet at generate time alluded to in the comment.&lt;/p&gt;

&lt;p&gt;Maybe the &quot;Insert&quot; in the comment is misleading.&lt;/p&gt;</comment>
                            <comment id="12879812" author="dagw" created="Thu, 17 Jun 2010 16:39:46 +0100"  >&lt;p&gt;Performing the rebinding block only for HalfOuterJoinNode (subclass of JoinNode), makes the&lt;br/&gt;
outer joins pass again, and removes the inconsistent binding seen in the original query of this issue and JoinTest still passes.&lt;/p&gt;

&lt;p&gt;It is still unclear to me why outer join should need this rebinding code, though, but not inner joins (at least those we test in JoinTest).&lt;/p&gt;

</comment>
                            <comment id="12879937" author="dagw" created="Thu, 17 Jun 2010 22:23:26 +0100"  >&lt;p&gt;Cf my note on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt;: Performing the rebinding block only for HalfOuterJoinNode actually also solves&lt;br/&gt;
the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; issue, as well as a variant query which still fails even after the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12880347" author="dagw" created="Fri, 18 Jun 2010 23:31:43 +0100"  >&lt;p&gt;Uploading why-loj-needs-2nd-bind.txt, which shows graphically what is wrong in query tree just prior to code generation if we skip the rebinding block for this query.&lt;/p&gt;

&lt;p&gt;By way of comparison, I also upload a similar analysis for an inner join which can do without this 2nd binding: why-ij-can-do-without-2nd-bind.txt&lt;/p&gt;

&lt;p&gt;My current thinking is that this hoisting of the column references to point to the RC in the RCL of the join node, is (sometimes) necessary, but can happens too early, cf. the problem addressed in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt;, since other rewriting can be thwarted by it - we lose the information about which original point in the tree the column reference pointed to. As we have seen it also can (will always?) lead to wrong assignment of table number and column number in the column reference. &lt;/p&gt;

&lt;p&gt;Note that at code generation time, the (tn, cn) information in a column reference can be wrong - it is not used - as long as the source points to the correct result column. In deed it &lt;b&gt;is&lt;/b&gt; wrong in the loj sample query, cf. note in why-loj-needs-2nd-bind.txt. &lt;/p&gt;

&lt;p&gt;Note that this doesn&apos;t mean that I have concluded that inner join can always do without this 2nd bind, nor that outer join always needs it, this is just a case study to understand what this 2nd bind is doing.&lt;/p&gt;</comment>
                            <comment id="12880349" author="dagw" created="Fri, 18 Jun 2010 23:39:21 +0100"  >&lt;p&gt;Another thing to note from these two examples, is that HalfOuterJoinNodes have been assigned table numbers, but plain JoinNodes are not (are still -1).&lt;/p&gt;</comment>
                            <comment id="12881199" author="dagw" created="Tue, 22 Jun 2010 14:37:19 +0100"  >&lt;p&gt;The -1 in the table number was a red herring, as this is only seen&lt;br/&gt;
after optimization. It turns out that join nodes are reintroduced&lt;br/&gt;
in SelectNode#modifyAccessPath, which are not involved during the&lt;br/&gt;
flattening process which happens during preprocess time.&lt;/p&gt;</comment>
                            <comment id="12881215" author="dagw" created="Tue, 22 Jun 2010 15:33:21 +0100"  >&lt;p&gt;I found the following comment in FromList#bindColumnReference:&lt;/p&gt;

&lt;p&gt;/* TableNumbers are set in the CR in the underlying&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;FromTable.  This ensures that they get the table&lt;/li&gt;
	&lt;li&gt;number from the underlying table, not the join node.&lt;/li&gt;
	&lt;li&gt;This is important for beging able to push predicates&lt;/li&gt;
	&lt;li&gt;down through join nodes.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So it appears that by design, the ColumnReference&apos;s source RC is set&lt;br/&gt;
to that of the join, whereas the table number and the column number is&lt;br/&gt;
set to that of the underlying FromTable.&lt;/p&gt;

&lt;p&gt;Referring to  the &quot;why-loj-needs-2nd-bind.txt&quot; example:&lt;/p&gt;

&lt;p&gt;select * from t1 left outer join (t2 left outer &quot;&lt;br/&gt;
                + &quot;join t3 on t2.c1=t3.c1) on t1.c1=t3.c1&lt;/p&gt;

&lt;p&gt;The 2nd bind sets up the corrects table number&lt;br/&gt;
and column number: although the returned RC from&lt;br/&gt;
JoinNode#getMatchingColumn is that of the JoinNode, the table number&lt;br/&gt;
has been set to the basetable&apos;s (not the join&apos;s), the column number is&lt;br/&gt;
&lt;b&gt;also&lt;/b&gt; set to the position in the base table, since the&lt;br/&gt;
columndescriptor of the returned RC contains the correct column number&lt;br/&gt;
(which is different from the column position of the returned rc in&lt;br/&gt;
the join (2nd bind), cf this call:&lt;/p&gt;

&lt;p&gt;ColumnReference#bindExpression:&lt;/p&gt;

&lt;p&gt;		/* Set the columnNumber from the base table.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Useful for optimizer and generation.&lt;br/&gt;
		 */&lt;br/&gt;
		columnNumber = matchingRC.getColumnPosition();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If the FromTable is a base table, matchingRC.getColumnPosition will&lt;br/&gt;
pick it up from the RC&apos;s columnDescriptor. This position is the column&lt;br/&gt;
position of the column in the base table,  so it is consistent with&lt;br/&gt;
the set table number.&lt;/p&gt;

&lt;p&gt;However, if the underlying FromTable is a subquery, we get the&lt;br/&gt;
virtual column id of the matchingRC, cf. this code for&lt;br/&gt;
getColumnPosition:&lt;/p&gt;

&lt;p&gt;	public int getColumnPosition()&lt;br/&gt;
	{&lt;br/&gt;
	    if (columnDescriptor != null) &lt;/p&gt;
{
                return columnDescriptor.getPosition();
            }
&lt;p&gt; else {&lt;br/&gt;
                return virtualColumnId;&lt;/p&gt;

&lt;p&gt;so, the columnNumber ends up pointing to the RC&apos;s position in the Join&lt;br/&gt;
node, whereas the table number still points to the FromTable, hence&lt;br/&gt;
the observed inconsistency.&lt;/p&gt;

&lt;p&gt;If this is intentional or wrong, I can&apos;t yet say, but it looks weird.&lt;br/&gt;
The comment in ColumnReference#bindExpression says &lt;/p&gt;

&lt;p&gt;    &quot;Set the columnNumber from the base table&quot;.&lt;/p&gt;

&lt;p&gt;but what we get here is definitely not that &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In the original query posted for this issue, the column number &quot;6&quot;&lt;br/&gt;
observed to look strange, stems from using virtualColumnId&lt;br/&gt;
above, (BVW is a FromSubquery).&lt;/p&gt;</comment>
                            <comment id="12881530" author="bryanpendleton" created="Wed, 23 Jun 2010 04:42:41 +0100"  >&lt;p&gt;Gurk. I can envision why pushing predicates around in the tree&lt;br/&gt;
introduces lots of complexity into the management of the column references.&lt;/p&gt;

&lt;p&gt;Your writeups are fascinating, and I&apos;m learning a lot from studying them.&lt;/p&gt;

&lt;p&gt;I have this feeling that you&apos;re getting very close to having such a&lt;br/&gt;
thorough knowledge of this subject that you are ready to redesign&lt;br/&gt;
the ColumnReference data structure and replace it with a scheme that&lt;br/&gt;
simplifies and avoids all these problems.&lt;/p&gt;

&lt;p&gt;In the meantime, I&apos;ll enjoy continuing to read your findings, so please&lt;br/&gt;
continue posting them as you have the time!&lt;/p&gt;</comment>
                            <comment id="12881680" author="dagw" created="Wed, 23 Jun 2010 14:11:30 +0100"  >&lt;p&gt;Thanks for the encouragement, Bryan &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I&apos;m afraid I am not quite yet&lt;br/&gt;
in the position to replace the existing machinery with a better&lt;br/&gt;
design, but I am slowly learning more about this area, too.&lt;/p&gt;

&lt;p&gt;Meanwhile, I feel more confident that the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; (with&lt;br/&gt;
the added followup-patch) would be safe to back-port from the following&lt;br/&gt;
reasoning:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the seen inconsistency lies in the columnNumber, not the tableNumber&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the (tn, cn)-based lookup used in the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; only&lt;br/&gt;
  considers RCs with a correct table number (and column number).  If&lt;br/&gt;
  the column number in the column reference should be wrong (as&lt;br/&gt;
  documented in this issue), the added sanity check for the column&lt;br/&gt;
  name to also match, would catch and discard the candidate RC, and&lt;br/&gt;
  make the (tn, cn)-based lookup return null.&lt;br/&gt;
  I.e. it can not return false positives.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;subsequently, we would fall back on the exisiting columnName based&lt;br/&gt;
  lookup (exisiting behavior)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This leads me to conclude that the code would always be an improvement over the current solution.&lt;/p&gt;

&lt;p&gt;So, I intend to back-port &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; to the 10.6 branch while I&lt;br/&gt;
continue to look for a better solution that would:&lt;/p&gt;

&lt;p&gt;         a) keep numbering consistent, if achievable&lt;br/&gt;
         b) document the invariants if I can establish any&lt;br/&gt;
         b) make the variant query i constructed for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; which still fails (the one that&lt;br/&gt;
         contains a subquery) also work.&lt;/p&gt;</comment>
                            <comment id="12883273" author="dagw" created="Mon, 28 Jun 2010 21:17:29 +0100"  >&lt;p&gt;Uploading a patch, derby-4679-fixcolumnno-1a, which fixes the wrong column numbers, by assigning them at the same time as the tableNumber is bound, i.e. in the fromTable classes, rather than in ColumnReference#bindExpression. The fact that JoinNode replaces the RC, will then not affect the actually bound columnNumber like before.&lt;/p&gt;

&lt;p&gt;Cf the enclosed trace patch which I have used to show what happens, trace-remapping.diff. This can be applied both with and without the patch proper.&lt;/p&gt;

&lt;p&gt;I have ported the original &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2526&quot; title=&quot;Wrong results with queries that use the JOIN ... ON syntax to join with views or other non-base table expressions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2526&quot;&gt;&lt;del&gt;DERBY-2526&lt;/del&gt;&lt;/a&gt; query over to JoinTest#testDerby_4695 and added one more query, so there are two queries, let&apos;s call them a and b. &lt;/p&gt;

&lt;p&gt;The query tree after the bind phase before and after are attached as query-a-before.log and query-a-after.log. There have been normalized, so they can be diffed to see the net difference in binding, which is that the column reference BVW.C1 was 1,6 before the patch and 1,2 after the patch. &lt;/p&gt;

&lt;p&gt;For query a, we see the following trace of remappings done as a result of join flattening before the patch:&lt;/p&gt;

&lt;p&gt;remapping CR: B3.C1 before: 0,1 after 5,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 5,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 5,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 5,4 null&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 6,2 null&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 0,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 0,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 0,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 0,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 1,2 B2   &amp;lt;-------- wrong input, but ends up correct&lt;/p&gt;



&lt;p&gt;and the following after the patch:&lt;/p&gt;

&lt;p&gt;remapping CR: B3.C1 before: 0,1 after 5,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 5,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 5,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 5,4 null&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 6,2 null&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 0,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 0,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 0,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 0,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 1,2 B2  &amp;lt;--- correct both before and after&lt;/p&gt;

&lt;p&gt;For query b, which is a more complicated join, I also upload similar log files, query-b-before.log and query-b-after.log, which also only differ in their column reference BVW.C1 (several this time, since the column in used in more places). The query looks like this:&lt;/p&gt;

&lt;p&gt;select b3.*, bvw.c1 from b3 inner join bvw on (b3.c1 = bvw.c5) &lt;br/&gt;
                            inner join b4  on (bvw.c1 = b4.c7) &lt;br/&gt;
                            inner join b  on (bvw.c1 = b.c1)&lt;br/&gt;
                            inner join b bcorr on bvw.c1 = bcorr.c1&lt;br/&gt;
    where b4.c4 = 42&quot;&lt;/p&gt;

&lt;p&gt;which is a bit meaningless, but exercises several flattenings involving bvw.c1. This query also gave a correct answer, but as we can see below, during the intermediate steps, the binding of RC ends up wrong (also one a la &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt;, due to falling back on column name based matching: since the (tablenumber, column number) pair was wrong at the outset, and so made the new lookup method introduced for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; fail to do its job. I believe, although I haven&apos;t yet been able to prove it, that the wrong numbering could lead to bugs:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;wrong or missing transitive closure computation since this is based         on (tn, cn)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;lead to yet other wrong intermediate CRs (shown to happen thrice in the example below, although it doesn&apos;t lead to query error here) which could then in turn confuse transitive closure computation, as seen in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; (CR bound to wrong column instance in a JOIN RCL). Note that this represents another mode of &quot;correct t-no, wrong col-no&quot; happening: the primary issue here is the wrong binding in the bind phase, this second mode happens during rebinding in the optimizer&apos;s preprocess phase. I.e. error mode one leads to error mode 2, which has been shown to cause bugs.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now, let us look at the differences for query b. Without the patch we see:&lt;/p&gt;

&lt;p&gt;remapping CR: B3.C1 before: 0,1 after 9,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 9,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 9,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 9,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 9,6 B2&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 9,11 null&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 7,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 7,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 7,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 7,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 7,6 B2&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 7,11 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 7,1 null &amp;lt;--- wrong!&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 5,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 5,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 5,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 5,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 5,6 B2&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 6,2 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 5,1 null &amp;lt;--- wrong&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 5,1 null &amp;lt;--- wrong&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 0,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 0,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 0,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 0,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 1,2 B2&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 1,2 B2 &amp;lt;--- correct with wrong input (rescued ultimately!)&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 1,2 B2 &amp;lt;--- ditto&lt;br/&gt;
remapping CR: BVW.C1 before: 1,6 after 1,2 B2 &amp;lt;--- ditto&lt;/p&gt;

&lt;p&gt;vs after the patch:&lt;/p&gt;

&lt;p&gt;remapping CR: B3.C1 before: 0,1 after 9,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 9,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 9,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 9,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 9,6 B2&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 9,11 null&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 7,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 7,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 7,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 7,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 7,6 B2&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 7,11 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 7,6 B2 &amp;lt;--- correct&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 5,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 5,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 5,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 5,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 5,6 B2&lt;br/&gt;
remapping CR: B4.C4 before: 6,2 after 6,2 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 5,6 B2 &amp;lt;--- correct&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 5,6 B2 &amp;lt;--- correct&lt;br/&gt;
remapping CR: B3.C1 before: 0,1 after 0,1 null&lt;br/&gt;
remapping CR: B3.C9 before: 0,2 after 0,2 null&lt;br/&gt;
remapping CR: B3.C5 before: 0,3 after 0,3 null&lt;br/&gt;
remapping CR: B3.C6 before: 0,4 after 0,4 null&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 1,2 B2&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 1,2 B2 &amp;lt;--- correct&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 1,2 B2 &amp;lt;--- correct&lt;br/&gt;
remapping CR: BVW.C1 before: 1,2 after 1,2 B2 &amp;lt;--- correct&lt;/p&gt;

&lt;p&gt;As can be seen, the fact that BVW.C1 on the join condition is now correctly bound, makes the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4679&quot; title=&quot;Several left outer joins causes unstable query with incorrect results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4679&quot;&gt;&lt;del&gt;DERBY-4679&lt;/del&gt;&lt;/a&gt; kick in in yet another instance, and return (7,6) rather than (7,1) after the second flattening.&lt;/p&gt;

&lt;p&gt;[ To see that (7,6) is correct, if we look inside the binding log file for query b, we see that table 7 corresponds to the join node with join clause BVW.C1 = B4.C7. This join has a RCL which is 12 columns long. We can see that RC (7,1) corresponds to B3.C1, which is wrong. After the patch, we see the binding is done to (9,6), which is correct, since that points to the correct RC in the RCL of table 7, that is a RC corresponding to RC in the join below, which ultimately stems from the subquery column BVW.C1. ]&lt;/p&gt;

&lt;p&gt;So, we see from the trace that for each flattening, the binding for BVW.C1 stays consistent during the flattening phases &lt;b&gt;with&lt;/b&gt; the patch, whereas before it was wrong in several places, and also led to binding to the wrong RC in three cases, although the final flattening saved the day since the CR is then remapped against a RCL that had no duplicates in it - i.e. the subquery representing the view - so (1,6) finally became (1,2).&lt;/p&gt;

&lt;p&gt;The patch ran regressions ok. While I haven&apos;t yet been able to prove that this issue could lead to query errors, I do think it could, for the reasons cited above. I therefore recommend we commit this patch as a defensive measure. If people think I should first be able to construct a wrong query, I can always try again.&lt;/p&gt;</comment>
                            <comment id="12900520" author="dagw" created="Fri, 20 Aug 2010 00:06:42 +0100"  >&lt;p&gt;Since this patch makes the intermediate (tableNumber, columnNumber) states (more) consistent and doesn&apos;t break anything as far as I can verify it, I propose to commit this patch soon unless somebody has objections.&lt;/p&gt;</comment>
                            <comment id="12901460" author="dagw" created="Mon, 23 Aug 2010 17:06:12 +0100"  >&lt;p&gt;Uploading a slightly improved version of the patch, derby-4695-fixcolumnno-1b. Relative to 1a,&lt;br/&gt;
I improved some comments and improved some code formatting, that&apos;s all.&lt;br/&gt;
Regressions ran ok.&lt;/p&gt;

&lt;p&gt;Again, the corrected behavior can be seen by running the new test case, testDerby_4695 without and with the patch trace-remapping.diff applied.&lt;/p&gt;</comment>
                            <comment id="12901520" author="dagw" created="Mon, 23 Aug 2010 19:18:00 +0100"  >&lt;p&gt;Commited patch 1b at svn 988204, closing. I do not intend to backport this one.&lt;/p&gt;</comment>
                            <comment id="12901665" author="dagw" created="Tue, 24 Aug 2010 00:20:54 +0100"  >&lt;p&gt;Changing Issue type to &quot;Improvement&quot;, since we haven&apos;t seen any bugs from this inconsistency.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12608438">DERBY-5933</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12366604">DERBY-2526</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12465506">DERBY-4679</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12448232" name="derby-4695-fixcolumnno-1a.diff" size="8033" author="dagw" created="Mon, 28 Jun 2010 21:17:29 +0100"/>
                            <attachment id="12448233" name="derby-4695-fixcolumnno-1a.stat" size="512" author="dagw" created="Mon, 28 Jun 2010 21:17:29 +0100"/>
                            <attachment id="12452822" name="derby-4695-fixcolumnno-1b.diff" size="8388" author="dagw" created="Mon, 23 Aug 2010 17:06:12 +0100"/>
                            <attachment id="12452823" name="derby-4695-fixcolumnno-1b.stat" size="512" author="dagw" created="Mon, 23 Aug 2010 17:06:12 +0100"/>
                            <attachment id="12446520" name="derby.log" size="81334" author="dagw" created="Mon, 7 Jun 2010 21:39:12 +0100"/>
                            <attachment id="12448235" name="query-a-after.log" size="147923" author="dagw" created="Mon, 28 Jun 2010 21:18:37 +0100"/>
                            <attachment id="12448234" name="query-a-before.log" size="147923" author="dagw" created="Mon, 28 Jun 2010 21:18:37 +0100"/>
                            <attachment id="12448237" name="query-b-after.log" size="284091" author="dagw" created="Mon, 28 Jun 2010 21:18:58 +0100"/>
                            <attachment id="12448236" name="query-b-before.log" size="284091" author="dagw" created="Mon, 28 Jun 2010 21:18:37 +0100"/>
                            <attachment id="12448239" name="trace-remapping.diff" size="838" author="dagw" created="Mon, 28 Jun 2010 21:37:13 +0100"/>
                            <attachment id="12447499" name="why-ij-can-do-without-2nd-bind.txt" size="51556" author="dagw" created="Fri, 18 Jun 2010 23:32:31 +0100"/>
                            <attachment id="12447498" name="why-loj-needs-2nd-bind.txt" size="68459" author="dagw" created="Fri, 18 Jun 2010 23:32:31 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 23 Jun 2010 03:42:41 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31333</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy09nr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35383</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>