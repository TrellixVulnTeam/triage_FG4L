<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:24:33 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3069/DERBY-3069.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3069] Derby does not resolve functions bound to methods with varargs.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3069</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Varargs were added in Java 5. It would be nice if Derby let you invoke a function bound to a method with a variable length argument list. The Reference Guide states a small number of restrictions for methods which can be invoked as Derby functions: They must be public, static, and not have arguments which are long datatypes. I see no reason that Derby shouldn&apos;t be able to resolve and invoke functions which are bound to methods which don&apos;t suffer these limitations but which have variable argument lists.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12378019">DERBY-3069</key>
            <summary>Derby does not resolve functions bound to methods with varargs.</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rhillegas">Rick Hillegas</assignee>
                                    <reporter username="rhillegas">Rick Hillegas</reporter>
                        <labels>
                            <label>derby_triage10_10</label>
                    </labels>
                <created>Wed, 12 Sep 2007 02:51:42 +0100</created>
                <updated>Fri, 14 Jun 2013 18:37:17 +0100</updated>
                            <resolved>Tue, 9 Apr 2013 19:35:40 +0100</resolved>
                                    <version>10.0.2.0</version>
                    <version>10.0.2.1</version>
                    <version>10.1.1.0</version>
                    <version>10.1.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                    <version>10.2.2.0</version>
                    <version>10.3.1.4</version>
                                    <fixVersion>10.10.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12526655" author="rhillegas" created="Wed, 12 Sep 2007 02:53:16 +0100"  >&lt;p&gt;To show the current behavior, compile the attached z.java source file and then run the attached z.sql scripts.&lt;/p&gt;</comment>
                            <comment id="12526828" author="djd" created="Wed, 12 Sep 2007 16:49:45 +0100"  >&lt;p&gt;One reason not to implement this is that method resolution is defined by the SQL Standard part 13, which does not cover 1.5 varargs since they were added later.&lt;/p&gt;</comment>
                            <comment id="12526829" author="djd" created="Wed, 12 Sep 2007 16:51:10 +0100"  >&lt;p&gt;I don&apos;t see this as a bug, it&apos;s an improvement.&lt;/p&gt;</comment>
                            <comment id="12526851" author="rhillegas" created="Wed, 12 Sep 2007 17:52:47 +0100"  >&lt;p&gt;Thanks for helping me puzzle through these issues.&lt;/p&gt;

&lt;p&gt;Just to be clear, I don&apos;t want to tackle varargs in CREATE FUNCTION statements. I think that lies outside the SQL standard. However, I think that the Derby SQL interpreter should be able to resolve method calls which the Java compiler can handle. So, for example, given the following method declaration in a Java class&lt;/p&gt;

&lt;p&gt;    public  static  String  varArgsFunc( String... args )&lt;/p&gt;

&lt;p&gt;I think that the following bindings should be meaningful and should be resolved when the functions are actually invoked:&lt;/p&gt;

&lt;p&gt;create function twoArgs( arg1 varchar( 10 ), arg2 varchar( 10 ) )&lt;br/&gt;
returns varchar( 40 )&lt;br/&gt;
language java&lt;br/&gt;
parameter style java&lt;br/&gt;
no sql&lt;br/&gt;
external name &apos;z.varArgsFunc&apos;&lt;br/&gt;
;&lt;/p&gt;

&lt;p&gt;create function threeArgs( arg1 varchar( 10 ), arg2 varchar( 10 ), arg3 varchar( 10 ) )&lt;br/&gt;
returns varchar( 40 )&lt;br/&gt;
language java&lt;br/&gt;
parameter style java&lt;br/&gt;
no sql&lt;br/&gt;
external name &apos;z.varArgsFunc&apos;&lt;br/&gt;
;&lt;/p&gt;

&lt;p&gt;Part 13 of the SQL standard is a little vague, but the resolution rules in the last paragraph of section 4.2.2 lead me to believe that the intention is that the SQL interpreter should follow the method resolution rules used by Java itself. I may not know where to look, but it seems to me that the Standard is vague about which version of Java is intended.&lt;/p&gt;

&lt;p&gt;I have no problem classifying this as an improvement rather than a bug. However, I think that for customers who are using Java 5 or Java 6, the description of CREATE FUNCTION in the Reference Guide is vague and misleading enough that something ought to be done: either tighten up the documentation or implement varargs resolution. I think that the latter makes Derby more useful.&lt;/p&gt;</comment>
                            <comment id="12526859" author="djd" created="Wed, 12 Sep 2007 18:19:17 +0100"  >&lt;p&gt;Section 8.6 of part 13 is very precise on the method resolution. It even mentions &quot;The Java Language Specification, Second Edition&quot; in one section.&lt;/p&gt;

&lt;p&gt;Can you be more explicit on what you see in the &quot;last paragraph of section 4.2.2&quot; that leads you to believe that Java method resolution is followed?&lt;/p&gt;

&lt;p&gt;Note that Java method resolution is not followed by the SQL Standard, e.g. a VARCHAR() column will not map to a java parameter of type Object&lt;br/&gt;
and a DECIMAL parameter will not map to an Object or Number.&lt;/p&gt;</comment>
                            <comment id="12526863" author="djd" created="Wed, 12 Sep 2007 18:26:18 +0100"  >&lt;p&gt;In what way is the description of CREATE FUNCTION misleading? I agree that it&apos;s vague, it just points to the standards without really explicitly stating which standard, but I don&apos;t see anything misleading.&lt;/p&gt;</comment>
                            <comment id="12526868" author="djd" created="Wed, 12 Sep 2007 18:53:56 +0100"  >&lt;p&gt;Question though, is the varargs just syntax at the Java language level or is the information propagated all the way to the class file?&lt;/p&gt;

&lt;p&gt;If it&apos;s just at the java compiler level then Derby could not implement it as it would be impossible to distinguish between a varargs method and one declared with the corresponding array type.   x(String ... args) and x(String[] args) &lt;span class=&quot;error&quot;&gt;&amp;#91;not even sure how Java handles this&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;From a very quick look at java.lang.reflect I couldn&apos;t see any mechanism to determine if a method to a parameter was a varargs one, though I could have missed it.&lt;/p&gt;

</comment>
                            <comment id="12526879" author="rhillegas" created="Wed, 12 Sep 2007 19:33:36 +0100"  >&lt;p&gt;Thanks for the reference to The Java Language Specification, Second Edition late in Part 13, Section 8.6. That section seems to indicate that the Java method resolution rules are to be applied to isolate a set of candidate methods after the types of the arguments have been mapped from SQL types to Java types. The sentence in section 4.2.2 which leapt out at me was this: &quot;If the instance SQL-invoked method is an external Java routine, the term &quot;set of overriding methods&quot; is not applicable; for such methods, the capabilities provided by overriding methods duplicate Java&apos;s own mechanisms and the subject routine executed is the one that would be invoked when no overriding methods are specified.&quot;&lt;/p&gt;

&lt;p&gt;The CREATE FUNCTION section is vague about how Derby will resolve methods at run-time. Where is this documented?&lt;/p&gt;

&lt;p&gt;The varargs information must be propagated to the classfile. It can be retrieved via reflection by calling Method.isVarArgs().&lt;/p&gt;</comment>
                            <comment id="12526882" author="djd" created="Wed, 12 Sep 2007 19:53:20 +0100"  >&lt;p&gt;For section 4.2.2 (second to last paragraph, the one starting &quot;Replace the 4th paragraph&quot;) - Derby does not support SQL-invoked methods.&lt;/p&gt;

&lt;p&gt;The PARAMETER STYLE section of CREATE FUNCTION and PROCEDURE state how the method is to be resolved, which is vague in terms of where to find the information but precise in that the rules are defined elsewhere.&lt;/p&gt;

&lt;p&gt;Missed that isVarArgs method, was instead looking for information at the parameter level, thanks&lt;/p&gt;</comment>
                            <comment id="12528048" author="rhillegas" created="Mon, 17 Sep 2007 13:56:21 +0100"  >&lt;p&gt;Attaching derby-3069-01-aa.diff. This allows you to run functions which are bound to methods which have vararg signatures. Touches the following files:&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java&lt;/p&gt;

&lt;p&gt;This is the compile-time bind() logic. This allows you to resolve function declarations against methods which have vararg signatures. This also exposes helper methods for determining whether a method has a vararg signature.&lt;/p&gt;


&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java&lt;/p&gt;

&lt;p&gt;This is the compile-time generate() piece, which generates the byte code needed to invoke varags methods. For varargs signatures, this method builds a concluding array argument and stuffs it with the trailing arguments specified by the user.&lt;/p&gt;
</comment>
                            <comment id="12528051" author="rhillegas" created="Mon, 17 Sep 2007 13:57:47 +0100"  >&lt;p&gt;This patch passes the existing regression tests. Does not, however, introduce any new tests yet.&lt;/p&gt;</comment>
                            <comment id="12528566" author="rhillegas" created="Tue, 18 Sep 2007 22:16:59 +0100"  >&lt;p&gt;Dan posted the following questions on derby-dev because JIRA was down:&lt;/p&gt;

&lt;p&gt;&amp;gt;Is there going to be some write up on exactly how the proposed method resolution will work with varargs, so that people can review it and see if it conflicts with the standard method resolution?&lt;/p&gt;

&lt;p&gt;The current resolution rules are mentioned in the Reference Guide section on CREATE FUNCTION in the subsection on PARAMETER STYLE. There the reader is told that the resolution rules are the ones described in part 13 of the SQL Standard. Let us call those resolution rules the OldRules.&lt;/p&gt;

&lt;p&gt;1) If the Derby engine is running on a pre-Java-5 vm (that is, JDK 1.4 or the CDC small device platform), then the resolution rules are the OldRules.&lt;/p&gt;

&lt;p&gt;2) If the  Derby engine is running on Java 5 or later, then the resolution rules are the OldRules with the following change: The SQL Standard, part 13, section 8.6, refers to the resolution rules described in The Java Language Specification, Second Edition. Replace that with a reference to the resolution rules in The Java Language Specification, Third Edition.&lt;/p&gt;

&lt;p&gt;&amp;gt;Will this be a different PARAMETER STYLE (than JAVA)? If not what does it say about Derby&apos;s commitment to standards when a SQL routine resolves to a method in Derby that it would not resolve to on another database that is following the SQL standard?&lt;/p&gt;

&lt;p&gt;I would have no problem limiting the application of these rules to functions/procedures which are declared with some other PARAMETER STYLE. Currently, we have 2 parameter styles, namely, JAVA and DERBY_JDBC_RESULT_SET. The second style is used for Derby-style table functions as described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-716&quot; title=&quot;Re-enable VTIs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-716&quot;&gt;&lt;del&gt;DERBY-716&lt;/del&gt;&lt;/a&gt;. You are only allowed to specify one parameter style according to the SQL Standard, part 2, section 11.50, syntax rule 6a. Now we need to consider the problem of ORing parameter styles together, so that, for instance, we can have a table function resolve against a method with a varags signature. I see a couple solutions to this problem:&lt;/p&gt;

&lt;p&gt;a) Introduce one new parameter style. Let&apos;s call it DERBY. Get rid of DERBY_JDBC_RESULT_SET. If the parameter style is DERBY, then table functions resolve to ResultSet-returning-methods and vararg resolution happens according to rule (2) above. In this scheme, there are 2 parameter styles: JAVA and DERBY.&lt;/p&gt;

&lt;p&gt;b) Introduce one new parameter style. Let&apos;s call it DERBY_VARARGS. The existing DERBY_JDBC_RESULT_SET parameter style continues to behave as it does today, that is, it resolves table functions to ResultSet-returning-methods but it uses OldRules regardless of the platform. Parameter style DERBY_VARARGS behaves as parameter style DERBY does in case (a). In this scheme, there are 3 parameter styles: JAVA, DERBY_VARARGS, and DERBY_JDBC_RESULT_SET.&lt;/p&gt;

&lt;p&gt;c) Introduce two new parameter styles. Let&apos;s call them DERBY_VARARGS_PLAIN and DERBY_VARARGS_JDBC_RESULT_SET. DERBY_VARARGS_PLAIN follows vararg resolution rule (2) but does not resolve table functions to ResultSet-returning-methods. DERBY_VARARGS_JDBC_RESULT_SET behaves as parameter style DERBY does in case (a). In this scheme, there are 4 parameter styles: JAVA, DERBY_JDBC_RESULT_SET, DERBY_VARARGS_PLAIN, and DERBY_VARARGS_JDBC_RESULT_SET.&lt;/p&gt;

&lt;p&gt;I would vote for option (a). As time goes on, people may need to implement other Derby-specific method resolution rules. At that time, they should consider whether to enrich the DERBY style or create a new one.&lt;/p&gt;</comment>
                            <comment id="12528637" author="dagw" created="Wed, 19 Sep 2007 03:21:48 +0100"  >&lt;p&gt;&amp;gt; 2) If the Derby engine is running on Java 5 or later, then the&lt;br/&gt;
&amp;gt; resolution rules are the OldRules with the following change: The SQL&lt;br/&gt;
&amp;gt; Standard, part 13, section 8.6, refers to the resolution rules&lt;br/&gt;
&amp;gt; described in The Java Language Specification, Second Edition. Replace&lt;br/&gt;
&amp;gt; that with a reference to the resolution rules in The Java Language&lt;br/&gt;
&amp;gt; Specification, Third Edition.&lt;/p&gt;

&lt;p&gt;I think we should allow ourselves to regard the standard&apos;s intent&lt;br/&gt;
rather than letter here: JAVA PARAMETER STYLE should be allowed to&lt;br/&gt;
resolve to varargs when running on Java 5 or later, since this is a&lt;br/&gt;
now a part of Java. (As well as for DERBY_JDBC_RESULT_SET).&lt;/p&gt;</comment>
                            <comment id="12528921" author="rhillegas" created="Wed, 19 Sep 2007 22:52:09 +0100"  >&lt;p&gt;Attaching a second rev of this patch: derby-3069-01-varargs-ab.diff. This fixes a corner case in the previous rev: In Java 5, a no argument invocation of a method can end up bound to a varargs overload. So, for instance, if you declare&lt;/p&gt;

&lt;p&gt;public static String sampleVarargs( String... args )&lt;/p&gt;

&lt;p&gt;then, barring an ambiguity, the following invocation will resolve to it:&lt;/p&gt;

&lt;p&gt;stringResult = sampleVarargs();&lt;/p&gt;

&lt;p&gt;This patch lets you bind no-arg functions/procedures to vararg static public methods.&lt;/p&gt;</comment>
                            <comment id="12529415" author="rhillegas" created="Fri, 21 Sep 2007 14:08:50 +0100"  >&lt;p&gt;I agree with Dag here. I think that the divergence from the ANSI spec is in line with the intention of the spec. I am inclined to do the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Commit derby-3069-01-varargs-ab.diff.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Add a note to the PARAMETER STYLE sub-topic of the CREATE FUNCTION topic in the Derby Reference Guide. The note would explain the divergence from the ANSI spec.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Please let me know if there are any strong objections to this approach.&lt;/p&gt;</comment>
                            <comment id="12530446" author="rhillegas" created="Wed, 26 Sep 2007 14:52:00 +0100"  >&lt;p&gt;No strong objections have surfaced. I have committed derby-3069-01-varargs-ab.diff at subversion revision 579653.&lt;/p&gt;</comment>
                            <comment id="12531092" author="djd" created="Fri, 28 Sep 2007 18:20:00 +0100"  >&lt;p&gt;&amp;gt;&amp;gt; 2) If the Derby engine is running on Java 5 or later, then the&lt;br/&gt;
&amp;gt;&amp;gt; resolution rules are the OldRules with the following change: The SQL&lt;br/&gt;
&amp;gt;&amp;gt; Standard, part 13, section 8.6, refers to the resolution rules&lt;br/&gt;
&amp;gt;&amp;gt; described in The Java Language Specification, Second Edition. Replace&lt;br/&gt;
&amp;gt;&amp;gt; that with a reference to the resolution rules in The Java Language&lt;br/&gt;
&amp;gt;&amp;gt; Specification, Third Edition.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think we should allow ourselves to regard the standard&apos;s intent&lt;br/&gt;
&amp;gt; rather than letter here: JAVA PARAMETER STYLE should be allowed to&lt;br/&gt;
&amp;gt; resolve to varargs when running on Java 5 or later, since this is a&lt;br/&gt;
&amp;gt; now a part of Java. (As well as for DERBY_JDBC_RESULT_SET).&lt;/p&gt;

&lt;p&gt;I think we need to be very careful here. Section 8.6 SR 3b case 2)  B II is the section that mentions the java language specification and it does &lt;b&gt;not&lt;/b&gt; apply to Derby&apos;s Java routines (SQL invoked routines). &lt;/p&gt;

&lt;p&gt;SQL resolution of SQL invoked routines to Java static methods does &lt;b&gt;not&lt;/b&gt; not follow Java rules, thus one cannot rely on that to justify that varargs can be resolved to because Java supports it.&lt;/p&gt;

&lt;p&gt;It would be really helpful if a functional spec was written indicating when &amp;amp; how varargs resolution will  be used and when it will not.&lt;/p&gt;</comment>
                            <comment id="12531168" author="rhillegas" created="Fri, 28 Sep 2007 22:12:44 +0100"  >&lt;p&gt;Let&apos;s figure out what a functional spec for this would look like. I think that we have to start out assuming that Derby implements the relevant rules in Section 8.6. Given that, I think that a functional spec would consist of describing the delta from those rules needed to support varargs. Does that sound useful and adequate to you?&lt;/p&gt;

&lt;p&gt;In describing a delta, I think that the crucial terms in 8.6 are JPDL and JCS. JPDL is the Java Parameter Datatype List, determined by applying earlier rules to the SQL datatypes of the routine invocation. JCS is the set of candidate methods which the rules consider as possible resolutions of the routine invocation. At the end of the process, there should be exactly 1 method in JCS. I do not believe that varargs change the definition of JPDL. However, I believe that varargs can add more candidate methods to JCS. So I believe it is that delta to JCS which must be described. Again, does that sound correct to you?&lt;/p&gt;

&lt;p&gt;It is easy for me to get lost in section 8.6. However, I think that the relevant part of that section is Rule 3, case b, step 4, case 1. I think that is the subsection which describes how to construct JCS for Derby&apos;s SQL invoked routines. Do you agree?&lt;/p&gt;</comment>
                            <comment id="12531182" author="djd" created="Fri, 28 Sep 2007 23:55:29 +0100"  >&lt;p&gt;&amp;gt; I do not believe that varargs change the definition of JPDL.&lt;br/&gt;
&amp;gt; However, I believe that varargs can add more candidate methods to JCS.&lt;br/&gt;
&amp;gt; So I believe it is that delta to JCS which must be described. Again, does that sound correct to you?&lt;/p&gt;

&lt;p&gt;I think this all depends on what you intend to implement (or have implemented). E.g. JPDL could support a varargs declaration in its &amp;lt;Java parameter declaration list&amp;gt;, not sure if you intend to do this or not, since it&apos;s non standard I can&apos;t guess what you are trying to implement, thus it&apos;s hard to review any patch as it&apos;s unclear what the intended behave is, beyond a vague &quot;support varargs&quot; statement.&lt;/p&gt;
</comment>
                            <comment id="12531561" author="rhillegas" created="Mon, 1 Oct 2007 17:49:42 +0100"  >&lt;p&gt;Here&apos;s a stab at a functional spec for this behavior:&lt;/p&gt;

&lt;p&gt;User Experience:&lt;/p&gt;

&lt;p&gt;1) Functions and Procedures (with fixed numbers of arguments) can resolve to Java methods with varargs signatures when Derby runs on Java 5 or higher.&lt;/p&gt;

&lt;p&gt;2) Does NOT allow varargs in the SQL declaration of the arguments of Functions and Procedures.&lt;/p&gt;


&lt;p&gt;Method Resolution Details:&lt;/p&gt;

&lt;p&gt;The method resolution rules for SQL invoked routines are described in the SQL Standard, part 13, section 8.6. We change the resolution rules given in Rule 3, case b, step 4, case 1. More specifically, we expand JCS to include additional candidate methods. The additional methods obey the following rules.&lt;/p&gt;

&lt;p&gt;Let the number of arguments in JPDL be SQLArgCount. Let Candidate be a method which satisfies the following:&lt;/p&gt;

&lt;p&gt;aa) Candidate is a visible Java method in class JCLSN in Jar JN with method name JMN.&lt;/p&gt;

&lt;p&gt;bb) Candidate has CandidateArgCount arguments in its signature. The last argument in that signature is a vararg argument of type T.&lt;/p&gt;

&lt;p&gt;cc) The first CandidateArgCount-1 arguments of JPDL have the types of the first CandidateArgCount-1 arguments of Candidate.&lt;/p&gt;

&lt;p&gt;dd) If SQLArgCount == CandidateArgCount-1, then Candidate is added to JCS.&lt;/p&gt;

&lt;p&gt;ee) If SQLArgCount &amp;gt;= CandidateArgCount and all of the arguments in JPDL from CandidateArgCount onward have type T, then Candidate is added to JCS.&lt;/p&gt;</comment>
                            <comment id="12531590" author="djd" created="Mon, 1 Oct 2007 19:24:57 +0100"  >&lt;p&gt;Thanks Rick, some questions based upon this:&lt;/p&gt;

&lt;p&gt;1) When Java resolves to methods with varargs it&apos;s a two phase process, so that if a non-varargs method that matches the arguments exists, it takes precedence over any varargs methods that matches the arguments. It seems with what you are describing this paradigm is not followed, which means that the presence of a varargs method could break an existing application once this improvement is enabled. One extreme case of this is the method foo(T ...) for any type T will cause failure when the Java routine with no parameters previously mapped to foo().&lt;/p&gt;

&lt;p&gt;Is this potential to break existing applications intentional, or should the method resolution follow something similar to Java&apos;s two stage process?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) Any issues with INOUT or OUT parameters that end up being mapped to the varargs? Especially for how the implementation of the varargs method would access the INOUT/OUT parameters?&lt;/p&gt;

&lt;p&gt;3) How about varargs with DYNAMIC RESULT SETS, can the return of the ResultSet&apos;s be through a varargs parameter? I assume not.&lt;/p&gt;

&lt;p&gt;4) Java&apos;s limitation to a single varargs argument in the last position leads to a somewhat strange situation. A procedure with multiple SQL  parameters of the same type can map to a  varargs method only when DYNAMIC RESULT SETS is zero.&lt;/p&gt;</comment>
                            <comment id="12531592" author="rhillegas" created="Mon, 1 Oct 2007 19:35:40 +0100"  >&lt;p&gt;Thanks for the quick response, Dan. Unfortunately, I&apos;m going to be on the road for the next couple days and won&apos;t have time to give you a thoughtful response until the end of the week. Please bear with me.&lt;/p&gt;</comment>
                            <comment id="12532693" author="rhillegas" created="Fri, 5 Oct 2007 16:51:30 +0100"  >&lt;p&gt;Thanks again for helping me puzzle through this, Dan. Here are some responses to your questions:&lt;/p&gt;

&lt;p&gt;1) I like what you propose: if there is a non-varargs resolution for a routine invocation, then that should be preferred over a varargs resolution. I think that this means that we would keep two lists of candidate methods as we resolve the invocation: JCS (already described in section 8.6) and JCVS (the set of candidate resolutions which have vararg signatures). The extra varargs methods which I proposed to put into JCS would instead go into JCVS. Then we would continue:&lt;/p&gt;

&lt;p&gt;a) If JCS has exactly one method in it, that is the resolution of the routine invocation.&lt;/p&gt;

&lt;p&gt;b) If JCS has more than one method in it, then we raise an error.&lt;/p&gt;

&lt;p&gt;c) Otherwise JCS is empty and we continue:&lt;/p&gt;

&lt;p&gt;d) If JCVS has exactly one method in it, then that is the resolution of the routine invocation.&lt;/p&gt;

&lt;p&gt;e) Otherwise, we raise an error.&lt;/p&gt;

&lt;p&gt;Does this sound reasonable?&lt;/p&gt;

&lt;p&gt;2) I think that INOUT and OUT parameters can resolve to varargs provided that we are careful that the vararg type is itself an array. So, for instance if we declare&lt;/p&gt;

&lt;p&gt;create procedure foo( inout arg1 varchar( 30 ) ) ...&lt;/p&gt;

&lt;p&gt;then an invocation of this procedure could resolve to the following method&lt;/p&gt;

&lt;p&gt;public static void fooRes( String[]... inoutargs )&lt;/p&gt;

&lt;p&gt;but not&lt;/p&gt;

&lt;p&gt;public static void fooRes( String... args)&lt;/p&gt;

&lt;p&gt;Right now, we are not correcty resolving these INOUT/OUT parameters against varargs signatures. That is, we are not detecting the vararg candidates and so resolution fails. That&apos;s a bug I need to fix. Are you seeing other subtleties here?&lt;/p&gt;

&lt;p&gt;3) I don&apos;t think I understand the subtleties of DYNAMIC RESULT SETS. Could you elaborate on why you think that we should not support these as varargs? Off the top of my head, it seems that we ought to be able to resolve dynamic result sets to varargs. So for instance, if we declare the following procedure:&lt;/p&gt;

&lt;p&gt;create procedure dynamicResultSet( arg1 int ) ... dynamic result sets 2 ...&lt;/p&gt;

&lt;p&gt;then an invocation of this procedure should be resolvable to&lt;/p&gt;

&lt;p&gt;public static void dynamicResultSetRes( int arg1, ResultSet[]... dynamicResultSets )&lt;/p&gt;

&lt;p&gt;4) I agree that it is unfortunate that we can&apos;t mix vararg parameters with dynamic result sets.&lt;/p&gt;</comment>
                            <comment id="12532709" author="djd" created="Fri, 5 Oct 2007 17:42:01 +0100"  >&lt;p&gt;Thanks Rick, I&apos;m still not sure that varargs should be resolved to when using PARAMETER STYLE JAVA for two reasons, but it&apos;s better to discuss that with a concrete detailed proposal, which we are heading towards. The two reasons I see for not supporting it are:&lt;/p&gt;

&lt;p&gt;A) It&apos;s non standard, an application using this would fail to run on a database following the standard, thus breaking Derby&apos;s charter.&lt;/p&gt;

&lt;p&gt;B) It doesn&apos;t provide much benefit, it&apos;s forcing a varargs method on a calling sequence that does not have variable numbers of arguments. SQL routines have fixed number of arguments. An application can always provide a wrapper method for a SQL routine that calls the varargs method.&lt;/p&gt;

&lt;p&gt;Having said that, here&apos;s some feedback on the latest comment.&lt;/p&gt;

&lt;p&gt;1) looks reasonable.&lt;/p&gt;

&lt;p&gt;2) What you describe does not match how varargs work in Java today. Not saying that&apos;s good or bad, just pointing it out.&lt;/p&gt;

&lt;p&gt;   v1(new String&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;) will resolve to a method v1(String ...)&lt;/p&gt;

&lt;p&gt;  Will it be confusing if Derby&apos;s resolution to varargs methods does not match Java semantics?&lt;/p&gt;

&lt;p&gt;  I also wonder if there&apos;s a bug (before any of your changes) where an INOUT/OUT parameter would incorrectly resolve to a varargs method.&lt;/p&gt;

&lt;p&gt;3) Maybe it&apos;s just the non-standard nature that makes me think DYNAMIC RESULT SETS should not resolve to varargs. I can an argument that allowing resolution to varargs methods that form part of some external library, like J2SE libraries, JavaMail etc. But no library is going to have method that is suitable for dynamic result sets, thus any method for dynamic result sets is going to be specific for that application, so what&apos;s the benefit of varargs?&lt;/p&gt;

&lt;p&gt;Within the implementation of such a method, does the use of varargs make the code easier to understand?&lt;/p&gt;

&lt;p&gt;     customerList&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = ps.executeQuery();    // non-varargs allows the variables holding the ResultSet to be specifically named&lt;/p&gt;

&lt;p&gt;      drs&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = ps.executeQuery();  // varargs, single name for the variable used to return result sets (or additional code to create local variables)&lt;/p&gt;

&lt;p&gt;One other issue here is how big an array should Derby pass into the varargs method? Is it as simple as the dynamic result set count? I don&apos;t think that&apos;s how the non-varargs method works, I think it can resolve to a method (as per spec) with any number of ResultSet[] parameters. Ie. with a maximum of three dynamic result sets the method may have holders for six ResultSets, but only return three, or could return five with two closed.&lt;/p&gt;

&lt;p&gt;DYNAMIC RESULT SETS is a variable number of ResultSets on the return from the method, not the input to the method, thus I don&apos;t think it really fits the Java varargs paradigm.&lt;/p&gt;</comment>
                            <comment id="12532771" author="rhillegas" created="Fri, 5 Oct 2007 21:44:05 +0100"  >&lt;p&gt;Thanks for the continued discussion, Dan. Some more responses follow:&lt;/p&gt;

&lt;p&gt;A) If we need another parameter style, I think that&apos;s ok. I would just like to keep the number of parameter styles to a minimum.&lt;/p&gt;

&lt;p&gt;B) To me there is a lot of value in taking advantage of Java 5 varargs even though you can&apos;t declare vararg SQL signatures yet. I agree that it is awkward that your application code still has to declare a separate SQL method for each new signature that it needs. Without support for Java 5 varargs, the application has to do the following additional work too:&lt;/p&gt;

&lt;p&gt;i) Generate and compile Java wrapper code for the new signature.&lt;/p&gt;

&lt;p&gt;ii) Replace the relevant server jar file either directly on the classpath or as stored in the database.&lt;/p&gt;

&lt;p&gt;I find that eliminating these steps is a welcome benefit.&lt;/p&gt;


&lt;p&gt;2) I can&apos;t say whether other people would find the INOUT/OUT resolution confusing. It seems straightforward to me.&lt;/p&gt;


&lt;p&gt;3) I haven&apos;t found a need for ResultSet varargs yet so I don&apos;t have any experience to suggest whether this makes the code easier or harder to write. However, I think that the advantages described for (B) still apply here. If we continue with the behavior described for (1), then I think that the existing SQL Standard rules continue to apply.&lt;/p&gt;

&lt;p&gt;Because I haven&apos;t personally needed ResultSet varargs yet, I don&apos;t have a lot of passion about the issue. We could not support ResultSet varargs for 10.4. If someone needed this feature later on, they could add it--by adding a third phase to the resolution process, we could continue to preserve backward compatibility.&lt;/p&gt;</comment>
                            <comment id="12548201" author="dyret" created="Tue, 4 Dec 2007 10:07:12 +0000"  >&lt;p&gt;Since the discussion appears to have stalled (last comment is from 5 Oct) before reaching a consensus, I&apos;m removing the &apos;patch available&apos; flag. &lt;/p&gt;</comment>
                            <comment id="12571634" author="rhillegas" created="Fri, 22 Feb 2008 23:07:58 +0000"  >&lt;p&gt;Attaching derby-3069-02-backout.diff, which backs out this feature. I do not have time to polish this before 10.4 code freeze. Committed at subversion revision 630351.&lt;/p&gt;</comment>
                            <comment id="13485096" author="rhillegas" created="Fri, 26 Oct 2012 19:29:03 +0100"  >&lt;p&gt;Here is my current thinking on this topic:&lt;/p&gt;

&lt;p&gt;1) We would clearly mark this as a Derby extension by using a new DERBY parameter style.&lt;/p&gt;

&lt;p&gt;2) We would clearly mark routines which were meant to resolve against vararg methods. If the last (and only the last) argument of the routine declaration ended with an ellipsis token (...), then the routine would have to resolve to a Java varargs method.&lt;/p&gt;

&lt;p&gt;So, for example, consider the following SQL function definition. Note the use of the DERBY parameter style and the ellipsis token:&lt;/p&gt;

&lt;p&gt;create function maximum( a int... ) returns int&lt;br/&gt;
language java parameter style derby no sql&lt;br/&gt;
external name &apos;IntFunctions.maximum&apos;;&lt;/p&gt;

&lt;p&gt;This SQL signature would resolve to the following Java vararg method:&lt;/p&gt;

&lt;p&gt;    public  static  Integer maximum( Integer... args )&lt;br/&gt;
    {&lt;br/&gt;
        if ( args == null ) &lt;/p&gt;
{ return null; }&lt;br/&gt;
        if ( args.length == 0 ) { return null; }

&lt;p&gt;        int     result = Integer.MIN_VALUE;&lt;br/&gt;
        for ( Integer value : args )&lt;br/&gt;
        {&lt;br/&gt;
            if ( value == null ) &lt;/p&gt;
{ return null; }
&lt;p&gt;            else &lt;/p&gt;
{ result = Math.max( result, value.intValue() ); }
&lt;p&gt;        }&lt;/p&gt;

&lt;p&gt;        return result;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;3) We would need to decide what to do about procedures which return dynamic ResultSets. That is because dynamic ResultSets and Java varargs both make claims on the trailing arguments of the Java method signature. Here are some possible ways to handle this problem:&lt;/p&gt;

&lt;p&gt;3a) Do not allow varargs if the procedure is defined with a DYNAMIC RESULT SETS greater than 0.&lt;/p&gt;

&lt;p&gt;3b) Allow the Java varargs argument to come AFTER the ResultSet[] arguments. So the Java method signature would begin with the non-vararg arguments, followed by a number of ResultSet[] arguments equal to the value of DYNAMIC RESULT SETS, followed by a trailing ellipsis tagged argument. So this SQL declaration&lt;/p&gt;

&lt;p&gt;create procedure varargProcWithDynamicResultSets&lt;br/&gt;
( in a int, b int, in f bigint... )&lt;br/&gt;
language java parameter style derby reads sql data&lt;br/&gt;
dynamic result sets 2&lt;br/&gt;
external name &apos;Procs.varargProcWithDynamicResultSets&apos;;&lt;/p&gt;

&lt;p&gt;would bind to this Java signature:&lt;/p&gt;

&lt;p&gt;public static void varargProcWithDynamicResultSets&lt;br/&gt;
( int a, int b, int c, ResultSet[] d, ResultSet[] e, long... f )&lt;/p&gt;


&lt;p&gt;What do other people think?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13489419" author="knutanders" created="Fri, 2 Nov 2012 13:26:16 +0000"  >&lt;p&gt;Using a special parameter style to enable this functionality sounds fine to me. That&apos;s the same thing we do for table functions, and it would prevent conflicts with future standardization in this area.&lt;/p&gt;

&lt;p&gt;As to item 3 above, I&apos;d suggest that we go for option 3a in the first iteration, and revisit it when we have more experience with how vararg functions are used.&lt;/p&gt;</comment>
                            <comment id="13492333" author="rhillegas" created="Wed, 7 Nov 2012 13:25:27 +0000"  >&lt;p&gt;Thanks for that feedback, Knut. Attaching Varargs.html, the first draft of a functional spec for this feature.&lt;/p&gt;</comment>
                            <comment id="13510625" author="rhillegas" created="Wed, 5 Dec 2012 17:47:02 +0000"  >&lt;p&gt;Attaching derby-3069-03-aa-varargsSyntax.diff. This patch adds DDL support for vararg routines. I am running regression tests now.&lt;/p&gt;

&lt;p&gt;This patch adds support for declaring vararg functions and procedures. Syntax like the following is supported:&lt;/p&gt;

&lt;p&gt;  create procedure varargsderbystyle ( a int ... )&lt;br/&gt;
  language java parameter style derby no sql external name &apos;Foo.foo&apos; ;&lt;/p&gt;

&lt;p&gt;  create function varargsderbystyle ( a int ... ) returns integer&lt;br/&gt;
  language java parameter style derby no sql external name &apos;Foo.foo&apos; ;&lt;/p&gt;

&lt;p&gt;  create function varargstablefunction ( a int ... )&lt;br/&gt;
  returns table ( b int )&lt;br/&gt;
  language java parameter style derby_jdbc_result_set no sql external name &apos;Foo.foo&apos; ;&lt;/p&gt;

&lt;p&gt;Invocations of these routines aren&apos;t bound to actual varargs methods yet. That will happen in a follow-on patch.&lt;/p&gt;



&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/catalog/types/RoutineAliasInfo.java&lt;/p&gt;

&lt;p&gt;Metadata changes to support vararg routines and the new DERBY parameter style.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;/p&gt;

&lt;p&gt;Data dictionary changes to declare existing functions/procedures as non-vararg routines.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;


&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java&lt;/p&gt;

&lt;p&gt;Parse- and bind-time support for declaring vararg routines.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/loc/messages.xml&lt;br/&gt;
M       java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/p&gt;

&lt;p&gt;New error messages.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java&lt;br/&gt;
A       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsTest.java&lt;/p&gt;

&lt;p&gt;Syntax tests for declaring vararg routines.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/tools/dblook_makeDB.sql&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/master/dblook_test.out&lt;/p&gt;

&lt;p&gt;Test to verify that dblook turns out the correct DDL for vararg routines.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_10.java&lt;/p&gt;

&lt;p&gt;Upgrade tests.&lt;/p&gt;</comment>
                            <comment id="13510739" author="rhillegas" created="Wed, 5 Dec 2012 20:35:38 +0000"  >&lt;p&gt;Attaching derby-3069-03-ab-varargsSyntax.diff. I needed to update some more canons for the dblook tests. I will re-run the regression tests.&lt;/p&gt;

&lt;p&gt;Touches the following additional files:&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/master/dblook_test_territory.out&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/dblook_test_net.out&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/master/DerbyNetClient/dblook_test_net_territory.out&lt;/p&gt;</comment>
                            <comment id="13510743" author="rhillegas" created="Wed, 5 Dec 2012 20:38:01 +0000"  >&lt;p&gt;The current rev of the functional spec needs a correction: The spec says that the varargs ... delimiter is only allowed if the parameter style is DERBY. I need to update to say that varargs are also allowed for parameter style DERBY_JDBC_RESULT_SET. Before posting a new spec, I will wait to see if other corrections to the spec arise during implementation.&lt;/p&gt;</comment>
                            <comment id="13510898" author="rhillegas" created="Wed, 5 Dec 2012 23:25:48 +0000"  >&lt;p&gt;Tests passed cleanly for me on derby-3069-03-ab-varargsSyntax.diff.&lt;/p&gt;</comment>
                            <comment id="13511594" author="rhillegas" created="Thu, 6 Dec 2012 18:29:16 +0000"  >&lt;p&gt;I committed derby-3069-03-ab-varargsSyntax.diff at subversion revision 1417835.&lt;/p&gt;</comment>
                            <comment id="13511596" author="rhillegas" created="Thu, 6 Dec 2012 18:30:59 +0000"  >&lt;p&gt;Attaching derby-3069-04-aa-shortenRoutineNamesInUpgradeTest.diff. My previous submission raised an error in the upgrade tests. This patch should fix that problem. Committed at subversion revision 1418022.&lt;/p&gt;

&lt;p&gt;The problem was that my new upgrade test created functions and procedures with names which were longer than 18 characters. In 10.0, the very first release of Derby, that&apos;s the limit on the length of SQL identifiers. In 10.1, the limit was raised to 128 (see submission 170069 by Sateesh).&lt;/p&gt;

&lt;p&gt;This patch shortens the lengths of the problematic identifiers. With this patch, the upgrade tests run cleanly for me when the initial release is 10.0.2.1.&lt;/p&gt;


&lt;p&gt;Touches the following file:&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_10.java&lt;/p&gt;</comment>
                            <comment id="13527990" author="rhillegas" created="Mon, 10 Dec 2012 15:08:26 +0000"  >&lt;p&gt;Attaching derby-3069-05-aa-executeVarargs.diff. This patch wires in bind() and generate() logic for vararg routines so that they can now be invoked. Many more tests need to be written but this patch supplies some initial test cases for invoking vararg routines. I am running regression tests now.&lt;/p&gt;

&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;-----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/services/loader/Java5ClassInspector.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/services/loader/ClassInspector.java&lt;/p&gt;

&lt;p&gt;Added a method to introspect whether a Java method is a varargs method.&lt;/p&gt;

&lt;p&gt;-----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;/p&gt;

&lt;p&gt;Fixed a comment and the declaration of the pi() system method.&lt;/p&gt;

&lt;p&gt;-----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/NewInvocationNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java&lt;/p&gt;

&lt;p&gt;A couple changes:&lt;/p&gt;

&lt;p&gt;1) For a varargs routine, at bind() time coerce the trailing invocation parameters to the declared type of the varargs argument. This involved factoring out the coercion logic into a separate method: coerceMethodParameter().&lt;/p&gt;

&lt;p&gt;2) For a varargs routine, at generate() time stuff the trailing, coerced invocation parameters into an array, which is the actual generated vararg argument. This involved factoring the parameter-generating logic into a separate method: generateAndCastOneParameter().&lt;/p&gt;

&lt;p&gt;I also changed the formatting of the unreadable code I was touching and corrected one of my pet peeves: putting brackets around one-line consequences of &quot;if&quot; statements. This makes the changes to these classes look more substantial.&lt;/p&gt;

&lt;p&gt;-----------------&lt;/p&gt;

&lt;p&gt;A       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsRoutines.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/build.xml&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsTest.java&lt;/p&gt;

&lt;p&gt;More tests.&lt;/p&gt;</comment>
                            <comment id="13528052" author="rhillegas" created="Mon, 10 Dec 2012 16:43:04 +0000"  >&lt;p&gt;Tests passed cleanly for me on derby-3069-05-aa-executeVarargs.diff.&lt;/p&gt;</comment>
                            <comment id="13528979" author="rhillegas" created="Tue, 11 Dec 2012 13:59:34 +0000"  >&lt;p&gt;Committed derby-3069-05-aa-executeVarargs.diff at subversion revision 1420165.&lt;/p&gt;</comment>
                            <comment id="13530243" author="rhillegas" created="Wed, 12 Dec 2012 19:35:31 +0000"  >&lt;p&gt;Attaching derby-3069-06-ab-fixBugs.diff. This patch fixes various bugs in the binding and code-generating of varargs calls. I am running regression tests now.&lt;/p&gt;

&lt;p&gt;This patch fixes the following bugs:&lt;/p&gt;

&lt;p&gt;1) Primitive vararg args were being treated as the correponding wrapper types.&lt;/p&gt;

&lt;p&gt;2) OUT and INOUT varargs to procedures needed extra logic to handle the extra array level added by OUT and INOUT args.&lt;/p&gt;

&lt;p&gt;In addition, this patch adds a number of tests.&lt;/p&gt;



&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;-----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java&lt;/p&gt;

&lt;p&gt;Changes to handle primitive varargs and OUT/INOUT procedure parameters.&lt;/p&gt;

&lt;p&gt;-----------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsRoutines.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsTest.java&lt;/p&gt;

&lt;p&gt;More tests.&lt;/p&gt;</comment>
                            <comment id="13530531" author="rhillegas" created="Thu, 13 Dec 2012 00:23:57 +0000"  >&lt;p&gt;Tests passed cleanly for me on derby-3069-06-ab-fixBugs.diff. Committed at subversion revision 1421052.&lt;/p&gt;</comment>
                            <comment id="13535270" author="rhillegas" created="Tue, 18 Dec 2012 20:27:13 +0000"  >&lt;p&gt;Attaching derby-3069-07-aa-datatypeTests.diff. This patch adds varargs tests for args of all possible datatypes and for legal coercions to those datatypes. This patch also makes one functional change, making sure that table functions are not created with parameter style DERBY.&lt;/p&gt;


&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;------------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj&lt;/p&gt;

&lt;p&gt;Prevent table functions from being created with parameter style DERBY.&lt;/p&gt;

&lt;p&gt;------------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsRoutines.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsTest.java&lt;/p&gt;

&lt;p&gt;Additional test cases.&lt;/p&gt;</comment>
                            <comment id="13535443" author="rhillegas" created="Tue, 18 Dec 2012 23:26:34 +0000"  >&lt;p&gt;Attaching derby-3069-07-ab-datatypeTests.diff. This patch disables the new tests if you are running on a CDC platform. Tests passed cleanly for me on the previous rev of the patch. Committed at subversion revision 1423714.&lt;/p&gt;</comment>
                            <comment id="13536006" author="rhillegas" created="Wed, 19 Dec 2012 14:48:14 +0000"  >&lt;p&gt;Attaching a second rev of the functional spec. This clarifies the following:&lt;/p&gt;

&lt;p&gt;o Varargs are also allowed if the parameter style is DERBY_JDBC_RESULT_SET.&lt;/p&gt;

&lt;p&gt;At this point, I think that the feature is ready to be documented and buddy-tested. Thanks.&lt;/p&gt;


</comment>
                            <comment id="13550393" author="rhillegas" created="Thu, 10 Jan 2013 20:42:25 +0000"  >&lt;p&gt;Attaching derby-3069-08-aa-stringArrayTable.diff. This patch adds a VTI which I find useful for ad-hoc testing of VTIs. Committed at revision 1431623.&lt;/p&gt;

&lt;p&gt;Here is the javadoc for the VTI:&lt;/p&gt;

&lt;p&gt;    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;This is a table function which creates a StringArrayVTI out of&lt;/li&gt;
	&lt;li&gt;a space separated list of column names, and a varargs of rows.&lt;/li&gt;
	&lt;li&gt;Each row is a space separated list of column values. Here is&lt;/li&gt;
	&lt;li&gt;a sample usage:&lt;/li&gt;
	&lt;li&gt;&amp;lt;/p&amp;gt;&lt;br/&gt;
     *&lt;/li&gt;
	&lt;li&gt;&amp;lt;pre&amp;gt;&lt;/li&gt;
	&lt;li&gt;connect &apos;jdbc:derby:memory:db;create=true&apos;;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;create function leftTable&lt;/li&gt;
	&lt;li&gt;(&lt;/li&gt;
	&lt;li&gt;columnNames varchar( 32672 ),&lt;/li&gt;
	&lt;li&gt;rowContents varchar( 32672 ) ...&lt;/li&gt;
	&lt;li&gt;)&lt;/li&gt;
	&lt;li&gt;returns table&lt;/li&gt;
	&lt;li&gt;(&lt;/li&gt;
	&lt;li&gt;a   varchar( 5 ),&lt;/li&gt;
	&lt;li&gt;b   varchar( 5 )&lt;/li&gt;
	&lt;li&gt;)&lt;/li&gt;
	&lt;li&gt;language java parameter style derby_jdbc_result_set no sql&lt;/li&gt;
	&lt;li&gt;external name &apos;org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.stringArrayTable&apos;;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;select * from table( leftTable( &apos;A B&apos;, &apos;APP T&apos;, &apos;APP S&apos; ) ) l;&lt;/li&gt;
	&lt;li&gt;&amp;lt;/pre&amp;gt;&lt;br/&gt;
     */&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Touches the following file:&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/VarargsRoutines.java&lt;/p&gt;</comment>
                            <comment id="13565368" author="rhillegas" created="Tue, 29 Jan 2013 13:51:44 +0000"  >&lt;p&gt;Attaching derby-3069-09-aa-docNotSupportedOnJSR169.diff. This patch makes a trivial change to the Reference Guide. It adds user-defined aggregates and varargs routines to the list of Derby features which are not supported on JSR 169 platforms. Committed at subversion revision 1439893.&lt;/p&gt;

&lt;p&gt;Touches the following file:&lt;/p&gt;

&lt;p&gt;M       src/ref/rrefjdbcjsr169.dita&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12628151">DERBY-6047</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12624646">DERBY-6018</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12624875">DERBY-6022</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12561701" name="Varargs.html" size="10531" author="rhillegas" created="Wed, 19 Dec 2012 14:48:14 +0000"/>
                            <attachment id="12552462" name="Varargs.html" size="10295" author="rhillegas" created="Wed, 7 Nov 2012 13:25:27 +0000"/>
                            <attachment id="12366003" name="derby-3069-01-varargs-aa.diff" size="11144" author="rhillegas" created="Mon, 17 Sep 2007 13:56:21 +0100"/>
                            <attachment id="12366237" name="derby-3069-01-varargs-ab.diff" size="11966" author="rhillegas" created="Wed, 19 Sep 2007 22:52:07 +0100"/>
                            <attachment id="12376281" name="derby-3069-02-backout.diff" size="11966" author="rhillegas" created="Fri, 22 Feb 2008 23:07:58 +0000"/>
                            <attachment id="12556125" name="derby-3069-03-aa-varargsSyntax.diff" size="54430" author="rhillegas" created="Wed, 5 Dec 2012 17:47:02 +0000"/>
                            <attachment id="12556140" name="derby-3069-03-ab-varargsSyntax.diff" size="58119" author="rhillegas" created="Wed, 5 Dec 2012 20:35:38 +0000"/>
                            <attachment id="12556387" name="derby-3069-04-aa-shortenRoutineNamesInUpgradeTest.diff" size="2258" author="rhillegas" created="Thu, 6 Dec 2012 18:30:59 +0000"/>
                            <attachment id="12560190" name="derby-3069-05-aa-executeVarargs.diff" size="45005" author="rhillegas" created="Mon, 10 Dec 2012 15:08:26 +0000"/>
                            <attachment id="12560620" name="derby-3069-06-ab-fixBugs.diff" size="27398" author="rhillegas" created="Wed, 12 Dec 2012 19:35:31 +0000"/>
                            <attachment id="12561560" name="derby-3069-07-aa-datatypeTests.diff" size="36184" author="rhillegas" created="Tue, 18 Dec 2012 20:27:13 +0000"/>
                            <attachment id="12561599" name="derby-3069-07-ab-datatypeTests.diff" size="36235" author="rhillegas" created="Tue, 18 Dec 2012 23:26:34 +0000"/>
                            <attachment id="12564254" name="derby-3069-08-aa-stringArrayTable.diff" size="2741" author="rhillegas" created="Thu, 10 Jan 2013 20:42:25 +0000"/>
                            <attachment id="12566954" name="derby-3069-09-aa-docNotSupportedOnJSR169.diff" size="398" author="rhillegas" created="Tue, 29 Jan 2013 13:51:44 +0000"/>
                            <attachment id="12365608" name="z.java" size="862" author="rhillegas" created="Wed, 12 Sep 2007 02:53:15 +0100"/>
                            <attachment id="12365609" name="z.sql" size="624" author="rhillegas" created="Wed, 12 Sep 2007 02:53:16 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 12 Sep 2007 15:49:45 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30715</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10102"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy08hr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35194</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>