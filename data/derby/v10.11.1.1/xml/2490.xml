<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:52:40 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2490/DERBY-2490.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2490] Clarify transaction management in LanguageConnectionContext.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2490</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;LanguageConnectionContext has these four methods (as well as other commit/rollback methods) to manage transactions and specifically nested transactions.&lt;/p&gt;

&lt;p&gt;void beginNestedTransaction(boolean readOnly) throws StandardException;&lt;br/&gt;
void commitNestedTransaction() throws StandardException;&lt;br/&gt;
TransactionController getTransactionCompile();&lt;br/&gt;
TransactionController getTransactionExecute();&lt;/p&gt;

&lt;p&gt;getTransactionCompile() returns the same as getTransactionExecute() if not in a nested transaction.&lt;/p&gt;

&lt;p&gt;nested transactions started out as &quot;compile time&quot; transactions  but are now used at runtime, for example in permission lookup and identity columns&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;,&lt;br/&gt;
thus the name getTransactionCompile() can confuse readers.&lt;/p&gt;

&lt;p&gt;A cleaner api might be to just have a single getTransaction() method that returns the current transaction, which is main transaction (non-nested) except&lt;br/&gt;
between calls to&lt;br/&gt;
   beginNestedTransaction() &lt;br/&gt;
  commitNestedTransaction()&lt;/p&gt;

&lt;p&gt;I think that is the logic today, one one transaction is active, either the nested one of the main one.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12365847">DERBY-2490</key>
            <summary>Clarify transaction management in LanguageConnectionContext.</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12365713">DERBY-2485</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                            <label>derby_triage10_10</label>
                    </labels>
                <created>Tue, 27 Mar 2007 00:56:27 +0100</created>
                <updated>Tue, 2 Oct 2012 06:20:26 +0100</updated>
                                                                            <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12484300" author="djd" created="Tue, 27 Mar 2007 05:42:14 +0100"  >&lt;p&gt;When running suites.All a few locations getTransactionExecute() is called when the code is clearly dealing with the nested transaction (thus the caller is using the wrong transaction object).&lt;br/&gt;
Some may not be a problem since:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in one place it&apos;s error logging getting the transaction identifier&lt;/li&gt;
	&lt;li&gt;in others it is getting the lock compatibility space to perform locking and the nested and main transaction share the same lock space&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;One is performing a scan using the wrong transaction (to get a schema descriptor)&lt;/p&gt;

&lt;p&gt;Any api that requires the caller to be aware of which transaction method to call is going to be subject to bugs like this, it would be much cleaner for the LCC to only expose a single current transaction and switch internally as required.&lt;/p&gt;

</comment>
                            <comment id="12484639" author="djd" created="Wed, 28 Mar 2007 00:03:13 +0100"  >&lt;p&gt;The beginNestedTransaction() and commitNestedTransaction() api/implementation is confusing. Here&apos;s a list of some of the items I&apos;ve found so far ...&lt;/p&gt;

&lt;p&gt;If beginNestedTransaction() is called but commitNestedTransaction() not called then the nested transaction will not be destroyed. Some callers avoid this by having the commitNestedTransaction() in a finally block, but this will mean commit is called even if an exception was thrown. This may not be a problem with the current code as the &apos;readOnly&apos; flag to beginNestedTransaction() is always set to true. It would be good to either document the requirement for a finally block or ensure the rollback path cleans up the nested transaction.&lt;/p&gt;

&lt;p&gt;However one caller to beginNestedTransaction(true) (read-only) has comments indicating that writes can occur (EmbedDatabaseMetaData.prepareSPS()).&lt;/p&gt;

&lt;p&gt;beginNestedTransaction() has a boolean for readOnly but it reuses the current nested transaction regardless of the previous setting of this flag, thus with the current api one could have a request for a read/write transaction return a read-only transaction. (same comments as above apply for all callers indicating read-only).&lt;/p&gt;

&lt;p&gt;Callers in the language area that require a read-write nested transaction don&apos;t use this api and instead use the lower-level api on TransactionController, ie.&lt;br/&gt;
  getTransactionExecute().startNestedUserTransaction(false). Thus some confusion here, when does a caller use the LCC method and when the store method? Again the api seems to require a finally block to clean things up and a commit is always performed, even on exception.&lt;/p&gt;

&lt;p&gt;I think a commit is always performed on a nested transaction as comments somewhere (in store I think) indicated that rolling back a nested transaction will rollback the parent as well.&lt;/p&gt;

&lt;p&gt;Unclear if the model supported is endless nesting, e.g. can I call startNestedUserTransaction() on a nested transaction. I think not from the implementation, it seems maybe nesting is only one level deep, but one can have a nested read only transaction and a nested read/write transaction active.&lt;/p&gt;




</comment>
                            <comment id="12484664" author="djd" created="Wed, 28 Mar 2007 01:42:43 +0100"  >&lt;p&gt;TransactionController.startNestedUserTransaction() actually has a good write-up on nested transactions.&lt;/p&gt;

&lt;p&gt;One thing that is somewhat unclear is how many nested read-only transactions can exist.&lt;/p&gt;

&lt;p&gt;The comments are clear that only 1 non-readOnly nested user transaction can exist, but not clear on the read-only case.&lt;/p&gt;</comment>
                            <comment id="12484666" author="djd" created="Wed, 28 Mar 2007 01:53:59 +0100"  >&lt;p&gt;I&apos;m going to try adding this code to doRollback() in GenericLanguageConnectionContext.&lt;/p&gt;

&lt;p&gt;            if (childTransaction != null)&lt;/p&gt;
            {
                childTransaction.destroy();
                childTransaction = null;
                queryNestingDepth = 0;
            }

&lt;p&gt;to try and ensure the nested transaction will be cleaned up and destroyed on a rollback without requiring a finally block.&lt;br/&gt;
Also adding a sanity assertion that childTransaction is null on any commit.&lt;/p&gt;</comment>
                            <comment id="12484921" author="mikem" created="Wed, 28 Mar 2007 17:35:20 +0100"  >&lt;p&gt;The best info for store provided nested info should be in the iapi javadoc where you get the nested transaction, of all the store javadoc information the most work in the past was put into the info located there:  ie. opensource/java/engine/org/apache/derby/iapi/store/access/TransactionController/startNestedUsetTransaction. &lt;/p&gt;

&lt;p&gt;The store currently only supports 1 level of nesting.  And Each user transaction can only nest a single readonly transaction and a single separate read/write transaction.  The usage of these transactions that I am aware of are:&lt;br/&gt;
o read only nested transaction - used to get and release read locks on system catalogs while compiling query.  These locks&lt;br/&gt;
                                                           are compatible with the parent transaction.&lt;br/&gt;
o read/write nested transaction - used to update system catalog and comit that work separate and earlier than user transaction.&lt;br/&gt;
                                                            used to commit updates to catalog which tracks system generated keys for auto generated &lt;br/&gt;
                                                             columns.  locks in this transaction are not compatible with parent transaction.&lt;/p&gt;

&lt;p&gt;The store also supports one other internal transaction that is not exported through the interface.  This transaction is used to &lt;br/&gt;
implement &quot;nested top transactions&quot;.  These are low level data structure changes which are committed separate from user transactions: btree split operations, page allocation, ....  There can only be one of these active at a time also.  &lt;/p&gt;

&lt;p&gt;All 3 types can be actiive at the same time, but only 1 of each type.  &lt;/p&gt;</comment>
                            <comment id="12484942" author="djd" created="Wed, 28 Mar 2007 18:48:53 +0100"  >&lt;p&gt;Thanks Mike, I think this info is essential to add to javadoc for startNestedUserTransaction:&lt;/p&gt;

&lt;p&gt;&quot;And Each user transaction can only nest a single readonly transaction and a single separate read/write transaction. &quot;&lt;/p&gt;

&lt;p&gt;apart from that, the rest was clear.&lt;/p&gt;

&lt;p&gt;I&apos;ll update the comments.&lt;/p&gt;

&lt;p&gt;Oh, one more dumb question, does the store enforce the readOnly flag for these nested transactions?&lt;br/&gt;
I assume it does, but comments in the langage layer seem to indicate otherwise.&lt;/p&gt;</comment>
                            <comment id="12485243" author="mikem" created="Thu, 29 Mar 2007 17:38:01 +0100"  >&lt;p&gt;yes, store enforces read only for a read only transaction.  &lt;/p&gt;

&lt;p&gt;The implementing code can be seen in Xact.java.  The allowed state of the transaction is maintained by the private readOnly variable.  The state of the transaction can be:&lt;br/&gt;
protected static final int  CLOSED          = 0;&lt;br/&gt;
protected static final int  IDLE            = 1;&lt;br/&gt;
protected static final int  ACTIVE          = 2;&lt;br/&gt;
protected static final int  UPDATE          = 3;&lt;br/&gt;
protected static final int  PREPARED        = 4;&lt;/p&gt;

&lt;p&gt;setUpdateState() is called whenever an update (as tracked by the system requesting to log something) is called on a transaction that is not yet in UPDATE state.  If that call is made on a read only transaction a protocol error is raised.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 28 Mar 2007 16:35:20 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30476</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy08dr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35176</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>