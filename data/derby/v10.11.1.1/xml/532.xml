<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:15:42 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-532/DERBY-532.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-532] Support deferrable constraints</title>
                <link>https://issues.apache.org/jira/browse/DERBY-532</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;In many situations it is desirable to have constraints checking taking place only at transaction commit time, and not before. If e.g. there is a chain of foreign key constraints between tables, insert statements have to be ordered to avoid constraint violations. If foreign key references are circular, the DML has to be split into insert statements and subsequent update statements by the user.&lt;/p&gt;

&lt;p&gt;In other words, with deferred constraints checking, life is much easier for the user. Also it can create problems with softwares such as object-relational mapping tools that are not prepared for statement ordering and thus depend on deferred constraints checking.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12313704">DERBY-532</key>
            <summary>Support deferrable constraints</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="jfrantzius">J&#246;rg von Frantzius</reporter>
                        <labels>
                            <label>derby_triage10_11</label>
                    </labels>
                <created>Wed, 24 Aug 2005 02:18:00 +0100</created>
                <updated>Fri, 25 Jul 2014 13:31:22 +0100</updated>
                            <resolved>Thu, 5 Jun 2014 23:01:58 +0100</resolved>
                                                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>6</votes>
                                    <watches>8</watches>
                                                                                                            <comments>
                            <comment id="13719335" author="dagw" created="Thu, 25 Jul 2013 08:39:09 +0100"  >&lt;p&gt;Uploading a functional specification for this, with some implementations ideas. I&apos;d like to try to build deferrable unique constraints in a first increment; but the specification covers all supported types.&lt;/p&gt;

&lt;p&gt;It seems it would desirable to avoid dropping a unique supporting index if few rows are modified; options include temporarily making it non-unique (hard?) and vice versa at commit, or using a temporary shadow table (would complicate updates and selects). &lt;/p&gt;</comment>
                            <comment id="13719564" author="rhillegas" created="Thu, 25 Jul 2013 13:18:05 +0100"  >&lt;p&gt;Linking this issue to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6303&quot; title=&quot;Add ability to defer enforcement of unique indexes until transaction end.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6303&quot;&gt;DERBY-6303&lt;/a&gt;. The reasons for deferring unique constraints probably apply to deferring unique index enforcement too.&lt;/p&gt;</comment>
                            <comment id="13728497" author="dagw" created="Sat, 3 Aug 2013 10:31:44 +0100"  >&lt;p&gt;Uploading 1.4 of the specification (adding note on NOT NULL).&lt;/p&gt;</comment>
                            <comment id="13730466" author="dagw" created="Tue, 6 Aug 2013 08:17:11 +0100"  >&lt;p&gt;Uploading a patch, derby-532-syntax-binding-dict-1. My local git commit record says:&lt;/p&gt;

&lt;p&gt;    Patch derby-532-syntax-binding-dict-1. This patch wires in the syntax&lt;br/&gt;
    for deferred constraints (aka &quot;constraint characteristics&quot;). It also&lt;br/&gt;
    does&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;binding checks for CREATE TABLE constraints and SET constraints&lt;br/&gt;
      statement (new). Binding is still missing for ALTER TABLE&lt;br/&gt;
      constraints clauses.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;temporarily throws not yet implemented (0A000.S) for all usage&lt;br/&gt;
      &lt;b&gt;except&lt;/b&gt; when characteristics coincide with the current (and future)&lt;br/&gt;
      Derby defaults, i.e. NOT DEFERRABLE &lt;span class=&quot;error&quot;&gt;&amp;#91;INITIALLY IMMEDIATE&amp;#93;&lt;/span&gt; ENFORCED&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;checks inconsistencies in characteristics (illegal combinations), cf.&lt;br/&gt;
      42X97 &quot;Conflicting constraint characteristics for constraint&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;implements implied DEFERRABLE of (only) INITIALLY DEFERRED is&lt;br/&gt;
      specified.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if the property &quot;derby.constraintsTesting&quot; is set, persists&lt;br/&gt;
      characteristics to dictionary by overloading the existing STATE&lt;br/&gt;
      character according to specification. This property will go away&lt;br/&gt;
      once the feature set is implemented, only implemented not to be able&lt;br/&gt;
      to test dictionary persistence&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throws 42XAK &quot;Constraint characteristics not allowed for NOT NULL.&quot;&lt;br/&gt;
      for NOT NULL characteristics since this constraint type is not&lt;br/&gt;
      explicitly implemented as a constraint in Derby (yet, at least)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;adds a new test, ConstraintCharacteristicsTest to test the above and&lt;br/&gt;
      wires it into the lang suite.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13730469" author="dagw" created="Tue, 6 Aug 2013 08:20:49 +0100"  >&lt;p&gt;Just to be clear, the patch is of course not yet committed to the Apache repos. Regressions ran ok.&lt;br/&gt;
Do people think its OK to build and commit this feature incrementally and just keep NOT IMPLEMENTED messages until all is in place? I do not yet know how much work it will turn out to be in the lower layers.&lt;/p&gt;</comment>
                            <comment id="13730691" author="rhillegas" created="Tue, 6 Aug 2013 13:09:40 +0100"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;That approach sounds fine to me, particularly since you&apos;re incrementally adding tests as you go along. Thanks.&lt;/p&gt;</comment>
                            <comment id="13736563" author="dagw" created="Mon, 12 Aug 2013 05:24:12 +0100"  >&lt;p&gt;Thanks, Rick. Building more tests, I noticed I had made the ALTER TABLE ALTER CONSTRAINT syntax too lenient; I&apos;ll fix that in the next version of the patch.&lt;/p&gt;</comment>
                            <comment id="13736864" author="dagw" created="Mon, 12 Aug 2013 14:38:10 +0100"  >&lt;p&gt;Uploading derby-532-syntax-binding-dict-2, which builds on patch #1 (apply consecutively).&lt;/p&gt;

&lt;p&gt;Elaborates ALTER TABLE ALTER TABLE, correcting syntax, adding name binding and updating dictionary (subject to the property derby.constraintsTesting) in a new AlterConstraintConstantAction class.&lt;/p&gt;

&lt;p&gt;Built out tests in ConstraintCharacteristicsTest to systematically check all possible characteristics combinations in all cases, and adding tests for ALTER TABLE ALTER TABLE, including dictionary updates.&lt;/p&gt;

&lt;p&gt;Regressions ran ok.&lt;/p&gt;</comment>
                            <comment id="13736869" author="dagw" created="Mon, 12 Aug 2013 14:48:18 +0100"  >&lt;p&gt;With the two patches above are finalized, I should be able to start thinking about actually deferring the constraints. As a first step, I&apos;ll try to understand how to add machinery for checking constraints at commit time, rather than at statement execution time, maybe for a check constraint by disabling it (or dropping it if it comes into play during execution) first and then checking all rows with a select like what is done when adding a check constraint. In general I&apos;d want to implement a naive approach first and the later try to do something performant. Perhaps for small tables a naive approach could even be faster; time will tell.&lt;/p&gt;</comment>
                            <comment id="13739785" author="rhillegas" created="Wed, 14 Aug 2013 16:43:35 +0100"  >&lt;p&gt;Thanks for the patches, Dag. I was unable to apply them, maybe because the diff was produced by git? When I try to apply the first patch via this command...&lt;/p&gt;

&lt;p&gt;patch -p 0 -i $patchFile&lt;/p&gt;

&lt;p&gt;...I get this error message:&lt;/p&gt;

&lt;p&gt;can&apos;t find file to patch at input line 5&lt;br/&gt;
Perhaps you used the wrong -p or --strip option?&lt;br/&gt;
The text leading up to this was:&lt;br/&gt;
--------------------------&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;diff --git a/java/engine/org/apache/derby/iapi/sql/dictionary/CheckConstraintDescriptor.java b/java/engine/org/apache/derby/iapi/sql/dictionary/CheckConstraintDescriptor.java&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;index 6378411..ceb2a99 100644&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8212; a/java/engine/org/apache/derby/iapi/sql/dictionary/CheckConstraintDescriptor.java&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;+++ b/java/engine/org/apache/derby/iapi/sql/dictionary/CheckConstraintDescriptor.java&lt;br/&gt;
--------------------------&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Maybe I need to give the patch command another switch or argument?&lt;/p&gt;

&lt;p&gt;Nevertheless, I did go through the patch files and have a couple, small comments:&lt;/p&gt;


&lt;p&gt;---------&lt;/p&gt;

&lt;p&gt;SYSCONSTRAINTSRowFactory:&lt;/p&gt;

&lt;p&gt;o Could probably use a comment somewhere explaining the encoding&lt;br/&gt;
scheme for SYSCONSTRAINTS.STATE. Extra credit if the explanation is&lt;br/&gt;
something which would be easy to copy into the Reference Guide section&lt;br/&gt;
on this catalog. And/or update the functional spec accordingly.&lt;/p&gt;

&lt;p&gt;---------&lt;/p&gt;

&lt;p&gt;AlterConstraintConstantAction:&lt;/p&gt;

&lt;p&gt;o Does this action need to invalidate statements?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13749998" author="dagw" created="Mon, 26 Aug 2013 12:07:29 +0100"  >&lt;p&gt;Thanks, Rick. You need the -p1 option to patch for git generated diffs. I&apos;ll add more comments about the encoding scheme.&lt;br/&gt;
As far as invalidation, I am not sure yet; it will depend on whether we generate different code for enforced/not enforced. Most likely, it will be &quot;yes&quot;.&lt;/p&gt;</comment>
                            <comment id="13751274" author="dagw" created="Tue, 27 Aug 2013 14:59:49 +0100"  >&lt;p&gt;Uploading derby-532-syntax-binding-dict-all-1, which includes the two first patches plus adjusts the patch to work on current trunk, and also adds the extra documentation requested by Rick (in  SYSCONSTRAINTSRowFactory). Regressions went ok.&lt;/p&gt;</comment>
                            <comment id="13751279" author="jira-bot" created="Tue, 27 Aug 2013 15:05:04 +0100"  >&lt;p&gt;Commit 1517823 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1517823&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1517823&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-syntax-binding-dict-all-1. This patch wires in the syntax&lt;br/&gt;
for deferred constraints (aka &quot;constraint characteristics&quot;). It also&lt;br/&gt;
does&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;binding checks for CREATE TABLE constraints and SET constraints&lt;br/&gt;
  statement (new). Binding is still missing for ALTER TABLE&lt;br/&gt;
  constraints clauses.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;temporarily throws not yet implemented (0A000.S) for all usage&lt;br/&gt;
  &lt;b&gt;except&lt;/b&gt; when characteristics coincide with the current (and future)&lt;br/&gt;
  Derby defaults, i.e. NOT DEFERRABLE &lt;span class=&quot;error&quot;&gt;&amp;#91;INITIALLY IMMEDIATE&amp;#93;&lt;/span&gt; ENFORCED&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;checks inconsistencies in characteristics (illegal combinations), cf.&lt;br/&gt;
  42X97 &quot;Conflicting constraint characteristics for constraint&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;implements implied DEFERRABLE of (only) INITIALLY DEFERRED is&lt;br/&gt;
  specified.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if the property &quot;derby.constraintsTesting&quot; is set, persists&lt;br/&gt;
  characteristics to dictionary by overloading the existing STATE&lt;br/&gt;
  character according to specification. This property will go away&lt;br/&gt;
  once the feature set is implemented, only implemented not to be able&lt;br/&gt;
  to test dictionary persistence&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throws 42XAK &quot;Constraint characteristics not allowed for NOT NULL.&quot;&lt;br/&gt;
  for NOT NULL characteristics since this constraint type is not&lt;br/&gt;
  explicitly implemented as a constraint in Derby (yet, at least)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;adds a new test, ConstraintCharacteristicsTest to test the above and&lt;br/&gt;
  wires it into the lang suite.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(part 2):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Elaborates ALTER TABLE ALTER TABLE, correcting syntax, adding name&lt;br/&gt;
  binding and updating dictionary (subject to the property&lt;br/&gt;
  derby.constraintsTesting) in a new AlterConstraintConstantAction&lt;br/&gt;
  class.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Built out tests in ConstraintCharacteristicsTest to systematically&lt;br/&gt;
  check all possible characteristics combinations in all cases, and&lt;br/&gt;
  adding tests for ALTER TABLE ALTER TABLE, including dictionary&lt;br/&gt;
  updates.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13751280" author="dagw" created="Tue, 27 Aug 2013 15:07:23 +0100"  >&lt;p&gt;Committed derby-532-syntax-binding-dict-all-1 at svn 1517823.&lt;/p&gt;</comment>
                            <comment id="13754977" author="dagw" created="Fri, 30 Aug 2013 19:22:29 +0100"  >&lt;p&gt;Uploading patch derby-532-testAlterConstraintInvalidation.&lt;/p&gt;

&lt;p&gt;Adds a fixture to test that prepared statement is invalidated when a&lt;br/&gt;
table its depends on undergoes an ALTER TABLE ALTER CONSTRAINT&lt;br/&gt;
statement. As it turns out, this is already handled by the common&lt;br/&gt;
machinery for ALTER TABLE.&lt;/p&gt;</comment>
                            <comment id="13754978" author="jira-bot" created="Fri, 30 Aug 2013 19:23:09 +0100"  >&lt;p&gt;Commit 1519045 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1519045&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1519045&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt;: Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-testAlterConstraintInvalidation.&lt;/p&gt;

&lt;p&gt;Adds a fixture to test that prepared statement is invalidated when a&lt;br/&gt;
table its depends on undergoes an ALTER TABLE ALTER CONSTRAINT&lt;br/&gt;
statement. As it turns out, this is already handled by the common&lt;br/&gt;
machinery for ALTER TABLE.&lt;/p&gt;</comment>
                            <comment id="13795273" author="dagw" created="Tue, 15 Oct 2013 16:07:40 +0100"  >&lt;p&gt;This experimental patch enables deferrable constraints for &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;     a) primary key constraints&lt;br/&gt;
     b) unique constraint with not nullable columns&lt;br/&gt;
     c) unique constraint with nullable columns&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;by new logic in supporting BTree indexes and sorts.&lt;/p&gt;

&lt;p&gt;The patch includes relaxing the constraint at insertion and update time, as well as adding a constraint to an existing table. There is as yet no support for importing data into a table with a deferred constraint, cf. the issue &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6374&quot; title=&quot;Bulk insert of data with nullable UNIQUE constraint fails to detect duplicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6374&quot;&gt;&lt;del&gt;DERBY-6374&lt;/del&gt;&lt;/a&gt;. When that issue is fixed, I&apos;ll add support for deferrable constraints for import as well.&lt;/p&gt;

&lt;p&gt;Derby treats constraints a) and b) the same, and in the code these are marked as &quot;unique&quot; when they are not deferrable (as in existing code).&lt;/p&gt;

&lt;p&gt;Constraint type c) is currently marked as &quot;uniqueWithDuplicateNulls&quot;. Insert/update of these is implemented in the BTree by including the RowLocation of the base row in the set of keys in the index row (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3330&quot; title=&quot;provide support for unique constraint over keys that include one or more nullable columns.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3330&quot;&gt;&lt;del&gt;DERBY-3330&lt;/del&gt;&lt;/a&gt;). This makes them trivially unique, but there is an extra code path in BTreeController that checks neighbor rows for duplicates, and only allows insertion if the key contains a null. When adding a constraint to an existing table, these are handled by a specially crafted sorter (UniqueWithDuplicateNullsMergeSort).&lt;/p&gt;

&lt;p&gt;The implementation of insert/update of deferrable indexes is based on the same approach, i.e. neighbor row comparison and tweaking the sorters. &lt;span class=&quot;error&quot;&gt;&amp;#91;This means a) and b) if deferrable are no longer marked &amp;quot;unique&amp;quot;&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Deferrable indexes are not shared.&lt;/p&gt;

&lt;p&gt;If there are duplicates and we have deferred constraint mode (a dynamic session property), we save the duplicate index row in a disk based hash table (DeferredDuplicates#rememberDuplicate).&lt;/p&gt;

&lt;p&gt;For a) and b), constraints which are deferrable are marked as &quot;uniqueDeferrable&quot; and &quot;hasDeferrableChecking&quot;. Constraints of type c) which are deferrable are marked &quot;uniqueWithDuplicateNulls&quot; and &quot;hasDeferrableChecking&quot;. These marks determines the code paths used. Note that existing indexes and non-deferrable constraint do not get a new code path, which should preserve correctness and performance of those.&lt;/p&gt;

&lt;p&gt;Now, with these markers in place, deferral of checks happens in logic in two places:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{{        IndexChanger#insertAndCheckDups + BTreeController#doIns}}&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;and     CreateIndexConstantAction#executeConstantAction +&lt;/tt&gt;&lt;br/&gt;
{{        MergeSort#compare and UniqueWithDuplicateNullsMergeSort#compare }}&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The former is active for deferral under INSERT and UPDATE.  The latter when adding a deferrable constraint to an existing table, when we sort existing rows detecting any duplicates.&lt;/p&gt;

&lt;p&gt;At transaction commit (1), or when the constraint mode for a deferred constraint is changed back to immediate (2), we validate the constraint (DeferredDuplicates#validate) by replaying the hash table and scanning the index for the duplicate index rows to ascertain there are none, or else we have an error: transaction or statement severity respectively for (1) and (2).&lt;/p&gt;

&lt;p&gt;The constraint mode is a SQL session level variable, and inside routines (nested connections), we push this on the stack. This means change of the constraint mode inside nested connections will be popped on routine exit. If, as part of this, a constraint changes from deferred to immediate mode, we also validate it for correctness. If this fail, the transaction rolls back (GenericLanguageConnectionContext#popNestedSessionContext calls #compareConstraintModes).&lt;/p&gt;

&lt;p&gt;#popNestedSessionContext is new: earlier we didn&apos;t need a handle for popping SQL session context, we needed one in this case, so we implemented the general mechanism as well. That hook is called from GenericPreparedStatement#executeStmt. As a part of this effort, we also renamed #setupNestedSessionContext to #pushNestedSessionContext.&lt;/p&gt;

&lt;p&gt;The test case &quot;testBasicDeferral&quot; and &quot;testRoutines&quot; has been added to ConstraintCharacteristicsTest to test these basic behaviors.&lt;/p&gt;

&lt;p&gt;The &quot;not enforced&quot; feature is not yet implemented in this patch.&lt;/p&gt;

&lt;p&gt;Regressions passed OK with this patch.&lt;/p&gt;

&lt;p&gt;Patch details:&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;new file:   java/engine/org/apache/derby/impl/sql/execute/DeferredDuplicates.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;New static class which handles much of the mechanics of saving duplicate index rows and later validating the index.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;new file:   java/engine/org/apache/derby/impl/store/access/btree/index/B2I_10_4.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/btree/index/B2I.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/btree/index/B2IFactory.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;The index conglomerate format has been bumped so we can store the deferral properties. Upgrade of indexes from old databases is lazy: they are not deferrable, but the format just lacks two final properties which default to false: hasDeferrableChecking and isUniqueDeferrable. The new format id is ACCESS_B2I_V6_ID. The new class B2I_10_4 makes sure we can write old conglomerate format correctly in soft upgrade mode (in format ACCESS_B2I_V5_ID).&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/store/raw/RawStoreFactory.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Added DERBY_STORE_MINOR_VERSION_11 which allows use of the new index conglomerate format.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/catalog/IndexDescriptor.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/catalog/types/IndexDescriptorImpl.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/sql/dictionary/IndexRowGenerator.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/compile/TableElementList.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/DDLSingleTableConstantAction.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/MaterializedResultSet.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/RIBulkChecker.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/RowChangerImpl.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/btree/BTree.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/btree/index/B2IController.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/PropertyConglomerate.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Addition/propagation of &quot;hasDeferrableChecking&quot; and &quot;uniqueDeferrable&quot; properties and add &quot;deferred=false&quot; argument to ConglomerateController#insert calls.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/sql/conn/SQLSessionContext.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/conn/SQLSessionContextImpl.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Storage of the session&apos;s current constraint modes and operations for pushing and clearing that information.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Add check that we are at dictionary 10_11 before allowing SET CONSTRAINTS to proceed. (Already done for deferred constraint creation).&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/store/access/ConglomerateController.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/btree/BTreeController.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/heap/HeapController.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/store/access/DiskHashtable.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/catalog/TabInfoImpl.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Add boolean &quot;deferred&quot; to indicate current behavior to #insert. For BTreeController, report back duplicates but still do insert iff deferred mode. Ignored by HeapController. The real use of the new argument is by IndexChanger which knows about constraints in deferred mode.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/compile/CreateIndexNode.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;New default arguments (doesn&apos;t use the deferred values).&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/store/access/RowUtil.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Small formatting fix to #toString.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/store/access/SortObserver.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/BasicSortObserver.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/UniqueIndexSortObserver.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/UniqueWithDuplicateNullsIndexSortObserver.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/store/access/sort/UniqueWithDuplicateNullsMergeSo&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Changes to accommodate saving duplicates during sorting of existing rows when adding an index for a constraint.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/GenericPreparedStatement.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Call hook for popNestedSessionContext. Renaming of pushNestedSessionContext.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Removed unnecessary overload of IndexRowGenerator (as part of adding more arguments anyway).&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/AlterConstraintConstantAction.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Addition of dictionary level check + one bug fix.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Determine the flags for the index conglomerates to support constraints, see introduction, and set up for creation of correct conglomerates.  Handle any initial insertion of rows when constraint mode is initially deferred.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Partial support (preparatory code) for bulk import &lt;span class=&quot;error&quot;&gt;&amp;#91;type a) and b)&amp;#93;&lt;/span&gt; in the presence of deferrable constraints, but see introduction.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/SetConstraintsConstantAction.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Logic for setting the session&apos;s constraint mode at execution time.&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/loc/messages.xml&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;New error messages. &lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/testing/org/apache/derbyTesting/functionTests/tests/lang/ConstraintCharacteristicsTest.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Added test cases &quot;testBasicDeferral&quot; and &quot;testRoutines&quot;.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/testing/org/apache/derbyTesting/functionTests/util/T_ConsistencyChecker.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/testing/org/apache/derbyTesting/unitTests/store/T_AccessFactory.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/testing/org/apache/derbyTesting/unitTests/store/T_QualifierTest.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/testing/org/apache/derbyTesting/unitTests/store/T_b2i.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Adjustment of old tests to use deferred=false argument to ConglomerateController#insert&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/testing/org/apache/derbyTesting/unitTests/store/T_SortController.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Instantiate sorters with default implementations for the new SortObserver interface methods.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Import fixes, Javadoc fixes, renaming of pushNestedSessionContext, added new interface method: setDeferred, isEffectivelyDeferred, setDeferredAll, getDeferredHashTables.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:&lt;/font&gt;&lt;br/&gt;
java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java&lt;/p&gt;

&lt;p&gt;Implementations of above. Store &quot;deferredHashTables&quot; for the transaction: the set of disk based hash tables that holds deferred rows for the session, if any. New logic in doCommit and doRollback to handle deferred rows and reset modes. New logic to push constraint modes state on routine invocation in pushNestedSessionContext. Added popNestedSessionContext to validate any deferred rows if we switch back to immediate checking.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/sql/conn/StatementContext.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/iapi/store/access/TransactionController.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Javadoc fixes.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Javadoc fixes and removal of an assertion that no longer hold with added call in GenericPreparedStatement.&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;modified:   java/engine/org/apache/derby/impl/sql/compile/SetConstraintsNode.java&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Import fix.&lt;/p&gt;

&lt;p&gt;To apply the patch, you need to add empty versions of the two new files:&lt;br/&gt;
java/engine/org/apache/derby/impl/sql/execute/DeferredDuplicates.java&lt;br/&gt;
java/engine/org/apache/derby/impl/store/access/btree/index/B2I_10_4.java&lt;/p&gt;</comment>
                            <comment id="13799219" author="kmarsden" created="Fri, 18 Oct 2013 16:50:05 +0100"  >&lt;p&gt;I have not had an opportunity to look at the patch, but have a general question.  For XA will the deferred constraints be enforced at prepare time?  &lt;/p&gt;</comment>
                            <comment id="13802761" author="dagw" created="Wed, 23 Oct 2013 11:09:41 +0100"  >&lt;p&gt;Kathey, I haven&apos;t looked at XA semantics yet, should it be enforced at prepare to commit time?&lt;/p&gt;</comment>
                            <comment id="13802983" author="kmarsden" created="Wed, 23 Oct 2013 17:04:44 +0100"  >&lt;p&gt;That makes sense to me as I believe once prepared, nothing should interfere with the commit, but I say that just from what seems logical, not having done any spec or product research on the matter.&lt;/p&gt;</comment>
                            <comment id="13803328" author="dagw" created="Wed, 23 Oct 2013 22:06:42 +0100"  >&lt;p&gt;Yes, I think it makes sense, too. I&apos;ll look around a bit to see what others do..&lt;/p&gt;</comment>
                            <comment id="13809530" author="dagw" created="Wed, 30 Oct 2013 19:53:43 +0000"  >&lt;p&gt;Uploading a new version of the specification, see its latest rev. note (1.5).&lt;/p&gt;</comment>
                            <comment id="13809547" author="dagw" created="Wed, 30 Oct 2013 20:02:56 +0000"  >&lt;p&gt;Uploading a second version, derby-532-unique-pk-2, which is essentially the same, just a refresh. I had to adjust some constants due to an intervening commit (see RegisteredFormatIds and StoredFormatIds) from the MERGE work.&lt;/p&gt;

&lt;p&gt;Uploading a new patch, derby-532-xa-1 (which builds upon pk-2). This adds support for checking deferred constraints in xa_prepare and xa_commit (.., true), cf. specification, and adds test cases.&lt;/p&gt;</comment>
                            <comment id="13810229" author="dagw" created="Thu, 31 Oct 2013 13:12:13 +0000"  >&lt;p&gt;As far as precedent for XA, I haven&apos;t been able to find much, but I did find that the Informix documentation mentions throwing  XAException#XA_RBINTEGRITY for unsatisfied deferred constraints in the API docs for both xa_prepare() and xa_commit(). I had chosen the same exception, so it seems that&apos;s right. The case of xa_commit applies to the possibility for commiting 1PC transactions &lt;span class=&quot;error&quot;&gt;&amp;#91;i.e. xa_commit(xid, true)&amp;#93;&lt;/span&gt;, which do not require xa_prepare.&lt;/p&gt;</comment>
                            <comment id="13810672" author="dagw" created="Thu, 31 Oct 2013 20:40:03 +0000"  >&lt;p&gt;derby-532-xa-2 uploaded (javadoc changes only relative to version 1).&lt;/p&gt;</comment>
                            <comment id="13813201" author="dagw" created="Mon, 4 Nov 2013 20:13:11 +0000"  >&lt;p&gt;Attaching another patch, derby-532-import-1, which adds support for deferred constraint in connection with bulk insert, e.g. by import and adds two test cases, ConstraintCharacteristicsTest#testImport and #testDeferredRowsInvalidation.&lt;/p&gt;

&lt;p&gt;The patch builds on the last rev of the previous two patches for this issue.&lt;/p&gt;

&lt;p&gt;It should also fix &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6374&quot; title=&quot;Bulk insert of data with nullable UNIQUE constraint fails to detect duplicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6374&quot;&gt;&lt;del&gt;DERBY-6374&lt;/del&gt;&lt;/a&gt; and adds a test case for it, ConstraintCharacteristicsTest#testDerby6374.&lt;/p&gt;

&lt;p&gt;Running regressions.&lt;/p&gt;</comment>
                            <comment id="13813421" author="dagw" created="Mon, 4 Nov 2013 23:43:09 +0000"  >&lt;p&gt;Uploading version 2,  derby-532-import-2 (minor clerical error).&lt;/p&gt;</comment>
                            <comment id="13814088" author="mikem" created="Tue, 5 Nov 2013 18:16:38 +0000"  >&lt;p&gt;i totally missed that this project was implementing yet another btree type, so sorry for late review.  I am still&lt;br/&gt;
looking at detail, but wondering if you ever considered any solution that did not require special case code&lt;br/&gt;
in the btree.  I would like to understand what would be the problem with implementing deferred constraints&lt;br/&gt;
using existing &quot;duplicate&quot; btrees with no changes, and then do all deferred contraint checking in the sql &lt;br/&gt;
layer doing probes to ascertain constraint consistency using existing access interfaces (with maybe something&lt;br/&gt;
more specialized if that allows for faster path).&lt;/p&gt;

&lt;p&gt;I know you are following a path that the &quot;unique&quot; with duplicate code followed.  I have regretted that approach&lt;br/&gt;
since it was implemented.  The project resulted in many bugs because of the complication involved in twisting&lt;br/&gt;
the code to do something that it really did not want to do.  &lt;/p&gt;</comment>
                            <comment id="13814095" author="mikem" created="Tue, 5 Nov 2013 18:25:00 +0000"  >&lt;p&gt;if the new btree approach is checked in, should add tests to look out for bugs like &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3502&quot; title=&quot;Unique Constraint&amp;#39;s backing index when shared with existing indexes doesn&amp;#39;t behave as expected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3502&quot;&gt;&lt;del&gt;DERBY-3502&lt;/del&gt;&lt;/a&gt; which&lt;br/&gt;
came about the last time a new, but similar btree was checked in.&lt;/p&gt;</comment>
                            <comment id="13814109" author="mikem" created="Tue, 5 Nov 2013 18:39:26 +0000"  >&lt;p&gt;can anyone speak to whether deferred constraint checking is in anyway similar to deferred updates already supported in the sql layer of the derby code.  Is there anyway to use that existing code to batch up a set of&lt;br/&gt;
changes and run deferred constraint checking at given time?&lt;/p&gt;</comment>
                            <comment id="13814125" author="mikem" created="Tue, 5 Nov 2013 18:51:53 +0000"  >&lt;p&gt;It looks like a lot of the fast path code paths now have added code to deal with differed update.  Should&lt;br/&gt;
code for instance in InsertResultSet.java be broken out and there to be one routine to handle deferred constraint&lt;br/&gt;
and one to not.  With some sort of inheritance to handle it?&lt;/p&gt;</comment>
                            <comment id="13814128" author="mikem" created="Tue, 5 Nov 2013 18:53:24 +0000"  >&lt;p&gt;should there be changes to update code in addition to insert code, or is this one of the benefits of doing this work at lowest level where all updates on btree&apos;s are turned into deletes and inserts?&lt;/p&gt;</comment>
                            <comment id="13814158" author="rhillegas" created="Tue, 5 Nov 2013 19:24:03 +0000"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;I don&apos;t see much overlap between &quot;deferred updates&quot; and &quot;deferred constraints&quot;. Deferred updates are meant to untangle the problem of a single statement writing to the same data container that it&apos;s reading. Deferred constraints are meant to handle the problem of complex, multi-statement updates which may make your data inconsistent temporarily. I don&apos;t see how the &quot;deferred update&quot; machinery, which is scoped to a single statement, can be pressed into service to handle the multi-statement problem of &quot;deferred constraints.&quot; Thanks.&lt;/p&gt;</comment>
                            <comment id="13814210" author="mikem" created="Tue, 5 Nov 2013 20:04:40 +0000"  >&lt;p&gt;deferred to end transaction seems like definitely the hardest part of deferred constraints.  As an incremental strategy did you consider doing just the &quot;alter table&quot; level part first.  I wonder how many customers would be helped by &lt;br/&gt;
just being able to turn off constraint checking initially and enabling later and are ok with taking the hit of dropping and recreating indexes for this at &quot;check&quot; time.&lt;/p&gt;</comment>
                            <comment id="13814235" author="mikem" created="Tue, 5 Nov 2013 20:45:01 +0000"  >&lt;p&gt;I am trying to understand the locking and isolation implications of doing the &quot;duplicate&quot; checking in the non-duplicate new btrees at insert time.  And what is the right thing to do with rows marked deleted.  I think doing this check at&lt;br/&gt;
insert time is going to add  unintended problems with either isolation or locking.  I think the insert time check for duplicates is really a performance thing to narrow down the number of deferred rows to keep track of, and would like to see how bad a simpler strategy would perform which then could be optimized later with a more complicated btree implementation later if necessary.  Would this type of implementation also match up well with whatever we would have to do for deferred foreign key constraints?&lt;/p&gt;

&lt;p&gt;We have always made the indexes created for constraint checking available to the optimizer to pull rows out of&lt;br/&gt;
in the past.  Should these new deferred constraint indexes also be available, or is there anything special we can&lt;br/&gt;
do with these to make deferred update implementation easier.  I looked at some public documents and did not&lt;br/&gt;
get any specific info on how other db&apos;s do this, but got the feeling that these might be treated differently in some&lt;br/&gt;
way vs. other indexes.  We should be careful on implementation to make sure stuff like sort avoidance for&lt;br/&gt;
uniqueness works correctly with these.&lt;/p&gt;

&lt;p&gt;If the deferred unique constraint indexes were not made available to the optimizer to satisfy query results from (and thus the rows could be&lt;br/&gt;
out of date until end of transaction), then another option would&lt;br/&gt;
be to define the unique constraints exactly as they are today in the store - but somehow mark them as not &lt;br/&gt;
available to optimizer.  The obvious problem with them is that the inserting transaction should see rows it has&lt;br/&gt;
inserted and won&apos;t.  And just defer the updating of this&lt;br/&gt;
index until end of transaction, driving the updates from a deferred list maintained by the sql layer.  In this case&lt;br/&gt;
all isolation level locking would be unchanged (just delayed) and no possible unexpecting locking differences &lt;br/&gt;
between a deferred and non-deferred constraint.&lt;/p&gt;


&lt;p&gt;Could the SQL layer during deferred mode keep track of every insert into the &quot;duplicate&quot; constraint index and then do&lt;br/&gt;
the constraint check at commit time itself.  At end transaction time I think it is clear that every row that is looked at to do the duplicate check needs to be first locked and waited on and then checked, with locks released according to isolation&lt;br/&gt;
level standards.  This would include rows marked deleted, which would be locked to make sure that are not part&lt;br/&gt;
of other transactions that have not committed yet.  This check could be coded as a scan for the key and not 2 rows or it would be pretty clean to add a special interface to return true/false for more than one row match for a given key description.&lt;/p&gt;</comment>
                            <comment id="13814871" author="dagw" created="Wed, 6 Nov 2013 13:27:09 +0000"  >&lt;p&gt;Thanks a lot, Mike! I have answered inlined below. I might not have understood all your point, please bear with me, and don&apos;t hesitate to ask again/elaborate on unclear issues.&lt;/p&gt;

&lt;p&gt;&amp;gt; I would like to understand what would be the problem with&lt;br/&gt;
&amp;gt; implementing deferred constraints using existing &quot;duplicate&quot; BTree&lt;br/&gt;
&amp;gt; with no changes, and then do all deferred constraint checking in the&lt;br/&gt;
&amp;gt; sql layer doing probes to ascertain constraint consistency using&lt;br/&gt;
&amp;gt; existing access interfaces (with maybe something more specialized if&lt;br/&gt;
&amp;gt; that allows for faster path).&lt;/p&gt;

&lt;p&gt;Not sure if I understand you correctly there, but the approach taken is essentially to use the existing &quot;duplicate&quot; BTree approach implemented for nullable unique constraints/indexes, but with a twist:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;when we see a duplicate on insert (this is already being checked, nothing new there), remember it&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;for primary key and unique not null constraints which are deferrable (and only those: not deferrable constraints/indexes are unchanged except for a couple of extra tests, see below), we now use the &quot;duplicate&quot; BTree approach also&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Somehow, we do need to intercept the current duplicate checks when BTree inserts happen, so they don&apos;t throw and data does get inserted: otherwise we&apos;d need to store duplicate rows somewhere else and this would make operation later in the transaction difficult: for example a query would need to look in two places for data, I didn&apos;t want to go there...&lt;/p&gt;

&lt;p&gt;&amp;gt; I know you are following a path that the &quot;unique&quot; with duplicate code&lt;br/&gt;
&amp;gt; followed. I have regretted that approach since it was implemented. The&lt;br/&gt;
&amp;gt; project resulted in many bugs because of the complication involved in&lt;br/&gt;
&amp;gt; twisting the code to do something that it really did not want to do.&lt;/p&gt;

&lt;p&gt;Yes I am aware of that; I did find one extra bug with this approach, which I have fixed as part of this work: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6374&quot; title=&quot;Bulk insert of data with nullable UNIQUE constraint fails to detect duplicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6374&quot;&gt;&lt;del&gt;DERBY-6374&lt;/del&gt;&lt;/a&gt;. If/when we redesign this approach, I hope we could carry the implementation for deferred constraints along somehow.&lt;/p&gt;

&lt;p&gt;&amp;gt; if the new BTree approach is checked in, should add tests to look out&lt;br/&gt;
&amp;gt; for bugs like &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3502&quot; title=&quot;Unique Constraint&amp;#39;s backing index when shared with existing indexes doesn&amp;#39;t behave as expected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3502&quot;&gt;&lt;del&gt;DERBY-3502&lt;/del&gt;&lt;/a&gt; which came about the last time a new, but&lt;br/&gt;
&amp;gt; similar BTree was checked in.&lt;/p&gt;

&lt;p&gt;&amp;gt; It looks like a lot of the fast path code paths now have added code to&lt;br/&gt;
&amp;gt; deal with differed update. Should code for instance in&lt;br/&gt;
&amp;gt; InsertResultSet.java be broken out and there to be one routine to&lt;br/&gt;
&amp;gt; handle deferred constraint and one to not. With some sort of&lt;br/&gt;
&amp;gt; inheritance to handle it?&lt;/p&gt;

&lt;p&gt;As far as the existing fast code path (for not deferrable constraints and for indexes which are not &quot;nullable unique&quot;) is concerned, the new code adds the following extra overhead:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;* IndexChanger#insertAndCheckDups: one extra simple boolean test:
  
      &quot;!deferrable&quot;

* BTreeController#doIns: the existing two tests for

      btree.isUniqueWithDuplicateNulls()

  now has an extra test:

      btree.isUniqueWithDuplicateNulls() ||
      btree.hasDeferrableChecking()

This could be optimized to just use the booleans directly thus:

     btree.uniqueWithDuplicateNulls ||
    btree.uniqueDeferrable
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;so, in total two extra simple boolean checks per insert, which isn&apos;t bad I think. I am sure we could factor this out into more object oriented fashion, but I&apos;d worry that would entail much redundancy and/or extra method calls for the current fast path.&lt;/p&gt;

&lt;p&gt;&amp;gt; should there be changes to update code in addition to insert code, or&lt;br/&gt;
&amp;gt; is this one of the benefits of doing this work at lowest level where&lt;br/&gt;
&amp;gt; all updates on BTree&apos;s are turned into deletes and inserts?&lt;/p&gt;

&lt;p&gt;Yes, we get that for free.&lt;/p&gt;

&lt;p&gt;&amp;gt; deferred to end transaction seems like definitely the hardest part of&lt;br/&gt;
&amp;gt; deferred constraints. As an incremental strategy did you consider&lt;br/&gt;
&amp;gt; doing just the &quot;alter table&quot; level part first. I wonder how many&lt;br/&gt;
&amp;gt; customers would be helped by just being able to turn off constraint&lt;br/&gt;
&amp;gt; checking initially and enabling later and are ok with taking the hit&lt;br/&gt;
&amp;gt; of dropping and recreating indexes for this at &quot;check&quot; time.&lt;/p&gt;

&lt;p&gt;Yes I did consider it, but we have use cases that can benefit from the standard SQL feature.&lt;/p&gt;

&lt;p&gt;&amp;gt; I am trying to understand the locking and isolation implications of&lt;br/&gt;
&amp;gt; doing the &quot;duplicate&quot; checking in the non-duplicate new btrees at&lt;br/&gt;
&amp;gt; insert time.&lt;/p&gt;

&lt;p&gt;Again, not sure if I understand 100% what you&apos;re asking, but: I tried to make insertion of duplicate rows work with non-duplicate B-tree, but I had to abandon that approach. Cf. above: for deferred constraints we always use the approach of the duplicate &quot;nullable unique&quot; B-trees. Using that approach for deferrable PRIMARY KEY and UNIQUE &quot;not null&quot; constraints, will shows locking behavior similar to the current &quot;nullable unique&quot; implementation, I should think.&lt;/p&gt;

&lt;p&gt;Duplicate rows would keep their row X locks till transaction end since as far as the index is concerned, they are all unique (in that the key includes the row location of the base row). As far as isolation, I think only other transaction that use &quot;read uncommitted&quot; could ever see the duplicates.&lt;/p&gt;

&lt;p&gt;&amp;gt; And what is the right thing to do with rows marked deleted.&lt;/p&gt;

&lt;p&gt;Yes, that&apos;s what I hit problems with&lt;/p&gt;

&lt;p&gt;&amp;gt; I think doing this check at insert time is going to add unintended&lt;br/&gt;
&amp;gt; problems with either isolation or locking.&lt;/p&gt;

&lt;p&gt;Given the above, not sure I understand how. Could you explain what would be the concern here? Again, if the nullable unique indexes are OK as far as isolation and locking, I think the deferred variants should be ok too?&lt;/p&gt;

&lt;p&gt;&amp;gt; I think the insert time check for duplicates is really a&lt;br/&gt;
&amp;gt; performance thing to narrow down the number of deferred rows to keep&lt;br/&gt;
&amp;gt; track of,&lt;/p&gt;

&lt;p&gt;Well, today, the inserts will fail due to the duplicate checks in the B-tree, so we&apos;d need to do something to intercept this in any case. Can you sketch is some more detail what you have in mind?&lt;/p&gt;

&lt;p&gt;&amp;gt; perform which then could be optimized later with a more complicated&lt;br/&gt;
&amp;gt; btree implementation later if necessary. Would this type of&lt;br/&gt;
&amp;gt; implementation also match up well with whatever we would have to do&lt;br/&gt;
&amp;gt; for deferred foreign key constraints?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; We have always made the indexes created for constraint checking&lt;br/&gt;
&amp;gt; available to the optimizer to pull rows out of in the past. Should&lt;br/&gt;
&amp;gt; these new deferred constraint indexes also be available, or is there&lt;br/&gt;
&amp;gt; anything special we can do with these to make deferred update&lt;br/&gt;
&amp;gt; implementation easier. I looked at some public documents and did not&lt;br/&gt;
&amp;gt; get any specific info on how other db&apos;s do this, but got the feeling&lt;br/&gt;
&amp;gt; that these might be treated differently in some way vs. other&lt;br/&gt;
&amp;gt; indexes. We should be careful on implementation to make sure stuff&lt;br/&gt;
&amp;gt; like sort avoidance for uniqueness works correctly with these.&lt;/p&gt;

&lt;p&gt;I made sure that the deferred indexes would all answer &quot;false&quot; to the isUnique() method which the optimizer consults, so I think this would bar the optimizer from presuming (wrongly) that there is only one row. Again, this might make some queries on deferrable indexes less performant, but that&apos;s the price one has to pay to have deferred constraints. The existing non deferrable unique indexes/constraint will not be impacted.&lt;/p&gt;

&lt;p&gt;&amp;gt; If the deferred unique constraint indexes were not made available to&lt;br/&gt;
&amp;gt; the optimizer to satisfy query results from (and thus the rows could&lt;br/&gt;
&amp;gt; be out of date until end of transaction), then another option would be&lt;br/&gt;
&amp;gt; to define the unique constraints exactly as they are today in the&lt;br/&gt;
&amp;gt; store - but somehow mark them as not available to optimizer.&lt;/p&gt;

&lt;p&gt;Not sure I understand: meaning that the queries couldn&apos;t use the index at all until transaction end? I think that would perform worse than what I currently do: offer a non-unique index?&lt;/p&gt;

&lt;p&gt;&amp;gt; The obvious problem with them is that the inserting transaction&lt;br/&gt;
&amp;gt; should see rows it has inserted and won&apos;t. And just defer the&lt;br/&gt;
&amp;gt; updating of this index until end of transaction, driving the updates&lt;br/&gt;
&amp;gt; from a deferred list maintained by the sql layer.&lt;/p&gt;

&lt;p&gt;In the current solution, the inserting transaction does see the duplicate rows.&lt;/p&gt;

&lt;p&gt;&amp;gt; In this case all isolation level locking would be unchanged (just&lt;br/&gt;
&amp;gt; delayed) and no possible unexpected locking differences between a&lt;br/&gt;
&amp;gt; deferred and non-deferred constraint.&lt;/p&gt;

&lt;p&gt;The deferred case would retain locks on more rows till transaction end, which is to be expected. I think it is acceptable that deferrable constraints could show slightly different locking behavior that non deferrable constraints in any case. But again, I might not understand exactly what you are driving at here...&lt;/p&gt;

&lt;p&gt;&amp;gt; Could the SQL layer during deferred mode keep track of every insert&lt;br/&gt;
&amp;gt; into the &quot;duplicate&quot; constraint index and then do the constraint&lt;br/&gt;
&amp;gt; check at commit time itself.&lt;/p&gt;

&lt;p&gt;Instead of just keeping track of the duplicates, you mean? Again, we&apos;d need to make sure the inserts would succeed somehow. We do perform the constraint check at commit time in the present solution...&lt;/p&gt;

&lt;p&gt;&amp;gt; At end transaction time I think it is clear that every row that is&lt;br/&gt;
&amp;gt; looked at to do the duplicate check needs to be first locked and&lt;br/&gt;
&amp;gt; waited on and then checked, with locks released according to&lt;br/&gt;
&amp;gt; isolation level standards.&lt;/p&gt;

&lt;p&gt;Agreed. The present solution may not be correct here, I&apos;ll take another look: The B-tree scan I use at commit time uses ISOLATION_READ_COMMITTED_NOHOLDLOCK to check for the duplicates: the transaction already holds X locks to the rows it inserted, but it would need read locks on any other row with the same key. But presumably, for repeatable ready/serializable, we&apos;d already have those locks too?&lt;/p&gt;

&lt;p&gt;&amp;gt; This would include rows marked deleted, which would be locked to&lt;br/&gt;
&amp;gt; make sure that are not part of other transactions that have not&lt;br/&gt;
&amp;gt; committed yet. This check could be coded as a scan for the key&lt;/p&gt;

&lt;p&gt;That&apos;s what I do I think? Cf. DeferredDuplicates#validate&lt;/p&gt;

&lt;p&gt;&amp;gt; and not 2 rows or it would be pretty clean to add a special&lt;br/&gt;
&amp;gt; interface to return true/false for more than one row match for a&lt;br/&gt;
&amp;gt; given key description.&lt;/p&gt;</comment>
                            <comment id="13814874" author="dagw" created="Wed, 6 Nov 2013 13:29:47 +0000"  >&lt;p&gt;I forgot to add:&lt;/p&gt;

&lt;p&gt;&amp;gt;if the new btree approach is checked in, should add tests to look out&lt;br/&gt;
&amp;gt; for bugs like &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3502&quot; title=&quot;Unique Constraint&amp;#39;s backing index when shared with existing indexes doesn&amp;#39;t behave as expected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3502&quot;&gt;&lt;del&gt;DERBY-3502&lt;/del&gt;&lt;/a&gt; which came about the last time a new, but&lt;br/&gt;
&amp;gt; similar btree was checked in.&lt;/p&gt;

&lt;p&gt;The new backing indexes for deferrable constraints are not sharable for now, so we should avoid this class of errors.&lt;/p&gt;</comment>
                            <comment id="13814975" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"  >&lt;p&gt;Uploading refreshed versions of the three uncommitted (apply in sequential order to build):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;derby-532-unique-pk-3.diff
derby-532-xa-3.diff
derby-532-import-3.diff
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also attaching a new patch, derby-532-more-tests-1, which&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;adds more tests and changes the representation of the duplicates we store away in the hash table, so omit a unique counter and the row location of th eoriginal row, since none of those are actually used, so the has table can be reduced in size - we do not need to &lt;b&gt;store&lt;/b&gt; all duplicates, just the key (once).  &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Apply on top of the three first ones, running regressions.&lt;/p&gt;</comment>
                            <comment id="13815082" author="mikem" created="Wed, 6 Nov 2013 18:06:35 +0000"  >&lt;p&gt;Thanks Dag for the reply.  Below is hopefully a clearer explanation&lt;br/&gt;
of how I think it should work.&lt;/p&gt;

&lt;p&gt;I think we should implement all deferrable unique constraints using&lt;br/&gt;
existing unmodified non-unique btree implementation.   At least as the&lt;br/&gt;
first incremental approach I believe this should function correctly and&lt;br/&gt;
work with your design.&lt;/p&gt;

&lt;p&gt;Constraint checking architecturally seems like something that should happen&lt;br/&gt;
at the SQL layer.  I know the system does existing uniqueness checks in store&lt;br/&gt;
code, but as we have seen as this constraint checking gets more convoluted at&lt;br/&gt;
least to me it seems best managed closer to the SQL level that understands&lt;br/&gt;
the datatypes, the nullability rules, and in this case the level that&lt;br/&gt;
understands the timing on when that checking is meant to be done.  It looks&lt;br/&gt;
like Oracle implements their deferred unique checking using a non-unique&lt;br/&gt;
index also.&lt;/p&gt;

&lt;p&gt;Using a pure duplicate index matches the reality of deffered unique&lt;br/&gt;
constraint.  At any time when the constraint is deferred there may&lt;br/&gt;
be duplicate keys seen by the inserting transaction during query&lt;br/&gt;
execution.  So optimizer and execution should not assume index is unique.&lt;br/&gt;
Having no special casing in the btree I think will lead to less bugs&lt;br/&gt;
overall, as it should force all code to treat the index as it really is: ie.&lt;br/&gt;
a non-unique index.&lt;/p&gt;

&lt;p&gt;o constraint definition time:&lt;br/&gt;
  o create a pure duplicate allowing index matching the constraint.  It is&lt;br/&gt;
    important that the catalog for this that is used by the optimizer and&lt;br/&gt;
    execution knows that it is non-unique, even though it will be used to&lt;br/&gt;
    implement unique constraints.&lt;/p&gt;

&lt;p&gt;o sql layer insert/update time deferable constraint (constraint deferred):&lt;/p&gt;

&lt;p&gt;  o just go ahead and insert the row into the duplicate allowing index. There&lt;br/&gt;
    should never be a unique error thrown.  Do not have any code at this point&lt;br/&gt;
    that tries to determine anything about the constraint.&lt;/p&gt;

&lt;p&gt;    It sounded like you were seeing unique errors at this point initially,&lt;br/&gt;
    which I don&apos;t understand.&lt;/p&gt;

&lt;p&gt;    At SQL layer add all inserts into the btree into a backing store hash&lt;br/&gt;
    table.&lt;/p&gt;

&lt;p&gt;    As you mentioned this approach avoids having any sort of shadow table,&lt;br/&gt;
    the index is always up to date.  Locking prevents other transactions&lt;br/&gt;
    from seeing the possible duplicates, and I assume SQL standard says it&lt;br/&gt;
    is ok to see these duplicates from same transaction.&lt;br/&gt;
o sql layer insert/update time deferrable constraint (constraint not deferred)&lt;/p&gt;

&lt;p&gt;  o after insert run same duplicate check you would have run if it were&lt;br/&gt;
    deferred, just after the insert.  If it fails thow error and backout&lt;br/&gt;
    from SQL layer.&lt;/p&gt;

&lt;p&gt;o sql layer commit time with outstanding constraint checking&lt;/p&gt;

&lt;p&gt;  o now simply run through entire list doing constraint checking.  This&lt;br/&gt;
    is actually less complicated from a locking perspective since a probe&lt;br/&gt;
    into the tree using just the key will always go to the left-most&lt;br/&gt;
    matching key and the locking will be guaranteed left to right which&lt;br/&gt;
    avoids&lt;/p&gt;

&lt;p&gt;  o by using backing store list you won&apos;t run out of memory for the to&lt;br/&gt;
    be processed constraint list.  This is apparently was a problem in&lt;br/&gt;
    one google found posting about postgres.&lt;/p&gt;

&lt;p&gt;  o I think this step is one area where once the system is running I would&lt;br/&gt;
    suggest a follow on patch to add some sort of&lt;br/&gt;
    &quot;reopenScanAndCheckForDuplicate()&quot;&lt;br/&gt;
    interface to GenericScanController, if performance looks critical.&lt;br/&gt;
    It could package positioning the scan and checking for duplicates in&lt;br/&gt;
    one call and minimize latch contention.&lt;/p&gt;


&lt;p&gt;For me the benefits of this approach are:&lt;br/&gt;
1) move any &quot;extra&quot; locking necessary to verify duplicate in case of deferred&lt;br/&gt;
   checking to end of transaction, so less chance of unexpected concurrency&lt;br/&gt;
   during middle of long running transaction.&lt;/p&gt;

&lt;p&gt;2) Seems simpler to prove correct.  In the currently proposed solution the&lt;br/&gt;
   constraint becomes corrupt if for any reason the first check on inserting&lt;br/&gt;
   into the duplicate btree misses a possible duplicate.&lt;br/&gt;
   There a number of subtle problems with&lt;br/&gt;
   checking &quot;left and right&quot; during insert into a non-unique btree for&lt;br/&gt;
   duplicates.  The code may be correct but testing is very hard and the&lt;br/&gt;
   cases include combinations of all the following:&lt;br/&gt;
   o committed deleted rows of other transactions and self transactions&lt;br/&gt;
   o non-committed deleted rows of other transactions and self transactions&lt;br/&gt;
   o when going left need to lose latch and &quot;restart&quot; all work&lt;br/&gt;
   o aborted other transactions after the check&lt;br/&gt;
   o concurrent other transactions doing same insert at same time&lt;br/&gt;
   o does the existing locking guarantee that the 2nd inserter always does&lt;br/&gt;
     the final deferred check, and the 1st one does not have to do a check.&lt;br/&gt;
     Should we be forcing that order of check, or is it more concurrent to&lt;br/&gt;
     just do the check by whoever is ending transaction first?&lt;/p&gt;

&lt;p&gt;3) I think this same architecture should allow for one shared implementation&lt;br/&gt;
   to be also used by deferred foreign key constraints.  Would like some&lt;br/&gt;
   feedback if this makes sense or not.  I don&apos;t know much about existing&lt;br/&gt;
   foreign key constraints or how/if we need to do work to make them deferrable.&lt;br/&gt;
~&lt;/p&gt;</comment>
                            <comment id="13815390" author="dagw" created="Wed, 6 Nov 2013 22:29:27 +0000"  >&lt;p&gt;Thanks, Mike. Your proposal makes sense to me and I agree on your architectural consideration that as far as keeping the store out of the language considerations here - I believe what you propose should work, but would be slightly less performant that what I currently do, in that we would be storing away (and checking at commit time) &lt;b&gt;all&lt;/b&gt; inserted keys, not only those that are duplicates. But I agree it would be safer if we don&apos;t fully trust the current &quot;left/right&quot; checking, and also simpler, as far as reducing special code in the store. I&apos;ll have a closer look at such an approach and report back. &lt;/p&gt;

&lt;p&gt;Also with such a solution, at commit time two concurrent transactions both inserting duplicates would both be running checks. Could that give rise to dead-locks I wonder? Could both have a row level X write lock on a duplicate in addition to an existing (left-most) unlocked existing row, say? Or can we latch the X locked row in the BTree to detect a duplicate anyway?) &lt;/p&gt;

&lt;p&gt;As far as foreign constraints are concerned, I haven&apos;t looked closely at those yet, but my hunch is that we could reuse the mechanism developed for pk/unique.&lt;/p&gt;</comment>
                            <comment id="13815485" author="mikem" created="Thu, 7 Nov 2013 00:15:52 +0000"  >&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt; Also with such a solution, at commit time two concurrent transactions both&lt;br/&gt;
&amp;gt; inserting duplicates would both be running checks. Could that give rise to&lt;br/&gt;
&amp;gt; dead-locks I wonder? Could both have a row level X write lock on a duplicate&lt;br/&gt;
&amp;gt; in addition to an existing (left-most) unlocked existing row, say? Or can we&lt;br/&gt;
&amp;gt; latch the X locked row in the BTree to detect a duplicate anyway?)&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;This is interesting, we could easily cause deadlocks if not careful.  I think&lt;br/&gt;
this is an issue with either implementation if the &quot;pre-commit&quot; checking gets locks on&lt;br/&gt;
rows while checking for duplicates.  I think in current current patch&lt;br/&gt;
the problem happens if 2 transactions at same time insert same key as an&lt;br/&gt;
existing key, and in my proposal it happens sooner when 2 transactions insert&lt;br/&gt;
same key at same time but does not need an existing key.  There are other&lt;br/&gt;
scenario&apos;s but these seem the most straight forward.&lt;br/&gt;
At least in the proposed implementation&lt;br/&gt;
the check phase always asks for locks left to right.  I think deadlocks would&lt;br/&gt;
be pretty much guaranteed for competing transactions inserting duplicate keys.&lt;br/&gt;
 if we go ahead and get shared locks while checking&lt;br/&gt;
for duplicates.  I think in the non-defered case the 2nd competing transaction&lt;br/&gt;
would wait on insert, for the first transaction.&lt;/p&gt;

&lt;p&gt;I have not thought this all the way through but the options seem to be (in&lt;br/&gt;
all cases we would have exclusive latch on the page we looking at, and thus&lt;br/&gt;
row can not be changing underneath us):&lt;br/&gt;
1) get shared waiting locks on each row while doing the duplicate checking.&lt;br/&gt;
   If we get the lock do the obvious checks (ie. if deleted no check, if&lt;br/&gt;
   not deleted to the dup check).  If we get a timeout or deadlock I suggest&lt;br/&gt;
   catching and throwing a duplicate key error.  It means that another&lt;br/&gt;
   transaction has an active write action on a duplicate row, so seems&lt;br/&gt;
   reasonable to return a duplicate error.&lt;/p&gt;

&lt;p&gt;   I think it would be bad to let the timeout or deadlock escape to the user,&lt;br/&gt;
   as it is hard to explain how a transaction doing a single insert is&lt;br/&gt;
   deadlocking.&lt;/p&gt;

&lt;p&gt;2) get shared non-waiting locks on each row.  will throw more &quot;in-flight&quot;&lt;br/&gt;
   duplicate key errors that #1, but will not pay the wait/deadlock wait&lt;br/&gt;
   time penalty.  Do same error handling as in #1, but will only get timeout&apos;s.&lt;/p&gt;

&lt;p&gt;3) don&apos;t do any locking.  Then would have to throw duplicate error even on&lt;br/&gt;
   deleted rows as there is no way to tell if they are committed deleted or&lt;br/&gt;
   not.&lt;/p&gt;

&lt;p&gt;I would not do option #3.  I lean toward option #2, but would be ok with&lt;br/&gt;
option #1.&lt;/p&gt;

&lt;p&gt;I will think about if there is anything smart we can do if we know the&lt;br/&gt;
rows we are looking at are &quot;locked for insert&quot;, but nothing comes to mind&lt;br/&gt;
yet.&lt;/p&gt;</comment>
                            <comment id="13818959" author="knutanders" created="Mon, 11 Nov 2013 13:40:15 +0000"  >&lt;p&gt;What would the alternative solution do when the deferrable constraint operates in immediate mode? Then the index that is backing a primary key constraint should behave as a normal unique index, even though it is non-unique at the store level. So in that mode I suppose it would still need to do a left and right check on every insert somehow?&lt;/p&gt;</comment>
                            <comment id="13818998" author="dagw" created="Mon, 11 Nov 2013 14:42:55 +0000"  >&lt;p&gt;Yes, the present patch solves this by throwing instead of saving duplicate key. Not sure how this would work&lt;br/&gt;
with Mike&apos;s proposed approach - we do need this dynamic mode switching in order to comply with the standard.&lt;br/&gt;
Maybe we could make a store API to provide language with the ability to decide whether to insert or not (depending on constraint mode), e.g. return keys to left and right of key (with locked rows) of the row to be inserted. I sort of feel it would be a shame in any case to lose the improved performance early checking would give... we have indexes in part for support constraints after all.&lt;/p&gt;</comment>
                            <comment id="13819015" author="knutanders" created="Mon, 11 Nov 2013 15:10:37 +0000"  >&lt;p&gt;If we want to do the duplicate checking in the language layer, would the following work?&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Before inserting the new row into the index, do a BTree scan with serializable isolation level and startkey = stopkey = key columns of the new row.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Check if the scan returned empty result. If it was empty, just insert the row (the range should be protected by the serializable scan, so it should be safe). If it was not empty, throw exception (on immediate check) or store the key in a hash table (on deferred check).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That might save us from doing the left/right check, and also from having to check all inserted rows again on commit.&lt;/p&gt;</comment>
                            <comment id="13819198" author="dagw" created="Mon, 11 Nov 2013 18:44:22 +0000"  >&lt;p&gt;This sounds promising. As a bonus, we might also be able to leverage this approach for to get rid of the left/right checking for &quot;normal&quot; (not deferrable) nullable unique constraints, so we could get rid of the old error-prone approach.&lt;/p&gt;</comment>
                            <comment id="13819311" author="mikem" created="Mon, 11 Nov 2013 20:08:12 +0000"  >&lt;p&gt;my proposal would be to hopefully use the exact same code to check for duplicates in all deferrable cases.&lt;br/&gt;
The only difference would be the timing of the check. &lt;/p&gt;

&lt;p&gt;So in both cases just do the insert as normal into the duplicate allowing index.  &lt;/p&gt;

&lt;p&gt;In the deferred case we track that we need to do a duplicate check and then do it later.&lt;br/&gt;
In the immediate case we just do the duplicate check right away.  Hopefully the checking code is the same. &lt;br/&gt;
And I do think there is an obvious benefit and clean to adding a new store interface to do the check.  In &lt;br/&gt;
both cases other transactions don&apos;t see the duplicate key because of locking, and deleting the &lt;br/&gt;
duplicate rows is taken care of by duplicate key abort.&lt;/p&gt;

&lt;p&gt;I think knut&apos;s suggestion might work.   I would rather see us first implement stuff all the same (deferred and&lt;br/&gt;
immedate) and measure.  then see if it is worth adding different codepaths for optimization.  &lt;/p&gt;

&lt;p&gt;+1 to later thinking about removing all the left/right checking and use this same approach for &lt;br/&gt;
nullable unique constraints.  &lt;/p&gt;

&lt;p&gt;It does seem like it is well known in other systems that deferrable constraints are likely to not perform&lt;br/&gt;
as well as deferrable constraints.  So I think it is ok for 1st implementation to not match performance, just&lt;br/&gt;
be correct.  I do wonder how often users actually want to defer uniqueness constraint other than possibly&lt;br/&gt;
initial loading situations.  I think the big request is really about deferred foriegn key contraints, things like&lt;br/&gt;
loading a child before a parent, or some set of circular constraints that are hard to order.&lt;/p&gt;
</comment>
                            <comment id="13819417" author="mikem" created="Mon, 11 Nov 2013 21:27:11 +0000"  >&lt;p&gt;As an initial development test I would suggest changing the system to define all non-deferable unique constraints as deferable (but not deferred), and run the complete set of tests.  I do worry about unintended&lt;br/&gt;
locking issues.  Obviously you would not want to check this in, but would be a good sanity check.  maybe some of the lock tests would show them.&lt;/p&gt;</comment>
                            <comment id="13820398" author="dagw" created="Tue, 12 Nov 2013 20:12:26 +0000"  >&lt;p&gt;Good idea to run all tests with default deferrable constraints, but with immediate checking, I&apos;ll run this newly uploaded patch, derby-532-serializable-scan-1 though that experiment. &lt;/p&gt;

&lt;p&gt;This patch removed the special logic in BTreeController, and moves the extra checking to language (IndexChanger is in package *.impl.sql.execute).&lt;/p&gt;

&lt;p&gt;It essentially uses the approach Knut suggested force strict same order locking: a serializable scan on the key of the index row proposed to be inserted. For a deferrable primary key that inserts a non-duplicate, this gives the following locks, with a number indicate order they are set&lt;/p&gt;

&lt;p&gt;    U&lt;span class=&quot;error&quot;&gt;&amp;#91;v-1&amp;#93;&lt;/span&gt;  : an update lock on the previous row in the index (2.)&lt;br/&gt;
    X&lt;span class=&quot;error&quot;&gt;&amp;#91;v&amp;#93;&lt;/span&gt;:  an exclusive lock on the newly inserted row (1. set before the U-lock when inserting into base table)&lt;/p&gt;

&lt;p&gt;For a normal primary key insert, we only get the latter lock.&lt;br/&gt;
For an insert of a (first) duplicate, we would see the following locks:&lt;/p&gt;

&lt;p&gt;    U&lt;span class=&quot;error&quot;&gt;&amp;#91;v-1&amp;#93;&lt;/span&gt;:  an update lock on the previous row in the index (2.)&lt;br/&gt;
    U&lt;span class=&quot;error&quot;&gt;&amp;#91;v&amp;#93;&lt;/span&gt;: an update lock on the first inserted value, for which we now insert a duplicate (3.)&lt;br/&gt;
    X&lt;span class=&quot;error&quot;&gt;&amp;#91;v&amp;#93;&lt;/span&gt;: an exclusive lock on the newly inserted row. (1.)&lt;/p&gt;

&lt;p&gt;Since any transaction wanting to insert &quot;v&quot; would need to lock &quot;v-1&quot; to the left, we would effectively serialize any contending transactions behind the first one to insert &quot;v&quot;; meaning they would detect the duplicate, and throw (not deferred) or postpone further checking till commit (deferred mode).&lt;/p&gt;

&lt;p&gt;A test case verifying this has been added in ConstraintCharacteristicsTest#testLocks.&lt;br/&gt;
The patch is a sum of the patched not yet committed so far (no prerequisites). I had to make one small concession: the unique nullable constraints needed an extra predicate inside BtreeController to allow them to insert a duplicate. An alternative would be to mark these indexes as something else than &quot;uniqueWithDuplicateNulls&quot; when constraints are deferred.&lt;/p&gt;

&lt;p&gt;The checking at commit time uses a BtreeScan also, but not an identical one, it uses read committed, read-only no hold lock scan. I &lt;b&gt;think&lt;/b&gt; this should be safe &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;
</comment>
                            <comment id="13820503" author="dagw" created="Tue, 12 Nov 2013 21:33:54 +0000"  >&lt;p&gt;Some thoughts about correctness in the last patch, I&apos;d appreciate help in thinking through this..&lt;/p&gt;

&lt;p&gt;Deferrable constraint correctness&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Using serializable BTree scan, on a physically non-unique index.&lt;br/&gt;
  Intending to insert key &quot;v&quot;, we navigate to the first match, if any,&lt;br/&gt;
  of the key (the base row Location - the last column - is not used in&lt;br/&gt;
  scan key even if it is physically part of the index). This leaves&lt;br/&gt;
  the scan on the first &quot;next&quot; on the first &quot;v&quot; if it exists, or just&lt;br/&gt;
  past &quot;v-1&quot; (the slot containing the key just before &quot;v&quot;, call it&lt;br/&gt;
  &quot;v-1&quot;).&lt;/li&gt;
	&lt;li&gt;transactions intending to insert value &quot;v&quot; will need to U-lock slot&lt;br/&gt;
  containing the value &quot;v-1&quot;, since the serializable scan always locks&lt;br/&gt;
  previous row.&lt;/li&gt;
	&lt;li&gt;One and only one transaction could find &quot;v&quot; missing (and hence OK to&lt;br/&gt;
  insert), namely the first to lock &quot;v-1&quot; as part of a serializable&lt;br/&gt;
  BTRee scan. [Any other transaction type with a U lock on &quot;v-1&quot; would&lt;br/&gt;
  not be looking to insert &quot;v&quot;, if it did it would need to do the same&lt;br/&gt;
  thing.] Later transactions to lock &quot;v-1&quot; would find &quot;v&quot; committed,&lt;br/&gt;
  and so would need to throw (not deferred mode), or postpose checking&lt;br/&gt;
  till transaction commit (deferred mode).&lt;/li&gt;
	&lt;li&gt;If the lock holder of &quot;v-1&quot; (the first transaction) decides to&lt;br/&gt;
  delete &quot;v&quot; or roll back, the road will be open for other&lt;br/&gt;
  transactions to insert &quot;v&quot; once the U-lock on &quot;v-1&quot; is released by&lt;br/&gt;
  trans one.&lt;/li&gt;
	&lt;li&gt;In transactions, SQL mandates duplicates be visible to self later in&lt;br/&gt;
  the transaction, which would hold since self owns the X-lock till&lt;br/&gt;
  transaction commit time.&lt;/li&gt;
	&lt;li&gt;Any other transaction would not see &quot;v&quot;, until the X-lock is release&lt;br/&gt;
  at commit time (with the exception of read uncommitted transactions).&lt;/li&gt;
	&lt;li&gt;Deleted slots are handled (presumably) correctly by the existing&lt;br/&gt;
  BTreeScan machinery.&lt;/li&gt;
	&lt;li&gt;The above holds for both unique nullable and unique not nullable&lt;br/&gt;
  deferrable, since in both cases, we use the same physically&lt;br/&gt;
  non-unique index and the same method of checking uniqueness with a&lt;br/&gt;
  serializable BTreeScan: the only difference is that insertion of &quot;v&quot;&lt;br/&gt;
  would go ahead in the presence of an existing &quot;v&quot; iff the key&lt;br/&gt;
  contains one or more nulls. We forego the left-right checking&lt;br/&gt;
  currently being done for non-deferrable nullable unique indexes.&lt;/li&gt;
	&lt;li&gt;At commit time, all transactions that inserted &quot;v&quot; but found it to&lt;br/&gt;
  be a duplicate must check that &quot;v&quot; is now present in max one row in&lt;br/&gt;
  the BTree. For this we use a read BTreeScan which releases its locks&lt;br/&gt;
  as it goes along (ISOLATION_READ_COMMITTED_NOHOLDLOCK).  By&lt;br/&gt;
  navigating to the first &quot;v&quot; we have two cases for the transaction:
	&lt;ul&gt;
		&lt;li&gt;The &quot;v&quot; was present &lt;b&gt;before&lt;/b&gt; transaction in which it inserted a&lt;br/&gt;
  duplicate: it already has a U-lock on the first &quot;v&quot; and and X-lock&lt;br/&gt;
  on the newly inserted ones. So, its the scan should be able to&lt;br/&gt;
  position a read scan on both kinds of rows, and so detect if there&lt;br/&gt;
  is more than one of them.&lt;/li&gt;
		&lt;li&gt;There was no &quot;v&quot; present before this transaction came along, in&lt;br/&gt;
  which case it has X-lock to all inserted &quot;v&quot;s. Also in this case,&lt;br/&gt;
  the transaction has the locks it needs to position a read scan and&lt;br/&gt;
  check.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Possible dead-locks:&lt;br/&gt;
Since the writing transaction takes U and X locks, no other writing&lt;br/&gt;
transaction can take U or X locks on these rows (only R is compatible&lt;br/&gt;
with U). So since a trans has U and X or &quot;v-1&quot; and &quot;v&quot; and doesn&apos;t&lt;br/&gt;
need to upgrade that to more locks during the transaction (at least&lt;br/&gt;
for the insert of value &quot;v&quot;), two transactions that insert different&lt;br/&gt;
values should be free to act concurrently, iff the values are not&lt;br/&gt;
adjacent in the Btree.&lt;/li&gt;
	&lt;li&gt;As for the checking phase at commit time, the read only BTreeScan used&lt;br/&gt;
takes read locks on locks we already have, so again multiple&lt;br/&gt;
transaction should be free to both move forward concurrently iff&lt;br/&gt;
inserting non adjacent values.&lt;/li&gt;
	&lt;li&gt;Any dead-locks should thus be the result of the transactions trying to&lt;br/&gt;
read each others inserted values before commit (normal), e.g.
&lt;blockquote&gt;
&lt;p&gt;t1:    X&lt;span class=&quot;error&quot;&gt;&amp;#91;v&amp;#93;&lt;/span&gt; wants R&lt;span class=&quot;error&quot;&gt;&amp;#91;z&amp;#93;&lt;/span&gt;&lt;br/&gt;
t2:    X&lt;span class=&quot;error&quot;&gt;&amp;#91;z&amp;#93;&lt;/span&gt; wants R&lt;span class=&quot;error&quot;&gt;&amp;#91;v&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This window slightly increases as the transactions now need to U-lock&lt;br/&gt;
&quot;v-1&quot; which isn&apos;t necessary with non deferrable PK indexes, at least&lt;br/&gt;
not in read committed mode.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="13820561" author="mikem" created="Tue, 12 Nov 2013 22:25:02 +0000"  >&lt;p&gt;i will look at this, though it does seem quite complicated.  Is it any less complicated to prove correct if you do the check after the insert always?&lt;/p&gt;

&lt;p&gt;For review I am first just going to concentrate on the algorithm described above.  If we all agree on it working, then I will look at the code.  Hopefully the code will also have the above description as comments somewhere.&lt;/p&gt;
</comment>
                            <comment id="13820562" author="mikem" created="Tue, 12 Nov 2013 22:26:22 +0000"  >&lt;p&gt;question:  Is it possible for 2 transactions to be operating at the same time on a deferrable constraint and in one case the checking is deferred and in the 2nd case the checking is immediate?&lt;/p&gt;</comment>
                            <comment id="13820597" author="mikem" created="Tue, 12 Nov 2013 22:49:10 +0000"  >&lt;p&gt;&amp;gt;I had to make one small concession: the unique nullable constraints needed an extra predicate inside &amp;gt;BtreeController to allow them to insert a duplicate. An alternative would be to mark these indexes as &amp;gt;something else than &quot;uniqueWithDuplicateNulls&quot; when constraints are deferred.&lt;br/&gt;
In the deferable case I think these should be just standard duplicate allowing index, and do the&lt;br/&gt;
&quot;allow duplicate&quot; checking in language.  I believe it is very easy.  If any key in the row is null always&lt;br/&gt;
allow it, otherwise it becomes the same case as the other defered uniqueness constraints.&lt;/p&gt;</comment>
                            <comment id="13820630" author="mikem" created="Tue, 12 Nov 2013 23:15:47 +0000"  >&lt;p&gt;could you describe what behavior you expect from the current algorithm in the following case:&lt;br/&gt;
deferable constraint, in deferred mode&lt;br/&gt;
xact 1:&lt;br/&gt;
inserts v&lt;br/&gt;
does not commit&lt;br/&gt;
xact 2:&lt;br/&gt;
inserts duplicate v&lt;/p&gt;

&lt;p&gt;reading above it seems like xact 2 is going to block doing the &quot;ahead&quot; check, which does not seem&lt;br/&gt;
to be what a deferred constraint wants to happen.&lt;/p&gt;</comment>
                            <comment id="13820853" author="mikem" created="Wed, 13 Nov 2013 02:38:14 +0000"  >&lt;p&gt;I thought this patch was removing the dependency on a new btree version.   If a new version is needed, could you comment on why?  If not, then there is some leftover stuff in the patch dealing with a new btree version&lt;br/&gt;
(format id&apos;s, upgrade stuff, ...).&lt;/p&gt;</comment>
                            <comment id="13821176" author="knutanders" created="Wed, 13 Nov 2013 10:48:41 +0000"  >&lt;p&gt;As to locking, I think it should be safe to release the prev key lock once the new key has been inserted (both in the immediate case and the deferred case). At that point, the X lock on the new key will be enough to prevent other transactions from inserting a duplicate key (they will be blocked when doing the initial scan to see if the key is already in the index). That might allow a slightly higher level of concurrency. I don&apos;t know if we currently have the interface to release the prev key lock early, though. And in any case that&apos;s clearly an optimization that could wait until we have a working solution.&lt;/p&gt;</comment>
                            <comment id="13821555" author="dagw" created="Wed, 13 Nov 2013 17:27:36 +0000"  >&lt;p&gt;Thanks, Mike &amp;amp; Knut!&lt;/p&gt;

&lt;p&gt;&amp;gt; question: Is it possible for 2 transactions to be operating at the&lt;br/&gt;
&amp;gt; same time on a deferrable constraint and in one case the checking is&lt;br/&gt;
&amp;gt; deferred and in the 2nd case the checking is immediate?&lt;/p&gt;

&lt;p&gt;Yes, the constraint mode is session local according to the standard. The present patch allows this, I think.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;I had to make one small concession: the unique nullable constraints&lt;br/&gt;
&amp;gt;&amp;gt;needed an extra predicate inside BtreeController to allow them to&lt;br/&gt;
&amp;gt;&amp;gt;insert a duplicate. An alternative would be to mark these indexes as&lt;br/&gt;
&amp;gt;&amp;gt;something else than &quot;uniqueWithDuplicateNulls&quot; when constraints are&lt;br/&gt;
&amp;gt;&amp;gt;deferred.  &lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;In the deferable case I think these should be just standard&lt;br/&gt;
&amp;gt;duplicate allowing index, and do the &quot;allow duplicate&quot; checking in&lt;br/&gt;
&amp;gt;language. I believe it is very easy. If any key in the row is null&lt;br/&gt;
&amp;gt;always allow it, otherwise it becomes the same case as the other&lt;br/&gt;
&amp;gt;defered uniqueness constraints.&lt;/p&gt;

&lt;p&gt;Yes, and this is indeed what we do for nullable unique for deferrable indexes. I think I can fix that by just omitting to make the index conglomerate with uniqueWithDuplicateNulls in the deferrable case, yes.&lt;/p&gt;

&lt;p&gt;As for the locking case, xact 2 would block. I agree with Knut we could optimize the locking as suggested later.&lt;/p&gt;

&lt;p&gt;&amp;gt; If a new version is needed, could you comment on why?&lt;/p&gt;

&lt;p&gt;Cf. the above: if we handle the uniqueWithDuplicateNulls as discussed above, the need to mark the conglomerate with hasDeferrableChecking would go away (and we no longer need the isUniqueDeferrable at the BTree level), so we don&apos;t need the format change: I&apos;ll roll a new patch.&lt;/p&gt;
</comment>
                            <comment id="13821569" author="mikem" created="Wed, 13 Nov 2013 17:39:36 +0000"  >&lt;p&gt;I don&apos;t think it is just the prev key lock that is a problem, but all the locking done previous to the insert - at least in the deferable constraint/deferred case.&lt;/p&gt;

&lt;p&gt;In the deferable constraint/deferred case my assumption is that an insert should only block in the case where a user intiated serializable transaction is blocking inserts into a range of keys.  In that case it must block and that is handled by locking done as part of the insert which is not changed by this project.&lt;/p&gt;</comment>
                            <comment id="13821863" author="dagw" created="Wed, 13 Nov 2013 21:26:56 +0000"  >&lt;p&gt;Attaching patch derby-532-serializable-scan-2. This removes the (new) btree conglomerate format as discussed, and also adds two more test cases:&lt;/p&gt;

&lt;p&gt;a) to testLocks we add a test to verify xact 2 must wait to insert (another) duplicate behind xact 1&lt;br/&gt;
b) to testImport, we add a test case to verify that multiple rows containing a null will not fail even for a deferred constraint.&lt;/p&gt;

&lt;p&gt;It also adds the point on the approach &amp;amp; its correctness to the code in IndexChanger as requested by Mike. Re-running regressions.&lt;/p&gt;</comment>
                            <comment id="13821877" author="dagw" created="Wed, 13 Nov 2013 21:35:06 +0000"  >&lt;p&gt;Mike, not sure what you are getting at here: as far as I can see the serializable scan only locks the previous key (&quot;v-1&quot;) and possibly an existing value of the one we are trying to insert (&quot;v&quot;). If that&apos;s correct, and you are not worried about the lock on the previous key, what other locks are you concerned about? Are you saying the serializable scan takes lock on values below &quot;v-1&quot; also? I thought I looked at that and found it didn&apos;t but I could be mistaken..&lt;/p&gt;</comment>
                            <comment id="13821921" author="mikem" created="Wed, 13 Nov 2013 22:25:28 +0000"  >&lt;p&gt;sorry to add the confusing note about serializable scan, as I actually don&apos;t think there is a problem&lt;br/&gt;
with that part of the implementation.&lt;/p&gt;

&lt;p&gt;I believe it is wrong in the example I asked about above, the deferrable constraint/deferred case, for an insert to block ever if there are no serialized scans in the system.  The current patch insures this&lt;br/&gt;
behavior and will continue to insure this behavior even if we figure out how to release the &quot;extra&quot; &lt;br/&gt;
previous key lock.   &lt;/p&gt;

&lt;p&gt;Any implementation that tries to do a check previous to the insert is likely to suffer from this issue, which is one of&lt;br/&gt;
the reasons I still think it would be better to always to do the check after the insert, and not try to do any &lt;br/&gt;
duplicate prevention locking schemes that are likely to present unintuitive concurrency issues to the &lt;br/&gt;
application.&lt;/p&gt;</comment>
                            <comment id="13821935" author="dagw" created="Wed, 13 Nov 2013 22:40:24 +0000"  >&lt;p&gt;Ok, thanks. I understand. I&apos;ll have a look at such an implementation, too. I shouldn&apos;t&#160;be too hard to check right after the insert with a read-only scan for &quot;v&quot;, but I&apos;d like to avoid saving all inserts with the pessimistic assumption they are all duplicates). &lt;/p&gt;</comment>
                            <comment id="13821939" author="mikem" created="Wed, 13 Nov 2013 22:44:48 +0000"  >&lt;p&gt;one other consideration is that Derby actually has more than row locks than S, U, and W.  We don&apos;t really document them as it is more confusing than it is worth to users, and the lock debugging tools map the 8 locks into these 3 letters.   There are actually 8 different types of locks&lt;br/&gt;
defined in org.apache.derby.iapi.store.raw.RowLock, and you can see the complete compatibility table&lt;br/&gt;
there.&lt;br/&gt;
    /* Row Shared lock for repeatable read and below isolation level */&lt;br/&gt;
    public static final RowLock RS2  = new RowLock(0);&lt;br/&gt;
    /* Row Shared lock for serialized read isolation level */&lt;br/&gt;
    public static final RowLock RS3  = new RowLock(1);&lt;br/&gt;
    /* Row Update lock for reapeatable read and below isolation level*/&lt;br/&gt;
    public static final RowLock RU2  = new RowLock(2);&lt;br/&gt;
    /* Row Update lock for serializable isolation level*/&lt;br/&gt;
    public static final RowLock RU3  = new RowLock(3);&lt;br/&gt;
    /* Row Insert previous key lock */&lt;br/&gt;
    public static final RowLock RIP  = new RowLock(4);&lt;br/&gt;
    /* Row Insert lock */&lt;br/&gt;
    public static final RowLock RI   = new RowLock(5);&lt;br/&gt;
    /* Row exclusive write lock for repeatable read and below isolation level */&lt;br/&gt;
    public static final RowLock RX2  = new RowLock(6);&lt;br/&gt;
    /* Row exclusive write lock for serializable isolation level */&lt;br/&gt;
    public static final RowLock RX3  = new RowLock(7);&lt;/p&gt;

&lt;p&gt;The one of interest to this discussion is the RIP lock, which implements the previous key lock for inserts.  This lock did not exist in the initial implementations, but was required as users found concurrency unacceptable when we just got a regular write lock as the previous key lock for inserts.&lt;/p&gt;

&lt;p&gt;inserts get the right previous key locks.  Doing a scan before the insert is going to get the wrong previous&lt;br/&gt;
key lock for an insert to have, and it is also going to block in cases I don&apos;t think are expected by someone&lt;br/&gt;
using deferred constraint.&lt;/p&gt;

&lt;p&gt;Here is the compatibility table:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    /** Row lock compatibility table. */
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt;[][] R_COMPAT = {
        &lt;span class=&quot;code-comment&quot;&gt;//          Granted
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// Request   RS2     RS3    RU2    RU3    RIP    RI     RX2    RX3
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//
&lt;/span&gt;        /* RS2 */    {&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RS3 */    {&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RU2 */    {&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RU3 */    {&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RIP */    {&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; , &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RI  */    {&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RX2 */    {&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,  &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; },
        /* RX3 */    {&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


</comment>
                            <comment id="13821971" author="dagw" created="Wed, 13 Nov 2013 23:14:22 +0000"  >&lt;p&gt;Thanks for that information, Mike. Interesting; I wasn&apos;t aware of this. I see the RIP is compatible with the other X-locks except the seriablizable ones (symmetrically). So, for the Btree serializable scan couldn&apos;t we make the  the scan optionally use this kind of lock?&lt;/p&gt;
</comment>
                            <comment id="13821972" author="mikem" created="Wed, 13 Nov 2013 23:18:24 +0000"  >&lt;p&gt;I do think we need to think hard about a similar set of issues that you wrote up for the single post check after the insert, to&lt;br/&gt;
convince everyone of correctness.  But I think the post scan need only answer a single question, did the&lt;br/&gt;
insert I made cause a duplicate key - I don&apos;t think it needs to prevent a subsequent duplicate key from &lt;br/&gt;
being inserted, even while the scan is happening so it can do a simpler scan&lt;/p&gt;

&lt;p&gt;assuming:&lt;br/&gt;
1) all inserts into this tree will do the same left to right scan for duplicates after the insert.  It may happen&lt;br/&gt;
    right after the insert or it may happen at end of transaction.&lt;br/&gt;
2) the scan positions at the first instance of the key (with no row position).&lt;br/&gt;
    If the scan comes back with no key assert if it is an immedate check as something is seriously wrong,&lt;br/&gt;
    otherwise in deferred mode I think it is ok as the inserting transaction may have deleted it in the meantime&lt;br/&gt;
    and we should not try to track that.&lt;br/&gt;
    if the key exists it waits for a S lock on the key.  If it gets a lock and it is deleted then all is fine.  If it&lt;br/&gt;
    gets a lock then note it if it is the first or throw a duplicate key error if it is the 2nd.  The normal case&lt;br/&gt;
    is the scan finds one and only one row.&lt;br/&gt;
    If it gets a lock timeout or a deadlock then I am not positive what to do.  I lean toward catching and &lt;br/&gt;
        turning it&lt;br/&gt;
        into a duplicate key error.   I think applications are much more likely to handle that than a unexpected&lt;br/&gt;
        deadlock.  I think the easy case of 2 concurrent inserts of same key to a deferred constraint  is going&lt;br/&gt;
        to generate a deadlock, and users are not going to expect a system with 2 xacts doing just a single &lt;br/&gt;
        insert each to generate a deadlock.&lt;/p&gt;</comment>
                            <comment id="13821980" author="mikem" created="Wed, 13 Nov 2013 23:27:06 +0000"  >&lt;p&gt;As part of trying to understand deferred constraints I did a bit of searching on the Web.  And one thing that kept popping up is a lot of experts recommending that database designers not pick deferred constraints, if at all possible.  One of the main reasons for this is that there was consensus that many if not most applications do not code for errors coming out of a &quot;commit&quot;.   I believe the standard has always allowed for commit to fail,&lt;br/&gt;
but previous to this I think in derby the only thing that would make commit fail would be some sort of server&lt;br/&gt;
crashing even like a low level bug, or the transaction logging system running out resources to write the &lt;br/&gt;
commit log record.  &lt;/p&gt;

&lt;p&gt;So I suggest that we highlight in the documentation for this project and for the individual new ddl that using this feature will call for applications to have error handling for commit to fail.  This may be new for many applications.  Probably would be good to show some sample code on how to handle a deferred unique constraint failing at commit time.&lt;/p&gt;</comment>
                            <comment id="13821990" author="mikem" created="Wed, 13 Nov 2013 23:39:45 +0000"  >&lt;p&gt;&amp;gt;Thanks for that information, Mike. Interesting; I wasn&apos;t aware of this. I see the RIP is compatible with the other &amp;gt;X-locks except the seriablizable ones (symmetrically). So, for the Btree serializable scan couldn&apos;t we make &amp;gt;the the scan optionally use this kind of lock?&lt;br/&gt;
The RIP lock is used to stop the insert if a serialized scan is going on, it is not used by the existing serialized scan.   So I don&apos;t think it fixes the problems I have raised even if we were to provide some new locking scan.&lt;/p&gt;

&lt;p&gt;I think the key requirement we should agree on that I am currently stuck on, is what should an insert into a deferrable constraint/deferred do when there exists an uncommitted insert of the same key in the table.  I&lt;br/&gt;
think the insert should procede and the current patch blocks.  And I think the current patch blocks even if&lt;br/&gt;
we were to not get a previous key lock because we scan for duplicates ahead of the insert in the deferred&lt;br/&gt;
case.&lt;/p&gt;</comment>
                            <comment id="13822013" author="mikem" created="Thu, 14 Nov 2013 00:07:45 +0000"  >&lt;p&gt;I don&apos;t think it is a big deal to add all inserts to the deferred check list when you are in deferred mode, but recognize others may not agree.&lt;br/&gt;
I consider any code that eliminates the inserts from the list early just an optimization, but any problem with&lt;br/&gt;
the optimization can easily lead to a corrupt table if it misses just one case it should have checked later.  I think&lt;br/&gt;
we agree at this point that all the other pieces still need to happen.&lt;/p&gt;

&lt;p&gt;If you think the optimization is necessary do you think the following can be proven correct, ie we will never&lt;br/&gt;
miss a case where the row we inserted is causing a duplicate key and should have been added to the&lt;br/&gt;
deferred check list:&lt;br/&gt;
o do the insert first.&lt;br/&gt;
o in deferred case do an immediate non-serialized, no hold, no lock wait, read only scan of the keys.  &lt;br/&gt;
   if duplicate add to list, and if it could not get a lock add to the list.  locks have to be acquired for store&lt;br/&gt;
   to do the right thing with rows marked deleted - can not do read uncommitted.&lt;br/&gt;
o in immediate case do the lock wait, read scan.&lt;/p&gt;

&lt;p&gt;and in deferred case do the lock wait read scan at commit.&lt;/p&gt;

&lt;p&gt;In both scan cases it is possible that while we are scanning someone might add a duplicate row&lt;br/&gt;
that the can will miss, but I think that is ok.  We just need to make sure all the rows as of &quot;now&quot; are being&lt;br/&gt;
checked.   And we insure that because the scan positions at the leftmost matching key &quot;now&quot; and moves&lt;br/&gt;
right.  No &quot;now&quot; row can move left. It is up to whoever is inserting those later rows to do their own check.&lt;br/&gt;
But I appreciate all to think about this.&lt;/p&gt;
</comment>
                            <comment id="13822037" author="mikem" created="Thu, 14 Nov 2013 00:46:46 +0000"  >&lt;p&gt;it would be good either as part of this project or a follow on to enhance the consistency checker to make sure keys in these indexes that support deferable constraints are all unique within whatever the appropriate guidelines &lt;br/&gt;
(ie. allow duplicate nulls or not).  If a table level lock is held then it should be true that there are no duplicates, even though the underlying implementation btree is a duplicate allowing index.&lt;/p&gt;

&lt;p&gt;being able to run this after some set of stressing the deferable constraint code in tests might make it easier to test.&lt;/p&gt;</comment>
                            <comment id="13822700" author="dagw" created="Thu, 14 Nov 2013 18:10:09 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; If you think the optimization is necessary do you think the following&lt;br/&gt;
&amp;gt; can be proven correct, ie we will never miss a case where the row we&lt;br/&gt;
&amp;gt; inserted is causing a duplicate key and should have been added to the&lt;br/&gt;
&amp;gt; deferred check list:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; o do the insert first.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; o in deferred case do an immediate non-serialized, no hold, no lock&lt;br/&gt;
&amp;gt;   wait, read only scan of the keys.  if duplicate add to list, and if&lt;br/&gt;
&amp;gt;   it could not get a lock add to the list. locks have to be acquired&lt;br/&gt;
&amp;gt;   for store to do the right thing with rows marked deleted - can not&lt;br/&gt;
&amp;gt;   do read uncommitted.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, I agree we wouldn&apos;t want to wait for the lock there; just adding it to the list in a &quot;pessimistic&quot; assumption is fine, so we&apos;d check again on commit.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; o in immediate case do the lock wait, read scan.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, and report as duplicate if timeout or deadlock. I think it&apos;s better than reporting lock timeout as you suggest.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; and in deferred case do the lock wait read scan at commit.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, and again, report as duplicate if timeout or deadlock. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt; In both scan cases it is possible that while we are scanning someone&lt;br/&gt;
&amp;gt; might add a duplicate row that the scan will miss, but I think that is&lt;br/&gt;
&amp;gt; ok. We just need to make sure all the rows as of &quot;now&quot; are being&lt;br/&gt;
&amp;gt; checked. And we insure that because the scan positions at the leftmost&lt;br/&gt;
&amp;gt; matching key &quot;now&quot; and moves right. No &quot;now&quot; row can move left. It is&lt;br/&gt;
&amp;gt; up to whoever is inserting those later rows to do their own check.&lt;br/&gt;
&amp;gt; But I appreciate all to think about this.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I believe this will be correct, but I will do some experiments.&lt;/p&gt;</comment>
                            <comment id="13822712" author="dagw" created="Thu, 14 Nov 2013 18:18:38 +0000"  >&lt;p&gt;&amp;gt; So I suggest that we highlight in the documentation for this project and for the individual new ddl &lt;br/&gt;
&amp;gt; that using this feature will call for applications to have error handling for commit to fail.&lt;/p&gt;

&lt;p&gt;Yes, that will be good. &lt;/p&gt;
</comment>
                            <comment id="13822715" author="dagw" created="Thu, 14 Nov 2013 18:20:22 +0000"  >&lt;p&gt;&amp;gt; it would be good either as part of this project or a follow on to enhance the consistency checker to make sure &amp;gt; keys in these indexes that support deferable constraints are all unique&lt;/p&gt;

&lt;p&gt;+1. If I don&apos;t get to it, I&apos;ll make a separate JIRA.&lt;/p&gt;</comment>
                            <comment id="13822768" author="dagw" created="Thu, 14 Nov 2013 18:55:57 +0000"  >&lt;p&gt;Btw, will the BTreeScan honor the flag OPENMODE_LOCK_NOWAIT? Is so, iff on next() we can&apos;t get a lock, will it throw or return null?&lt;/p&gt;</comment>
                            <comment id="13822773" author="mikem" created="Thu, 14 Nov 2013 18:58:23 +0000"  >&lt;p&gt;looking at latest patch, with changes to move the checking out of store and not special casing the types of btree&lt;br/&gt;
I am wondering if the changes to the following files are still needed.  I have not reviewed the changes in &lt;br/&gt;
latest patch yet, just was not expecting changes to these files.:&lt;br/&gt;
M       java\engine\org\apache\derby\iapi\store\access\SortObserver.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\store\access\sort\UniqueWithDuplicateNullsMergeSort.java&lt;br/&gt;
M       java\engine\org\apache\derby\impl\store\access\sort\MergeSort.java&lt;br/&gt;
M       java\testing\org\apache\derbyTesting\unitTests\store\T_SortController.java&lt;/p&gt;

&lt;p&gt;If they are still needed can you give a short explanation of why, to help with my review.&lt;/p&gt;</comment>
                            <comment id="13822807" author="mikem" created="Thu, 14 Nov 2013 19:38:24 +0000"  >&lt;p&gt;I just looked at the protocol documentation and I don&apos;t think currently the btree scan will do what you want, with respect to OPENMODE_LOCK_NOWAIT.  It looks like it will do nowait on the table lock but not on the subsequent row locks.  &lt;/p&gt;

&lt;p&gt;I would suggest as an incremental approach to code the deferred check using waiting locks for now, and&lt;br/&gt;
we can optimize it to not wait in a subsequent patch.  I think even in the nowait case the new interface should throw a locktimeout error if it can&apos;t get the lock.&lt;/p&gt;

&lt;p&gt;I need to think about what would be the best solution to providing this functionality.  We can either enhance all scans to support lock nowait, which i think is it a lot of work.  Or I think it would be easier and better for this feature in the long run to provide a new interface that your code would just pass in the key you are looking for,&lt;br/&gt;
some params similar to openScan to tell what type of scan to use in addition to a wait or no wait flag.  This would mean the duplicate check could be done in a single trip to store, rather than open a scan and then do a next.   At the lowest level of the btree we often ask for nowait locks, so that part is not hard.  But making it&lt;br/&gt;
available for all scans is overriding the user setting for this.  This is obviously a special case, so think it is&lt;br/&gt;
cleaner making it clear it is a special case by using a different interface.&lt;/p&gt;

&lt;p&gt;I would be interested in implementing this interface as a subsequent patch, once you get checked in.  Or if you want to implement I can help.  Let me know which you prefer.&lt;/p&gt;</comment>
                            <comment id="13822823" author="dagw" created="Thu, 14 Nov 2013 19:54:16 +0000"  >&lt;p&gt;(re SortObserver &amp;amp; friends): Possibly not, I&apos;ll have a look. I guess for deferrable, we could check for duplicates in a separate scan, but again I modeled the checking on what was done for nullable unique.&lt;/p&gt;</comment>
                            <comment id="13822832" author="dagw" created="Thu, 14 Nov 2013 20:01:22 +0000"  >&lt;p&gt;&amp;gt; I just looked at the protocol documentation and I don&apos;t think currently the btree scan will do what you want, &lt;br/&gt;
&amp;gt; with respect to OPENMODE_LOCK_NOWAIT. It looks like it will do nowait on the table lock but not on the &lt;br/&gt;
&amp;gt; subsequent row locks. &lt;/p&gt;

&lt;p&gt;Thanks, Mike. That was was I suspected by my cursory investigation, yes. I&apos;ll code it with the waiting locks for now. I did see the lowest levels use nolock, though. If you&apos;d like to help me make a special API for this, that would be great. I can certainly help with it too, should you be to busy to get it done. If you like, I can make a separate JIRA for in, so whoever gets to it first can grab that.&lt;/p&gt;</comment>
                            <comment id="13823565" author="knutanders" created="Fri, 15 Nov 2013 11:11:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;    &amp;gt;&lt;br/&gt;
    &amp;gt; o in immediate case do the lock wait, read scan.&lt;/p&gt;

&lt;p&gt;Yes, and report as duplicate if timeout or deadlock. I think it&apos;s better than reporting lock timeout as you suggest.&lt;/p&gt;

&lt;p&gt;    &amp;gt;&lt;br/&gt;
    &amp;gt; and in deferred case do the lock wait read scan at commit.&lt;/p&gt;

&lt;p&gt;Yes, and again, report as duplicate if timeout or deadlock.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If I understand this proposal correctly, an insert operation will throw duplicate key exception instead of lock timeout exception if it cannot obtain a lock during duplicate checking. If so, that doesn&apos;t match what we do in the non-deferrable case:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos; as c1;
ij&amp;gt; create table t(x int primary key);
0 rows inserted/updated/deleted
ij&amp;gt; autocommit off;
ij&amp;gt; insert into t values 1;
1 row inserted/updated/deleted
ij&amp;gt; connect &apos;jdbc:derby:memory:db&apos; as c2;
ij(C2)&amp;gt; insert into t values 0;
1 row inserted/updated/deleted
ij(C2)&amp;gt; insert into t values 1;
ERROR 40XL1: A lock could not be obtained within the time requested
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I agree that we should not throw lock timeout exception if we cannot get a lock immediately during the preliminary check in the deferred case. Then we should just add that key to the list of keys to check at commit time. But if we fail to get a lock in the final duplicate check (either immediate or deferred), I think it is correct to report that as a lock timeout, not as a constraint violation, as we don&apos;t know if it actually is a constraint violation until the other transactions have completed.&lt;/p&gt;</comment>
                            <comment id="13826414" author="dagw" created="Tue, 19 Nov 2013 11:50:04 +0000"  >&lt;p&gt;Created &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt; as a sub-task: Make BTree scan honor OPENMODE_LOCK_NOWAIT for row locks.&lt;/p&gt;</comment>
                            <comment id="13826437" author="dagw" created="Tue, 19 Nov 2013 12:32:39 +0000"  >&lt;p&gt;Thanks, Knut. Seeing that we get a lock time-out also in the non.deferrable case, I tend to agree. So, in summary, at insert time, presume duplicate and check later, at commit/check time, report time-out if we can&apos;t get the lock.&lt;/p&gt;</comment>
                            <comment id="13826517" author="dagw" created="Tue, 19 Nov 2013 13:46:10 +0000"  >&lt;p&gt;(re SortObserver &amp;amp; friends): I think the changes are pretty small, and the alternative would be to make separate sorting passes (one for each deferrable constraint/index on a table) with new code to check the deferrables; not convinced that&apos;s worth the extra amount of code and redundancy. For the moment, I&apos;d like to keep these changes.&lt;/p&gt;</comment>
                            <comment id="13826560" author="dagw" created="Tue, 19 Nov 2013 14:57:32 +0000"  >&lt;p&gt;Attaching derby-532-post-scan-1 which changes the serializable scan to check before the insert to use an unconditional insert (in IndexChanger#insertAndCheckDups) plus a post-insert scan to check for duplicates. This scan presently uses a scan that will wait if a row is locked. &lt;br/&gt;
A time.out on insert will presume it&apos;s a duplicate and schedule a commit-time check.&lt;br/&gt;
This will changed when we implement the optimization described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt;. A time-out (or dead-lock) at commit-time will be reported as such. A change of constraint mode to immediate which can&apos;t get a lock will also report a time-out or dead-lock.&lt;/p&gt;

&lt;p&gt;Re-running regressions.&lt;/p&gt;</comment>
                            <comment id="13826644" author="dagw" created="Tue, 19 Nov 2013 16:21:25 +0000"  >&lt;p&gt;Regressions passed. I intend to commit this in a day or two modulo review comments.&lt;/p&gt;</comment>
                            <comment id="13826813" author="mikem" created="Tue, 19 Nov 2013 18:56:39 +0000"  >&lt;p&gt;I plan on doing one more review of whole package.  I am ok with the lock timeout deciscion, but I am concerned that I think 2 duplicate inserters to a deferrable constraint/deferred are I think guaranteed to deadlock.  But I don&apos;t have a good answer to that.&lt;/p&gt;

&lt;p&gt;I will post comments to the new issue about the new interface we talked about.  lets get this part in first.&lt;/p&gt;</comment>
                            <comment id="13826899" author="mikem" created="Tue, 19 Nov 2013 20:16:38 +0000"  >&lt;p&gt;first half of review, really only questions and requests for more comments, code so far looks fine.   It would be &lt;br/&gt;
good to get someone with more language expertise to look at that part.   I can probably do a good job reviewing&lt;br/&gt;
the changes that are there - but someone else might need to review to think about the changes that aren&apos;t there&lt;br/&gt;
that might be needed.   I am ok with leaving the sort observer stuff.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/catalog/IndexDescriptor.java&lt;br/&gt;
nit: maybe would be good to add comments here describing that unique&lt;br/&gt;
     deferrable indexes are implemented using store non-uniqe indexes, and&lt;br/&gt;
     that sql layer owns enforcing uniqueness.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/catalog/types/IndexDescriptorImpl.java&lt;br/&gt;
nit: same comment as about about more detail about deferrable indexes.&lt;/p&gt;

&lt;p&gt;some document table describing the use of the following associating it with&lt;br/&gt;
deferred and non-deffered and different contraint types might help to make&lt;br/&gt;
it clearer:&lt;/p&gt;

&lt;p&gt;boolean isUnique,&lt;br/&gt;
boolean isUniqueWithDuplicateNulls,&lt;br/&gt;
boolean isUniqueDeferrable,&lt;br/&gt;
boolean hasDeferrableChecking,&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;/p&gt;

&lt;p&gt;no comment.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/iapi/sql/conn/SQLSessionContext.java&lt;br/&gt;
no comment.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/iapi/sql/conn/StatementContext.java&lt;br/&gt;
no comment.&lt;/p&gt;

&lt;p&gt;java/engine/org/apache/derby/iapi/sql/dictionary/IndexRowGenerator.java&lt;br/&gt;
nit: same comment about expanding on what isUniqueDeferrable means for the index&lt;/p&gt;

&lt;p&gt;java/engine/org/apache/derby/iapi/store/access/SortObserver.java&lt;br/&gt;
would be nice for the 3 new interfaces to have javadoc comments for each,&lt;br/&gt;
explaing their use in more detail.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;br/&gt;
+1&lt;br/&gt;
nice you got rid of old version check here.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/sql/execute/AlterConstraintConstantActi&lt;br/&gt;
on.java&lt;br/&gt;
o would be good to have tests that alter back and forth from deferred and&lt;br/&gt;
  not deffered and make sure subsequent actions do the right thing.  Could&lt;br/&gt;
  looks like existing mechanism should work, but seems a good code path to&lt;br/&gt;
  test.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.j&lt;br/&gt;
ava&lt;br/&gt;
some comment on why sharing is turned off for deferable constraints would&lt;br/&gt;
be good.  A user is going to complain at some point when they see duplicate&lt;br/&gt;
indexes taking up twice space that they don&apos;t think they need.&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/sql/execute/DeferredDuplicates.java&lt;/p&gt;

&lt;p&gt;o This code throws   SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T or&lt;br/&gt;
  SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_S.  If these are not&lt;br/&gt;
  caught and remapped can someone comment on if this is the standard. Is it&lt;br/&gt;
  ok that this type of constrain will throw a different error than previous&lt;br/&gt;
  constraints?  I think it is ok with standard as they all start with&lt;br/&gt;
  23xxx.&lt;/p&gt;

&lt;p&gt;  can you comment on statement vs transaction level rollback.  While thinking&lt;br/&gt;
  about this I have always assumed transaction level rollback to get the&lt;br/&gt;
  rows out of the table.  I think statement level must be when savepoints&lt;br/&gt;
  are involved.&lt;/p&gt;</comment>
                            <comment id="13827514" author="knutanders" created="Wed, 20 Nov 2013 10:21:07 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I am ok with the lock timeout deciscion, but I am concerned that I think 2 duplicate inserters to a deferrable constraint/deferred are I think guaranteed to deadlock. But I don&apos;t have a good answer to that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If the main motivation for not doing a serializable scan up front was to avoid the potential of lock timeouts, and the result is that it guarantees deadlocks, maybe we should reconsider the serializable scan? The range lock obtained by the serializable scan will make competing transactions block earlier, and at least avoid deadlock in the simple case of two transactions doing a single-row insert of the same key at the same time.&lt;/p&gt;</comment>
                            <comment id="13827992" author="dagw" created="Wed, 20 Nov 2013 19:08:16 +0000"  >&lt;p&gt;Thanks for the comments, Mike. Please see my replies inlined..&lt;/p&gt;

&lt;p&gt;&amp;gt; Index: java/engine/org/apache/derby/catalog/IndexDescriptor.java&lt;br/&gt;
&amp;gt; nit: maybe would be good to add comments here describing that unique&lt;br/&gt;
&amp;gt; deferrable indexes are implemented using store non-uniqe indexes, and&lt;br/&gt;
&amp;gt; that sql layer owns enforcing uniqueness.&lt;/p&gt;

&lt;p&gt;Done, cf. attachment IndexDescriptor.html and IndexDescriptorImpl.html&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Index: java/engine/org/apache/derby/catalog/types/IndexDescriptorImpl.java&lt;br/&gt;
&amp;gt; nit: same comment as about about more detail about deferrable indexes.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; some document table describing the use of the following associating it with&lt;br/&gt;
&amp;gt; deferred and non-deffered and different contraint types might help to make&lt;br/&gt;
&amp;gt; it clearer:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; boolean isUnique,&lt;br/&gt;
&amp;gt; boolean isUniqueWithDuplicateNulls,&lt;br/&gt;
&amp;gt; boolean isUniqueDeferrable,&lt;br/&gt;
&amp;gt; boolean hasDeferrableChecking,&lt;/p&gt;

&lt;p&gt;See above.&lt;/p&gt;

&lt;p&gt;&amp;gt; java/engine/org/apache/derby/iapi/sql/dictionary/IndexRowGenerator.java&lt;br/&gt;
&amp;gt; nit: same comment about expanding on what isUniqueDeferrable means&lt;br/&gt;
  for the index&lt;/p&gt;

&lt;p&gt;Fixed, see attached IndexRowGenerator.html.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; java/engine/org/apache/derby/iapi/store/access/SortObserver.java&lt;br/&gt;
&amp;gt; would be nice for the 3 new interfaces to have javadoc comments for each,&lt;br/&gt;
&amp;gt; explaing their use in more detail.&lt;/p&gt;

&lt;p&gt;Added, see SortObserver.html&lt;/p&gt;

&lt;p&gt;&amp;gt; Index: java/engine/org/apache/derby/impl/sql/execute/AlterConstraintConstantActi&lt;br/&gt;
&amp;gt; on.java&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; o would be good to have tests that alter back and forth from deferred and&lt;br/&gt;
&amp;gt; not deffered and make sure subsequent actions do the right thing. Could&lt;br/&gt;
&amp;gt; looks like existing mechanism should work, but seems a good code path to&lt;br/&gt;
&amp;gt; test.&lt;/p&gt;

&lt;p&gt;I have one test already and added more in ConstraintCharactericsTest#testBasicDeferral on these lines and below&lt;/p&gt;

&lt;p&gt;// Try to set immediate mode, and detect violation&lt;br/&gt;
assertStatementError(&quot;23507&quot;, s, sCF + &quot; immediate&quot;);&lt;br/&gt;
// Once more, error above should not roll back&lt;br/&gt;
assertStatementError(&quot;23507&quot;, s, sCF + &quot; immediate&quot;);&lt;/p&gt;


&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Index: java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java&lt;br/&gt;
&amp;gt; o&lt;br/&gt;
&amp;gt; some comment on why sharing is turned off for deferable constraints would&lt;br/&gt;
&amp;gt; be good. A user is going to complain at some point when they see duplicate&lt;br/&gt;
&amp;gt; indexes taking up twice space that they don&apos;t think they need.&lt;/p&gt;

&lt;p&gt;Added a comment. I guess we could introduce sharing in a follow-up patch with any non-unique indexes now that all checking happens in language.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Index: java/engine/org/apache/derby/impl/sql/execute/DeferredDuplicates.java&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; o This code throws SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T or&lt;br/&gt;
&amp;gt; SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_S. If these are not&lt;br/&gt;
&amp;gt; caught and remapped can someone comment on if this is the standard. Is it&lt;br/&gt;
&amp;gt; ok that this type of constrain will throw a different error than previous&lt;br/&gt;
&amp;gt; constraints? I think it is ok with standard as they all start with&lt;br/&gt;
&amp;gt; 23xxx.&lt;/p&gt;

&lt;p&gt;These are indeed thrown. As far as I can understand, the prefix 23 is correct.&lt;/p&gt;

&lt;p&gt;&amp;gt; can you comment on statement vs transaction level rollback. While thinking&lt;br/&gt;
&amp;gt; about this I have always assumed transaction level rollback to get the&lt;br/&gt;
&amp;gt; rows out of the table. I think statement level must be when savepoints&lt;br/&gt;
&amp;gt; are involved.&lt;/p&gt;

&lt;p&gt;The _S variant doesn&apos;t roll back - the transaction is still active and if the offending rows aren&apos;t deleted, the commit will throw the _T variant and roll back. This is tested in ConstraintCharactericsTest#testBasicDeferral.&lt;/p&gt;
</comment>
                            <comment id="13828144" author="dagw" created="Wed, 20 Nov 2013 21:26:32 +0000"  >&lt;p&gt;Attaching derby-532-post-scan-3, which fixes two bugs: 1. InsertResultSet didn&apos;t test on effective deferred status, just initiallyDeferred. Renamed the variables there and in the sort observers accordingly. 2. Changed the order in which status DEFERRED ALL and the map of individual constraint modes gets propagated to child SQL session contexts (in casu IMPORT_TABLE), so that individual modes doesn&apos;t get clobbered when we inherit the ALL state. This bug was exposed when we started checking on effective deferred status in InsertResultSet. Updated the test to include this case.&lt;br/&gt;
Rerunning regressions.&lt;/p&gt;



</comment>
                            <comment id="13831661" author="dagw" created="Mon, 25 Nov 2013 17:46:13 +0000"  >&lt;p&gt;Attaching derby-532-post-scan-4, which makes some minor improvements to the tests.&lt;/p&gt;</comment>
                            <comment id="13831670" author="dagw" created="Mon, 25 Nov 2013 17:57:22 +0000"  >&lt;p&gt;Uploading a new version of the functional specification; 1.6. Minor changes only.&lt;/p&gt;</comment>
                            <comment id="13831878" author="jira-bot" created="Mon, 25 Nov 2013 20:30:47 +0000"  >&lt;p&gt;Commit 1545394 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1545394&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1545394&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-post-scan-4 implements basic support for deferred&lt;br/&gt;
constraints for PRIMARY KEY and UNIQUE constraints. Deferrable&lt;br/&gt;
constraints are not enabled by default yet; one needs to set a&lt;br/&gt;
property to try the feature: &quot;derby.constraintsTesting&quot;.&lt;/p&gt;

&lt;p&gt;This patch enables deferred constraints for:&lt;/p&gt;

&lt;p&gt;    a) primary key constraints&lt;br/&gt;
    b) unique constraint with not nullable columns&lt;br/&gt;
    c) unique constraint with nullable columns&lt;/p&gt;

&lt;p&gt;by new logic in insertion and sorts.&lt;/p&gt;

&lt;p&gt;The patch includes relaxing the constraint at insertion and update&lt;br/&gt;
time, as well as adding a constraint to an existing table. &lt;/p&gt;

&lt;p&gt;Derby treats constraints a) and b) the same, and in the code these are&lt;br/&gt;
marked as &quot;unique&quot; when they are not deferrable (as in existing code).&lt;/p&gt;

&lt;p&gt;Constraint type c) is currently marked as&lt;br/&gt;
&quot;uniqueWithDuplicateNulls&quot;. Insert/update of these is implemented in&lt;br/&gt;
the BTree by including the RowLocation of the base row in the set of&lt;br/&gt;
keys in the index row (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3330&quot; title=&quot;provide support for unique constraint over keys that include one or more nullable columns.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3330&quot;&gt;&lt;del&gt;DERBY-3330&lt;/del&gt;&lt;/a&gt;). This makes them trivially unique,&lt;br/&gt;
but there is an extra code path in BTreeController that checks&lt;br/&gt;
neighbor rows for duplicates, and only allows insertion if the key&lt;br/&gt;
contains a null. When adding a constraint to an existing table, these&lt;br/&gt;
are handled by a specially crafted sorter&lt;br/&gt;
(UniqueWithDuplicateNullsMergeSort).&lt;/p&gt;

&lt;p&gt;The implementation of insert/update of deferrable indexes is based on&lt;br/&gt;
a similar approach, i.e. by backing with a non-unique index, and checking &lt;br/&gt;
duplicates in the language layer, notably IndexChanger.&lt;/p&gt;

&lt;p&gt;In IndexChanger, after inserting a row, we check if it is unique by&lt;br/&gt;
performing a scan of the BTree. A time-out here leads to a pessimistic&lt;br/&gt;
assumption that there is a duplicate. Duplicate key values are saved&lt;br/&gt;
until checking time (usually commit time), when a new scan is&lt;br/&gt;
performed to validate the uniqueness property.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;This means a) and b) if deferrable are no longer marked &amp;quot;unique&amp;quot;&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;Deferrable indexes are not shared.&lt;/p&gt;

&lt;p&gt;If there are duplicates and we have deferred constraint mode (a&lt;br/&gt;
dynamic session property), we save the duplicate index row in a disk&lt;br/&gt;
based hash table (DeferredDuplicates#rememberDuplicate).&lt;/p&gt;

&lt;p&gt;For a) and b), constraints which are deferrable are marked as&lt;br/&gt;
&quot;uniqueDeferrable&quot; and &quot;hasDeferrableChecking&quot;. Constraints of type c)&lt;br/&gt;
which are deferrable are marked &quot;uniqueWithDuplicateNulls&quot; and&lt;br/&gt;
&quot;hasDeferrableChecking&quot;. These marks determines the code paths&lt;br/&gt;
used. Note that existing indexes and non-deferrable constraint do not&lt;br/&gt;
get a new code path, which should preserve correctness and performance&lt;br/&gt;
of those.&lt;/p&gt;

&lt;p&gt;Now, with these markers in place, deferral of checks happens in three&lt;br/&gt;
places:&lt;/p&gt;

&lt;p&gt;    {{ IndexChanger#insertAndCheckDups}}&lt;/p&gt;

&lt;p&gt;    {{CreateIndexConstantAction#executeConstantAction +&lt;br/&gt;
     MergeSort#compare and UniqueWithDuplicateNullsMergeSort#compare }}&lt;/p&gt;

&lt;p&gt;    &lt;tt&gt;InsertResultSet#setUpAllSorts&lt;/tt&gt;&lt;/p&gt;


&lt;p&gt;The former is active for deferral under INSERT and UPDATE. The middle&lt;br/&gt;
when adding a deferrable constraint to an existing table, when we sort&lt;br/&gt;
existing rows detecting any duplicates. The last is used when importing&lt;br/&gt;
rows.&lt;/p&gt;

&lt;p&gt;At transaction commit (1), or when the constraint mode for a deferred&lt;br/&gt;
constraint is changed back to immediate (2), we validate the&lt;br/&gt;
constraint (DeferredDuplicates#validate) by replaying the hash table&lt;br/&gt;
and scanning the index for the duplicate index rows to ascertain there&lt;br/&gt;
are none, or else we have an error: transaction or statement severity&lt;br/&gt;
respectively for (1) and (2).&lt;/p&gt;

&lt;p&gt;The constraint mode is a SQL session level variable, and inside&lt;br/&gt;
routines (nested connections), we push this on the stack. This means&lt;br/&gt;
change of the constraint mode inside nested connections will be popped&lt;br/&gt;
on routine exit. If, as part of this, a constraint changes from&lt;br/&gt;
deferred to immediate mode, we also validate it for correctness. If&lt;br/&gt;
this fail, the transaction rolls back&lt;br/&gt;
We needed to do this from a newly introduced method,&lt;br/&gt;
GenericLanguageConnectionContext#popNestedSessionContext. This&lt;br/&gt;
pops the SQL session context.&lt;br/&gt;
That hook is called from GenericPreparedStatement#executeStmt. As a&lt;br/&gt;
part of this effort, we also renamed #setupNestedSessionContext to&lt;br/&gt;
#pushNestedSessionContext.&lt;/p&gt;

&lt;p&gt;The patch also adds support for checking deferred constraints in&lt;br/&gt;
xa_prepare and xa_commit (.., true), cf. specification attached to the&lt;br/&gt;
JIRA issue.&lt;/p&gt;

&lt;p&gt;Concurrency: if a transaction gets a lock time-out when trying to&lt;br/&gt;
establish if a row just inserted is a duplicate (another transaction&lt;br/&gt;
may have just inserted a row with a similar index key), we use a&lt;br/&gt;
pessimistics assumption and add that key to the set of keys to be&lt;br/&gt;
checked at commit time. If a key can&apos;t be grabbed then, a time-out is&lt;br/&gt;
thrown. We plan to add an optimized scan to avoid waiting for the lock&lt;br/&gt;
at insertion time, cf &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &quot;not enforced&quot; feature is not yet implemented in this patch.&lt;/p&gt;

&lt;p&gt;Several new test cases been added to ConstraintCharacteristicsTest to&lt;br/&gt;
test these basic behaviors.&lt;/p&gt;</comment>
                            <comment id="13831881" author="dagw" created="Mon, 25 Nov 2013 20:31:39 +0000"  >&lt;p&gt;Committed derby-532-post-scan-4 as svn version 1545394.&lt;/p&gt;</comment>
                            <comment id="13832749" author="dagw" created="Tue, 26 Nov 2013 16:43:19 +0000"  >&lt;p&gt;Running an experiment setting all unique and pk constraints as deferrable &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; (but not deferred) for the existing regression tests to validate any differences in behavior.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; by instrumenting the code with the patch derby-532-test-with-default-deferrable-all-over.diff&lt;/p&gt;


</comment>
                            <comment id="13834914" author="dagw" created="Thu, 28 Nov 2013 15:15:18 +0000"  >&lt;p&gt;Here is one fallout of running the regressions with default constraint mode deferrable.&lt;/p&gt;

&lt;p&gt;Uploading a patch (&quot;derby-532-fix-metadata-1&quot;) that fixes broken database metadata for deferred constraint indexes: the metadata query used the method IndexDescriptor#isUnique to determine logical uniqueness, but it really represents physical uniqueness now. For deferred unique constraints, the method that should be used is &quot;isUniqueDeferrable&quot;. Added a test, and also added client/server run of the regression test for deferred constraints. &lt;/p&gt;

&lt;p&gt;Before the fix, the added test fixture &quot;testDatabaseMetaData&quot; failed in that the index in question was identified as non unique, but it is logically unique.&lt;/p&gt;

&lt;p&gt;When changing the code for the database metadata query, I discovered &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6423&quot; title=&quot;The expression syntax in CASE&amp;#39;s THEN clause doesn&amp;#39;t accept boolean value expression&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6423&quot;&gt;&lt;del&gt;DERBY-6423&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13835590" author="dagw" created="Sat, 30 Nov 2013 01:46:05 +0000"  >&lt;p&gt;Here are the rest of the failures and errors I saw running the JUnit tests with default deferrable (the experiment mentioned above). I&apos;ll be analyzing them to see if they are to be expected or not. &lt;/p&gt;

&lt;p&gt;(Note: this run included the proposed patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt; as well)&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Update 2013-12-09 Analysis added for all issues&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LangProcedureTest (lock difference)
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  =&amp;gt; To be expected: we are running with serializable isolation mode&lt;br/&gt;
  and the index used is no longer physically unique, so the&lt;br/&gt;
  query reads the previous key also. Locks expected in the non deferred case:&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  XID,TYPE,MODE,TABLENAME,LOCKNAME,STATE,TABLETYPE,LOCKCOUNT,INDEXNAME
  --- ---- ---- --------- -------- ----- --------- --------- ---------
  {345,TABLE,IS,T1,Tablelock,GRANT,T,2,null}
  {345,ROW,S,T1,(1,8),GRANT,T,1,null}
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  what we see in the deferrable case is:&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  XID,TYPE,MODE,TABLENAME,LOCKNAME,STATE,TABLETYPE,LOCKCOUNT,INDEXNAME
  --- ---- ---- --------- -------- ----- --------- --------- ---------
  {503,TABLE,IS,T1,Tablelock,GRANT,T,2,null}
  {503,ROW,S,T1,(1,7),GRANT,T,1,null}
  {503,ROW,S,T1,(1,8),GRANT,T,1,null}
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;LangScripts update (lock difference)
 &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt; =&amp;gt; To be expected. We have this table:&lt;/p&gt;
 &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   create table tab1 (c1 int not null primary key, c2 int)
   insert into tab1 values (1, 8)
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; and then we do:&lt;/p&gt;
 &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   update tab1 set c2 = c2 + 3 where c1 = 1;
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; Read committed, deferrable&lt;/p&gt;
 &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  XID,TYPE,MODE,TABLENAME,LOCKNAME,STATE,TABLETYPE,LOCKCOUNT,INDEXNAME
  --- ---- ---- --------- -------- ----- --------- --------- ---------
  {184,TABLE,IX,TAB1,Tablelock,GRANT,T,2,null}
  {184,ROW,X,TAB1,(1,7),GRANT,T,3,null}
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; Serializable , deferrable&lt;/p&gt;
 &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  XID,TYPE,MODE,TABLENAME,LOCKNAME,STATE,TABLETYPE,LOCKCOUNT,INDEXNAME
  --- ---- ---- --------- -------- ----- --------- --------- ---------
 {186,TABLE,IX,TAB1,Tablelock,GRANT,T,2,null}
 {186,ROW,X,TAB1,(1,3),GRANT,T,1,null}
 {186,ROW,X,TAB1,(1,7),GRANT,T,3,null}
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; i.e. we also have a lock on the first (control) row (before row&lt;br/&gt;
 containing 1).  In the non-deferrable case, again we have a unique&lt;br/&gt;
 physical index on c1, so a previous lock is not required. Note, for&lt;br/&gt;
 read committed there is no difference.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;LojReorderTest (different execution plan)
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  =&amp;gt; To be expected. The original plan looked like this:&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;	     
     &quot;Sort ResultSet:&quot;,
     &quot;Source result set:&quot;,
     &quot;_Hash Left Outer Join ResultSet:&quot;,
     &quot;_Left result set:&quot;,
     &quot;__Nested Loop Left Outer Join ResultSet:&quot;,
     &quot;__Left result set:&quot;,
     &quot;___Nested Loop Left Outer Join ResultSet:&quot;,
     &quot;___Left result set:&quot;,
     &quot;____Index Scan ResultSet for A&quot;,
     &quot;___Right result set:&quot;,
     &quot;____Index Scan ResultSet for B&quot;,
     &quot;__Right result set:&quot;,
     &quot;___Index Scan ResultSet for C&quot;,
     &quot;_Right result set:&quot;,
     &quot;__Hash Scan ResultSet for D&quot;});
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  With deferrable constraints it looks like this:&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    &quot;Sort ResultSet:&quot;,
    &quot;Source result set:&quot;,
    &quot;_Hash Left Outer Join ResultSet:&quot;,
    &quot;_Left result set:&quot;,
    &quot;__Nested Loop Left Outer Join ResultSet:&quot;,
    &quot;__Left result set:&quot;,
    &quot;___Hash Left Outer Join ResultSet:&quot;,
    &quot;___Left result set:&quot;,
    &quot;____Index Scan ResultSet for A&quot;,
    &quot;___Right result set:&quot;,
    &quot;____Hash Scan ResultSet for B&quot;,
    &quot;__Right result set:&quot;,
    &quot;___Index Scan ResultSet for C&quot;,
    &quot;_Right result set:&quot;,
    &quot;__Hash Scan ResultSet for D&quot;});
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  As we can see, the deferrable the inner (leftmost) LOJ uses as Hash&lt;br/&gt;
  left order join with and index scan for A and a hash scan for B,&lt;br/&gt;
  whereas the non deferrable case uses nested loop over two index&lt;br/&gt;
  scans for A and B, presumably because the physical uniqeness of the&lt;br/&gt;
  index on B gives the optimizer another cardinality estimate. In any&lt;br/&gt;
  case both plans are good.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;InListMultiProbeTest (assertTrue(rtsp.usedIndexScan()))
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  Test case testDerby6045WithoutUpdateStatistics fails.&lt;br/&gt;
  In this case, Derby picks a table scan instead of an index scan for multi&lt;br/&gt;
  probe result set.  I see using Rick&apos;s tools to trace the optimizer that the&lt;br/&gt;
  selectivity for the start stop predicate on TERM_ID is increased from 0.1 in&lt;br/&gt;
  the no deferrable case to 1.0 in the deferrable case.&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  s.executeQuery(&quot;SELECT  *  FROM  &quot; + whiteSpace + 
                    DERBY_6045_DATA_TABLE + 
                    &quot; WHERE (TERM_ID = 11) OR &quot; +
                    &quot;(TERM_ID =21) OR (TERM_ID = 31)&quot;);
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Presumably this makes the optimizer discard the index scan in favor of a table scan, cf. this quote from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  So in the context of row counts, if the number of IN-list predicates
  multiplied by the estimated row count (after stat selectivity is applied)
  yields a high precentage row count (ex. all rows in the table) then the odds
  of the optimizer choosing to use that particular index are lower. It may
  still choose to use the index, in which case multi-probing will take effect,
  but it probably will not (it all depends).
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Perhaps this could be improved upon (should?). For a &quot;normal&quot; non unique index this may be&lt;br/&gt;
  the right choice but it does seem a bit pessimistic for the deferrable case.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;CollationTest2 (java.sql.SQLIntegrityConstraintViolationException:&lt;br/&gt;
  The statement was aborted because it would have caused a duplicate&lt;br/&gt;
  key value in a unique or primary key constraint or unique index&lt;br/&gt;
  identified by &apos;SQL131129120107383&apos; defined on &apos;DERBY_5367&apos;.)
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  Not an issue with last patch.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;ConglomerateSharingTest (number of physical conglomerates that exist&lt;br/&gt;
  for the received table: Expected: &amp;gt;3&amp;lt; Found: &amp;gt;4&amp;lt;
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  We have the following scenario:&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;        create table dropc_t2 (a int, b int not null, c int not null)
        create index dropc_ix1 on dropc_t2 (a,b)
        create unique index dropc_uix2 on dropc_t2 (c)
        alter table dropc_t2 add constraint dropc_uc1 unique (c)
        alter table dropc_t2 add constraint dropc_fk0 
            foreign key (a,b) references dropc_t0
        alter table dropc_t2 add constraint dropc_fk1 
            foreign key (a,b) references dropc_t0
        alter table dropc_t2 add constraint &quot;dropc_fk2 
            foreign key (c) references dropc_t1

        /* Should have 3 conglomerates on DROPC_T2:
         *
         *  1. Heap
         *  2. DROPC_IX1 (shared by: DROPC_FK0, DROPC_FK1)
         *  3. DROPC_UIX2 (shared by: DROPC_UC1, DROPC_FK2)
         */
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Here the unique constraint DROPC_UC1 is deferrable by default, so it doesn&apos;t&lt;br/&gt;
  share the unique index DROPC_UIX2. This is as designed.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;NullableUniqueConstraintTest (junit.framework.ComparisonFailure:&lt;br/&gt;
  Unexpected SQL state. expected:&amp;lt;&lt;span class=&quot;error&quot;&gt;&amp;#91;23505&amp;#93;&lt;/span&gt;&amp;gt; but was:&amp;lt;&lt;span class=&quot;error&quot;&gt;&amp;#91;XJ001&amp;#93;&lt;/span&gt;&amp;gt;)&lt;br/&gt;
  if (SanityManager.DEBUG) 
{ // deferrable: we use a non-unique index
     SanityManager.ASSERT(
       insertStatus != ConglomerateController.ROWISDUPLICATE); &amp;lt;=====!!
  }
&lt;p&gt;  ++ more&lt;/p&gt;
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  To be expected.  This fails in the test case testMixedInsertDelete&lt;br/&gt;
  which mentions an earlier problem with this fixture:&lt;br/&gt;
  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4097&quot; title=&quot;&amp;#39;testMixedInsertDelete(org.apache.derbyTesting.functionTests.tests.lang.NullableUniqueConstraintTest)org.apache.derby.client.am.BatchUpdateException&amp;#39;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4097&quot;&gt;&lt;del&gt;DERBY-4097&lt;/del&gt;&lt;/a&gt;. Since we are now running a BTree scan to check for the&lt;br/&gt;
  duplicate instead of the check on the left sibling as done for&lt;br/&gt;
  unique not null in the non deferrable case, we don&apos;t get to retry if&lt;br/&gt;
  we can&apos;t lock the row. We lose here because we timeout trying to get&lt;br/&gt;
  a lock for the same reason as described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4097&quot; title=&quot;&amp;#39;testMixedInsertDelete(org.apache.derbyTesting.functionTests.tests.lang.NullableUniqueConstraintTest)org.apache.derby.client.am.BatchUpdateException&amp;#39;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4097&quot;&gt;&lt;del&gt;DERBY-4097&lt;/del&gt;&lt;/a&gt;; a conflict&lt;br/&gt;
  with the post commit work done by another thread. It happens in&lt;br/&gt;
  iteration four. As discussed in the thread, the issue can be avoided&lt;br/&gt;
  by turning off autocommit. Another thing is that in this case, it&lt;br/&gt;
  would be better to report the time-out rather report it as a&lt;br/&gt;
  duplicate I think: since we are running with immediate checking. &lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;UniqueConstraintSetNullTest&lt;br/&gt;
  (java.sql.SQLIntegrityConstraintViolationException: The statement&lt;br/&gt;
  was aborted because it would have caused a duplicate key value in a&lt;br/&gt;
  unique or primary key constraint or unique index identified by&lt;br/&gt;
  &apos;U_CON&apos; defined on &apos;CONSTRAINTEST&apos;.)&lt;br/&gt;
  ++ more
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  This exposed a bug: a broken predicate when recreating the index&lt;br/&gt;
  when going from UNQIUE NOT NULL to plain UNIQUE: the existing test&lt;br/&gt;
  missed the deferrable case, so the index was not recreated.&lt;br/&gt;
  Fixed in attached patch derby-532-fix-drop-not-nullable, which also&lt;br/&gt;
  adds a test case for this.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;UniqueConstraintMultiThreadedTest&lt;br/&gt;
  (junit.framework.AssertionFailedError: isolation levels: 1 1)
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  This exposed a bug with the introduction of the no-wait scan, cf.&lt;br/&gt;
  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt;: we should only return immediately from the checking scan&lt;br/&gt;
  if we hit a timeout or deadlock iff the constraint mode is deferred.&lt;br/&gt;
  For immediate deferrable constraints, the check should wait obey the&lt;br/&gt;
  usual timeout values. This is fixed with a follow-up patch&lt;br/&gt;
  to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;XplainStatisticsTest (	 expected rows:&lt;br/&gt;
		[&lt;span class=&quot;error&quot;&gt;&amp;#91;COUNTRIES_UNQ_NM, C, BTREE, RC, 1, 1, 1, SH, R, 2, ALL&amp;#93;&lt;/span&gt;]&lt;br/&gt;
	 actual result: &lt;br/&gt;
		[&lt;span class=&quot;error&quot;&gt;&amp;#91;COUNTRIES_UNQ_NM, C, BTREE, RC, 2, 1, 1, IS, R, 2, ALL&amp;#93;&lt;/span&gt;])
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  The difference here as far as I can see consists of two items:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;two rows are read from via the index instead of one (ok I think)&lt;/li&gt;
	&lt;li&gt;the lock mode is &quot;instantaneous&quot;; in the non-deferrable case I see&lt;br/&gt;
    the following in the execution plan:
    &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    Index Scan ResultSet for COUNTRIES using constraint COUNTRIES_UNQ_NM at
    read committed isolation level using share row locking chosen by the optimizer
    &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;    whereas in the deferrable case I see:&lt;/p&gt;
    &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    Index Scan ResultSet for COUNTRIES using constraint COUNTRIES_UNQ_NM at 
    read committed isolation level using instantaneous share row locking chosen by the optimizer
    &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;    I presume this is because we are now using a non-unique scan, but&lt;br/&gt;
    I am not 100% sure. As for now I&apos;ll treat this as an &quot;expected difference&quot;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;dml019(org.apache.derbyTesting.functionTests.tests.nist.NistScripts)&lt;br/&gt;
  failed: junit.framework.ComparisonFailure: Output at line 85 &lt;br/&gt;
  expected:&amp;lt;E1 |P&lt;span class=&quot;error&quot;&gt;&amp;#91;1 |4&amp;#93;&lt;/span&gt;0 &amp;gt; but was:&amp;lt;E1 |P&lt;span class=&quot;error&quot;&gt;&amp;#91;2 |2&amp;#93;&lt;/span&gt;0 &amp;gt;
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  To be expected: the following statement gave the correct rows, but the ordering in the result set was different from the master due to a different execution plan.&lt;/p&gt;
  &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;   SELECT PNUM,EMPNUM                      
          FROM WORKS                              
          GROUP BY EMPNUM,PNUM,HOURS;
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;UpdateStatisticsTest (junit.framework.AssertionFailedError: failed&lt;br/&gt;
  to get statistics for table TEST_TAB_1 (#expected=0, timeout=0)&lt;br/&gt;
  Index statistics for TEST_TAB_1 1:&lt;br/&gt;
  
{tableId=2f2b17ef-0142-a377-c079-0000766f8c2f, tableName=TEST_TAB_1,
  indexName=SQL131129120747740, lcols=1, rows=2, unique/card=2,
  created=2013-11-29 12:07:47.742}
&lt;p&gt; expected:&amp;lt;0&amp;gt; but was:&amp;lt;1&amp;gt;)&lt;/p&gt;
  &lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;  To be expected: There were four errors here, and all were instances of the same issue: we found statistics where none were expected due to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3790&quot; title=&quot;Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3790&quot;&gt;&lt;del&gt;DERBY-3790&lt;/del&gt;&lt;/a&gt; &quot; Investigate if request for update statistics can be skipped for certain kind of indexes, one instance may be unique indexes based on one column.&quot;. Since primary key indexes are not physically unique with deferrable indexes, the skipping of the statistics generation did not happen.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13838258" author="dagw" created="Tue, 3 Dec 2013 22:24:09 +0000"  >&lt;p&gt;Uploading two patches to fix fallout from the regressions run with default deferrable constraints: derby-532-nullableUniqueFix and derby-532-fix-drop-not-nullable. New test cases were added. Rerunning regressions.&lt;/p&gt;</comment>
                            <comment id="13844751" author="dagw" created="Tue, 10 Dec 2013 22:26:37 +0000"  >&lt;p&gt;Regressions ran ok with the two latest patches.&lt;/p&gt;</comment>
                            <comment id="13844755" author="dagw" created="Tue, 10 Dec 2013 22:29:19 +0000"  >&lt;p&gt;Uploading derby-532-test-speedup. Quote from my sandbox commit:&lt;/p&gt;

&lt;p&gt;Patch derby-532-test-speedup changes ConstraintCharacteristicsTest to&lt;br/&gt;
use a main memory database for some tests for increased speed. It also&lt;br/&gt;
changes the way SystemPropertyTestSetup for static properties closes&lt;br/&gt;
down the database to not deregister the driver; without this change we&lt;br/&gt;
saw a test setup try to connect via the client driver to a Derby server&lt;br/&gt;
engine without a registered driver.&lt;/p&gt;

&lt;p&gt;Regressions ran OK with this patch.&lt;/p&gt;</comment>
                            <comment id="13845330" author="jira-bot" created="Wed, 11 Dec 2013 11:47:33 +0000"  >&lt;p&gt;Commit 1550113 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1550113&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1550113&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;A patch (&quot;derby-532-fix-metadata-1&quot;) that fixes broken database&lt;br/&gt;
metadata for deferred constraint indexes: the metadata query used the&lt;br/&gt;
method IndexDescriptor#isUnique to determine logical uniqueness, but&lt;br/&gt;
it really represents physical uniqueness now. For deferred unique&lt;br/&gt;
constraints, the method that should be used is&lt;br/&gt;
&quot;isUniqueDeferrable&quot;. Added a test, and also added client/server run&lt;br/&gt;
of the regression test for deferred constraints.&lt;/p&gt;

&lt;p&gt;Before the fix, the added test fixture &quot;testDatabaseMetaData&quot; failed&lt;br/&gt;
in that the index in question was identified as non unique, but it is&lt;br/&gt;
logically unique and so should be reported as such.&lt;/p&gt;</comment>
                            <comment id="13845435" author="jira-bot" created="Wed, 11 Dec 2013 14:34:33 +0000"  >&lt;p&gt;Commit 1550152 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1550152&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1550152&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-nullableUniqueFix. When we changed the implementation from&lt;br/&gt;
special treatment of deferrable constraints in the BTree, a couple of extra&lt;br/&gt;
predicates needed to be added were omitted - added those here: we should not&lt;br/&gt;
mark the physical index with &quot;uniqueWithDuplicateNulls&quot; if it is deferrable.&lt;br/&gt;
This error was found when running the regressions with default deferrable for&lt;br/&gt;
all pk and unique constraints.&lt;/p&gt;

&lt;p&gt;We also removed an unused flag &quot;hasDeferrableChecking&quot; in the same places (it is&lt;br/&gt;
not longer used by the physical index).&lt;/p&gt;

&lt;p&gt;Added a new test case, testCompressTable, which tests the&lt;br/&gt;
&quot;uniqueWithDuplicateNulls&quot; case.&lt;/p&gt;

&lt;p&gt;We also change the behavior in the following way for deferrable, but not&lt;br/&gt;
deferred constraints: if we hit a time-out or dead-lock when checking uniqueness&lt;br/&gt;
(in the BTree scan), we throw that time-out or dead-lock. Up till now we&lt;br/&gt;
converted it to a duplicate exception. We will only assume it can be a duplicate&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for later checking - iff the constraint mode is deferrable.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13845768" author="jira-bot" created="Wed, 11 Dec 2013 22:07:17 +0000"  >&lt;p&gt;Commit 1550284 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1550284&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1550284&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-fix-drop-not-nullable. Fixes a broken predicate when&lt;br/&gt;
recreating the index when going from UNIQUE NOT NULL to plain UNIQUE:&lt;br/&gt;
the existing predicate missed the deferrable case, so the index was not&lt;br/&gt;
recreated.&lt;/p&gt;

&lt;p&gt;Added a test case.&lt;/p&gt;</comment>
                            <comment id="13845796" author="jira-bot" created="Wed, 11 Dec 2013 22:36:49 +0000"  >&lt;p&gt;Commit 1550299 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1550299&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1550299&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6419&quot; title=&quot;Make BTree scan honor  OPENMODE_LOCK_NOWAIT for row locks.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6419&quot;&gt;&lt;del&gt;DERBY-6419&lt;/del&gt;&lt;/a&gt; Make BTree scan honor OPENMODE_LOCK_NOWAIT for row locks&lt;/p&gt;

&lt;p&gt;A follow-up patch: derby-6419-followup.&lt;/p&gt;

&lt;p&gt;Only short circuit waiting for lock in BTree scan to check duplicates&lt;br/&gt;
for a deferred unique/pk constraint if constraint mode is deferred&lt;br/&gt;
(i.e. not if immediate).&lt;/p&gt;

&lt;p&gt;Added a test case lifted from UniqueConstraintMultiThreadedTest, which&lt;br/&gt;
exposed the issue when we run the regressions with default deferrable&lt;br/&gt;
by default (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="13845815" author="jira-bot" created="Wed, 11 Dec 2013 23:10:06 +0000"  >&lt;p&gt;Commit 1550308 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1550308&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1550308&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-test-speedup changes ConstraintCharacteristicsTest to&lt;br/&gt;
use a main memory database for some tests for increased speed. It also&lt;br/&gt;
changes the way SystemPropertyTestSetup for static properties closes&lt;br/&gt;
down the database to not deregister the driver; without this change we&lt;br/&gt;
saw a test setup try to connect via the client driver to a Derby server&lt;br/&gt;
engine without a registered driver.&lt;/p&gt;</comment>
                            <comment id="13848094" author="dagw" created="Sat, 14 Dec 2013 00:20:45 +0000"  >&lt;p&gt;Uploading patch &lt;b&gt;derby-532-allow-pk-unique-1&lt;/b&gt;, which opens up for using deferrable constraints for primary key and unique constraints, i.e. it is no longer required that the special property &lt;em&gt;&quot;derby.constraintsTesting&quot;&lt;/em&gt; be used for those constraints, since the implementation is complete modulo bugs. Upgrade tests still remain to be built, though.&lt;/p&gt;

&lt;p&gt;For foreign key and check constraints as well as for &lt;em&gt;&quot;not enforced&quot;&lt;/em&gt;, the property will still required till the implementation for those is completed.&lt;/p&gt;</comment>
                            <comment id="13861164" author="jira-bot" created="Fri, 3 Jan 2014 03:38:22 +0000"  >&lt;p&gt;Commit 1555006 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1555006&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1555006&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-allow-pk-unique-1, which opens up for using deferrable&lt;br/&gt;
constraints for primary key and unique constraints, i.e. it is no&lt;br/&gt;
longer required that the special property &quot;derby.constraintsTesting&quot;&lt;br/&gt;
be used for those constraints, since the implementation is complete&lt;br/&gt;
modulo bugs. Upgrade tests still remain to be built, though.&lt;/p&gt;

&lt;p&gt;For foreign key and check constraints as well as for &quot;not enforced&quot;,&lt;br/&gt;
the property will still required till the implementation for those is&lt;br/&gt;
completed.&lt;/p&gt;</comment>
                            <comment id="13861795" author="dagw" created="Fri, 3 Jan 2014 19:09:11 +0000"  >&lt;p&gt;Uploading a patch with upgrade tests: &lt;em&gt;derby-532-upgrade-1&lt;/em&gt;. It checks that deferrable constraints cannot be used unless hard upgrade has happened. &lt;/p&gt;</comment>
                            <comment id="13862934" author="dagw" created="Mon, 6 Jan 2014 11:57:15 +0000"  >&lt;p&gt;Uploading &lt;em&gt;&lt;b&gt;derby-532-upgrade-1b&lt;/b&gt;&lt;/em&gt; which slightly changes the upgrade test: we only run the test with upgrades from &amp;gt;= 10.4 since nullable unique constraint wasn&apos;t added before that release. Regressions now passed with all old version jars present.&lt;/p&gt;
</comment>
                            <comment id="13862945" author="jira-bot" created="Mon, 6 Jan 2014 12:10:22 +0000"  >&lt;p&gt;Commit 1555724 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1555724&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1555724&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch &lt;em&gt;&lt;b&gt;derby-532-upgrade-1b&lt;/b&gt;&lt;/em&gt;. It checks that deferrable constraints&lt;br/&gt;
cannot be used unless hard upgrade has happened.&lt;/p&gt;</comment>
                            <comment id="13910884" author="dagw" created="Mon, 24 Feb 2014 22:16:48 +0000"  >&lt;p&gt;Uploading a first patch &lt;font color=&quot;red&quot;&gt;derby-532-check-constraints-1&lt;/font&gt; which implements deferred check constraints and supporting tests.  Comments are welcome.&lt;/p&gt;

&lt;p&gt;The high level approach is as follows.  When a violation occurs, we note the row location in the base table of the offending row. At commit time (or when switching a constraint to immediate), we revisit those rows using the row locations if they are still valid, and validate those rows again. This is achieved by positioning to the saved row locations in combination with a specially crafted result set: &lt;font color=&quot;blue&quot;&gt;ValidateCheckConstraintResultSet&lt;/font&gt; (see &lt;font color=&quot;blue&quot;&gt;ProjectRestrictResultSet#getNextRowCore&lt;/font&gt;) which positions to the offending base row using &lt;font color=&quot;blue&quot;&gt;ValidateCheckConstraintResultSet#positionScanAtRowLocation&lt;/font&gt; before letting &lt;font color=&quot;blue&quot;&gt;ValidateCheckConstraintResultSet&lt;/font&gt; read the row. If the row locations are no longer valid, e.g. an intervening compress happened, we do a full table scan to verify the constraints instead.&lt;/p&gt;

&lt;p&gt;Adding a constraint in deferred constraint mode is currently sub-optimal, since we currently do a full table scan via an internally generated &lt;font color=&quot;blue&quot;&gt;&quot;SELECT .. WHERE NOT &amp;lt;constraints&amp;gt;&quot;&lt;/font&gt;, and we don&apos;t have a way the get at the row locations of the offending rows in this case. I might add a specially tailored result set for that purpose later.&lt;/p&gt;

&lt;p&gt;Normally, when a row is inserted or updated, we execute a generated method which combines evaluation of all check constraints on the table relevant for the inserted or updated columns. This evaluation is performed using McCarthy boolean evaluation (short-circuits as soon as result is known). This isn&apos;t optimal for deferred constraints, as we&apos;d need to assume all constraints were violated in such a case. The implementation replaces the short-circuited evaluation with a full evaluation, so we can remember exactly which constraints were violated, cf. &lt;font color=&quot;blue&quot;&gt;AndNoShortCircuitNode&lt;/font&gt; and &lt;font color=&quot;blue&quot;&gt;SQLBoolean#throwExceptionIfImmediateAndFalse&lt;/font&gt;. A violation in &lt;font color=&quot;blue&quot;&gt;throwExceptionIfImmediateAndFalse&lt;/font&gt; when we have a deferred constraint is noted (&lt;font color=&quot;blue&quot;&gt;DMLWriteResultSet#rememberConstraint&lt;/font&gt; implemented by &lt;font color=&quot;blue&quot;&gt;UpdateResultSet&lt;/font&gt; and &lt;font color=&quot;blue&quot;&gt;InsertResultSet&lt;/font&gt;) by adding the violation to a list for that row. After the insert/update is completed, the set of violations is remembered for posterity, cf. &lt;font color=&quot;blue&quot;&gt;InsertResultSet#normalInsertCode&lt;/font&gt; and &lt;font color=&quot;blue&quot;&gt;UpdateResultSet#collectAffectedRows&lt;/font&gt; by inspecting the lists (&lt;font color=&quot;blue&quot;&gt;#violatingCheckConstraints&lt;/font&gt;).&lt;/p&gt;

&lt;p&gt;Note that we currently do not note which constraints were violated &lt;b&gt;for each individual row&lt;/b&gt;, only per table in the transaction. This means that we visit potentially more rows over again when a single constraint is changed to immediate.  This could be improved further by storing the set of violated constraints along with the row location.&lt;/p&gt;

&lt;p&gt;For bulk insert and deferred (see panel 1 below) insert row processing there is special code paths, cf.  &lt;font color=&quot;blue&quot;&gt;InsertResultSet#offendingRowLocation&lt;/font&gt; which is invoked via a callback from &lt;font color=&quot;blue&quot;&gt;HeapController#load&lt;/font&gt; and another path in &lt;font color=&quot;blue&quot;&gt;InsertResultSet#normalInsertCode&lt;/font&gt; respectively.&lt;/p&gt;

&lt;p&gt;For update, the code for deferred treatment is in in one of &lt;font color=&quot;blue&quot;&gt;UpdateResultSet#collectAffectedRows&lt;/font&gt; and &lt;font color=&quot;blue&quot;&gt;UpdateResultSet#updateDeferredRows&lt;/font&gt; depending on whether there are triggers.&lt;/p&gt;

&lt;p&gt;The existing test &lt;font color=&quot;blue&quot;&gt;ConstraintCharacteristcsTest&lt;/font&gt; has been built out by adding check constraint to those fixture for which it is relevant, as well as adding new ones which are only relevant for check constraints.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt; &lt;font color=&quot;blue&quot;&gt;&lt;b&gt;1&lt;/b&gt;&lt;/font&gt; This &quot;deferred&quot; refers to Derby special handling of rows in certain situation, for example when doing an insert which uses the same table as a source result set, we need to make sure we don&apos;t get confused and see the incrementally inserted rows &quot;again&quot; as we process the original result set, essentially we do a snapshot of the source result set, hence &quot;deferred rows&quot;.  &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;All regressions passed.&lt;/p&gt;

&lt;p&gt;Detailed code comments:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/conn/SQLSessionContext.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/conn/SQLSessionContextImpl.java &lt;br/&gt;
M java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java&lt;br/&gt;
D java/engine/org/apache/derby/impl/sql/execute/DeferredDuplicates.java&lt;br/&gt;
A java/engine/org/apache/derby/impl/sql/execute/DeferredConstraintsMemory.java&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Extended and refactored slightly existing mechanism for deferred primary key/unique constraints to also cater for check constraints. Since the hash key we used for the memory of primary key and unique constraints was the conglomerate id of the indexes, and those are guaranteed to be disjoint from the conglomerate ids of the base tables having deferred constraints, we can use the same hash table to find the &quot;memory&quot; in the form of the disk based hash table (BackingStoreHashtable), cf.  LCC#getDeferredHashTables.--&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/dictionary/ConstraintDescriptor.java-&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Code to drop any deferred constraints memory in the transaction when a constraint is dropped.-&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;M java/engine/org/apache/derby/impl/store/access/heap/HeapController.java&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Call back added for bulk insert in the presence of deferrable check constraints.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/NoPutResultSet.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java &lt;br/&gt;
M java/engine/org/apache/derby/iapi/store/access/RowLocationRetRowSource.java &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Extra plumbing to be able to signal to HeapController that we need to do a callback with the inserted row location (for bulk insert)&lt;/p&gt;



&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/TargetResultSet.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extra interface method, offendingRowLocation. Only implemented with meaningful semantics for NoPutResultSetImpl which calls it for its targetResultSet, an InsertResultSet.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;More parameters to getProjectRestrictResult set to do the magic mention in the overview for that result set, pass along schema and table name to InsertResultSet so we can remember them for check violations. They are used to produced checking SQL statements. This may be a bit fragile, since a rename schema or table could make those invalid. However, there is presently no RENAME SCHEMA in Derby and the RENAME TABLE is illegal in certain cases, notably if there is a check constraint defined on it, so the solution should be OK for now. Also adds an interface method, getValidateCheckConstraintResultSet, to allow the execution run-time to build one of those, cf. code generation logic in NestedLoopStrategy#resultSetMethodName.&lt;/p&gt;



&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/RowChanger.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/RowChangerImpl.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extra parameter to insertRow to get at the row location if needed.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/store/access/BackingStoreHashtable.java&lt;br/&gt;
M java/engine/org/apache/derby/iapi/store/access/ScanController.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Javadoc fixes.&lt;/p&gt;



&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/types/BooleanDataValue.java &lt;br/&gt;
M java/engine/org/apache/derby/iapi/types/SQLBoolean.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extra method throwExceptionIfImmediateAndFalse used by deferred check constraints to make a note of all violated constraints as evaluated by the generated method. Picked up by InsertResultSet or UpdateResultSet.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;A java/engine/org/apache/derby/impl/sql/compile/AndNoShortCircuitNode.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/AndNode.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/DMLModStatementNode.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;AndNoShortCircuitNode is used to represent a non-McCarthy evaluation of the combined check constraints. See usage in DMLModStatementNode#generateCheckTree.&lt;/p&gt;



&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/DeleteNode.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extra dummy parameter added for call to super#bindConstraints (DMLModStatementNode). Only used by insert.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Pick up the DERBY_PROPERTIES value for property &quot;validateCheckConstraint = &amp;lt;conlomerateId&amp;gt;&quot; we provide to the checking query (internal syntax only) generated by DeferredConstraintsMemory#validateCheck.  The conglomerate id is used to retrieve the violating rows information set up by ProjectRestrictResultSet#openCore to drive ValidateCheckConstraintResultSet.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/InsertNode.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Boolean member variable to know if we have a deferrable check constraint; also pass only schema and table name to the result set. Passed on to the InsertConstantAction from which InsertResultSet can pick it up.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Logic to keep track of whether we are used by the special internal query to check violated check constraints.  In this case we also do not push the check predicates down to store for simpler handling.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Code to parse a long value from &quot;--DERBY-PROPERTIES&quot; property.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/SetConstraintsNode.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extra code to comply with the sane mode parse tree printing conventions.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/TestConstraintNode.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Handle different code generation for deferrable check contraints.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/UpdateNode.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Pass on more info: schema and table name + small refactoring.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M  java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Handle the new internal query to validate violated check constraints. Cf. query in DeferredConstraintsMemory#validateCheck.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/AlterConstraintConstantAction.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Open up for check constraints.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/ConstraintConstantAction.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;ATCA: Special handling of adding a deferred check constraint: need different code path to get the UUID of constraint soon enough to be able to note any constraint violations. CCA: note any violation and remember it.  We&apos;d like to remember that row locations of the offending rows here, but not done for now, so at checking time, we&apos;ll need a full table scan. This can be improved upon, see code comment.&lt;/p&gt;




&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/UpdateConstantAction.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Pass on more info to InsertConstantAction and UpdateConstantAction needed by the result sets.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Drives the checking for check constraints, and picks up the result. If we have violations and deferred constraints, we remember that. Also some refactorings to avoid local variables shadowing globals.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Drives the checking for check constraints, and picks up the result. If we have violations and deferred constraints, we remember that.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Removed unused method.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/ProjectRestrictResultSet.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Drive the special result set, ValidateCheckConstraintResultSet by positioning it correctly for each row retrieved, using the remembered row locations from violation time.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/SetConstraintsConstantAction.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Added logic for check constraints. Also added a new check that the user don&apos;t specify the same constraint twice, cf new test case for it.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/TableScanResultSet.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Make some members protected rather than private, to let the new result set ValidateCheckConstraintResultSet inherit from it.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/store/access/sort/MergeScanRowSource.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/store/access/sort/SortBufferRowSource.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/CardinalityCounter.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Boiler plate to comply with interface (not used).&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/UniqueIndexSortObserver.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/UniqueWithDuplicateNullsIndexSortObserver.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Refactoring only.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;A java/engine/org/apache/derby/impl/sql/execute/ValidateCheckConstraintResultSet.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;The new result we use to check violating rows only based on row location&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/compile/JoinStrategy.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/HashJoinStrategy.java &lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/NestedLoopJoinStrategy.java &lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;New boolean to signal that we want ValidateCheckConstraintResultSet&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/jdbc/EmbedXAResource.java&lt;br/&gt;
M java/engine/org/apache/derby/jdbc/XATransactionState.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extra logic to handle check constraints (already had it for primary key and unique).&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/iapi/error/ExceptionUtil.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Utility method to determine if an exception if a transaction deferred constraint violation. Needed by the XA code.&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/engine/org/apache/derby/loc/messages.xml&lt;br/&gt;
M java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;New error messages&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/testing/org/apache/derbyTesting/functionTests/tests/lang/ConstraintCharacteristicsTest.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;New test cases and extension of present ones to include check constraints&lt;/p&gt;


&lt;blockquote&gt;


&lt;p&gt;M java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_11.java&lt;/p&gt;

&lt;/blockquote&gt;


&lt;p&gt;Extension of present test cases to include check constraints.&lt;/p&gt;</comment>
                            <comment id="13922953" author="rhillegas" created="Thu, 6 Mar 2014 19:43:18 +0000"  >&lt;p&gt;Thanks for the derby-532-check-constraints-1.diff patch, Dag. I took a quick glance at it. A couple points:&lt;/p&gt;

&lt;p&gt;1) It would be good to add header comments to AndNoShortCircuitNode and DeferredConstraintsMemory, explaining what these classes are for.&lt;/p&gt;

&lt;p&gt;2) The header comment for ValidateCheckConstraintResultSet suggests that it is only used when a debug flag is set. Is that true?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13925765" author="dagw" created="Mon, 10 Mar 2014 14:41:04 +0000"  >&lt;p&gt;Hi Rick, &lt;br/&gt;
thanks for looking at the patch.&lt;/p&gt;

&lt;p&gt;Uploading version 2, &lt;font color=&quot;blue&quot;&gt;derby-532-check-constraints-2&lt;/font&gt;. This adds the comments you requested as well as some minor refactoring to simplify code in lcc a bit.&lt;br/&gt;
As for ValidateCheckConstraintResultSet, it is used in normal operation (not only for debugging). What was the wording that made you think so? It &lt;b&gt;is&lt;/b&gt; activated by a directive since it is only for internal use.&lt;/p&gt;</comment>
                            <comment id="13925773" author="rhillegas" created="Mon, 10 Mar 2014 14:47:00 +0000"  >&lt;p&gt;Thanks, Dag. Here&apos;s the header comment:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;+/**
+ * Special result set used when checking deferred CHECK constraints.  Activated
+ * by a special {@code --DERBY_PROPERTY validateCheckConstraint=&amp;lt;conglomId&amp;gt;}
+ * override on a SELECT query, cf DeferredConstraintsMemory#validateCheck.  It
+ * relies on having a correct row location set prior to invoking {@code
+ * getNewtRowCore}, cf. the special code path in
+ * {@code ProjectRestrictResultSet#getNextRowCore} activated by
+ * {@code #validatingCheckConstraint}.
+ *
+ */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To me that comment says that a ValidateCheckConstraintResultSet is only created when you set --DERBY_PROPERTY validateCheckConstraint=&amp;lt;conglomId&amp;gt;. Thanks.&lt;/p&gt;
</comment>
                            <comment id="13930339" author="dagw" created="Tue, 11 Mar 2014 13:58:55 +0000"  >&lt;p&gt;That&apos;s correct. That directive is what I use to make Derby use the non-standard scan when we check the violations when the constraint mode changes back to immediate. Cf. this code in DeferredConstraintsMemory#validateCheck, ca. line 476:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// If a compress has happened in &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; transaction, we can&apos;t
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// trust the rowLocations, so make a full table scan. If
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// not, we optimize by using a special result set type
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// which utilized the saved away row locations &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// offending rows, so we only visit those when checking.
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// I.e. other rows are known to be good a priori.
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!ci.isInvalidated()) {
    checkStmt.append(
        &lt;span class=&quot;code-quote&quot;&gt;&quot; --DERBY-PROPERTIES joinStrategy=nestedLoop, &quot;&lt;/span&gt; +
            &lt;span class=&quot;code-quote&quot;&gt;&quot;                    index=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, &quot;&lt;/span&gt; +
            &lt;span class=&quot;code-quote&quot;&gt;&quot;                    validateCheckConstraint=&quot;&lt;/span&gt;);
    checkStmt.append(&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;.toString(baseTableCID));
    checkStmt.append(&apos;\n&apos;);
}

checkStmt.append(&lt;span class=&quot;code-quote&quot;&gt;&quot; WHERE NOT(&quot;&lt;/span&gt;);
checkStmt.append(cd.getConstraintText());
checkStmt.append(&apos;)&apos;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is normal code path, though, not only for debugging.&lt;/p&gt;</comment>
                            <comment id="13930375" author="rhillegas" created="Tue, 11 Mar 2014 14:15:33 +0000"  >&lt;p&gt;Thanks for that explanation, Dag. Now I understand.&lt;/p&gt;</comment>
                            <comment id="13930413" author="jira-bot" created="Tue, 11 Mar 2014 14:46:17 +0000"  >&lt;p&gt;Commit 1576367 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1576367&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1576367&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-check-constraints-2 which implements deferred CHECK&lt;br/&gt;
constraints and supporting tests.&lt;/p&gt;

&lt;p&gt;The high level approach is as follows.  When a violation occurs, we note the row&lt;br/&gt;
location in the base table of the offending row. At commit time (or when&lt;br/&gt;
switching a constraint to immediate), we revisit those rows using the row&lt;br/&gt;
locations if they are still valid, and validate those rows again. This is&lt;br/&gt;
achieved by positioning to the saved row locations in combination with a&lt;br/&gt;
specially crafted result set: ValidateCheckConstraintResultSet (see&lt;br/&gt;
ProjectRestrictResultSet#getNextRowCore) which positions to the offending base&lt;br/&gt;
row using ValidateCheckConstraintResultSet#positionScanAtRowLocation before&lt;br/&gt;
letting ValidateCheckConstraintResultSet read the row. If the row locations are&lt;br/&gt;
no longer valid, e.g. an intervening compress happened, we do a full table scan&lt;br/&gt;
to verify the constraints instead.&lt;/p&gt;

&lt;p&gt;Adding a constraint in deferred constraint mode is currently sub-optimal, since&lt;br/&gt;
we currently do a full table scan via an internally generated &quot;SELECT .. WHERE&lt;br/&gt;
NOT &amp;lt;constraints&amp;gt;&quot;, and we don&apos;t have a way the get at the row locations of the&lt;br/&gt;
offending rows in this case. I might add a specially tailored result set for&lt;br/&gt;
that purpose later.&lt;/p&gt;

&lt;p&gt;Normally, when a row is inserted or updated, we execute a generated method which&lt;br/&gt;
combines evaluation of all check constraints on the table relevant for the&lt;br/&gt;
inserted or updated columns. This evaluation is performed using McCarthy boolean&lt;br/&gt;
evaluation (short-circuits as soon as result is known). This isn&apos;t optimal for&lt;br/&gt;
deferred constraints, as we&apos;d need to assume all constraints were violated in&lt;br/&gt;
such a case. The implementation replaces the short-circuited evaluation with a&lt;br/&gt;
full evaluation, so we can remember exactly which constraints were violated,&lt;br/&gt;
cf. AndNoShortCircuitNode and SQLBoolean#throwExceptionIfImmediateAndFalse. A&lt;br/&gt;
violation in throwExceptionIfImmediateAndFalse when we have a deferred&lt;br/&gt;
constraint is noted (DMLWriteResultSet#rememberConstraint implemented by&lt;br/&gt;
UpdateResultSet and InsertResultSet) by adding the violation to a list for that&lt;br/&gt;
row. After the insert/update is completed, the set of violations is remembered&lt;br/&gt;
for posterity, cf. InsertResultSet#normalInsertCode and&lt;br/&gt;
UpdateResultSet#collectAffectedRows by inspecting the lists&lt;br/&gt;
(#violatingCheckConstraints).&lt;/p&gt;

&lt;p&gt;Note that we currently do not note which constraints were violated *for each&lt;br/&gt;
individual row*, only per table in the transaction. This means that we visit&lt;br/&gt;
potentially more rows over again when a single constraint is changed to&lt;br/&gt;
immediate.  This could be improved further by storing the set of violated&lt;br/&gt;
constraints along with the row location.&lt;/p&gt;

&lt;p&gt;For bulk insert and deferred (see panel 1 below) insert row processing there is&lt;br/&gt;
special code paths, cf.  InsertResultSet#offendingRowLocation which is invoked&lt;br/&gt;
via a callback from HeapController#load and another path in&lt;br/&gt;
InsertResultSet#normalInsertCode respectively.&lt;/p&gt;

&lt;p&gt;For update, the code for deferred treatment is in in one of&lt;br/&gt;
UpdateResultSet#collectAffectedRows and UpdateResultSet#updateDeferredRows&lt;br/&gt;
depending on whether there are triggers.&lt;/p&gt;

&lt;p&gt;The existing test ConstraintCharacteristcsTest has been built out by adding&lt;br/&gt;
check constraint to those fixture for which it is relevant, as well as adding&lt;br/&gt;
new ones which are only relevant for check constraints.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; This &quot;deferred&quot; refers to Derby special handling of rows in certain&lt;br/&gt;
situation, for example when doing an insert which uses the same table as a&lt;br/&gt;
source result set, we need to make sure we don&apos;t get confused and see the&lt;br/&gt;
incrementally inserted rows &quot;again&quot; as we process the original result set,&lt;br/&gt;
essentially we do a snapshot of the source result set, hence &quot;deferred rows&quot;.&lt;/p&gt;

&lt;p&gt;All regressions passed.&lt;/p&gt;

&lt;p&gt;Detailed code comments:&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/conn/SQLSessionContext.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/conn/SQLSessionContextImpl.java&lt;br/&gt;
M java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java&lt;br/&gt;
D java/engine/org/apache/derby/impl/sql/execute/DeferredDuplicates.java&lt;br/&gt;
A java/engine/org/apache/derby/impl/sql/execute/DeferredConstraintsMemory.java&lt;/p&gt;

&lt;p&gt;Extended and refactored slightly existing mechanism for deferred primary&lt;br/&gt;
key/unique constraints to also cater for check constraints. Since the hash key&lt;br/&gt;
we used for the memory of primary key and unique constraints was the&lt;br/&gt;
conglomerate id of the indexes, and those are guaranteed to be disjoint from the&lt;br/&gt;
conglomerate ids of the base tables having deferred constraints, we can use the&lt;br/&gt;
same hash table to find the &quot;memory&quot; in the form of the disk based hash table&lt;br/&gt;
(BackingStoreHashtable), cf.  LCC#getDeferredHashTables.--&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/dictionary/ConstraintDescriptor.java-&lt;/p&gt;

&lt;p&gt;Code to drop any deferred constraints memory in the transaction when a&lt;br/&gt;
constraint is dropped.-&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/store/access/heap/HeapController.java&lt;/p&gt;

&lt;p&gt;Call back added for bulk insert in the presence of deferrable check constraints.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/NoPutResultSet.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java&lt;br/&gt;
M java/engine/org/apache/derby/iapi/store/access/RowLocationRetRowSource.java&lt;/p&gt;

&lt;p&gt;Extra plumbing to be able to signal to HeapController that we need to do a&lt;br/&gt;
callback with the inserted row location (for bulk insert)&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/TargetResultSet.java&lt;/p&gt;

&lt;p&gt;Extra interface method, offendingRowLocation. Only implemented with meaningful&lt;br/&gt;
semantics for NoPutResultSetImpl which calls it for its targetResultSet, an&lt;br/&gt;
InsertResultSet.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java&lt;/p&gt;

&lt;p&gt;More parameters to getProjectRestrictResult set to do the magic mention in the&lt;br/&gt;
overview for that result set, pass along schema and table name to&lt;br/&gt;
InsertResultSet so we can remember them for check violations. They are used to&lt;br/&gt;
produced checking SQL statements. This may be a bit fragile, since a rename&lt;br/&gt;
schema or table could make those invalid. However, there is presently no RENAME&lt;br/&gt;
SCHEMA in Derby and the RENAME TABLE is illegal in certain cases, notably if&lt;br/&gt;
there is a check constraint defined on it, so the solution should be OK for&lt;br/&gt;
now. Also adds an interface method, getValidateCheckConstraintResultSet, to&lt;br/&gt;
allow the execution run-time to build one of those, cf. code generation logic in&lt;br/&gt;
NestedLoopStrategy#resultSetMethodName.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/execute/RowChanger.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/RowChangerImpl.java&lt;/p&gt;

&lt;p&gt;Extra parameter to insertRow to get at the row location if needed.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/store/access/BackingStoreHashtable.java&lt;br/&gt;
M java/engine/org/apache/derby/iapi/store/access/ScanController.java&lt;/p&gt;

&lt;p&gt;Javadoc fixes.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/types/BooleanDataValue.java&lt;br/&gt;
M java/engine/org/apache/derby/iapi/types/SQLBoolean.java&lt;/p&gt;

&lt;p&gt;Extra method throwExceptionIfImmediateAndFalse used by deferred check&lt;br/&gt;
constraints to make a note of all violated constraints as evaluated by the&lt;br/&gt;
generated method. Picked up by InsertResultSet or UpdateResultSet.&lt;/p&gt;

&lt;p&gt;A java/engine/org/apache/derby/impl/sql/compile/AndNoShortCircuitNode.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/AndNode.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/DMLModStatementNode.java&lt;/p&gt;

&lt;p&gt;AndNoShortCircuitNode is used to represent a non-McCarthy evaluation of the&lt;br/&gt;
combined check constraints. See usage in DMLModStatementNode#generateCheckTree.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/DeleteNode.java&lt;/p&gt;

&lt;p&gt;Extra dummy parameter added for call to super#bindConstraints&lt;br/&gt;
(DMLModStatementNode). Only used by insert.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java&lt;/p&gt;

&lt;p&gt;Pick up the DERBY_PROPERTIES value for property &quot;validateCheckConstraint =&lt;br/&gt;
&amp;lt;conlomerateId&amp;gt;&quot; we provide to the checking query (internal syntax only)&lt;br/&gt;
generated by DeferredConstraintsMemory#validateCheck.  The conglomerate id is&lt;br/&gt;
used to retrieve the violating rows information set up by&lt;br/&gt;
ProjectRestrictResultSet#openCore to drive ValidateCheckConstraintResultSet.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/InsertNode.java&lt;/p&gt;

&lt;p&gt;Boolean member variable to know if we have a deferrable check constraint; also&lt;br/&gt;
pass only schema and table name to the result set. Passed on to the&lt;br/&gt;
InsertConstantAction from which InsertResultSet can pick it up.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java&lt;/p&gt;

&lt;p&gt;Logic to keep track of whether we are used by the special internal query to&lt;br/&gt;
check violated check constraints.  In this case we also do not push the check&lt;br/&gt;
predicates down to store for simpler handling.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java&lt;/p&gt;

&lt;p&gt;Code to parse a long value from &quot;--DERBY-PROPERTIES&quot; property.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/SetConstraintsNode.java&lt;/p&gt;

&lt;p&gt;Extra code to comply with the sane mode parse tree printing conventions.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/TestConstraintNode.java&lt;/p&gt;

&lt;p&gt;Handle different code generation for deferrable check contraints.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/compile/UpdateNode.java&lt;/p&gt;

&lt;p&gt;Pass on more info: schema and table name + small refactoring.&lt;/p&gt;

&lt;p&gt;M  java/engine/org/apache/derby/impl/sql/compile/sqlgrammar.jj&lt;/p&gt;

&lt;p&gt;Handle the new internal query to validate violated check constraints. Cf. query&lt;br/&gt;
in DeferredConstraintsMemory#validateCheck.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/AlterConstraintConstantAction.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java&lt;/p&gt;

&lt;p&gt;Open up for check constraints.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/ConstraintConstantAction.java&lt;/p&gt;

&lt;p&gt;ATCA: Special handling of adding a deferred check constraint: need different&lt;br/&gt;
code path to get the UUID of constraint soon enough to be able to note any&lt;br/&gt;
constraint violations. CCA: note any violation and remember it.  We&apos;d like to&lt;br/&gt;
remember that row locations of the offending rows here, but not done for now, so&lt;br/&gt;
at checking time, we&apos;ll need a full table scan. This can be improved upon, see&lt;br/&gt;
code comment.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/UpdateConstantAction.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java&lt;/p&gt;

&lt;p&gt;Pass on more info to InsertConstantAction and UpdateConstantAction needed by the&lt;br/&gt;
result sets.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java&lt;/p&gt;

&lt;p&gt;Drives the checking for check constraints, and picks up the result. If we have&lt;br/&gt;
violations and deferred constraints, we remember that. Also some refactorings to&lt;br/&gt;
avoid local variables shadowing globals.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java&lt;/p&gt;

&lt;p&gt;Drives the checking for check constraints, and picks up the result. If we have&lt;br/&gt;
violations and deferred constraints, we remember that.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java&lt;/p&gt;

&lt;p&gt;Removed unused method.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/ProjectRestrictResultSet.java&lt;/p&gt;

&lt;p&gt;Drive the special result set, ValidateCheckConstraintResultSet by positioning it&lt;br/&gt;
correctly for each row retrieved, using the remembered row locations from&lt;br/&gt;
violation time.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/SetConstraintsConstantAction.java&lt;/p&gt;

&lt;p&gt;Added logic for check constraints. Also added a new check that the user don&apos;t&lt;br/&gt;
specify the same constraint twice, cf new test case for it.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/TableScanResultSet.java&lt;/p&gt;

&lt;p&gt;Make some members protected rather than private, to let the new result set&lt;br/&gt;
ValidateCheckConstraintResultSet inherit from it.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/store/access/sort/MergeScanRowSource.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/store/access/sort/SortBufferRowSource.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/CardinalityCounter.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/DMLWriteResultSet.java&lt;/p&gt;

&lt;p&gt;Boiler plate to comply with interface (not used).&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/impl/sql/execute/UniqueIndexSortObserver.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/UniqueWithDuplicateNullsIndexSortObserver.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java&lt;/p&gt;

&lt;p&gt;Refactoring only.&lt;/p&gt;

&lt;p&gt;A java/engine/org/apache/derby/impl/sql/execute/ValidateCheckConstraintResultSet.java&lt;/p&gt;

&lt;p&gt;The new result we use to check violating rows only based on row location&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/sql/compile/JoinStrategy.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/HashJoinStrategy.java&lt;br/&gt;
M java/engine/org/apache/derby/impl/sql/compile/NestedLoopJoinStrategy.java&lt;/p&gt;

&lt;p&gt;New boolean to signal that we want ValidateCheckConstraintResultSet&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/jdbc/EmbedXAResource.java&lt;br/&gt;
M java/engine/org/apache/derby/jdbc/XATransactionState.java&lt;/p&gt;

&lt;p&gt;Extra logic to handle check constraints (already had it for primary key and unique).&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/iapi/error/ExceptionUtil.java&lt;/p&gt;

&lt;p&gt;Utility method to determine if an exception if a transaction deferred constraint&lt;br/&gt;
violation. Needed by the XA code.&lt;/p&gt;

&lt;p&gt;M java/engine/org/apache/derby/loc/messages.xml&lt;br/&gt;
M java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/p&gt;

&lt;p&gt;New error messages&lt;/p&gt;

&lt;p&gt;M java/testing/org/apache/derbyTesting/functionTests/tests/lang/ConstraintCharacteristicsTest.java&lt;/p&gt;

&lt;p&gt;New test cases and extension of present ones to include check constraints&lt;/p&gt;

&lt;p&gt;M java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_11.java&lt;/p&gt;

&lt;p&gt;Extension of present test cases to include check constraints.&lt;/p&gt;</comment>
                            <comment id="13933172" author="jira-bot" created="Thu, 13 Mar 2014 12:29:14 +0000"  >&lt;p&gt;Commit 1577134 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1577134&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1577134&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Added an extra test case.&lt;/p&gt;</comment>
                            <comment id="13942264" author="dagw" created="Thu, 20 Mar 2014 20:57:00 +0000"  >&lt;p&gt;Marking this as resolved.&lt;/p&gt;</comment>
                            <comment id="13942265" author="dagw" created="Thu, 20 Mar 2014 20:57:43 +0000"  >&lt;p&gt;Oops, wrong issue, reopening.&lt;/p&gt;</comment>
                            <comment id="13942275" author="jira-bot" created="Thu, 20 Mar 2014 21:03:47 +0000"  >&lt;p&gt;Commit 1579737 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/branches/10.10&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1579737&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1579737&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6374&quot; title=&quot;Bulk insert of data with nullable UNIQUE constraint fails to detect duplicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6374&quot;&gt;&lt;del&gt;DERBY-6374&lt;/del&gt;&lt;/a&gt; Bulk insert of data with nullable UNIQUE constraint fails to detect duplicates&lt;/p&gt;

&lt;p&gt;Backported to 10.10, had to do major surgery since the original fix&lt;br/&gt;
was part of a &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; patch.&lt;/p&gt;</comment>
                            <comment id="13948656" author="dagw" created="Wed, 26 Mar 2014 23:34:31 +0000"  >&lt;p&gt;Attaching an exploratory patch &lt;font color=&quot;blue&quot;&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12637050/derby-532-fk-baseline.diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/secure/attachment/12637050/derby-532-fk-baseline.diff&lt;/a&gt;&lt;/font&gt; for foreign constraints: the new test ForeignKeysDeferrableTest (I may integrate in the existing test for deferrable constraints later), contains fixtures that enumerate the different places/code paths in which we check foreign constraints. The solution for&lt;br/&gt;
deferrable constraints need to handle all of these.&lt;/p&gt;</comment>
                            <comment id="13949561" author="dagw" created="Thu, 27 Mar 2014 16:47:02 +0000"  >&lt;p&gt;Uploading version 2 of the foreign constraints baseline test patch (improvements).&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12637180/derby-532-fk-baseline-2.diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/secure/attachment/12637180/derby-532-fk-baseline-2.diff&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13960062" author="dagw" created="Fri, 4 Apr 2014 16:40:41 +0100"  >&lt;p&gt;Uploading a first working patch for foreign constraints (derby-532-fk-1) with a new test, ForeignKeysDeferrableTest. The patch is preliminary; more testing needs to happen, but the basic functionality works for what&apos;s tested. It&apos;s not for commit yet, just for an early view/proof-of-concept.&lt;/p&gt;</comment>
                            <comment id="13965694" author="dagw" created="Thu, 10 Apr 2014 19:57:13 +0100"  >&lt;p&gt;Uploading patch derby-532-fk-3, which relative to version 1 adds invalidation of saved rows for deferred foreign key constraints and adds tests for that. In addition this led to uncovering some issues with invalidation for unique constraints as well, also fixed here.&lt;br/&gt;
I don&apos;t know of missing functionality for deferred foreign keys by now, so I&apos;ll look to committing this patch modulo review comments - reviews welcome at this point!&lt;br/&gt;
Next, I plan to add more tests for more complicated use cases.&lt;/p&gt;

&lt;p&gt;JUnit regressions passed.&lt;/p&gt;</comment>
                            <comment id="13965726" author="dagw" created="Thu, 10 Apr 2014 20:10:41 +0100"  >&lt;p&gt;The approach take for deferring foreign keys is similar to that taken for the other constraints: when we detect a violation when inserting or updating the referring table, and when detecting a violation when deleting or updating the referenced table (only when we have ON DELETE (or UPDATE) NO ACTION), we save the key in a temporary table instead of throwing an exception. At check time, typically on commit, we revisit first the supporting index of referencing table to see if there might still be a problem. If that key is (still) present, we must also check the corresponding index in the referenced table. If that is found, all is good. Otherwise we throw. The main new pieces of the machinery are ForeignKeysDeferrableTest#rememberFKViolation and #validateForeignKey and GenericLanguageConnectionContext#doValidateForeignKey and its uses.&lt;/p&gt;</comment>
                            <comment id="13966065" author="dagw" created="Fri, 11 Apr 2014 01:25:54 +0100"  >&lt;p&gt;Uploading a refactored version of last patch: derby-532-fk-4.&lt;br/&gt;
It gives better encapsulation/object orientation relative to patch #3.&lt;/p&gt;</comment>
                            <comment id="13966446" author="dagw" created="Fri, 11 Apr 2014 13:02:12 +0100"  >&lt;p&gt;Uploading derby-532-fk-5, a revision of #4: smaller simplifications in asserting in ConstraintCharacteristicsTest, and clean-up of too long lines.&lt;br/&gt;
Rerunning regressions.&lt;/p&gt;</comment>
                            <comment id="13981319" author="dagw" created="Fri, 25 Apr 2014 18:53:29 +0100"  >&lt;p&gt;Patch derby-532-fk-6. Smaller changes relative to #5.&lt;br/&gt;
I intend to commit this version if no comments are made.&lt;/p&gt;

&lt;div class=&quot;panel&quot; style=&quot;background-color: #FFFFCE;border-color: #ccc;border-style: dashed;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelHeader&quot; style=&quot;border-bottom-width: 1px;border-bottom-style: dashed;border-bottom-color: #ccc;background-color: #F7D6C1;&quot;&gt;&lt;b&gt;Patch details&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;panelContent&quot; style=&quot;background-color: #FFFFCE;&quot;&gt;
&lt;p&gt;M       java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java&lt;/p&gt;

&lt;p&gt;Move logic related to constraints checking to&lt;br/&gt;
DeferredConstraintsMemory. &lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/DeferredConstraintsMemory.java&lt;/p&gt;

&lt;p&gt;New logic from LanguageConnectionContext; added logic for the case of&lt;br/&gt;
foreign key constraints violation memory and checking. Make old &quot;if&quot;s&lt;br/&gt;
on object type object oriented: new interface methods in&lt;br/&gt;
ValidationInfo: possiblyValidateOnReturn and validateConstraint which&lt;br/&gt;
are implemented differently for each constraint type.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/ConstraintConstantAction.java&lt;/p&gt;

&lt;p&gt;More fk info to bulk insert; smaller refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/sql/dictionary/ReferencedKeyConstraintDescriptor.java&lt;/p&gt;

&lt;p&gt;Change the method hasNonSelfReferencingFK to getNonSelfReferencingFK;&lt;br/&gt;
we need to get at them, see AlterTableConstantAction for truncate.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java&lt;/p&gt;

&lt;p&gt;Refactored logic to DeferredConstraintsMemory#compressOrTruncate.&lt;br/&gt;
Allow truncate (if deferred and NO_ACTION constraints only) of&lt;br/&gt;
deferenced table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/types/SQLBoolean.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/ProjectRestrictResultSet.java&lt;/p&gt;

&lt;p&gt;Minor refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/FKInfo.java&lt;/p&gt;

&lt;p&gt;Extended with information about deferred constraints; conglomerate ids and constrain ids.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/DMLModStatementNode.java&lt;/p&gt;

&lt;p&gt;More information collection to support extended FKInfo, see above.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/TableElementList.java&lt;/p&gt;

&lt;p&gt;Extra predicates to avoid logic for unique and primary key constraints to inferere with&lt;br/&gt;
deferred foreign keys.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java&lt;/p&gt;

&lt;p&gt;Remove foreign keys as &quot;not supported&quot;, minor refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java&lt;/p&gt;

&lt;p&gt;Added arguments, refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java&lt;/p&gt;

&lt;p&gt;This is where we actually defer when we see a fk violation at insert/update of referencing table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java&lt;/p&gt;

&lt;p&gt;Minor interface changes: new member variable: lcc&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/RIBulkChecker.java&lt;/p&gt;

&lt;p&gt;This is where we actually defer when we see a fk violation at bulk insert&lt;br/&gt;
into referencing table.&lt;/p&gt;


&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/RISetChecker.java&lt;/p&gt;

&lt;p&gt;Minor interface changes; added parameters.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/ReferencedKeyRIChecker.java&lt;/p&gt;

&lt;p&gt;This is where we actually defer when we see a fk violation at delete or update of&lt;br/&gt;
a row in the referenced table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/SetConstraintsConstantAction.java&lt;/p&gt;

&lt;p&gt;Make SET CONSTRAINTS work also for foreign keys.&lt;/p&gt;

&lt;p&gt;M       java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;br/&gt;
M       java/engine/org/apache/derby/loc/messages.xml&lt;/p&gt;

&lt;p&gt;New error messages.&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/ConstraintCharacteristicsTest.java&lt;/p&gt;

&lt;p&gt;Extended existing deferrable constraints to also work for foreign constraints.&lt;/p&gt;

&lt;p&gt;A       java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java&lt;/p&gt;

&lt;p&gt;New tests only for foreign key constraints.&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_11.java&lt;/p&gt;

&lt;p&gt;Remove asserts for not implemented on deferrable foreign key&lt;br/&gt;
constraints, check basic sanity iff hard upgraded.&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java&lt;/p&gt;

&lt;p&gt;Added assertCommitError; minor changes to support fk testing.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="13983782" author="jira-bot" created="Tue, 29 Apr 2014 01:23:54 +0100"  >&lt;p&gt;Commit 1590849 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1590849&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1590849&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Deferred foreign key constraint. Patch derby-532-fk-7.&lt;/p&gt;

&lt;p&gt;The approach taken for deferring foreign keys is similar to that taken&lt;br/&gt;
for the other constraints: when we detect a violation inserting or&lt;br/&gt;
updating the referring table, and when detecting a violation when&lt;br/&gt;
deleting or updating the referenced table (only when we have ON DELETE&lt;br/&gt;
(or UPDATE) NO ACTION), we save the key in a temporary table instead&lt;br/&gt;
of throwing an exception. At check time, typically on commit, we&lt;br/&gt;
revisit first the supporting index of referencing table to see if&lt;br/&gt;
there might still be a problem. If that key is (still) present, we&lt;br/&gt;
must also check the corresponding index in the referenced table. If&lt;br/&gt;
that is found, all is good. Otherwise we throw.&lt;/p&gt;

&lt;p&gt;Patch details:&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java&lt;/p&gt;

&lt;p&gt;Move logic related to constraints checking to&lt;br/&gt;
DeferredConstraintsMemory. &lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/DeferredConstraintsMemory.java&lt;/p&gt;

&lt;p&gt;New logic from LanguageConnectionContext; added logic for the case of&lt;br/&gt;
foreign key constraints violation memory and checking. Make old &quot;if&quot;s&lt;br/&gt;
on object type object oriented: new interface methods in&lt;br/&gt;
ValidationInfo: possiblyValidateOnReturn and validateConstraint which&lt;br/&gt;
are implemented differently for each constraint type.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/UpdateResultSet.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/ConstraintConstantAction.java&lt;/p&gt;

&lt;p&gt;More fk info to bulk insert; smaller refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/sql/dictionary/ReferencedKeyConstraintDescriptor.java&lt;/p&gt;

&lt;p&gt;Change the method hasNonSelfReferencingFK to getNonSelfReferencingFK;&lt;br/&gt;
we need to get at them, see AlterTableConstantAction for truncate.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java&lt;/p&gt;

&lt;p&gt;Refactored logic to DeferredConstraintsMemory#compressOrTruncate.&lt;br/&gt;
Allow truncate (if deferred and NO_ACTION constraints only) of&lt;br/&gt;
deferenced table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/types/SQLBoolean.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/execute/ProjectRestrictResultSet.java&lt;/p&gt;

&lt;p&gt;Minor refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/FKInfo.java&lt;/p&gt;

&lt;p&gt;Extended with information about deferred constraints; conglomerate ids and constrain ids.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/DMLModStatementNode.java&lt;/p&gt;

&lt;p&gt;More information collection to support extended FKInfo, see above.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/compile/TableElementList.java&lt;/p&gt;

&lt;p&gt;Extra predicates to avoid logic for unique and primary key constraints to inferere with&lt;br/&gt;
deferred foreign keys.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java&lt;/p&gt;

&lt;p&gt;Remove foreign keys as &quot;not supported&quot;, minor refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/DeleteResultSet.java&lt;/p&gt;

&lt;p&gt;Added arguments, refactorings.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/ForeignKeyRIChecker.java&lt;/p&gt;

&lt;p&gt;This is where we actually defer when we see a fk violation at insert/update of referencing table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java&lt;/p&gt;

&lt;p&gt;Minor interface changes: new member variable: lcc&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/RIBulkChecker.java&lt;/p&gt;

&lt;p&gt;This is where we actually defer when we see a fk violation at bulk insert&lt;br/&gt;
into referencing table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/RISetChecker.java&lt;/p&gt;

&lt;p&gt;Minor interface changes; added parameters.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/ReferencedKeyRIChecker.java&lt;/p&gt;

&lt;p&gt;This is where we actually defer when we see a fk violation at delete or update of&lt;br/&gt;
a row in the referenced table.&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/SetConstraintsConstantAction.java&lt;/p&gt;

&lt;p&gt;Make SET CONSTRAINTS work also for foreign keys.&lt;/p&gt;

&lt;p&gt;M       java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;br/&gt;
M       java/engine/org/apache/derby/loc/messages.xml&lt;/p&gt;

&lt;p&gt;New error messages.&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/ConstraintCharacteristicsTest.java&lt;/p&gt;

&lt;p&gt;Extended existing deferrable constraints to also work for foreign constraints.&lt;/p&gt;

&lt;p&gt;A       java/testing/org/apache/derbyTesting/functionTests/tests/lang/ForeignKeysDeferrableTest.java&lt;/p&gt;

&lt;p&gt;New tests only for foreign key constraints.&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_11.java&lt;/p&gt;

&lt;p&gt;Remove asserts for not implemented on deferrable foreign key&lt;br/&gt;
constraints, check basic sanity iff hard upgraded.&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java&lt;/p&gt;

&lt;p&gt;Added assertCommitError; minor changes to support fk testing.&lt;/p&gt;</comment>
                            <comment id="13983787" author="dagw" created="Tue, 29 Apr 2014 01:26:09 +0100"  >&lt;p&gt;Patch derby-532-fk-7 adds wiring of ForeignKeysDeferrableTest into the lang suite, no other changes compared to #6.&lt;/p&gt;</comment>
                            <comment id="13983798" author="dagw" created="Tue, 29 Apr 2014 01:38:05 +0100"  >&lt;p&gt;With the latest commit, deferrable constraints ought to (prove me wrong!) work for&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;unique/primary key constraints&lt;/li&gt;
	&lt;li&gt;referential constraints (aka foreign key constraints)&lt;/li&gt;
	&lt;li&gt;check constraints&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I do not intend to add support for column NOT NULL constraints. Also, there is no support yet for changing constraints to &quot;not enforced&quot;, otherwise the standard semantics of SQL 2011 should apply. &lt;/p&gt;

&lt;p&gt;I intend to add a few more tests for foreign key constraints. &lt;span class=&quot;error&quot;&gt;&amp;#91;Update: Cf DERBY-6559&amp;#93;&lt;/span&gt;.&lt;/p&gt;</comment>
                            <comment id="13993878" author="dagw" created="Fri, 9 May 2014 21:14:17 +0100"  >&lt;p&gt;Attaching a patch, derby-532-metadata-queries, which updates the&lt;br/&gt;
metadata queries to give correct results in the DEFERRABILITY column returned by the calls:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DataBaseMetaData#getImportedKeys&lt;/li&gt;
	&lt;li&gt;DataBaseMetaData#getExportedKeys&lt;/li&gt;
	&lt;li&gt;DataBaseMetaData#getCrossReference.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Tests added. Running regressions. &lt;span class=&quot;error&quot;&gt;&amp;#91;&lt;font color=&quot;green&quot;&gt;Update: ran ok&lt;/font&gt;&amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="13993897" author="dagw" created="Fri, 9 May 2014 21:40:52 +0100"  >&lt;p&gt;Updating a new up-to-date version of the functional specification. This should form a basis for the documentation, it is hoped.&lt;/p&gt;

&lt;p&gt;Some parts are as yet, unimplemented, i.e. NOT NULL constraints are not deferrable, and the NOT ENFORCED state is not yet supported. These parts are marked in red (rather than being removed) in the updated spec since I wanted to keep the material there where it belongs if someone wants to pick it up later.&lt;/p&gt;</comment>
                            <comment id="13995044" author="jira-bot" created="Mon, 12 May 2014 13:49:16 +0100"  >&lt;p&gt;Commit 1593949 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1593949&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1593949&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Patch derby-532-metadata-queries: updates the metadata queries to give&lt;br/&gt;
correct results in the DEFERRABILITY column returned by the calls:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DataBaseMetaData#getImportedKeys&lt;/li&gt;
	&lt;li&gt;DataBaseMetaData#getExportedKeys&lt;/li&gt;
	&lt;li&gt;DataBaseMetaData#getCrossReference.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Test have been added.&lt;/p&gt;</comment>
                            <comment id="13996517" author="jira-bot" created="Tue, 13 May 2014 16:51:42 +0100"  >&lt;p&gt;Commit 1594255 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dagw&quot; class=&quot;user-hover&quot; rel=&quot;dagw&quot;&gt;Dag H. Wanvik&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1594255&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1594255&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-532&quot; title=&quot;Support deferrable constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-532&quot;&gt;&lt;del&gt;DERBY-532&lt;/del&gt;&lt;/a&gt; Support deferrable constraints&lt;/p&gt;

&lt;p&gt;Substituted BaseJDBCTestCase#dropTable for home grown version, we&lt;br/&gt;
prefer the standard way to do it.&lt;/p&gt;</comment>
                            <comment id="14014105" author="dagw" created="Fri, 30 May 2014 19:54:24 +0100"  >&lt;p&gt;I just found a note in the standard which seems to ban foreign keys from relying on deferrable primary and unique keys. Cf.&lt;br/&gt;
Syntax Rule 5 in section 11.8 &amp;lt;referential constrain definition&amp;gt;: &lt;/p&gt;

&lt;p&gt;&quot;The table constraint descriptor describing the &amp;lt;unique constraint definition&amp;gt; whose &amp;lt;unique column list&amp;gt; identifies the referenced columns shall indicate that the unique constraint is not deferrable.&quot;&lt;/p&gt;</comment>
                            <comment id="14016008" author="dagw" created="Mon, 2 Jun 2014 23:53:36 +0100"  >&lt;p&gt;Uploaded version 1.9 of the functional specification adding note on limitation on fk iff referenced primary/unique key is deferrable.&lt;/p&gt;</comment>
                            <comment id="14019339" author="dagw" created="Thu, 5 Jun 2014 23:01:58 +0100"  >&lt;p&gt;Resolving. I consider the feature complete as specified and documented modulo unknown errors.&lt;/p&gt;</comment>
                            <comment id="14027197" author="dagw" created="Wed, 11 Jun 2014 00:19:41 +0100"  >&lt;p&gt;Uploading a new functional specification - small clerical addition (not relevant for user docs).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12672630">DERBY-6374</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12659782">DERBY-6303</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12681591">DERBY-6423</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12727140">DERBY-6661</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12727754">DERBY-6668</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12727966">DERBY-6670</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12728432">DERBY-6672</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12729178">DERBY-6674</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12688046">DERBY-6453</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310050">
                    <name>Regression</name>
                                                                <inwardlinks description="is broken by">
                                        <issuelink>
            <issuekey id="12711323">DERBY-6559</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12713983">DERBY-6576</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12713384">DERBY-6571</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12614960" name="IndexDescriptor.html" size="20480" author="dagw" created="Wed, 20 Nov 2013 19:10:58 +0000"/>
                            <attachment id="12614958" name="IndexDescriptorImpl.html" size="45275" author="dagw" created="Wed, 20 Nov 2013 19:10:58 +0000"/>
                            <attachment id="12614957" name="IndexRowGenerator.html" size="53853" author="dagw" created="Wed, 20 Nov 2013 19:10:58 +0000"/>
                            <attachment id="12614999" name="SortObserver.html" size="20417" author="dagw" created="Wed, 20 Nov 2013 21:27:24 +0000"/>
                            <attachment id="12649695" name="deferredConstraints.html" size="23050" author="dagw" created="Wed, 11 Jun 2014 00:18:51 +0100"/>
                            <attachment id="12648028" name="deferredConstraints.html" size="22831" author="dagw" created="Mon, 2 Jun 2014 23:53:36 +0100"/>
                            <attachment id="12648025" name="deferredConstraints.html" size="22435" author="dagw" created="Mon, 2 Jun 2014 23:26:16 +0100"/>
                            <attachment id="12644183" name="deferredConstraints.html" size="22191" author="dagw" created="Fri, 9 May 2014 21:40:52 +0100"/>
                            <attachment id="12615631" name="deferredConstraints.html" size="18379" author="dagw" created="Mon, 25 Nov 2013 17:57:22 +0000"/>
                            <attachment id="12611404" name="deferredConstraints.html" size="19601" author="dagw" created="Thu, 31 Oct 2013 15:40:25 +0000"/>
                            <attachment id="12611153" name="deferredConstraints.html" size="18181" author="dagw" created="Wed, 30 Oct 2013 19:58:41 +0000"/>
                            <attachment id="12595741" name="deferredConstraints.html" size="16411" author="dagw" created="Sat, 3 Aug 2013 10:31:44 +0100"/>
                            <attachment id="12594133" name="deferredConstraints.html" size="15524" author="dagw" created="Thu, 25 Jul 2013 08:44:10 +0100"/>
                            <attachment id="12618729" name="derby-532-allow-pk-unique-1.diff" size="21979" author="dagw" created="Sat, 14 Dec 2013 00:20:45 +0000"/>
                            <attachment id="12618728" name="derby-532-allow-pk-unique-1.status" size="592" author="dagw" created="Sat, 14 Dec 2013 00:20:45 +0000"/>
                            <attachment id="12630813" name="derby-532-check-constraints-1.diff" size="289895" author="dagw" created="Mon, 24 Feb 2014 22:18:20 +0000"/>
                            <attachment id="12630814" name="derby-532-check-constraints-1.stat" size="5114" author="dagw" created="Mon, 24 Feb 2014 22:18:20 +0000"/>
                            <attachment id="12633695" name="derby-532-check-constraints-2.diff" size="295048" author="dagw" created="Mon, 10 Mar 2014 14:41:04 +0000"/>
                            <attachment id="12633696" name="derby-532-check-constraints-2.stat" size="5114" author="dagw" created="Mon, 10 Mar 2014 14:41:04 +0000"/>
                            <attachment id="12616860" name="derby-532-fix-drop-not-nullable.diff" size="3967" author="dagw" created="Tue, 3 Dec 2013 22:24:09 +0000"/>
                            <attachment id="12616861" name="derby-532-fix-drop-not-nullable.status" size="505" author="dagw" created="Tue, 3 Dec 2013 22:24:09 +0000"/>
                            <attachment id="12616267" name="derby-532-fix-metadata-1.diff" size="10112" author="dagw" created="Thu, 28 Nov 2013 15:15:18 +0000"/>
                            <attachment id="12616268" name="derby-532-fix-metadata-1.status" size="380" author="dagw" created="Thu, 28 Nov 2013 15:15:18 +0000"/>
                            <attachment id="12638700" name="derby-532-fk-1.diff" size="113225" author="dagw" created="Fri, 4 Apr 2014 16:41:05 +0100"/>
                            <attachment id="12639628" name="derby-532-fk-3.diff" size="142356" author="dagw" created="Thu, 10 Apr 2014 19:57:13 +0100"/>
                            <attachment id="12639629" name="derby-532-fk-3.stat" size="2109" author="dagw" created="Thu, 10 Apr 2014 19:57:13 +0100"/>
                            <attachment id="12639697" name="derby-532-fk-4.diff" size="196823" author="dagw" created="Fri, 11 Apr 2014 01:25:54 +0100"/>
                            <attachment id="12639792" name="derby-532-fk-5.diff" size="203804" author="dagw" created="Fri, 11 Apr 2014 13:02:12 +0100"/>
                            <attachment id="12639793" name="derby-532-fk-5.stat" size="2275" author="dagw" created="Fri, 11 Apr 2014 13:02:12 +0100"/>
                            <attachment id="12641967" name="derby-532-fk-6.diff" size="210157" author="dagw" created="Fri, 25 Apr 2014 18:53:29 +0100"/>
                            <attachment id="12641968" name="derby-532-fk-6.stat" size="2250" author="dagw" created="Fri, 25 Apr 2014 18:53:29 +0100"/>
                            <attachment id="12642372" name="derby-532-fk-7.diff" size="210889" author="dagw" created="Tue, 29 Apr 2014 01:25:00 +0100"/>
                            <attachment id="12642371" name="derby-532-fk-7.stat" size="2332" author="dagw" created="Tue, 29 Apr 2014 01:25:00 +0100"/>
                            <attachment id="12637180" name="derby-532-fk-baseline-2.diff" size="23065" author="dagw" created="Thu, 27 Mar 2014 16:47:02 +0000"/>
                            <attachment id="12637050" name="derby-532-fk-baseline.diff" size="2956" author="dagw" created="Wed, 26 Mar 2014 23:34:31 +0000"/>
                            <attachment id="12612015" name="derby-532-import-1.diff" size="23025" author="dagw" created="Mon, 4 Nov 2013 20:13:11 +0000"/>
                            <attachment id="12612016" name="derby-532-import-1.status" size="997" author="dagw" created="Mon, 4 Nov 2013 20:13:11 +0000"/>
                            <attachment id="12612057" name="derby-532-import-2.diff" size="23028" author="dagw" created="Mon, 4 Nov 2013 23:43:09 +0000"/>
                            <attachment id="12612386" name="derby-532-import-3.diff" size="21416" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"/>
                            <attachment id="12612385" name="derby-532-import-3.status" size="913" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"/>
                            <attachment id="12644179" name="derby-532-metadata-queries.diff" size="5205" author="dagw" created="Fri, 9 May 2014 21:14:17 +0100"/>
                            <attachment id="12644178" name="derby-532-metadata-queries.status" size="664" author="dagw" created="Fri, 9 May 2014 21:14:17 +0100"/>
                            <attachment id="12612390" name="derby-532-more-tests-1.diff" size="8893" author="dagw" created="Wed, 6 Nov 2013 15:52:00 +0000"/>
                            <attachment id="12612391" name="derby-532-more-tests-1.stat" size="499" author="dagw" created="Wed, 6 Nov 2013 15:52:00 +0000"/>
                            <attachment id="12616862" name="derby-532-nullableUniqueFix.diff" size="10069" author="dagw" created="Tue, 3 Dec 2013 22:24:09 +0000"/>
                            <attachment id="12616863" name="derby-532-nullableUniqueFix.status" size="742" author="dagw" created="Tue, 3 Dec 2013 22:24:09 +0000"/>
                            <attachment id="12614629" name="derby-532-post-scan-1.diff" size="183189" author="dagw" created="Tue, 19 Nov 2013 14:57:32 +0000"/>
                            <attachment id="12614630" name="derby-532-post-scan-1.stat" size="3923" author="dagw" created="Tue, 19 Nov 2013 14:57:32 +0000"/>
                            <attachment id="12614955" name="derby-532-post-scan-2.diff" size="188633" author="dagw" created="Wed, 20 Nov 2013 19:08:16 +0000"/>
                            <attachment id="12614956" name="derby-532-post-scan-2.stat" size="3923" author="dagw" created="Wed, 20 Nov 2013 19:08:16 +0000"/>
                            <attachment id="12615003" name="derby-532-post-scan-3.diff" size="189733" author="dagw" created="Wed, 20 Nov 2013 21:33:52 +0000"/>
                            <attachment id="12614998" name="derby-532-post-scan-3.stat" size="3923" author="dagw" created="Wed, 20 Nov 2013 21:26:32 +0000"/>
                            <attachment id="12615625" name="derby-532-post-scan-4.diff" size="192140" author="dagw" created="Mon, 25 Nov 2013 17:46:13 +0000"/>
                            <attachment id="12615624" name="derby-532-post-scan-4.stat" size="3923" author="dagw" created="Mon, 25 Nov 2013 17:46:13 +0000"/>
                            <attachment id="12613417" name="derby-532-serializable-scan-1.diff" size="228634" author="dagw" created="Tue, 12 Nov 2013 20:13:14 +0000"/>
                            <attachment id="12613698" name="derby-532-serializable-scan-2.diff" size="190322" author="dagw" created="Wed, 13 Nov 2013 21:26:56 +0000"/>
                            <attachment id="12613699" name="derby-532-serializable-scan-2.stat" size="3923" author="dagw" created="Wed, 13 Nov 2013 21:26:56 +0000"/>
                            <attachment id="12596289" name="derby-532-syntax-binding-dict-1.diff" size="90853" author="dagw" created="Tue, 6 Aug 2013 08:17:11 +0100"/>
                            <attachment id="12596290" name="derby-532-syntax-binding-dict-1.status" size="2566" author="dagw" created="Tue, 6 Aug 2013 08:17:11 +0100"/>
                            <attachment id="12597475" name="derby-532-syntax-binding-dict-2.diff" size="58765" author="dagw" created="Mon, 12 Aug 2013 14:38:10 +0100"/>
                            <attachment id="12597476" name="derby-532-syntax-binding-dict-2.status" size="2163" author="dagw" created="Mon, 12 Aug 2013 14:38:10 +0100"/>
                            <attachment id="12600166" name="derby-532-syntax-binding-dict-all-1.diff" size="120862" author="dagw" created="Tue, 27 Aug 2013 14:59:49 +0100"/>
                            <attachment id="12618121" name="derby-532-test-speedup.diff" size="22725" author="dagw" created="Tue, 10 Dec 2013 22:29:19 +0000"/>
                            <attachment id="12618122" name="derby-532-test-speedup.status" size="1000" author="dagw" created="Tue, 10 Dec 2013 22:29:19 +0000"/>
                            <attachment id="12615857" name="derby-532-test-with-default-deferrable-all-over.diff" size="4816" author="dagw" created="Tue, 26 Nov 2013 16:43:57 +0000"/>
                            <attachment id="12600824" name="derby-532-testAlterConstraintInvalidation.diff" size="4282" author="dagw" created="Fri, 30 Aug 2013 19:22:29 +0100"/>
                            <attachment id="12600825" name="derby-532-testAlterConstraintInvalidation.status" size="395" author="dagw" created="Fri, 30 Aug 2013 19:22:29 +0100"/>
                            <attachment id="12608514" name="derby-532-unique-pk-1.diff" size="226927" author="dagw" created="Tue, 15 Oct 2013 16:07:40 +0100"/>
                            <attachment id="12608515" name="derby-532-unique-pk-1.status" size="5740" author="dagw" created="Tue, 15 Oct 2013 16:07:40 +0100"/>
                            <attachment id="12611155" name="derby-532-unique-pk-2.diff" size="227386" author="dagw" created="Wed, 30 Oct 2013 20:02:56 +0000"/>
                            <attachment id="12612384" name="derby-532-unique-pk-3.diff" size="228284" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"/>
                            <attachment id="12612389" name="derby-532-unique-pk-3.status" size="125" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"/>
                            <attachment id="12621368" name="derby-532-upgrade-1.diff" size="4602" author="dagw" created="Fri, 3 Jan 2014 19:09:11 +0000"/>
                            <attachment id="12621369" name="derby-532-upgrade-1.status" size="298" author="dagw" created="Fri, 3 Jan 2014 19:09:11 +0000"/>
                            <attachment id="12621589" name="derby-532-upgrade-1b.diff" size="4968" author="dagw" created="Mon, 6 Jan 2014 11:57:15 +0000"/>
                            <attachment id="12611156" name="derby-532-xa-1.diff" size="17029" author="dagw" created="Wed, 30 Oct 2013 20:02:56 +0000"/>
                            <attachment id="12611474" name="derby-532-xa-2.diff" size="19342" author="dagw" created="Thu, 31 Oct 2013 20:40:03 +0000"/>
                            <attachment id="12612387" name="derby-532-xa-3.diff" size="19168" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"/>
                            <attachment id="12612388" name="derby-532-xa-3.status" size="980" author="dagw" created="Wed, 6 Nov 2013 15:51:16 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12679933">DERBY-6419</subtask>
                            <subtask id="12713384">DERBY-6571</subtask>
                            <subtask id="12713621">DERBY-6574</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>79.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 25 Jul 2013 07:39:09 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29595</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0t2n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38528</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>