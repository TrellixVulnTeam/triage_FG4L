<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:39:52 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-268/DERBY-268.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-268] Add Support for truncate table</title>
                <link>https://issues.apache.org/jira/browse/DERBY-268</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Adding support for truncate table command will aid to portability&lt;/p&gt;</description>
                <environment></environment>
        <key id="32428">DERBY-268</key>
            <summary>Add Support for truncate table</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="eranda">Eranda Sooriyabandara</assignee>
                                    <reporter username="lancea">Lance Andersen</reporter>
                        <labels>
                    </labels>
                <created>Wed, 11 May 2005 06:04:23 +0100</created>
                <updated>Mon, 17 Jun 2013 10:19:48 +0100</updated>
                            <resolved>Tue, 6 Sep 2011 18:02:30 +0100</resolved>
                                                    <fixVersion>10.7.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="64924" author="bandaram" created="Wed, 11 May 2005 06:48:37 +0100"  >&lt;p&gt;Truncate table is not part of SQL standard (2003) specification... Mike Matrigali suggested using import procedure with replace option as a workaround.&lt;/p&gt;

&lt;p&gt;&quot;Look at the using the import system procedure with the replace option&lt;br/&gt;
set to true and the source import being empty.  I believe this will&lt;br/&gt;
run faster than delete, even better would be if your application had&lt;br/&gt;
a set of real rows to load when you want to truncate and use the table&lt;br/&gt;
again.&lt;/p&gt;

&lt;p&gt;Here is a link to 10.0 documentation for the system procedure:&lt;br/&gt;
&lt;a href=&quot;http://incubator.apache.org/derby/manuals/reference/sqlj120.html#HDRIMPORTPROC&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://incubator.apache.org/derby/manuals/reference/sqlj120.html#HDRIMPORTPROC&lt;/a&gt; &quot;&lt;/p&gt;</comment>
                            <comment id="12562428" author="knutanders" created="Fri, 25 Jan 2008 10:35:18 +0000"  >&lt;p&gt;Truncate table is implemented, but only enabled in debug builds. See this comment in AlterTableNode:&lt;/p&gt;

&lt;p&gt;		//truncate table is not suppotted in this release&lt;br/&gt;
		//semantics are not yet clearly defined by SQL Council yet&lt;br/&gt;
		//truncate will be allowed only in DEBUG builds for testing purposes.&lt;/p&gt;</comment>
                            <comment id="12562546" author="djd" created="Fri, 25 Jan 2008 15:48:08 +0000"  >&lt;p&gt;A more precise statement might be there appears to be code that implements truncate table, its state of completion is probably unknown.&lt;/p&gt;</comment>
                            <comment id="12707973" author="knutanders" created="Mon, 11 May 2009 12:17:04 +0100"  >&lt;p&gt;Truncate table is now part of the SQL standard (feature F200 in SQL:2008).&lt;/p&gt;</comment>
                            <comment id="12905937" author="rhillegas" created="Fri, 3 Sep 2010 16:28:49 +0100"  >&lt;p&gt;As Knut notes, the TRUNCATE TABLE command is defined in the 2008 SQL Standard, part 2, section 14.10 &amp;lt;truncate table statement&amp;gt;. The standard syntax is:&lt;/p&gt;

&lt;p&gt;TRUNCATE TABLE tableName [ identityBehavior ]&lt;/p&gt;

&lt;p&gt;identityBehavior ::=&lt;br/&gt;
   CONTINUE IDENTITY&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; RESTART IDENTITY&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;The default behavior is CONTINUE IDENTITY, which means that the table&apos;s identity column (if it has one) continues its sequence where it left off. RESTART IDENTITY means that the identity column resets to start again at its original initial value.&lt;/p&gt;

&lt;p&gt;Derby appears to implement a compatible subset of this standard syntax if you are running in debug mode:&lt;/p&gt;

&lt;p&gt;TRUNCATE TABLE tableName&lt;/p&gt;

&lt;p&gt;Derby preserves the standard CONTINUE IDENTITY default behavior.&lt;/p&gt;

&lt;p&gt;The following comment in AlterTableNode explains why TRUNCATE TABLE has been disabled in non-debug mode:&lt;/p&gt;

&lt;p&gt;		//truncate table is not supported in this release&lt;br/&gt;
		//semantics are not yet clearly defined by SQL Council yet&lt;br/&gt;
		//truncate will be allowed only in DEBUG builds for testing purposes.&lt;/p&gt;

&lt;p&gt;I believe that was a statement about the 2003 rev of the Standard--it is no longer true. I believe that we can expose this useful command in non-debug, production mode now.&lt;/p&gt;

&lt;p&gt;This seems to me to be a good issue for a newcomer. It involves the following:&lt;/p&gt;

&lt;p&gt;1) Remove the disabling logic from the initializer of AlterTableNode.&lt;/p&gt;

&lt;p&gt;2) Write regression tests to verify that TRUNCATE behaves correctly. In particular, verify that CONTINUE IDENTITY semantics are enforced.&lt;/p&gt;

&lt;p&gt;3) Document this command in the Reference Guide.&lt;/p&gt;

&lt;p&gt;A follow-on effort might be to implement the optional CONTINUE IDENTITY and RESTART IDENTITY clauses. Fortunately, the tricky bit of RESTART IDENTITY has already been implemented. The tricky bit is the following implied statement which is executed after truncating the table:&lt;/p&gt;

&lt;p&gt;ALTER TABLE  tableName ALTER COLUMN RESTART WITH initialValue&lt;/p&gt;</comment>
                            <comment id="12906226" author="eranda" created="Sat, 4 Sep 2010 06:47:59 +0100"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
It seems truncate table is working for me in the normal mode (without setting the debug mode)&lt;/p&gt;

&lt;p&gt;eranda@Eranda:~/Desktop/Derby/Derby-268/trunk/tests$ java org.apache.derby.tools.ij&lt;br/&gt;
ij version 10.7&lt;br/&gt;
ij&amp;gt; connect &apos;jdbc:derby:MyDB&apos;;&lt;br/&gt;
ij&amp;gt; insert into t1 values(1),(2),(3),(4),(5),(6);&lt;br/&gt;
6 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t1;&lt;br/&gt;
A          &lt;br/&gt;
-----------&lt;br/&gt;
1          &lt;br/&gt;
2          &lt;br/&gt;
3          &lt;br/&gt;
4          &lt;br/&gt;
5          &lt;br/&gt;
6          &lt;/p&gt;

&lt;p&gt;6 rows selected&lt;br/&gt;
ij&amp;gt; truncate table t1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t1;&lt;br/&gt;
A          &lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;br/&gt;
ij&amp;gt; &lt;/p&gt;

&lt;p&gt;What is the reason for this?&lt;/p&gt;
</comment>
                            <comment id="12906251" author="bryanpendleton" created="Sat, 4 Sep 2010 16:15:46 +0100"  >&lt;p&gt;Hi Eranda,&lt;/p&gt;

&lt;p&gt;Does your &apos;ant.properties&apos; file contain the line &apos;sane=true&apos;? If it does, then I think&lt;br/&gt;
you are performing a &quot;debug&quot; build, and TRUNCATE TABLE is enabled.&lt;/p&gt;

&lt;p&gt;Try removing &apos;sane=true&apos; from your ant.properties, then do &apos;ant clobber&apos; and &apos;ant all&apos;,&lt;br/&gt;
and see if TRUNCATE TABLE still works.&lt;/p&gt;

&lt;p&gt;The relevant code is this, in java/engine/org/apache/derby/impl/sql/compile/AlterTableNode.java&lt;/p&gt;


&lt;p&gt;  public void init(Object objectName)&lt;br/&gt;
    throws StandardException&lt;br/&gt;
  {&lt;/p&gt;

&lt;p&gt;    //truncate table is not suppotted in this release&lt;br/&gt;
    //semantics are not yet clearly defined by SQL Council yet&lt;br/&gt;
    //truncate will be allowed only in DEBUG builds for testing purposes.&lt;br/&gt;
    if (SanityManager.DEBUG)&lt;br/&gt;
    &lt;/p&gt;
{           
      initAndCheck(objectName);
      /* For now, this init() only called for truncate table */
      truncateTable = true;
      schemaDescriptor = getSchemaDescriptor();
    }
&lt;p&gt;else       &lt;/p&gt;
    {                   
      throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
                         &quot;truncate table&quot;);
    }                   
&lt;p&gt;  }                     &lt;/p&gt;</comment>
                            <comment id="12906252" author="eranda" created="Sat, 4 Sep 2010 16:24:50 +0100"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
Here is the changes you suggest. The TruncateTableTest passed for me now. If this is satisfying you I will take a look at implementing the optional CONTINUE IDENTITY and RESTART IDENTITY clauses.&lt;/p&gt;</comment>
                            <comment id="12906253" author="eranda" created="Sat, 4 Sep 2010 17:01:31 +0100"  >&lt;p&gt;Hi Bryan,&lt;br/&gt;
Yes that is the why truncate table works. After I remove that part in ant.property file, truncate table didn&apos;t work as we needed.&lt;br/&gt;
thanks&lt;/p&gt;</comment>
                            <comment id="12906832" author="rhillegas" created="Tue, 7 Sep 2010 16:23:28 +0100"  >&lt;p&gt;Thanks for the patch, Eranda. I am running regression tests on an insane build after making a couple changes to the test. See the attached derby-268-01-ab-enableForInsaneBuilds.diff:&lt;/p&gt;

&lt;p&gt;1) I put a primary key on the table so that the test would continue to test index truncation.&lt;/p&gt;

&lt;p&gt;2) I added ORDER BY clauses to the selects so that the query results will be deterministic.&lt;/p&gt;

&lt;p&gt;3) I capitalized the table name in the assertTableRowCount() call because the table name there is case-sensitive and the call was raising an exception.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12906876" author="rhillegas" created="Tue, 7 Sep 2010 18:01:41 +0100"  >&lt;p&gt;Tests ran cleanly for me. Committed derby-268-01-ab-enableForInsaneBuilds.diff at subversion revision 993428. Thanks, Eranda.&lt;/p&gt;</comment>
                            <comment id="12906921" author="mikem" created="Tue, 7 Sep 2010 19:20:50 +0100"  >&lt;p&gt;to add history to this feature.  Truncate table was originally implemented as a prototype and the current state of the code never went through the expected code review, testing, and planning for release.   Partly the reason was the standard.  But because of the standard it was never &quot;finished&quot;.  Just because it passes the existing tests does not mean the current code is right, there was very minimal testing effort originally.  It is especially likely that the existing code may be missing updates that subsequent features added since the original code might need.  &lt;/p&gt;

&lt;p&gt;One should not assume that &quot;hidden code&quot; will just work by enabling it.&lt;/p&gt;

&lt;p&gt;Has anyone read through the existing code and verified it looked right before just doing the parser change?  Unfortunately the hardest bugs to find when enabling &quot;dead&quot; code is finding&lt;br/&gt;
the code that is missing due to changes since the dead code was disabled.  I didn&apos;t see anything obvious, I read the code to make sure it was not going to reintroduce db corruption of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4677&quot; title=&quot;SYSCS_COMPRESS_TABLE disables unique constraints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4677&quot;&gt;&lt;del&gt;DERBY-4677&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I would suggest more testing and at least making this feature high for buddy testing before releasing it.  Maybe look at the ddl testing for offline compress table and make sure the tests also work for truncate table.&lt;/p&gt;</comment>
                            <comment id="12907134" author="knutanders" created="Wed, 8 Sep 2010 09:53:16 +0100"  >&lt;p&gt;I was going to ask whether delete triggers were supposed to be fired on truncate, but ij gave me a reasonable answer:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; truncate table t1;&lt;br/&gt;
ERROR XCL49: TRUNCATE TABLE is not permitted on &apos;T1&apos; because it has an enabled DELETE trigger (T1_DEL).&lt;/p&gt;

&lt;p&gt;Similarly, it refuses to truncate a table referenced in a foreign key relationship (unless the table is only referenced by itself):&lt;/p&gt;

&lt;p&gt;ij&amp;gt; truncate table t1;&lt;br/&gt;
ERROR XCL48: TRUNCATE TABLE is not permitted on &apos;T1&apos; because unique/primary key constraints on this table are referenced by enabled foreign key constraints from other tables. &lt;/p&gt;

&lt;p&gt;I&apos;ve added test cases to verify this behaviour (see attached patch tests.diff). I&apos;ll commit the patch when write access to the subversion repository has been restored (it&apos;s currently read-only because of maintenance).&lt;/p&gt;</comment>
                            <comment id="12907147" author="knutanders" created="Wed, 8 Sep 2010 10:47:27 +0100"  >&lt;p&gt;Committed revision 994946.&lt;/p&gt;</comment>
                            <comment id="12907155" author="knutanders" created="Wed, 8 Sep 2010 11:19:34 +0100"  >&lt;p&gt;I noticed that TruncateTableTest was being wrapped with TestConfiguration.sqlAuthorizationDecorator(). I assume that was unintended, since there&apos;s no use of authorization in the test. Removed it and committed revision 994970. Please shout if adding the decorator was indeed intended. Thanks.&lt;/p&gt;</comment>
                            <comment id="12907158" author="knutanders" created="Wed, 8 Sep 2010 11:31:57 +0100"  >&lt;p&gt;Mike, do you think the implementation would be safer (and perhaps also smaller) if we made it a wrapper around import/replace?&lt;/p&gt;</comment>
                            <comment id="12907299" author="mikem" created="Wed, 8 Sep 2010 17:38:48 +0100"  >&lt;p&gt;knut, that sounds like a good approach.  or at least sharing more code in the same file - i would trust the existing code from working features more than the truncate code.   truncate and compress should be able to share all the code that does the new conglomerate stuff, and just skip the load part.  It does share some code which is why it does not have the compress bug.  Eventually&lt;br/&gt;
truncate might have more specific code if we implement the other syntax.&lt;/p&gt;

&lt;p&gt;I&apos;ve been trying to think of what might be missing.  Are there any tests for truncate table with sql roles/permissions.  It may have been added after truncate code was added.&lt;/p&gt;</comment>
                            <comment id="12907342" author="rhillegas" created="Wed, 8 Sep 2010 19:04:27 +0100"  >&lt;p&gt;Re-using the import/replace code will allow truncate to succeed in the following edge case, which currently raises an error:&lt;/p&gt;

&lt;p&gt;o The truncated table is referenced by a foreign key&lt;br/&gt;
o But there are no rows in the referencing table&lt;/p&gt;

&lt;p&gt;It seems to me that the proposal may not be appropriate for an issue flagged for a newcomer. I recommend one of the following:&lt;/p&gt;

&lt;p&gt;o Create a new JIRA for the improvement&lt;br/&gt;
o Remove the &quot;newcomer&quot; flag and negotiate with Eranda about who will do the work&lt;/p&gt;

&lt;p&gt;------------------------------&lt;/p&gt;

&lt;p&gt;Here is a script which demonstrates the different edge-case behavior of the truncate and import/replace code:&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:memory:dummy;create=true&apos;;&lt;/p&gt;

&lt;p&gt;create table deltriggertest_t1(x int);&lt;br/&gt;
create table deltriggertest_t2(y int);&lt;br/&gt;
create trigger deltriggertest_tr after delete on deltriggertest_t1 referencing old as old for each row insert into deltriggertest_t2 values old.x;&lt;/p&gt;

&lt;p&gt;create table foreignkey_t1(x int primary key);&lt;br/&gt;
create table foreignkey_t2(y int references foreignkey_t1);&lt;/p&gt;

&lt;p&gt;insert into deltriggertest_t1( x ) values ( 1 );&lt;/p&gt;

&lt;p&gt;insert into foreignkey_t1 values 1,2;&lt;br/&gt;
insert into foreignkey_t2 values 2;&lt;/p&gt;


&lt;p&gt;call syscs_util.syscs_export_table ( null, &apos;DELTRIGGERTEST_T1&apos;, &apos;z.dat&apos;, null, null, null );&lt;/p&gt;

&lt;p&gt;&amp;#8211; fails because of delete trigger&lt;br/&gt;
truncate table deltriggertest_t1;&lt;br/&gt;
&amp;#8211; fails because of foreign key&lt;br/&gt;
truncate table foreignkey_t1;&lt;/p&gt;

&lt;p&gt;&amp;#8211; fails because of delete trigger&lt;br/&gt;
call syscs_util.syscs_import_table( null, &apos;DELTRIGGERTEST_T1&apos;, &apos;z.dat&apos;, null, null, null,1 );&lt;br/&gt;
&amp;#8211; fails because foreign key is not satisfied&lt;br/&gt;
call syscs_util.syscs_import_table( null, &apos;FOREIGNKEY_T1&apos;, &apos;z.dat&apos;, null, null, null,1 );&lt;/p&gt;

&lt;p&gt;delete from foreignkey_t2;&lt;br/&gt;
delete from foreignkey_t1;&lt;br/&gt;
delete from deltriggertest_t1;&lt;/p&gt;

&lt;p&gt;&amp;#8211; fails because of delete trigger&lt;br/&gt;
truncate table deltriggertest_t1;&lt;br/&gt;
&amp;#8211; fails because of foreign key&lt;br/&gt;
truncate table foreignkey_t1;&lt;/p&gt;

&lt;p&gt;&amp;#8211; fails because of delete trigger&lt;br/&gt;
call syscs_util.syscs_import_table( null, &apos;DELTRIGGERTEST_T1&apos;, &apos;z.dat&apos;, null, null, null,1 );&lt;br/&gt;
&amp;#8211; succeeds&lt;br/&gt;
call syscs_util.syscs_import_table( null, &apos;FOREIGNKEY_T1&apos;, &apos;z.dat&apos;, null, null, null,1 );&lt;/p&gt;</comment>
                            <comment id="12910128" author="eranda" created="Thu, 16 Sep 2010 13:31:01 +0100"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
I feel that it&apos;s a lot to do with this to fix. I can work with the improvement but it take some time to fix the issue. If the this has to be fixed quickly please remove me from the assignee and start work on it.&lt;br/&gt;
thanks &lt;/p&gt;</comment>
                            <comment id="12910170" author="bryanpendleton" created="Thu, 16 Sep 2010 15:44:04 +0100"  >&lt;p&gt;I think that we should open a new JIRA  to address Rick&apos;s 8-sep regarding foreign keys.&lt;/p&gt;

&lt;p&gt;I think we should also open a new JIRA (sub-task) to address documenting the current support.&lt;/p&gt;

&lt;p&gt;And, I think we should mark this issue as resolved, since the basic functionality and tests are in place.&lt;/p&gt;</comment>
                            <comment id="12910196" author="rhillegas" created="Thu, 16 Sep 2010 16:51:47 +0100"  >&lt;p&gt;Thanks, Bryan. I have linked this issue to a documentation follow-up task and to a cleanup task to address the code-reuse concerns. At this point, we support the following standard syntax:&lt;/p&gt;

&lt;p&gt;TRUNCATE TABLE tableName&lt;/p&gt;

&lt;p&gt;If someone has the itch, they are welcome to open a related issue to implement the optional IDENTITY clauses.&lt;/p&gt;</comment>
                            <comment id="12911046" author="eranda" created="Sat, 18 Sep 2010 17:30:55 +0100"  >&lt;p&gt;I like to implement IDENTITY clauses. Where should I start implementing? Is it ij.jj?&lt;/p&gt;</comment>
                            <comment id="12912378" author="knutanders" created="Mon, 20 Sep 2010 08:59:02 +0100"  >&lt;p&gt;Hi Eranda,&lt;br/&gt;
I think sqlgrammar.jj would be a good starting point.&lt;/p&gt;</comment>
                            <comment id="12913027" author="rhillegas" created="Tue, 21 Sep 2010 16:18:27 +0100"  >&lt;p&gt;Attaching derby-268-02-aa-permsTest.diff, which adds a test case to verify that only the owner and the DBO can truncate a table. Committed at subversion revision 999459.&lt;/p&gt;</comment>
                            <comment id="12913170" author="dagw" created="Tue, 21 Sep 2010 19:54:52 +0100"  >&lt;p&gt;I haven&apos;t been following this issue closely, but allow me just a quick question.. Is it well defined what would happen for open cursors (result sets), holdable, not holdable, when a table is attempted truncated? forward-only, scrollable, updatable.. &lt;/p&gt;

&lt;p&gt;Cf SQL 2008, section 14.10 GR 2,3 onwards.&lt;/p&gt;

&lt;p&gt;Note also GR 7: &quot; If no rows are deleted from T, then a completion condition is raised: no data.&quot;&lt;/p&gt;

&lt;p&gt;Do we have/need a functional specification for this feature?&lt;/p&gt;</comment>
                            <comment id="12913209" author="rhillegas" created="Tue, 21 Sep 2010 20:53:50 +0100"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;We don&apos;t have a functional spec for this feature beyond our sense about what it means to subset the brief SQL 2008 language. The concurrency issues you raise are worth probing with some tests. There could be some bugs here. At a high level, TRUNCATE TABLE is implemented as a DDL operation (more specifically as a kind of ALTER TABLE statement). That means that like other DDL, an attempt is made to invalidate other statements which reference the table in question. That would be the point at which those other statements would be able to object that an in-flight cursor blocks the DDL. Thanks.&lt;/p&gt;</comment>
                            <comment id="12914560" author="rhillegas" created="Fri, 24 Sep 2010 18:57:21 +0100"  >&lt;p&gt;Attaching TruncateConcurrency.java. This test program explores how TRUNCATE TABLE interacts with holdable cursors. As a result of running this program, I believe:&lt;/p&gt;

&lt;p&gt;i) Derby&apos;s behavior is consistent with the Standard.&lt;/p&gt;

&lt;p&gt;ii) However, the test uncovers other bugs.&lt;/p&gt;


&lt;p&gt;------------&lt;/p&gt;

&lt;p&gt;The program creates two connections, which may be the same, depending on whether &quot;same&quot; or &quot;different&quot; is specified.&lt;/p&gt;

&lt;p&gt;o Selector - This connection opens a holdable cursor for reading a table.&lt;/p&gt;

&lt;p&gt;o Truncator - This connection truncates the table.&lt;/p&gt;

&lt;p&gt;After creating the table and putting 2 rows in it, the program does the following:&lt;/p&gt;

&lt;p&gt;o Selector opens its holdable cursor (sensitive or insensitive, depending on the argument) then reads a row.&lt;/p&gt;

&lt;p&gt;o If commitSelector is set, Selector commits its transaction.&lt;/p&gt;

&lt;p&gt;o Truncator truncates the table.&lt;/p&gt;

&lt;p&gt;o If commitTruncator is set, Truncator commits its transaction.&lt;/p&gt;

&lt;p&gt;o Selector reads the remaining rows from the table.&lt;/p&gt;


&lt;p&gt;---------&lt;/p&gt;


&lt;p&gt;Here&apos;s how to run the program:&lt;/p&gt;

&lt;p&gt;   java TruncateConcurrency $transaction $sensitivity [ $commit ]*&lt;/p&gt;

&lt;p&gt;   where&lt;/p&gt;

&lt;p&gt;   $transaction  =    same | different (whether the reader and truncator do their work in the same transaction)&lt;br/&gt;
   $sensitivity    =    sensitive | insensitive (whether the reader should use a sensitive or insensitive cursor)&lt;br/&gt;
   $commit       =    commitSelector | commitTruncator&lt;/p&gt;

&lt;p&gt;   If commitSelector is specified, then the Selector commits after&lt;br/&gt;
   reading a row but before the truncation.&lt;/p&gt;

&lt;p&gt;   If commitTruncator is specified, then the Truncator commits&lt;br/&gt;
   immediately after truncation.&lt;/p&gt;

&lt;p&gt;   E.g.:&lt;/p&gt;

&lt;p&gt;   java TruncateConcurrency different sensitive commitTruncator commitSelector&lt;/p&gt;

&lt;p&gt;-----------&lt;/p&gt;

&lt;p&gt;I see the following behavior:&lt;/p&gt;

&lt;p&gt;1) When the cursor is open in the SAME transaction which truncates the table, then the TRUNCATE TABLE command fails. Sensitivity is irrelevant. Whether the transaction commits after reading the first row is also irrelevant.&lt;/p&gt;

&lt;p&gt;That is, in the following experiments, the TRUNCATE TABLE raises &quot;Operation &apos;TRUNCATE TABLE&apos; cannot be performed on object &apos;T&apos; because there is an open ResultSet dependent on that object.&quot;:&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency same sensitive&lt;br/&gt;
java TruncateConcurrency same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency same insensitive&lt;br/&gt;
java TruncateConcurrency same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency same insensitive commitTruncator commitSelector&lt;/p&gt;



&lt;p&gt;2) When the Selector and Truncator are DIFFERENT transactions, then Derby&apos;s behavior is bizarre. Regardless of sensitivity, after truncation the Selector is able to read the last row from the table. Then on the subsequent ResultSet.next() call, Derby misbehaves. There are two kinds of misbehavior here. The sub-cases are distinguished by whether the Truncator committed immediately after truncating the table. Whether the Selector committed after reading its first row is also irrelevant.&lt;/p&gt;

&lt;p&gt;2a) If the Truncator committed immediately after truncating the table, then the Selector trips across an NPE when calling ResultSet.next().&lt;/p&gt;

&lt;p&gt;That is, in the following experiments, the Selector triggers an NPE when calling ResultSet.next():&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency different insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency different insensitive commitTruncator commitSelector&lt;/p&gt;



&lt;p&gt;2b) If the Truncator did NOT commit after truncating the table, then the Selector hangs on ResultSet.next().&lt;/p&gt;

&lt;p&gt;That is, the following experiments hang the Selector when calling ResultSet.next():&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency different sensitive&lt;br/&gt;
java TruncateConcurrency different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency different insensitive&lt;br/&gt;
java TruncateConcurrency different insensitive commitSelector&lt;/p&gt;


&lt;p&gt;------------&lt;/p&gt;

&lt;p&gt;The SQL Standard, part 2, section 14.10 &amp;lt;truncate table statement&amp;gt;, General Rules 2-4 provide guidance for case (1), that is, for when a cursor on the table is open in the same transaction which truncates the table. In this case, Derby refuses to truncate the table and raises an exception. One could quibble about the wording of the exception, but I do not think that is a serious divergence from the Standard. Derby&apos;s behavior in this case seems to be correct to me.&lt;/p&gt;

&lt;p&gt;The Standard does not provide guidance for case (2). I believe that we should fix Derby to behave like case (1). That is, the TRUNCATE TABLE command should raise an exception if there is a cursor open on the table.&lt;/p&gt;</comment>
                            <comment id="12914586" author="knutanders" created="Fri, 24 Sep 2010 19:48:49 +0100"  >&lt;p&gt;FWIW, the described behaviour sounds consistent with that of DROP TABLE. I assume the NPE is similar to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-979&quot; title=&quot;NullPointerException in store when using holdable resultset to get next tuple on a deleted table&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-979&quot;&gt;DERBY-979&lt;/a&gt;? And I also assume that the hang you saw in 2b was a lock wait that timed out after a while?&lt;/p&gt;</comment>
                            <comment id="12915343" author="rhillegas" created="Mon, 27 Sep 2010 16:58:02 +0100"  >&lt;p&gt;Thanks, Knut. Your theory about the hang sounds good to me. Not sure about &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-979&quot; title=&quot;NullPointerException in store when using holdable resultset to get next tuple on a deleted table&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-979&quot;&gt;DERBY-979&lt;/a&gt;. I&apos;m seeing a different stack trace than what&apos;s recorded on that issue (see below). I do see the same stack trace regardless of whether the truncating operation is TRUNCATE TABLE or DROP TABLE. As you note, TRUNCATE TABLE is behaving like DROP TABLE, which makes some sense since they are both implemented using the DDL machinery. Attaching a new rev of TruncateConcurrency.java. This compares the behavior of TRUNCATE TABLE to DROP TABLE and DELETE FROM.&lt;/p&gt;


&lt;p&gt;---------&lt;/p&gt;


&lt;p&gt;Here&apos;s how to run the new rev of the program:&lt;/p&gt;

&lt;p&gt;   java TruncateConcurrency $resetOperation $transaction $sensitivity [ $commit ]*&lt;/p&gt;

&lt;p&gt;   where&lt;/p&gt;

&lt;p&gt;   $resetOperation = truncate | drop | delete (whether the re-initialization operation should be TRUNCATE TABLE, DROP TABLE, or DELETE&lt;br/&gt;
   $transaction  =    same | different (whether the reader and truncator do their work in the same transaction)&lt;br/&gt;
   $sensitivity    =    sensitive | insensitive (whether the reader should use a sensitive or insensitive cursor)&lt;br/&gt;
   $commit       =    commitSelector | commitTruncator&lt;/p&gt;

&lt;p&gt;   If commitSelector is specified, then the Selector commits after&lt;br/&gt;
   reading a row but before the truncation.&lt;/p&gt;

&lt;p&gt;   If commitTruncator is specified, then the Truncator commits&lt;br/&gt;
   immediately after truncation.&lt;/p&gt;

&lt;p&gt;   E.g.:&lt;/p&gt;

&lt;p&gt;   java TruncateConcurrency different sensitive commitTruncator commitSelector&lt;/p&gt;

&lt;p&gt;-----------&lt;/p&gt;

&lt;p&gt;As previously, I see the following behavior for TRUNCATE TABLE:&lt;/p&gt;

&lt;p&gt;1) In the following experiments, the TRUNCATE TABLE raises &quot;Operation &apos;TRUNCATE TABLE&apos; cannot be performed on object &apos;T&apos; because there is an open ResultSet dependent on that object.&quot;:&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate same sensitive&lt;br/&gt;
java TruncateConcurrency truncate same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency truncate same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency truncate same insensitive&lt;br/&gt;
java TruncateConcurrency truncate same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency truncate same insensitive commitTruncator commitSelector&lt;/p&gt;



&lt;p&gt;2) When the Selector and Truncator are DIFFERENT transactions, then Derby misbehaves. There are two kinds of misbehavior here. The sub-cases are distinguished by whether the Truncator committed immediately after truncating the table. Whether the Selector committed after reading its first row is also irrelevant.&lt;/p&gt;

&lt;p&gt;2a) In the following experiments, the Selector triggers an NPE when calling ResultSet.next():&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency truncate different insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate different insensitive commitTruncator commitSelector&lt;/p&gt;

&lt;p&gt;This is the NPE:&lt;/p&gt;

&lt;p&gt;java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.impl.store.access.conglomerate.GenericController.setEstimatedRowCount(GenericController.java:224)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TableScanResultSet.setRowCountIfPossible(TableScanResultSet.java:1325)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BulkTableScanResultSet.getNextRowCore(BulkTableScanResultSet.java:311)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet.getNextRowFromSource(ScrollInsensitiveResultSet.java:801)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet.getNextRowCore(ScrollInsensitiveResultSet.java:518)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:477)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:429)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedResultSet.next(EmbedResultSet.java:373)&lt;br/&gt;
	at TruncateConcurrency.printRow(TruncateConcurrency.java:188)&lt;br/&gt;
	at TruncateConcurrency.justDoIt(TruncateConcurrency.java:97)&lt;br/&gt;
	at TruncateConcurrency.main(TruncateConcurrency.java:49)&lt;/p&gt;



&lt;p&gt;2b) The following experiments hang the Selector when calling ResultSet.next():&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate different sensitive&lt;br/&gt;
java TruncateConcurrency truncate different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency truncate different insensitive&lt;br/&gt;
java TruncateConcurrency truncate different insensitive commitSelector&lt;/p&gt;

&lt;p&gt;-----------&lt;/p&gt;

&lt;p&gt;I see the following behavior for DROP TABLE:&lt;/p&gt;

&lt;p&gt;1&apos;) In the following experiments, the DROP TABLE raises &quot;DROP TABLE&apos; cannot be performed on object &apos;T&apos; because there is an open ResultSet dependent on that object.&quot;:&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop same sensitive&lt;br/&gt;
java TruncateConcurrency drop same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency drop same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency drop same insensitive&lt;br/&gt;
java TruncateConcurrency drop same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency drop same insensitive commitTruncator commitSelector&lt;/p&gt;


&lt;p&gt;2&apos;) When the Selector and Truncator are DIFFERENT transactions, then Derby misbehaves. There are two kinds of misbehavior here. The sub-cases are distinguished by whether the Truncator committed immediately after truncating the table. Whether the Selector committed after reading its first row is also irrelevant.&lt;/p&gt;

&lt;p&gt;2a&apos;) In the following experiments, the Selector triggers an NPE when calling ResultSet.next():&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency drop different insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop different insensitive commitTruncator commitSelector&lt;/p&gt;

&lt;p&gt;This is the NPE:&lt;/p&gt;

&lt;p&gt;java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.impl.store.access.conglomerate.GenericController.setEstimatedRowCount(GenericController.java:224)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TableScanResultSet.setRowCountIfPossible(TableScanResultSet.java:1325)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BulkTableScanResultSet.getNextRowCore(BulkTableScanResultSet.java:311)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet.getNextRowFromSource(ScrollInsensitiveResultSet.java:801)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet.getNextRowCore(ScrollInsensitiveResultSet.java:518)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:477)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:429)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedResultSet.next(EmbedResultSet.java:373)&lt;br/&gt;
	at TruncateConcurrency.printRow(TruncateConcurrency.java:188)&lt;br/&gt;
	at TruncateConcurrency.justDoIt(TruncateConcurrency.java:97)&lt;br/&gt;
	at TruncateConcurrency.main(TruncateConcurrency.java:49)&lt;/p&gt;



&lt;p&gt;2b&apos;) The following experiments hang the Selector when calling ResultSet.next():&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop different sensitive&lt;br/&gt;
java TruncateConcurrency drop different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency drop different insensitive&lt;br/&gt;
java TruncateConcurrency drop different insensitive commitSelector&lt;/p&gt;



&lt;p&gt;-----------&lt;/p&gt;

&lt;p&gt;I see the following behavior for DELETE FROM: All of the test cases terminate without errors. The Selector is able to read the second row regardless of the sensitivity of the cursor and regardless of whether the read takes place in the same transaction as DELETE FROM.&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency delete same sensitive&lt;br/&gt;
java TruncateConcurrency delete same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency delete same insensitive&lt;br/&gt;
java TruncateConcurrency delete same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete same insensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency delete different sensitive&lt;br/&gt;
java TruncateConcurrency delete different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency delete different insensitive&lt;br/&gt;
java TruncateConcurrency delete different insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete different insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete different insensitive commitTruncator commitSelector&lt;/p&gt;</comment>
                            <comment id="12915413" author="rhillegas" created="Mon, 27 Sep 2010 19:24:34 +0100"  >&lt;p&gt;Attaching a new rev of TruncateConcurrency. The previous version was always committing the Selector after reading the first row. This version makes the commitSelector option function correctly. Now if the Selector does not commit, I see that the Truncator blocks waiting for a lock if the Truncator is working in a separate transaction.&lt;/p&gt;

&lt;p&gt;This fix does not affect the following conclusions:&lt;/p&gt;

&lt;p&gt;i) The behavior of TRUNCATE TABLE is still consistent with the SQL Standard.&lt;/p&gt;

&lt;p&gt;ii) TRUNCATE TABLE still behaves like DROP TABLE.&lt;/p&gt;


&lt;p&gt;Here are the results after fixing this defect:&lt;/p&gt;

&lt;p&gt;------------ Re-initialization command is TRUNCATE TABLE -------------&lt;/p&gt;

&lt;p&gt;1) TRUNCATE TABLE command raises &quot;Operation &apos;TRUNCATE TABLE&apos; cannot be performed on object &apos;T&apos; because there is an open ResultSet dependent on that object.&quot;&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate same sensitive&lt;br/&gt;
java TruncateConcurrency truncate same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency truncate same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency truncate same insensitive&lt;br/&gt;
java TruncateConcurrency truncate same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency truncate same insensitive commitTruncator commitSelector&lt;/p&gt;


&lt;p&gt;2) TRUNCATE TABLE command hangs waiting for a lock&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate different sensitive&lt;br/&gt;
java TruncateConcurrency truncate different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency truncate different insensitive&lt;br/&gt;
java TruncateConcurrency truncate different insensitive commitTruncator&lt;/p&gt;


&lt;p&gt;3) Selector hangs trying to read the second row&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency truncate different insensitive commitSelector&lt;/p&gt;


&lt;p&gt;4) Selector trips over an NPE trying to read the second row&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency truncate different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency truncate different insensitive commitTruncator commitSelector&lt;/p&gt;




&lt;p&gt;------------ Re-initialization command is DROP TABLE -------------&lt;/p&gt;

&lt;p&gt;1&apos;) DROP TABLE raises &quot;Operation &apos;DROP TABLE&apos; cannot be performed on object &apos;T&apos; because there is an open ResultSet dependent on that object.&quot;&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop same sensitive&lt;br/&gt;
java TruncateConcurrency drop same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency drop same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency drop same insensitive&lt;br/&gt;
java TruncateConcurrency drop same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency drop same insensitive commitTruncator commitSelector&lt;/p&gt;


&lt;p&gt;2&apos;) DROP TABLE command hangs waiting for a lock&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop different sensitive&lt;br/&gt;
java TruncateConcurrency drop different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency drop different insensitive&lt;br/&gt;
java TruncateConcurrency drop different insensitive commitTruncator&lt;/p&gt;


&lt;p&gt;3&apos;) Selector hangs trying to read the second row&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency drop different insensitive commitSelector&lt;/p&gt;


&lt;p&gt;4&apos;) Selector trips over an NPE trying to read the second row&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency drop different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency drop different insensitive commitTruncator commitSelector&lt;/p&gt;


&lt;p&gt;------------ Re-initialization command is DELETE FROM -------------&lt;/p&gt;

&lt;p&gt;The Selector successfully reads both rows&lt;/p&gt;

&lt;p&gt;java TruncateConcurrency delete same sensitive&lt;br/&gt;
java TruncateConcurrency delete same sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete same sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete same sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency delete same insensitive&lt;br/&gt;
java TruncateConcurrency delete same insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete same insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete same insensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency delete different sensitive&lt;br/&gt;
java TruncateConcurrency delete different sensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete different sensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete different sensitive commitTruncator commitSelector&lt;br/&gt;
java TruncateConcurrency delete different insensitive&lt;br/&gt;
java TruncateConcurrency delete different insensitive commitTruncator&lt;br/&gt;
java TruncateConcurrency delete different insensitive commitSelector&lt;br/&gt;
java TruncateConcurrency delete different insensitive commitTruncator commitSelector&lt;/p&gt;</comment>
                            <comment id="12915749" author="rhillegas" created="Tue, 28 Sep 2010 14:55:54 +0100"  >&lt;p&gt;Attaching derby-268-03-aa-npe.diff. This patch fixes the NPE seen in the TruncatorConcurrency experiments when the re-initialization statement is TRUNCATE TABLE or DROP TABLE. I am running regression tests now.&lt;/p&gt;

&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;----------&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/store/access/conglomerate/GenericController.java&lt;/p&gt;

&lt;p&gt;The NPE occurred while trying to update the statistics for a conglomerate which has been dropped. The fix is to not update the statistics if the conglomerate no longer exists.&lt;/p&gt;

&lt;p&gt;----------&lt;/p&gt;

&lt;p&gt;M      java/testing/org/apache/derbyTesting/functionTests/tests/lang/TruncateTableTest.java&lt;/p&gt;

&lt;p&gt;Added a test case to track this fix.&lt;/p&gt;</comment>
                            <comment id="12915798" author="rhillegas" created="Tue, 28 Sep 2010 16:57:18 +0100"  >&lt;p&gt;Tests passed cleanly for me. Committed derby-268-03-aa-npe.diff at subversion revision 1002232.&lt;/p&gt;</comment>
                            <comment id="12915881" author="eranda" created="Tue, 28 Sep 2010 20:01:24 +0100"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
Considering your previous comment,&lt;br/&gt;
Where we can execute &quot;ALTER TABLE tableName ALTER COLUMN RESTART WITH initialValue &quot;  after truncating table? Is it only from ij.java(by adding a line like &quot;aStatement.execute(&quot;ALTER TABLE t1 ALTER COLUMN a RESTART WITH 0&quot;)&quot; to ij.jj)?&lt;br/&gt;
thanks&lt;/p&gt;</comment>
                            <comment id="12916134" author="rhillegas" created="Wed, 29 Sep 2010 14:04:15 +0100"  >&lt;p&gt;Hi Eranda,&lt;/p&gt;

&lt;p&gt;No need to touch ij, all of this code should be in the engine. The good news is that both TRUNCATE TABLE and ALTER TABLE ALTER COLUMN RESTART are handled by the AlterTableConstantAction machinery at run time. If I were tackling this, I would first try something along these lines:&lt;/p&gt;

&lt;p&gt;o AlterTableNode.bindStatement() will need to build a tableElementList structure for TRUNCATE TABLE, describing the identity column which needs to be re-initialized. For ALTER TABLE ALTER COLUMN RESTART, that tableElementList is created by the parser.&lt;/p&gt;

&lt;p&gt;o That tableElementList structure will then be picked up by AlterTableNode.prepConstantAction and turned into a ColumnInfo array when the run time structures are generated for TRUNCATE TABLE. The ColumnInfo[] structure should contain enough information to describe the change to the identity column.&lt;/p&gt;

&lt;p&gt;o The column info structure will then be processed by AlterTableConstantAction.executeConstantAction() at run time.&lt;/p&gt;

&lt;p&gt;You may need to tweak the code a bit to get this to function, but I think this basic processing flow should work. Please ask more questions if this is too cryptic.&lt;/p&gt;

&lt;p&gt;Hope this helps,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12916628" author="rhillegas" created="Thu, 30 Sep 2010 20:52:21 +0100"  >&lt;p&gt;Dag raised the following issue: The 2008 SQL Standard (part 2, section 14.10 &amp;lt;truncate table statement&amp;gt;, General Rule 7) says that if the table was empty to begin with, then TRUNCATE TABLE should raise a &quot;no data&quot; completion condition. Note that the Standard says that the same completion condition should be raised by INSERT statements which end up inserting no rows: see section 14.11 &amp;lt;insert statement&amp;gt;, General Rule 9.&lt;/p&gt;

&lt;p&gt;Completion conditions are represented as SQLStates. I do not see where these completion conditions are modelled in JDBC. In any event, Derby does not do anything special for empty INSERTs. I see no reason to introduce special machinery to model this clause of the TRUNCATE standard. We can revisit this topic if we decide to build completion conditions for INSERT statements.&lt;/p&gt;</comment>
                            <comment id="12917536" author="kristwaa" created="Mon, 4 Oct 2010 10:46:39 +0100"  >&lt;p&gt;Out of curiosity, is TRUNCATE TABLE returning a row count?&lt;/p&gt;</comment>
                            <comment id="12917584" author="rhillegas" created="Mon, 4 Oct 2010 14:09:02 +0100"  >&lt;p&gt;Hi Kristian,&lt;/p&gt;

&lt;p&gt;Connection.prepareStatement( &quot;truncate table t&quot; ).executeUpdate() returns 0, regardless of how many rows are in the table, just as is done by Connection.prepareStatement( &quot;drop table t&quot; ).executeUpdate(). Regards.&lt;/p&gt;</comment>
                            <comment id="12917632" author="dagw" created="Mon, 4 Oct 2010 16:03:56 +0100"  >&lt;p&gt;&amp;gt; I see no reason to introduce special machinery to model this clause of the TRUNCATE standard. We can revisit &amp;gt; this topic if we decide to build completion conditions for INSERT statements.&lt;/p&gt;

&lt;p&gt;Sounds good to me.&lt;/p&gt;</comment>
                            <comment id="12919643" author="eranda" created="Sun, 10 Oct 2010 19:48:28 +0100"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
Sorry for being late to reply. &lt;br/&gt;
I used &quot;TableElementList tableElementList = (TableElementList) nodeFactory.getNode(C_NodeTypes.TABLE_ELEMENT_LIST, getContextManager());&quot;&lt;br/&gt;
to get the TableElementList inside of the truncateTableStatement() in the SQLParser but it didn&apos;t give the actual results of the table which I created. &lt;br/&gt;
For example it gives the number of the columns 0 and when I try to get the first element it gives an exception. Any idea why above doesn&apos;t return the correct TableElementList?&lt;br/&gt;
Also here I am attaching the changes I did.&lt;br/&gt;
thanks&lt;/p&gt;</comment>
                            <comment id="12919823" author="rhillegas" created="Mon, 11 Oct 2010 14:48:03 +0100"  >&lt;p&gt;Hi Eranda,&lt;/p&gt;

&lt;p&gt;You are on the right track. sqlgrammar.jj is the right place to start to see how the TableElementList is constructed. But at parse() time you don&apos;t have enough information to construct the list for a TRUNCATE TABLE statement. You only have that information at bind() time. That is because it is the responsibility of the bind() phase to look at the metadata to fill in missing facts about the table.&lt;/p&gt;

&lt;p&gt;The nodeFactory.getNode() call cited above will give you an empty TableElementList. You then need to put one TableElementNode on that list, a TableElementNode which represents the action ALTER TABLE ALTER COLUMN...RESTART WITH. To see how to make that node, look in sqlgrammar.jj for the string &quot;&amp;lt;RESTART&amp;gt; &amp;lt;WITH&amp;gt;&quot;.&lt;/p&gt;

&lt;p&gt;The TableElementList itself should be constructed in AlterTableNode.bindStatement() once you know that you are dealing with a TRUNCATE TABLE statement.&lt;/p&gt;

&lt;p&gt;Hope this helps,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12933483" author="eranda" created="Thu, 18 Nov 2010 17:13:01 +0000"  >&lt;p&gt;HI Rick,&lt;br/&gt;
I have a problem with what is the purpose of creating a StatementNode by executing&lt;br/&gt;
nodeFactory.getNode(C_NodeTypes.ALTER_TABLE_NODE,tableName, getContextManager();. &lt;br/&gt;
And how this StatementNode is helping to execute. &lt;br/&gt;
thanks&lt;/p&gt;</comment>
                            <comment id="12933558" author="rhillegas" created="Thu, 18 Nov 2010 20:52:12 +0000"  >&lt;p&gt;Hi Eranda,&lt;/p&gt;

&lt;p&gt;I am not sure where you are in the code now, so I may not be answering your question. If you can give me more context, I may be more helpful. For TRUNCATE TABLE, the AlterTableNode is created by the parser. This is the basic processing flow today:&lt;/p&gt;

&lt;p&gt;o The parser digests the TRUNCATE TABLE statement and creates an AlterTableNode.&lt;/p&gt;

&lt;p&gt;o Then the AlterTableNode is bound. That is, object names are looked up in the system catalogs (in this case, the named object in question is the table). As necessary, metadata is copied out of the system catalogs into in-memory structures in the parse tree.&lt;/p&gt;

&lt;p&gt;o Then the AlterTableNode is optimized. Since this is a DDL statement, there is nothing to do during this phase.&lt;/p&gt;

&lt;p&gt;o An executable plan is then generated from the AlterTableNode. This phase is called code-generation. The executable plan is an AlterTableConstantAction.&lt;/p&gt;

&lt;p&gt;o At run-time, the AlterTableConstantAction performs the truncation.&lt;/p&gt;

&lt;p&gt;Here&apos;s what I think the code will end up doing, at a high level:&lt;/p&gt;

&lt;p&gt;o At parse time, you will detect the RESTART IDENTITY clause and set some flag in the AlterTableNode.&lt;/p&gt;

&lt;p&gt;o At bind time, you will see that flag. That will cause you to look up the column metadata for the table, find the identity column, then build a TableElementNode which represents the instruction to re-initialize the identity column.&lt;/p&gt;

&lt;p&gt;o At code-generation time, you will turn the TableElementNode into a ColumnInfo which represents the same information. The TableElementNode is a compile-time structure. The ColumnInfo is a runtime structure. What you are doing here is translating compile-time structures into runtime structures.&lt;/p&gt;

&lt;p&gt;o At runtime, the AlterTableConstantAction will notice the ColumnInfo structure and reinitialize the identity column.&lt;/p&gt;

&lt;p&gt;I hope I am not confusing you by answering the wrong question. Keep asking questions so that I can better understand what&apos;s puzzling you.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12982034" author="eranda" created="Sat, 15 Jan 2011 06:35:09 +0000"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
Thanks Rick the previous comment was exactly describing what I want to know.&lt;br/&gt;
I did some work on this and came up with a patch which is not fully completed.  &lt;br/&gt;
I use the following method to get the tableElementList. But it gives a TableElementList, which has zero elements.&lt;/p&gt;

&lt;p&gt;TableElementList tableElementList = (TableElementList) nodeFactory.getNode(&lt;br/&gt;
                                            C_NodeTypes.TABLE_ELEMENT_LIST,&lt;br/&gt;
                                            getContextManager());&lt;/p&gt;

&lt;p&gt;Is it a incorrect way to get the table element list. &lt;br/&gt;
And  please take a look at the code and let me know your ideas.&lt;br/&gt;
thanks&lt;/p&gt;</comment>
                            <comment id="12983236" author="rhillegas" created="Tue, 18 Jan 2011 15:52:24 +0000"  >&lt;p&gt;Hi Eranda,&lt;/p&gt;

&lt;p&gt;That is the right code for creating a table element list (if there isn&apos;t one already). Now you just need to put a node on that list. The node will represent the instruction to restart the identity column at a new value. Here&apos;s how sqlgrammar.jj constructs that node when it sees an ALTER TABLE ALTER COLUMN...RESTART WITH... statement:&lt;/p&gt;

&lt;p&gt;	&amp;lt;RESTART&amp;gt; &amp;lt;WITH&amp;gt; autoIncrementRestartWith = exactNumber()&lt;/p&gt;
	{
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementRestartWith;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE;
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
						columnName,
						null, null, autoIncrementInfo,
						getContextManager());
	}

&lt;p&gt;Hope this helps,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12984605" author="eranda" created="Fri, 21 Jan 2011 08:11:46 +0000"  >&lt;p&gt;Hi Rick,&lt;br/&gt;
But here we cannot use any column name since we do not know the column names of the identity columns. &lt;br/&gt;
Are there any method which we can get all the column information at SQLParser (sqlgrammer.jj)?&lt;br/&gt;
thanks&lt;br/&gt;
Eranda&lt;/p&gt;</comment>
                            <comment id="12993589" author="rhillegas" created="Fri, 11 Feb 2011 17:16:29 +0000"  >&lt;p&gt;Hi Eranda,&lt;/p&gt;

&lt;p&gt;The idea is that the table element representing the RESTART action should be added at bind() time, not at parse() time. All that happens at parse() time is that you mark the AlterTableNode to note that the user has requested RESTART. The new tableElement should be added at bind() time. At bind() time you will have access to all of the metadata you need and you should be able to find the name of the identity column in structures hanging off the TableDescriptor. You should build the tableElement in AlterTableNode.bind(). See my comment on 2010-11-18 for the processing flow.&lt;/p&gt;

&lt;p&gt;Hope this helps,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13085878" author="myrna" created="Tue, 16 Aug 2011 19:12:55 +0100"  >&lt;p&gt;Eranda, are you still working on this issue?&lt;br/&gt;
If not, we should unassign you, and probably close this issue and split off a separate issue to support the identityBehavior functionality.&lt;/p&gt;</comment>
                            <comment id="13096727" author="eranda" created="Sat, 3 Sep 2011 18:28:09 +0100"  >&lt;p&gt;Hi Myrna,&lt;br/&gt;
I am not working on this issue for now. You may close this issue and split&lt;br/&gt;
off a separate issue to support the identityBehavior functionality. Then I&lt;br/&gt;
can later see into it.&lt;br/&gt;
thanks&lt;/p&gt;</comment>
                            <comment id="13098164" author="myrna" created="Tue, 6 Sep 2011 18:02:30 +0100"  >&lt;p&gt;Support for the basic TRUNCATE TABLE command went into 10.7.1.1. I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5403&quot; title=&quot;implement further syntax for truncate table support - identityBehavior clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5403&quot;&gt;DERBY-5403&lt;/a&gt; for implementation of the identityBehavior clause.&lt;/p&gt;</comment>
                            <comment id="13685364" author="knutanders" created="Mon, 17 Jun 2013 10:19:48 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12474291">DERBY-4802</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12473034">DERBY-4788</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12521469">DERBY-5403</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12387118">DERBY-3352</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12474290">DERBY-4801</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12468444" name="Derby-268.diff" size="5410" author="eranda" created="Sat, 15 Jan 2011 06:35:09 +0000"/>
                            <attachment id="12453869" name="Derby-268.diff" size="5194" author="eranda" created="Sat, 4 Sep 2010 16:24:50 +0100"/>
                            <attachment id="12455736" name="TruncateConcurrency.java" size="9135" author="rhillegas" created="Mon, 27 Sep 2010 19:24:34 +0100"/>
                            <attachment id="12455667" name="TruncateConcurrency.java" size="8952" author="rhillegas" created="Mon, 27 Sep 2010 16:58:02 +0100"/>
                            <attachment id="12455504" name="TruncateConcurrency.java" size="7924" author="rhillegas" created="Fri, 24 Sep 2010 18:57:21 +0100"/>
                            <attachment id="12456810" name="changes.diff" size="2791" author="eranda" created="Sun, 10 Oct 2010 19:48:28 +0100"/>
                            <attachment id="12454022" name="derby-268-01-ab-enableForInsaneBuilds.diff" size="5229" author="rhillegas" created="Tue, 7 Sep 2010 16:23:28 +0100"/>
                            <attachment id="12455148" name="derby-268-02-aa-permsTest.diff" size="7425" author="rhillegas" created="Tue, 21 Sep 2010 16:18:27 +0100"/>
                            <attachment id="12455831" name="derby-268-03-aa-npe.diff" size="3746" author="rhillegas" created="Tue, 28 Sep 2010 14:55:54 +0100"/>
                            <attachment id="12454084" name="tests.diff" size="3767" author="knutanders" created="Wed, 8 Sep 2010 09:53:16 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 11 May 2005 05:48:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29463</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10423"><![CDATA[Newcomer]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0fbj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36300</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>