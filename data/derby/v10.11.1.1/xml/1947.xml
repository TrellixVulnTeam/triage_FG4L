<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:17:54 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1947/DERBY-1947.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1947] OutOfMemoryError after repeated calls to boot and shutdown a database</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1947</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I came across this OOM issue while running some system tests involving&lt;br/&gt;
backup and restore against  Derby. The test is expected to run forever but&lt;br/&gt;
using the default heap space it runs into OOM within 2 days. I earlier mentioned about this&lt;br/&gt;
in my reply to the 10.2.1.6 vote - &lt;a href=&quot;http://www.nabble.com/Re%3A--VOTE--10.2.1.6-release-p6650528.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Re%3A--VOTE--10.2.1.6-release-p6650528.html&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Also there has been some discussions on the list on the related topic:&lt;br/&gt;
&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-23&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-23&lt;/a&gt; and&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/question-about-shutdown-tf2300504.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/question-about-shutdown-tf2300504.html&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Basic Analysis:&lt;br/&gt;
--------------------&lt;/p&gt;

&lt;p&gt;Wrote a simple Java app (attached to this issue) that booted and shutdown the same &lt;br/&gt;
database multiple times. Depending on the heapsize the program ran into the&lt;br/&gt;
OOM at some point, as expected. Some heap dump analysis using the IBM HeapAnalyzer &lt;br/&gt;
and revealed that the HashSet (allContexts) within org.apache.derby.iapi.services.context.ContextService &lt;br/&gt;
class seemed to be location of the leak (snapshot of the heapanalysis attached).&lt;/p&gt;

&lt;p&gt;A little bit of debugging shows that:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for every:connection two ContextManager objects (say, cm1, cm2) are added to the HashSet&lt;/li&gt;
	&lt;li&gt;for every shutdown a new ContextManager object (say, cm3) is added and two objects are removed&lt;/li&gt;
	&lt;li&gt;the object removed are cm2 and cm3 - in that sequence&lt;/li&gt;
	&lt;li&gt;but the object cm1 gets left behind&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This happens for every connect/shutdown sequence and since one of the ContextManager objects added to the &lt;br/&gt;
HashSet is not removed as a part of the cleanup, it contributes to growth in memory usage, hence&lt;br/&gt;
an OOM eventually.&lt;/p&gt;

&lt;p&gt;For example:&lt;br/&gt;
============&lt;br/&gt;
A 64M heap could allow about 1107 iterations of connect/shutdown only before running into OOM and &lt;br/&gt;
created 1108 un-used ContextManager objects in the memory.&lt;/p&gt;

&lt;p&gt;java -Xmx64M testEmbedAndClient&lt;br/&gt;
++++Debug: add() Size of allContexts HashSet obj= 1&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 0&lt;br/&gt;
++++Debug: add() Size of allContexts HashSet obj= 1&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 0&lt;br/&gt;
++++Debug: add() Size of allContexts HashSet obj= 1&lt;br/&gt;
++++Debug: add() Size of allContexts HashSet obj= 2&lt;/p&gt;

&lt;p&gt;==== Database booted in embedded ====&lt;/p&gt;

&lt;p&gt;++++Debug: add() Size of allContexts HashSet obj= 3&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 2&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 1&lt;/p&gt;

&lt;p&gt;==== Shutdown complete in embedded ====&lt;/p&gt;

&lt;p&gt;++++Debug: add() Size of allContexts HashSet obj= 2&lt;br/&gt;
++++Debug: add() Size of allContexts HashSet obj= 3&lt;/p&gt;

&lt;p&gt;==== Database booted in embedded ====&lt;/p&gt;

&lt;p&gt;++++Debug: add() Size of allContexts HashSet obj= 4&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 3&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 2&lt;br/&gt;
..&lt;br/&gt;
..&lt;br/&gt;
..&lt;br/&gt;
==== Database booted in embedded ====&lt;/p&gt;

&lt;p&gt;++++Debug: add() Size of allContexts HashSet obj= 1109&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 1108&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 1107&lt;/p&gt;

&lt;p&gt;==== Shutdown complete in embedded ====&lt;/p&gt;

&lt;p&gt;++++Debug: add() Size of allContexts HashSet obj= 1108&lt;br/&gt;
++++Debug: add() Size of allContexts HashSet obj= 1109&lt;br/&gt;
----Debug: remove() Size of allContexts HashSet obj= 1108&lt;br/&gt;
java.sql.SQLException: Failed to start database &apos;testdb&apos;, see the next exception&lt;br/&gt;
 for details.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:89)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:95)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:174)&lt;/p&gt;

&lt;p&gt;        at org.apache.derby.impl.jdbc.EmbedConnection.newSQLException(EmbedConnection.java:1985)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.bootDatabase(EmbedConnection.java:1649)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.&amp;lt;init&amp;gt;(EmbedConnection.java:223)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection30.&amp;lt;init&amp;gt;(EmbedConnection30.java:73)&lt;br/&gt;
        at org.apache.derby.jdbc.Driver30.getNewEmbedConnection(Driver30.java:74)&lt;br/&gt;
        at org.apache.derby.jdbc.InternalDriver.connect(InternalDriver.java:210)&lt;/p&gt;

&lt;p&gt;----Debug: remove() Size of allContexts HashSet obj= 1107&lt;br/&gt;
        at org.apache.derby.jdbc.AutoloadedDriver.connect(AutoloadedDriver.java:117)&lt;br/&gt;
        at java.sql.DriverManager.getConnection(DriverManager.java:525)&lt;br/&gt;
        at java.sql.DriverManager.getConnection(DriverManager.java:193)&lt;br/&gt;
        at testEmbedAndClient.testInEmbedded(testEmbedAndClient.java:40)&lt;br/&gt;
        at testEmbedAndClient.main(testEmbedAndClient.java:19)&lt;br/&gt;
java.lang.OutOfMemoryError: Java heap space&lt;/p&gt;

&lt;p&gt;OOM happened after 1107 iterations&lt;/p&gt;
</description>
                <environment>Any</environment>
        <key id="12352818">DERBY-1947</key>
            <summary>OutOfMemoryError after repeated calls to boot and shutdown a database</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="kartha">Rajesh Kartha</reporter>
                        <labels>
                    </labels>
                <created>Tue, 10 Oct 2006 04:43:30 +0100</created>
                <updated>Fri, 16 Nov 2007 15:13:36 +0000</updated>
                            <resolved>Mon, 23 Apr 2007 23:47:25 +0100</resolved>
                                    <version>10.0.2.0</version>
                    <version>10.0.2.1</version>
                    <version>10.1.1.0</version>
                    <version>10.1.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Services</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12441042" author="kartha" created="Tue, 10 Oct 2006 04:45:26 +0100"  >&lt;p&gt;Attaching the files I mentioned in the description of this issue.&lt;/p&gt;</comment>
                            <comment id="12483854" author="dagw" created="Sat, 24 Mar 2007 16:32:21 +0000"  >&lt;p&gt;My analysis of this problem:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;When EmbedConnection#close is called from testEmbedAndClient.java:50, the&lt;br/&gt;
  call fails to clean up the connection properly, since the call to the&lt;br/&gt;
  private EmbedConnection#close(StandardException) never happens.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  This is due to the fact that the public close method first checks if&lt;br/&gt;
  the connection is already closed via a call to&lt;br/&gt;
  EmbedConnection#isClosed(). If so, close just returns,&lt;/p&gt;

&lt;p&gt;  EmbedConnection#isClosed() returns true even though the connection is still&lt;br/&gt;
  marked as active, because the underlying database has been shut down. This&lt;br/&gt;
  fact makes TransactionResourceImpl#isActive() return false.&lt;/p&gt;

&lt;p&gt;  Now, the connection objects and the TransactionResourceImpl will eventually&lt;br/&gt;
  be garbage collected, but the ContextManager object owned by&lt;br/&gt;
  TransactionResourceImpl, will not, leading to the memory leak.  This is&lt;br/&gt;
  because the ContextManager object is referenced from the HashSet&lt;br/&gt;
  &apos;allContexts&apos; of the ContextService.&lt;/p&gt;

&lt;p&gt;  Normally, the context manager object is removed from &apos;allContexts&apos; when the&lt;br/&gt;
  EmbedConnection#close(exceptionclose) calls&lt;br/&gt;
  TransactionResourceImpl#cleanupOnError. However, it does not happen here&lt;br/&gt;
  since isClosed returns true, so EmbedConnection#close() never gets&lt;br/&gt;
  to call EmbedConnection#close(exceptionclose).&lt;/p&gt;

&lt;p&gt;  Modifying the repro to never close the connection object, I also see&lt;br/&gt;
  the leak, since EmbedConnection#finalize similarly fails to call&lt;br/&gt;
  EmbedConnection#close(exceptionclose) when isClosed() returns true.&lt;/p&gt;

&lt;p&gt;  More detail (feel free to skip &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  TransactionResourceImpl#cleanupOnError, in turn, calls&lt;br/&gt;
  ContextManager#cleanupOnError which, when popping its stack of contexts&lt;br/&gt;
  finally calls the stack&apos;s bottom SystemContext#cleanupOnError, which again&lt;br/&gt;
  makes this call on line 62:&lt;/p&gt;

&lt;p&gt;      :&lt;br/&gt;
      getContextManager().owningCsf.removeContext(getContextManager());&lt;br/&gt;
      :&lt;/p&gt;

&lt;p&gt;  which releases the context manager from &apos;allContexts&apos; so it can be garbage&lt;br/&gt;
  collected.&lt;/p&gt;


&lt;ul&gt;
	&lt;li&gt;I have made a patch which makes the repro (and the modified repro I&lt;br/&gt;
  mentioned) work without running out of space: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-1.
{diff,stat}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  It modifies EmbedConnection#close to clean up in the case described&lt;br/&gt;
  above.&lt;/p&gt;

&lt;p&gt;  It also adds a finalizer method to TransactionResourceImpl which&lt;br/&gt;
  calls ContextManager#cleanupOnError with an argument of&lt;br/&gt;
  StandardException.closeException(), if not done already.  This&lt;br/&gt;
  catches the case when no close is called on the connection.  This&lt;br/&gt;
  change would make the leak go away on its own for both repro cases,&lt;br/&gt;
  but I added the change to EmbedConnection#close also, since it&lt;br/&gt;
  purports to release database resources in its Javadoc.&lt;/p&gt;

&lt;p&gt;  So, when the connection is closed or garbage collected, the&lt;br/&gt;
  ContextManager will be cleaned up as well, and the leak is plugged.&lt;/p&gt;

&lt;p&gt;  suites.All and derbyall ran without incident on Sun JDK 1.6, Solaris&lt;br/&gt;
  10/x86.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;There is a related issue, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2480&quot; title=&quot;DriverManager.getConnection leaks memory when connecting to a non-existent database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2480&quot;&gt;&lt;del&gt;DERBY-2480&lt;/del&gt;&lt;/a&gt;, for which Jeff Clary has&lt;br/&gt;
  produced a patch. They overlap, in that that both patches makes a&lt;br/&gt;
  changes to EmbedConnection#close, so we need to reconcile them for&lt;br/&gt;
  that method. &lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12483856" author="dagw" created="Sat, 24 Mar 2007 16:41:56 +0000"  >&lt;p&gt;Please disregard the paragraph quoted below in my previous comment, the&lt;br/&gt;
correct version is given below (the original text reflects my first attempt&lt;br/&gt;
at the patch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; It also adds a finalizer method to TransactionResourceImpl which&lt;br/&gt;
&amp;gt; calls ContextManager#cleanupOnError with an argument of&lt;br/&gt;
&amp;gt; StandardException.closeException(), if not done already. &lt;/p&gt;

&lt;p&gt;It also adds a finalizer method to EmbedConnection which&lt;br/&gt;
calls TransactionResourceImpl#cleanupOnError with an argument of&lt;br/&gt;
StandardException.closeException(), if not done already.  &lt;/p&gt;</comment>
                            <comment id="12483951" author="bryanpendleton" created="Sun, 25 Mar 2007 16:32:10 +0100"  >&lt;p&gt;It seems like it would be nice if, instead of adding more code to&lt;br/&gt;
EmbedConnection.close(), we could instead just have EmbedConnection.close()&lt;br/&gt;
call EmbedConnection.close(StandardException), and have all the&lt;br/&gt;
EmbedConnection closing logic in one place. Right now there seems to&lt;br/&gt;
be logic in two EmbedConnection.close() methods, and also in the&lt;br/&gt;
finalize() method. Can it all be moved to the one close(exception) method&lt;br/&gt;
and have the other two be 1-line wrappers?&lt;/p&gt;
</comment>
                            <comment id="12484614" author="dagw" created="Tue, 27 Mar 2007 23:00:36 +0100"  >&lt;p&gt;Thanks for looking at this, Bryan!&lt;/p&gt;

&lt;p&gt;Uploading a modified patch &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-2 (supercedes &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-1)&lt;br/&gt;
which addresses Bryan&apos;s comment, although I did not &lt;b&gt;quite&lt;/b&gt; manage to&lt;br/&gt;
make it a one-liner &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I also noticed that the isClosed() method changes the internal state&lt;br/&gt;
variable &apos;active&apos;, thwarting the logic needed to get the cleanup done,&lt;br/&gt;
so I removed the call to setInactive() from isClosed(). I believe this&lt;br/&gt;
is safe. [Alterately, one call do all the cleanup needed from inside&lt;br/&gt;
isClosed() if the underlying transaction is not active.]&lt;/p&gt;

&lt;p&gt;I further simplified the finalizer by removing the test for rootConnection&lt;br/&gt;
since this is done inside close(StandardException) anyway.&lt;/p&gt;

&lt;p&gt;I verified the patch against the repro again, including the modified one&lt;br/&gt;
I described for the previous patch. I did not add a new test for this issue.&lt;/p&gt;

&lt;p&gt;I ran derbyall and suites.All again with the patch against svn 521401&lt;br/&gt;
with successfully (modulo the often seen dblook error in derbyall),&lt;br/&gt;
Solaris 10/x86, Sun JDK1.6.&lt;/p&gt;</comment>
                            <comment id="12484667" author="bryanpendleton" created="Wed, 28 Mar 2007 02:15:52 +0100"  >&lt;p&gt;Hi Dag, the new patch looks very good to me. This sort of close&lt;br/&gt;
logic always seems to be a bit finicky, but I think you&apos;ve got it&lt;br/&gt;
nicely packaged now.&lt;/p&gt;</comment>
                            <comment id="12489576" author="dagw" created="Wed, 18 Apr 2007 01:04:21 +0100"  >&lt;p&gt;I was getting ready to commit the patch for this issue, but then I&lt;br/&gt;
updated my trunk and found that the following newly&lt;br/&gt;
introduced/converted JUnit test makes Derby deadlock when the patch&lt;br/&gt;
(&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-2) is active:&lt;/p&gt;

&lt;p&gt;  ProcedureInTriggerTest&lt;/p&gt;

&lt;p&gt;It looks like a deadlock in the VM (see also enclosed stacks of&lt;br/&gt;
involved threads) caused by the patch&apos;s use of finalizer code which&lt;br/&gt;
leads to synchronization, and I am at a loss presently for how to&lt;br/&gt;
resolve this best.&lt;/p&gt;

&lt;p&gt;What seems to happen is this:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;In ProcedureInTriggerTest:388, a call to Stement#execute is performed:&lt;br/&gt;
   &amp;gt; s.execute(&quot;create trigger select_from_trig_table no cascade before &quot; + &lt;br/&gt;
                               &quot;delete on t1 for each STATEMENT call proc_reads_sql(1)&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  This call synchronizes on the current (root) connection object.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;At this time I believe there are still two nested connection objects&lt;br/&gt;
  from previous statements (the test uses triggers and stored&lt;br/&gt;
  procedures called from them), which are no longer referenced but for&lt;br/&gt;
  whom the finalizer has yet to run (not yet garbage collected).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Now, the CreateTriggerConstantAction#executeConstantAction in line&lt;br/&gt;
  275 uses the Dependency manager to send an invalidate to the trigger&lt;br/&gt;
  table so that DML statements on this table will be recompiled.  (see&lt;br/&gt;
  stack of thread &quot;main&quot; in attachment&lt;br/&gt;
  ProcedureInTriggerTest-threadstacks.txt).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;As a result of this, GenericPreparedStatement#prepareToInvalidate is&lt;br/&gt;
  called which again calls&lt;br/&gt;
  GenericLanguageConnectionContext#verifyNoOpenResultSets&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;verifyNoOpenResultSets contains this sequence of calls:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  	// There may be open ResultSet&apos;s that are yet to be garbage collected&lt;br/&gt;
        // let&apos;s try and force these out rather than throw an error&lt;br/&gt;
        System.gc();&lt;br/&gt;
        System.runFinalization();&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;This last call causes deadlock. This seems to happens because the&lt;br/&gt;
  said nested connection&apos;s finalizers are attempted executed.  With&lt;br/&gt;
  the patch, the finalizer of EmbedConnection contains a call to&lt;br/&gt;
  EmbedConnection#close which synchronizes on the root connection&lt;br/&gt;
  object (already locked by the &quot;main&quot; thread as part of the execute).&lt;br/&gt;
  The execution of the finalizer happens in a thread forked by the&lt;br/&gt;
  call to System.runFinalization(), which hangs waiting for the&lt;br/&gt;
  finalizer thread to complete (see Finalizer#forkSecondaryFinalizer&apos;s&lt;br/&gt;
  call to sft.join() ca line 115 in Sun JDK 1.6). Now, the finalizers&lt;br/&gt;
  are stuck waiting for the lock held my &quot;main&quot;, so deadlock ensues.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Now, without the call to System.runFinalization(); the test runs&lt;br/&gt;
  successfully, presumably because the two connection objects will&lt;br/&gt;
  then be garbage collected later, after s.execute() has terminated.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Also, removing the call to System.gc() removes the deadlock, but&lt;br/&gt;
  this breaks the test however (verifyNoOpenResultSets throws X0X95.S&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LANG_CANT_INVALIDATE_OPEN_RESULT_SET in line 1733):&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     &quot;Operation &apos;CREATE TRIGGER&apos; cannot be performed on object &apos;T1&apos;&lt;br/&gt;
      because there is an open ResultSet dependent on that object.&quot;&lt;/p&gt;

&lt;p&gt;  So it would seem that calling System.gc() is sufficient, but&lt;br/&gt;
  System.runFinalization is harmful, since it will wait for&lt;br/&gt;
  finalization to finish, which is a dangerous thing if the thread&lt;br/&gt;
  already holds locks. &lt;b&gt;Or&lt;/b&gt; one could argue that the finalizers should&lt;br/&gt;
  never call anything that could require a lock (too strict in my&lt;br/&gt;
  view).&lt;/p&gt;

&lt;p&gt;So, now I am trying to understand what would be the correct approach&lt;br/&gt;
to resolve this.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Without the call to close in the finalizer of EmbedConnection, we&lt;br/&gt;
  have &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;, that is, ContextManager objects is referenced from&lt;br/&gt;
  the HashSet &apos;allContexts&apos; of the ContextService may leak.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;With the call to close in the finalizer of EmbedConnection, we risk&lt;br/&gt;
  deadlock as long as any Derby code calls System.runFinalization()&lt;br/&gt;
  anywhere. Grepping, i see this happens in three places in the&lt;br/&gt;
  engine:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  LowMemory.java:95: System.runFinalization();&lt;br/&gt;
  GenericLanguageConnectionContext.java:1617: System.runFinalization();&lt;br/&gt;
  GenericLanguageConnectionContext.java:1709: System.runFinalization();&lt;/p&gt;

&lt;p&gt;Possible approaches:&lt;/p&gt;

&lt;p&gt;1) Maybe we could change the HashSet &apos;allContexts&apos; of the&lt;br/&gt;
   ContextService to use weak hash map perhaps, a WeakHashSet, if there&lt;br/&gt;
   is such a thing. That way, the ContextManager objects would be&lt;br/&gt;
   cleaned eventually.&lt;/p&gt;

&lt;p&gt;2) Remove the explicit calls to System.runFinalization. It seems that&lt;br/&gt;
   keeping just the System.gc() call is less risky, but may be less&lt;br/&gt;
   efficient, so could break existing apps? The System.gc() is not&lt;br/&gt;
   guaranteed to yield results anyway..&lt;/p&gt;

&lt;p&gt;3) Figure out a way to explicitly close the result sets in question,&lt;br/&gt;
   so the gc calls would be redundant. I am not sure how easy this&lt;br/&gt;
   would be; they are probably there for a good reason.&lt;/p&gt;

&lt;p&gt;4) Remove the calls and allow the execution to fail as indicated in&lt;br/&gt;
   the comment of verifyNoOpenResultSets:&lt;/p&gt;

&lt;p&gt;   // There may be open ResultSet&apos;s that are yet to be garbage collected&lt;br/&gt;
   // let&apos;s try and force these out rather than throw an error&lt;br/&gt;
   System.gc();&lt;br/&gt;
   System.runFinalization();&lt;/p&gt;

&lt;p&gt;   This could break existing apps.&lt;/p&gt;

&lt;p&gt;5) other ideas..? &lt;/p&gt;

&lt;p&gt;Finally, can this deadlock be considered a Java run-time error? If&lt;br/&gt;
not, what is the contract being broken by Derby app code in the above?&lt;br/&gt;
I tried to search a bit around advisability of explicitly running&lt;br/&gt;
runFinalization, in the presence of held Java locks, and finalizers&lt;br/&gt;
which can cause locks, but I didn&apos;t find anything conclusive...&lt;/p&gt;

&lt;p&gt;Any advise is appreciated &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
</comment>
                            <comment id="12489808" author="rhillegas" created="Wed, 18 Apr 2007 17:19:15 +0100"  >&lt;p&gt;Hi Dag,&lt;/p&gt;

&lt;p&gt;&amp;gt;1) Maybe we could change the HashSet &apos;allContexts&apos; of the&lt;br/&gt;
&amp;gt;   ContextService to use weak hash map perhaps, a WeakHashSet, if there&lt;br/&gt;
&amp;gt;   is such a thing. That way, the ContextManager objects would be&lt;br/&gt;
&amp;gt;   cleaned eventually.&lt;/p&gt;

&lt;p&gt;Maybe you could press java.util.WeakHashMap into service. Its javadoc suggests the following issues:&lt;/p&gt;

&lt;p&gt;a) You would need to choose something innocuous for the values in this map. You&apos;re only interested in the keys and garbage-collectible values would need to be wrapped in WeakReferences.&lt;/p&gt;

&lt;p&gt;b) ContextService.notifyAllActiveThreads() would need to be insulated from disappearing keys. Also, for the record, it looks to me as though the Thread.interrupt() call needs to be wrapped in a privileged action block.&lt;/p&gt;</comment>
                            <comment id="12489814" author="dagw" created="Wed, 18 Apr 2007 17:38:05 +0100"  >&lt;p&gt;A data point: In addition to the patch, I removed both calls to&lt;br/&gt;
System.runFinalization() from GenericLanguageConnectionContext.java,&lt;br/&gt;
but kept the calls to System.gc().&lt;/p&gt;

&lt;p&gt;I ran suites.All end derbyall successfully with both Sun JDK1.4.2 and&lt;br/&gt;
1.6 (sane jars), so I wonder if this may be the simplest way to resolve this. &lt;/p&gt;

&lt;p&gt;Does anyone know if/why the calls to System.runFinalization() are&lt;br/&gt;
(sometimes only, it would seem) necessary?&lt;/p&gt;

&lt;p&gt;The calls to System.runFinalization() has been there since incubation&lt;br/&gt;
as far as I can tell.&lt;/p&gt;

&lt;p&gt;In any case, I will prepare a patch which contains this change as&lt;br/&gt;
well, maybe then someone can test on other VMs; I wonder whether the&lt;br/&gt;
behavior could differ in a significant way between VMs here.&lt;/p&gt;</comment>
                            <comment id="12489816" author="dagw" created="Wed, 18 Apr 2007 18:06:06 +0100"  >&lt;p&gt;Uploaded patch &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-3, which is the same as *-2, except&lt;br/&gt;
that two calls to System.runFinalization have been commented out,&lt;br/&gt;
please see previous comment.&lt;/p&gt;</comment>
                            <comment id="12490202" author="dagw" created="Fri, 20 Apr 2007 00:51:39 +0100"  >&lt;p&gt;More data:&lt;br/&gt;
Unfortunately, without the call to System.runFinalization(),&lt;br/&gt;
ProcedureInTriggerTest fails on Linux with Sun JDKs&lt;br/&gt;
with LANG_CANT_INVALIDATE_OPEN_RESULT_SET.&lt;br/&gt;
Keeping the call, it deadlocks, as on Solaris.&lt;/p&gt;

&lt;p&gt;For the IBM 1.5 VM, keeping the call, there is no deadlock,&lt;br/&gt;
but the error happens. As soon as the finalizer of the nested&lt;br/&gt;
EmbedConnection objects (non-root) synchronize,&lt;br/&gt;
the failure happens, but at least the VM doesn&apos;t deadlock...&lt;br/&gt;
Presumably the failure happens because the finalizers can&apos;t complete&lt;br/&gt;
when gc() and runFinalization() is called, barring the&lt;br/&gt;
result sets from being garbage collected as well.&lt;/p&gt;

&lt;p&gt;I&apos;ll have to try another tack than removing the call to&lt;/p&gt;</comment>
                            <comment id="12490203" author="dagw" created="Fri, 20 Apr 2007 00:55:29 +0100"  >&lt;p&gt;.. to complete the sentence of the previous comment:&lt;/p&gt;

&lt;p&gt;I&apos;ll have to try another tack than removing the call to&lt;br/&gt;
System.runFinalization().&lt;/p&gt;</comment>
                            <comment id="12490311" author="knutanders" created="Fri, 20 Apr 2007 11:22:58 +0100"  >&lt;p&gt;&amp;gt; Presumably the failure happens because the finalizers can&apos;t complete&lt;br/&gt;
&amp;gt; when gc() and runFinalization() is called, barring the&lt;br/&gt;
&amp;gt; result sets from being garbage collected as well.&lt;/p&gt;

&lt;p&gt;It could also be that gc() just makes the garbage collection start, possibly in another thread, so that runFinalization() is called before the objects are marked as unreferenced. IIRC, gc() doesn&apos;t block whereas runFinalization() does.&lt;/p&gt;

&lt;p&gt;Note that the IBM 1.5 VM implemented a much more aggressive gc than previous versions. I remember that many tests had to be rewritten when people started running tests with that VM because ResultSets were closed earlier, etc. That probably explains why you don&apos;t see the deadlock in runFinalization() on IBM 1.5, since the objects most likely are gc&apos;ed and finalized before you come to that point.&lt;/p&gt;</comment>
                            <comment id="12490357" author="dagw" created="Fri, 20 Apr 2007 14:37:27 +0100"  >&lt;p&gt;Thanks for looking at this Knut! &lt;/p&gt;

&lt;p&gt;&amp;gt; It could also be that gc() just makes the garbage collection start,&lt;br/&gt;
&amp;gt; possibly in another thread, so that runFinalization() is called before&lt;br/&gt;
&amp;gt; the objects are marked as unreferenced. IIRC, gc() doesn&apos;t block&lt;br/&gt;
&amp;gt; whereas runFinalization() does.&lt;/p&gt;

&lt;p&gt;On Solaris, gc() alone manages to clear up the result set objects in&lt;br/&gt;
time: Not sure how that works; possibly the marking of the nested&lt;br/&gt;
connection objects makes it possible to also mark the result set&lt;br/&gt;
objects which are then effectively collected in time for the test in&lt;br/&gt;
#prepareToInvalidate() even though the connection objects can&apos;t yet be&lt;br/&gt;
finalized (blocked). As you say, since gc() doesn&apos;t block, there is no deadlock,&lt;br/&gt;
and it works.&lt;/p&gt;

&lt;p&gt;&amp;gt; Note that the IBM 1.5 VM implemented a much more aggressive gc than&lt;br/&gt;
&amp;gt; previous versions. I remember that many tests had to be rewritten when&lt;br/&gt;
&amp;gt; people started running tests with that VM because ResultSets were&lt;/p&gt;

&lt;p&gt;On Linux with SUN VM and with the IBM VM, gc() alone are not able to&lt;br/&gt;
free the result set objects in time, but this is could be timing&lt;br/&gt;
dependent.&lt;/p&gt;

&lt;p&gt;&amp;gt; closed earlier, etc. That probably explains why you don&apos;t see the&lt;br/&gt;
&amp;gt; deadlock in runFinalization() on IBM 1.5, since the objects most&lt;br/&gt;
&amp;gt; likely are gc&apos;ed and finalized before you come to that point.&lt;/p&gt;

&lt;p&gt;No, I get the error with the IBM VM too, so the calls are&lt;br/&gt;
necessary. But they will not succeed in finalizing the nested&lt;br/&gt;
connection objects (unless they are collected earlier but result set&lt;br/&gt;
objects are not) but at least it doesn&apos;t deadlock.&lt;/p&gt;

&lt;p&gt;I will upload a new patch which avoids synchronization in the&lt;br/&gt;
finalizer of nested connection objects, which solves the deadlock&lt;br/&gt;
problem.&lt;/p&gt;</comment>
                            <comment id="12490362" author="dagw" created="Fri, 20 Apr 2007 14:52:16 +0100"  >&lt;p&gt;This version of the patch, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-4.* supercedes all earlier versions.&lt;br/&gt;
It removes the call to close() from the finalizer of EmbedConnection for nested&lt;br/&gt;
connection objects introduced in earlier versions of this patch as it is not strictly necessary. This solves the deadlock issue.&lt;/p&gt;

&lt;p&gt;suites.All and derbyall + the repro run cleanly with Sun 1.4 on Solaris.&lt;br/&gt;
I have verified the repro and ProcudureInTriggerTest against Sun 1.4 and IBM 1.5 on Linux as well.&lt;/p&gt;

&lt;p&gt;Unless I get feedback on this version I will commit it on Monday.&lt;/p&gt;
</comment>
                            <comment id="12491094" author="dagw" created="Mon, 23 Apr 2007 23:46:45 +0100"  >&lt;p&gt;Committed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1947&quot; title=&quot;OutOfMemoryError after repeated calls to boot and shutdown a database&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1947&quot;&gt;&lt;del&gt;DERBY-1947&lt;/del&gt;&lt;/a&gt;-4.* as svn 531638 and resolving it.&lt;/p&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12346613">DERBY-1585</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12365617">DERBY-2480</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12354147" name="DERBY-1947-1.diff" size="2100" author="dagw" created="Sat, 24 Mar 2007 16:32:21 +0000"/>
                            <attachment id="12354148" name="DERBY-1947-1.stat" size="133" author="dagw" created="Sat, 24 Mar 2007 16:32:21 +0000"/>
                            <attachment id="12354369" name="DERBY-1947-2.diff" size="2966" author="dagw" created="Tue, 27 Mar 2007 23:00:16 +0100"/>
                            <attachment id="12354370" name="DERBY-1947-2.stat" size="133" author="dagw" created="Tue, 27 Mar 2007 23:00:22 +0100"/>
                            <attachment id="12355775" name="DERBY-1947-3.diff" size="3987" author="dagw" created="Wed, 18 Apr 2007 18:06:05 +0100"/>
                            <attachment id="12355776" name="DERBY-1947-3.stat" size="221" author="dagw" created="Wed, 18 Apr 2007 18:06:06 +0100"/>
                            <attachment id="12355927" name="DERBY-1947-4.diff" size="3184" author="dagw" created="Fri, 20 Apr 2007 14:52:16 +0100"/>
                            <attachment id="12355928" name="DERBY-1947-4.stat" size="133" author="dagw" created="Fri, 20 Apr 2007 14:52:16 +0100"/>
                            <attachment id="12342610" name="HeapAnalysis_op.jpg" size="143764" author="kartha" created="Tue, 10 Oct 2006 04:45:26 +0100"/>
                            <attachment id="12355722" name="ProcedureInTriggerTest-threadstacks.txt" size="5193" author="dagw" created="Wed, 18 Apr 2007 01:04:21 +0100"/>
                            <attachment id="12342609" name="testEmbedAndClient.java" size="1504" author="kartha" created="Tue, 10 Oct 2006 04:45:26 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 24 Mar 2007 16:32:21 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22809</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy10pr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39766</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>