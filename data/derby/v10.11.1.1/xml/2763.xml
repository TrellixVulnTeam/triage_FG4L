<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:31:04 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2763/DERBY-2763.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2763] In the Network Client InputStreams and Readers returned from LOB&apos;s should be sensitive to underlying LOB data changes.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2763</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Currently the Embedded and Network Client would differ &lt;br/&gt;
in behaviour when the following series of steps is &lt;br/&gt;
followed.&lt;/p&gt;

&lt;p&gt;a) Create an empty Blob&lt;br/&gt;
b) get an InputStream using Blob.getBinaryStream()&lt;br/&gt;
c) write data into this Blob&lt;br/&gt;
   c.1) Get an OutputStream&lt;br/&gt;
   c.2) Use OutputStream.write(byte [] b) to write&lt;br/&gt;
        into this Blob.&lt;br/&gt;
d) Now read from the InputStream obtained in step b)&lt;br/&gt;
   and print the number of bytes read as output.&lt;/p&gt;

&lt;p&gt;The output of step d) differs in the client and in the Embedded side.&lt;/p&gt;


&lt;p&gt;In the Client&lt;br/&gt;
-------------&lt;/p&gt;

&lt;p&gt;The number of bytes read would always be -1.&lt;/p&gt;

&lt;p&gt;In the Embedded&lt;br/&gt;
---------------&lt;/p&gt;

&lt;p&gt;The number of bytes would be the number of bytes we&lt;br/&gt;
reflected.&lt;/p&gt;

&lt;p&gt;The above behaviour in the NetworkClient is because&lt;br/&gt;
the length of the Blob is read once and stored in the &lt;br/&gt;
constructor of the locator Stream returned (in the &lt;br/&gt;
attribute maxPos).&lt;/p&gt;

&lt;p&gt;This instead should be read each time we use the streams.&lt;/p&gt;

&lt;p&gt;A similar issue exists for Clobs also.&lt;/p&gt;

&lt;p&gt;I will raise a seperate JIRA issue for this.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12370925">DERBY-2763</key>
            <summary>In the Network Client InputStreams and Readers returned from LOB&apos;s should be sensitive to underlying LOB data changes.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="narayanan">V.Narayanan</assignee>
                                    <reporter username="narayanan">V.Narayanan</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Jun 2007 14:50:25 +0100</created>
                <updated>Tue, 19 Jun 2007 13:52:54 +0100</updated>
                            <resolved>Fri, 15 Jun 2007 07:08:58 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Network Client</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12501561" author="narayanan" created="Tue, 5 Jun 2007 14:53:07 +0100"  >&lt;p&gt;Attaching a reproducible for this issue.&lt;/p&gt;</comment>
                            <comment id="12502651" author="myrna" created="Fri, 8 Jun 2007 06:07:31 +0100"  >&lt;p&gt;Does this need to be fixed in 10.3? Or can it be marked as another difference between client and server (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-310&quot; title=&quot;Document and/or change Derby client code to match behavior with Embedded driver where possible.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-310&quot;&gt;&lt;del&gt;DERBY-310&lt;/del&gt;&lt;/a&gt;)?&lt;/p&gt;</comment>
                            <comment id="12502666" author="narayanan" created="Fri, 8 Jun 2007 06:26:23 +0100"  >&lt;p&gt;I am looking into this issue and will revert back with a solution to this issue before I leave for home today evening.&lt;/p&gt;</comment>
                            <comment id="12502677" author="narayanan" created="Fri, 8 Jun 2007 06:49:32 +0100"  >&lt;p&gt;It seems to me that we have quite a few alternative behaviors:&lt;/p&gt;

&lt;p&gt;1. Streams still see the old data.&lt;br/&gt;
2. Streams sees the changes that have been made to the part of the Lob&lt;br/&gt;
    that has not yet been read.&lt;br/&gt;
3. Streams throw an exception saying that it is invalid since Lob has&lt;br/&gt;
    been updated.&lt;br/&gt;
4. Change just maxPos and leave the rest as it is (incl. buffering)&lt;br/&gt;
5. Do nothing&lt;/p&gt;

&lt;p&gt;The spec does not seem to say anything about this.&lt;/p&gt;

&lt;p&gt;1. is not possible without very much work and overhead.&lt;br/&gt;
2. is some work, but will make it similar to embedded.&lt;br/&gt;
3. should not be much work, acceptable solution, but different from&lt;br/&gt;
    embedded.  However, it would not be much work to make embedded&lt;br/&gt;
    behave the same way.&lt;br/&gt;
4.-5. even less, need to say that behavior is unpredictable.&lt;/p&gt;

&lt;p&gt;In case we pick 2., I think I prefer the same solution as Anurag has&lt;br/&gt;
done for embedded.  It introduces a few more classes, but it isolates&lt;br/&gt;
the mechanism needed here (separation of concerns), and it does not&lt;br/&gt;
reimplement mechanisms already provided by Java.  Getting buffering&lt;br/&gt;
right may also be a bit tricky, and if there already is a working&lt;br/&gt;
mechanism, I do not think we need to change that.&lt;/p&gt;

&lt;p&gt;A similar situation exists for streams from Clobs(&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2764&quot; title=&quot;In the Network Client Streams returned using Clob.getAsciiStream() and Clob.getCharacterStream() should reflect the changes made to the underlying Clob.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2764&quot;&gt;&lt;del&gt;DERBY-2764&lt;/del&gt;&lt;/a&gt; also).&lt;/p&gt;</comment>
                            <comment id="12502847" author="rhillegas" created="Fri, 8 Jun 2007 16:36:45 +0100"  >&lt;p&gt;Hi Narayanan,&lt;/p&gt;

&lt;p&gt;Thanks for the crisp descrition of the possible solutions. I have a couple immediate reactions:&lt;/p&gt;

&lt;p&gt;A) It would be good if the embedded and network behavior agreed.&lt;/p&gt;

&lt;p&gt;B) I don&apos;t  understand what it means to read out of a blob with one hand while you are writing into it with the other.&lt;/p&gt;

&lt;p&gt;It&apos;s worth pointing out that the same issues arise if you are writing to the Blob using Blob.setBytes() at the same time as you are siphoning out bytes using the InputStream returned by Blob.getBinaryStream(). &lt;/p&gt;

&lt;p&gt;Issue (B) troubles me. What does it mean to read the InputStream up to position X, then insert a block of bytes which straddle that position (i.e., from X-A to X+B)? Quite likely, the inserted bytes have some meaning as a complete block. What does it mean to read only the trailing portion of that block?&lt;/p&gt;

&lt;p&gt;My gut feeling is that we should raise an exception if someone tries to write into a Blob which still has an open InputStream on it. I think this should be the behavior for both the embedded and network clients.&lt;/p&gt;

&lt;p&gt;Do we have real customer demand for some use-case supported by the current embedded behavior? If not, I would recommend raising an exception now. We can relax this in the future if there&apos;s real demand for a real use-case.&lt;/p&gt;</comment>
                            <comment id="12502997" author="narayanan" created="Sat, 9 Jun 2007 04:31:01 +0100"  >&lt;p&gt;Thank you for the comments Rick&lt;/p&gt;

&lt;p&gt;&amp;gt;Issue (B) troubles me. What does it mean to read the InputStream up to position X, &lt;br/&gt;
&amp;gt;then insert a block of bytes which straddle that position (i.e., from X-A to X+B)? &lt;br/&gt;
&amp;gt;Quite likely, the inserted bytes have some meaning as a complete block. &lt;br/&gt;
&amp;gt;What does it mean to read only the trailing portion of that block? &lt;/p&gt;

&lt;p&gt;I think this is an excellent point&lt;/p&gt;

&lt;p&gt;As an analogy&lt;/p&gt;

&lt;p&gt;For example if the Clob were used to store address data and it were&lt;br/&gt;
modified using setString, what is the point of reading from an&lt;br/&gt;
InputStream from this Clob which would have given the old address&lt;br/&gt;
initially and after the updates starts giving the new address.&lt;/p&gt;

&lt;p&gt;&amp;gt;My gut feeling is that we should raise an exception if someone tries&lt;br/&gt;
&amp;gt;to write into a Blob which still has an open InputStream on it. &lt;br/&gt;
&amp;gt;I think this should be the behavior for both the embedded and &lt;br/&gt;
&amp;gt;network clients. &lt;/p&gt;

&lt;p&gt;I think we could allow updates to happen but throw an exception &lt;br/&gt;
upon subsequent reads from the InputStreams after this modification &lt;br/&gt;
has happened. This would not tie the writes to the LOB to the reads&lt;br/&gt;
from the LOB. I agree that invalidation is a form of linking the two but&lt;br/&gt;
the user could just re-create the stream and proceed with the reads&lt;br/&gt;
again.&lt;/p&gt;

&lt;p&gt;As in the above(address) analogy why would you proceed to read the old&lt;br/&gt;
data(address) when the old data(address) is no longer valid? &lt;/p&gt;

&lt;p&gt;Pls do mention if you think this is not the correct approach.&lt;/p&gt;

&lt;p&gt;Thanks again for the comments Rick !!&lt;/p&gt;</comment>
                            <comment id="12503083" author="narayanan" created="Sat, 9 Jun 2007 15:37:09 +0100"  >&lt;p&gt;This patch address this issue using Approach 2 namely&lt;/p&gt;

&lt;p&gt;Streams sees the changes that have been made to the part of the Lob&lt;br/&gt;
that has not yet been read. &lt;/p&gt;

&lt;p&gt;I have attached a .txt file that explains the changes in detail&lt;/p&gt;

&lt;p&gt;I ran BlobClob4BlobTest on this patch and saw no failues.&lt;/p&gt;

&lt;p&gt;The patch still needs more tests to test for the case of the underlying&lt;br/&gt;
LOB being invalidated.&lt;/p&gt;</comment>
                            <comment id="12503085" author="narayanan" created="Sat, 9 Jun 2007 15:52:58 +0100"  >&lt;p&gt;This patch address this issue using Approach 3 namely &lt;/p&gt;

&lt;p&gt;Streams throw an exception saying that it is invalid since Lob has&lt;br/&gt;
been updated. &lt;/p&gt;

&lt;p&gt;The changes made in this patch are very similar to the changes made&lt;br/&gt;
in Approach 2 except that instead of re-creating the streams we throw&lt;br/&gt;
an IOException.&lt;/p&gt;

&lt;p&gt;For now the error string is hard-coded in the IOException. I will change&lt;br/&gt;
this and also write additional tests once this approach is accepted.&lt;/p&gt;

&lt;p&gt;I ran BlobClob4BlobTest and did not see any failures.&lt;/p&gt;

&lt;p&gt;I have not yet run junit All on this patch.&lt;/p&gt;</comment>
                            <comment id="12503086" author="narayanan" created="Sat, 9 Jun 2007 16:01:45 +0100"  >&lt;p&gt;This patch addresses the issue using Approach 4.&lt;/p&gt;

&lt;p&gt;Change just maxPos and leave the rest as it is (incl. buffering) &lt;/p&gt;

&lt;p&gt;The maxPos attribute in the locator classes was being initialized&lt;br/&gt;
during stream creation with the length of stream and was then&lt;br/&gt;
being permanently used as the length of the Lob.&lt;/p&gt;

&lt;p&gt;I have changed this so that the length of the Lob is fetched in the&lt;br/&gt;
cases where it is not mentioned during stream creation.&lt;/p&gt;

&lt;p&gt;I have not yet run junit All on this patch.&lt;/p&gt;</comment>
                            <comment id="12503087" author="narayanan" created="Sat, 9 Jun 2007 16:08:50 +0100"  >&lt;p&gt;Please note that&lt;/p&gt;

&lt;p&gt;The patches Approach_2,3,4.diff are not for commit. &lt;/p&gt;

&lt;p&gt;I have tried out all the approaches and have posted them so that&lt;br/&gt;
it would help people in getting a practical view of these approaches.&lt;/p&gt;

&lt;p&gt;My inclination among the various approaches is towards 2) and 3)&lt;/p&gt;

&lt;p&gt;2) But I consider the point mentioned by Rick as going against this&lt;/p&gt;

&lt;p&gt;3) or the solution suggested by Rick whichever is OK with the community.&lt;/p&gt;</comment>
                            <comment id="12503348" author="oysteing" created="Mon, 11 Jun 2007 10:23:59 +0100"  >&lt;p&gt;&amp;gt; Rick Hillegas commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2763&quot; title=&quot;In the Network Client InputStreams and Readers returned from LOB&amp;#39;s should be sensitive to underlying LOB data changes.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2763&quot;&gt;&lt;del&gt;DERBY-2763&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; --------------------------------------&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Hi Narayanan,&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Thanks for the crisp descrition of the possible solutions. I have a&lt;br/&gt;
&amp;gt; couple immediate reactions:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; A) It would be good if the embedded and network behavior agreed.&lt;/p&gt;

&lt;p&gt;I agree.  I think that is more important than the actual behavior&lt;br/&gt;
here.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; B) I don&apos;t understand what it means to read out of a blob with one&lt;br/&gt;
&amp;gt;    hand while you are writing into it with the other.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; It&apos;s worth pointing out that the same issues arise if you are&lt;br/&gt;
&amp;gt; writing to the Blob using Blob.setBytes() at the same time as you&lt;br/&gt;
&amp;gt; are siphoning out bytes using the InputStream returned by&lt;br/&gt;
&amp;gt; Blob.getBinaryStream().&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Issue (B) troubles me. What does it mean to read the InputStream up&lt;br/&gt;
&amp;gt; to position X, then insert a block of bytes which straddle that&lt;br/&gt;
&amp;gt; position (i.e., from X-A to X+B)? Quite likely, the inserted bytes&lt;br/&gt;
&amp;gt; have some meaning as a complete block. What does it mean to read&lt;br/&gt;
&amp;gt; only the trailing portion of that block?&lt;/p&gt;

&lt;p&gt;A Blob or Clob may well be structured data where segments may be&lt;br/&gt;
updated independently.  Hence, it may make sense to read and update&lt;br/&gt;
Lobs a segment at a time.  However, I agree that it is not very likely&lt;br/&gt;
that one update in the middle of where one is reading.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; My gut feeling is that we should raise an exception if someone tries&lt;br/&gt;
&amp;gt; to write into a Blob which still has an open InputStream on it. I&lt;br/&gt;
&amp;gt; think this should be the behavior for both the embedded and network&lt;br/&gt;
&amp;gt; clients.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Do we have real customer demand for some use-case supported by the&lt;br/&gt;
&amp;gt; current embedded behavior? If not, I would recommend raising an&lt;br/&gt;
&amp;gt; exception now. We can relax this in the future if there&apos;s real&lt;br/&gt;
&amp;gt; demand for a real use-case.&lt;/p&gt;

&lt;p&gt;On use-case I can think of: Read first segment, make update to that,&lt;br/&gt;
continue to read second segment, and so on.  This will not be possible&lt;br/&gt;
if we raise an exception as you suggest.  (You can get around it&lt;br/&gt;
around this by closing the stream and creating a new one, but you will&lt;br/&gt;
then get the overhead of repositioning.)  In this use-case, it does&lt;br/&gt;
not matter whether one is able to see one&apos;s own updates or not, since&lt;br/&gt;
one will never be reading segments that have been updated. Hence, any&lt;br/&gt;
behavior, except raising an exception, would support this use-case. I&lt;br/&gt;
think the advantage of the way Anurag has implemented it on the&lt;br/&gt;
embedded is that it is a well defined behavior that is easy to explain&lt;br/&gt;
to users.  I think a clean behavior is to be preferred over an&lt;br/&gt;
unpredictable behavior if it does not require much extra work.&lt;/p&gt;

&lt;p&gt;I agree that it is better to make a strict behavior now and relax it&lt;br/&gt;
later if needed, than risking to have to restrict the behavior in&lt;br/&gt;
later versions.  I guess the main risk is that future JDBC specs would&lt;br/&gt;
require a specific behavior.  However, it is likely that different&lt;br/&gt;
vendors have different behavior today and that the only thing they&lt;br/&gt;
will agree on is to say that the behavior is unpredictable.&lt;/p&gt;</comment>
                            <comment id="12503446" author="rhillegas" created="Mon, 11 Jun 2007 16:50:08 +0100"  >&lt;p&gt;I think that &#216;ystein describes a useful scenario: efficiently looping through a lob and modifying it one segment at a time. If we go with (2), then the user guides should explain that our implementation supports this scenario and the user guides should warn the customer that other use-cases may produce unpredictable results. &lt;/p&gt;</comment>
                            <comment id="12503845" author="narayanan" created="Tue, 12 Jun 2007 13:32:17 +0100"  >&lt;p&gt;Since update sensitive LOB discussion has mostly happened on this issue&lt;br/&gt;
and proposals for the solution and sample implementations have been&lt;br/&gt;
generalized to LOB&apos;s I am changing this issue from Blob specific to dealing&lt;br/&gt;
with LOB streams in general. I will mark 2764 as duplicate.&lt;/p&gt;</comment>
                            <comment id="12503848" author="narayanan" created="Tue, 12 Jun 2007 13:42:12 +0100"  >&lt;p&gt;I concur with the support voiced for Approach 2 since it is being supported&lt;br/&gt;
by a very valid use case and seems a very logical approach at this&lt;br/&gt;
juncture.&lt;/p&gt;

&lt;p&gt;I highly appreciate the guidance offered and thank Rick and Oystein&lt;br/&gt;
for their invaluable inputs in this patch.&lt;/p&gt;

&lt;p&gt;Attached here is the patch that is a extension of the already attached&lt;br/&gt;
Approach_2.txt&lt;/p&gt;

&lt;p&gt;In this patch I have enabled&lt;/p&gt;

&lt;p&gt;jdbcapi/BlobUpdaetableStreamTest&lt;br/&gt;
jdbcapi/ClobupdateableReaderTest&lt;/p&gt;

&lt;p&gt;for the Network Client.&lt;/p&gt;

&lt;p&gt;I have added tests for the case when a stream&lt;br/&gt;
is taken from a empty Clob or a empty Blob&lt;br/&gt;
(con.createClob or con.createBlob) to&lt;/p&gt;

&lt;p&gt;jdbc4/BlobTest&lt;br/&gt;
jdbc4/ClobTest&lt;/p&gt;

&lt;p&gt;Pls find a detailed explanation for this approach in my&lt;br/&gt;
previous attachment Approach_2.txt&lt;/p&gt;
</comment>
                            <comment id="12503850" author="narayanan" created="Tue, 12 Jun 2007 13:44:46 +0100"  >&lt;p&gt;I have run jdbcapi/BlobClob4BlobTest and the tests I have modified &lt;br/&gt;
uptil now successfully on UpdateSensitiveStreamsForClient_v1.diff.&lt;br/&gt;
I have started a junit all run and shall revert back with the results.&lt;br/&gt;
I request for UpdateSensitiveStreamsForClient_v1.diff to be considered&lt;br/&gt;
for reviews and comments.&lt;/p&gt;</comment>
                            <comment id="12503877" author="narayanan" created="Tue, 12 Jun 2007 16:10:39 +0100"  >&lt;p&gt;I ran junit All on this patch and observed no failures. If everything is OK I request for this patch to be considered for a commit too.&lt;/p&gt;</comment>
                            <comment id="12503899" author="rhillegas" created="Tue, 12 Jun 2007 17:11:56 +0100"  >&lt;p&gt;Thanks for the patch, Narayanan. I am reading it now. Here is an initial reaction:&lt;/p&gt;

&lt;p&gt;It seems to me that the input stream&apos;s position is an offset from the start of the LOB. When the stream is recreated, the current position (offset from the start of the LOB) does not change. So it seems to me that &#216;ystein&apos;s use-case is supported if the rewritten chunks do not change size. So, I am puzzled. To support that use case, is there any need to recreate the streams? It appears to me that the recreation of the streams supports some other use-case, in which the writer is writing bytes further on in the LOB, and not in the porition that has already been read.&lt;/p&gt;

&lt;p&gt;Do we have a use-case in mind for this scenario? It would be nice to be able to argue to ourselves that we are building something that solves a customer problem here.&lt;/p&gt;</comment>
                            <comment id="12503925" author="narayanan" created="Tue, 12 Jun 2007 17:56:44 +0100"  >&lt;p&gt;&amp;gt;It seems to me that the input stream&apos;s position is an offset from the start of the LOB. &lt;/p&gt;

&lt;p&gt;By InputStreams I guess the UpdateSensitiveStreams (UpdateSensitiveLOBInputStream, &lt;br/&gt;
UpdateSensitiveClobLocatorReader) are meant.&lt;/p&gt;

&lt;p&gt;&amp;gt;It appears to me that the recreation of the streams supports some other use-case, &lt;br/&gt;
&amp;gt;in which the writer is writing bytes further on in the LOB, and not in&lt;br/&gt;
&amp;gt;the porition that has already been read. &lt;/p&gt;

&lt;p&gt;These streams internally wrap inside a Buffered Streams&lt;/p&gt;

&lt;p&gt;UpdateSensitiveLOBInputStream - Has a BlobLocatorInputStream or a ClobLocatorInputStream&lt;br/&gt;
                                                               inside a BufferedInputStream&lt;/p&gt;

&lt;p&gt;UpdateSensitiveClobLocatorReader - Has a BlobLocatorReader inside a BufferedReader.&lt;/p&gt;

&lt;p&gt;The Buffered streams pre-fetch larger data than we request(4k = 4096 bytes).&lt;/p&gt;

&lt;p&gt;So if a request for 1000 bytes is made initially from the InputStream the BufferedInputStream would fetch&lt;br/&gt;
4096 bytes. &lt;/p&gt;

&lt;p&gt;Now if the user decides to update from the 2000 position or byte onwards, a subsequent read,&lt;br/&gt;
unless re-creation of the streams that are wrapped inside the Buffered streams is done, will return already&lt;br/&gt;
pre-feched data. &lt;/p&gt;

&lt;p&gt;So upto 4096 bytes you would get the pre-fetched or old data and from 4096 onwards you would get the new&lt;br/&gt;
data. This would be inconsistent.&lt;/p&gt;

&lt;p&gt;So while re-creating the streams they would then re-create with the original position and the reading would&lt;br/&gt;
resume with the updated data. If we remove the BufferedStreams the process of reads becomes very slow.&lt;/p&gt;</comment>
                            <comment id="12503939" author="rhillegas" created="Tue, 12 Jun 2007 18:34:10 +0100"  >&lt;p&gt;Thanks for the quick response, Narayanan. I think I can see how this patch reduces the possibility of the inconsistency which you describe. However, I think that there are race conditions in this patch which could still give rise to that inconsistency--because the read() methods handshake with the writers on entry and not on exit.&lt;/p&gt;

&lt;p&gt;Inconsistencies of some sort can always arise if the contents of the LOB change between the time that reading starts and the time that reading ends. I think that&apos;s true with or without this patch. This patch may change the kind of inconsistencies that can occur and this patch may reduce the possibility of certain inconsistencies. Whether those inconsistencies are acceptable depends on what the application is doing and what it expects.&lt;/p&gt;

&lt;p&gt;What I&apos;m struggling to understand is this: why are the inconsistencies allowed by this patch better than the inconsistencies allowed if we don&apos;t do anything? What are the supported use-cases which we want to document? If I understood those use-cases, then I could reason about whether this patch actually delivers the intended benefit.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="12503964" author="rhillegas" created="Tue, 12 Jun 2007 19:46:45 +0100"  >&lt;p&gt;The regressiion tests pass cleanly for me after applying this patch. I have some additional comments:&lt;/p&gt;

&lt;p&gt;General:&lt;/p&gt;

&lt;p&gt;1) As noted earlier, there are race conditions in the read() methods because they check the update count on the way in and the LOB contents could change before the read() methods exit. Is this OK?&lt;/p&gt;

&lt;p&gt;2) I think that calling sqlLength() in order to check for committed transactions is a little tricky. I think it would be better if Lob exposed a method, say isValid() which has the required semantics. Under the covers, Lob.isValid() can call sqlLength() for the time being.&lt;/p&gt;

&lt;p&gt;UpdateSensitiveLOBLocatorInputStream&lt;/p&gt;

&lt;p&gt;3) I think this class should be abstract. Methods to be implemented by subclasses should be abstract too.&lt;/p&gt;

&lt;p&gt;4) Here is an issue for the documentation noted in my earlier comment today: &#216;ystein&apos;s use case is supported only if a rewritten chunk is exactly the same length as the chunk it is replacing.&lt;/p&gt;


&lt;p&gt;BlobLocatorOutputStream&lt;br/&gt;
ClobLocatorWriter&lt;br/&gt;
ClobLocatorOutputStream&lt;/p&gt;

&lt;p&gt;5) Why is incrementUpdateCount() called in these streams? Shouldn&apos;t the update count be incremented by the Blob and Clob methods which do the actual writing?&lt;/p&gt;</comment>
                            <comment id="12504122" author="anurag" created="Wed, 13 Jun 2007 06:45:52 +0100"  >&lt;p&gt;&amp;gt;Inconsistencies of some sort can always arise if the contents of &lt;br/&gt;
&amp;gt;the LOB change between the time that reading starts and the &lt;br/&gt;
&amp;gt;time that reading ends. I think that&apos;s true with or without this &lt;br/&gt;
&amp;gt;patch. This patch may change the kind of inconsistencies that&lt;br/&gt;
&amp;gt;can occur and this patch may reduce the possibility of certain &lt;br/&gt;
&amp;gt;inconsistencies. Whether those inconsistencies are acceptable&lt;br/&gt;
&amp;gt;depends on what the application is doing and what it expects. &lt;/p&gt;

&lt;p&gt;I think you are talking about the case where a write is in progress &lt;br/&gt;
and at the same read is called and read gets partially updated data. &lt;br/&gt;
This particular scenario is taken care by LOBStreamControl please &lt;br/&gt;
note this class is central repository of all lob classes (for both &lt;br/&gt;
network client and embedded driver). LOBStreamControl &lt;br/&gt;
synchronizes all read and write methods so a read will never&lt;br/&gt;
pickup data which is still being written. &lt;/p&gt;

&lt;p&gt;But I do agree there may be another race condition when there &lt;br/&gt;
is a modification after checking for obsoleteness and before read.&lt;br/&gt;
But I am not sure we really need to handle this case as in this &lt;br/&gt;
case data will be same if the reader thread was scheduled before &lt;br/&gt;
the writer thread.&lt;/p&gt;</comment>
                            <comment id="12504136" author="knutanders" created="Wed, 13 Jun 2007 07:39:23 +0100"  >&lt;p&gt;I&apos;m not familiar with all the details in this discussion, but here are my two cents:&lt;/p&gt;

&lt;p&gt;I think it would be perfectly fine if we said that when reading a stream returned by &lt;span class=&quot;error&quot;&gt;&amp;#91;BC&amp;#93;&lt;/span&gt;lob.get*Stream(), one may or may not see one&apos;s own updates made to that LOB after the call to get*Stream(). I guess a portable application couldn&apos;t rely on any particular behaviour anyway, and it would have to call get*Stream() after the update to get a fresh stream if it needed to see the updated value. If we define the behaviour this way, those applications that need the updated value pay the extra cost themselves, whereas those that don&apos;t care about this (that is, most applications) wouldn&apos;t have to pay for the extra complexity, emptying of buffers etc.&lt;/p&gt;</comment>
                            <comment id="12504138" author="anurag" created="Wed, 13 Jun 2007 07:44:52 +0100"  >&lt;p&gt;&amp;gt; 4) Here is an issue for the documentation noted in my &lt;br/&gt;
&amp;gt;earlier comment today: &#216;ystein&apos;s use case is supported &lt;br/&gt;
&amp;gt;only if a rewritten chunk is exactly the same length as &lt;br/&gt;
&amp;gt;the chunk it is replacing. &lt;/p&gt;

&lt;p&gt;Blob.setBytes or OutputStream.write always overwrites the &lt;br/&gt;
bytes of same length.Even in case of Clob, setString or &lt;br/&gt;
Writer.write will replace chars of same length.&lt;/p&gt;
</comment>
                            <comment id="12504141" author="narayanan" created="Wed, 13 Jun 2007 07:56:02 +0100"  >&lt;p&gt;Thank you for the reviews, comments and the test Runs Rick.&lt;/p&gt;

&lt;p&gt;&amp;gt;1) As noted earlier, there are race conditions in the read() methods &lt;br/&gt;
&amp;gt;   because they check the update count on the way in and the LOB &lt;br/&gt;
&amp;gt;   contents could change before the read() methods exit. Is this OK?&lt;/p&gt;

&lt;p&gt;    I read the comments from Anurag just now... &lt;/p&gt;

&lt;p&gt;    A small addition to that.&lt;/p&gt;

&lt;p&gt;    Writes and reads to LOB&apos;s are basically stored procedure calls with&lt;br/&gt;
    the locator information passed as parameter. So during the case&lt;br/&gt;
    pointed out when a read and a write simultaneously happen the calls&lt;br/&gt;
    would be propogated un-affected by the presence of each other till&lt;br/&gt;
    the LOBStreamControl class which then synchronizes the calls. So this&lt;br/&gt;
    issue would be avoided here.&lt;/p&gt;


&lt;p&gt;&amp;gt;2) I think that calling sqlLength() in order to check for committed transactions &lt;br/&gt;
&amp;gt;   is a little tricky. I think it would be better if Lob exposed a method, &lt;br/&gt;
&amp;gt;   say isValid() which has the required semantics. Under the covers, &lt;br/&gt;
&amp;gt;   Lob.isValid() can call sqlLength() for the time being.&lt;/p&gt;

&lt;p&gt;    I initially thought of adding this in the checkValidity()&lt;br/&gt;
    method of am/Blob and am/Clob. I then decided against this&lt;br/&gt;
    because these methods were being called in the methods that&lt;br/&gt;
    result in a Stored Procedure call themselves. For example&lt;br/&gt;
    checkValidity is called in readBytes. If the locator associated &lt;br/&gt;
    with this is valid then it will result in 2 round trips to the&lt;br/&gt;
    server instead of two. One for the SqlLength() call and the&lt;br/&gt;
    other for the BLOBSETBYTES stored procedure call. The initial&lt;br/&gt;
    round-trip would not be necessary for this method since during&lt;br/&gt;
    the call to BLOBSETBYTES itself we would find out that the&lt;br/&gt;
    locator in invalid.&lt;/p&gt;

&lt;p&gt;    But your solution of keeping the locator valid check in one&lt;br/&gt;
    place (Lob) is correct because if in the future we decide to&lt;br/&gt;
    not use this we can change it at this place alone.&lt;/p&gt;

&lt;p&gt;    I will do this in the follow-up&lt;/p&gt;

&lt;p&gt;    UpdateSensitiveLOBLocatorInputStream&lt;/p&gt;

&lt;p&gt;&amp;gt; 3) I think this class should be abstract. Methods to be implemented by subclasses &lt;br/&gt;
     should be abstract too.&lt;/p&gt;

&lt;p&gt;     I agree. I found this while doing the mock review runs I do on my patches&lt;br/&gt;
     to find silly mistakes. I am sorry, I missed implementing this. I will do&lt;br/&gt;
     this in a follow-up.&lt;/p&gt;

&lt;p&gt;&amp;gt; 4) Here is an issue for the documentation noted in my earlier comment today: &#216;ystein&apos;s use case is &lt;br/&gt;
&amp;gt;    supported only if a rewritten chunk is exactly the same length as the chunk it is replacing.&lt;/p&gt;

&lt;p&gt;     I guess the release note needed flag needs to be enabled and a&lt;br/&gt;
     release note written. Will Do!&lt;/p&gt;


&lt;p&gt;&amp;gt;BlobLocatorOutputStream&lt;br/&gt;
&amp;gt;ClobLocatorWriter&lt;br/&gt;
&amp;gt;ClobLocatorOutputStream&lt;/p&gt;

&lt;p&gt;&amp;gt;5) Why is incrementUpdateCount() called in these streams? Shouldn&apos;t the update count be &lt;br/&gt;
&amp;gt;   incremented by the Blob and Clob methods which do the actual writing?&lt;/p&gt;

&lt;p&gt;   readCharacters, writeCharacters, writeBytes on the Locator streams forward their calls to&lt;br/&gt;
   the framework that calls the stored procedures with the locator value obtained&lt;br/&gt;
   from the Lob. The only way to reach the update count being the Lob reference&lt;br/&gt;
   that is maintained within these streams.&lt;/p&gt;

&lt;p&gt;   So when a user takes a OutputStream from a Lob and does not write&lt;br/&gt;
   into it the InputStreams can continue reading un-hindered. When a&lt;br/&gt;
   write into the OutputStreams or the Writer happens then we need to&lt;br/&gt;
   do increment the updateCount.&lt;/p&gt;

&lt;p&gt;   Hence I decided to increment the updateCount by calling the incrementUpdateCount&lt;br/&gt;
   method using Lob reference mainted in the streams.&lt;/p&gt;</comment>
                            <comment id="12504189" author="oysteing" created="Wed, 13 Jun 2007 11:26:33 +0100"  >&lt;p&gt;Rick Hillegas (JIRA) wrote:&lt;br/&gt;
&amp;gt; Thanks for the patch, Narayanan. I am reading it now. Here is an initial reaction:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; It seems to me that the input stream&apos;s position is an offset from&lt;br/&gt;
&amp;gt; the start of the LOB. When the stream is recreated, the current&lt;br/&gt;
&amp;gt; position (offset from the start of the LOB) does not change. So it&lt;br/&gt;
&amp;gt; seems to me that &#216;ystein&apos;s use-case is supported if the rewritten&lt;br/&gt;
&amp;gt; chunks do not change size. So, I am puzzled. To support that use&lt;br/&gt;
&amp;gt; case, is there any need to recreate the streams? It appears to me&lt;br/&gt;
&amp;gt; that the recreation of the streams supports some other use-case, in&lt;br/&gt;
&amp;gt; which the writer is writing bytes further on in the LOB, and not in&lt;br/&gt;
&amp;gt; the porition that has already been read.&lt;/p&gt;

&lt;p&gt;The use-case I came up with, is an argument for not throwing an&lt;br/&gt;
exception when the underlying LOB has been changed since the stream&lt;br/&gt;
was created.  It does no require any particular behavior with respect&lt;br/&gt;
to whether the updates will be seen by the stream.&lt;/p&gt;

&lt;p&gt;My arguments for choosing the implementation that Narayanan proposes is:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;This is the way it has been implemented in the embedded driver&lt;/li&gt;
	&lt;li&gt;It gives a clean behavior that is very easy to explain and&lt;br/&gt;
    understand: You will see all updates made so far.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;An alternative is, as Knut Anders suggests, that we give no guarantees&lt;br/&gt;
with respect to what updates will be seen.  The given use-case will&lt;br/&gt;
still be supported.  I guess we can make that the official story also&lt;br/&gt;
for embedded driver, even if the implementation guarantees a specific&lt;br/&gt;
behavior.&lt;/p&gt;

&lt;p&gt;&amp;gt; Do we have a use-case in mind for this scenario? It would be nice to&lt;br/&gt;
&amp;gt; be able to argue to ourselves that we are building something that&lt;br/&gt;
&amp;gt; solves a customer problem here.&lt;/p&gt;

&lt;p&gt;I doubt that most users would care here.  It seems to me that if you&lt;br/&gt;
need to work with a LOB, and need to read something you have written&lt;br/&gt;
earlier, an application could use other data structures that are more&lt;br/&gt;
suitable than Blob/Clob objects (e.g., a byte array or a local file).&lt;br/&gt;
Also, if you insists on using Blob/Clob objects for this purpose, you&lt;br/&gt;
will be able to see your updates if you open a new stream.&lt;/p&gt;

&lt;p&gt;(Maybe a bit far-fetched, but Blob/Clob objects give you a mechanism&lt;br/&gt;
for temporary storage of large objects on a server.  It will probably&lt;br/&gt;
be more efficient than storing them in a database table since the&lt;br/&gt;
temporary LOBs support direct access to specific positions within the&lt;br/&gt;
LOB, something Store does not.)&lt;/p&gt;</comment>
                            <comment id="12504211" author="oysteing" created="Wed, 13 Jun 2007 13:24:34 +0100"  >&lt;p&gt;Rick Hillegas (JIRA) wrote:&lt;br/&gt;
&amp;gt; Thanks for the quick response, Narayanan. I think I can see how this&lt;br/&gt;
&amp;gt; patch reduces the possibility of the inconsistency which you&lt;br/&gt;
&amp;gt; describe. However, I think that there are race conditions in this&lt;br/&gt;
&amp;gt; patch which could still give rise to that inconsistency--because the&lt;br/&gt;
&amp;gt; read() methods handshake with the writers on entry and not on exit.&lt;/p&gt;

&lt;p&gt;Thanks, for raising the issue of race conditions, Rick.  We might not&lt;br/&gt;
have considered that carefully enough.  One thing to note here is that&lt;br/&gt;
Blob/Clob objects are local to one transaction/connection.  I do not&lt;br/&gt;
think it is very common for two threads to share the same connection,&lt;br/&gt;
but we need to consider what would happen in such cases.  &lt;/p&gt;

&lt;p&gt;In the client driver, Blob and Clob operations synchronize on the&lt;br/&gt;
connection, associated streams do not.  (This has not changed from&lt;br/&gt;
10.2).  However, in 10.3 reads and writes will lead to calls to stored&lt;br/&gt;
procedures, which synchronize on the connection.  Hence, only one&lt;br/&gt;
thread will read or write LOB fragments at a time.  However, for large&lt;br/&gt;
data transfers (&amp;gt; max VARCHAR size), reads and writes will not be&lt;br/&gt;
atomic.  Readers may see parts of what is written by a single API&lt;br/&gt;
call.  I am not sure how big a problem this is, but I think we should&lt;br/&gt;
consider also synchronizing on the connection in streams.&lt;/p&gt;

&lt;p&gt;&amp;gt; What I&apos;m struggling to understand is this: why are the&lt;br/&gt;
&amp;gt; inconsistencies allowed by this patch better than the&lt;br/&gt;
&amp;gt; inconsistencies allowed if we don&apos;t do anything? &lt;/p&gt;

&lt;p&gt;The major difference is that the inconsistencies that Narayanan is&lt;br/&gt;
adressing in this issue will also appear in single-threaded&lt;br/&gt;
environments.  That is a greater concern since multithreaded access in&lt;br/&gt;
the same transaction is not very likely.  &lt;/p&gt;

&lt;p&gt;It is also quite separate issues since the multi-threaded issue should&lt;br/&gt;
be solved by synchronizing on the connection, while that will not&lt;br/&gt;
help here.  (We must also make sure that the implementation does not&lt;br/&gt;
introduce new multi-threaded issues.)&lt;/p&gt;

&lt;p&gt;&amp;gt; What are the supported use-cases which we want to document? If I&lt;br/&gt;
&amp;gt; understood those use-cases, then I could reason about whether this&lt;br/&gt;
&amp;gt; patch actually delivers the intended benefit.&lt;/p&gt;

&lt;p&gt;I feel that the best would be if did not have to document any&lt;br/&gt;
use-cases at all because the behavior is so well-defined that the&lt;br/&gt;
programmer by himself could imply how to behave. &lt;br/&gt;
Narayanan&apos;s proposal will make it possible to say: &quot;A read operation&lt;br/&gt;
on a stream will see all previous updates to a Blob/Clob object&quot;, and&lt;br/&gt;
I think most people would understand what that implies.&lt;/p&gt;

&lt;p&gt;In my view, the major benefit of this patch is that you get a&lt;br/&gt;
well-defined behavior.  Whether that is enough value to justify the&lt;br/&gt;
patch, I am not 100% sure of.&lt;/p&gt;</comment>
                            <comment id="12504298" author="narayanan" created="Wed, 13 Jun 2007 16:55:09 +0100"  >&lt;p&gt;Thank you for the reviews and comments on the earlier patch Rick.&lt;/p&gt;

&lt;p&gt;In the attached patch I have&lt;/p&gt;

&lt;p&gt;I have made UpdateSensitiveLOBLocatorInputStream  abstract.&lt;/p&gt;

&lt;p&gt;Added a method to Lob that checks for locator validity.&lt;br/&gt;
I have moved the calls to this method to the UpdateSensitive&lt;br/&gt;
streams.&lt;/p&gt;

&lt;p&gt;I ran BlobClob4BlobTest, jdbc4/BlobTest, jdbc4/ClobTest and the &lt;br/&gt;
Updateable streams test that I have enabled in the patch and saw&lt;br/&gt;
no failures.&lt;/p&gt;

&lt;p&gt;I am running junit All now.&lt;/p&gt;
</comment>
                            <comment id="12504327" author="rhillegas" created="Wed, 13 Jun 2007 17:59:22 +0100"  >&lt;p&gt;Thanks Anurag, Knut, Narayanan, and &#216;ystein for the additional clarification. Is this a fair statement of the customer-visible behavior:&lt;/p&gt;

&lt;p&gt;&quot;A thread will always see the writes which it has made to the LOB. It is not defined whether a thread will see writes made by other threads to the LOB.&quot;&lt;/p&gt;

&lt;p&gt;Whatever the contract turns out to be, we should describe it in the user guides. A release note is not sufficient.&lt;/p&gt;</comment>
                            <comment id="12504343" author="rhillegas" created="Wed, 13 Jun 2007 18:29:25 +0100"  >&lt;p&gt;Thanks for the additional modifications, Narayanan.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;5) Why is incrementUpdateCount() called in these streams? Shouldn&apos;t the update count be&lt;br/&gt;
&amp;gt;&amp;gt; incremented by the Blob and Clob methods which do the actual writing?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   readCharacters, writeCharacters, writeBytes on the Locator streams forward their calls to&lt;br/&gt;
&amp;gt;   the framework that calls the stored procedures with the locator value obtained&lt;br/&gt;
&amp;gt;   from the Lob. The only way to reach the update count being the Lob reference&lt;br/&gt;
&amp;gt;   &amp;gt;\that is maintained within these streams.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; ...&lt;/p&gt;

&lt;p&gt;I think I&apos;m missing something. BlobLocatorOutputStream.writeBytes() does the following:&lt;/p&gt;

&lt;p&gt;            connection.locatorProcedureCall()&lt;br/&gt;
                .blobSetBytes(blob.locator_, currentPos, b.length, b);&lt;/p&gt;

&lt;p&gt;            ...&lt;/p&gt;

&lt;p&gt;            blob.incrementUpdateCount();&lt;/p&gt;

&lt;p&gt;Why can&apos;t BlobLocatorOutputStream.writeBytes()  do something like the following, instead:&lt;/p&gt;

&lt;p&gt;            blob.setBytesX( currentPos, b, 0, b.length );&lt;/p&gt;

&lt;p&gt;Blob.setBytesX() already increments the update count and there is no need for BlobLocatorOutputStream to do this. I think that the bumping of the update count should be encapsulated in the Lob and incrementUpdateCount() should be a private method.&lt;/p&gt;</comment>
                            <comment id="12504549" author="narayanan" created="Thu, 14 Jun 2007 06:49:26 +0100"  >&lt;p&gt;Thank you for the comments Rick&lt;/p&gt;

&lt;p&gt;I had run tests on v2 and saw no failures.&lt;/p&gt;

&lt;p&gt;I will do the modification you have suggested and post a patch&lt;br/&gt;
again.&lt;/p&gt;

&lt;p&gt;Thanks once again for the detailed reviews and comments.&lt;/p&gt;


</comment>
                            <comment id="12504567" author="narayanan" created="Thu, 14 Jun 2007 08:10:39 +0100"  >&lt;p&gt;Thank you for the comments Rick.&lt;/p&gt;

&lt;p&gt;I have addressed the issue as pointed out by you&lt;br/&gt;
and have also implemented you suggestion.&lt;/p&gt;

&lt;p&gt;I am running junit All now and shall revert&lt;br/&gt;
back with the results.&lt;/p&gt;</comment>
                            <comment id="12504700" author="narayanan" created="Thu, 14 Jun 2007 13:50:12 +0100"  >&lt;p&gt;I have run junit All and observed no failures. I request for this patch to be considered for a commit.&lt;/p&gt;</comment>
                            <comment id="12504710" author="oysteing" created="Thu, 14 Jun 2007 14:03:58 +0100"  >&lt;p&gt;Patch looks good.  A few comments/questions:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When you recreate the stream, are you getting the right length?  It&lt;br/&gt;
  seems to me that if something has been read (the position has&lt;br/&gt;
  changed from when creating the previous stream), the remaining&lt;br/&gt;
  length should be smaller than what it was initially.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When using setBytesX, I recommend using the return value to&lt;br/&gt;
  determine the number of bytes written since I do not think setBytesX&lt;br/&gt;
  guarantees that everything is written (even if it always will).  I&lt;br/&gt;
  guess you then would need a loop to make sure everything is written.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The use of -1 for unset maxPos complicates stuff a bit.  Would it&lt;br/&gt;
  not be possible to set maxPos to the end of the Blob/Clob instead if&lt;br/&gt;
  it was not specified?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12504767" author="narayanan" created="Thu, 14 Jun 2007 16:06:20 +0100"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When you recreate the stream, are you getting the right length?  It&lt;br/&gt;
&amp;gt;  seems to me that if something has been read (the position has&lt;br/&gt;
&amp;gt;  changed from when creating the previous stream), the remaining&lt;br/&gt;
&amp;gt;  length should be smaller than what it was initially.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;You are correct. In the cases where the subset of the stream is requested&lt;br/&gt;
(using getCharacterStream(long, long), getBinaryStream(long, long) the &lt;br/&gt;
length has to be re-calculated as length-currentPos+1.&lt;/p&gt;

&lt;p&gt;&amp;gt;- When using setBytesX, I recommend using the return value to&lt;br/&gt;
&amp;gt;  determine the number of bytes written since I do not think setBytesX&lt;br/&gt;
&amp;gt;  guarantees that everything is written (even if it always will).  I&lt;br/&gt;
&amp;gt;  guess you then would need a loop to make sure everything is written.&lt;/p&gt;

&lt;p&gt;setBytesX internally calls the framework method blobSetBytes that has&lt;br/&gt;
a while loop that ensures that all the bytes are sent. Adding a loop&lt;br/&gt;
is redundant because it will never be called.&lt;/p&gt;

&lt;p&gt;&amp;gt;- The use of -1 for unset maxPos complicates stuff a bit.  Would it&lt;br/&gt;
&amp;gt;  not be possible to set maxPos to the end of the Blob/Clob instead if&lt;br/&gt;
&amp;gt;  it was not specified?&lt;/p&gt;

&lt;p&gt;The end of the Blob/Clob is variable. It can keep increasing with writes&lt;br/&gt;
and decreasing with truncates. Hence it would really not be possible to&lt;br/&gt;
find out if it was really a value set to represent a subset of the stream&lt;br/&gt;
or the end of the stream.&lt;/p&gt;

&lt;p&gt;I have fixed the length issue in the patch attached. I have run&lt;/p&gt;

&lt;p&gt;1) jdbcapi/BlobClob4BlobTest&lt;br/&gt;
2) jdbc4/BlobTest&lt;br/&gt;
3) jdbc4/ClobTest&lt;br/&gt;
4) jdbcapi/ClobUpdateableReaderTest&lt;br/&gt;
5) jdbcapi/BlobUpdateableStreamTest&lt;/p&gt;

&lt;p&gt;without any failures.&lt;/p&gt;

&lt;p&gt;I request for this patch to be considered for a commit.&lt;/p&gt;</comment>
                            <comment id="12504796" author="rhillegas" created="Thu, 14 Jun 2007 17:07:13 +0100"  >&lt;p&gt;Thanks for all the great work, Narayanan. Looks like my concerns have been addressed. I am running the tests now.&lt;/p&gt;</comment>
                            <comment id="12504894" author="rhillegas" created="Thu, 14 Jun 2007 21:00:14 +0100"  >&lt;p&gt;Committed at revision 547382.&lt;/p&gt;</comment>
                            <comment id="12505030" author="narayanan" created="Fri, 15 Jun 2007 05:30:27 +0100"  >&lt;p&gt;Thank you for the commit Rick !&lt;/p&gt;


</comment>
                            <comment id="12505055" author="narayanan" created="Fri, 15 Jun 2007 07:08:57 +0100"  >&lt;p&gt;All patches submitted and committed!&lt;/p&gt;</comment>
                            <comment id="12505916" author="army" created="Mon, 18 Jun 2007 19:37:01 +0100"  >&lt;p&gt;Noticed that the changes for this issue are causing some javadoc warnings:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveBlobLocatorInputStream.java:53: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveBlobLocatorInputStream.java:74: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveClobLocatorInputStream.java:53: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveClobLocatorReader.java:72: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveClobLocatorReader.java:72: warning - @param argument &quot;r&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveClobLocatorReader.java:110: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveClobLocatorReader.java:110: warning - @param argument &quot;r&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveLOBLocatorInputStream.java:87: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; java\client\org\apache\derby\client\am\UpdateSensitiveLOBLocatorInputStream.java:123: warning - @param argument &quot;connection&quot; is not a parameter name.&lt;/p&gt;</comment>
                            <comment id="12506051" author="narayanan" created="Tue, 19 Jun 2007 06:38:28 +0100"  >&lt;p&gt;Thank you for catching this. I will raise a seperate JIRA for this and &lt;br/&gt;
submit a patch.&lt;/p&gt;

</comment>
                            <comment id="12506147" author="narayanan" created="Tue, 19 Jun 2007 13:52:54 +0100"  >&lt;p&gt;I have addressed the javadoc issues pointed out here in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2846&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/DERBY-2846&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanx again for pointing this out.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12359336" name="Approach_2.diff" size="38437" author="narayanan" created="Sat, 9 Jun 2007 15:37:09 +0100"/>
                            <attachment id="12359337" name="Approach_2.stat" size="980" author="narayanan" created="Sat, 9 Jun 2007 15:37:09 +0100"/>
                            <attachment id="12359338" name="Approach_2.txt" size="2550" author="narayanan" created="Sat, 9 Jun 2007 15:37:09 +0100"/>
                            <attachment id="12359339" name="Approach_3.diff" size="28379" author="narayanan" created="Sat, 9 Jun 2007 15:52:58 +0100"/>
                            <attachment id="12359340" name="Approach_3.stat" size="763" author="narayanan" created="Sat, 9 Jun 2007 15:52:58 +0100"/>
                            <attachment id="12359341" name="Approach_4.diff" size="6290" author="narayanan" created="Sat, 9 Jun 2007 16:01:45 +0100"/>
                            <attachment id="12359342" name="Approach_4.stat" size="244" author="narayanan" created="Sat, 9 Jun 2007 16:01:45 +0100"/>
                            <attachment id="12358970" name="LOBLengthPersists.java" size="1883" author="narayanan" created="Tue, 5 Jun 2007 14:53:07 +0100"/>
                            <attachment id="12359504" name="UpdateSensitiveStreamsForClient_v1.diff" size="54054" author="narayanan" created="Tue, 12 Jun 2007 13:42:12 +0100"/>
                            <attachment id="12359505" name="UpdateSensitiveStreamsForClient_v1.stat" size="1352" author="narayanan" created="Tue, 12 Jun 2007 13:42:12 +0100"/>
                            <attachment id="12359611" name="UpdateSensitiveStreamsForClient_v2.diff" size="53873" author="narayanan" created="Wed, 13 Jun 2007 16:55:03 +0100"/>
                            <attachment id="12359612" name="UpdateSensitiveStreamsForClient_v2.stat" size="1352" author="narayanan" created="Wed, 13 Jun 2007 16:55:09 +0100"/>
                            <attachment id="12359678" name="UpdateSensitiveStreamsForClient_v3.diff" size="54499" author="narayanan" created="Thu, 14 Jun 2007 08:10:36 +0100"/>
                            <attachment id="12359679" name="UpdateSensitiveStreamsForClient_v3.stat" size="1352" author="narayanan" created="Thu, 14 Jun 2007 08:10:37 +0100"/>
                            <attachment id="12359746" name="UpdateSensitiveStreamsForClient_v4.diff" size="54382" author="narayanan" created="Thu, 14 Jun 2007 16:06:20 +0100"/>
                            <attachment id="12359747" name="UpdateSensitiveStreamsForClient_v4.stat" size="1352" author="narayanan" created="Thu, 14 Jun 2007 16:06:20 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 8 Jun 2007 05:07:31 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23228</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy11o7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39921</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>