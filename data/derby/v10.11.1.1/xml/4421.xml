<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:31:16 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4421/DERBY-4421.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4421] Allow Visitors to process the nodes bottom-up</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4421</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Currently, QueryTreeNode.accept() walks the tree top-down, always calling&lt;br/&gt;
visit() on the parent before it calls visit() on the children. Although this&lt;br/&gt;
is fine in most cases, there are use cases where visiting the nodes&lt;br/&gt;
bottom-up would be better. One example is mentioned in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4416&quot; title=&quot;Handle comparison of two constants as a boolean constant&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4416&quot;&gt;&lt;del&gt;DERBY-4416&lt;/del&gt;&lt;/a&gt;. The&lt;br/&gt;
visitor posted there looks for binary comparison operators and checks&lt;br/&gt;
whether both operands are constants. If they are, the operator is replaced&lt;br/&gt;
with a boolean constant.&lt;/p&gt;

&lt;p&gt;Take this expression as an example: (1&amp;lt;2)=(2&amp;gt;1)&lt;/p&gt;

&lt;p&gt;The query tree looks like this:&lt;/p&gt;

&lt;p&gt;       =&lt;br/&gt;
     /   \&lt;br/&gt;
    /     \&lt;br/&gt;
   &amp;lt;       &amp;gt;&lt;br/&gt;
  / \     / \&lt;br/&gt;
 /   \   /   \&lt;br/&gt;
1     2 2     1&lt;/p&gt;

&lt;p&gt;If we walk the tree top-down with the said visitor, the = node doesn&apos;t have&lt;br/&gt;
constant operands when it&apos;s visited. The &amp;lt; and &amp;gt; operators do have constant&lt;br/&gt;
operands, and they&apos;re both replaced with constant TRUE. This means the&lt;br/&gt;
expression (1&amp;lt;2)=(2&amp;gt;1) is rewritten to TRUE=TRUE, and that&apos;s how far the&lt;br/&gt;
transformation goes.&lt;/p&gt;

&lt;p&gt;If the tree had been processed bottom-up, we would start with the &amp;lt; and &amp;gt;&lt;br/&gt;
operators, and again replace them with TRUE. The query tree would therefore&lt;br/&gt;
have been transformed to this intermediate form when the = operator was&lt;br/&gt;
visited:&lt;/p&gt;

&lt;p&gt;       =&lt;br/&gt;
     /   \&lt;br/&gt;
    /     \&lt;br/&gt;
  TRUE   TRUE&lt;/p&gt;

&lt;p&gt;This is the same as the end result when visiting top-down, but now the =&lt;br/&gt;
operator hasn&apos;t been visited yet. Since both the operands of the = operator&lt;br/&gt;
are constants, the visitor will perform yet another transformation so the&lt;br/&gt;
tree is simplified further and ends up as:&lt;/p&gt;

&lt;p&gt;    TRUE&lt;/p&gt;</description>
                <environment></environment>
        <key id="12438910">DERBY-4421</key>
            <summary>Allow Visitors to process the nodes bottom-up</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Fri, 23 Oct 2009 12:19:35 +0100</created>
                <updated>Tue, 2 Feb 2010 10:01:53 +0000</updated>
                            <resolved>Fri, 30 Oct 2009 10:03:01 +0000</resolved>
                                    <version>10.6.1.0</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12769189" author="knutanders" created="Fri, 23 Oct 2009 13:01:24 +0100"  >&lt;p&gt;I propose that we add a method to the Visitor interface to control whether the visitor should visit parents or children first:&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Method that is called to see if 
{@code visit()}
&lt;p&gt; should be called on&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;the children of 
{@code node} before it is called on {@code node}
&lt;p&gt; itself.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;If this method always returns 
{@code true}, the visitor will walk the&lt;br/&gt;
	 * tree bottom-up. If it always returns {@code false}, the tree is visited&lt;br/&gt;
	 * top-down.&lt;br/&gt;
	 *&lt;br/&gt;
	 * @param node the top node of a sub-tree about to be visited&lt;br/&gt;
	 * @return {@code true}
&lt;p&gt; if &lt;/p&gt;
{@code node}&apos;s children should be visited&lt;br/&gt;
	 * before {@code node}
&lt;p&gt;, &lt;/p&gt;
{@code false}
&lt;p&gt; otherwise&lt;br/&gt;
	 */&lt;br/&gt;
	boolean visitChildrenFirst(Visitable node);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;QueryTreeNode.accept() must be changed to check the return value of this method, and all the existing visitors must implement the method (should return false, since all the current visitors walk the tree top-down).&lt;/p&gt;</comment>
                            <comment id="12769224" author="rhillegas" created="Fri, 23 Oct 2009 14:42:52 +0100"  >&lt;p&gt;+1 to this idea.&lt;/p&gt;</comment>
                            <comment id="12769321" author="dagw" created="Fri, 23 Oct 2009 18:41:41 +0100"  >&lt;p&gt;+1. &lt;/p&gt;</comment>
                            <comment id="12770023" author="knutanders" created="Mon, 26 Oct 2009 13:46:55 +0000"  >&lt;p&gt;Attached is a patch with the following code changes:&lt;/p&gt;

&lt;p&gt;1) Adds a method visitChildrenFirst() to the Visitor interface and implements it as &quot;return false&quot; for all existing visitor classes.&lt;/p&gt;

&lt;p&gt;2) QueryTreeNode.accept() checks visitChildrenFirst() to see if visit() should be called on the parent or the children first.&lt;/p&gt;

&lt;p&gt;3) Makes QueryTreeNode.accept() final to prevent sub-classes from overriding it, as classes that override it would need to duplicate the logic. Duplicated code tends to be more difficult to maintain and more error-prone and should be avoided.&lt;/p&gt;

&lt;p&gt;4) Adds an empty acceptChildren() method to QueryTreeNode. This method is called by QueryTreeNode.accept(), and sub-classes should now override this method instead of accept().&lt;/p&gt;

&lt;p&gt;5) Replaces all accept() overrides in sub-classes of QueryTreeNode with acceptChildren().&lt;/p&gt;

&lt;p&gt;Most of these steps were just mechanical transformations. There&apos;s one exception from the rule: FromList.accept() was removed instead of replaced with an acceptChildren() method. That&apos;s because the old accept() method did the exact same thing as the parent&apos;s (QueryTreeNodeVector) accept() method did. This worked, and didn&apos;t cause nodes to be visited twice, because FromList.accept() didn&apos;t follow the established pattern and call super.accept(). There&apos;s however no reason to implement accept() or acceptChildren() in FromList, so I found it more consistent to remove it.&lt;/p&gt;

&lt;p&gt;The patch removes more code than it adds (215 lines added, 359 lines removed), so I think it&apos;s a good clean-up. Since the checking of Visitor.stopTraversal() has been centralized to QueryTreeNode.accept(), we could also remove the now redundant calls to stopTraversal() in all the acceptChildren() methods. But I&apos;d prefer to do that in a follow-up patch in order to keep this patch smaller and easier to understand.&lt;/p&gt;

&lt;p&gt;The regression tests ran cleanly with an earlier version of the patch. The patch had to be refreshed because &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3634&quot; title=&quot;Cannot use row_number() in ORDER BY clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3634&quot;&gt;&lt;del&gt;DERBY-3634&lt;/del&gt;&lt;/a&gt; has added one new visitor and two new accept() methods after that. Rerunning regression tests now.&lt;/p&gt;

&lt;p&gt;I also tested the patch together with the patch from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4416&quot; title=&quot;Handle comparison of two constants as a boolean constant&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4416&quot;&gt;&lt;del&gt;DERBY-4416&lt;/del&gt;&lt;/a&gt;. If the visitor is told to traverse the tree bottom-up, the patch is now able to optimize away an WHERE clause that contains (1=1)=(1=1), so that no project-restrict result set is generated for this statement:&lt;/p&gt;

&lt;p&gt;  SELECT * FROM T WHERE (1=1)=(1=1)&lt;/p&gt;

&lt;p&gt;Without this patch, there would be a project-restrict result set on top of the table scan with a (TRUE=TRUE) restriction.&lt;/p&gt;</comment>
                            <comment id="12770032" author="rhillegas" created="Mon, 26 Oct 2009 14:14:23 +0000"  >&lt;p&gt;Thanks for the patch, Knut. Looks good. A couple comments:&lt;/p&gt;

&lt;p&gt;1) Why does acceptChildren() have package access rather than public or protected access?&lt;/p&gt;

&lt;p&gt;2) As a follow-on effort, it might be good to make QueryTreeNode.accept() abstract in order to force node designers to think about how new nodes should be walked.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12770076" author="knutanders" created="Mon, 26 Oct 2009 16:17:28 +0000"  >&lt;p&gt;Thanks for looking at the patch, Rick. My responses to your questions&lt;br/&gt;
follow below.&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) Why does acceptChildren() have package access rather than public&lt;br/&gt;
&amp;gt; or protected access?&lt;/p&gt;

&lt;p&gt;The reason why it&apos;s not public is that it&apos;s only meant to be called&lt;br/&gt;
from QueryTreeNode and its subclasses. Others should access it&lt;br/&gt;
indirectly via the methods in the Visitable interface.&lt;/p&gt;

&lt;p&gt;Protected access is more liberal than package access and would allow&lt;br/&gt;
the method to be overridden by sub-classes in other packages, but&lt;br/&gt;
since all the sub-classes of QueryTreeNode are in the same package, I&lt;br/&gt;
chose the stricter one.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) As a follow-on effort, it might be good to make&lt;br/&gt;
&amp;gt; QueryTreeNode.accept() abstract in order to force node designers to&lt;br/&gt;
&amp;gt; think about how new nodes should be walked.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I follow you. Wouldn&apos;t that mean that the logic in&lt;br/&gt;
accept() would have to be duplicated in each sub-class of&lt;br/&gt;
QueryTreeNode?&lt;/p&gt;</comment>
                            <comment id="12770116" author="bryanpendleton" created="Mon, 26 Oct 2009 18:17:51 +0000"  >&lt;p&gt;I think Rick may have been asking whether QueryTreeNode.acceptChildren should&lt;br/&gt;
be abstract. For which sub-classes of QueryTreeNode is the empty implementation&lt;br/&gt;
of acceptChildren correct as is?&lt;/p&gt;</comment>
                            <comment id="12770477" author="knutanders" created="Tue, 27 Oct 2009 12:09:08 +0000"  >&lt;p&gt;I didn&apos;t check all the nodes (QueryTreeNode has 159 sub-classes), but here are some examples on classes that should have an empty implementation of acceptChildren() because they have no visitable children:&lt;/p&gt;

&lt;p&gt;UserTypeConstantNode&lt;br/&gt;
SQLBooleanConstantNode&lt;br/&gt;
UntypedNullConstantNode&lt;br/&gt;
BitConstantNode&lt;br/&gt;
XMLConstantNode&lt;br/&gt;
BooleanConstantNode&lt;br/&gt;
VarbitConstantNode&lt;br/&gt;
NumericConstantNode&lt;br/&gt;
SpecialFunctionNode&lt;br/&gt;
TableName&lt;br/&gt;
TableElementNode&lt;br/&gt;
WindowReferenceNode&lt;br/&gt;
CurrentDatetimeOperatorNode&lt;br/&gt;
CurrentRowLocationNode&lt;br/&gt;
NOPStatementNode&lt;br/&gt;
SetTransactionIsolationNode&lt;/p&gt;

&lt;p&gt;The following classes should also have an empty acceptChildren() method if they currently implement accept() correctly (they do have visitable children, though, so it might be that they actually should have had a non-empty acceptChildren() method):&lt;/p&gt;

&lt;p&gt;GenerationClassNode&lt;br/&gt;
DefaultNode&lt;br/&gt;
PrivilegeNode&lt;br/&gt;
TablePrivilegeNode&lt;br/&gt;
WindowDefinitionNode&lt;br/&gt;
BaseColumnNode&lt;br/&gt;
VirtualColumnNode&lt;br/&gt;
ParameterNode&lt;br/&gt;
ColumnReference&lt;br/&gt;
ExecSPSNode&lt;/p&gt;

&lt;p&gt;I see the point that making acceptChildren() abstract could help us detect some cases of missing overrides. Apart from slightly reducing the amount of code needed, one advantage of having an empty method in QTN instead of an abstract method is that all the overrides will have the same structure (call super.acceptChildren() and then accept() on all added children). With the abstract method, the structure will be different depending on where in the class tree the node is located (super.acceptChildren() cannot be called if none of the super-classes implement it, but it has to be called if one of them does). This means that each time you implement an acceptChildren() method, you&apos;ll have to check all sub-classes of the node in which you implement it, and add a call to super.acceptChildren() in each of the sub-classes&apos; implementations. This could be easy to forget.&lt;/p&gt;

&lt;p&gt;The two approaches protect against different classes of errors, so I can be convinced either way. For now, I&apos;ll just commit the patch as it is, since most of it will stay the same regardless of which approach we choose.&lt;/p&gt;</comment>
                            <comment id="12770485" author="knutanders" created="Tue, 27 Oct 2009 12:46:25 +0000"  >&lt;p&gt;Committed d4421-1a.diff with revision 830154.&lt;/p&gt;</comment>
                            <comment id="12770515" author="bryanpendleton" created="Tue, 27 Oct 2009 14:10:40 +0000"  >&lt;p&gt;Thanks Knut for taking the time to work through the details. I think this is a good&lt;br/&gt;
change and I&apos;m excited about the improved optimization behaviors!&lt;/p&gt;</comment>
                            <comment id="12770727" author="dagw" created="Wed, 28 Oct 2009 00:35:47 +0000"  >&lt;p&gt;I think the regular structure provided by the empty method, and the saved code in nodes with no kids, is the stronger argument here. I noticed similar advantages when working with treePrint/printSubNodes. The usage pattern should be clearly documented in QTN, though, since it is slight less intuitive.&lt;/p&gt;</comment>
                            <comment id="12770824" author="knutanders" created="Wed, 28 Oct 2009 08:14:57 +0000"  >&lt;p&gt;Dag, when you say that the pattern should be clearly documented in QTN, did you have something else in mind than the current javadoc for QTN.acceptChildren()? It currently says that all overrides should call super.acceptChildren(), but I could make the comment more verbose if you think that&apos;s appropriate.&lt;/p&gt;</comment>
                            <comment id="12770972" author="dagw" created="Wed, 28 Oct 2009 16:11:32 +0000"  >&lt;p&gt;I checked the Javadoc on QTN.acceptChildren, I think it is fine.&lt;/p&gt;</comment>
                            <comment id="12771366" author="knutanders" created="Thu, 29 Oct 2009 09:55:08 +0000"  >&lt;p&gt;Attaching patch 2a which removes the now redundant calls to stopTraversal() in acceptChildren(). The calls are redundant because QTN.accept() always checks stopTraversal() before calling visit(). I found a couple of instances where subclasses had forgotten to check stopTraversal(), so I believe the centralized check in QTN.accept() is more robust than relying on each subclass to check it.&lt;/p&gt;

&lt;p&gt;All the regression tests ran cleanly.&lt;/p&gt;</comment>
                            <comment id="12771451" author="dagw" created="Thu, 29 Oct 2009 15:40:15 +0000"  >&lt;p&gt;+1 to centralizing the stopTraversal check.&lt;/p&gt;</comment>
                            <comment id="12771894" author="knutanders" created="Fri, 30 Oct 2009 10:03:01 +0000"  >&lt;p&gt;Committed patch 2a with revision 831244.&lt;br/&gt;
This concludes the planned work on this issue, so I&apos;m marking it as resolved.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12438687">DERBY-4416</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12423194" name="d4421-1a.diff" size="41095" author="knutanders" created="Mon, 26 Oct 2009 13:46:55 +0000"/>
                            <attachment id="12423195" name="d4421-1a.stat" size="3472" author="knutanders" created="Mon, 26 Oct 2009 13:46:55 +0000"/>
                            <attachment id="12423566" name="d4421-2a.diff" size="15873" author="knutanders" created="Thu, 29 Oct 2009 09:55:08 +0000"/>
                            <attachment id="12423567" name="d4421-2a.stat" size="1953" author="knutanders" created="Thu, 29 Oct 2009 09:55:08 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 23 Oct 2009 13:42:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31231</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0r7z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38228</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>