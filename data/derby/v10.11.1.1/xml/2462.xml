<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:20:03 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2462/DERBY-2462.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2462] org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2462</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;After an unrelated statement on the same connection commits, and after some number of successful calls to ResultSet.next(), a subsequent call to ResultSet.next() throws an SQLException with a message like: The heap container with container id Container(-1, 1173965368428) is closed.  This seems to be related to the hard-coded passing of false to the super in the constructor of org.apache.derby.impl.store.access.BackingStoreHashTableFromScan.&lt;/p&gt;

&lt;p&gt;Steps to reproduce:&lt;/p&gt;

&lt;p&gt;1. Execute a statement on a connection that returns a result set.&lt;/p&gt;

&lt;p&gt;2. Execute a second statement on the same connection that modifies the database and commits.&lt;/p&gt;

&lt;p&gt;3. Call next() on the first result set until the exception is thrown.&lt;/p&gt;

&lt;p&gt;Note that the number of rows that can be successfully retrieved from the result set seems to be related to the amount of data per row.  Increasing the number of columns in the result set or the length of the columns causes the exception to be taken sooner.&lt;/p&gt;

&lt;p&gt;The attached test program demonstrates the issue.&lt;/p&gt;</description>
                <environment>Test under Windows Vista, Java 1.4.2_13</environment>
        <key id="12365142">DERBY-2462</key>
            <summary>org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="clary2137">Jeff Clary</reporter>
                        <labels>
                    </labels>
                <created>Fri, 16 Mar 2007 19:22:24 +0000</created>
                <updated>Fri, 16 Nov 2007 15:17:09 +0000</updated>
                            <resolved>Wed, 16 May 2007 14:11:29 +0100</resolved>
                                    <version>10.1.1.0</version>
                    <version>10.1.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                    <version>10.2.2.0</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12481780" author="dagw" created="Fri, 16 Mar 2007 22:53:42 +0000"  >&lt;p&gt;The spilling of the hash table to disk was added in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-106&quot; title=&quot;HashJoinStrategy leads to java.lang.OutOfMemoryError&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-106&quot;&gt;&lt;del&gt;DERBY-106&lt;/del&gt;&lt;/a&gt; in svn&lt;br/&gt;
157861. I checked the issue comments, the code changes and the tests,&lt;br/&gt;
but I did not find a clue to why false is passed (for keepAfterCommit) to super from&lt;br/&gt;
BackingStoreHashTableFromScan.  &lt;/p&gt;

&lt;p&gt;I see the test for insensitive result sets (which also relies on&lt;br/&gt;
spilling the hash table to disk) uses holdability=true, but the test&lt;br/&gt;
for join and distinct only tests the non-holdable case.&lt;/p&gt;

&lt;p&gt;So it would seem holdability is not meant to work (or was postponed?)&lt;br/&gt;
for the join and distinct cases. Does anyone know the status of this? (The&lt;br/&gt;
contributor is not active in the community any longer).&lt;/p&gt;</comment>
                            <comment id="12481785" author="dagw" created="Fri, 16 Mar 2007 23:15:30 +0000"  >&lt;p&gt;Thanks for making the JIRA issue, Jeff!&lt;br/&gt;
I upload a preliminary patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;-1.*) which works for your repro&lt;br/&gt;
program and which passes the regression tests (derbyall and suites.All)&lt;br/&gt;
on Solaris 10/x86, SUN JDK1.6.&lt;br/&gt;
It apparently fixes the hashed join case of spilling with holdability true; &lt;br/&gt;
but I have not  added extra tests yet. &lt;/p&gt;

&lt;p&gt;The patch should probably not be committed until someone more familiar with&lt;br/&gt;
this part of the code has looked at this.&lt;/p&gt;</comment>
                            <comment id="12481794" author="dagw" created="Sat, 17 Mar 2007 00:22:54 +0000"  >&lt;p&gt;See also discussion in thread in derby-dev:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/Possible-problem-in-org.apache.derby.impl.store.access.BackingStoreHashTableFromScan-tf3414777.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Possible-problem-in-org.apache.derby.impl.store.access.BackingStoreHashTableFromScan-tf3414777.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12482304" author="dagw" created="Tue, 20 Mar 2007 03:51:45 +0000"  >&lt;p&gt;Dag said:&lt;/p&gt;

&lt;p&gt;&amp;gt; I see the test for insensitive result sets (which also relies on&lt;br/&gt;
&amp;gt; spilling the hash table to disk) uses holdability=true, but the test&lt;br/&gt;
&amp;gt; for join and DISTINCT only tests the non-holdable case. &lt;/p&gt;

&lt;p&gt;Checking the test SpillHash.java (from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-106&quot; title=&quot;HashJoinStrategy leads to java.lang.OutOfMemoryError&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-106&quot;&gt;&lt;del&gt;DERBY-106&lt;/del&gt;&lt;/a&gt;) further, I see that&lt;br/&gt;
none of the cases actually do run with holdability: Apparently the&lt;br/&gt;
case for insensitive result sets does, but I got misled by the fact&lt;br/&gt;
that the test relies on the metadata method&lt;br/&gt;
supportsOpenCursorsAcrossCommit() which always returns false for&lt;br/&gt;
Derby, as it turns out, since we do not support holdability for XA. So&lt;br/&gt;
the test chooses to run without holdability.&lt;/p&gt;

&lt;p&gt;When enabling holdability in the test cases in SpillHash.java, I see&lt;br/&gt;
the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;hash join fails with the same error as reported in this issue,&lt;/li&gt;
	&lt;li&gt;scroll insensitive result sets work (to be expected, has other&lt;br/&gt;
   tests).&lt;/li&gt;
	&lt;li&gt;DISTINCT fails with an exception NoSuchElementException in&lt;br/&gt;
   DiskHashTable#nextElement.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My first patch fixes the hash join case, but not the DISTINCT case,&lt;br/&gt;
because this accesses the spilled rows in the hash tabledifferently;&lt;br/&gt;
it uses a heap scan which fails (the hash join case accesses the&lt;br/&gt;
spiiled rows via a btree lookup of the hash key) since the scan is&lt;br/&gt;
closed due to the commit, and not reopened. I am working on a patch&lt;br/&gt;
which fixes this as well.&lt;/p&gt;</comment>
                            <comment id="12482990" author="dagw" created="Thu, 22 Mar 2007 02:21:56 +0000"  >&lt;p&gt;This patch, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;-2.&lt;/p&gt;
{stat,diff}
&lt;p&gt; supercedes &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;-1.  It does&lt;br/&gt;
the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;modifies the test lang/SpillHash.java to run the test cases both&lt;br/&gt;
     with and without holdability set for the three tests of the disk&lt;br/&gt;
     spill of the backing store hash table:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;hash join result set&lt;/li&gt;
	&lt;li&gt;distinct result set&lt;/li&gt;
	&lt;li&gt;scollable insensitive result set&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     The changed test will reveal the same problem as the repro&lt;br/&gt;
     provided for this issue (if applied before the rest of this&lt;br/&gt;
     patch), as well as a failure of the distinct result set test case. &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;modifies BackingStoreHashTableFromScan to use the holdable&lt;br/&gt;
     mode of the disk hash table if applicable to the query.&lt;br/&gt;
     This change was encessary to make the hash join test case&lt;br/&gt;
     of SpillHash.java work with holdability.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;modifies DiskHashtable.java to enable its enumerator class&lt;br/&gt;
     ElementEnum to survives a commit. It uses a scan of the row&lt;br/&gt;
     conglomerate (heap). Under holdability, the scan gets closed at&lt;br/&gt;
     commit time, and ElementEnum#nextElement would fail. The patch&lt;br/&gt;
     reopens the scan if appropriate (under holdability).  In addition&lt;br/&gt;
     to the change in BackingStoreHashTableFromScan, this change was&lt;br/&gt;
     necessary to make the distinct test case of SpillHash.java work&lt;br/&gt;
     with holdability.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     I would especially appreciate if someone familiar with this area&lt;br/&gt;
     of the code could take a look at this part of the patch; the&lt;br/&gt;
     method I use for salvaging the scan is to save the row location&lt;br/&gt;
     after each nextElement, and use that to reopen the scan at the&lt;br/&gt;
     right position after a commit. I did not find a way to check&lt;br/&gt;
     if the scan was closed before attempting a fetch; I just catch&lt;br/&gt;
     the exception and check for SQLState.AM_SCAN_NOT_POSITIONED, in&lt;br/&gt;
     which I reopen the scan (only under holdability). I seems a bit of a&lt;br/&gt;
     hack; there may be a better way.&lt;/p&gt;

&lt;p&gt;The patch fixes the repro, I ran derbyall and suites.All with no&lt;br/&gt;
errors on JDK1.6 under Solaris 10/x86. It is ready for review.&lt;/p&gt;</comment>
                            <comment id="12490462" author="army" created="Fri, 20 Apr 2007 23:05:05 +0100"  >&lt;p&gt;I am not familiar with this area of code so I cannot make any definitive comments on whether or not the changes are correct nor on if there may be a better way.  I did look at the patch, though, and had the following two questions.  These are both minor and somewhat theoretical, so I don&apos;t think either should block commit of the patch.  Just my proverbial two cents...&lt;/p&gt;

&lt;p&gt;1) The interaction of the various ScanController interfaces and implementations has me completely confused (which has nothing to do with your changes) but I did notice one interface called ScanManager, which extends ScanController, that defines a &quot;closeForEndTransaction(boolean)&quot; method:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://db.apache.org/derby/javadoc/engine/org/apache/derby/iapi/store/access/conglomerate/ScanManager.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/javadoc/engine/org/apache/derby/iapi/store/access/conglomerate/ScanManager.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I also noticed that most of the Scan implementations apparently implement the ScanManager class.  At least, that&apos;s what I gather from the above javadoc page; I tried to verify that by looking at the actual code but got lost in no time.  In any event, I was wondering if that method could somehow be used to indicate that a ScanController has been closed as the result of a commit.  Then instead of catching an exception in DiskHashtable, you could try something like:&lt;/p&gt;

&lt;p&gt;     try&lt;br/&gt;
     {&lt;br/&gt;
        // &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;: if holdable and scan got closed due&lt;br/&gt;
        // to commit, we need to reopen where we left off&lt;br/&gt;
        if (scan.closedByCommit() &amp;amp;&amp;amp; keepAfterCommit)&lt;/p&gt;
        {
            scan = openRowConglomerate(tc, rowConglomerateId);
            scan.positionAtRowLocation(rowloc);
        }
&lt;p&gt;        scan.fetch(row);&lt;/p&gt;

&lt;p&gt;where &quot;scan.closedByCommit()&quot; would return true if the scan was closed by a ScanManager.closeForEndTransaction() call.&lt;/p&gt;

&lt;p&gt;As I said, that&apos;s just a theoretical.  I don&apos;t know if it&apos;s actually possible to get something like that working, but since I noticed the method I thought I&apos;d ask.&lt;/p&gt;

&lt;p&gt;If that type of check is not possible then it seems like we should at least be able to add an &quot;isClosed()&quot; or &quot;isPositioned()&quot; method to the ScanController that could be used instead of catching the exception.  Is there something in particular that would make such an aproach infeasible?&lt;/p&gt;

&lt;p&gt;2) The patch includes the following diff in DiskHashtable:&lt;/p&gt;

&lt;p&gt; +    // &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;: if holdable and scan got closed due&lt;br/&gt;
 +    // to commit, we need to reopen where we left off&lt;br/&gt;
 +    if (keepAfterCommit &amp;amp;&amp;amp; (SQLState.AM_SCAN_NOT_POSITIONED.&lt;br/&gt;
 +            substring(0,5).&lt;br/&gt;
 +            equals(e.getSQLState()))) {&lt;br/&gt;
 +        scan = openRowConglomerate(tc, rowConglomerateId);&lt;br/&gt;
 +        scan.positionAtRowLocation(rowloc);&lt;/p&gt;

&lt;p&gt;It looks like we first make a call to reopen the scan, then we call &quot;positionAtRowLocation()&quot;.  But the javadoc for the latter method (see ScanController.java) seems to indicate that the reopen happens automatically:&lt;/p&gt;

&lt;p&gt;    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Positions the scan at row location and locks the row.&lt;/li&gt;
	&lt;li&gt;If the scan is not opened, it will be reopened if this is a holdable&lt;/li&gt;
	&lt;li&gt;scan and there has not been any operations which causes RowLocations&lt;/li&gt;
	&lt;li&gt;to be invalidated.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Is this javadoc correct?  If so, then is it necessary to explicitly call &quot;openRowConglomerate()&quot; in the above diff, or could we get by without it?&lt;/p&gt;

&lt;p&gt;Also, the javadoc mentions that &quot;positionAtRowLocation()&quot; locks the row.  The javadoc for ScanController.fetch() doesn&apos;t mention anything about locking the row, but I&apos;m assuming it happens anyway...is that correct? (excuse my ignorance here). Can you confirm that row locking occurs as expected with these changes?  I have no reason to believe otherwise, just thought I&apos;d ask.&lt;/p&gt;

&lt;p&gt;It&apos;s worth repeating here that I am not familiar with this area of code and thus this feedback could be of little-to-no-value, so please keep that in mind.  If any committer out there (including you) wishes to commit these changes as they are, I would not complain.&lt;/p&gt;

&lt;p&gt;On a more concrete level, I verified that the new lang/SpillHash.java test runs cleanly with your changes and fails with error XSCH6 without them, as expected.  So thanks for fixing that test up.&lt;/p&gt;</comment>
                            <comment id="12491073" author="dagw" created="Mon, 23 Apr 2007 22:30:36 +0100"  >&lt;p&gt;Thanks for the review, Army! &lt;/p&gt;

&lt;p&gt;I attach a new version of the patch, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;-3.* which supercedes&lt;br/&gt;
earlier versions. I address your comments explicitly below. Relative&lt;br/&gt;
to the previous version (*-2.diff), this patch:&lt;/p&gt;

&lt;p&gt;1) opens the heap scan in DiskHashtable#ElementEnum&apos;s constructor with&lt;br/&gt;
   hold=true if we have holdability. Required for item 3) below to&lt;br/&gt;
   work.&lt;/p&gt;

&lt;p&gt;2) avoids having to catch the not positioned exception in&lt;br/&gt;
   DiskHashtable#nextElement, when the scan has been closed, by using&lt;br/&gt;
   the new method ScanController#isPositioned.&lt;/p&gt;

&lt;p&gt;3) removes the call to openRowConglomerate, now relying on&lt;br/&gt;
   positionAtRowLocation to do the reopening when required under&lt;br/&gt;
   holdability. &lt;/p&gt;

&lt;p&gt;4) checks the result of positionAtRowLocation to verify that it&lt;br/&gt;
   worked, else throw an exception &quot;24000&quot; NO_CURRENT_ROW. It can fail&lt;br/&gt;
   if the row location has been invalidated by compress. Pretty&lt;br/&gt;
   unlikely, but one never knows..&lt;/p&gt;

&lt;p&gt;5) removes the exit() calls from the SpillHash.java test to make it&lt;br/&gt;
   runnable with -Duseprocess=false&lt;/p&gt;

&lt;p&gt;6) some small cleanup in DiskHashtable.&lt;/p&gt;

&lt;p&gt;Regression tests ran cleanly on Sun 1.4 Solaris 10/x86.&lt;/p&gt;


&lt;p&gt;Answers to Army&apos;s review comments:&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) The interaction of the various ScanController interfaces and&lt;br/&gt;
&amp;gt; implementations has me completely confused (which has nothing to do&lt;/p&gt;

&lt;p&gt;you are not alone... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; If that type of check is not possible then it seems like we should&lt;br/&gt;
&amp;gt; at least be able to add an &quot;isClosed()&quot; or &quot;isPositioned()&quot; method&lt;br/&gt;
&amp;gt; to the ScanController that could be used instead of catching the&lt;br/&gt;
&amp;gt; exception. Is there something in particular that would make such an&lt;br/&gt;
&amp;gt; aproach infeasible?&lt;/p&gt;

&lt;p&gt;Yes, I thought of something like this too. I finally added a method&lt;br/&gt;
ScanController#isPositioned, and implemented it for heap and btree&lt;br/&gt;
scans (only used by the former, though).&lt;/p&gt;

&lt;p&gt;&amp;gt; It looks like we first make a call to reopen the scan, then we call&lt;br/&gt;
&amp;gt; &quot;positionAtRowLocation()&quot;. But the javadoc for the latter method&lt;br/&gt;
&amp;gt; (see ScanController.java) seems to indicate that the reopen happens&lt;br/&gt;
&amp;gt; automatically:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     /**&lt;br/&gt;
&amp;gt;      * Positions the scan at row location and locks the row.&lt;br/&gt;
&amp;gt;      * If the scan is not opened, it will be reopened if this is a holdable&lt;br/&gt;
&amp;gt;      * scan and there has not been any operations which causes RowLocations&lt;br/&gt;
&amp;gt;      * to be invalidated.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Is this javadoc correct? If so, then is it necessary to explicitly&lt;br/&gt;
&amp;gt; call &quot;openRowConglomerate()&quot; in the above diff, or could we get by&lt;br/&gt;
&amp;gt; without it?&lt;/p&gt;

&lt;p&gt;Yes, no and yes. Much cleaner, thanks. See item 1) and 3) above.&lt;/p&gt;

&lt;p&gt;&amp;gt; Also, the javadoc mentions that &quot;positionAtRowLocation()&quot; locks the&lt;br/&gt;
&amp;gt; row. The javadoc for ScanController.fetch() doesn&apos;t mention anything&lt;br/&gt;
&amp;gt; about locking the row, but I&apos;m assuming it happens anyway...is that&lt;br/&gt;
&amp;gt; correct? (excuse my ignorance here). Can you confirm that row&lt;br/&gt;
&amp;gt; locking occurs as expected with these changes? I have no reason to&lt;br/&gt;
&amp;gt; believe otherwise, just thought I&apos;d ask.&lt;/p&gt;

&lt;p&gt;Yes, locking is performed as a consequence of calling&lt;br/&gt;
positionAtRowLocation, see HeapScan#positionAtRowLocation which calls&lt;br/&gt;
reopenScanByRecordHandleAndSetLocks. &lt;/p&gt;

&lt;p&gt;&amp;gt; It&apos;s worth repeating here that I am not familiar with this area of&lt;br/&gt;
&amp;gt; code and thus this feedback could be of little-to-no-value, so&lt;br/&gt;
&amp;gt; please keep that in mind. &lt;/p&gt;

&lt;p&gt;I very much appreciate your feedback; I am also unfamiliar with this&lt;br/&gt;
area of the code, and an extra set of eyes is always useful! The patch&lt;br/&gt;
is cleaner now, I think. Thanks again! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12491102" author="army" created="Tue, 24 Apr 2007 00:54:18 +0100"  >&lt;p&gt;Thank you for considering my feedback, Dag.  The v3 patch is indeed cleaner now.&lt;/p&gt;

&lt;p&gt;Two follow-up questions that occur to me:&lt;/p&gt;

&lt;p&gt;1) The new &quot;isPositioned()&quot; method checks to see if the current scan_state is &quot;SCAN_INPROGRESS&quot;.  This works well enough for the case we&apos;re trying to address--i.e. the scan was closed due to a commit and is therefore no longer &quot;in progress&quot;.&lt;/p&gt;

&lt;p&gt;  My question is: are there any scenarios in which we could get to the new code when the scan was closed for some reason &lt;b&gt;other&lt;/b&gt; than a commit?  If this is possible, will attempting to re-open the scan in such a scenario cause problems?&lt;/p&gt;

&lt;p&gt;  I don&apos;t know enough about the lifetime of a scan to give any examples of when or if this could happen, but given the generality of the isPositioned() method I thought I&apos;d bring it up.&lt;/p&gt;

&lt;p&gt;  I did notice that one of the possible scan states is (pulled from BTreeScan):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;SCAN_HOLD_INPROGRESS -&lt;/li&gt;
	&lt;li&gt;The scan has been opened and held open across a commit,&lt;/li&gt;
	&lt;li&gt;at the last commit the state was in SCAN_INPROGRESS.&lt;/li&gt;
	&lt;li&gt;The transaction which opened the scan has committed,&lt;/li&gt;
	&lt;li&gt;but the scan was opened with the &quot;hold&quot; option true.&lt;/li&gt;
	&lt;li&gt;At commit the locks were released and the &quot;current&quot;&lt;/li&gt;
	&lt;li&gt;position is remembered.  In this state only two calls&lt;/li&gt;
	&lt;li&gt;are valid, either next() or close().  When next() is&lt;/li&gt;
	&lt;li&gt;called the scan is reopened, the underlying container&lt;/li&gt;
	&lt;li&gt;is opened thus associating all new locks with the current&lt;/li&gt;
	&lt;li&gt;transaction, and the scan continues at the &quot;next&quot; row.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  To see what would happen I changed &quot;isPositioned()&quot; method to:&lt;/p&gt;

&lt;p&gt;     public boolean isPositioned() throws StandardException&lt;/p&gt;
     {
         return scan_state == SCAN_HOLD_INPROGRESS;
     }

&lt;p&gt;  and then dropped the negation from the check in DiskHashtable:&lt;/p&gt;

&lt;p&gt;     if (keepAfterCommit &amp;amp;&amp;amp; scan.isPositioned()) {&lt;br/&gt;
         // automatically reopens scan:&lt;br/&gt;
         if (!scan.positionAtRowLocation(rowloc)) &lt;/p&gt;
{
             // Will not happen unless compress of this table
             // has invalidated the row location. Possible?
             throw StandardException.
                 newException(SQLState.NO_CURRENT_ROW);
         }
&lt;p&gt;     }&lt;/p&gt;

&lt;p&gt;  I then ran lang/SpillHash.java and the test still passed. The good thing about this approach is that we will only execute the &quot;reopen&quot; logic if we know for a fact that the &quot;scan has been opened and held open across a commit&quot;--which is exactly what we want.  Also, if we rename &quot;isPositioned()&quot; to something more appropriate, the &quot;if&quot; statement in DiskHashtable becomes more intuitive:&lt;/p&gt;

&lt;p&gt;     if (scan.heldAcrossCommit()) {&lt;br/&gt;
         // automatically reopens scan:&lt;br/&gt;
         if (!scan.positionAtRowLocation(rowloc)) {&lt;/p&gt;

&lt;p&gt;  Note that you wouldn&apos;t need to include &quot;keepAfterCommit&quot; anymore because the scan state can only be &quot;HOLD_INPROGRESS&quot; if the scan was opened with &quot;hold&quot; set to true, which (I think?) can only happen if &quot;keepAfterCommit&quot; is true.&lt;/p&gt;

&lt;p&gt;2) I noticed that the lang/SpillHash.java test checks to make sure that the scan is still available after a commit if holdOverCommit is true.  This is good because that&apos;s the whole point of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;.  I was wondering, though,  if it would be worth it to check that the correct &lt;b&gt;error&lt;/b&gt; is thrown if a call to &quot;next()&quot; is made after a commit when holdOverCommit is &lt;b&gt;false&lt;/b&gt;.  Or is that already tested somewhere else?&lt;/p&gt;

&lt;p&gt;Thanks for your patience with my ramblings...&lt;/p&gt;</comment>
                            <comment id="12491481" author="dagw" created="Wed, 25 Apr 2007 00:14:54 +0100"  >&lt;p&gt;Thanks for your continued help with this one, Army!&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) ...&lt;br/&gt;
&amp;gt;   My question is: are there any scenarios in which we could get to&lt;br/&gt;
&amp;gt; the new code when the scan was closed for some reason &lt;b&gt;other&lt;/b&gt; than a&lt;br/&gt;
&amp;gt; commit? If this is possible, will attempting to re-open the scan in&lt;br/&gt;
&amp;gt; such a scenario cause problems?&lt;/p&gt;

&lt;p&gt;I don&apos;t believe so, but let me try an analysis:&lt;/p&gt;

&lt;p&gt;The states of the scan (heap, I omit btree here for simplicity&lt;br/&gt;
although i believe it is similar) is one of&lt;/p&gt;

    {SCAN_INIT,
     SCAN_INPROGRESS,
     SCAN_DONE,
     SCAN_HOLD_INIT,
     SCAN_HOLD_INPROGRESS}

&lt;p&gt; Btw, the comment at the top of GenericScanController (used for heap&lt;br/&gt;
 scan along with subclass HeapScan) omits the &lt;b&gt;&lt;em&gt;HOLD&lt;/em&gt;&lt;/b&gt; states, so it&lt;br/&gt;
 is out of date..&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The constructor of DiskHashTable#ElementEnum opens the scan.  This&lt;br/&gt;
  moves the scan state to SCAN_INIT if successful. If not, it is&lt;br/&gt;
  silently swallowed (not good!), and the enumeration will have zero&lt;br/&gt;
  elements (hasMore==false).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Next, the constructor performs a scan.next() which sets the boolean&lt;br/&gt;
  state variable &quot;hasMore&quot;. When this is true, the scan state will be&lt;br/&gt;
  SCAN_INPROGRESS, when its is false, there are no more data and the&lt;br/&gt;
  scan state will be SCAN_DONE. So when the constructor of ElementEnum&lt;br/&gt;
  returns, the scan state (if no error occurred) will be one of&lt;br/&gt;
  
{SCAN_INPROGRESS, SCAN_DONE}.&lt;br/&gt;
&lt;br/&gt;
  If we have holdability: The state SCAN_HOLD_INIT can only happen if&lt;br/&gt;
  a commit happens &lt;b&gt;before&lt;/b&gt; an initial next() is performed, so that&lt;br/&gt;
  state can not happen for this scan. Also, I believe there are no&lt;br/&gt;
  state transitions possible back to SCAN_INIT or SCAN_HOLD_INIT once&lt;br/&gt;
  a next() is performed and {SCAN_INPROGRESS, SCAN_DONE}
&lt;p&gt; is reached (I&lt;br/&gt;
  did some inspection).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Now, when ElementEnum#nextElement() is attempted, there are four cases&lt;br/&gt;
  cases: &lt;br/&gt;
     n1) holdability and no commit has happened &lt;br/&gt;
     n2) holdability and a commit happened&lt;br/&gt;
     n3) no holdability and  no commit has happened &lt;br/&gt;
     n4) no holdability and a commit happened&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  n1) Scan state should be either &lt;br/&gt;
      SCAN_INPROGRESS (and hasMore == true) or &lt;br/&gt;
      SCAN_DONE (and hasMore == false).&lt;/p&gt;

&lt;p&gt;      If hasMore == false, NoSuchElementException is thrown.  &lt;br/&gt;
      If hasMore == true, state should be SCAN_INPROGRESS,&lt;br/&gt;
      isPositioned() returns true and the fetch will succeed. Also a&lt;br/&gt;
      new next() is performed which moves the state to one of&lt;br/&gt;
      &lt;/p&gt;
{SCAN_INPROGRESS, SCAN_DONE}.&lt;br/&gt;
&lt;br/&gt;
  n2) Scan state should be either &lt;br/&gt;
      SCAN_HOLD_INPROGRESS&#185; (and hasMore == true) or &lt;br/&gt;
      SCAN_DONE (and hasMore == false).&lt;br/&gt;
&lt;br/&gt;
      If hasMore == false, NoSuchElementException is thrown. This&lt;br/&gt;
      would not normally happen, since nextElement would not be&lt;br/&gt;
      called, cf, hasMoreElements().&lt;br/&gt;
&lt;br/&gt;
      If hasMore == true, state should be SCAN_HOLD_INPROGRESS: Our&lt;br/&gt;
      predicate &quot;(keepAfterCommit &amp;amp;&amp;amp; !scan.isPositioned()&quot; == true and&lt;br/&gt;
      we reopen scan before doing the fetch, which should succeed.  A&lt;br/&gt;
      new next() is performed which moves the state to one of&lt;br/&gt;
      {SCAN_INPROGRESS, SCAN_DONE}
&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;      &#185;see GenericScanController#closeForEndTransaction().&lt;/p&gt;

&lt;p&gt;  n3) Similar to n1, except isPositioned() is not called.&lt;/p&gt;

&lt;p&gt;  n4) Scan state should be SCAN_DONE,&lt;br/&gt;
      cf. GenericScanController#closeForEndTransaction.&lt;/p&gt;

&lt;p&gt;      In this case, nextElement is never called; the fact that the&lt;br/&gt;
      result set is closed is caught at a higher level, e.g. in&lt;br/&gt;
      BasicNoPutResultSetImpl#getNextRow() for the DISTINCT case&lt;br/&gt;
      (SQLState.LANG_RESULT_SET_NOT_OPEN, ca line 463).&lt;/p&gt;

&lt;p&gt;      Even if it were reached, no attempt to reopen it would be&lt;br/&gt;
      performed (not held), and scan.fetch would throw&lt;br/&gt;
      SQLState.AM_SCAN_NOT_POSITIONED, which is OK.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;There is a public method setScanState(state) in&lt;br/&gt;
  GenericScanController which could conceivably be used to effect&lt;br/&gt;
  other state transitions, but I checked, and it is only used by&lt;br/&gt;
  HeapScan#positionAtRowLocation to transition from&lt;br/&gt;
  SCAN_HOLD_INPROGRESS back to SCAN_INPROGRESS (and for a similar&lt;br/&gt;
  purpose by HeapCompressScan).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Now, for your question, would it better (safer) to explicitly test&lt;br/&gt;
  for SCAN_HOLD_INPROGRESS with a method called, say,&lt;br/&gt;
  heldAcrossCommit? I believe my analysis above shows that when the&lt;br/&gt;
  call to isPositioned is performed, there are only two possible&lt;br/&gt;
  states the scan can be in: SCAN_HOLD_INPROGRESS or SCAN_INPROGRESS,&lt;br/&gt;
  so they are equally safe (as the code stands right now, anyway).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Now, whether there is, or were to be, some &lt;b&gt;other&lt;/b&gt; way of closing&lt;br/&gt;
  the scan (moving it to SCAN_DONE without also closing the result&lt;br/&gt;
  set), I don&apos;t know, but if it were, positionAtRowLocation will&lt;br/&gt;
  actually try to reopen the scan (not sure if this is good or not &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;,&lt;br/&gt;
  however scan.fetch() would fail with&lt;br/&gt;
  SQLState.AM_SCAN_NOT_POSITIONED. If we use your approach, we would&lt;br/&gt;
  not attempt to reopen in such a case, which may be safer.&lt;/p&gt;

&lt;p&gt;  I agree heldAcrossCommit has the benefit of avoiding the test for&lt;br/&gt;
  holdability as you indicate, which does make for easier reading of&lt;br/&gt;
  the logic. I think I went for is isPositioned from a vague feeling&lt;br/&gt;
  this was potentially more generally useful..&lt;/p&gt;

&lt;p&gt;  Maybe a (even more) generally useful method could be:&lt;/p&gt;

&lt;p&gt;    public boolean isHeldAfterCommit() throws StandardException&lt;/p&gt;
    {
        return (scan_state == SCAN_HOLD_INIT ||
                scan_state == SCAN_HOLD_INPROGRESS);
    }

&lt;p&gt;  that is, if this returns true, the scan can always be reopened&lt;br/&gt;
  (although in the case at hand, only the second state tested for may&lt;br/&gt;
  occur as shown above).&lt;/p&gt;

&lt;p&gt;  What do you think?&lt;/p&gt;


&lt;p&gt;&amp;gt; 2) .... I was wondering, though, if it would be worth it to check&lt;br/&gt;
&amp;gt; that the correct &lt;b&gt;error&lt;/b&gt; is thrown if a call to &quot;next()&quot; is made&lt;br/&gt;
&amp;gt; after a commit when holdOverCommit is &lt;b&gt;false&lt;/b&gt;. Or is that already&lt;br/&gt;
&amp;gt; tested somewhere else?&lt;/p&gt;

&lt;p&gt;As I mentioned above, the error is caught higher up in language layer&lt;br/&gt;
(open result set or not), so I belive this is (or should be &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; tested&lt;br/&gt;
for elsewhere. I manually modified the test to verify that for all&lt;br/&gt;
three variants (join, distinct and cursor), this happened. If you this&lt;br/&gt;
it is still advisable, I can add those tests cases to SpillHash.&lt;/p&gt;

&lt;p&gt;If you agree, I will make a version of the patch with the new&lt;br/&gt;
isHeldAfterCommit outlined above.&lt;/p&gt;</comment>
                            <comment id="12491683" author="army" created="Wed, 25 Apr 2007 17:12:45 +0100"  >&lt;p&gt;Thank you &lt;em&gt;very&lt;/em&gt; much for the detailed analysis, Dag.   I feel better about the &quot;safety&quot; of your v3 changes after reading your previous comment.&lt;/p&gt;

&lt;p&gt;&amp;gt;  Maybe a (even more) generally useful method could be:&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt;    public boolean isHeldAfterCommit() throws StandardException&lt;br/&gt;
&amp;gt;    &lt;/p&gt;
{
&amp;gt;        return (scan_state == SCAN_HOLD_INIT ||
&amp;gt;                scan_state == SCAN_HOLD_INPROGRESS);
&amp;gt;    }
&lt;p&gt; &lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  that is, if this returns true, the scan can always be reopened&lt;br/&gt;
&amp;gt;  (although in the case at hand, only the second state tested for may&lt;br/&gt;
&amp;gt;  occur as shown above).&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  What do you think?&lt;/p&gt;

&lt;p&gt;+1, I like this idea even better.  Thank you for the suggestion and for your willingness to implement it.&lt;/p&gt;

&lt;p&gt;&amp;gt; I manually modified the test to verify that for all three variants (join, distinct and cursor),&lt;br/&gt;
&amp;gt; this happened. If you this it is still advisable, I can add those tests cases to SpillHash.&lt;/p&gt;

&lt;p&gt;If it&apos;s not too much work I think this would be good.  I&apos;m sure there are tests elsewhere to check the general concept of cursor holdability across commits, but it might be nice to have a test case for the specific scenario of a spilled DiskHashtable.&lt;/p&gt;

&lt;p&gt;&amp;gt; If you agree, I will make a version of the patch with the new isHeldAfterCommit outlined above.&lt;/p&gt;

&lt;p&gt;Sounds great.  Thanks again for your continued work with this, and for your prompt consideration of my feedback.&lt;/p&gt;</comment>
                            <comment id="12492080" author="dagw" created="Thu, 26 Apr 2007 19:05:47 +0100"  >&lt;p&gt;This patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2462&quot; title=&quot;org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2462&quot;&gt;&lt;del&gt;DERBY-2462&lt;/del&gt;&lt;/a&gt;-4.*) supercedes earlier versions.&lt;/p&gt;

&lt;p&gt;As agreed,&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it replaces ScanController#isPositioned with with isHeldAfterCommit&lt;br/&gt;
  and uses that in DiskHashTable#ElementNum#NextElement.&lt;/li&gt;
	&lt;li&gt;it adds negative tests to SpillHash.java for the non-holdable cases&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Ran regression tests successfully again (Sun JDK 1.4 and 1.6), Solaris&lt;br/&gt;
10/x86 modulo upgrade tests which failed as mentioned on derby-dev&lt;br/&gt;
(unrelated I believe).&lt;/p&gt;</comment>
                            <comment id="12492093" author="army" created="Thu, 26 Apr 2007 19:53:08 +0100"  >&lt;p&gt;Latest patch (version 4) incorporates all previous feedback and I have no other comments to make.  I applied the patch and ran lang/SpillHash.java with no problems.  I also ran the repro attached to this issue after applying the patch, and it ran cleanly.&lt;/p&gt;

&lt;p&gt;+1 to commit.&lt;/p&gt;

&lt;p&gt;Thank you for your persistence with this issue, Dag.&lt;/p&gt;</comment>
                            <comment id="12496286" author="dagw" created="Wed, 16 May 2007 14:09:26 +0100"  >&lt;p&gt;Refreshed the patch and ran derbyall and suites.All ok again, modulo&lt;br/&gt;
one seemingly intermittent error in ReleaseCompileLocksTest. I don&apos;t&lt;br/&gt;
this is related to this patch.  Committed as svn 538572.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12353551" name="DERBY-2462-1.diff" size="6470" author="dagw" created="Fri, 16 Mar 2007 23:15:29 +0000"/>
                            <attachment id="12353552" name="DERBY-2462-1.stat" size="542" author="dagw" created="Fri, 16 Mar 2007 23:15:29 +0000"/>
                            <attachment id="12353919" name="DERBY-2462-2.diff" size="19455" author="dagw" created="Thu, 22 Mar 2007 02:21:56 +0000"/>
                            <attachment id="12353920" name="DERBY-2462-2.stat" size="778" author="dagw" created="Thu, 22 Mar 2007 02:21:56 +0000"/>
                            <attachment id="12356091" name="DERBY-2462-3.diff" size="21559" author="dagw" created="Mon, 23 Apr 2007 22:30:36 +0100"/>
                            <attachment id="12356092" name="DERBY-2462-3.stat" size="1090" author="dagw" created="Mon, 23 Apr 2007 22:30:36 +0100"/>
                            <attachment id="12356358" name="DERBY-2462-4.diff" size="26667" author="dagw" created="Thu, 26 Apr 2007 19:05:47 +0100"/>
                            <attachment id="12356359" name="DERBY-2462-4.stat" size="1090" author="dagw" created="Thu, 26 Apr 2007 19:05:47 +0100"/>
                            <attachment id="12353534" name="DerbyHoldabilityTest.java" size="7718" author="clary2137" created="Fri, 16 Mar 2007 19:23:08 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 16 Mar 2007 22:53:42 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23063</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy10pb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39764</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>