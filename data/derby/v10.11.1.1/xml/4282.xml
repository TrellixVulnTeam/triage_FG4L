<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:12:55 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4282/DERBY-4282.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4282] strange behavior with the &quot;update ... where current of c1&quot; in the CheckConstraintTest</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4282</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;import java.sql.*;&lt;/p&gt;

&lt;p&gt;public class cons&lt;br/&gt;
{&lt;br/&gt;
   public static void main(String []args)&lt;br/&gt;
       throws Exception&lt;/p&gt;
   {
       Class.forName(&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;).newInstance();
       Connection conn =
           DriverManager.getConnection(&quot;jdbc:derby:testdb;create=true&quot;);
       Statement st = conn.createStatement();

       st.executeUpdate(
           &quot;create table t1(c1 int, c2 int, constraint ck1 &quot;
           + &quot;check(c1 = c2), constraint ck2 check(c2=c1))&quot;);

       st.executeUpdate(&quot;insert into t1 values (1, 1),(2, 2),(3, 3),(4, 4)&quot;);

       Statement st1=conn.createStatement();
       st1.setCursorName(&quot;c1&quot;);
       ResultSet rs = st1.executeQuery(&quot;select * from t1 for update&quot;);
       rs.next();
       st.executeUpdate(&quot;update t1 set c1 = c1 where current of \&quot;c1\&quot;&quot;);
   }
&lt;p&gt;}&lt;br/&gt;
Exception in thread &quot;main&quot; java.sql.SQLException: Column &apos;C2&apos; is either not in any &lt;br/&gt;
table in the FROM list or appears within a join specification and is outside&lt;br/&gt;
the scope of the join specification or appears in a HAVING clause and is not in&lt;br/&gt;
the GROUP BY list. If this is a CREATE or ALTER TABLE  statement then &apos;C2&apos; is not&lt;br/&gt;
 a column in the target table.&lt;br/&gt;
       at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExc&lt;br/&gt;
eptionFactory.java:45)&lt;br/&gt;
       at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:201)&lt;/p&gt;

&lt;p&gt;       at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException&lt;br/&gt;
(TransactionResourceImpl.java:391)&lt;br/&gt;
       at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Tr&lt;br/&gt;
ansactionResourceImpl.java:346)&lt;br/&gt;
       at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConne&lt;br/&gt;
ction.java:2201)&lt;br/&gt;
       at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Connection&lt;br/&gt;
Child.java:81)&lt;br/&gt;
       at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java&lt;br/&gt;
:614)&lt;br/&gt;
       at org.apache.derby.impl.jdbc.EmbedStatement.executeUpdate(EmbedStatemen&lt;br/&gt;
t.java:175)&lt;br/&gt;
       at cons.main(cons.java:25)&lt;/p&gt;

&lt;p&gt;Caused by: ERROR 42X04: Column &apos;C2&apos; is either not in any table in the FROM list&lt;br/&gt;
or appears within a join specification and is outside the scope of the join spec&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Show quoted text -&lt;br/&gt;
       ... 2 more&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12428443">DERBY-4282</key>
            <summary>strange behavior with the &quot;update ... where current of c1&quot; in the CheckConstraintTest</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="eranda">Eranda Sooriyabandara</assignee>
                                    <reporter username="eranda">Eranda Sooriyabandara</reporter>
                        <labels>
                    </labels>
                <created>Sat, 20 Jun 2009 08:52:01 +0100</created>
                <updated>Mon, 17 Jun 2013 10:19:37 +0100</updated>
                            <resolved>Fri, 18 Feb 2011 19:47:35 +0000</resolved>
                                    <version>10.0.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.2.0</version>
                    <version>10.3.3.0</version>
                    <version>10.4.2.0</version>
                    <version>10.5.1.1</version>
                                    <fixVersion>10.5.3.2</fixVersion>
                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12722625" author="bryanpendleton" created="Mon, 22 Jun 2009 15:53:14 +0100"  >&lt;p&gt;Dag Wanvik posted an alternate reproduction case to the derby-dev list:&lt;/p&gt;

&lt;p&gt;Another data point.&lt;/p&gt;

&lt;p&gt;This also fails when using updatable result set, as could be expected&lt;br/&gt;
since it uses an underlying cursor:&lt;/p&gt;

&lt;p&gt;        Statement st1=conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;
        st1.setCursorName(&quot;c1&quot;);&lt;br/&gt;
        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update&quot;);&lt;br/&gt;
        rs.next();&lt;br/&gt;
        rs.updateInt(1, rs.getInt(1));&lt;br/&gt;
        rs.updateRow();&lt;/p&gt;


&lt;p&gt;Caused by: ERROR 42X04: Column &apos;C2&apos; is either not in any table in the FROM list or appears within a join specification and is outside the scope of the join specification or appears in a HAVING clause and is not in the GROUP BY list. If this is a CREATE or ALTER TABLE  statement then &apos;C2&apos; is not a column in the target table.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:286)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ColumnReference.bindExpression(ColumnReference.java:354)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.BinaryOperatorNode.bindExpression(BinaryOperatorNode.java:298)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.BinaryComparisonOperatorNode.bindExpression(BinaryComparisonOperatorNode.java:133)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.UnaryOperatorNode.bindOperand(UnaryOperatorNode.java:333)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.TestConstraintNode.bindExpression(TestConstraintNode.java:92)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.BinaryOperatorNode.bindExpression(BinaryOperatorNode.java:298)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.BinaryLogicalOperatorNode.bindExpression(BinaryLogicalOperatorNode.java:94)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.AndNode.bindExpression(AndNode.java:68)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.DMLModStatementNode.bindRowScopedExpression(DMLModStatementNode.java:809)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.DMLModStatementNode.bindConstraints(DMLModStatementNode.java:735)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.UpdateNode.bindStatement(UpdateNode.java:618)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:316)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:80)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:831)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedResultSet.updateRow(EmbedResultSet.java:3710)&lt;br/&gt;
	... 1 more&lt;/p&gt;</comment>
                            <comment id="12727008" author="dagw" created="Fri, 3 Jul 2009 16:28:01 +0100"  >&lt;p&gt;Triaged for 10.5.2, checking &quot;repro attached&quot;.&lt;/p&gt;</comment>
                            <comment id="12729981" author="eranda" created="Sat, 11 Jul 2009 13:24:17 +0100"  >&lt;p&gt;Hi Bryan,&lt;br/&gt;
In,&lt;br/&gt;
       Statement st1=conn.createStatement();&lt;br/&gt;
       st1.setCursorName(&quot;c1&quot;);&lt;br/&gt;
       ResultSet rs = st1.executeQuery(&quot;select * from t1 for update&quot;);&lt;br/&gt;
       rs.next();&lt;br/&gt;
       st.executeUpdate(&quot;update t1 set c1 = c1 where current of \&quot;c1\&quot;&quot;);&lt;/p&gt;

&lt;p&gt;I think it should add autoCommit(false); statement.&lt;br/&gt;
Because when I try to test when autocommit on, i got the message&lt;br/&gt;
        ij&amp;gt; update t1 set c1 = c1 where current of c1;&lt;br/&gt;
      ERROR 42X30: Cursor &apos;C1&apos; not found. Verify that autocommit is OFF.&lt;br/&gt;
When autocommit off; this succeeds.&lt;/p&gt;

&lt;p&gt;But I am confused with it because the error message includes that c2 is not&lt;br/&gt;
there, because we don&apos;t consider c2 here.&lt;/p&gt;

&lt;p&gt;&quot;Exception in thread &quot;main&quot; java.sql.SQLException: Column &apos;C2&apos; is either not&lt;br/&gt;
in any&lt;br/&gt;
table in the FROM list or appears within a join specification and is&lt;br/&gt;
outside&lt;br/&gt;
the scope of the join specification or appears in a HAVING clause and is not&lt;br/&gt;
in&lt;br/&gt;
the GROUP BY list. If this is a CREATE or ALTER TABLE statement then &apos;C2&apos; is&lt;br/&gt;
not&lt;br/&gt;
 a column in the target table.&quot;&lt;/p&gt;

&lt;p&gt;Why it is show autocommit must off when we setCommit(false)?&lt;/p&gt;

&lt;p&gt;Thanks&lt;br/&gt;
Eranda&lt;/p&gt;</comment>
                            <comment id="12730008" author="bryanpendleton" created="Sat, 11 Jul 2009 18:06:20 +0100"  >&lt;p&gt;I tried adding &lt;/p&gt;

&lt;p&gt;  conn.setAutoCommit(false);&lt;/p&gt;

&lt;p&gt;to the test, but it didn&apos;t seem to change the behavior for me.&lt;/p&gt;

&lt;p&gt;Attached is the &apos;cons.java&apos; that I tried.&lt;/p&gt;</comment>
                            <comment id="12734875" author="bryanpendleton" created="Fri, 24 Jul 2009 03:39:22 +0100"  >&lt;p&gt;I spent some time stepping through this code and trying to figure out what&apos;s going on.&lt;br/&gt;
Here are some notes on what I learned:&lt;/p&gt;

&lt;p&gt;1) Firstly, here are some observations on possible workarounds:&lt;br/&gt;
     a) If we change the line&lt;br/&gt;
                      st.executeUpdate(&quot;update t1 set c1 = c1 where current of \&quot;c1\&quot;&quot;);&lt;br/&gt;
          to&lt;br/&gt;
                      st.executeUpdate(&quot;update t1 set c1 = c1,c2=c2 where current of \&quot;c1\&quot;&quot;);&lt;br/&gt;
          then the problem does not occur&lt;br/&gt;
     b) If we, alternately, change the line&lt;br/&gt;
                        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update&quot;);&lt;br/&gt;
          to&lt;br/&gt;
                        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update of c1,c2&quot;);&lt;br/&gt;
          then the problem does not occur.&lt;br/&gt;
     c) Similarly, if we change&lt;br/&gt;
                        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update&quot;);&lt;br/&gt;
          to&lt;br/&gt;
                        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update of c1&quot;);&lt;br/&gt;
          then the problem does not occur.&lt;/p&gt;

&lt;p&gt;2) Secondly, if we change&lt;br/&gt;
                        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update&quot;);&lt;br/&gt;
          to&lt;br/&gt;
                        ResultSet rs = st1.executeQuery(&quot;select * from t1 for update of c2&quot;);&lt;br/&gt;
   Then we get, correctly I believe, the following error:&lt;/p&gt;

&lt;p&gt;           Exception in thread &quot;main&quot; java.sql.SQLSyntaxErrorException: Column &apos;C1&apos; is not&lt;br/&gt;
           in the FOR UPDATE list of cursor &apos;c1&apos;.&lt;/p&gt;

&lt;p&gt;Regardless of how we fix this Jira issue, I think that the 4 above test cases, as well&lt;br/&gt;
as the test case in the issue description, should be added to our regression suites.&lt;/p&gt;

&lt;p&gt;3) I spent some time stepping through the code in the debugger, and I believe that the&lt;br/&gt;
   problem arises around line 435 of UpdateNode.java, where we find this code:&lt;/p&gt;

&lt;p&gt;	/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Add the &quot;after&quot; portion of the result row.  This is the update&lt;/li&gt;
		&lt;li&gt;list augmented to include every column in the target table.&lt;/li&gt;
		&lt;li&gt;Those columns that are not being updated are set to themselves.&lt;/li&gt;
		&lt;li&gt;The expanded list will be in the order of the columns in the base&lt;/li&gt;
		&lt;li&gt;table.&lt;br/&gt;
	*/&lt;br/&gt;
	afterColumns = resultSet.getResultColumns().expandToAll(&lt;br/&gt;
				targetTableDescriptor,&lt;br/&gt;
				targetTable.getTableName());&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   We then arrive at line 2546 of ResultColumnList.java, where we find this code:&lt;/p&gt;

&lt;p&gt;	/* Build a ResultColumn/ColumnReference pair for the column */&lt;br/&gt;
	rc = makeColumnReferenceFromName( tableName, cd.getColumnName() );&lt;/p&gt;

&lt;p&gt;   And then we get to line 4070 of ResultColumnList.java, where we find this code:&lt;/p&gt;

&lt;p&gt;		ResultColumn	rc = (ResultColumn) nodeFactory.getNode&lt;br/&gt;
			(&lt;br/&gt;
				C_NodeTypes.RESULT_COLUMN,&lt;br/&gt;
				null,&lt;br/&gt;
				nodeFactory.getNode&lt;br/&gt;
				(&lt;br/&gt;
					C_NodeTypes.COLUMN_REFERENCE,&lt;br/&gt;
					columnName,&lt;br/&gt;
					tableName,&lt;br/&gt;
					cm&lt;br/&gt;
				),&lt;br/&gt;
				cm&lt;br/&gt;
			);&lt;/p&gt;

&lt;p&gt;I think that the problem involves the &apos;null&apos; that we pass as the first argument&lt;br/&gt;
to the ResultColumn initialization logic, because this causes the generated &apos;C2&apos; column&lt;br/&gt;
that is pulled from the &apos;select *&apos; cursor into the &apos;update&apos; statement to be pulled&lt;br/&gt;
as an &lt;b&gt;UNNAMED&lt;/b&gt; column, which is (later) transformed into a column named &apos;SQLCOL1&apos;,&lt;br/&gt;
and ends up resulting in a bind failure for the CHECK constraint, which can&apos;t find&lt;br/&gt;
column &apos;C2&apos; in the ResultColumnList, finding instead the columns &apos;C1&apos; and &apos;SQLCOL1&apos;.&lt;/p&gt;

&lt;p&gt;I think the fix may be as simple as changing &apos;null&apos; to &apos;columnName&apos;, as in this diff:&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java (revision 787523)&lt;br/&gt;
+++ java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java (working copy)&lt;br/&gt;
@@ -4057,7 +4057,7 @@&lt;br/&gt;
                ResultColumn    rc = (ResultColumn) nodeFactory.getNode&lt;br/&gt;
                        (&lt;br/&gt;
                                C_NodeTypes.RESULT_COLUMN,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;null,&lt;br/&gt;
+                               columnName,&lt;br/&gt;
                                nodeFactory.getNode&lt;br/&gt;
                                (&lt;br/&gt;
                                        C_NodeTypes.COLUMN_REFERENCE,&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I did some very simple testing, and this appeared to fix the reproduction case, but&lt;br/&gt;
I have not run any other regression tests.&lt;/p&gt;

&lt;p&gt;I think that the next steps here ought to be to construct a proper patch, containing:&lt;br/&gt;
   1) the code change to ResultColumnList.java&lt;br/&gt;
   2) the necessary changes to CheckConstraintTest.java to include the bug script&lt;br/&gt;
      from the issue description, together with the additional test cases I&lt;br/&gt;
      mentioned above&lt;br/&gt;
and then to run a complete set of regression tests to see if the code change&lt;br/&gt;
causes any other problems with Derby.&lt;/p&gt;
</comment>
                            <comment id="12741686" author="eranda" created="Tue, 11 Aug 2009 05:57:17 +0100"  >&lt;p&gt;Hi Bryan,&lt;br/&gt;
I test with your update and found some problems,&lt;/p&gt;

&lt;p&gt;1.When I use the code as,&lt;/p&gt;

&lt;p&gt;Statement st1 = conn.createStatement();&lt;br/&gt;
        st1.setCursorName(&quot;c1&quot;);&lt;br/&gt;
        ResultSet rs1 = st1.executeQuery(&quot;elect * from t1 where c2 = 2 for&lt;br/&gt;
update of c1&quot;);&lt;br/&gt;
        rs1.next();&lt;br/&gt;
        st.executeUpdate(&quot;update t1 set c1 = c1 where current of \&quot;c1\&quot;&quot;);&lt;br/&gt;
        assertStatementError(&quot;23513&quot;, st,&lt;br/&gt;
            &quot;update t1 set c1 = c1 + 1 where current of \&quot;c1\&quot;&quot;);&lt;/p&gt;

&lt;p&gt;it is successfully working but when I change the code as,&lt;/p&gt;

&lt;p&gt;Statement st1 = conn.createStatement();&lt;br/&gt;
        st1.setCursorName(&quot;c1&quot;);&lt;br/&gt;
        ResultSet rs1 = st1.executeQuery(&quot;select * from t1 where c2 = 2 for&lt;br/&gt;
update of c1&quot;);&lt;br/&gt;
        rs1.next();&lt;br/&gt;
        expRS=new String[][]{&lt;/p&gt;
            {&quot;2&quot;,&quot;2&quot;}&lt;br/&gt;
        };&lt;br/&gt;
        JDBC.assertFullResultSet(rs1, expRS);&lt;br/&gt;
        st.executeUpdate(&quot;update t1 set c1 = c1 where current of \&quot;c1\&quot;&quot;);&lt;br/&gt;
        assertStatementError(&quot;23513&quot;, st,&lt;br/&gt;
            &quot;update t1 set c1 = c1 + 1 where current of \&quot;c1\&quot;&quot;);&lt;br/&gt;
&lt;br/&gt;
It gave me the error &quot;unexpected row count:expected&amp;lt;1&amp;gt; but was&amp;lt;0&amp;gt;&quot;  in the&lt;br/&gt;
line of &quot;JDBC.assertFullResultSet(rs1, expRS);&quot;;.&lt;br/&gt;
&lt;br/&gt;
I think this is because in the JDBC they called the rs.next() until it&apos;s&lt;br/&gt;
become false. So the cursor ends from there.&lt;br/&gt;
When we reach the line &quot;st.executeUpdate(&quot;update t1 set c1 = c1 where&lt;br/&gt;
current of \&quot;c1\&quot;&quot;);&quot; cursor not available. So we can&apos;t use both of them&lt;br/&gt;
together. I thought to skip the part of,&lt;br/&gt;
        expRS=new String[][]{&lt;br/&gt;
            {&quot;2&quot;,&quot;2&quot;}
&lt;p&gt;        };&lt;br/&gt;
        JDBC.assertFullResultSet(rs1, expRS);&lt;br/&gt;
from the code.&lt;/p&gt;

&lt;p&gt;So I try a method which successful at the end.I send it as a patch file&lt;br/&gt;
here.&lt;br/&gt;
If it is fine for you then I can do as the same thing for the rest of the&lt;br/&gt;
commented codes.&lt;/p&gt;</comment>
                            <comment id="12741687" author="eranda" created="Tue, 11 Aug 2009 06:13:16 +0100"  >&lt;p&gt;Hi Bryan,Here I am attaching the full patch that I edited for your concern.&lt;/p&gt;</comment>
                            <comment id="12741886" author="bryanpendleton" created="Tue, 11 Aug 2009 15:10:42 +0100"  >&lt;p&gt;The important part of the test is to verify that the check constraint is enforced&lt;br/&gt;
properly for the &quot;where current of&quot; style of  the update statement when the cursor is open.&lt;/p&gt;

&lt;p&gt;So we don&apos;t need to call JDBC.assertFullResultSet on the SELECT statement, I agree.&lt;br/&gt;
The only reason we are issuing the SELECT statement and calling rs1.next() is to&lt;br/&gt;
ensure that the cursor is opened.&lt;/p&gt;

&lt;p&gt;So your technique looks fine to me.&lt;/p&gt;

&lt;p&gt;Is that the only remaining issue for this patch? &lt;/p&gt;</comment>
                            <comment id="12741895" author="eranda" created="Tue, 11 Aug 2009 15:33:15 +0100"  >&lt;p&gt;Hi Bryan,&lt;br/&gt;
Yes,that&apos;s all in the test part. Can we commit it now?&lt;br/&gt;
Thanks&lt;/p&gt;</comment>
                            <comment id="12742159" author="bryanpendleton" created="Wed, 12 Aug 2009 01:53:15 +0100"  >&lt;p&gt;I included the test case from the issue description into CheckConstraintTest, because that&lt;br/&gt;
test case was very clear and simple and I wanted to preserve it in the test suite. And I verified&lt;br/&gt;
that CheckConstraintTest fails as expected without the code patch to ResultColumnList,&lt;br/&gt;
and succeeds once the code patch to ResultColumnList is applied.&lt;/p&gt;

&lt;p&gt;I also ran a complete set of regression tests and didn&apos;t find any other problems, and I have&lt;br/&gt;
committed the patch to svn as revision 803336.&lt;/p&gt;

&lt;p&gt;Eranda, thanks very much for contributing this bug fix to Derby.&lt;/p&gt;</comment>
                            <comment id="12742455" author="eranda" created="Wed, 12 Aug 2009 18:13:16 +0100"  >&lt;p&gt;Hi Bryan,Thanks for the updates and the committing and it&apos;s my pleasure to&lt;br/&gt;
have more codes in DERBY with my contribution.&lt;br/&gt;
I am closing this issue.&lt;/p&gt;

</comment>
                            <comment id="12989878" author="kmarsden" created="Wed, 2 Feb 2011 23:38:18 +0000"  >&lt;p&gt;Reopen for backport.&lt;/p&gt;</comment>
                            <comment id="12996078" author="kmarsden" created="Thu, 17 Feb 2011 21:07:32 +0000"  >&lt;p&gt;Assigning to myself temporarily for backport.&lt;/p&gt;</comment>
                            <comment id="12996579" author="kmarsden" created="Fri, 18 Feb 2011 19:47:35 +0000"  >&lt;p&gt;Resolving after port to 10.5.  Thank you Eranda for the fix!&lt;/p&gt;</comment>
                            <comment id="13685305" author="knutanders" created="Mon, 17 Jun 2013 10:19:37 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                                                <inwardlinks description="is required by">
                                        <issuelink>
            <issuekey id="12497378">DERBY-4994</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12426308">DERBY-4248</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12416161" name="ASF.LICENSE.NOT.GRANTED--DERBY4282.diff" size="5209" author="eranda" created="Tue, 11 Aug 2009 06:13:16 +0100"/>
                            <attachment id="12416160" name="ASF.LICENSE.NOT.GRANTED--DERBY4282.diff" size="1728" author="eranda" created="Tue, 11 Aug 2009 05:57:17 +0100"/>
                            <attachment id="12413209" name="cons.java" size="778" author="bryanpendleton" created="Sat, 11 Jul 2009 18:06:20 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 22 Jun 2009 14:53:14 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24154</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10423"><![CDATA[Newcomer]]></customfieldvalue>
    <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0htz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36707</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>