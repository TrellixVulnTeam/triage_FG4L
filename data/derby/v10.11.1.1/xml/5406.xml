<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:08:44 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-5406/DERBY-5406.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-5406] Intermittent failures in CompressTableTest and TruncateTableTest</title>
                <link>https://issues.apache.org/jira/browse/DERBY-5406</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The test cases CompressTableTest.testConcurrentInvalidation() and TruncateTableTest.testConcurrentInvalidation() fail intermittently with errors such as:&lt;/p&gt;

&lt;p&gt;ERROR XSAI2: The conglomerate (2,720) requested does not exist.&lt;/p&gt;

&lt;p&gt;The problem has been analyzed in the comments on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4275&quot; title=&quot;Query executions fail when compressing a table using SYSCS_UTIL.SYSCS_COMPRESS_TABLE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4275&quot;&gt;&lt;del&gt;DERBY-4275&lt;/del&gt;&lt;/a&gt;, and a patch attached to that issue (invalidation-during-compilation.diff) fixes the underlying race condition. However, that patch only works correctly together with the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5161&quot; title=&quot;Cannot rollback after syntax error in internal statement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5161&quot;&gt;&lt;del&gt;DERBY-5161&lt;/del&gt;&lt;/a&gt;, which was backed out because it caused the regression &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5280&quot; title=&quot;Large batch of DDL in a database procedure dies on a transaction severity error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5280&quot;&gt;&lt;del&gt;DERBY-5280&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We will therefore need to find a way to fix &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5161&quot; title=&quot;Cannot rollback after syntax error in internal statement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5161&quot;&gt;&lt;del&gt;DERBY-5161&lt;/del&gt;&lt;/a&gt; without reintroducing &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5280&quot; title=&quot;Large batch of DDL in a database procedure dies on a transaction severity error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5280&quot;&gt;&lt;del&gt;DERBY-5280&lt;/del&gt;&lt;/a&gt; in order to resolve this issue.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12522398">DERBY-5406</key>
            <summary>Intermittent failures in CompressTableTest and TruncateTableTest</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Fri, 9 Sep 2011 10:54:47 +0100</created>
                <updated>Thu, 1 Nov 2012 21:10:43 +0000</updated>
                            <resolved>Mon, 23 Jan 2012 14:23:31 +0000</resolved>
                                    <version>10.8.2.2</version>
                    <version>10.9.1.0</version>
                                    <fixVersion>10.8.3.0</fixVersion>
                    <fixVersion>10.9.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="13108594" author="knutanders" created="Tue, 20 Sep 2011 12:19:47 +0100"  >&lt;p&gt;The attached patch (d5406-1a-detect-invalidation-during-compilation.diff) improves the invalidation-during-compilation.diff patch attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4275&quot; title=&quot;Query executions fail when compressing a table using SYSCS_UTIL.SYSCS_COMPRESS_TABLE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4275&quot;&gt;&lt;del&gt;DERBY-4275&lt;/del&gt;&lt;/a&gt; by restoring the state of the context stack before retrying the compilation. This prevents the &quot;Cannot issue commit in a nested connection&quot; errors seen with the original patch.&lt;/p&gt;

&lt;p&gt;Although the patch makes the failures happen less frequently, there still appears to be race conditions in this area. I&apos;ve seen the following two failures when running the D4275.java repro attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4275&quot; title=&quot;Query executions fail when compressing a table using SYSCS_UTIL.SYSCS_COMPRESS_TABLE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4275&quot;&gt;&lt;del&gt;DERBY-4275&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;1) java.sql.SQLException: The conglomerate (1,136) requested does not exist.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:98)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:256)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:400)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:348)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2290)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:82)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:150)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(EmbedPreparedStatement20.java:82)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(EmbedPreparedStatement30.java:63)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(EmbedPreparedStatement40.java:40)&lt;br/&gt;
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Driver40.java:107)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(EmbedConnection.java:1615)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(EmbedConnection.java:1443)&lt;br/&gt;
	at D4275$1.run0(D4275.java:32)&lt;br/&gt;
	at D4275$1.run(D4275.java:23)&lt;br/&gt;
Caused by: java.sql.SQLException: The conglomerate (1,136) requested does not exist.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:122)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:71)&lt;br/&gt;
	... 14 more&lt;br/&gt;
Caused by: ERROR XSAI2: The conglomerate (1,136) requested does not exist.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:278)&lt;br/&gt;
	at org.apache.derby.impl.store.access.heap.HeapConglomerateFactory.readConglomerate(HeapConglomerateFactory.java:254)&lt;br/&gt;
	at org.apache.derby.impl.store.access.RAMAccessManager.conglomCacheFind(RAMAccessManager.java:482)&lt;br/&gt;
	at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(RAMTransaction.java:394)&lt;br/&gt;
	at org.apache.derby.impl.store.access.RAMTransaction.getStaticCompiledConglomInfo(RAMTransaction.java:665)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.BaseJoinStrategy.fillInScanArgs1(BaseJoinStrategy.java:100)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.NestedLoopJoinStrategy.getScanArgs(NestedLoopJoinStrategy.java:252)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.getScanArguments(FromBaseTable.java:3496)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.generateResultSet(FromBaseTable.java:3186)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.generate(FromBaseTable.java:3113)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(ProjectRestrictNode.java:1382)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(ProjectRestrictNode.java:1334)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(ProjectRestrictNode.java:1382)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(ProjectRestrictNode.java:1334)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.ScrollInsensitiveResultSetNode.generate(ScrollInsensitiveResultSetNode.java:109)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.CursorNode.generate(CursorNode.java:637)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.StatementNode.generate(StatementNode.java:345)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:472)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:93)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:1103)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:131)&lt;br/&gt;
	... 8 more&lt;br/&gt;
Test stopped after 2927 ms&lt;/p&gt;

&lt;p&gt;This error happens in a different code path, outside of the current retry logic.&lt;/p&gt;

&lt;p&gt;2) java.sql.SQLException: The conglomerate (136,832) requested does not exist.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:98)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:256)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:400)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:348)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2290)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:82)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1334)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1686)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeQuery(EmbedPreparedStatement.java:284)&lt;br/&gt;
	at D4275$1.run0(D4275.java:35)&lt;br/&gt;
	at D4275$1.run(D4275.java:23)&lt;br/&gt;
Caused by: java.sql.SQLException: The conglomerate (136,832) requested does not exist.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(SQLExceptionFactory40.java:122)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(SQLExceptionFactory40.java:71)&lt;br/&gt;
	... 10 more&lt;br/&gt;
Caused by: ERROR XSAI2: The conglomerate (136,832) requested does not exist.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:278)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromBaseTable.bindNonVTITables(FromBaseTable.java:2352)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.FromList.bindTables(FromList.java:317)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.SelectNode.bindNonVTITables(SelectNode.java:489)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.DMLStatementNode.bindTables(DMLStatementNode.java:199)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.DMLStatementNode.bind(DMLStatementNode.java:137)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.CursorNode.bindStatement(CursorNode.java:253)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:327)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:85)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.rePrepare(GenericPreparedStatement.java:231)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:414)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:319)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1242)&lt;br/&gt;
	... 4 more&lt;br/&gt;
Test stopped after 78573 ms&lt;/p&gt;

&lt;p&gt;This error does go through the code path with the retry logic, but it doesn&apos;t trigger a retry, so it looks like the invalidation somehow gets lost.&lt;/p&gt;</comment>
                            <comment id="13114590" author="knutanders" created="Mon, 26 Sep 2011 11:58:20 +0100"  >&lt;p&gt;Attaching a new revision (1b) of the patch that prevents invalidation requests to get lost if a compilation is already in progress. It adds some more comments, and also moves the restoring of the context stack out from the block synchronized on the GPS, since it only modifies state local to the LCC and doesn&apos;t need statement-global synchronization.&lt;/p&gt;

&lt;p&gt;Committed revision 1175785.&lt;/p&gt;</comment>
                            <comment id="13129781" author="knutanders" created="Tue, 18 Oct 2011 16:03:54 +0100"  >&lt;p&gt;Of the two stack traces mentioned above, I see (2) more frequently than (1). (I also sometimes see other stack traces, and I suspect there may be multiple holes.)&lt;/p&gt;

&lt;p&gt;Stack trace (2) is in fact the same problem that caused the NullPointerException fixed in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4275&quot; title=&quot;Query executions fail when compressing a table using SYSCS_UTIL.SYSCS_COMPRESS_TABLE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4275&quot;&gt;&lt;del&gt;DERBY-4275&lt;/del&gt;&lt;/a&gt;. The fix made it throw a StandardException instead, so that the retry logic would come into play. In some cases it actually does recover from that error, but apparently not always. Here&apos;s what I think is happening in FromBaseTable.bindNonVTITables() when this error occurs:&lt;/p&gt;

&lt;p&gt;1) The statement is in the process of being recompiled, and it builds the table descriptor at line 2190:&lt;/p&gt;

&lt;p&gt;		TableDescriptor tableDescriptor = bindTableDescriptor();&lt;/p&gt;

&lt;p&gt;2) The statement&apos;s dependency on the table is registered at line 2341:&lt;/p&gt;

&lt;p&gt;			/* This represents a table - query is dependent on the TableDescriptor */&lt;br/&gt;
			compilerContext.createDependency(tableDescriptor);&lt;/p&gt;

&lt;p&gt;3) It discovers that the conglomerate referred to by the table descriptor no longer exists at line 2351 and raises an exception:&lt;/p&gt;

&lt;p&gt;            // Bail out if the descriptor couldn&apos;t be found. The conglomerate&lt;br/&gt;
            // probably doesn&apos;t exist anymore.&lt;br/&gt;
            if (baseConglomerateDescriptor == null) &lt;/p&gt;
{
                throw StandardException.newException(
                        SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST,
                        new Long(tableDescriptor.getHeapConglomerateId()));
            }

&lt;p&gt;Now, the conglomerate disappeared some time after the table descriptor was built, because of a compress or truncate operation. If the dependency on the table had been registered before the conglomerate was removed, the compress/truncate operation will have invalidated the statement, so the retry logic knows it should try again.&lt;/p&gt;

&lt;p&gt;If the compress/truncate operation happened after the table descriptor was built, but before the dependency was registered, the statement will not be invalidated. In that case, the retry logic does not know that an invalidation has occurred, and it won&apos;t retry the compilation.&lt;/p&gt;

&lt;p&gt;So it looks like we either need to find a way to close the window between the calls to bindTableDescriptor() and createDependency(), or when this happens the statement should invalidate itself before it throws the exception.&lt;/p&gt;</comment>
                            <comment id="13131684" author="knutanders" created="Thu, 20 Oct 2011 16:10:09 +0100"  >&lt;p&gt;Attaching patch 2a which makes FromBaseTable.bindNonVTITables() invalidate the statement itself when it discovers that the conglomerate has disappeared. That way, if the conglomerate was dropped between buildTableDescriptor() and createDependency() so that the original invalidation was lost, we&apos;ll still invalidate the statement and make GenericPreparedStatement.executeStmt() detect that a recompilation is needed.&lt;/p&gt;

&lt;p&gt;I&apos;ve run four parallel instances of the D4275 test case for 1.5 hours without seeing any instances of stack trace (2) mentioned in an earlier comment. That stack trace usually reproduces in 2 to 5 minutes on the same machine without the patch.&lt;/p&gt;

&lt;p&gt;A very similar stack trace was seen three times in those 1.5 hours. That exception was thrown at the exact same place in FromBaseTable, but the re-compilation had been started at a lower level, from GenericActivationHolder, instead of directly from GenericPreparedStatement.executeStmt().&lt;/p&gt;

&lt;p&gt;I think the reason why it still fails if the compilation was started at a lower level, is that the self-invalidation introduced by this patch is ignored because it happens while the statement is being compiled. This was the exact same problem as the one addressed by the 1b patch. However, the 1b patch only added logic to retry compilations started directly from GenericPreparedStatement.executeStmt(). So it looks like the retry logic from 1b must be enhanced to cover more cases.&lt;/p&gt;

&lt;p&gt;But, in any case, I think the 2a patch is an improvement on its own. It makes the failures happen less frequently, and I haven&apos;t noticed any new failures because of it.&lt;/p&gt;

&lt;p&gt;The full regression test suite is currently running. I plan to commit the patch if all the tests pass, and then I&apos;ll go on trying to fix the retry logic for the cases that are still missed out.&lt;/p&gt;</comment>
                            <comment id="13132323" author="kristwaa" created="Fri, 21 Oct 2011 05:35:23 +0100"  >&lt;p&gt;Patch 2a looks like a good improvement to me too, Knut Anders. It&apos;s clean and concise.&lt;/p&gt;

&lt;p&gt;Just by looking at the patch I have one question: will getCurrentDependent() always return a dependent, or is null a valid return value as well?&lt;/p&gt;</comment>
                            <comment id="13132501" author="knutanders" created="Fri, 21 Oct 2011 09:08:16 +0100"  >&lt;p&gt;Thanks for looking at the patch, Kristian.&lt;/p&gt;

&lt;p&gt;I think getCurrentDependent() is guaranteed to return a non-null dependent at that location in the code for the following reasons:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;JavaDoc for CompilerContext.setCurrentDependent() says&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;This should be called at the start of a compile to&lt;/li&gt;
	&lt;li&gt;register who has the dependencies needed for the compilation.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;so it sounds like the compiler context is expected to have a dependent once the compilation has started.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompilerContextImpl.createDependency(Provider), which is called just a few lines before getCurrentDependent() is called, has the following assertion:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;		SanityManager.ASSERT(currentDependent != null,&lt;br/&gt;
				&quot;no current dependent for compilation&quot;);&lt;/p&gt;

&lt;p&gt;(and in insane builds it would fail with a NullPointerException) so we should not come to that point in the code if the dependent was null.&lt;/p&gt;</comment>
                            <comment id="13132503" author="knutanders" created="Fri, 21 Oct 2011 09:13:05 +0100"  >&lt;p&gt;Committed the 2a patch with revision 1187204.&lt;/p&gt;</comment>
                            <comment id="13133896" author="knutanders" created="Mon, 24 Oct 2011 09:41:20 +0100"  >&lt;p&gt;I mentioned that I still saw similar stack traces when the compilation was&lt;br/&gt;
invoked from GenericActivationHolder.execute() instead of&lt;br/&gt;
GenericPreparedStatement.executeStmt(), and suggested that&lt;br/&gt;
GenericActivationHolder needed retry logic similar to the one in&lt;br/&gt;
GenericPreparedStatement.&lt;/p&gt;

&lt;p&gt;The attached patch (d5406-3a.diff) takes a somewhat different approach. Instead&lt;br/&gt;
of adding the extra logic to GenericActivationHolder, it makes&lt;br/&gt;
GenericActivationHolder.execute() stop re-preparing the statement if it detects&lt;br/&gt;
that it&apos;s using an outdated generated class. Instead, it just asks the prepared&lt;br/&gt;
statement to give it the most recent version of the generated class.&lt;/p&gt;

&lt;p&gt;In most cases, it will receive an up-to-date version of the class, and it can&lt;br/&gt;
continue without recompiling (the existing code would short-circuit the&lt;br/&gt;
rePrepare() call in that case, so no changes in this scenario).&lt;/p&gt;

&lt;p&gt;If an invalidation happened after the last recompilation of the statement, the&lt;br/&gt;
fresh version of the generated class will also be outdated. With the existing&lt;br/&gt;
code, a recompilation would be requested immediately. With the patch, however,&lt;br/&gt;
we just go ahead executing using the outdated class. The execution code already&lt;br/&gt;
has checks for invalid plans, so it will be detected by the normal execution&lt;br/&gt;
mechanisms. This has the advantage that the invalid plans will be reported in a&lt;br/&gt;
way that GenericPreparedStatement.executeStmt() is able to detect, and the&lt;br/&gt;
recompilation will be done by GenericPreparedStatement.executeStmt(). Since we&lt;br/&gt;
already have the required retry logic in place there, re-invalidation of the&lt;br/&gt;
statement during the recompilation will be detected and handled properly.&lt;/p&gt;

&lt;p&gt;(This is, by the way, the exact same thing as the existing code would do if the&lt;br/&gt;
invalidation had happened right after we had fetched the fresh class. So this&lt;br/&gt;
change could be seen as handling the two cases - invalidation right before&lt;br/&gt;
retrieving the class and invalidation right after retrieving the class -&lt;br/&gt;
uniformly.)&lt;/p&gt;

&lt;p&gt;Another edge case is that the returned generated class could be null. This&lt;br/&gt;
happens if another thread was recompiling the statement when we retrieved the&lt;br/&gt;
class. In that case, the patch makes GenericActivationHolder.execute() throw an&lt;br/&gt;
exception with message id LANG_STATEMENT_NEEDS_RECOMPILE. This is a special&lt;br/&gt;
kind of exception that GenericPreparedStatement.executeStmt() detects and takes&lt;br/&gt;
as a signal to recompile the statement. Again, the recompilation will happen&lt;br/&gt;
using the code that&apos;s already prepared for the need to retry in case of&lt;br/&gt;
re-invalidations, so we should be covered if the conglomerate disappears during&lt;br/&gt;
that compilation too.&lt;/p&gt;

&lt;p&gt;This also has the benefit that we can remove the workaround for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3260&quot; title=&quot;NullPointerException caused by race condition in GenericActivationHolder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3260&quot;&gt;&lt;del&gt;DERBY-3260&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
where we added a synchronization block around the calls to rePrepare() and&lt;br/&gt;
getActivationClass() to prevent that a concurrent recompilation made&lt;br/&gt;
getActivationClass() return null.&lt;/p&gt;

&lt;p&gt;All the regression tests ran cleanly with the patch.&lt;/p&gt;

&lt;p&gt;I also ran my standard test case, four parallel processes of the D4275 class,&lt;br/&gt;
for two hours without seeing any failures.&lt;/p&gt;</comment>
                            <comment id="13135791" author="knutanders" created="Wed, 26 Oct 2011 09:07:58 +0100"  >&lt;p&gt;Committed the 3a patch to trunk with revision 1189067.&lt;/p&gt;</comment>
                            <comment id="13135867" author="knutanders" created="Wed, 26 Oct 2011 12:04:29 +0100"  >&lt;p&gt;Attaching a class (CompressAndPrepare.java) that can be used to more easily reproduce the stack trace (1) in the first comment on this issue. This repro repeatedly prepares a query while another thread repeatedly compresses a table used by the query.&lt;/p&gt;

&lt;p&gt;The difference between the stack traces (1) and (2) is that the former happens in prepareStatement(), whereas the latter happens in executeQuery().&lt;/p&gt;

&lt;p&gt;When running the class on an idle system, it can run for a long time without showing the error (at least in my environment). But when putting on some background load, for example by running two instances of the repro concurrently, I get the error within seconds.&lt;/p&gt;</comment>
                            <comment id="13136087" author="knutanders" created="Wed, 26 Oct 2011 17:35:27 +0100"  >&lt;p&gt;The attached d5406-4a-push-retry-logic.diff patch attempts to fix stack trace (1) by pushing the retry logic further down into GenericStatement.prepare(). That method is used both when the compilation request comes from prepareStatement() and when it comes from the execution.&lt;/p&gt;

&lt;p&gt;I don&apos;t see stack trace (1) when I run the CompressAndPrepare repro. I saw a couple occurrences of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5358&quot; title=&quot;SYSCS_COMPRESS_TABLE failed with conglomerate not found exception&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5358&quot;&gt;&lt;del&gt;DERBY-5358&lt;/del&gt;&lt;/a&gt;, but no other errors.&lt;/p&gt;

&lt;p&gt;All the regression tests passed with the patch.&lt;/p&gt;

&lt;p&gt;More disappointing, I saw an error appear a couple of times when I ran the D4275 repro. However, I also saw this error without the patch, so it looks like an existing hole, and not something caused by this patch. No idea why I didn&apos;t see it when I tested the 3a patch in the same environment. Here&apos;s the stack trace I saw:&lt;/p&gt;

&lt;p&gt;Caused by: ERROR XSAI2: The conglomerate (20&#160;848) requested does not exist.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:278)&lt;br/&gt;
        at org.apache.derby.impl.store.access.heap.HeapConglomerateFactory.readConglomerate(HeapConglomerateFactory.java:254)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMAccessManager.conglomCacheFind(RAMAccessManager.java:482)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.findExistingConglomerate(RAMTransaction.java:394)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.getStaticCompiledConglomInfo(RAMTransaction.java:665)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.BaseJoinStrategy.fillInScanArgs1(BaseJoinStrategy.java:100)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.NestedLoopJoinStrategy.getScanArgs(NestedLoopJoinStrategy.java:252)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.FromBaseTable.getScanArguments(FromBaseTable.java:3510)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.FromBaseTable.generateResultSet(FromBaseTable.java:3200)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.FromBaseTable.generate(FromBaseTable.java:3127)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(ProjectRestrictNode.java:1382)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(ProjectRestrictNode.java:1334)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(ProjectRestrictNode.java:1382)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(ProjectRestrictNode.java:1334)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.ScrollInsensitiveResultSetNode.generate(ScrollInsensitiveResultSetNode.java:109)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.CursorNode.generate(CursorNode.java:637)&lt;br/&gt;
        at org.apache.derby.impl.sql.compile.StatementNode.generate(StatementNode.java:345)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:517)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:97)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:85)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.rePrepare(GenericPreparedStatement.java:231)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:411)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:319)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1242)&lt;br/&gt;
        ... 4 more&lt;/p&gt;</comment>
                            <comment id="13136104" author="knutanders" created="Wed, 26 Oct 2011 17:51:06 +0100"  >&lt;p&gt;Setting the patch available flag since the patch passes the regression tests, and the problems still seen with the stress test for this issue are also seen without the patch.&lt;/p&gt;</comment>
                            <comment id="13138202" author="knutanders" created="Fri, 28 Oct 2011 10:49:58 +0100"  >&lt;p&gt;Committed d5406-4a-push-retry-logic.diff to trunk revision 1190220.&lt;/p&gt;

&lt;p&gt;Then there&apos;s hopefully just one single exception left to fix before we can declare victory on this issue (see comment dated 26/Oct/11 16:35). I added some instrumentation and found that the statement did not have the invalidatedWhileCompiling flag set, which means that it wasn&apos;t retried because the invalidation was lost somehow.&lt;/p&gt;

&lt;p&gt;My guess is that its cause is similar to the case fixed by patch 2a. The statement is invalidated after we have built the table descriptor, but before we have registered the statement as a dependent of the table. However, contrary to the case fixed by 2a, the conglomerate isn&apos;t actually removed before we fetch the conglomerate descriptor, so the self-invalidation logic we added to the error handling when the conglomerate descriptor is missing, doesn&apos;t help in this case. The conglomerate is removed a little later, though, so the compilation will fail, but without the invalidation flag set, the compilation will not be retried.&lt;/p&gt;

&lt;p&gt;I&apos;m wondering if a more robust approach would be to retry the compilation always if it fails because of a missing conglomerate. That&apos;s an error that will never be reported to the user unless there&apos;s a bug in Derby, I think, so retrying the compilation in those cases shouldn&apos;t be a problem. And if we get an error about the same conglomerate missing on the retry, we could report it to prevent infinite loops in case there actually is a problem that must be reported. In the case of a concurrent compress or truncate operation, we should find the new conglomerate when retrying. If the conglomerate is missing because of a drop operation, the recompilation will fail, but it should fail earlier because the system tables have been updated with the correct information, and the error message will be more informative (typically: &quot;Table T does not exist&quot; instead of &quot;Conglomerate X does not exist&quot;).&lt;/p&gt;</comment>
                            <comment id="13147040" author="knutanders" created="Wed, 9 Nov 2011 13:32:07 +0000"  >&lt;p&gt;I experimented with always retrying the compilation if it failed with conglomerate does not exist, see the attached patch d5406-4a-retry-on-conglomerate-error.diff. That patch also backs out the changes in the 2a patch, since the case addressed by that fix will also be covered by the broader fix in the 4a patch.&lt;/p&gt;

&lt;p&gt;I ran four parallel processes of the D4275 repro for almost two hours, two of the processes with the fix and two without the fix. The processes that had the fix only had one occurrence of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5358&quot; title=&quot;SYSCS_COMPRESS_TABLE failed with conglomerate not found exception&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5358&quot;&gt;&lt;del&gt;DERBY-5358&lt;/del&gt;&lt;/a&gt;, and no other errors. The processes that ran without the fix, had about 30 errors.&lt;/p&gt;

&lt;p&gt;So this fix appears to take care of the remaining issues, at least those I&apos;m able to reproduce. It is however just a workaround for a more fundamental problem with how we track dependencies between statements and conglomerates. I would have felt more comfortable if we found a way to fix the underlying issue that makes invalidation requests vanish. I&apos;ll do a little more digging before I give up...&lt;/p&gt;

&lt;p&gt;All regression tests ran cleanly with the 4a patch, except one intermittent failure (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5498&quot; title=&quot;ClosedByInterruptException in AuthenticationTest&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5498&quot;&gt;&lt;del&gt;DERBY-5498&lt;/del&gt;&lt;/a&gt;) that didn&apos;t show up when rerunning the tests.&lt;/p&gt;</comment>
                            <comment id="13187787" author="mikem" created="Tue, 17 Jan 2012 16:29:50 +0000"  >&lt;p&gt;I have a user with a trigger referencing a bad conglomerate number.  With the &quot;right&quot; set of circumstances could this issue cause a trigger to not get recompiled after a compress and be left with the old conglomerate number?&lt;/p&gt;</comment>
                            <comment id="13188563" author="knutanders" created="Wed, 18 Jan 2012 17:41:41 +0000"  >&lt;p&gt;Triggers use a different code path for doing the recompiling, but I think they also suffer from the problems with invalidations that get lost if they happen during compilation. I&apos;m not sure if any of the fixes that have gone into this issue would help the trigger case. Probably not, since most of the new code lives in GenericStatement.prepare(), which on first look doesn&apos;t seem to be used when preparing a trigger.&lt;/p&gt;</comment>
                            <comment id="13188813" author="mikem" created="Wed, 18 Jan 2012 23:47:34 +0000"  >&lt;p&gt;saw following in nightly&apos;s, 10.8 current branch, windows, ibm15 jvm.  This looks like another occurence of this bug.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://people.apache.org/~myrnavl/derby_test_results/v10_8/windows/testlog/ibm15/1231438-suites.All_diff.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://people.apache.org/~myrnavl/derby_test_results/v10_8/windows/testlog/ibm15/1231438-suites.All_diff.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1) testConcurrentInvalidation(org.apache.derbyTesting.functionTests.tests.lang.TruncateTableTest)junit.framework.AssertionFailedError: Helper thread failed&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.fail(BaseTestCase.java:813)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.lang.TruncateTableTest.testConcurrentInvalidation(TruncateTableTest.java:359)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:79)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:113)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
Caused by: java.sql.SQLException: The conglomerate (3696) requested does not exist.&lt;br/&gt;
	at org.apache.derby.client.am.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.am.SqlException.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.lang.TruncateTableTest$1.run(TruncateTableTest.java:331)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: The conglomerate (3696) requested does not exist.&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeSqlca(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.am.Statement.completeOpenQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseOpenQueryFailure(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.parseOPNQRYreply(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatementReply.readOpenQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.net.StatementReply.readOpenQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.net.NetStatement.readOpenQuery_(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.am.Statement.readOpenQuery(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.flowExecute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.client.am.PreparedStatement.executeQueryX(Unknown Source)&lt;br/&gt;
	... 2 more&lt;/p&gt;</comment>
                            <comment id="13190077" author="mikem" created="Fri, 20 Jan 2012 20:38:15 +0000"  >&lt;p&gt;do you still think we should not checkin your most current patch to this issue?  The patch seems good to me in that at least it will reduce errors reported to user.  I didn&apos;t see much downside with this approach, as it only affects the error&lt;br/&gt;
code path with an added retry.  &lt;/p&gt;

&lt;p&gt;I agree it would be best to fix the underlying issue, but at least this patch seems like a good incremental step to make&lt;br/&gt;
the system better until we get there.  &lt;/p&gt;</comment>
                            <comment id="13191176" author="knutanders" created="Mon, 23 Jan 2012 14:23:31 +0000"  >&lt;p&gt;Thanks for looking at the patch, Mike. I haven&apos;t come any closer to a good solution for the underlying problem, so I agree that it&apos;s better to check in the workaround for now. Committed revision 1234776.&lt;/p&gt;

&lt;p&gt;Since multiple fixes have been checked in as part of this issue, and each of them fixed actual problems, I think it is OK to mark this issue as resolved for now. If more problems of similar nature surface, new and more specific bug reports should be filed to get those problems fixed.&lt;/p&gt;</comment>
                            <comment id="13191430" author="mikem" created="Mon, 23 Jan 2012 20:39:45 +0000"  >&lt;p&gt;are the fixes associated with this derby issue appropriate for backport, i do see that it is not going to be a simple merge as there are a number of svn commits and some backouts of other changes.  &lt;/p&gt;

&lt;p&gt;Any idea how old the issues are, I assume they at least go back as far as 10.5.&lt;/p&gt;</comment>
                            <comment id="13191565" author="knutanders" created="Mon, 23 Jan 2012 22:34:26 +0000"  >&lt;p&gt;I think merging to 10.8 should be straightforward. Not sure how many conflicts to expect when merging further back. I suppose at least &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4275&quot; title=&quot;Query executions fail when compressing a table using SYSCS_UTIL.SYSCS_COMPRESS_TABLE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4275&quot;&gt;&lt;del&gt;DERBY-4275&lt;/del&gt;&lt;/a&gt; would have to be merged first.&lt;/p&gt;

&lt;p&gt;I think most of these issues go all the way back, but I haven&apos;t checked. Dag verified that the repro for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4275&quot; title=&quot;Query executions fail when compressing a table using SYSCS_UTIL.SYSCS_COMPRESS_TABLE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4275&quot;&gt;&lt;del&gt;DERBY-4275&lt;/del&gt;&lt;/a&gt; failed on 10.4, and that&apos;s the repro used to show the problems in this JIRA issue too.&lt;/p&gt;</comment>
                            <comment id="13195217" author="mikem" created="Fri, 27 Jan 2012 23:13:40 +0000"  >&lt;p&gt;I am looking at backporting this fix to 10.8, so setting ownership to myself.&lt;/p&gt;</comment>
                            <comment id="13198010" author="mikem" created="Wed, 1 Feb 2012 18:05:15 +0000"  >&lt;p&gt;backported change from trunk to 10.8.  resetting original owner.  &lt;/p&gt;

&lt;p&gt;To backport farther back, this change may depend on other changes, as is discussed in previous comments of this issue.  &lt;/p&gt;

&lt;p&gt;Hope is that this backport will elinate current intermittent failures in the nightly tests against 10.8 as they did for trunk.   At this point since this issue is closed any new failures seen in these 2 tests in versions that have the fix should be logged in a new issue and can&lt;br/&gt;
be linked back to this one  &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12428006">DERBY-4275</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12502679">DERBY-5161</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12500862" name="CompressAndPrepare.java" size="1766" author="knutanders" created="Wed, 26 Oct 2011 12:04:29 +0100"/>
                            <attachment id="12495211" name="d5406-1a-detect-invalidation-during-compilation.diff" size="3850" author="knutanders" created="Tue, 20 Sep 2011 12:19:47 +0100"/>
                            <attachment id="12496464" name="d5406-1b.diff" size="4137" author="knutanders" created="Mon, 26 Sep 2011 11:58:20 +0100"/>
                            <attachment id="12499869" name="d5406-2a-invalidate-self.diff" size="3742" author="knutanders" created="Thu, 20 Oct 2011 16:10:09 +0100"/>
                            <attachment id="12500410" name="d5406-3a.diff" size="2757" author="knutanders" created="Mon, 24 Oct 2011 09:41:20 +0100"/>
                            <attachment id="12500901" name="d5406-4a-push-retry-logic.diff" size="6864" author="knutanders" created="Wed, 26 Oct 2011 17:35:27 +0100"/>
                            <attachment id="12503079" name="d5406-4a-retry-on-conglomerate-error.diff" size="7969" author="knutanders" created="Wed, 9 Nov 2011 13:32:07 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10369"><![CDATA[Regression Test Failure]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 21 Oct 2011 04:35:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3322</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0apb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35552</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>