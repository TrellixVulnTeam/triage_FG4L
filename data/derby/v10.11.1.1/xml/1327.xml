<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:40:35 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1327/DERBY-1327.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1327] Identity column can be  created with wrong and very large start with value with  &quot;J2RE 1.5.0 IBM Windows 32 build pwi32dev-20060412 (SR2)&quot; with JIT on</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1327</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Using the following JRE with JIT on  an identity column may be created with a wrong and very large START WITH value.  When the problem occurs it affects not only the table being created, but also other tables that were created in previous transactions.&lt;/p&gt;

&lt;p&gt;For example attempting to create 1000 tables with identity columns the 126th table creation changes the start with value in sys.syscolumns to 41628850257395713 for ALL 125 tables.  Attempts to insert into any of the tables cause&lt;br/&gt;
&quot;SQL Exception: A truncation error was encountered trying to &lt;br/&gt;
shrink ... to length 12.&quot; &lt;/p&gt;


&lt;p&gt;This program will create up to 1000 tables until the problem &lt;br/&gt;
occurs&lt;br/&gt;
Note:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The problem does not occur with -Xnojit (JIT OFF)&lt;/li&gt;
	&lt;li&gt;The problem, when it occurs, changes not only the table being&lt;br/&gt;
created but all previous tables created.  See output below. &lt;br/&gt;
Every thing was fine up until mytable126 and then all the &lt;br/&gt;
tables got changed to start with 41628850257395713 &lt;/li&gt;
	&lt;li&gt;Problem occurs with autocommit on/off.&lt;/li&gt;
	&lt;li&gt;The problem occurs after the create table but before the&lt;br/&gt;
commit.&lt;/li&gt;
	&lt;li&gt;If the non-identity columns are removed the problem does not&lt;br/&gt;
reproduce.&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;import java.sql.DatabaseMetaData;&lt;br/&gt;
import java.sql.ResultSet;&lt;br/&gt;
import java.sql.SQLException;&lt;br/&gt;
import java.sql.Statement;&lt;br/&gt;
import java.sql.DriverManager;&lt;/p&gt;




&lt;p&gt;public class BadStartWith&lt;br/&gt;
{&lt;/p&gt;


&lt;p&gt;    public static void main (String args [])throws Exception &lt;/p&gt;
    {
    	testBadStartWith();
    }

&lt;p&gt;    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;After some number of table creations with JIT turned on, the START WITH value&lt;/li&gt;
	&lt;li&gt;for the table being created and all the ones already created gets mysteriously&lt;/li&gt;
	&lt;li&gt;changed with pwi32dev-20060412 (SR2)&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@throws Exception&lt;br/&gt;
     */&lt;br/&gt;
    public static void testBadStartWith() throws Exception&lt;br/&gt;
    {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;		Class.forName(&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;).newInstance();&lt;br/&gt;
		Connection conn = DriverManager.getConnection(&quot;jdbc:derby:wombat;create=true&quot;);&lt;br/&gt;
               conn.setAutoCommit(false);&lt;br/&gt;
		Statement stmt = null;&lt;/p&gt;


&lt;p&gt;		DatabaseMetaData md = conn.getMetaData() ;&lt;br/&gt;
		System.out.println(md.getDatabaseProductVersion());&lt;br/&gt;
               System.out.println(md.getDatabaseProductName());&lt;br/&gt;
                System.out.println(md.getDriverName());&lt;br/&gt;
		dropAllAppTables(conn);&lt;br/&gt;
		System.out.println(&quot;Create tables until we get a wrong Start with value&quot;);&lt;br/&gt;
		stmt = conn.createStatement();&lt;/p&gt;

&lt;p&gt;		// numBadStartWith will be changed if any columns get a bad start with value.&lt;br/&gt;
		int numBadStartWith = 0; &lt;/p&gt;

&lt;p&gt;		try {&lt;br/&gt;
			// create 1000 tables.  Break out if we get a table that has a bad&lt;br/&gt;
			// start with value.&lt;br/&gt;
			for (int i = 0; (i &amp;lt; 1000) &amp;amp;&amp;amp; (numBadStartWith == 0); i++)&lt;/p&gt;
			{
				String tableName = &quot;APP.MYTABLE&quot; + i;
			    String createTableSQL = &quot;CREATE TABLE &quot; + tableName + &quot;  (ROLEID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 2, INCREMENT BY 1), INSTANCEID INTEGER, STATUS INTEGER, LOGICAL_STATE INTEGER, LSTATE_TSTAMP  TIMESTAMP, UPDT_TSTAMP TIMESTAMP, TSTAMP TIMESTAMP, CLALEVEL1_CLALEVEL2_CLALEVEL2ID VARCHAR(255),  CLALEVEL1_CLALEVEL2_CLALEVEL3_CLALEVEL3ID VARCHAR(255))&quot;;
				
				stmt.executeUpdate(createTableSQL);
				System.out.println(createTableSQL);
                System.out.println(&quot;Check before commit&quot;);
                numBadStartWith = checkBadStartWithCols(conn,2);
                conn.commit();
                System.out.println(&quot;Check after commit&quot;);
				numBadStartWith = checkBadStartWithCols(conn,2);
				if (numBadStartWith &amp;gt; 0)
					break;
			}
&lt;p&gt;		} catch (SQLException se)&lt;/p&gt;
		{
			se.printStackTrace();
		}
&lt;p&gt;		if (numBadStartWith == 0)&lt;br/&gt;
			System.out.println(&quot;PASS: All 1000 tables created without problems&quot;);&lt;br/&gt;
		stmt.close();&lt;br/&gt;
		conn.rollback();&lt;br/&gt;
        conn.close();&lt;br/&gt;
	}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Check that all tables in App do not have a an autoincrementstart value&lt;/li&gt;
	&lt;li&gt;greater tan maxautoincrementstart&lt;/li&gt;
	&lt;li&gt;@param conn&lt;/li&gt;
	&lt;li&gt;@param maxautoincrementstart  Maximum expected autoincrementstart value&lt;/li&gt;
	&lt;li&gt;@return number of columns with bad autoincrementstart value&lt;br/&gt;
 */&lt;br/&gt;
	private static int checkBadStartWithCols(Connection conn, int&lt;br/&gt;
											 maxautoincrementstart) throws Exception&lt;br/&gt;
	{&lt;br/&gt;
		Statement stmt = conn.createStatement();&lt;br/&gt;
		ResultSet rs =stmt.executeQuery(&quot;select count(autoincrementstart) from sys.syscolumns c, sys.systables t, sys.sysschemas s WHERE t.schemaid =  s.schemaid and s.schemaname = &apos;APP&apos; and autoincrementstart &amp;gt; &quot; +  maxautoincrementstart);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;		rs.next();&lt;br/&gt;
		int numBadStartWith = rs.getInt(1);&lt;br/&gt;
		System.out.println(numBadStartWith + &quot; columns have bad START WITH VALUE&quot;);&lt;br/&gt;
		rs.close();&lt;/p&gt;

&lt;p&gt;		if (numBadStartWith &amp;gt; 0)&lt;br/&gt;
		{&lt;br/&gt;
			rs =stmt.executeQuery(&quot;select tablename, columnname, autoincrementstart from sys.syscolumns c, sys.systables t, sys.sysschemas s WHERE t.schemaid = s.schemaid and s.schemaname = &apos;APP&apos; and autoincrementstart &amp;gt; 2 ORDER BY tablename&quot;);&lt;br/&gt;
			while (rs.next())&lt;/p&gt;
			{
				System.out.println(&quot;Unexpected start value: &quot; +
								   rs.getLong(3) + 
								   &quot; on column &quot; + rs.getString(1) +
								   &quot;(&quot; + rs.getString(2) + &quot;)&quot;);
				
				
			}
&lt;p&gt;		}&lt;br/&gt;
       return numBadStartWith;&lt;br/&gt;
	}&lt;/p&gt;


&lt;p&gt;      /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Drop all tables in schema APP&lt;/li&gt;
	&lt;li&gt;@param conn&lt;/li&gt;
	&lt;li&gt;@throws SQLException&lt;br/&gt;
	 */&lt;br/&gt;
	private  static void dropAllAppTables(Connection conn) throws SQLException&lt;br/&gt;
	{&lt;br/&gt;
		Statement stmt1 = conn.createStatement();&lt;br/&gt;
		Statement stmt2 = conn.createStatement();&lt;br/&gt;
		System.out.println(&quot;Drop all tables in APP schema&quot;);&lt;br/&gt;
		ResultSet rs = stmt1.executeQuery(&quot;SELECT tablename from sys.systables t, sys.sysschemas s where t.schemaid = s.schemaid and s.schemaname = &apos;APP&apos;&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;		while (rs.next())&lt;br/&gt;
		{&lt;br/&gt;
			String tableName = rs.getString(1);&lt;/p&gt;

&lt;p&gt;			try &lt;/p&gt;
{
				stmt2.executeUpdate(&quot;DROP TABLE &quot; + tableName);
			}
&lt;p&gt;			catch (SQLException se)&lt;/p&gt;
			{
				System.out.println(&quot;Error dropping table:&quot; + tableName);
				se.printStackTrace();
				continue;
			}
&lt;p&gt;		}&lt;br/&gt;
	}&lt;/p&gt;


&lt;p&gt;}&lt;/p&gt;


&lt;p&gt;Relevant output:&lt;br/&gt;
$java BadStartWith&lt;br/&gt;
10.2.0.0 alpha&lt;br/&gt;
Apache Derby&lt;br/&gt;
Apache Derby Embedded JDBC Driver&lt;br/&gt;
Drop all tables in APP schema&lt;br/&gt;
Create tables until we get a wrong Start with value&lt;br/&gt;
CREATE TABLE APP.MYTABLE0  (ROLEID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY&lt;br/&gt;
 (START WITH 2, INCREMENT BY 1), INSTANCEID INTEGER, STATUS INTEGER, LOGICAL_STA&lt;br/&gt;
TE INTEGER, LSTATE_TSTAMP  TIMESTAMP, UPDT_TSTAMP TIMESTAMP, TSTAMP TIMESTAMP, C&lt;br/&gt;
LALEVEL1_CLALEVEL2_CLALEVEL2ID VARCHAR(255),  CLALEVEL1_CLALEVEL2_CLALEVEL3_CLAL&lt;br/&gt;
EVEL3ID VARCHAR(255))&lt;br/&gt;
Check before commit&lt;br/&gt;
0 columns have bad START WITH VALUE&lt;br/&gt;
Check after commit&lt;br/&gt;
0 columns have bad START WITH VALUE&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;snip MYTABLE1 ... MYTABLE124&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;CREATE TABLE APP.MYTABLE125  (ROLEID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 2, INCREMENT BY 1), INSTANCEID INTEGER, STATUS INTEGER, LOGICAL_STATE INTEGER, LSTATE_TSTAMP  TIMESTAMP,&lt;br/&gt;
UPDT_TSTAMP TIMESTAMP, TSTAMP TIMESTAMP, CLALEVEL1_CLALEVEL2_CLALEVEL2ID VARCHAR(255),  CLALEVEL1_CLALEVEL2_CLALEVEL3_CLALEVEL3ID VARCHAR(255))&lt;br/&gt;
Check before commit&lt;br/&gt;
0 columns have bad START WITH VALUE&lt;br/&gt;
Check after commit&lt;br/&gt;
0 columns have bad START WITH VALUE&lt;br/&gt;
CREATE TABLE APP.MYTABLE126  (ROLEID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 2, INCREMENT BY 1), INSTANCEID INTEGER, STATUS INTEGER, LOGICAL_STATE INTEGER, LSTATE_TSTAMP  TIMESTAMP,&lt;br/&gt;
UPDT_TSTAMP TIMESTAMP, TSTAMP TIMESTAMP, CLALEVEL1_CLALEVEL2_CLALEVEL2ID VARCHAR(255),  CLALEVEL1_CLALEVEL2_CLALEVEL3_CLALEVEL3ID VARCHAR(255))&lt;br/&gt;
Check before commit&lt;br/&gt;
127 columns have bad START WITH VALUE&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE0(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE1(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE10(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE100(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE101(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE102(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE103(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE104(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE105(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE106(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE107(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE108(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE109(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE11(ROLEID)&lt;br/&gt;
Unexpected start value: 41628850257395713 on column MYTABLE110(ROLEID)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;snip the rest of the tables have unexpected START WITH value too&amp;#93;&lt;/span&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12343095">DERBY-1327</key>
            <summary>Identity column can be  created with wrong and very large start with value with  &quot;J2RE 1.5.0 IBM Windows 32 build pwi32dev-20060412 (SR2)&quot; with JIT on</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                    </labels>
                <created>Tue, 16 May 2006 14:34:03 +0100</created>
                <updated>Sun, 30 Jul 2006 17:21:46 +0100</updated>
                            <resolved>Wed, 14 Jun 2006 04:26:11 +0100</resolved>
                                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                                    <fixVersion>10.1.3.1</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12411900" author="kmarsden" created="Tue, 16 May 2006 15:00:51 +0100"  >&lt;p&gt;I am trying to narrrow down what java calls may be  causing this issue.&lt;br/&gt;
Because it only reproduces with JIT on I can&apos;t really debug with the debugger.&lt;br/&gt;
How is it that the creation of one table could affect the autoincrementstart value of all the tables  that have already been created and committed?&lt;/p&gt;

&lt;p&gt;I am not able to post this JRE unfortunately but  am hoping someone can provide some pointers on how one create table could have such a far ranging impact on tables already created.&lt;/p&gt;

&lt;p&gt;I tried putting some println&apos;s in org.apache.derby.impl.sql.execute.ColumnInfo but never see autoincstart being greater than 2.  Other references to this value seem unlikely to cause such widespread damage to other tables.  I&apos;d appreciate any clues or thoughts on how to track this down.&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;

</comment>
                            <comment id="12412408" author="kmarsden" created="Fri, 19 May 2006 03:48:01 +0100"  >&lt;p&gt;I found  some good JIT diagnostic info  for this JVM at:&lt;br/&gt;
&lt;a href=&quot;http://download.boulder.ibm.com/ibmdl/pub/software/dw/jdk/diagnosis/diag50.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://download.boulder.ibm.com/ibmdl/pub/software/dw/jdk/diagnosis/diag50.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To get jit to kick in immediately so it fails on the first create table and get a dump of the methods compiled  I:&lt;/p&gt;

&lt;p&gt;java -Xjit:count=0,disableInlining,optLevel=noOpt,verbose,vlog=BadStartWith.vlog BadStartWith&lt;/p&gt;

&lt;p&gt;I did a binary search to find the offending entry narrowed down to line 5531&lt;br/&gt;
java -Xjit:count=0,disableInlining,optLevel=noOpt,limitFile=&amp;#40;BadStartWith.vlog,5531,5531&amp;#41; BadStartWith&lt;/p&gt;

&lt;p&gt;This is the offending compilation:&lt;/p&gt;

&lt;p&gt;+ (no-opt) org/apache/derby/impl/sql/execute/CreateTableConstantAction.executeConstantAction(Lorg/apache/derby/iapi/sql/Activation;)V @ 0x229499B0-0x2294A9FA&lt;/p&gt;

&lt;p&gt;So the workaround to exclude compilation of this method  is:&lt;/p&gt;

&lt;p&gt;java -Xjit:exclude=&lt;/p&gt;
{org/apache/derby/impl/sql/execute/CreateTableConstantAction.executeConstantAction\(Lorg/apache/derby/iapi/sql/Activation\;\)V}
&lt;p&gt; BadStartWith&lt;/p&gt;
</comment>
                            <comment id="12412448" author="kmarsden" created="Fri, 19 May 2006 07:59:58 +0100"  >&lt;p&gt;The problem seems to be in the compilation of this constructor call.&lt;br/&gt;
The parameter for autoincStart gets compiled incorrectly.&lt;br/&gt;
This is a long value and even hard coded as 0L it will have a bad value maybe an address, since the 0L value is much less than the variable.  I still have not been able to isolate completely from Derby.&lt;/p&gt;

&lt;p&gt;Constructor call  code in CreateTAbleConstantAction.executeConstantAction()&lt;/p&gt;

&lt;p&gt;columnDescriptor = new ColumnDescriptor(&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.name,&lt;br/&gt;
index++,&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.dataType,&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.defaultValue,&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.defaultInfo,&lt;br/&gt;
td,&lt;br/&gt;
defaultUUID,&lt;br/&gt;
// below  is the problem parameter.&lt;br/&gt;
// Occurs also with 0L hard coded.&lt;br/&gt;
// The value when printed is ok.&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.autoincStart,&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.autoincInc,&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.autoincInc != 0,&lt;br/&gt;
columnInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;ix&amp;#93;&lt;/span&gt;.autoinc_create_or_modify_Start_Increment&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;Constructor definition:&lt;/p&gt;

&lt;p&gt;public ColumnDescriptor(String columnName, int columnPosition,&lt;br/&gt;
DataTypeDescriptor columnType, DataValueDescriptor columnDefault,&lt;br/&gt;
DefaultInfo columnDefaultInfo,&lt;br/&gt;
TableDescriptor table,&lt;br/&gt;
UUID defaultUUID, long autoincStart,&lt;br/&gt;
long autoincInc, boolean&lt;br/&gt;
autoinc,&lt;br/&gt;
long userChangedWhat)&lt;/p&gt;

</comment>
                            <comment id="12414892" author="kmarsden" created="Tue, 6 Jun 2006 10:16:16 +0100"  >&lt;p&gt;The information that I got on this issue is that the problem is triggered when a method with a long parameter list (&amp;gt;10) is called, but before the JIT compiler has encountered the same number of temporary variables.&lt;/p&gt;

&lt;p&gt;A possible Derby Workaround would be to rework this  code so the constructor to have ten or less parameters &lt;/p&gt;
</comment>
                            <comment id="12415368" author="mamtas" created="Thu, 8 Jun 2006 23:47:18 +0100"  >&lt;p&gt;The fix for this issue would be to reduce the number of parameters required by the constructor to &amp;lt;=10 in org.apache.derby.iapi.sql.dictionary.ColumnDescriptor class. While researching into this, I found that all the 3 constructors in the class have a parameter named autoinc and it is defined as a boolean. This parameter is always equal to (parameter named autoincInc != 0). In my patch (Derby1327WrongStartKeyPatch1CodelineTrunk.txt) which is attached to this JIRA, I have removed the autoinc parameter and inside the constructors, I use (parameter named autoincInc != 0) instead of relying on autoinc. This cleans up the constructor parameter passing for all the 3 constructors and also brings down the number of parameters to &amp;lt;=10. The test program from the JIRA entry runs fine with this change and I have created a new test JitTest.java based on that test program. Hopefully this test can be a place holder for any future JIT issues. I also ran the test suites and there were no new failures.&lt;/p&gt;

&lt;p&gt;If the changes looks good, can a committer please commit it? As a cleanup, I also removed the import of org.apache.derby.iapi.sql.dictionary.ColumnDescriptor from some classes which didn&apos;t really use ColumnDescriptor.&lt;/p&gt;

&lt;p&gt;svn stat&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\FromSubquery.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\CallStatementNode.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\UpdateNode.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\FromList.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\InsertNode.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\SubqueryList.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\compile\ResultColumnList.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\WriteCursorConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\GenericResultSetFactory.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\DropSchemaConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\CreateTableConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\CreateViewConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\IndexConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\DropConstraintConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\SetConstraintsConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\InsertConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\DropViewConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\ConstraintConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\DropIndexConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\execute\AlterTableConstantAction.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\catalog\SYSCOLUMNSRowFactory.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\catalog\DataDictionaryImpl.java&lt;br/&gt;
M java\engine\org\apache\derby\impl\sql\catalog\SYSFILESRowFactory.java&lt;br/&gt;
M java\engine\org\apache\derby\iapi\sql\conn\LanguageConnectionContext.java&lt;br/&gt;
M java\engine\org\apache\derby\iapi\sql\dictionary\ColumnDescriptor.java&lt;br/&gt;
A java\testing\org\apache\derbyTesting\functionTests\tests\lang\JitTest.java&lt;br/&gt;
A java\testing\org\apache\derbyTesting\functionTests\master\JitTest.out&lt;br/&gt;
M java\testing\org\apache\derbyTesting\functionTests\suites\derbylang.runall&lt;/p&gt;</comment>
                            <comment id="12415369" author="mamtas" created="Thu, 8 Jun 2006 23:49:35 +0100"  >&lt;p&gt;BTW, the patch, Derby1327WrongStartKeyPatch1CodelineTrunk.txt is for the main codeline. If it looks good and there are no comments on it, I can submit similar patch for 10.1 codeline as well.&lt;/p&gt;</comment>
                            <comment id="12415458" author="bandaram" created="Fri, 9 Jun 2006 08:44:18 +0100"  >&lt;p&gt;I was reviewing this change and I noticed we are moving this:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/* NOTE: We use the autoincColumn variable in order to work around&lt;/li&gt;
	&lt;li&gt;* a 1.3.0 HotSpot bug.  (#4361550)&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;boolean autoincColumn = (autoincInc != 0);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Does anyone know if this &quot;HotSpot&quot; bug is still an issue and any issues caused by removing this code?&lt;/p&gt;

&lt;p&gt;Noticed this code has been there since 10.0... so likely came from before code contribution.&lt;/p&gt;
</comment>
                            <comment id="12415460" author="mamtas" created="Fri, 9 Jun 2006 08:59:36 +0100"  >&lt;p&gt;While working on this, I tried looking up the number 4361550 on Sun&apos;s website and got only one hit(&lt;a href=&quot;http://sunsolve.sun.com/search/document.do?assetkey=1-1-4361550-1&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://sunsolve.sun.com/search/document.do?assetkey=1-1-4361550-1&lt;/a&gt;), which I could not access because I don&apos;t have SunSolve technical support id.  &lt;/p&gt;

&lt;p&gt;The code that I am removing was first added in Cloudscape in August 2000 for 1.3.0 HotSpot bug which we don&apos;t support any more(I think). So, I am hoping my code change will not have any regression.&lt;/p&gt;
</comment>
                            <comment id="12415463" author="kmarsden" created="Fri, 9 Jun 2006 10:35:07 +0100"  >&lt;p&gt;Hopefully it is safe to assume that any hot spot bug from 1.3.0, August  2000 has been rectified in the currently supported  JDK 1.3.1.&lt;br/&gt;
I think running the new test  with Sun JDK 1.3.1 would  be good verification. Beyojnd that unless someone has access and wants to look this up I don&apos;t think we need to keep that code.&lt;/p&gt;

&lt;p&gt;Kind of ironic that cleaning up a workaround to fix  one JIT bug, fixed another JIT bug.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;
</comment>
                            <comment id="12415491" author="mamtas" created="Fri, 9 Jun 2006 14:11:37 +0100"  >&lt;p&gt;I ran the new test JitTest.java with Sun JDK 1.3.1 and it ran fine. I have also started derbyall run with Sun JDK 1.3.1 and so far no failures. This is all on main codeline.&lt;/p&gt;</comment>
                            <comment id="12415563" author="mamtas" created="Sat, 10 Jun 2006 00:12:19 +0100"  >&lt;p&gt;Sun JDK 1.3.1 run on derbyall finished on my codeline with no new failures. So, if there are no further comments, can a committer please commit this patch?&lt;/p&gt;</comment>
                            <comment id="12415583" author="kmarsden" created="Sat, 10 Jun 2006 01:38:49 +0100"  >&lt;p&gt;On the test JitTest.java I am concerned with the time that it takes.  It took 6 minutes.&lt;br/&gt;
 I think creating 200 tables would  be more than sufficient in this case and bring it down to 2. Ok if I make that small edit before checking in?&lt;/p&gt;
</comment>
                            <comment id="12415584" author="mamtas" created="Sat, 10 Jun 2006 01:50:18 +0100"  >&lt;p&gt;Sure, Kathey, go ahead and make that change.&lt;/p&gt;</comment>
                            <comment id="12415607" author="kmarsden" created="Sat, 10 Jun 2006 04:03:40 +0100"  >&lt;p&gt;Committed this to trunk.  I reduced some superfluous before and after commit  checking  and reduced the  test output to speed things up so JitTest runs in under 1:30. &lt;/p&gt;

&lt;p&gt;Date: Fri Jun  9 12:23:47 2006&lt;br/&gt;
New Revision: 413129&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=413129&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=413129&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12415696" author="mamtas" created="Sun, 11 Jun 2006 02:15:38 +0100"  >&lt;p&gt;I am attaching the patch for 10.1 codeline after doing a merge from main and hand fixing some of the conflicts. (The derbyall test suite ran fine with jdk13)&lt;br/&gt;
svn merge -r 413128:413129 &lt;a href=&quot;https://svn.apache.org/repos/asf/db/derby/code/trunk/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/repos/asf/db/derby/code/trunk/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One thing to note though is that in 10.1 codeline, the number of parameters to ColumnDescriptor constructors are 10 and not &amp;gt;10. So, from the bug diagnosis as mentioned in this JIRA entry, the bug should not have manifested in 10.1 codeline (the main codeline does have ColumnDscriptor constructor with &amp;gt;10 parameters). &lt;/p&gt;

&lt;p&gt;So, I am attaching the svn diff and svn stat for 10.1 codeline since it cleans up parameter passing to ColumnDescriptor but further investigation is required to see why the test program in JIRA fails on 10.1 codeline if it is supposed to fail only if the number of parameters are &amp;gt;10.&lt;/p&gt;</comment>
                            <comment id="12415703" author="kmarsden" created="Sun, 11 Jun 2006 03:17:25 +0100"  >&lt;p&gt;Thanks Mamta!&lt;/p&gt;

&lt;p&gt;I commtted this patch:&lt;br/&gt;
Date: Sat Jun 10 12:10:35 2006&lt;br/&gt;
New Revision: 413354&lt;br/&gt;
URL: &lt;a href=&quot;http://svn.apache.org/viewvc?rev=413354&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?rev=413354&amp;amp;view=rev&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I manually merged the test which did not seem to merge properly.  Please check it.&lt;/p&gt;

&lt;p&gt;I re-verified that the issue reproduced on the reported version without the patch.&lt;br/&gt;
Then I verified that it did not reproduce  with this patch, but it is indeed not clear why the issue manifested itself in 10.1 based on the JVM bug description which says you must have &amp;gt; 10 parameters.&lt;/p&gt;

&lt;p&gt;Even though the symptom is eleviated I think we should leave this issue unresolved until we have a better understanding of the JIT bug and  why it manifested itself in 10.1 in the first place and determine if this is a reliable resolution to the issue.&lt;/p&gt;

&lt;p&gt;I will  update this issue once the mystery is solved.  &lt;/p&gt;
</comment>
                            <comment id="12415801" author="kmarsden" created="Mon, 12 Jun 2006 10:21:20 +0100"  >&lt;p&gt;Taking off Patch Available as this has been committed to trunk and 10.1&lt;/p&gt;</comment>
                            <comment id="12416072" author="kmarsden" created="Wed, 14 Jun 2006 04:25:31 +0100"  >&lt;p&gt;I confirmed with the released IBM JDK Service release 2 that this issue does reproduce without Mamta&apos;s change and was fixed afterward.   I am awaiting clarification on what is the minimum number of parameters to trigger the JVM bug but since this is a compile time issue I think that Mamta&apos;s fix is enough to resolve &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1327&quot; title=&quot;Identity column can be  created with wrong and very large start with value with  &amp;quot;J2RE 1.5.0 IBM Windows 32 build pwi32dev-20060412 (SR2)&amp;quot; with JIT on&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1327&quot;&gt;&lt;del&gt;DERBY-1327&lt;/del&gt;&lt;/a&gt; in both trunk and 10.1 as I do not think there are any runtime configurations that could cause different behaviour.  Below is a summary of this issue from a user perspective.&lt;/p&gt;


&lt;p&gt;PROBLEM&lt;/p&gt;

&lt;p&gt;After creating a table, with JIT engaged, identity column start with values for any column in the database gets changed to an incorrect value.&lt;/p&gt;

&lt;p&gt;SYMPTOM&lt;/p&gt;

&lt;p&gt;The symptom is typically that an insert to the table will fail with the Exception:&lt;br/&gt;
SQLSTATE 22001: &quot;A truncation error was encountered trying to shrink ... to length 12.&quot;&lt;/p&gt;

&lt;p&gt;CAUSE&lt;br/&gt;
A JIT issue in IBM JDK 1.5 Service Release 2 can cause corruption of the start with value.  The affected version is:&lt;br/&gt;
java version &quot;1.5.0&quot;&lt;br/&gt;
Java(TM) 2 Runtime Environment, Standard Edition (build pwi32dev-20060511 (SR2))&lt;br/&gt;
IBM J9 VM (build 2.3, J2RE 1.5.0 IBM J9 2.3 Windows XP x86-32 j9vmwi3223-20060504 (JIT enabled)&lt;br/&gt;
J9VM - 20060501_06428_lHdSMR&lt;br/&gt;
JIT  - 20060428_1800_r8&lt;br/&gt;
GC   - 20060501_AA)&lt;br/&gt;
JCL  - 20060511a&lt;/p&gt;

&lt;p&gt;SOLUTION:&lt;/p&gt;

&lt;p&gt;A fix to resolve the Derby symptom is available in 10.1 builds after 10.1.2.5.413354 and will be included in the Derby 10.1.3.0 release.  &lt;/p&gt;

&lt;p&gt;Once corruption has occurred there is no way in 10.1 to correct the START WITH value.   The only way to recover date is to recreate the database and use export/import to transfer the data.&lt;/p&gt;

&lt;p&gt;WORKAROUND:&lt;br/&gt;
If  users wish to wait  for the 10.1.3.0 official release,  The following JIT options can be specified for the JVM to prevent corruption in identity columns but this does allow recovery after the problem has occured.&lt;/p&gt;

&lt;p&gt;-Xjit:exclude=&lt;/p&gt;
{org/apache/derby/impl/sql/execute/CreateTableCon
stantAction.executeConstantAction\(Lorg/apache/derby/iapi/sql/Ac
tivation\;\)V}

</comment>
                            <comment id="12418739" author="kmarsden" created="Sat, 1 Jul 2006 08:29:28 +0100"  >&lt;p&gt;Verified fix&lt;/p&gt;</comment>
                            <comment id="12421888" author="kmarsden" created="Tue, 18 Jul 2006 16:35:44 +0100"  >&lt;p&gt;The core JVM  issue can be tracked with  IBM APAR APAR number  IY86935. &lt;/p&gt;</comment>
                            <comment id="12424398" author="kmarsden" created="Sun, 30 Jul 2006 17:21:46 +0100"  >&lt;p&gt;APAR link for tracking:&lt;br/&gt;
&lt;a href=&quot;http://www-1.ibm.com/support/docview.wss?uid=swg1IY86935&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www-1.ibm.com/support/docview.wss?uid=swg1IY86935&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12335221" name="Derby1327WrongStartKeyPatch1CodelineTrunk.txt" size="495024" author="mamtas" created="Thu, 8 Jun 2006 23:47:18 +0100"/>
                            <attachment id="12335302" name="Derby1327WrongStartKeyPatch1SvnDiff101.txt" size="485854" author="mamtas" created="Sun, 11 Jun 2006 02:15:38 +0100"/>
                            <attachment id="12335303" name="Derby1327WrongStartKeyPatch1SvnStat101.txt" size="2203" author="mamtas" created="Sun, 11 Jun 2006 02:15:38 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 8 Jun 2006 22:47:18 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22440</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy151z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40469</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>