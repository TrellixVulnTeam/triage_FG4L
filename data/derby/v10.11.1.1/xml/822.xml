<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:21:25 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-822/DERBY-822.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-822] Client driver: Pre-fetch data on executeQuery()</title>
                <link>https://issues.apache.org/jira/browse/DERBY-822</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Currently, the client driver does not pre-fetch data when&lt;br/&gt;
executeQuery() is called, but it does on the first call to&lt;br/&gt;
ResultSet.next(). Pre-fetching data on executeQuery() would reduce&lt;br/&gt;
network traffic and improve performance.&lt;/p&gt;

&lt;p&gt;The DRDA protocol supports this. From the description of OPNQRY (open&lt;br/&gt;
query):&lt;/p&gt;

&lt;p&gt;  The qryrowset parameter specifies whether a rowset of rows is to be&lt;br/&gt;
  returned with the command.  This is only honored for non-dynamic&lt;br/&gt;
  scrollable cursors (QRYATTSNS not equal to QRYSNSDYN) and for&lt;br/&gt;
  non-scrollable cursors conforming to the limited block query&lt;br/&gt;
  protocol.  The target server fetches no more than the requested&lt;br/&gt;
  number of rows. It may fetch fewer rows if it is restricted by extra&lt;br/&gt;
  query block limits, or if a fetch operation results in a negative&lt;br/&gt;
  SQLSTATE or an SQLSTATE of 02000.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12327784">DERBY-822</key>
            <summary>Client driver: Pre-fetch data on executeQuery()</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Wed, 18 Jan 2006 19:52:40 +0000</created>
                <updated>Tue, 30 Jun 2009 17:12:53 +0100</updated>
                            <resolved>Tue, 18 Apr 2006 14:55:26 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>Network Server</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                            <comments>
                            <comment id="12365915" author="knutanders" created="Sat, 11 Feb 2006 01:24:26 +0000"  >&lt;p&gt;Brief status update...&lt;/p&gt;

&lt;p&gt;This seems easier than I first thought. In theory, at least... When&lt;br/&gt;
the server receives an OPNQRY (Open Query) it is supposed to respond&lt;br/&gt;
with an OPNQRYRM (Open Query Reply Message), QRYDSC (Query Answer Set&lt;br/&gt;
Description), and optionally (and with some restrictions) QRYDTA&lt;br/&gt;
(Query Answer Set Data).&lt;/p&gt;

&lt;p&gt;Right now, the server doesn&apos;t return QRYDTA in the response to OPNQRY,&lt;br/&gt;
but I found this comment in DRDAConnThread.processCommands():&lt;/p&gt;

&lt;p&gt;    writeQRYDSC(stmt, false);&lt;br/&gt;
    // We could send QRYDTA here if there&apos;s no LOB data&lt;br/&gt;
    // in the result set, and if we are using LMTBLKPRC, as&lt;br/&gt;
    // allowed by drda spec, as an option.&lt;/p&gt;

&lt;p&gt;I am not convinced that the comment about LMTBLKPRC is correct, I&lt;br/&gt;
think it is also allowed for FIXROWPRC. Will look more into that.&lt;/p&gt;

&lt;p&gt;Anyway, I have enabled sending of QRYDTA for LMTBLKPRC and that seems&lt;br/&gt;
to work for some simple tests I have run. A lot of failures in&lt;br/&gt;
derbynetmats and derbynetclientmats, though. Many of the failures are&lt;br/&gt;
caused by changes in the output from SYSCS_GET_RUNTIMESTATISTICS()&lt;br/&gt;
(pretty huge diffs). Will have to look more at the failures to see&lt;br/&gt;
which ones are real failures.&lt;/p&gt;

&lt;p&gt;So far, I haven&apos;t had to make any changes on the client side.&lt;/p&gt;</comment>
                            <comment id="12366794" author="knutanders" created="Fri, 17 Feb 2006 22:58:51 +0000"  >&lt;p&gt;I have attached a patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-822&quot; title=&quot;Client driver: Pre-fetch data on executeQuery()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-822&quot;&gt;&lt;del&gt;DERBY-822&lt;/del&gt;&lt;/a&gt;-v1.diff) which implements&lt;br/&gt;
prefetching on executeQuery(). Derbyall (including JCC tests) passed&lt;br/&gt;
on Solaris 10 x86/Sun JVM 1.4.2 (a couple of failures, but they are&lt;br/&gt;
also seen in Ole&apos;s nightly regression tests).&lt;/p&gt;

&lt;p&gt;I hope the size of the patch doesn&apos;t scare off potential&lt;br/&gt;
reviewers. The actual code changes are very small. 95% of the patch is&lt;br/&gt;
just updating the master files for the Wisconsin test.&lt;/p&gt;

&lt;p&gt;Below is a description of the changes.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Knut Anders&lt;/p&gt;



&lt;p&gt;MOTIVATION&lt;/p&gt;

&lt;p&gt;Derby (in client/server mode) needs more round trips to the server&lt;br/&gt;
than other databases to execute select operations. While other&lt;br/&gt;
database drivers prefetch data when calling&lt;br/&gt;
PreparedStatement.executeQuery(), Derby does not fetch data until&lt;br/&gt;
ResultSet.next() is called. If data is sent in the reply to&lt;br/&gt;
PreparedStatement.executeQuery(), one round trip is saved per select&lt;br/&gt;
operation and the performance will increase.&lt;/p&gt;

&lt;p&gt;PROPOSED SOLUTION&lt;/p&gt;

&lt;p&gt;The DRDA protocol lists some command sequences that require query data&lt;br/&gt;
(QRYDTA) to be returned together with the reply to an open query&lt;br/&gt;
(OPNQRY) command. None of these command sequences are currently in use&lt;br/&gt;
by the Derby client driver or JCC, and the network server does not&lt;br/&gt;
support them.&lt;/p&gt;

&lt;p&gt;Additionally, the DRDA protocol specifies command sequences for which&lt;br/&gt;
the server can choose whether it includes QRYDTA in the reply or&lt;br/&gt;
not. These sequences are used by the client driver, but the network&lt;br/&gt;
server chooses not to send QRYDTA.&lt;/p&gt;

&lt;p&gt;What I propose, is that we change the network server&apos;s behaviour in&lt;br/&gt;
the optional case, so that it includes QRYDTA when it replies to an&lt;br/&gt;
OPNQRY command. I do not propose to implement support for the required&lt;br/&gt;
case, since the clients do not currently send those commands to the&lt;br/&gt;
server.&lt;/p&gt;

&lt;p&gt;IMPLEMENTATION&lt;/p&gt;

&lt;p&gt;The client driver (and JCC) already supports OPNQRYRM messages with&lt;br/&gt;
QRYDTA attached, so only the network server needed to be modified.&lt;/p&gt;

&lt;p&gt;In the section of DRDAConnThread.processCommands() that processed&lt;br/&gt;
OPNQRY commands, this comment was found:&lt;/p&gt;

&lt;p&gt;  // We could send QRYDTA here if there&apos;s no LOB data&lt;br/&gt;
  // in the result set, and if we are using LMTBLKPRC, as&lt;br/&gt;
  // allowed by drda spec, as an option.&lt;/p&gt;

&lt;p&gt;At that spot I inserted code for writing QRYDTA similar to what&lt;br/&gt;
processCommands() does for CNTQRY:&lt;/p&gt;

&lt;p&gt;  if (stmt.getQryprctyp() == CodePoint.LMTBLKPRC) {&lt;br/&gt;
      // The DRDA spec allows us to send&lt;br/&gt;
      // QRYDTA here if there are no LOB&lt;br/&gt;
      // columns.&lt;br/&gt;
      DRDAResultSet drdars =&lt;br/&gt;
          stmt.getCurrentDrdaResultSet();&lt;br/&gt;
      try {&lt;br/&gt;
          if (drdars != null &amp;amp;&amp;amp;&lt;br/&gt;
              !drdars.hasLobColumns()) &lt;/p&gt;
{
              writeQRYDTA(stmt, true);
          }
&lt;p&gt;      } catch (SQLException sqle) &lt;/p&gt;
{
          cleanUpAndCloseStatement(stmt, sqle,
                                   writerMark);
      }
&lt;p&gt;  }&lt;/p&gt;

&lt;p&gt;All other changes to the code were just minor adjustments to make&lt;br/&gt;
writeQRYDTA() and writeFDODTA() work with OPNQRY (they contained some&lt;br/&gt;
code which assumed that they were responding to a CNTQRY).&lt;/p&gt;

&lt;p&gt;REGRESSION TESTING&lt;/p&gt;

&lt;p&gt;No explicit regression tests were added, since the amount of&lt;br/&gt;
regression test failures caused by this change was so huge that a&lt;br/&gt;
regression back to the old behaviour will not likely go unnoticed. For&lt;br/&gt;
instance, the protocol test (derbynet/testProtocol.java) had to be&lt;br/&gt;
changed to expect QRYDTA when it sends OPNQRY to the server, and it&lt;br/&gt;
will fail if the network server changes are reverted.&lt;/p&gt;

&lt;p&gt;Below is a list of changes that had to be made to the regression&lt;br/&gt;
tests:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;jdbcapi/parameterMetaDataJdbc30.java *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This test tried to compile an expression containing &quot;WHERE x LIKE ?&lt;br/&gt;
ESCAPE ?&quot;, set the escape sequence to an empty string and execute the&lt;br/&gt;
query, but it did not call ResultSet.next() to fetch data. An empty&lt;br/&gt;
string is not a valid escape sequence, so when prefetching was enabled&lt;br/&gt;
the test failed. Failure was fixed by calling ResultSet.next() to&lt;br/&gt;
ensure that the invalid escape sequence would be caught in all&lt;br/&gt;
frameworks, and a message will be printed if we do not get the&lt;br/&gt;
expected exception.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;jdbcapi/setTransactionIsolation.java *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Some test cases where a statement was executed without calling&lt;br/&gt;
ResultSet.next() failed because the statement execution plan text&lt;br/&gt;
differed. The difference was related to the prefetching which would&lt;br/&gt;
cause a larger number of rows and pages seen. The execution plan did&lt;br/&gt;
not change.&lt;/p&gt;

&lt;p&gt;Additionally, some two test cases failed because of a lock&lt;br/&gt;
timeout. This was expected and caused by the prefetching. (You do not&lt;br/&gt;
get a lock timeout until you actually try to fetch the data.)&lt;/p&gt;

&lt;p&gt;Fixed by updating master files for DerbyNet and DerbyNetClient.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;jdbcapi/resultset.java *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This test failed because some column headers were not printed. The&lt;br/&gt;
failure was caused by the prefetching. Exceptions that were expected&lt;br/&gt;
when calling ResultSet.next() were thrown when calling&lt;br/&gt;
Statement.executeQuery() instead, leading to slightly different&lt;br/&gt;
output. Updated master files for DerbyNet and DerbyNetClient.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;derbynet/testProtocol.java *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Test failed because it just expected OPNQRYRM and QRYDSC in response&lt;br/&gt;
to OPNQRY with LMTBLKPRC and no LOBs. Had to add QRYDTA to the&lt;br/&gt;
expected response in values1.inc.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;lang/scrollCursors1.sql *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;One statement execution plan text changed because of prefetching (more&lt;br/&gt;
rows seen). Updated master files for DerbyNet and DerbyNetClient.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;lang/supersimple.sql *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In queries that were expected to fail, column headers were not printed&lt;br/&gt;
because prefetching caused the query to fail earlier. Updated master&lt;br/&gt;
files for DerbyNet and DerbyNetClient.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;lang/wisconsin.java *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Many statement execution plan texts had changed. The plans still were&lt;br/&gt;
the same, but the number of rows/pages seen increased since&lt;br/&gt;
prefetching caused data to be fetched even though the test closed the&lt;br/&gt;
cursors without reading data. Updated master files for DerbyNet and&lt;br/&gt;
DerbyNetClient.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;lang/forupdate.sql *&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Two occurrences of this error message:&lt;/p&gt;

&lt;p&gt;  ERROR 42X23: Cursor SQL_CURLH000C1 is not updatable.&lt;/p&gt;

&lt;p&gt;were replaced with this message:&lt;/p&gt;

&lt;p&gt;  ERROR 42X30: Cursor &apos;SQL_CURLH000C1&apos; not found. Verify that&lt;br/&gt;
  autocommit is OFF.&lt;/p&gt;

&lt;p&gt;The failure was caused by prefetching causing all data from the&lt;br/&gt;
forward-only/read-only cursor to be fetched, combined with implicit&lt;br/&gt;
closing of the cursor on the server side. The failure is expected.&lt;/p&gt;

&lt;p&gt;Fixed by updating master file for DerbyNetClient.&lt;/p&gt;</comment>
                            <comment id="12367192" author="knutanders" created="Tue, 21 Feb 2006 22:42:34 +0000"  >&lt;p&gt;Created a sub-task (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1014&quot; title=&quot;Make tests less sensitive to pre-fetching&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1014&quot;&gt;&lt;del&gt;DERBY-1014&lt;/del&gt;&lt;/a&gt;) to make most of the test changes independent of the code changes in my previously attached patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-822&quot; title=&quot;Client driver: Pre-fetch data on executeQuery()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-822&quot;&gt;&lt;del&gt;DERBY-822&lt;/del&gt;&lt;/a&gt;-v1.diff). Will attach a new (and smaller) patch to this issue later.&lt;/p&gt;</comment>
                            <comment id="12373359" author="knutanders" created="Wed, 5 Apr 2006 22:56:50 +0100"  >&lt;p&gt;Uploading a new patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-822&quot; title=&quot;Client driver: Pre-fetch data on executeQuery()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-822&quot;&gt;&lt;del&gt;DERBY-822&lt;/del&gt;&lt;/a&gt;-v2.diff) with most of the canon diffs&lt;br/&gt;
removed. For the network server code, the patch is identical to the v1&lt;br/&gt;
patch. See the description of that patch for details. The client (both&lt;br/&gt;
Derby and JCC) handles the new behaviour without code changes.&lt;/p&gt;

&lt;p&gt;The test changes made by this patch are:&lt;/p&gt;

&lt;p&gt;lang/supersimple.sql: Some queries which are expected to fail, don&apos;t&lt;br/&gt;
print column names in DerbyNet and DerbyNetClient (because the failure&lt;br/&gt;
is exposed earlier and the result set metadata isn&apos;t sent). Removed&lt;br/&gt;
column names from the canons.&lt;/p&gt;

&lt;p&gt;lang/forupdate.sql: Some queries which failed with &quot;Cursor not&lt;br/&gt;
updatable&quot; now fail with &quot;Cursor not found&quot;. This is actually caused&lt;br/&gt;
by this patch in combination with the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-821&quot; title=&quot;Client driver: Implicitly close exhausted result sets on the server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-821&quot;&gt;&lt;del&gt;DERBY-821&lt;/del&gt;&lt;/a&gt;. The&lt;br/&gt;
forward-only, read-only cursor is closed on the server because all&lt;br/&gt;
rows are read, and there&apos;s no way to move backwards. The error message&lt;br/&gt;
could probably have been more accurate, but it&apos;s not incorrect, and I&lt;br/&gt;
believe most users will use ResultSet.deleteRow(), not &quot;delete from t&lt;br/&gt;
where current of ...&quot;. (ResultSet.&lt;/p&gt;
{delete,insert,update}
&lt;p&gt;Row does say&lt;br/&gt;
the concurrency of the result set is read-only.) Updated canons with&lt;br/&gt;
the changed error messages.&lt;/p&gt;

&lt;p&gt;derbynet/testProtocol.java: In the file &apos;values1.inc&apos;, which is used&lt;br/&gt;
frequently by the protocol test, the OPNQRYRM is expected to be&lt;br/&gt;
followed by a QRYDSC only. With this patch, it is followed by a QRYDSC&lt;br/&gt;
and a QRYDTA. Added this to the file, and also changed the test so&lt;br/&gt;
that it checked that the codepoints were correct (the original test&lt;br/&gt;
just did skipDss a number of times).&lt;/p&gt;</comment>
                            <comment id="12373790" author="bryanpendleton" created="Mon, 10 Apr 2006 03:52:35 +0100"  >&lt;p&gt;Hi Knut Anders.&lt;/p&gt;

&lt;p&gt;This diff is a lot easier to read now that &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1014&quot; title=&quot;Make tests less sensitive to pre-fetching&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1014&quot;&gt;&lt;del&gt;DERBY-1014&lt;/del&gt;&lt;/a&gt; has been separated out. Very nice!&lt;/p&gt;

&lt;p&gt;I read through the changes and had a couple questions I wanted to ask:&lt;/p&gt;

&lt;p&gt;1) I don&apos;t really understand why we have to pass the &quot;opnqry&quot; argument down to writeQRYDTA and writeFDODTA. I read your comments and they make sense at a &quot;detail&quot; level, but I think I&apos;m missing the bigger picture. It seems to me like writeQRYDTA and writeFDODTA should not have to care whether they were called in response to a CNTQRY or in response to a OPNQRY, and when I stare at the detailed changes to writeFDODTA I&apos;m puzzled:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;when called during processing of an OPNQRY, why would it be wrong to call positionCursor()&lt;/li&gt;
	&lt;li&gt;when called during processing of an OPNQRY, doesn&apos;t stmt.getQryrtndta() return false?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think what I&apos;m trying to suggest is that it seems like it would be cleaner to make positionCursor() and stmt.getQryrtndta() &quot;do the right thing&quot; when called during OPNQRY, rather than passing the flag through, since that seems like it would make the code overall more robust and clear. (That is, the &quot;if&quot; statements in writeFDODTA are already too complex for my taste, so I&apos;m hoping not to add any more conditions to them).&lt;/p&gt;

&lt;p&gt;2) I don&apos;t understand what&apos;s going on with the change to DRDAStatement.java. It seems like there are various configuration settings (qryrowset, blksize, maxblkext, etc.) which are being tracked both in the statement and in the result set, and you&apos;re changing things so that when these options are passed in an OPNQRY call, they will now affect not only the particular result set for that query, but also the overall statement?&lt;/p&gt;

&lt;p&gt;I think I&apos;m just puzzled by this change. It doesn&apos;t seem to be directly related to the other work you&apos;re doing, except that it involves OPNQRY processing, and I&apos;m concerned that I don&apos;t really understand the implications of setting these various variables on the statement object as opposed to on the result set object.&lt;/p&gt;

&lt;p&gt;Can you expand upon the reasoning behind the DRDAStatement change, and also help me understand why we have these variables in both the statement and the result set?&lt;/p&gt;</comment>
                            <comment id="12373927" author="knutanders" created="Tue, 11 Apr 2006 05:45:10 +0100"  >&lt;p&gt;Thank you for looking at the patch, Bryan! Your comments are valuable,&lt;br/&gt;
as always. I have tried to answer your questions below.&lt;/p&gt;

&lt;p&gt;&amp;gt; Bryan Pendleton commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-822&quot; title=&quot;Client driver: Pre-fetch data on executeQuery()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-822&quot;&gt;&lt;del&gt;DERBY-822&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; ---------------------------------------&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) I don&apos;t really understand why we have to pass the &quot;opnqry&quot;&lt;br/&gt;
&amp;gt; argument down to writeQRYDTA and writeFDODTA. I read your comments&lt;br/&gt;
&amp;gt; and they make sense at a &quot;detail&quot; level, but I think I&apos;m missing the&lt;br/&gt;
&amp;gt; bigger picture. It seems to me like writeQRYDTA and writeFDODTA&lt;br/&gt;
&amp;gt; should not have to care whether they were called in response to a&lt;br/&gt;
&amp;gt; CNTQRY or in response to a OPNQRY, and when I stare at the detailed&lt;br/&gt;
&amp;gt; changes to writeFDODTA I&apos;m puzzled:&lt;br/&gt;
&amp;gt;   - when called during processing of an OPNQRY, why would it be&lt;br/&gt;
&amp;gt;     wrong to call positionCursor()&lt;/p&gt;

&lt;p&gt;positionCursor() uses the value of QRYSCRORN, which is not part of the&lt;br/&gt;
OPNQRY command. After an OPNQRY, DRDAResultSet.qryscrorn is&lt;br/&gt;
unintialized (zero), and it is not accepted by positionCursor().&lt;/p&gt;

&lt;p&gt;&amp;gt;   - when called during processing of an OPNQRY, doesn&apos;t&lt;br/&gt;
&amp;gt;     stmt.getQryrtndta() return false?&lt;/p&gt;

&lt;p&gt;Yes, it does. And that is the problem. I realize now that my comment&lt;br/&gt;
wasn&apos;t quite clear. The comment said:&lt;/p&gt;

&lt;p&gt;  	If we were asked not to return data (QRYRTNDTA) ...&lt;/p&gt;

&lt;p&gt;It should have said:&lt;/p&gt;

&lt;p&gt;    If we were asked not to return data (QRYRTNDTA false) ...&lt;/p&gt;

&lt;p&gt;The original code has this assignment:&lt;/p&gt;

&lt;p&gt;    boolean noRetrieveRS = (rs != null &amp;amp;&amp;amp; !stmt.getQryrtndta());&lt;/p&gt;

&lt;p&gt;Since qryrtndta is false when processing OPNQRY, noRetrieveRS is true,&lt;br/&gt;
and no results are returned. Therefore, the test for OPNQRY was needed&lt;br/&gt;
to make it work.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think what I&apos;m trying to suggest is that it seems like it would be&lt;br/&gt;
&amp;gt; cleaner to make positionCursor() and stmt.getQryrtndta() &quot;do the&lt;br/&gt;
&amp;gt; right thing&quot; when called during OPNQRY, rather than passing the flag&lt;br/&gt;
&amp;gt; through, since that seems like it would make the code overall more&lt;br/&gt;
&amp;gt; robust and clear.&lt;/p&gt;

&lt;p&gt;I agree. I think the best way is to set the values of&lt;br/&gt;
DRDAResultSet.qryrtndta and DRDAResultSet.qryscrorn to something&lt;br/&gt;
meaningful on OPNQRY. That should be safe, since the values are&lt;br/&gt;
overwritten when a CNTQRY is received.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) I don&apos;t understand what&apos;s going on with the change to&lt;br/&gt;
&amp;gt; DRDAStatement.java. It seems like there are various configuration&lt;br/&gt;
&amp;gt; settings (qryrowset, blksize, maxblkext, etc.) which are being&lt;br/&gt;
&amp;gt; tracked both in the statement and in the result set, and you&apos;re&lt;br/&gt;
&amp;gt; changing things so that when these options are passed in an OPNQRY&lt;br/&gt;
&amp;gt; call, they will now affect not only the particular result set for&lt;br/&gt;
&amp;gt; that query, but also the overall statement?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I think I&apos;m just puzzled by this change. It doesn&apos;t seem to be&lt;br/&gt;
&amp;gt; directly related to the other work you&apos;re doing, except that it&lt;br/&gt;
&amp;gt; involves OPNQRY processing, and I&apos;m concerned that I don&apos;t really&lt;br/&gt;
&amp;gt; understand the implications of setting these various variables on&lt;br/&gt;
&amp;gt; the statement object as opposed to on the result set object.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Can you expand upon the reasoning behind the DRDAStatement change,&lt;br/&gt;
&amp;gt; and also help me understand why we have these variables in both the&lt;br/&gt;
&amp;gt; statement and the result set?&lt;/p&gt;

&lt;p&gt;Right, I didn&apos;t explain that change very well...&lt;/p&gt;

&lt;p&gt;First, I&apos;ll explain why these changes were needed:&lt;/p&gt;

&lt;p&gt;The current implementation does not set default block size (and some&lt;br/&gt;
other options) for the DRDAStatement on an OPNQRY command. Actually,&lt;br/&gt;
the only command that sets these options is EXCSQLSTT. For the old&lt;br/&gt;
behaviour with no pre-fetching, this is okay since the block size for&lt;br/&gt;
the result set is set on each CNTQRY command. However, it is not okay&lt;br/&gt;
with pre-fetching. What happens is&lt;/p&gt;

&lt;p&gt;  1) DRDAConnThread.processCommands() calls parseOPNQRY(), which sets&lt;br/&gt;
     the block size of the current DRDAResultSet to ~32K.&lt;/p&gt;

&lt;p&gt;  2) DRDAConnThread.processCommands() calls DRDAStatement.execute(),&lt;br/&gt;
     which (indirectly) calls setRsDefaultOptions(). Since the default&lt;br/&gt;
     block size of the DRDAStatement is not set, the block size of the&lt;br/&gt;
     current DRDAResultSet will be reset to zero.&lt;/p&gt;

&lt;p&gt;  3) When DRDAConnThread.processCommands() tries to pre-fetch rows it&lt;br/&gt;
     only fetches one row, since it thinks that the block is full.&lt;/p&gt;

&lt;p&gt;If we set the default block size for the statement on OPNQRY, the&lt;br/&gt;
result set won&apos;t get its block size reset when the statement is&lt;br/&gt;
executed, and we can fill the entire block with pre-fetched rows.&lt;/p&gt;

&lt;p&gt;Only the block size was necessary to get the pre-fetching working, but&lt;br/&gt;
I felt it was cleaner to update all the default values rather than&lt;br/&gt;
just one. (Actually, I see that I forgot one variable. Will fix that&lt;br/&gt;
one.)&lt;/p&gt;

&lt;p&gt;Now, here&apos;s why I think this change is correct:&lt;/p&gt;

&lt;p&gt;  a) There is never more than one open result set per statement, so&lt;br/&gt;
     changing the defaults for the statement does not affect any other&lt;br/&gt;
     open result set.&lt;/p&gt;

&lt;p&gt;  b) The default values are only used in setRsDefaultOptions(). All&lt;br/&gt;
     code paths that end up calling setRsDefaultOptions() go through&lt;br/&gt;
     DRDAStatement.execute(). DRDAStatement.execute() is only invoked&lt;br/&gt;
     from within parseEXCSQLSTT() and after parseOPNQRY(). Since&lt;br/&gt;
     parseEXCSQLSTT() already updates the defaults, it won&apos;t see any&lt;br/&gt;
     changes made by OPNQRY.&lt;/p&gt;

&lt;p&gt;You also asked why the variables were needed in both DRDAStatement and&lt;br/&gt;
DRDAResultSet. I don&apos;t see any good reason for having two copies of&lt;br/&gt;
these variables. I think the code would be cleaner if we got rid of&lt;br/&gt;
the ones in DRDAStatement. But that&apos;s another patch... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12374818" author="knutanders" created="Tue, 18 Apr 2006 05:51:33 +0100"  >&lt;p&gt;Uploading new patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-822&quot; title=&quot;Client driver: Pre-fetch data on executeQuery()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-822&quot;&gt;&lt;del&gt;DERBY-822&lt;/del&gt;&lt;/a&gt;-v3.diff) addressing Bryan&apos;s comments. Changes from the previous patch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;renamed clean-up method for Beetle 4758 from cleanUpAndCloseStatement to cleanUpAndCloseResultSet&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assigned default values to QRYRTNDTA, QRYSCRREL and QRYROWNBR on OPNQRY, so that writeQRYDTA() and writeFDODTA() can be used without changes before CNTQRY has been called&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Derbyall ran cleanly on Sun JVM 1.5, Solaris 10 x86.&lt;/p&gt;</comment>
                            <comment id="12374837" author="bryanpendleton" created="Tue, 18 Apr 2006 10:57:26 +0100"  >&lt;p&gt;Thank you for investigating my feedback. This has become a very elegant change, and I have no further suggestions to make. Great work!&lt;/p&gt;</comment>
                            <comment id="12374857" author="knutanders" created="Tue, 18 Apr 2006 14:55:26 +0100"  >&lt;p&gt;Thanks again for your feedback, Bryan!&lt;/p&gt;

&lt;p&gt;Committed revision 394859.&lt;/p&gt;</comment>
                            <comment id="12376757" author="kmarsden" created="Fri, 28 Apr 2006 00:37:44 +0100"  >&lt;p&gt;I noticed that on the day of this checkin, lang/simpleScroll.sql, and  lang/scrollCursors1.sql  with JCC 2.5 (56) started failing with a protocol error.&lt;/p&gt;

&lt;p&gt;The test is ok  with JCC 2.4(17), JCC 2.5 (36) and  JCC 2.6 (90) are all ok.   I am  not sure yet if this is some sort of regression with our DRDA handling or a bug with this particular verison of JCC. I will post more info as I have it.  Here is the diff for scrollCursors1&lt;/p&gt;


&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;Start: scrollCursors1 jdk1.5.0_02 DerbyNet derbynetmats:jdbc20 2006-04-18 23:37:03 ***&lt;br/&gt;
392a393&lt;br/&gt;
&amp;gt; ERROR 58017: The DDM parameter value is not supported.  DDM parameter code point having unsupported value : 0x2102&lt;br/&gt;
394 del&lt;br/&gt;
 I          &lt;br/&gt;
395 del&lt;br/&gt;
&amp;lt; -----&lt;br/&gt;
396 del&lt;br/&gt;
&amp;lt; 2          &lt;br/&gt;
396a395&lt;br/&gt;
&amp;gt; IJ ERROR: Unable to establish cursor&lt;br/&gt;
398 del&lt;br/&gt;
&amp;lt; I          &lt;br/&gt;
399 del&lt;br/&gt;
&amp;lt; -----&lt;br/&gt;
400 del&lt;br/&gt;
&amp;lt; 3          &lt;br/&gt;
400a397&lt;br/&gt;
&amp;gt; IJ ERROR: Unable to establish cursor&lt;br/&gt;
402 del&lt;br/&gt;
&amp;lt; 1 row inserted/updated/deleted&lt;br/&gt;
402a399&lt;br/&gt;
&amp;gt; ERROR (no SQLState): invalid operation: connection closed&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12418123" author="kmarsden" created="Wed, 28 Jun 2006 04:57:22 +0100"  >&lt;p&gt;I think we probably need to check the &quot;Existing application Impact&quot; box on this issue and provide a release note because I think this is one of those cases where we intentionally introduced the following behaviour changes:&lt;/p&gt;

&lt;p&gt;      1)  Queries may fail earlier.  Instead of failing on the  ResultSet next() call, they may now fail on execute()/executeQuery(). Applications need to be prepared to handle this.&lt;br/&gt;
         2)   Prefetching may  impact locking behavior.  Locks may be acquired earlier or may be acquired where they never were before, promoted to table locks etc.&lt;br/&gt;
         3) This introduces a new difference I think between embedded and network behavior &lt;/p&gt;

&lt;p&gt;Does this sound right?  If so I can take a stab and a release note.  Is there a workaround if prefetching causes users any trouble on upgrade?&lt;/p&gt;

</comment>
                            <comment id="12418258" author="knutanders" created="Wed, 28 Jun 2006 23:02:15 +0100"  >&lt;p&gt;Kathey Marsden wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt;  1) Queries may fail earlier. Instead of failing on the ResultSet&lt;br/&gt;
&amp;gt;     next() call, they may now fail on execute()/executeQuery().&lt;br/&gt;
&amp;gt;     Applications need to be prepared to handle this.&lt;/p&gt;

&lt;p&gt;This is correct. However, applications should already be prepared to&lt;br/&gt;
handle errors on execute()/executeQuery(), so I hope this shouldn&apos;t&lt;br/&gt;
cause too much trouble.&lt;/p&gt;

&lt;p&gt;&amp;gt;  2) Prefetching may impact locking behavior. Locks may be acquired&lt;br/&gt;
&amp;gt;     earlier or may be acquired where they never were before,&lt;br/&gt;
&amp;gt;     promoted to table locks etc.&lt;/p&gt;

&lt;p&gt;This is partly correct.&lt;/p&gt;

&lt;p&gt;Locks for the first chunk of pre-fetched rows are aquired on&lt;br/&gt;
execute/executeQuery instead of on the first call to next().&lt;/p&gt;

&lt;p&gt;The locks &quot;may be acquired where they never were before&quot;, but that is&lt;br/&gt;
only the case when there is no call to next() after the&lt;br/&gt;
execute. Although a lot of our tests do this (in order to test that&lt;br/&gt;
the statement compiles or to print the query execution plan), I fail&lt;br/&gt;
to see why an application would execute a SELECT statement but not&lt;br/&gt;
read any of the data.&lt;/p&gt;

&lt;p&gt;I do not believe locks will be promoted to table locks because of the&lt;br/&gt;
pre-fetching. The number of rows pre-fetched when invoking&lt;br/&gt;
executeQuery() is exactly the same as the number of rows that would be&lt;br/&gt;
pre-fetched on the first call to next() with an old server.&lt;/p&gt;

&lt;p&gt;&amp;gt;  3) This introduces a new difference I think between embedded and&lt;br/&gt;
&amp;gt;     network behavior&lt;/p&gt;

&lt;p&gt;Correct.&lt;/p&gt;

&lt;p&gt;&amp;gt; Does this sound right? If so I can take a stab and a release&lt;br/&gt;
&amp;gt; note.&lt;/p&gt;

&lt;p&gt;Thanks, that would be great!&lt;/p&gt;

&lt;p&gt;&amp;gt; Is there a workaround if prefetching causes users any trouble&lt;br/&gt;
&amp;gt; on upgrade?&lt;/p&gt;

&lt;p&gt;The best work-around is: Do not execute SELECT statements just for&lt;br/&gt;
fun! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Seriously, if a select statement is executed, but the results&lt;br/&gt;
are never read, it should probably not have been executed in the first&lt;br/&gt;
place. Also, it might help to move the executeQuery() closer to the&lt;br/&gt;
first call to next() (that is, don&apos;t do too much work between&lt;br/&gt;
executeQuery() and next()).&lt;/p&gt;

&lt;p&gt;There is no simple way to disable the pre-fetching. The only ways I&lt;br/&gt;
know of are using an updateable result set or including a LOB column&lt;br/&gt;
in the query.&lt;/p&gt;</comment>
                            <comment id="12418486" author="kmarsden" created="Thu, 29 Jun 2006 23:53:56 +0100"  >&lt;p&gt;RELEASE NOTE:&lt;/p&gt;

&lt;p&gt;Pre-fetching  with Network Client/Server  is a performance optimization that eliminates a round trip to the server.  Essentially the first ResultSet next()  call is executed on the Statement executeQuery() or execute().   Applications are typically  prepared to handle this but the following issue may be seen,&lt;/p&gt;

&lt;p&gt;PROBLEM&lt;/p&gt;

&lt;p&gt;Queries may fail earlier and locks may be aquired earlier when executing queries.   Location where errors occur  embedded environment is different.&lt;/p&gt;

&lt;p&gt;SYMPTOM&lt;/p&gt;

&lt;p&gt;Errors that happen as part of the normal execution path are moved earlier.   For example,  code to execute a query, with executeQuery() retrieve the result set metadata and then perform a next() might fail with a lock timeout on executeQuery() instead of next().  Locking changes are observed.&lt;/p&gt;

&lt;p&gt;CAUSE&lt;/p&gt;

&lt;p&gt;Pre-fetching moves execution of retrieval of data earlier for network client/server configurations.&lt;/p&gt;

&lt;p&gt;SOLUTION&lt;/p&gt;

&lt;p&gt;This was an intentional behavior change to improve performance.  No Derby product solution is offered.&lt;/p&gt;

&lt;p&gt;WORKAROUND&lt;/p&gt;

&lt;p&gt;Application code needs to be changed to adjust error handling if needed.&lt;/p&gt;







</comment>
                    </comments>
                    <attachments>
                            <attachment id="12323109" name="DERBY-822-v1.diff" size="832696" author="knutanders" created="Fri, 17 Feb 2006 22:58:51 +0000"/>
                            <attachment id="12323110" name="DERBY-822-v1.stat" size="1422" author="knutanders" created="Fri, 17 Feb 2006 22:58:51 +0000"/>
                            <attachment id="12324985" name="DERBY-822-v2.diff" size="12661" author="knutanders" created="Wed, 5 Apr 2006 22:56:37 +0100"/>
                            <attachment id="12324986" name="DERBY-822-v2.stat" size="555" author="knutanders" created="Wed, 5 Apr 2006 22:56:45 +0100"/>
                            <attachment id="12325456" name="DERBY-822-v3.diff" size="9809" author="knutanders" created="Tue, 18 Apr 2006 05:51:33 +0100"/>
                            <attachment id="12325457" name="DERBY-822-v3.stat" size="555" author="knutanders" created="Tue, 18 Apr 2006 05:51:33 +0100"/>
                    </attachments>
                <subtasks>
                            <subtask id="12329257">DERBY-1014</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 10 Apr 2006 02:52:35 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29722</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ue7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38742</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>