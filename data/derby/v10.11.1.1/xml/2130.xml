<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:42:07 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2130/DERBY-2130.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2130] Optimizer performance slowdown from 10.1 to 10.2</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2130</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Attached is &apos;repro.sql&apos;, an IJ script which demonstrates what I&lt;br/&gt;
believe to be a serious performance issue in the Optimizer.&lt;/p&gt;

&lt;p&gt;I have run this script in a number of configurations:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;10.1.2.1: the script runs successfully. The &apos;prepare&apos; statement&lt;br/&gt;
   takes about 90 seconds, on a fairly powerful Windows machine&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;10.1.3.1: the script produces a NPE. I believe this is &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;10.2.1.8/trunk: the script runs successfully. The &apos;prepare&apos; statement&lt;br/&gt;
   often takes about 220 seconds, on the same Windows machine&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   Intermittently, on 10.2 and on the trunk, the prepare statement takes&lt;br/&gt;
   15+ minutes. I cannot reliably reproduce this; I run the same script&lt;br/&gt;
   several times in a row and I cannot predict whether it will take 220&lt;br/&gt;
   seconds or whether it will take 15+ minutes.&lt;/p&gt;

&lt;p&gt;I am quite motivated to work on this problem, as this is blocking me from&lt;br/&gt;
using Derby for a project that I&apos;m quite keen on, but I need some&lt;br/&gt;
suggestions and ideas about how to attack it. From my perspective&lt;br/&gt;
there are 3 primary topics:&lt;/p&gt;

&lt;p&gt;1) Why did optimizer performance for this query degrade so significantly&lt;br/&gt;
from 10.1.2.1 to 10.2? The optimizer seems to be at least 2.5 times slower,&lt;br/&gt;
for this particular query at least, in 10.2. Sometimes it is 10x slower.&lt;/p&gt;

&lt;p&gt;2) What is the source of the non-determinism? Why does the optimizer&lt;br/&gt;
often take 4 minutes to optimize this query on the trunk, but sometimes&lt;br/&gt;
take 15+ minutes? I don&apos;t believe that I&apos;m changing anything from&lt;br/&gt;
run to run.&lt;/p&gt;

&lt;p&gt;3) Can we improve the optimizer performance even beyond what it was&lt;br/&gt;
for 10.1.2? I realize that this is an ugly query, but I was hoping to&lt;br/&gt;
see an optimization time of 5-10 seconds, not 90 seconds (and certainly&lt;br/&gt;
not 220 seconds).&lt;/p&gt;

&lt;p&gt;I have attempted to start answering some of these questions, with&lt;br/&gt;
limited success. Here is some of what I think I&apos;ve discovered so far:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the optimizer changes in 10.2 seem to have given the optimizer many&lt;br/&gt;
   more choices of possible query plans to consider. I think this means&lt;br/&gt;
   that, if the optimizer does not time out, it will spend substantially&lt;br/&gt;
   more time optimizing because there are more choices to evaluate. Does&lt;br/&gt;
   this by itself mean that the optimizer will take 2.5 times longer in&lt;br/&gt;
   10.2 than it did in 10.1?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;something about this query seems to make the costing mechanism go&lt;br/&gt;
   haywire, and produce extreme costs. While stepping through the&lt;br/&gt;
   optimization of this query in the debugger I have seen it compute&lt;br/&gt;
   costs like 1e63 and 1e200. This might be very closely related to&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt;, although I don&apos;t think I&apos;m doing any subqueries here.&lt;br/&gt;
   But maybe I&apos;m misunderstanding the term &quot;subquery&quot; in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt;.&lt;br/&gt;
   At any rate, due to the enormous estimated costs, timeout does not&lt;br/&gt;
   occur.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the WHERE clause in this query is converted during compilation to&lt;br/&gt;
   an equivalent IN clause, I believe, which then causes me to run into&lt;br/&gt;
   a number of the problems described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-713&quot; title=&quot;CLONE - Query optimizer should not make poor choices when optimizing IN and WHERE clauses&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-713&quot;&gt;&lt;del&gt;DERBY-713&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
   Specifically, rather than constructing a plan which involves 4&lt;br/&gt;
   index probes for the 4 WHERE clause values, the optimizer decides&lt;br/&gt;
   that an index scan must be performed and that it will have to process&lt;br/&gt;
   the entire index (because the query uses parameter markers, not&lt;br/&gt;
   literal values). So perhaps solving &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt; would help me&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the optimizer in fact comes up with a &quot;decent&quot; query plan quite quickly.&lt;br/&gt;
   I have experimented with placing a hard limit into the optimizer&lt;br/&gt;
   timeout code, so that I can force optimization to stop after an&lt;br/&gt;
   arbitrary fixed period of time. Then I have been able to set that&lt;br/&gt;
   value to as low as 1 second, and the optimizer has produced plans&lt;br/&gt;
   that then execute in a few milliseconds. Of course, I have only tried&lt;br/&gt;
   this with a trivial amount of data in my database, so it&apos;s possible&lt;br/&gt;
   that the plan produced by the optimizer after just a second of&lt;br/&gt;
   optimizing is in fact poor, and I&apos;m just not noticing it because my&lt;br/&gt;
   data sizes are so small.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;At this point, what would be really helpful to me would be some suggestions&lt;br/&gt;
about some general approaches or techniques to try to start breaking down&lt;br/&gt;
and analyzing this problem.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12357299">DERBY-2130</key>
            <summary>Optimizer performance slowdown from 10.1 to 10.2</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mikem">Mike Matrigali</assignee>
                                    <reporter username="bryanpendleton">Bryan Pendleton</reporter>
                        <labels>
                            <label>derby_triage10_11</label>
                    </labels>
                <created>Wed, 29 Nov 2006 22:55:05 +0000</created>
                <updated>Wed, 21 Jan 2015 00:22:54 +0000</updated>
                            <resolved>Wed, 26 Feb 2014 23:44:46 +0000</resolved>
                                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                    <version>10.3.1.4</version>
                                    <fixVersion>10.10.2.0</fixVersion>
                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12454477" author="bryanpendleton" created="Wed, 29 Nov 2006 22:56:44 +0000"  >&lt;p&gt;reproduction script is &apos;repro.sql&apos;.&lt;/p&gt;</comment>
                            <comment id="12454479" author="bryanpendleton" created="Wed, 29 Nov 2006 22:57:57 +0000"  >&lt;p&gt;One experiment I tried was to remove all the secondary &lt;br/&gt;
indexes. I thought that that might shrink the overall &quot;search &lt;br/&gt;
space&quot; that the optimizer was dealing with. However, it&lt;br/&gt;
actually seemed to make matters worse, not better.&lt;/p&gt;</comment>
                            <comment id="12454738" author="mikem" created="Thu, 30 Nov 2006 19:33:58 +0000"  >&lt;p&gt;What continues to puzzle me about these issues is that the &lt;br/&gt;
estimated costs are so out of control.  Without a major&lt;br/&gt;
rewrite of the optimizer, the basic assumption is that the&lt;br/&gt;
estimated costs are somewhat close to the actual elapsed&lt;br/&gt;
time of the query.  Timeout depends on this, and thus&lt;br/&gt;
optimizer &quot;performance&quot; depends on this as we tend to&lt;br/&gt;
loop through ever increasing number of plans as each&lt;br/&gt;
variable is added.&lt;/p&gt;

&lt;p&gt;I think the key is to get the optimizer to time out correctly.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1907&quot; title=&quot;Improve optimizer to prune query plans more aggressively.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1907&quot;&gt;DERBY-1907&lt;/a&gt; would be nice but the whole system is just broken&lt;br/&gt;
if estimates are so wrong.&lt;/p&gt;

&lt;p&gt;Army posted some &quot;simple&quot; problem cases, that is where I&lt;br/&gt;
would start.  It seems like all of the following may apply&lt;br/&gt;
to your case, probably good to validate there is not something&lt;br/&gt;
new going on with your query.:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1908&quot; title=&quot;Investigate: What&amp;#39;s the &amp;quot;unit&amp;quot; for optimizer cost estimates?&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1908&quot;&gt;&lt;del&gt;DERBY-1908&lt;/del&gt;&lt;/a&gt;  	 Investigate: What&apos;s the &quot;unit&quot; for optimizer cost estimates?   	 &lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1907&quot; title=&quot;Improve optimizer to prune query plans more aggressively.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1907&quot;&gt;DERBY-1907&lt;/a&gt; 	Improve optimizer to prune query plans more aggressively. 	&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1906&quot; title=&quot;Investigate appropriateness of current optimizer timeout mechanism.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1906&quot;&gt;DERBY-1906&lt;/a&gt; 	Investigate appropriateness of current optimizer timeout mechanism. 	&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt; 	Optimizer cost estimates for subqueries are way (way) too high. 	&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;	IN list optimization&lt;/p&gt;

&lt;p&gt;One approach that would keep the current basic optimizer technology would be to see if we can fix the estimates.  Some items might be:&lt;/p&gt;

&lt;p&gt;1) update the store costs to reflect current machines&lt;br/&gt;
o update the store costs to reflect &quot;actual&quot; machine it is running on&lt;br/&gt;
o figure out why there is such variance in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2130&quot; title=&quot;Optimizer performance slowdown from 10.1 to 10.2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2130&quot;&gt;&lt;del&gt;DERBY-2130&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
o investigate why optimizer costs are so out of line - is it just&lt;br/&gt;
  wrong logic, is it lack of some sort of cost estimate so one bad&lt;br/&gt;
  guess on top of another.&lt;br/&gt;
o &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I am interested in doing 1, but I don&apos;t think it is going to help&lt;br/&gt;
with infinite costs.&lt;/p&gt;

&lt;p&gt;Is anyone else interested in looking at this?  The repro for&lt;br/&gt;
2130 is pretty ugly, I wonder if we could agree on a smaller problem&lt;br/&gt;
to work on that hopefully would help the harder problem.&lt;/p&gt;</comment>
                            <comment id="12454741" author="mikem" created="Thu, 30 Nov 2006 19:39:57 +0000"  >&lt;p&gt;The variance in optimizer times is puzzling as I thought the order of plans picked was pretty much the same.  I think&lt;br/&gt;
2 things would help in understanding this:&lt;br/&gt;
1) Have a trace flag that tells us if the prepare ended because of timeout or because of plan exhaustion.&lt;br/&gt;
2) Can you reproduce the variance if you only do the prepare on the same db, without redoing the ddl.  I think I &lt;br/&gt;
     remember some issue with&lt;br/&gt;
     the order that tables are looked at being related to hash codes which might vary from ddl to ddl.&lt;br/&gt;
      Is this an issue only if entire optmizer is timing out, or are there any &quot;sub-timeouts&quot; where we might short circuit&lt;br/&gt;
     a list of subquery options?&lt;/p&gt;</comment>
                            <comment id="12454745" author="army" created="Thu, 30 Nov 2006 20:11:54 +0000"  >&lt;p&gt;&amp;gt; Some items might be:&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) update the store costs to reflect current machines&lt;br/&gt;
&amp;gt; o update the store costs to reflect &quot;actual&quot; machine it is running on&lt;br/&gt;
&amp;gt; o figure out why there is such variance in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2130&quot; title=&quot;Optimizer performance slowdown from 10.1 to 10.2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2130&quot;&gt;&lt;del&gt;DERBY-2130&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
&amp;gt; o investigate why optimizer costs are so out of line - is it just&lt;br/&gt;
&amp;gt;  wrong logic, is it lack of some sort of cost estimate so one bad&lt;br/&gt;
&amp;gt;  guess on top of another.&lt;br/&gt;
&amp;gt; o &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; I am interested in doing 1, but I don&apos;t think it is going to help&lt;br/&gt;
&amp;gt; with infinite costs.&lt;/p&gt;

&lt;p&gt;&amp;gt; Is anyone else interested in looking at this?&lt;/p&gt;

&lt;p&gt;I am interested both in this particular issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2130&quot; title=&quot;Optimizer performance slowdown from 10.1 to 10.2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2130&quot;&gt;&lt;del&gt;DERBY-2130&lt;/del&gt;&lt;/a&gt;) and also in #3: why the optimizer cost estimates are so out of line.  I.e. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt;.  I haven&apos;t started just yet but I would like to look more into &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt; to see if I can pull anything up.  I hope to start looking at this very soon...&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth, I ran the repro attached to this issue with various sets of Derby insane jars, and the timings I saw were as follows.  I ran the repro 3 times for each set of jars on Red Hat Linux using ibm142.  Unit of measurement is milliseconds (returned via the &quot;elapsedtime on&quot; ij command).&lt;/p&gt;

&lt;p&gt;10.1 Pre-805:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;141570&lt;/li&gt;
	&lt;li&gt;142463&lt;/li&gt;
	&lt;li&gt;140686&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;10.2 Pre-805:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;143794&lt;/li&gt;
	&lt;li&gt;139213&lt;/li&gt;
	&lt;li&gt;138892&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;10.1 latest branch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;43494&lt;/li&gt;
	&lt;li&gt;37229&lt;/li&gt;
	&lt;li&gt;37532&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;10.2 Post-805, Pre-781 (10.2.0.4, svn 423199)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;NPE (caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;10.2 latest branch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;470067&lt;/li&gt;
	&lt;li&gt;438084&lt;/li&gt;
	&lt;li&gt;433038&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Things to notice:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;It looks like the slow-down is &lt;b&gt;not&lt;/b&gt; caused by the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes--at least not directly.  On the contrary, the query actually runs quite a bit more quickly with the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes (and all subsequent patches, esp. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;) than it does without.  Or put another way, the query runs faster with the latest 10.1 codeline than it does with 10.1.2.1.  Of course, it&apos;s possible that changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; are mingling with more recent changes to cause the slowdown, but we at least know that the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes alone are not the problem.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The run at revision 423199 fails with an NPE, which corresponds to Bryan&apos;s results when he ran with 10.1.3.1.  In both cases the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes have been committed but the subsequent regression fixes (including &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;) have not, hence the NPE.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I did not see the non-deterministic behavior that Bryan did with 10.2 trunk--instead, I consistently see 7+ minutes.  However, I only ran the query 3 times, which is probably not enough to have seen what Bryan saw.  Also note that I only ran the DDL one time and then I re-ran the query the second two times.  So given Mike&apos;s previous comment, this may be the reason I didn&apos;t see the variance that Bryan did.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Note sure how useful this information is, but that&apos;s what I&apos;ve found so far.  Still scratching my head and poking around, though, so maybe something will come up. (My inclination is toward &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-781&quot; title=&quot;Materialize subqueries in select list where possible to avoid creating invariant resultsets many times.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-781&quot;&gt;&lt;del&gt;DERBY-781&lt;/del&gt;&lt;/a&gt;, but I don&apos;t really know how just yet...)&lt;/p&gt;</comment>
                            <comment id="12454963" author="army" created="Fri, 1 Dec 2006 17:41:01 +0000"  >&lt;p&gt;Just a random though that occured to me...&lt;/p&gt;

&lt;p&gt;The query in question is written as:&lt;/p&gt;

&lt;p&gt;prepare p1 as &apos;&lt;br/&gt;
select count(distinct t1.c5) &lt;br/&gt;
    from table19 t1 &lt;br/&gt;
        inner join table05 t3 on ( t1.c5 = t3.c2)  &lt;br/&gt;
        inner join table06 t4 on ( t3.c33 = t4.c1)  &lt;br/&gt;
        inner join v3 t5 on ( t4.c34 = t5.c1)  &lt;br/&gt;
        inner join table20 t2 on ( t5.c3 = t2.c5)  &lt;br/&gt;
        inner join v1 t6 on ( t2.c35 = t6.c1)  &lt;br/&gt;
        inner join v2 t7 on ( t6.c3 = t7.c5)  &lt;br/&gt;
        inner join v1 t8 on ( t7.c22 = t8.c1)  &lt;br/&gt;
    where (((t8.c3 = ? or t8.c3 = ? or t8.c3 = ? or t8.c3 = ?)))&apos;;&lt;/p&gt;

&lt;p&gt;Is the use of the explicit &quot;inner join&quot; syntax an intentional decision?  Or more specifically, is the intention that the tables are to be joined in a specific order?  From the Optimizer standpoint this query  becomes one large outer query with 8 Optimizables in the from list, so the Optimizer will attempt to evaluate all combinations of the 8 Optimizables before quitting--which takes a (long) while.  If, however, the query was written with a specific join order in mind, you could use Derby optimizer overrides to fix the join order of the 8 Optimizables to be the join order in which they are specified:&lt;/p&gt;

&lt;p&gt;prepare p1 as &apos;&lt;br/&gt;
select count(distinct t1.c5) &lt;br/&gt;
    from  --DERBY-PROPERTIES joinOrder=FIXED&lt;br/&gt;
            table19 t1 &lt;br/&gt;
            inner join table05 t3 on ( t1.c5 = t3.c2)  &lt;br/&gt;
            inner join table06 t4 on ( t3.c33 = t4.c1)  &lt;br/&gt;
            inner join v3 t5 on ( t4.c34 = t5.c1)  &lt;br/&gt;
            inner join table20 t2 on ( t5.c3 = t2.c5)  &lt;br/&gt;
            inner join v1 t6 on ( t2.c35 = t6.c1)  &lt;br/&gt;
            inner join v2 t7 on ( t6.c3 = t7.c5)  &lt;br/&gt;
            inner join v1 t8 on ( t7.c22 = t8.c1)  &lt;br/&gt;
    where (((t8.c3 = ? or t8.c3 = ? or t8.c3 = ? or t8.c3 = ?)))&apos;;&lt;/p&gt;

&lt;p&gt;When I did this the &quot;prepare&apos; finished in about 3 seconds on the same Red Hat Linux machine with the latest trunk branch (sane build).&lt;/p&gt;

&lt;p&gt;Of course, I still think this issue is one that needs to be resolved.  But if a) you&apos;re looking for a temprorary workaround and b) you know the order in which you would like the tables to be joined, maybe the optimizer override can help in the short term.&lt;/p&gt;

&lt;p&gt;Please note, though, that Derby optimization as a whole would benefit a &lt;b&gt;lot&lt;/b&gt; more if you continued to help resolve this problem &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12455117" author="bryanpendleton" created="Sat, 2 Dec 2006 18:25:04 +0000"  >&lt;p&gt;Army, thank you for the hint about the optimizer overrides. I will investigate this&lt;br/&gt;
as a possible workaround for the short term.&lt;/p&gt;</comment>
                            <comment id="12455118" author="bryanpendleton" created="Sat, 2 Dec 2006 18:27:12 +0000"  >&lt;p&gt;Just speaking abstractly here for a minute, I want to make sure I&apos;m following the discussion.&lt;/p&gt;

&lt;p&gt;As I understand it, the Optimizer&apos;s overall top-level algorithm is:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Consider every possible query plan for executing this query (modulo permutation &quot;jumping&quot;)&lt;/li&gt;
	&lt;li&gt;Evaluate the cost of each such plan.&lt;/li&gt;
	&lt;li&gt;Select the cheapest.&lt;/li&gt;
	&lt;li&gt;If at any time we determine that we&apos;ve now spent longer evaluating plans&lt;br/&gt;
     than it would have taken to execute the cheapest plan seen so far, then&lt;br/&gt;
     quit and go run that plan (this is known as OptimizerTimeout)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Is that an accurate summary? If so, it seems that:&lt;/p&gt;

&lt;p&gt;1) The most important thing about the Optimizer&apos;s cost estimation algorithm&lt;br/&gt;
is that it be &quot;relatively accurate&quot;: the cheapest actual plan should&lt;br/&gt;
have the lowest estimated cost. &lt;/p&gt;

&lt;p&gt;2) The second most important thing is that the algorithm should strive to&lt;br/&gt;
be accurate, so that the optimizer timeout works effectively.&lt;/p&gt;

&lt;p&gt;3) Another important thing is that the algorithm should be as rapid as&lt;br/&gt;
possible, so that the optimizer can evaluate as many plans as possible&lt;br/&gt;
prior to timing out.&lt;/p&gt;

&lt;p&gt;It seems that most of the discussion so far has been around item (2), regarding&lt;br/&gt;
the accuracy and interpretation (units of measurement) of the cost estimate.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1906&quot; title=&quot;Investigate appropriateness of current optimizer timeout mechanism.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1906&quot;&gt;DERBY-1906&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1908&quot; title=&quot;Investigate: What&amp;#39;s the &amp;quot;unit&amp;quot; for optimizer cost estimates?&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1908&quot;&gt;&lt;del&gt;DERBY-1908&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1259&quot; title=&quot;Optimizer plan consideration doesn&amp;#39;t account for infinite cost estimates and can therefore choose plans requiring excessive memory.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1259&quot;&gt;DERBY-1259&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1260&quot; title=&quot;Investigate impact of infinite cost estimates on arithmetic operations/comparisons in the optimizer.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1260&quot;&gt;DERBY-1260&lt;/a&gt; all&lt;br/&gt;
have to do with this topic.&lt;/p&gt;

&lt;p&gt;I&apos;ve seen almost no discussion of the first point (that the cheapest actual plan&lt;br/&gt;
should have the cheapest estimated cost); does this mean that we are pretty&lt;br/&gt;
confident about this aspect of cost estimation at this point? That is, the cost&lt;br/&gt;
estimating may be off, but it seems to be off for all queries equally?&lt;/p&gt;

&lt;p&gt;And I haven&apos;t seen much discussion of the third point (that the Optimizer should&lt;br/&gt;
strive to evaluate plans as rapidly as possible, so as to increase its chances of&lt;br/&gt;
coming across a decent plan prior to timeout). &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1907&quot; title=&quot;Improve optimizer to prune query plans more aggressively.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1907&quot;&gt;DERBY-1907&lt;/a&gt; is certainly relevant&lt;br/&gt;
here; are there other issues logged like this?&lt;/p&gt;

&lt;p&gt;I guess I&apos;m wondering (out loud) whether it is worth investigating a simple tuning&lt;br/&gt;
of the cost estimation algorithm. If the optimizer was &lt;b&gt;much&lt;/b&gt; faster at&lt;br/&gt;
generating and estimating possible plans, wouldn&apos;t that be a big benefit?&lt;/p&gt;

&lt;p&gt;Also, how confident are we that permutation jumping (as described in &lt;br/&gt;
&lt;a href=&quot;http://wiki.apache.org/db-derby/JoinOrderPermutations&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/JoinOrderPermutations&lt;/a&gt;) is working properly?&lt;/p&gt;</comment>
                            <comment id="12455141" author="army" created="Sun, 3 Dec 2006 00:16:41 +0000"  >&lt;p&gt;Everything written in Bryan&apos;s preceding comment sounds correct to me, so I won&apos;t dwell.  As for the specific questions:&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;ve seen almost no discussion of the first point (that the cheapest actual plan&lt;br/&gt;
&amp;gt; should have the cheapest estimated cost); does this mean that we are pretty&lt;br/&gt;
&amp;gt; confident about this aspect of cost estimation at this point? That is, the cost&lt;br/&gt;
&amp;gt; estimating may be off, but it seems to be off for all queries equally?&lt;/p&gt;

&lt;p&gt;This has been my general assumption about the code, yes-&lt;del&gt;at least, after &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; was resolved.  It seems to me that at some point in the last year I found a scenario where the optimizer&apos;s &quot;best&quot; cost estimate did not (appear to) correspond to the best query plan, but I don&apos;t remember the details and it may have ended up being correct after all.  In any event, in all of the discussion that I&apos;ve had/written, my general assumption has been that &quot;Yes&quot;, the &lt;b&gt;relative&lt;/b&gt; accuracy of the cost estimates is correct&lt;/del&gt;-i.e. that better plans have lower cost estimates.  Note, though, that this is just an assumption of mine which I have not bothered trying to debunk; if you find info to the contrary, please say so!&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1907&quot; title=&quot;Improve optimizer to prune query plans more aggressively.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1907&quot;&gt;DERBY-1907&lt;/a&gt; is certainly relevant here; are there other issues logged like this?&lt;/p&gt;

&lt;p&gt;None come to mind, no.  But I admit that&apos;s an answer based strictly on memory; I didn&apos;t actually do any searching...&lt;/p&gt;

&lt;p&gt;&amp;gt; I guess I&apos;m wondering (out loud) whether it is worth investigating a simple tuning &lt;br/&gt;
&amp;gt; of the cost estimation algorithm. If the optimizer was &lt;b&gt;much&lt;/b&gt; faster at generating&lt;br/&gt;
&amp;gt; and estimating possible plans, wouldn&apos;t that be a big benefit? &lt;/p&gt;

&lt;p&gt;Yes, definitely!&lt;/p&gt;

&lt;p&gt;&amp;gt; Also, how confident are we that permutation jumping (as described in&lt;br/&gt;
&amp;gt; &lt;a href=&quot;http://wiki.apache.org/db-derby/JoinOrderPermutations&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/JoinOrderPermutations&lt;/a&gt;) is working properly? &lt;/p&gt;

&lt;p&gt;I had to laugh out loud when I read this question.  It sounds to me like the kind of question someone asks when they&apos;ve found a somewhat serious bug but don&apos;t want to rock the boat &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;So far as I know, the jumping code is working properly.  But if you told me there was a problem with the code, I think I&apos;d assume you were right.  Is that the case?&lt;/p&gt;</comment>
                            <comment id="12455197" author="bryanpendleton" created="Sun, 3 Dec 2006 19:44:04 +0000"  >&lt;p&gt;&amp;gt; So far as I know, the jumping code is working properly.&lt;/p&gt;

&lt;p&gt;Thanks, that&apos;s good to know. It actually was an innocent question; I&apos;m&lt;br/&gt;
not holding anything up my sleeve &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; My train of thought was something like:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;7+ minutes of CPU time is a &lt;b&gt;lot&lt;/b&gt; on today&apos;s machines&lt;/li&gt;
	&lt;li&gt;therefore, we&apos;re either evaluating an astounding number of query plans,&lt;/li&gt;
	&lt;li&gt;or, we&apos;re burning a lot of CPU evaluating the plans,&lt;/li&gt;
	&lt;li&gt;or both&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12455713" author="bryanpendleton" created="Tue, 5 Dec 2006 18:09:16 +0000"  >&lt;p&gt;Attached are the query plans that I get when running with 10.1.2.1 and 10.2&lt;/p&gt;

&lt;p&gt;I also attached &apos;plans.diff&apos;, which is a diff of the plans after editing the plans to remove &quot;noisy&quot; differences such as the floating point values of the estimated costs.&lt;/p&gt;

&lt;p&gt;The plans are very similar, but not identical.&lt;/p&gt;

&lt;p&gt;It seems that 10.2 is, in several cases, preferring indexed access to tables, which I think shows that the predicate pushdown changes (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; and friends) are working.&lt;/p&gt;

&lt;p&gt;Other than that, my extremely coarse reading of the plans is that the primary difference between the two plans is the estimated costs.&lt;/p&gt;</comment>
                            <comment id="12455802" author="army" created="Tue, 5 Dec 2006 23:46:15 +0000"  >&lt;p&gt;Thanks for the query plans, Bryan.  I took a quick look and nothing stood out, but I&apos;ll have to look more closely before I can say anything for sure.  Thank you for taking the time to pull out the &quot;noise&quot;--I think that&apos;ll be helpful.&lt;/p&gt;

&lt;p&gt;On a different note, I added some System.outs to various places in the Optimizer to see what cost estimates the optimizer is calculating for different complete join orders in the top-level OptimizerImpl.  I then ran the repro query against the latest 10.1 branch and the latest 10.3 trunk.  The abbreviated output from what I saw is shown below.&lt;/p&gt;

&lt;p&gt;Some things to note:&lt;/p&gt;

&lt;p&gt;  0. Lots of &quot;Infinity&quot; and &quot;NaN&quot; cost estimates, which are probably the result of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1260&quot; title=&quot;Investigate impact of infinite cost estimates on arithmetic operations/comparisons in the optimizer.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1260&quot;&gt;DERBY-1260&lt;/a&gt;, respectively. This pretty much renders all but a handful of the cost estimates useless.&lt;/p&gt;

&lt;p&gt;  1. In 10.1.3 we try to jump to a target join order and we SUCCESSFULLY do so.  In 10.3 we also try to jump to the same target join order, BUT for some reason the jump does NOT take effect.  So it looks like Bryan&apos;s question about whether or not permutation jumping works correctly was indeed well-founded.  This is, I think, the first thing to investigate.&lt;/p&gt;

&lt;p&gt;  2. Because the 10.3 &quot;jump&quot; does not occur we spend a lot of time iterating through different permutations until we get to the &quot;best join order&quot; found by 10.1. Once we get there the estimated cost for 10.3 (on a 10.1 database) is finite but is much higher than the cost estimate of the same join order in 10.1 (namely, &quot;247&quot; in 10.1 vs &quot;1736685&quot; in 10.3).  So this is another point of interest.  This could again be the result of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1260&quot; title=&quot;Investigate impact of infinite cost estimates on arithmetic operations/comparisons in the optimizer.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1260&quot;&gt;DERBY-1260&lt;/a&gt;, but it&apos;s hard to say at this point.&lt;/p&gt;

&lt;p&gt;  3. This next observation is weird: when running 10.3 on a 10.1 database the query finishes after about 10,000 iterations (roughly 5 minutes on my laptop).  But when running 10.3 on a &lt;b&gt;10.3&lt;/b&gt; database the query runs until it has exhausted all possible permutations (over 40,000).  The difference is in the calculated cost estimate for the &quot;2 0 1 3 4 5 6 7&quot; join order.  When running against a 10.1 database 10.3 estimates a cost of 1736685, followed up by a cost of 198589 for the next complete order, which leads leads to eventual timeout.  But when running against a 10.3 database, the cost estimate is &lt;b&gt;Infinity&lt;/b&gt; and thus the timeout value sits at 5E62, which we never reach.  I have absolutely no idea why this would be the case.  Any one out there have any theories?   Bryan, can you perhaps try this out to see if you observe the same behavior?  You can connect to a 10.1 database by setting the &quot;derby.database.allowPreReleaseUpgrade&quot; property to &quot;true&quot;.  Note that you should only use that on a &lt;em&gt;test&lt;/em&gt; 10.1 database, though; I don&apos;t think it&apos;s intended for production db&apos;s.&lt;/p&gt;

&lt;p&gt;Generally speaking lines in the output are of the form:&lt;/p&gt;

&lt;p&gt;-=&amp;gt; estimatedCost: j o i n O r d e r&lt;/p&gt;

&lt;p&gt;--------------------------&lt;br/&gt;
10.1.3 on 10.1.3 database:&lt;br/&gt;
--------------------------&lt;/p&gt;

&lt;p&gt;ij version 10.1&lt;br/&gt;
-=&amp;gt; 5.607246651648704E62: 0 1 2 3 4 5 6 7&lt;br/&gt;
-==&amp;gt; Just set bestCost to: 5.607246651648704E62&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt;&amp;gt; JUMPING to: 1 4 2 6 7 0 3 5&lt;br/&gt;
-=&amp;gt; Infinity: 1 4 2 6 7 0 3 5&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 6 7 0 5 3&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 6 7 3 0 5&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 6 7 3 5 0&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 6 7 5 0 3&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 6 7 5 3 0&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 7 0 3 5 6&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 7 0 3 6 5&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 7 0 5 3 6&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 7 0 5 6 3&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 7 0 6 3 5&lt;br/&gt;
-=&amp;gt; NaN: 1 4 2 7 0 6 5 3&lt;/p&gt;

&lt;p&gt;&amp;lt;snip ~2,600 permutations with cost estimates of &quot;NaN&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;-=&amp;gt; NaN: 1 7 6 5 4 0 2 3&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 0 3 2&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 2 0 3&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 2 3 0&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 3 0 2&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 3 2 0&lt;br/&gt;
-=&amp;gt; 247.4647753453739: 2 0 1 3 4 5 6 7&lt;br/&gt;
-==&amp;gt; Just set bestCost to: 247.4647753453739&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt;&amp;gt; TIMED OUT: exceeded 247.4647753453739 ms.&lt;br/&gt;
-=&amp;gt; 247.4647753453739: 2 0 1 3 4 5 6 7&lt;br/&gt;
ELAPSED TIME = 82961 milliseconds&lt;/p&gt;

&lt;p&gt;------------------------&lt;br/&gt;
10.3 on &lt;b&gt;10.1.3&lt;/b&gt; database:&lt;br/&gt;
------------------------&lt;/p&gt;

&lt;p&gt;(on the &lt;b&gt;same&lt;/b&gt; database that was created by 10.1)&lt;/p&gt;

&lt;p&gt;ij version 10.3&lt;br/&gt;
-=&amp;gt; 5.607246651648704E62: 0 1 2 3 4 5 6 7&lt;br/&gt;
-==&amp;gt; Just set bestCost to: 5.607246651648704E62&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt;&amp;gt; JUMPING to: 1 4 2 6 7 0 3 5&lt;br/&gt;
-=&amp;gt; 1.8253980349686949E106: 0 1 2 3 4 5 6 7&lt;br/&gt;
-=&amp;gt; 3.021440681134236E107: 0 1 2 3 4 5 7 6&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 4 6 5 7&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 4 6 7 5&lt;br/&gt;
-=&amp;gt; 5.993308284393933E109: 0 1 2 3 4 7 5 6&lt;br/&gt;
-=&amp;gt; 2.736734332816085E108: 0 1 2 3 4 7 6 5&lt;br/&gt;
-=&amp;gt; 3.973494182787193E115: 0 1 2 3 5 4 6 7&lt;br/&gt;
-=&amp;gt; 6.577018684224087E116: 0 1 2 3 5 4 7 6&lt;br/&gt;
-=&amp;gt; 3.973494182787193E115: 0 1 2 3 5 6 4 7&lt;br/&gt;
-=&amp;gt; 6.577018684224087E116: 0 1 2 3 5 7 4 6&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 6 4 5 7&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 6 4 7 5&lt;br/&gt;
-=&amp;gt; 1.0852895218002162E119: 0 1 2 3 6 5 4 7&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 6 7 4 5&lt;br/&gt;
-=&amp;gt; 5.993308284393933E109: 0 1 2 3 7 4 5 6&lt;br/&gt;
-=&amp;gt; 2.736734332816085E108: 0 1 2 3 7 4 6 5&lt;br/&gt;
-=&amp;gt; 1.2945545894290903E112: 0 1 2 3 7 5 4 6&lt;br/&gt;
-=&amp;gt; 2.736734332816085E108: 0 1 2 3 7 6 4 5&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 3 6 7&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 3 7 6&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 6 3 7&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 6 7 3&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 7 3 6&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 7 6 3&lt;/p&gt;

&lt;p&gt;&amp;lt;snip ~10,000 permutations with cost estimates of &quot;NaN&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;-=&amp;gt; NaN: 1 7 6 5 4 0 2 3&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 0 3 2&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 2 0 3&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 2 3 0&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 3 0 2&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 3 2 0&lt;br/&gt;
-=&amp;gt; 1736685.050617207: 2 0 1 3 4 5 6 7&lt;br/&gt;
-==&amp;gt; Just set bestCost to: 1736685.050617207&lt;br/&gt;
-=&amp;gt; 198589.53739726284: 2 0 1 3 4 5 7 6&lt;br/&gt;
-==&amp;gt; Just set bestCost to: 198589.53739726284&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt;&amp;gt; TIMED OUT: exceeded 198589.53739726284 ms.&lt;br/&gt;
-=&amp;gt; 198589.53739726284: 2 0 1 3 4 5 7 6&lt;br/&gt;
ELAPSED TIME = 336370 milliseconds&lt;/p&gt;

&lt;p&gt;------------------------&lt;br/&gt;
10.3 on 10.3 database:&lt;br/&gt;
------------------------&lt;/p&gt;

&lt;p&gt;ij version 10.3&lt;br/&gt;
-=&amp;gt; 5.607246651648704E62: 0 1 2 3 4 5 6 7&lt;br/&gt;
-==&amp;gt; Just set bestCost to: 5.607246651648704E62&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt;&amp;gt; JUMPING to: 1 4 2 6 7 0 3 5&lt;br/&gt;
-=&amp;gt; 1.8253980349686949E106: 0 1 2 3 4 5 6 7&lt;br/&gt;
-=&amp;gt; 3.021440681134236E107: 0 1 2 3 4 5 7 6&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 4 6 5 7&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 4 6 7 5&lt;br/&gt;
-=&amp;gt; 5.993308284393933E109: 0 1 2 3 4 7 5 6&lt;br/&gt;
-=&amp;gt; 2.736734332816085E108: 0 1 2 3 4 7 6 5&lt;br/&gt;
-=&amp;gt; 3.973494182787193E115: 0 1 2 3 5 4 6 7&lt;br/&gt;
-=&amp;gt; 6.577018684224087E116: 0 1 2 3 5 4 7 6&lt;br/&gt;
-=&amp;gt; 3.973494182787193E115: 0 1 2 3 5 6 4 7&lt;br/&gt;
-=&amp;gt; 6.577018684224087E116: 0 1 2 3 5 7 4 6&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 6 4 5 7&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 6 4 7 5&lt;br/&gt;
-=&amp;gt; 1.0852895218002162E119: 0 1 2 3 6 5 4 7&lt;br/&gt;
-=&amp;gt; 8.374147544754745E119: 0 1 2 3 6 7 4 5&lt;br/&gt;
-=&amp;gt; 5.993308284393933E109: 0 1 2 3 7 4 5 6&lt;br/&gt;
-=&amp;gt; 2.736734332816085E108: 0 1 2 3 7 4 6 5&lt;br/&gt;
-=&amp;gt; 1.2945545894290903E112: 0 1 2 3 7 5 4 6&lt;br/&gt;
-=&amp;gt; 2.736734332816085E108: 0 1 2 3 7 6 4 5&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 3 6 7&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 3 7 6&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 6 3 7&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 6 7 3&lt;br/&gt;
-=&amp;gt; NaN: 0 1 2 4 5 7 3 6&lt;/p&gt;

&lt;p&gt;&amp;lt;snip ~10,000 permutations with cost estimates of &quot;NaN&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;-=&amp;gt; NaN: 1 7 6 5 4 2 0 3&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 2 3 0&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 3 0 2&lt;br/&gt;
-=&amp;gt; NaN: 1 7 6 5 4 3 2 0&lt;br/&gt;
-=&amp;gt; Infinity: 2 0 1 3 4 5 6 7&lt;br/&gt;
-=&amp;gt; NaN: 2 0 1 3 4 5 7 6&lt;br/&gt;
-=&amp;gt; NaN: 2 0 1 3 4 6 5 7&lt;br/&gt;
-=&amp;gt; NaN: 2 0 1 3 4 6 7 5&lt;br/&gt;
-=&amp;gt; NaN: 2 0 1 3 4 7 5 6&lt;br/&gt;
-=&amp;gt; NaN: 2 0 1 3 4 7 6 5&lt;br/&gt;
-=&amp;gt; NaN: 2 0 1 3 5 4 6 7&lt;/p&gt;

&lt;p&gt;&amp;lt;snip ~30,000 permutations, most with cost estimates of &quot;NaN&quot;, a few with estimates of Infinity&amp;gt;&lt;/p&gt;

&lt;p&gt;-=&amp;gt; NaN: 7 6 5 4 3 1 0 2&lt;br/&gt;
-=&amp;gt; NaN: 7 6 5 4 3 1 2 0&lt;br/&gt;
-=&amp;gt; NaN: 7 6 5 4 3 2 0 1&lt;br/&gt;
-=&amp;gt; NaN: 7 6 5 4 3 2 1 0&lt;br/&gt;
&lt;del&gt;=&lt;/del&gt;&amp;gt; ENDED because ran out of permutations.&lt;br/&gt;
-=&amp;gt; 5.607246651648704E62: 0 1 2 3 4 5 6 7&lt;br/&gt;
ELAPSED TIME = 1145530 milliseconds&lt;/p&gt;

&lt;p&gt;I&apos;m still trying to make sense of this data, but perhaps this info will be helpful in tracking down the issue(s) here...&lt;/p&gt;</comment>
                            <comment id="12456115" author="bryanpendleton" created="Wed, 6 Dec 2006 17:02:43 +0000"  >&lt;p&gt;&amp;gt; When running against a 10.1 database 10.3 estimates a cost of 1736685, followed up by a &lt;br/&gt;
&amp;gt; cost of 198589 for the next complete order, which leads leads to eventual timeout. But when &lt;br/&gt;
&amp;gt; running against a 10.3 database, the cost estimate is &lt;b&gt;Infinity&lt;/b&gt; and thus the timeout value &lt;br/&gt;
&amp;gt; sits at 5E62, which we never reach.&lt;/p&gt;

&lt;p&gt;Is it possible that the 10.1 vs 10.3 database is a red herring here, and this is simply the&lt;br/&gt;
same &quot;non-determinism&quot; that I was observing in my initial tests? That is, you ran against two&lt;br/&gt;
different database, thus you ran all the CREATE TABLE/INDEX/VIEW statements twice,&lt;br/&gt;
and got hugely different results. I definitely saw dramatically different results even in the&lt;br/&gt;
10.3-only case from run to run, when running the entire script which recreates all the tables each time.&lt;/p&gt;

&lt;p&gt;My guess is that if you created 10.1 database A, and ran 10.3 against it, and then created&lt;br/&gt;
10.1 database B, and ran 10.3 against it, you might see dramatic differences even in just&lt;br/&gt;
those two runs. &lt;/p&gt;

&lt;p&gt;I&apos;m wondering if there is something going on, correlated to the DDL statements executed&lt;br/&gt;
by the repro script, which sometimes results in tables that return &quot;reasonable&quot;&lt;br/&gt;
estimates, and sometimes results in tables that return &quot;infinite&quot; estimates.&lt;/p&gt;</comment>
                            <comment id="12456541" author="army" created="Thu, 7 Dec 2006 19:03:39 +0000"  >&lt;p&gt;&amp;gt; Is it possible that the 10.1 vs 10.3 database is a red herring here,&lt;br/&gt;
&amp;gt; and this is simply the same &quot;non-determinism&quot; that I was observing&lt;br/&gt;
&amp;gt; in my initial tests?&lt;/p&gt;

&lt;p&gt;Good point, very well could be.  That didn&apos;t occur to me.&lt;/p&gt;

&lt;p&gt;&amp;gt; My guess is that if you created 10.1 database A, and ran 10.3 against&lt;br/&gt;
&amp;gt; it, and then created 10.1 database B, and ran 10.3 against it, you&lt;br/&gt;
&amp;gt; might see dramatic differences even in just those two runs.&lt;/p&gt;

&lt;p&gt;Have you yourself seen this variance with &lt;b&gt;10.1&lt;/b&gt; databases, as well?  I was limiting myself to the details in the description of this issue, which only mention the variance with 10.2 and trunk.  If you are also seeing the variance in 10.1, then can we assume that the non-deterministic variance aspect of this issue is not a regression, but is an existing problem with Derby since who-knows-when?  That might correlate with Mike&apos;s earlier comments about that being a potential issue in the past (hash codes based on DDL)...&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m wondering if there is something going on, correlated to the DDL&lt;br/&gt;
&amp;gt; statements executed by the repro script, which sometimes results in&lt;br/&gt;
&amp;gt; tables that return &quot;reasonable&quot; estimates, and sometimes results in&lt;br/&gt;
&amp;gt; tables that return &quot;infinite&quot; estimates.&lt;/p&gt;

&lt;p&gt;This is great question.  A follow-up question would be whether or not this DDL-based variance is a regression from 10.1 or has been there from the &quot;beginning&quot;.&lt;/p&gt;

&lt;p&gt;As you can tell, my primary focus here has been on potentially regressed behavior.  As I&apos;ve been looking at this problem I have been asking myself &quot;what changed from 10.1 to 10.2 to cause this sudden slow-down?&quot; So that&apos;s where my mind (and all of my questions) have been leading...&lt;/p&gt;

&lt;p&gt;And on that point, I mentioned in my last comment that the JUMP behavior &quot;does not take effect&quot; for 10.3, but it does for 10.1.  I spent some time tracing through the code and quickly realized that this change in behavior is an indirect result of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1357&quot; title=&quot;Short-circuit logic in optimizer appears to be incorrect...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1357&quot;&gt;&lt;del&gt;DERBY-1357&lt;/del&gt;&lt;/a&gt;.  Here&apos;s why.&lt;/p&gt;

&lt;p&gt;As explained on the wiki page that describes jumping (&lt;a href=&quot;http://wiki.apache.org/db-derby/JoinOrderPermutations&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/JoinOrderPermutations&lt;/a&gt;), the optimizer will find the first complete join order for a query before attempting to jump.  In the repro query the first join order is simply &quot;0 1 2 3 4 5 6 7&quot;.  The associated cost is 5.607E62.  Using the row counts calculated for this join order, the &quot;target&quot; join order then becomes &quot;1 4 2 6 7 0 3 5&quot;.  This means that the next 8 calls to &quot;getNextPermutation()&quot; will return partial join orders that build up to this target.  i.e.&lt;/p&gt;

&lt;p&gt;1 -1 -1 -1 -1 -1 -1 -1&lt;br/&gt;
1  4 -1 -1 -1 -1 -1 -1&lt;br/&gt;
1  4  2 -1 -1 -1 -1 -1&lt;br/&gt;
etc.&lt;/p&gt;

&lt;p&gt;Prior to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1357&quot; title=&quot;Short-circuit logic in optimizer appears to be incorrect...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1357&quot;&gt;&lt;del&gt;DERBY-1357&lt;/del&gt;&lt;/a&gt; the optimizer &quot;short-circuit&quot; logic was not working, so even if a partial join order is more expensive than the best complete join order so far, the optimizer will continue to waste time optimizing join orders that are always going to return an estimate that is higher than the best so far.  So in 10.1 (which does not have the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1357&quot; title=&quot;Short-circuit logic in optimizer appears to be incorrect...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1357&quot;&gt;&lt;del&gt;DERBY-1357&lt;/del&gt;&lt;/a&gt;) we&apos;ll merrily continue on our way from &lt;span class=&quot;error&quot;&gt;&amp;#91;1 4 2 ... &amp;#93;&lt;/span&gt; all the way up until we either timeout or find a join order that is cheaper than 5.607E62.  We eventually find a cheaper join order after about 2500 permutations, and that&apos;s the point at which optimization stops (see details from my previous comment).&lt;/p&gt;

&lt;p&gt;With 10.2 and trunk, though, the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1357&quot; title=&quot;Short-circuit logic in optimizer appears to be incorrect...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1357&quot;&gt;&lt;del&gt;DERBY-1357&lt;/del&gt;&lt;/a&gt; short-circuit logic has been corrected.  And as it happens, the estimated cost for the partial join order &quot;1 4 2 6 7 0 3&quot; is &quot;Infinity&quot;; since that&apos;s greater than 5.607E62, we do not advance the join order and thus we effectively skip the rest of it (because we know it&apos;s going to return a cost that&apos;s worse than 5.607E62).  That part is, I think, correct.&lt;/p&gt;

&lt;p&gt;But having chosen to NOT advance the join order, now we come to the following block of code in OptimizerImpl:&lt;/p&gt;

&lt;p&gt;    if (permuteState == JUMPING &amp;amp;&amp;amp; !joinPosAdvanced &amp;amp;&amp;amp; joinPosition &amp;gt;= 0)&lt;/p&gt;
    {
        //not feeling well in the middle of jump
        // Note: we have to make sure we reload the best plans
        // as we rewind since they may have been clobbered
        // (as part of the current join order) before we gave
        // up on jumping.
        reloadBestPlan = true;
        rewindJoinOrder();  //fall
        permuteState = NO_JUMP;  //give up
    }

&lt;p&gt;Since we&apos;re in the middle of jumping and since we did &lt;b&gt;not&lt;/b&gt; advance the join order, we execute this if block--i.e. we rewind the join order back to the beginning and start all over.  Or put another way, we gave up on the &quot;JUMP&quot; and went back to normal processing.  From there we then have to go through thousands and thousands of permutations before we find a plan that&apos;s cheaper than 5.607E62.  Depending on which database is in use, that can be ten thousand permutations or it could be forty thousand, which explains the variance in the time taken to complete optimization.&lt;/p&gt;

&lt;p&gt;I think the changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1357&quot; title=&quot;Short-circuit logic in optimizer appears to be incorrect...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1357&quot;&gt;&lt;del&gt;DERBY-1357&lt;/del&gt;&lt;/a&gt; are correct; what&apos;s not clear is whether the &quot;if&quot; block shown above is really necessary.  The idea sort of makes sense to me: if we broke away from normal processing and jumped to a &lt;em&gt;bad&lt;/em&gt; join order then we want to abort the jump as quickly as possible and return to normal processing.  However, now that the optimizer &quot;short-circuit&quot; logic is fixed, I&apos;m not so sure we need to revert back to &quot;normal&quot; processing when we jump to a bad join order.  If the join order is bad then the short-circuit logic will make sure that we do not waste &quot;too much&quot; (yes, that&apos;s an awfully subjective term) time trying out bad join orders.  So would it make sense to just &quot;iterate&quot; the target join order as usual without defaulting back to square one?&lt;/p&gt;

&lt;p&gt;As a sanity check I commented the above &quot;if&quot; block out in the trunk codeline and ran the repro; when I did so, the script executed in about the same time as it does on the latest 10.1 branch.  So this seems to confirm my findings.  FAR more testing is needed, though, to see if this simple removal of the &quot;if&quot; block is a viable solution.&lt;/p&gt;

&lt;p&gt;All of that said, I still think the BIGGER problems we are seeing are 1) &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt; and 2) as Bryan has said, the apparent variance in cost estimates based on DDL.  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1905&quot; title=&quot;Optimizer cost estimates for subqueries are way (way) too high.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1905&quot;&gt;DERBY-1905&lt;/a&gt; is definitely playing a huge role here, what with the Infinity cost estimates followed by NaN.  These kinds of estimates render the vast majority of the join order estimates useless, even if we do remove the &quot;if&quot; block mentioned above.&lt;/p&gt;

&lt;p&gt;Also note: when I remove the &quot;if&quot; block as mentioned above, I found that sometimes the cost estimate for the &quot;best&quot; join order (&quot;2 0 1 3 4 5 6 7&quot;) was &quot;14116&quot;, and sometimes it was &quot;247&quot;.  This was on the &lt;b&gt;same&lt;/b&gt; database and so does not appear to be the result of DDL statements.  I&apos;m still looking into this little tidbit to see what might be going on there...&lt;/p&gt;

&lt;p&gt;As usual, some of this may be useful, some of it may not be. Please excuse me if I&apos;m babbling...&lt;/p&gt;</comment>
                            <comment id="12457083" author="bryanpendleton" created="Sat, 9 Dec 2006 16:13:32 +0000"  >&lt;p&gt;&amp;gt; My guess is that if you created 10.1 database A, and ran 10.3 against&lt;br/&gt;
&amp;gt; it, and then created 10.1 database B, and ran 10.3 against it, you&lt;br/&gt;
&amp;gt; might see dramatic differences even in just those two runs.&lt;/p&gt;

&lt;p&gt;I was able to confirm this.&lt;/p&gt;

&lt;p&gt;I created 10 separate databases using 10.1.2.1, and ran the DDL portion of repro.sql&lt;br/&gt;
against each of those 10 databases using 10.1.2.1.&lt;/p&gt;

&lt;p&gt;Then I ran just the PREPARE portion of repro.sql against each of those 10 databases,&lt;br/&gt;
using the 10.3 trunk, and setting derby.database.allowPreReleaseUpgrade=true so&lt;br/&gt;
that 10.3 would be willing to access the 10.1 database.&lt;/p&gt;

&lt;p&gt;Often, I observed 170-180 seconds for the prepare.&lt;/p&gt;

&lt;p&gt;But I also observed 500-650 seconds for the prepare.&lt;/p&gt;

&lt;p&gt;Furthermore, it wasn&apos;t on the same database each time!&lt;/p&gt;

&lt;p&gt;That is, once I saw 500 seconds for the prepare on database 6, but I reran DB 6&lt;br/&gt;
and saw 168 seconds.&lt;/p&gt;

&lt;p&gt;And, the first time I did the prepare on DB 8, it was 170 seconds, but the second&lt;br/&gt;
time I did the prepare on DB 8, it was 607 seconds.&lt;/p&gt;

&lt;p&gt;So my observations are that:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;10.3 is non-deterministic regarding the amount of time that the PREPARE takes&lt;/li&gt;
	&lt;li&gt;it happens whether the DB and schema are created using 10.1, or 10.3&lt;/li&gt;
	&lt;li&gt;the same DB, with the same DDL, can sometimes prepare the query in time X,&lt;br/&gt;
   and sometimes in time Y, and as far as I can tell nothing is changing&lt;br/&gt;
   between runs. I just run IJ with the &quot;prepare&quot; script twice in a row, and&lt;br/&gt;
   get two very different elapsed times.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; I&apos;m wondering if there is something going on, correlated to the DDL&lt;br/&gt;
&amp;gt; statements executed by the repro script, which sometimes results in&lt;br/&gt;
&amp;gt; tables that return &quot;reasonable&quot; estimates, and sometimes results in&lt;br/&gt;
&amp;gt; tables that return &quot;infinite&quot; estimates.&lt;/p&gt;

&lt;p&gt;I now believe this is &lt;b&gt;not&lt;/b&gt; an accurate theory, as the non-determinism does not&lt;br/&gt;
seem to be correlated to a particular run of the DDL statements.&lt;/p&gt;

&lt;p&gt;So at this point I don&apos;t think that the non-determinism depends on whether the&lt;br/&gt;
database and its tables were created by 10.1, or by 10.3, and I don&apos;t think that&lt;br/&gt;
the non-determinism is &quot;tied&quot; to a particular database and set of tables; the&lt;br/&gt;
same database and tables can sometimes lead to one prepare time, and sometimes&lt;br/&gt;
to a different prepare time.&lt;/p&gt;</comment>
                            <comment id="12457784" author="army" created="Tue, 12 Dec 2006 16:29:31 +0000"  >&lt;p&gt;&amp;gt; That is, once I saw 500 seconds for the prepare on database 6, but I&lt;br/&gt;
&amp;gt; reran DB 6 and saw 168 seconds. &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; I don&apos;t think that the non-&lt;br/&gt;
&amp;gt; determinism is &quot;tied&quot; to a particular database and set of tables;&lt;br/&gt;
&amp;gt; the same database and tables can sometimes lead to one prepare time,&lt;br/&gt;
&amp;gt; and sometimes to a different prepare time.  &lt;/p&gt;

&lt;p&gt;As I was looking at this problem I noticed a bug in the code that &lt;b&gt;may&lt;/b&gt; be causing this variance.  It looks like we are not resetting the permuteState field in OptimizerImpl at the beginning of each &quot;round&quot; of optimization.  The result (in the cases I saw) was that the field has the value WALK_LOW at the start of the second round of optimization, which, in very timing- sensitive situations, can lead to a code-path that causes the bestCost for the round to remain UNSET--i.e. it sits as Double.MAX_VALUE.  Then if we try to add anything to that cost, we end up with Infinity, which effectively ruins most subsequent cost estimates.&lt;/p&gt;

&lt;p&gt;I still have not been able to reproduce the variance that Bryan reports, so I cannot say for sure that this is the cause.  I ran the repro 10 times against the same database and I consistently saw times of 550 to 700 seconds--and in each case I could see that the optimizer tried out all 40k permutations before completing.  Then I added code to reset the permuteState variable (see attached jumpReset.patch) and ran the repro 10 more times against the same database.  In this case every execution completed in about 200 to 220 seconds, and I could see that the optimizer timed out before trying out all permutations (which is more what I would expect).&lt;/p&gt;

&lt;p&gt;The reason I bring this is up is because the compilation time without jumpReset.patch and the compilation time with it appear to correlate to the times that Bryan is seeing in his variance (based on his previous comment).  So I&apos;m wondering if the two are related...?&lt;/p&gt;

&lt;p&gt;Bryan, I know you are busy and that running these tests takes a while, but if you have the time/inclination, can you apply jumpReset.patch to your codeline and run your tests again?  I&apos;m wondering what effect (if any) the patch will have on the variance that you are seeing...  &lt;/p&gt;</comment>
                            <comment id="12458025" author="bryanpendleton" created="Wed, 13 Dec 2006 05:57:07 +0000"  >&lt;p&gt;With jumpReset.patch applied, I cannot reproduce the varying optimize times.&lt;br/&gt;
The times are all in a tight range, after nearly 6x as many tests as produced&lt;br/&gt;
the variable optimize times before.&lt;/p&gt;</comment>
                            <comment id="12662441" author="kmarsden" created="Fri, 9 Jan 2009 17:40:17 +0000"  >&lt;p&gt;I wonder if the patch attached to this issue can be pursued as is or if there is more work that needs to be done.  It seems it would be good to get this performance regression fixed.&lt;/p&gt;</comment>
                            <comment id="12728132" author="knutanders" created="Tue, 7 Jul 2009 15:57:33 +0100"  >&lt;p&gt;Triaged for 10.5.2.&lt;/p&gt;</comment>
                            <comment id="12859413" author="rhillegas" created="Wed, 21 Apr 2010 17:11:16 +0100"  >&lt;p&gt;Hi Bryan,&lt;/p&gt;

&lt;p&gt;You contributed a patch for this issue more than 3 years ago but the patch probably needs to be updated before it can be applied now. Are you interested in pursuing this?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12859624" author="bryanpendleton" created="Thu, 22 Apr 2010 03:06:56 +0100"  >&lt;p&gt;Hi Rick,&lt;/p&gt;

&lt;p&gt;I think that Army&apos;s patch is a good one, but I&apos;m afraid I don&apos;t have time right&lt;br/&gt;
now to push this issue forward.&lt;/p&gt;</comment>
                            <comment id="13464142" author="kmarsden" created="Wed, 26 Sep 2012 21:29:12 +0100"  >&lt;p&gt;Is the patch considered high risk?  Would it be appropriate to mark this newcomer if someone wants to try out Army&apos;s patch, run tests and drive this issue to resolution?&lt;/p&gt;</comment>
                            <comment id="13464757" author="bryanpendleton" created="Thu, 27 Sep 2012 15:09:37 +0100"  >&lt;p&gt;I don&apos;t consider the patch high risk. I think it is ready to pursue. I think it&apos;s reasonable&lt;br/&gt;
to mark this as a newcomer issue. I would be willing to help work with anybody who&lt;br/&gt;
has the time/motivation to push this forward.&lt;/p&gt;</comment>
                            <comment id="13800149" author="kmarsden" created="Sun, 20 Oct 2013 16:15:14 +0100"  >&lt;p&gt;Verified this is still a problem.  On my machine the 10.1 query takes 13 seconds but 203 seconds on trunk.&lt;/p&gt;</comment>
                            <comment id="13800154" author="kmarsden" created="Sun, 20 Oct 2013 16:58:37 +0100"  >&lt;p&gt;I manually merged the changes to trunk (jumpReset_10_11_trunk_diff.txt) and find the query runs in 64 seconds on trunk  vs the 13 on 10.1, so three times faster but nowhere near the 10.1 performance.  I am using &lt;br/&gt;
java version &quot;1.7.0&quot;&lt;br/&gt;
Java(TM) SE Runtime Environment (build pwi3270sr5-20130619_01(SR5))&lt;br/&gt;
IBM J9 VM (build 2.6, JRE 1.7.0 Windows 7 x86-32 20130617_152572 (JIT enabled, AOT enabled)&lt;br/&gt;
J9VM - R26_Java726_SR5_20130617_1436_B152572&lt;br/&gt;
JIT  - r11.b04_20130528_38954ifx1&lt;br/&gt;
GC   - R26_Java726_SR5_20130617_1436_B152572&lt;br/&gt;
J9CL - 20130617_152572)&lt;br/&gt;
JCL - 20130616_01 based on Oracle 7u25-b12&lt;/p&gt;

&lt;p&gt;I am not sure if I made an error with the merge or if there is some other regression that has been masked by this one.&lt;/p&gt;
</comment>
                            <comment id="13800159" author="bryanpendleton" created="Sun, 20 Oct 2013 17:56:10 +0100"  >&lt;p&gt;Three times faster is nothing to sneeze at!&lt;/p&gt;</comment>
                            <comment id="13800791" author="kmarsden" created="Mon, 21 Oct 2013 17:43:45 +0100"  >&lt;p&gt;So should I  go ahead and check this in as is if tests pass?  If so, should it go back to 10.10? We aren&apos;t really set up for performance regression tests so I am not really sure what testing we could add.&lt;/p&gt;</comment>
                            <comment id="13801328" author="bryanpendleton" created="Tue, 22 Oct 2013 00:53:47 +0100"  >&lt;p&gt;+1 to checking in the patch. It clearly makes this case better, and that&apos;s a good thing.&lt;/p&gt;

&lt;p&gt;I don&apos;t think it&apos;s worth any backporting, as nobody is specifically waiting for it&lt;br/&gt;
that I know of. If we put the patch only in trunk for now we can continue to&lt;br/&gt;
try to figure out how to test it better.&lt;/p&gt;</comment>
                            <comment id="13801431" author="jira-bot" created="Tue, 22 Oct 2013 03:37:13 +0100"  >&lt;p&gt;Commit 1534465 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kmarsden&quot; class=&quot;user-hover&quot; rel=&quot;kmarsden&quot;&gt;Kathey Marsden&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1534465&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1534465&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2130&quot; title=&quot;Optimizer performance slowdown from 10.1 to 10.2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2130&quot;&gt;&lt;del&gt;DERBY-2130&lt;/del&gt;&lt;/a&gt; - Optimizer performance slowdown from 10.1 to 10.2&lt;/p&gt;

&lt;p&gt;Patch contributed by Army Brown&lt;/p&gt;</comment>
                            <comment id="13803544" author="kmarsden" created="Thu, 24 Oct 2013 00:33:33 +0100"  >&lt;p&gt;I tried patched 10.2 and found the prepare was 13 seconds, so it seems this patch did resolve the original performance regression.  On patched 10.3 the prepare was 69 seconds, so I guess there was an additional slow down from 10.2 to 10.3 which we are still seeing on trunk 10.11. I will resolve this issue and open another one for the 10.2 to 10.3 performance slow down.&lt;/p&gt;

</comment>
                            <comment id="13803585" author="kmarsden" created="Thu, 24 Oct 2013 01:09:23 +0100"  >&lt;p&gt;Fixing just in trunk for now to monitor any performance change.  Fix should be suitable for backport.&lt;/p&gt;</comment>
                            <comment id="13913302" author="mikem" created="Wed, 26 Feb 2014 18:46:05 +0000"  >&lt;p&gt;consider for 10.10 backport&lt;/p&gt;</comment>
                            <comment id="13913337" author="mikem" created="Wed, 26 Feb 2014 19:05:02 +0000"  >&lt;p&gt;looking at backporting this to 10.10&lt;/p&gt;</comment>
                            <comment id="13913351" author="mikem" created="Wed, 26 Feb 2014 19:12:24 +0000"  >&lt;p&gt;just reopening while working on backport to 10.10.&lt;/p&gt;</comment>
                            <comment id="13913749" author="jira-bot" created="Wed, 26 Feb 2014 23:43:36 +0000"  >&lt;p&gt;Commit 1572351 from mikem@apache.org in branch &apos;code/branches/10.10&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1572351&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1572351&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2130&quot; title=&quot;Optimizer performance slowdown from 10.1 to 10.2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2130&quot;&gt;&lt;del&gt;DERBY-2130&lt;/del&gt;&lt;/a&gt; - Optimizer performance slowdown from 10.1 to 10.2&lt;/p&gt;

&lt;p&gt;backporting change #1534465 from trunk to 10.10&lt;/p&gt;

&lt;p&gt;Patch contributed by Army Brown&lt;/p&gt;</comment>
                            <comment id="13913752" author="mikem" created="Wed, 26 Feb 2014 23:44:46 +0000"  >&lt;p&gt;backported from trunk to 10.10, do not plan on backporting any more for now - but see no reason it could not be.&lt;/p&gt;</comment>
                            <comment id="14284711" author="myrna" created="Wed, 21 Jan 2015 00:22:54 +0000"  >&lt;p&gt;bulk change to close all issues resolved but not closed and not changed since June 1, 2014.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12675361">DERBY-6392</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12474981">DERBY-4818</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12695601">DERBY-6481</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12347032" name="jumpReset.patch" size="1796" author="army" created="Tue, 12 Dec 2006 16:29:30 +0000"/>
                            <attachment id="12609310" name="jumpReset_10_11_trunk_diff.txt" size="1912" author="kmarsden" created="Sun, 20 Oct 2013 16:58:36 +0100"/>
                            <attachment id="12346468" name="plan10_1_2_1.txt" size="80801" author="bryanpendleton" created="Tue, 5 Dec 2006 18:09:16 +0000"/>
                            <attachment id="12346469" name="plan10_2.txt" size="79876" author="bryanpendleton" created="Tue, 5 Dec 2006 18:09:16 +0000"/>
                            <attachment id="12346470" name="plans.diff" size="13718" author="bryanpendleton" created="Tue, 5 Dec 2006 18:09:16 +0000"/>
                            <attachment id="12346070" name="repro.sql" size="9072" author="bryanpendleton" created="Wed, 29 Nov 2006 22:56:44 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 30 Nov 2006 19:33:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22901</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    <customfieldvalue key="10423"><![CDATA[Newcomer]]></customfieldvalue>
    <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy09dz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35339</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>