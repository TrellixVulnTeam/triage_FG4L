<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:36:21 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1261/DERBY-1261.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1261] Two triggers on same table cause &quot;ERROR 54038: Maximum depth of nested triggers was exceeded.&quot;</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1261</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Two triggers on same table may lead to self-recursion:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t3(i integer primary key, j integer, t timestamp);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create trigger tr3i after insert on t3 referencing new as new for each row mode db2sql update t3 set t = current_timestamp where i = new.i;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t3 values (1, 1, NULL);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create trigger tr3u after update on t3 referencing old as old for each row mode db2sql update t3 set t = current_timestamp where i = old.i;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t3 values (2, 1, NULL);&lt;br/&gt;
ERROR 54038: Maximum depth of nested triggers was exceeded.&lt;br/&gt;
ij&amp;gt; update t3 set j=j+1;&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create trigger tr3u2 after update on t3 referencing old as old for each row mode db2sql update t3 set j = 0 where i = old.i and j &amp;gt; 2;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; update t3 set j=j+1;&lt;br/&gt;
ERROR 54038: Maximum depth of nested triggers was exceeded.&lt;/p&gt;


&lt;p&gt;From derby.log:&lt;br/&gt;
2006-04-27 10:03:54.792 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 1274), (SESSIONID = 0), (DATABASE = testDB), (DRDAID = null), Cleanup action starting&lt;br/&gt;
2006-04-27 10:03:54.792 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 1274), (SESSIONID = 0), (DATABASE = testDB), (DRDAID = null), Failed Statement is: insert into t3 values (2, 1, NULL)&lt;br/&gt;
ERROR 54038: Maximum depth of nested triggers was exceeded.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:301)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.pushTriggerExecutionContext(GenericLanguageConnectionContext.java:2104)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InternalTriggerExecutionContext.&amp;lt;init&amp;gt;(InternalTriggerExecutionContext.java:179)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.GenericExecutionFactory.getTriggerExecutionContext(GenericExecutionFactory.java:302)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TriggerEventActivator.&amp;lt;init&amp;gt;(TriggerEventActivator.java:105)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.fireBeforeTriggers(UpdateResultSet.java:798)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:283)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:361)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(GenericTriggerExecutor.java:169)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.RowTriggerExecutor.fireTrigger(RowTriggerExecutor.java:110)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(TriggerEventActivator.java:277)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(InsertResultSet.java:1134)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(InsertResultSet.java:522)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:361)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1161)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:567)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:497)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:313)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:433)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:310)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Main.java:203)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:169)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main14.main(Main14.java:55)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(ij.java:60)&lt;br/&gt;
Cleanup action completed&lt;br/&gt;
2006-04-27 10:06:18.589 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 1293), (SESSIONID = 0), (DATABASE = testDB), (DRDAID = null), Cleanup action starting&lt;br/&gt;
2006-04-27 10:06:18.589 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;main,5,main&amp;#93;&lt;/span&gt; (XID = 1293), (SESSIONID = 0), (DATABASE = testDB), (DRDAID = null), Failed Statement is: update t3 set j=j+1&lt;br/&gt;
ERROR 54038: Maximum depth of nested triggers was exceeded.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:301)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.pushTriggerExecutionContext(GenericLanguageConnectionContext.java:2104)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InternalTriggerExecutionContext.&amp;lt;init&amp;gt;(InternalTriggerExecutionContext.java:179)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.GenericExecutionFactory.getTriggerExecutionContext(GenericExecutionFactory.java:302)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TriggerEventActivator.&amp;lt;init&amp;gt;(TriggerEventActivator.java:105)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.fireBeforeTriggers(UpdateResultSet.java:798)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:283)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:361)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(GenericTriggerExecutor.java:169)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.RowTriggerExecutor.fireTrigger(RowTriggerExecutor.java:110)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(TriggerEventActivator.java:277)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.fireAfterTriggers(UpdateResultSet.java:825)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:288)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:361)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1161)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:567)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:497)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:313)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:433)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:310)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Main.java:203)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:169)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main14.main(Main14.java:55)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(ij.java:60)&lt;br/&gt;
Cleanup action completed&lt;/p&gt;</description>
                <environment>Embedded on Solaris x86</environment>
        <key id="12332783">DERBY-1261</key>
            <summary>Two triggers on same table cause &quot;ERROR 54038: Maximum depth of nested triggers was exceeded.&quot;</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="oysteing">&#216;ystein Gr&#248;vlen</reporter>
                        <labels>
                            <label>derby_triage10_11</label>
                    </labels>
                <created>Thu, 27 Apr 2006 18:57:37 +0100</created>
                <updated>Wed, 3 Jul 2013 16:26:40 +0100</updated>
                                            <version>10.0.2.0</version>
                                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12377458" author="djd" created="Wed, 3 May 2006 03:52:54 +0100"  >&lt;p&gt;Why is this a bug. Isn&apos;t the second trigger (tr3u) defined as a recursive trigger?&lt;/p&gt;

&lt;p&gt;What behaviour are you expecting?&lt;/p&gt;</comment>
                            <comment id="12377531" author="oysteing" created="Wed, 3 May 2006 16:05:59 +0100"  >&lt;p&gt;I am not quite sure what the definition of a recursive trigger is, and I did not find any definition of that in the documentation. Is a trigger recursive if it updates the record it is fired on?  I would think that would be very useful to able to do in many cases, and in fact, it seems like you can do that in Derby as long as you do not define more than one trigger on a table.  If I only create the tr3u trigger, everything works fine.   However, if I add an insert trigger or another update trigger recursion overflow occur.&lt;/p&gt;

&lt;p&gt;I have not looked at the code, but from the outside it looks like there is a mechanism to prevent recursion in the event that a single update trigger updates the record it was fire on.  However, if the trigger is triggered by an update caused by another trigger, recursion is not prevented.&lt;/p&gt;

&lt;p&gt;I guess the behavior I am expecting is that whether a trigger is recursive or not, should not depend on whether it was fired by a direct user update or by a update performed by a trigger.&lt;/p&gt;</comment>
                            <comment id="12377637" author="djd" created="Thu, 4 May 2006 05:15:39 +0100"  >&lt;p&gt;Trigger recursion occurs when there is a cycle in the firing of triggers that leads to recursion. (is that a recursive definition!)&lt;/p&gt;

&lt;p&gt;I would say that this bug is really that behave of triggers is inconsistent when there is potential recursion.&lt;/p&gt;

&lt;p&gt;I expected in your example the first update statement to lead to recursion and 54038 exception.&lt;/p&gt;

&lt;p&gt;And when I ran your test in a clean database I do not see any exception on the second INSERT,&lt;br/&gt;
though if I drop the table and re-run the same SQL statements I do see the  54038 error&lt;/p&gt;

&lt;p&gt;Seems like we need to define clean consistent behaviour, which may come from the SQL standard.&lt;/p&gt;</comment>
                            <comment id="12378605" author="bernt" created="Tue, 9 May 2006 19:25:02 +0100"  >&lt;p&gt;I have tried to unsetsand the significance of section 4.38 w.r.t. the&lt;br/&gt;
above example, but I am not sure what to think yet.....&lt;/p&gt;

&lt;p&gt;Another interesting (and simpler) example seem to be a bit easier to&lt;br/&gt;
uderstand, and might shed some light on the problem:&lt;/p&gt;

&lt;p&gt;    create table tab(i integer primary key, j integer);&lt;br/&gt;
    insert into tab values (1, null);&lt;br/&gt;
    insert into tab values (2, null);&lt;/p&gt;

&lt;p&gt;    create trigger t1&lt;br/&gt;
        after update &lt;br/&gt;
        on tab &lt;br/&gt;
        referencing old as old for each row &lt;br/&gt;
        mode db2sql &lt;br/&gt;
        update tab set j=1 where i = old.i;&lt;/p&gt;

&lt;p&gt;    create trigger t2&lt;br/&gt;
        after update &lt;br/&gt;
        on tab &lt;br/&gt;
        referencing old as old for each row &lt;br/&gt;
        mode db2sql &lt;br/&gt;
        update tab set j=2 where i = old.i;&lt;/p&gt;

&lt;p&gt;    update tab set j=3;&lt;/p&gt;

&lt;p&gt;The way I interpret section 4.38, this should not cause a&lt;br/&gt;
recursion. The update sentence will cause both t1 and t2 to be&lt;br/&gt;
executed in that order and the set of rows/columns changed is the&lt;br/&gt;
same, so trigger t1 should be executed only once.&lt;/p&gt;

&lt;p&gt;Disclaimer: Try to understand section 4.28 yourself...... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12378607" author="bernt" created="Tue, 9 May 2006 19:28:10 +0100"  >&lt;p&gt;Since I&apos;m not allowed to change my comment (why?):&lt;br/&gt;
In the previous comment: unsetsand=understand&lt;/p&gt;

&lt;p&gt;The result of the update statement should be (1,2),(2,2)&lt;/p&gt;</comment>
                            <comment id="12378610" author="bernt" created="Tue, 9 May 2006 19:43:06 +0100"  >&lt;p&gt;And, I forgot t mention that my example fails with&lt;br/&gt;
ERROR 54038: Maximum depth of nested triggers was exceeded.&lt;/p&gt;</comment>
                            <comment id="12418666" author="deepa" created="Fri, 30 Jun 2006 23:20:26 +0100"  >&lt;p&gt;In the context of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-551&quot; title=&quot;Allow invoking java stored procedures from inside a trigger. Make CALL a valid statement in the trigger body.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-551&quot;&gt;&lt;del&gt;DERBY-551&lt;/del&gt;&lt;/a&gt; (enabling procedures in triggers), I have been looking at behaviour of triggers and recursion. I came across this issue and on looking at it, I tend to think the examples above are cases of recursion. Even with just the first trigger, I think we should be getting &quot;ERROR 54038: Maximum depth of nested triggers was exceeded. &quot;. I am basing this on the following paragraph from section 4.38 of the spec:&lt;/p&gt;

&lt;p&gt;&quot;During the execution of an SQL-statement, zero or more trigger execution contexts exist, no more&lt;br/&gt;
than one of which is active. The execution of an SQL-data change statement Si creates at least one&lt;br/&gt;
new trigger execution context TECi and causes TECi to become active. TECi remains in existence&lt;br/&gt;
until the completion of Si. An SQL-data change statement Sj that is executed before the completion&lt;br/&gt;
of Si preserves TECi and creates a new trigger execution context TECj that becomes the active one&lt;br/&gt;
and remains in existence until the completion of Sj. At the completion of Sj, TECj ceases to exist&lt;br/&gt;
and TECi is restored as the active trigger execution context.&quot;&lt;/p&gt;

&lt;p&gt;I think the example below with just one trigger should cause recursion when we try to fire the trigger. But currently it does not and this looks like a bug to me.&lt;/p&gt;

&lt;p&gt; create table tab(i integer primary key, j integer);&lt;br/&gt;
    insert into tab values (1, null);&lt;br/&gt;
    insert into tab values (2, null);&lt;/p&gt;

&lt;p&gt;    create trigger t1&lt;br/&gt;
        after update&lt;br/&gt;
        on tab&lt;br/&gt;
        referencing old as old for each row&lt;br/&gt;
        mode db2sql&lt;br/&gt;
        update tab set j=1 where i = old.i;&lt;/p&gt;

&lt;p&gt;    update tab set j=3; &lt;/p&gt;

&lt;p&gt;When we execute the update statement ( update tab set j=3; ), it will create a trigger execution context (TEC). The trigger firing will cause another update statement (update tab set j=1 where i = old.i; &amp;#8212; this is the triggered-sql-statement) to get executed. This new statement will in turn create a new TEC. This will cause the same trigger to fire and that will create another TEC and so on. Each TEC can execute the trigger once (if trigger event is satisfied). As there will new TECs for each new update statement, the trigger will get fired by each of the associated TECs. So I think this is a case of recursion. I have not read the code surrounding this. This is just my interpretation of the spec. &lt;/p&gt;

&lt;p&gt;Thoughts/comments?&lt;/p&gt;</comment>
                            <comment id="12420298" author="fernanda" created="Tue, 11 Jul 2006 20:30:13 +0100"  >&lt;p&gt;I agree with Deepa&apos;s interpretation that a trigger should be able to fire itself, but based on the following paragraph on section 4.38 of the spec, I believe that the same row-level trigger should not be executed more than once for the same row.&lt;/p&gt;

&lt;p&gt;&quot;If a row-level trigger RLT is considered as executed for some row R in SC, then RLT is not subsequently executed for R.&quot;&lt;/p&gt;

&lt;p&gt;I looked into this issue when I was working on other trigger related issues (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1043&quot; title=&quot;Invalid column references are not caught in a trigger action statement when the referencing table of the column is the triggered table&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1043&quot;&gt;&lt;del&gt;DERBY-1043&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1064&quot; title=&quot;Delete cascade causes NULL values inserted into table when after delete Trigger fires&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1064&quot;&gt;&lt;del&gt;DERBY-1064&lt;/del&gt;&lt;/a&gt;) and I found out that the behavior of the trigger (recursive or not) changed when changes were made to the definition of the table. Regardless of which interpretation of the spec is correct, the sudden change on the behavior of the trigger is definitively a bug.&lt;/p&gt;

&lt;p&gt;When I create the trigger &quot;tr1&quot; on table &quot;t1&quot; it is not recursive.&lt;/p&gt;

&lt;p&gt;	create table t1 (a int, b int);&lt;/p&gt;

&lt;p&gt;	insert into t1 (a) values (1), (2), (3), (4), (5);&lt;/p&gt;

&lt;p&gt;	create trigger tr1 &lt;br/&gt;
		after update on t1 &lt;br/&gt;
		referencing old as old &lt;br/&gt;
		for each row mode db2sql &lt;br/&gt;
		update t1 set b = 1 where a = old.a + 1;&lt;/p&gt;

&lt;p&gt;	update t1 set a = a + 10 where a = 1;&lt;/p&gt;

&lt;p&gt;	select * from t1;&lt;br/&gt;
	A          |B&lt;br/&gt;
	-----------------------&lt;br/&gt;
	11         |NULL&lt;br/&gt;
	2          |1&lt;br/&gt;
	3          |NULL&lt;br/&gt;
	4          |NULL&lt;br/&gt;
	5          |NULL&lt;/p&gt;

&lt;p&gt;	5 rows selected&lt;/p&gt;

&lt;p&gt;If I later create a new trigger on table &quot;t1&quot; or add a column to table &quot;t1&quot; as the two examples below show, the trigger &quot;tr1&quot; becomes recursive.&lt;/p&gt;

&lt;p&gt;Example 1: creating a new trigger&lt;/p&gt;

&lt;p&gt;	create trigger tr2 &lt;br/&gt;
		after update on t1 &lt;br/&gt;
		referencing old as old &lt;br/&gt;
		for each row mode db2sql &lt;br/&gt;
		values(old.a);&lt;/p&gt;

&lt;p&gt;	update t1 set a = a + 10 where a = 1;&lt;/p&gt;

&lt;p&gt;	select * from t1;&lt;br/&gt;
	A          |B&lt;br/&gt;
	-----------------------&lt;br/&gt;
	11         |NULL&lt;br/&gt;
	2          |1&lt;br/&gt;
	3          |1&lt;br/&gt;
	4          |1&lt;br/&gt;
	5          |1&lt;/p&gt;

&lt;p&gt;	5 rows selected&lt;/p&gt;

&lt;p&gt;Example 2: adding a column&lt;/p&gt;

&lt;p&gt;	alter table t1 &lt;br/&gt;
		add column c int;&lt;/p&gt;

&lt;p&gt;	update t1 set a = a + 10 where a = 1;&lt;/p&gt;

&lt;p&gt;	select * from t1;&lt;br/&gt;
	A          |B          |C&lt;br/&gt;
	-----------------------------------&lt;br/&gt;
	11         |NULL       |NULL&lt;br/&gt;
	2          |1          |NULL&lt;br/&gt;
	3          |1          |NULL&lt;br/&gt;
	4          |1          |NULL&lt;br/&gt;
	5          |1          |NULL&lt;/p&gt;

&lt;p&gt;	5 rows selected&lt;/p&gt;

&lt;p&gt;It seems that changing the definition of &quot;t1&quot; (by creating a new trigger, adding a new column, etc) caused the update statement inside the trigger &quot;tr1&quot; to be invalidated and later recompiled. I suspect that the first time the update statement is compiled table &quot;t1&quot; does not have a trigger &quot;tr1&quot; and therefore the update statement does not fire triggers (UpdateResultSet with deferred = false). When the update statement is recompiled (after changes in the definition of the table), the table &quot;t1&quot; does have a trigger &quot;tr1&quot; and the update statement fires triggers (deferred = true).&lt;/p&gt;</comment>
                            <comment id="12420354" author="deepa" created="Wed, 12 Jul 2006 00:52:11 +0100"  >&lt;p&gt;Thanks Fernanda for sharing your thoughts on this. I have a slightly different understanding of the following statement:&lt;/p&gt;

&lt;p&gt;&quot;If a row-level trigger RLT is considered as executed for some row R in SC, then RLT is not subsequently executed for R.&quot;&lt;/p&gt;

&lt;p&gt;I had read both these statements together and thought &quot;(in a given trigger execution context)&quot; implicitly applies to row-level triggers too.&lt;/p&gt;

&lt;p&gt;&quot;&lt;br/&gt;
A statement-level trigger that is considered as executed for a state change SC (in a given trigger execution context) is not subsequently executed for SC.&lt;br/&gt;
If a row-level trigger RLT is considered as executed for some row R in SC, then RLT is not subsequently executed for R.&lt;br/&gt;
&quot;&lt;/p&gt;

&lt;p&gt;To me, it looked like a SC is tied to a TEC. So I had interpreted it as: &lt;br/&gt;
&quot;If a row-level trigger RLT is considered as executed for some row R in SC (in a given trigger execution context), then RLT is not subsequently executed for R.&quot; &lt;/p&gt;

&lt;p&gt;Is this the right interpretation? If yes, I think the same row-level trigger can be executed more than once for the same row from different TECs. It can be executed only once for the same row from the same TEC.&lt;/p&gt;</comment>
                            <comment id="12428581" author="yipng" created="Thu, 17 Aug 2006 07:01:37 +0100"  >&lt;p&gt;This issue seems to be related to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1652&quot; title=&quot;Update trigger updating the same rows as the original update does not  throw an exception ERROR 54038: &amp;quot;Maximum depth of nested triggers was exceeded&amp;quot; as it should&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1652&quot;&gt;&lt;del&gt;DERBY-1652&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13698987" author="kmarsden" created="Wed, 3 Jul 2013 15:07:19 +0100"  >&lt;p&gt;Verified this still reproduces on trunk 10.11 with attached repro.sql&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12347431">DERBY-1652</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12590633" name="repro.sql" size="606" author="kmarsden" created="Wed, 3 Jul 2013 15:07:19 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 3 May 2006 02:52:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22402</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0i1b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36740</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>