<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:38:50 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2107/DERBY-2107.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2107] Move page latching out of the lock manager</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2107</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Latching of pages could be done more efficiently locally in store than in the lock manager. See the discussion here: &lt;a href=&quot;http://thread.gmane.org/gmane.comp.apache.db.derby.devel/33135&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://thread.gmane.org/gmane.comp.apache.db.derby.devel/33135&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12356332">DERBY-2107</key>
            <summary>Move page latching out of the lock manager</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Wed, 22 Nov 2006 08:25:58 +0000</created>
                <updated>Mon, 29 Jun 2009 15:23:22 +0100</updated>
                            <resolved>Thu, 26 Apr 2007 08:21:50 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Services</component>
                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12452300" author="knutanders" created="Thu, 23 Nov 2006 18:20:20 +0000"  >&lt;p&gt;Here&apos;s a first patch (derby-2107-1a.diff) which implements latching&lt;br/&gt;
locally in the page objects. Description of the changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BasePage.java:&lt;/li&gt;
	&lt;li&gt;removed all traces of Latch and Lockable&lt;/li&gt;
	&lt;li&gt;setExclusive() and setExclusiveNoWait() now set the variables that&lt;br/&gt;
    the page is locked (owner and preLatch) directly, instead of going&lt;br/&gt;
    through the lock manager. wait() and notifyAll() are used to&lt;br/&gt;
    coordinate with releaseExclusive().&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The rest of the patch affects code that is only called from the unit&lt;br/&gt;
tests for store. I think this is too much complexity for code that is&lt;br/&gt;
never used outside the tests, but I&apos;m just trying to preserve the old&lt;br/&gt;
behaviour for now.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LockingPolicy.java:&lt;/li&gt;
	&lt;li&gt;the lockRecordForRead() and lockRecordForWrite() methods that&lt;br/&gt;
      took a Latch object was changed to take a Transaction object, a&lt;br/&gt;
      Page object and a ContainerHandle object. This was needed in&lt;br/&gt;
      order to be able to unlatch the latched page in case a row lock&lt;br/&gt;
      couldn&apos;t be obtained immediately.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;NoLocking.java, RowLocking1.java:&lt;/li&gt;
	&lt;li&gt;change the signatures as in LockingPolicy. No implementation&lt;br/&gt;
      changes needed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RowLocking2.java, RowLocking3.java:&lt;/li&gt;
	&lt;li&gt;change the signatures as in LockingPolicy.&lt;/li&gt;
	&lt;li&gt;instead of calling the LockFactory.lockObject() method which&lt;br/&gt;
      took a Latch parameter, the logic needed to be inlined. First&lt;br/&gt;
      try to get a row lock without waiting. If it couldn&apos;t be&lt;br/&gt;
      obtained immediately, unlatch the page, wait for the lock, and&lt;br/&gt;
      re-latch the page when the lock has been obtained.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Page.java (interface) and BasePage.java (implementation):&lt;/li&gt;
	&lt;li&gt;added new method Page.latch(ContainerHandle) (which only&lt;br/&gt;
      forwards the call to the protected setExclusive() method) which&lt;br/&gt;
      was needed for the RowLocking* classes to be able to re-latch the&lt;br/&gt;
      page. (Page already has an unlatch() method.)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I have run derbyall and the JUnit tests successfully. I sometimes see&lt;br/&gt;
an error in lang/compressTable.sql, but the same diff has been seen in&lt;br/&gt;
the nightlies too&lt;br/&gt;
(&lt;a href=&quot;http://dbtg.thresher.com/derby/test/trunk15/jvm1.5/testing/testlog/Linux-2.6.9-34.ELsmp_x86_64-x86_64/476241-derbylang_diff.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dbtg.thresher.com/derby/test/trunk15/jvm1.5/testing/testlog/Linux-2.6.9-34.ELsmp_x86_64-x86_64/476241-derbylang_diff.txt&lt;/a&gt;).&lt;br/&gt;
However, I do see it more frequently with the patch, probably because&lt;br/&gt;
of changes in the timing.&lt;/p&gt;

&lt;p&gt;This patch does not address deadlock detection issues, or timeout when&lt;br/&gt;
the latch cannot be obtained. I think those issues would be better to&lt;br/&gt;
address in follow-up patches (incremental development, right?).&lt;/p&gt;

&lt;p&gt;Reviews and comments would be greatly appreciated! Thanks.&lt;/p&gt;</comment>
                            <comment id="12456463" author="djd" created="Thu, 7 Dec 2006 16:03:11 +0000"  >&lt;p&gt;Couple of comments jump out from an initial look at the patch.&lt;/p&gt;

&lt;p&gt;The first may have been an existing issue:&lt;/p&gt;

&lt;p&gt;1) The field nestedLatch is used under synchronization when gettting the latch, but not when releasing the latch.&lt;/p&gt;

&lt;p&gt;2) In setExclusive() if an attempt is made to double latch the page it will suceed, even when the transaction is not in abort. This seems to conflict the comments in the method. This will not be handled correctly on the unlatch as the first unlatch will completely clear the latch leaving the caller thinking it has the latch when it doesn&apos;t.&lt;br/&gt;
Not sure what the old code did in this situation.&lt;/p&gt;</comment>
                            <comment id="12456466" author="djd" created="Thu, 7 Dec 2006 16:04:31 +0000"  >&lt;p&gt;On more, I think there has to be synchronization in isLatched() based upon previous discussions on the list about Java&apos;s memory model.&lt;/p&gt;</comment>
                            <comment id="12456770" author="knutanders" created="Fri, 8 Dec 2006 11:10:37 +0000"  >&lt;p&gt;&amp;gt; The first may have been an existing issue:&lt;br/&gt;
&amp;gt; 1) The field nestedLatch is used under synchronization when gettting&lt;br/&gt;
&amp;gt; the latch, but not when releasing the latch.&lt;/p&gt;

&lt;p&gt;Thanks, I will move that into the synchronized block.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) In setExclusive() if an attempt is made to double latch the page&lt;br/&gt;
&amp;gt; it will suceed, even when the transaction is not in abort. This&lt;br/&gt;
&amp;gt; seems to conflict the comments in the method. This will not be&lt;br/&gt;
&amp;gt; handled correctly on the unlatch as the first unlatch will&lt;br/&gt;
&amp;gt; completely clear the latch leaving the caller thinking it has the&lt;br/&gt;
&amp;gt; latch when it doesn&apos;t.  Not sure what the old code did in this&lt;br/&gt;
&amp;gt; situation.&lt;/p&gt;

&lt;p&gt;Not sure I understand this comment. If one tries to double latch a&lt;br/&gt;
page, and the transaction is not in abort, it will wait until the page&lt;br/&gt;
is unlatched, just as any other transaction. This is the same as the&lt;br/&gt;
old code did, except that the old code would probably detect the&lt;br/&gt;
deadlock after derby.locks.deadlockTimeout seconds. Am I missing&lt;br/&gt;
something?&lt;/p&gt;

&lt;p&gt;&amp;gt; On more, I think there has to be synchronization in isLatched()&lt;br/&gt;
&amp;gt; based upon previous discussions on the list about Java&apos;s memory&lt;br/&gt;
&amp;gt; model.&lt;/p&gt;

&lt;p&gt;Yes, I believe that&apos;s true. Will fix that too.&lt;/p&gt;</comment>
                            <comment id="12456903" author="djd" created="Fri, 8 Dec 2006 16:25:37 +0000"  >&lt;p&gt;Sorry, I was wrong on issue 2), got confused mentally walking through the code.&lt;/p&gt;

&lt;p&gt;Though the patch does remove this comment: for the situation in 2)&lt;/p&gt;

&lt;p&gt;   // just deadlock out ...&lt;/p&gt;

&lt;p&gt;I think some comment should exist there indicating that the code path is not expected or maybe even throw an exception there.&lt;br/&gt;
The patched code I think is confusing without some form of comment as to what is expected.&lt;/p&gt;</comment>
                            <comment id="12458478" author="knutanders" created="Thu, 14 Dec 2006 13:40:37 +0000"  >&lt;p&gt;Attaching a new version of the patch to address Dan&apos;s comments. (Improved synchronization and comments.)&lt;/p&gt;

&lt;p&gt;If this patch is accepted, I plan to post follow-up patches to address these issues:&lt;br/&gt;
  1) There should be some kind of timeout mechanism so that possible deadlocks are reported.&lt;br/&gt;
  2) Tool for debugging of deadlocks. A VTI which shows all latches in the system was suggested on derby-dev.&lt;br/&gt;
  3) The extra complexity to handle latches should be removed from the lock manager.&lt;/p&gt;</comment>
                            <comment id="12458593" author="djd" created="Thu, 14 Dec 2006 20:06:48 +0000"  >&lt;p&gt;Even though the parameters have changed for LockingPolicy.lockRecordForRead its description has not, nor in any of its implementations. Since you have been working in the code and understanding it, it would be good to record knowledge you gained, and improve the java doc comments if they are wrong.&lt;/p&gt;

&lt;p&gt;I think this comment for LockingPoliy.lockRecordForRead needs to be augmented (&amp;amp; I think this is an existing problem ).&lt;br/&gt;
  &quot;Lock a record while holding a page latch.&quot;&lt;br/&gt;
I think the api should state that the latch might be dropped and re-acquired during this call.&lt;/p&gt;

&lt;p&gt;The ordering &amp;amp; timing of latching/locking has changed in the row locking implementations of LockingPolicy.lockRecordForRead.&lt;br/&gt;
Can you share with the list any evaluation you perfomed of the effect on this, in terms of race conditions between multiple threads?&lt;/p&gt;


</comment>
                            <comment id="12458608" author="mikem" created="Thu, 14 Dec 2006 21:25:27 +0000"  >&lt;p&gt;I am reviewing the changes, and do agree with Dan&apos;s comments.  Have you thought about the implecations of order change?  I am &lt;br/&gt;
trying to think if it is a problem.  So far what I am looking at is:&lt;/p&gt;

&lt;p&gt;1) With your new implementation a waiting lock now requires 2 trips to the lock manager rather than the previous 1 trip.&lt;br/&gt;
      This was one of the reasons to put latching in the lock manager in the first place, so that the queuing of the waiting&lt;br/&gt;
       lock could be handled once rather than twice.&lt;/p&gt;

&lt;p&gt;2) I believe existing implementation the logic for a lock that waits is something like:&lt;br/&gt;
     o get exclusive access to lock manager&lt;br/&gt;
     o queue waiting lock while holding latch&lt;br/&gt;
     o release latch&lt;br/&gt;
     o release exclusive access to lock manager&lt;br/&gt;
     o wait for grant of lock&lt;br/&gt;
     o reclaim latch&lt;/p&gt;

&lt;p&gt;     new order is &lt;br/&gt;
     o release latch&lt;br/&gt;
     o get exclusive access to lock manager&lt;br/&gt;
     o queue waiting lock  WITHOUT latch&lt;br/&gt;
     o release exclusive access to lock manager&lt;br/&gt;
     o wait for grant of lock&lt;br/&gt;
     o reclaim latch&lt;/p&gt;


&lt;p&gt;The case I am trying to work out in my mind is the space reclamation thread.  It gets latches on pages and &lt;br/&gt;
loops through rows requesting zero duration locks to see if it can purge a row from a page.  In the first case&lt;br/&gt;
the row we are requesting a lock on will never be purged as it is not possible for the reclaim space thread to&lt;br/&gt;
get a latch on a the page and purge the row we are waiting for a lock on (the lock request for an update lock&lt;br/&gt;
will fail because of our wait).  In the second case It can sneak in between the release of the latch and queue&lt;br/&gt;
of the waiting lock.&lt;/p&gt;

&lt;p&gt;It might not be good that the system depends on this behavior, but at this point I don&apos;t know how much or if &lt;br/&gt;
other code would need to change to support this lock/latch behavior change.  i&lt;/p&gt;</comment>
                            <comment id="12458609" author="djd" created="Thu, 14 Dec 2006 21:32:20 +0000"  >&lt;p&gt;I think the patch has a severe problem, here is code from RowLocking3.lockRecordForRead (one of several instances):&lt;/p&gt;

&lt;p&gt;        // Couldn&apos;t get the lock immediately. Release the latch while waiting.&lt;br/&gt;
        latchedPage.unlatch();&lt;/p&gt;

&lt;p&gt;        lf.lockObject(&lt;br/&gt;
            t.getCompatibilitySpace(), t, record, qualifier,&lt;br/&gt;
            C_LockFactory.TIMED_WAIT);&lt;/p&gt;

&lt;p&gt;        latchedPage.latch(containerHandle);&lt;/p&gt;

&lt;p&gt;The api for Page.unlatch() states that the reference used to unlatch the page must be not used (i.e. must be set to null) after calling unlatch().&lt;br/&gt;
This code uses the reference used to unlatch the page after the lock call &lt;b&gt;and&lt;/b&gt; the caller of this method will continue to use the same Page reference.&lt;br/&gt;
The reference must be set to null after an unlatch because once the page in unlatched there is no guarantee that the page will remain in cache or that the reference will continue to describe the same page.&lt;/p&gt;

&lt;p&gt;So this code clearly uses a Page reference after it has been unlatched and thus can be referring to a wrong page or an invlaid page.&lt;/p&gt;

&lt;p&gt;I think it works with the current code because a a latch on the Page is a super-set of a lock manager Latch, I&apos;ll add more on that in a separate comment.&lt;/p&gt;</comment>
                            <comment id="12458611" author="mikem" created="Thu, 14 Dec 2006 21:45:44 +0000"  >&lt;p&gt;Dan is absolutely right about the unlatch() call.  Once unlatch call is made the page is free to be thrown out of the cache and be replaced by a different page, from possibly a different table, different page size ....&lt;br/&gt;
Once you call unlatch you have to reload the buffer manager, the problem is that you can&apos;t do it in the interfaces you have&lt;br/&gt;
as the callers still have the old reference.  The btree code does this in it&apos;s code that manages latch/lock outside of &lt;br/&gt;
lockmanager.  For btree it was necessary as after you gave up latch while waiting on lock the row could move off the &lt;br/&gt;
original page.&lt;/p&gt;

&lt;p&gt;For heap rows don&apos;t ever move off the page.  They can &quot;disappear&quot; in the purge case described above, and in the &lt;br/&gt;
offline compress case which is handled by a table level lock.&lt;/p&gt;
</comment>
                            <comment id="12458612" author="mikem" created="Thu, 14 Dec 2006 21:48:16 +0000"  >&lt;p&gt;Dan, do you think the current code is actually allowing another thread to latch the page while the lock is waiting?  I used to think it did, but definitely got confused reading through the lock manager.&lt;/p&gt;</comment>
                            <comment id="12458623" author="djd" created="Thu, 14 Dec 2006 22:12:06 +0000"  >&lt;p&gt;This is how the page latching currently works in the case when the lock manager releases its latch:&lt;/p&gt;

&lt;p&gt;Page page = ContainerHandle.getPage(long)&lt;br/&gt;
     results in a call to FileContainer.getPage(...)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;page is found in the cache and kept (ie. usage count in the cache will be bumped)&lt;/li&gt;
	&lt;li&gt;page is latched&lt;/li&gt;
	&lt;li&gt;BasePage.lockEvent() is called  to assign page ownership&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    at this point the page is held in the cache and is latched, ContainerHandle.getPage states Page reference will remain valid until unlatch() is called. Note that multiple threads can execute this code concurrently, all will have the same valid reference to the Page, one will have it latched, the others will be queued in the lock manager waiting for the latch to be released.&lt;/p&gt;

&lt;p&gt;LockingPolicy.lockRecordForRead() called to get a row lock passing the Page&apos;s latch, assume the lock can not be obtained.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Page&apos;s latch will be released&lt;/li&gt;
	&lt;li&gt;BasePage.unlockEvent() is called to clear page ownership&lt;/li&gt;
	&lt;li&gt;caller will wait for row lock&lt;br/&gt;
      at this point the caller still has not returned the Page object to the cache, so from the cache&apos;s point of view the&lt;br/&gt;
      Page is still in use and so cannot be re-used with another identity.&lt;/li&gt;
	&lt;li&gt;next waiter is be granted the Page latch and continue their work, ie. their  ContainerHandle.getPage(long) returns with the same valid Page reference.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;at some point the caller gets its row lock and then attempts to get the latch, queuing behind any other waiters&lt;/li&gt;
	&lt;li&gt;once the latch is granted (following the row lock) the lockRecordForRead() call returns&lt;br/&gt;
       BasePage.lockEvent() is called to assign page ownership&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Caller reads and/or modifies page&lt;/p&gt;

&lt;p&gt;Page.unlatch() is called to indicate the caller is finished with the page&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;page is unlatched&lt;/li&gt;
	&lt;li&gt;BasePage.unlockEvent()  is called to clear page ownership&lt;/li&gt;
	&lt;li&gt;Page is released from the cache (ie. usage count decremented)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;At this point in time the caller cannot trust the Page reference any more, since its usage count in the cache could have dropped to zero and some other thread could have replaced it.&lt;/p&gt;

</comment>
                            <comment id="12458628" author="djd" created="Thu, 14 Dec 2006 22:30:29 +0000"  >&lt;p&gt;I think the patch hit this issue due to some existing confusion with naming in the existing code.&lt;/p&gt;

&lt;p&gt;The top level api currently is&lt;br/&gt;
   Page page = ContainerHandle.getPage()&lt;br/&gt;
   // do stuff with page&lt;br/&gt;
   page.unlatch();&lt;/p&gt;

&lt;p&gt;and then internally the page code uses a lock manager Latch to help manage its lifecyle.&lt;/p&gt;

&lt;p&gt;As latching moves into the page implementation it might make sense to rename concepts to maintain a clear separation.&lt;/p&gt;

&lt;p&gt;Maybe the top-level api could use release() instead of unlatch() and leave the latch concept for the code Knut has implemented.&lt;br/&gt;
Obviously changing/cleaning up the comments in the various .getPage() calls to reflect the new terminology would be required as well.&lt;/p&gt;
</comment>
                            <comment id="12458736" author="knutanders" created="Fri, 15 Dec 2006 10:51:31 +0000"  >&lt;p&gt;Thanks for your comments, Dan and Mike. It seems to me that all your&lt;br/&gt;
comments are about the variants of LockingPolicy.lockRecordForRead and&lt;br/&gt;
lockRecordForWrite that take a latch parameter. I share your concern&lt;br/&gt;
for the correctness of this code, and that was actually what made me&lt;br/&gt;
start the thread which is archived at&lt;br/&gt;
&amp;lt;URL:&lt;a href=&quot;http://thread.gmane.org/gmane.comp.apache.db.derby.devel/33135&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://thread.gmane.org/gmane.comp.apache.db.derby.devel/33135&lt;/a&gt;&amp;gt;.&lt;/p&gt;

&lt;p&gt;But this brings us back to the original question in that thread: When&lt;br/&gt;
is this code used? I believe it was concluded that those methods were&lt;br/&gt;
only called when the locking policy was NoLocking, in which case they&lt;br/&gt;
are no-ops. (With the exception of some unit tests which invoke the&lt;br/&gt;
methods of the Page interface directly.)&lt;/p&gt;

&lt;p&gt;If it is true that this code is never used, perhaps we should consider&lt;br/&gt;
removing it?&lt;/p&gt;</comment>
                            <comment id="12459725" author="djd" created="Tue, 19 Dec 2006 18:52:51 +0000"  >&lt;p&gt;Maybe that&apos;s the best approach, leave latching as it is for now, and first work on removing the possibly unused code. Then hopefully after the cleanup your proposed latch code will work as it will no longer have the potential of being released while holding a lock.&lt;/p&gt;</comment>
                            <comment id="12459846" author="knutanders" created="Wed, 20 Dec 2006 07:53:33 +0000"  >&lt;p&gt;Will do that. I have logged &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2197&quot; title=&quot;Remove unused code for locking rows while holding a latch&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2197&quot;&gt;&lt;del&gt;DERBY-2197&lt;/del&gt;&lt;/a&gt; to track those changes.&lt;/p&gt;</comment>
                            <comment id="12465695" author="knutanders" created="Thu, 18 Jan 2007 09:38:09 +0000"  >&lt;p&gt;Attached new patch (1c). The only change from 1b is that the unused code is not touched (because it has been removed from trunk). The new patch only touches BasePage.java. Please review.&lt;/p&gt;</comment>
                            <comment id="12468291" author="knutanders" created="Mon, 29 Jan 2007 14:22:20 +0000"  >&lt;p&gt;Does anyone plan to review the latest version of the patch?&lt;/p&gt;</comment>
                            <comment id="12469431" author="knutanders" created="Thu, 1 Feb 2007 13:58:41 +0000"  >&lt;p&gt;If there are no more comments, I plan to commit 1c after the weekend.&lt;/p&gt;</comment>
                            <comment id="12469575" author="tsuresh" created="Thu, 1 Feb 2007 20:33:12 +0000"  >&lt;p&gt;Hi Knut, &lt;/p&gt;

&lt;p&gt;I reviewed the latest patch, it looks good to be committed.  I have only &lt;br/&gt;
few minor questions/comments :&lt;/p&gt;

&lt;p&gt;1) you may want to fix comments in void setExclusive(BaseContainerHandle requester)&lt;/p&gt;

&lt;p&gt;// because i) lock manager might assume latches are exclusive for&lt;br/&gt;
// performance, ii) &lt;/p&gt;


&lt;p&gt;2)&lt;br/&gt;
+			owner = requester;&lt;br/&gt;
+			requester.addObserver(this);&lt;/p&gt;

&lt;p&gt;It took me some time to understand how this works on an error cases&lt;br/&gt;
scenarios, basically what happens if a thread after acquiring a latch &lt;br/&gt;
errors out for some reason. My understanding is  you are handling &lt;br/&gt;
this cases by by putting the pages on the  container observer list&lt;br/&gt;
(requester.addObserver(this)). Please add some comments to why this page &lt;br/&gt;
is added to observer list. &lt;/p&gt;


&lt;p&gt;3) &lt;br/&gt;
+&lt;br/&gt;
+ // just deadlock out if a transaction tries to double latch the&lt;br/&gt;
+ // page while not in abort&lt;/p&gt;

&lt;p&gt;comment is good. But , you may want to add some assertion or throw &lt;br/&gt;
error here, if this case should not happen.&lt;/p&gt;


&lt;p&gt;4) &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Debugging, print slot table information */&lt;/li&gt;
	&lt;li&gt;protected String slotTableToString()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I don&apos;t know why you removed this method in this patch.  May &lt;br/&gt;
be this method is not used or not required. Occasionally I found&lt;br/&gt;
these type of methods useful while debugging a page corruption&lt;br/&gt;
to quickly dump page info with some minor changes to the code. &lt;/p&gt;


&lt;p&gt;5)&lt;br/&gt;
+		// Expect notify from releaseExclusive().&lt;br/&gt;
+		wait();&lt;/p&gt;

&lt;p&gt;I was wondering , if the wait() method here should be time based to catch&lt;br/&gt;
any infinite waits due to incorrectly missing release latch calls or you think&lt;br/&gt;
it is going to be be unnecessarily expensive ?&lt;/p&gt;


&lt;p&gt;5) Did you find the existing unit tests already tests latching methods ? or&lt;br/&gt;
you are planning to write one. &lt;/p&gt;


&lt;p&gt;Thanks&lt;br/&gt;
-suresh&lt;/p&gt;</comment>
                            <comment id="12469712" author="knutanders" created="Fri, 2 Feb 2007 10:47:37 +0000"  >&lt;p&gt;Thanks for reviewing the patch, Suresh! Those are great&lt;br/&gt;
suggestions. I&apos;ll try to answer your questions below.&lt;/p&gt;

&lt;p&gt;1) I&apos;ll update that comment.&lt;/p&gt;

&lt;p&gt;2) I don&apos;t think the observer is used to clean up and release the&lt;br/&gt;
latch if the thread errors out, but rather to release the latch if the&lt;br/&gt;
container is closed/dropped while the page is latched. I&apos;m not sure&lt;br/&gt;
why we need special handling of this situation (I&apos;d assume that the&lt;br/&gt;
general error handling/clean-up would work for this situation too),&lt;br/&gt;
but I wanted to keep as much of the old behaviour as possible. I&apos;ll&lt;br/&gt;
see if I can improve the comments.&lt;/p&gt;

&lt;p&gt;If a thread errors out after the page has been latched, I think it is&lt;br/&gt;
the the caller&apos;s responsibility to detect the error and unlatch the&lt;br/&gt;
page. At least, it seems like this is the pattern being used in the&lt;br/&gt;
code:&lt;/p&gt;

&lt;p&gt;  Page page = getPage(...);&lt;br/&gt;
  try &lt;/p&gt;
{
      // do something with page
  }
&lt;p&gt; finally &lt;/p&gt;
{
      page.unlatch();
  }

&lt;p&gt;3 and 5) I agree that the wait() should be timed. I was planning to&lt;br/&gt;
change it in a followup patch if that sounds OK. What would be a&lt;br/&gt;
reasonable timeout value? Ten seconds?&lt;/p&gt;

&lt;p&gt;With a timed wait, there would be no need for an assert/error in the&lt;br/&gt;
double-latching case, since we would get a timeout error in the end.&lt;/p&gt;

&lt;p&gt;4) I&apos;ll keep the method (it is unused, but as you said it could be&lt;br/&gt;
useful for debugging).&lt;/p&gt;

&lt;p&gt;6) There are some unit tests which check that the pages are correctly&lt;br/&gt;
latched (for instance T_RawStoreFactory, T_Recovery, T_b2i). However,&lt;br/&gt;
I don&apos;t think any of them test that the latching behaves correctly&lt;br/&gt;
when there&apos;s a conflict. I&apos;ll see if I can write some tests for&lt;br/&gt;
that. Would it be OK to add such tests in a separate followup patch?&lt;/p&gt;</comment>
                            <comment id="12469760" author="knutanders" created="Fri, 2 Feb 2007 14:01:52 +0000"  >&lt;p&gt;New revision of the patch (1d) with the following changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;updated comments as suggested&lt;/li&gt;
	&lt;li&gt;doesn&apos;t delete slotTableToString()&lt;/li&gt;
	&lt;li&gt;factored out some common code from setExclusive()/setExclusiveNoWait() into a new method called preLatch()&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12469806" author="djd" created="Fri, 2 Feb 2007 17:15:53 +0000"  >&lt;p&gt;I agree that any timeout on the latch wait should be a separate patch &amp;amp; I believe a separate Jira issue.&lt;br/&gt;
For one thing it will change the api to use patches, e.g. this logic would no longer work:&lt;/p&gt;

&lt;p&gt;  Page page = getPage(...);&lt;br/&gt;
  try &lt;/p&gt;
{
      // do something with page
  }
&lt;p&gt; finally &lt;/p&gt;
{
      page.unlatch();
  }

&lt;p&gt;as obviously with a timeout there would be a path through the finally block where the page is not latched.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I see the value of a timeout though, though that discussion should be in any new issue.&lt;/p&gt;</comment>
                            <comment id="12469855" author="tsuresh" created="Fri, 2 Feb 2007 20:16:17 +0000"  >&lt;p&gt;Please commit the patch, you can address tests or comment fixes in &lt;br/&gt;
separate patches. &lt;/p&gt;

&lt;p&gt;&amp;gt;2) I don&apos;t think the observer is used to clean up and release the&lt;br/&gt;
l&amp;gt; atch if the thread errors out, but rather to release the latch if the&lt;br/&gt;
&amp;gt;&amp;gt;container is closed/dropped while the page is latched. I&lt;/p&gt;

&lt;p&gt;My understanding of this is  cleanup will tigger abort, or save point &lt;br/&gt;
rollback which will trigger the close of container handle, which inturn &lt;br/&gt;
will trigger release of latches on pages that are on the observer &lt;br/&gt;
list of the container handle. &lt;/p&gt;

&lt;p&gt;I agree with you in most of the cases you will find latches being &lt;br/&gt;
released in  the finally{ } blocks. I belive it is good practice too. But &lt;br/&gt;
I am not sure that is case all  throughout the code, in any case i belive&lt;br/&gt;
cleanup will release the latches, if there are any of those missing cases. &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 3 and 5) I agree that the wait() should be timed. I was planning to&lt;br/&gt;
&amp;gt;change it in a followup patch if that sounds OK. What would be a&lt;br/&gt;
&amp;gt;reasonable timeout value? Ten seconds? &lt;br/&gt;
&amp;gt;&amp;gt; &lt;/p&gt;

&lt;p&gt;I was thinking more like 1/2 hour or more,   mainly to get some kind of stack/information  &lt;br/&gt;
and avoid the complaints that the derby  freezes forever without any clues, especially &lt;br/&gt;
when derby is embedded in another application;   It may be the case that there are no &lt;br/&gt;
bugs and will  not be any bugs in this area, so it may not be worth adding a timeout. &lt;br/&gt;
I agree with Dan, this  can be addressed as separate issue, if needed. &lt;/p&gt;

&lt;p&gt;-suresh&lt;/p&gt;</comment>
                            <comment id="12470066" author="knutanders" created="Sun, 4 Feb 2007 16:44:57 +0000"  >&lt;p&gt;Thanks! Committed derby-2107-1d.diff with revision 503440.&lt;/p&gt;</comment>
                            <comment id="12470067" author="knutanders" created="Sun, 4 Feb 2007 17:08:42 +0000"  >&lt;p&gt;&amp;gt; I agree that any timeout on the latch wait should be a separate&lt;br/&gt;
&amp;gt; patch &amp;amp; I believe a separate Jira issue.  For one thing it will&lt;br/&gt;
&amp;gt; change the api to use patches, e.g. this logic would no longer work:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  Page page = getPage(...);&lt;br/&gt;
&amp;gt;  try &lt;/p&gt;
{
&amp;gt;      // do something with page
&amp;gt;  }
&lt;p&gt; finally &lt;/p&gt;
{
&amp;gt;      page.unlatch();
&amp;gt;  }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt; as obviously with a timeout there would be a path through the&lt;br/&gt;
&amp;gt; finally block where the page is not latched.&lt;/p&gt;

&lt;p&gt;I don&apos;t think this will change since the call to getPage() is outside&lt;br/&gt;
the try block. The timeout exception will be thrown inside getPage()&lt;br/&gt;
and the reference to the page object won&apos;t be returned.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m not sure I see the value of a timeout though, though that&lt;br/&gt;
&amp;gt; discussion should be in any new issue.&lt;/p&gt;

&lt;p&gt;I&apos;ll file a new issue where we can discuss ways to report/debug&lt;br/&gt;
deadlocks.&lt;/p&gt;</comment>
                            <comment id="12470456" author="knutanders" created="Tue, 6 Feb 2007 06:27:32 +0000"  >&lt;p&gt;derby-2107-2a.diff removes the now unused latch methods from the lock manager. It also removes one test case from T_LockFactory which tests the methods. Derbyall and the JUnit tests passed.&lt;/p&gt;</comment>
                            <comment id="12470457" author="knutanders" created="Tue, 6 Feb 2007 06:29:59 +0000"  >&lt;p&gt;Reattaching 2a with &quot;grant license&quot; checked.&lt;/p&gt;</comment>
                            <comment id="12470853" author="knutanders" created="Wed, 7 Feb 2007 08:46:21 +0000"  >&lt;p&gt;Committed 2a with revision 504462.&lt;/p&gt;</comment>
                            <comment id="12472249" author="knutanders" created="Mon, 12 Feb 2007 10:56:34 +0000"  >&lt;p&gt;Patch 3a adds a test case to T_RawStoreFactory. The new test case tests that multiple requests for a page block each other out.&lt;/p&gt;</comment>
                            <comment id="12472563" author="knutanders" created="Tue, 13 Feb 2007 08:11:57 +0000"  >&lt;p&gt;Committed 3a with revision 506899.&lt;/p&gt;</comment>
                            <comment id="12491646" author="knutanders" created="Wed, 25 Apr 2007 14:48:59 +0100"  >&lt;p&gt;Attaching a patch (4a) to address comment #3 from Suresh. It adds an assert which fails when a transaction attempts to latch the same page twice. Also needed to update the test case added by the 3a patch, since it now throws an assert failure instead of hanging when using a sane build. All the tests ran cleanly.&lt;/p&gt;</comment>
                            <comment id="12491897" author="knutanders" created="Thu, 26 Apr 2007 08:21:50 +0100"  >&lt;p&gt;Committed 4a with revision 532636.&lt;br/&gt;
I think all comments have been addressed (either by fixing them or by opening new JIRAs), so I&apos;m resolving the issue.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12359093">DERBY-2197</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12361995">DERBY-2291</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12361996">DERBY-2292</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12345570" name="derby-2107-1a.diff" size="22780" author="knutanders" created="Thu, 23 Nov 2006 18:20:20 +0000"/>
                            <attachment id="12345571" name="derby-2107-1a.stat" size="491" author="knutanders" created="Thu, 23 Nov 2006 18:20:20 +0000"/>
                            <attachment id="12347186" name="derby-2107-1b.diff" size="23120" author="knutanders" created="Thu, 14 Dec 2006 13:40:37 +0000"/>
                            <attachment id="12349143" name="derby-2107-1c.diff" size="9700" author="knutanders" created="Thu, 18 Jan 2007 09:31:21 +0000"/>
                            <attachment id="12349144" name="derby-2107-1c.stat" size="70" author="knutanders" created="Thu, 18 Jan 2007 09:31:21 +0000"/>
                            <attachment id="12350215" name="derby-2107-1d.diff" size="10134" author="knutanders" created="Fri, 2 Feb 2007 14:01:51 +0000"/>
                            <attachment id="12350408" name="derby-2107-2a.diff" size="8879" author="knutanders" created="Tue, 6 Feb 2007 06:29:59 +0000"/>
                            <attachment id="12350406" name="derby-2107-2a.diff" size="8879" author="knutanders" created="Tue, 6 Feb 2007 06:27:32 +0000"/>
                            <attachment id="12350409" name="derby-2107-2a.stat" size="227" author="knutanders" created="Tue, 6 Feb 2007 06:29:59 +0000"/>
                            <attachment id="12350407" name="derby-2107-2a.stat" size="227" author="knutanders" created="Tue, 6 Feb 2007 06:27:32 +0000"/>
                            <attachment id="12350920" name="derby-2107-3a.diff" size="3343" author="knutanders" created="Mon, 12 Feb 2007 10:56:34 +0000"/>
                            <attachment id="12350921" name="derby-2107-3a.stat" size="155" author="knutanders" created="Mon, 12 Feb 2007 10:56:34 +0000"/>
                            <attachment id="12356239" name="derby-2107-4a.diff" size="1565" author="knutanders" created="Wed, 25 Apr 2007 14:48:59 +0100"/>
                            <attachment id="12356240" name="derby-2107-4a.stat" size="142" author="knutanders" created="Wed, 25 Apr 2007 14:48:59 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>14.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 7 Dec 2006 16:03:11 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30276</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0wlj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39099</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>