<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:27:45 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4416/DERBY-4416.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4416] Handle comparison of two constants as a boolean constant</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4416</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;In the lack of the boolean data type, Derby forces you to use expressions like 1=1 and 1&amp;lt;&amp;gt;1 to express true and false. Generated SQL statements also tend to use such expressions, and so does Derby in its own meta-data queries.&lt;/p&gt;

&lt;p&gt;Derby has many useful optimizations for boolean true/false. For instance, ProjectRestrictNode and PredicateList are able to eliminate predicates, and in some cases the entire ProjectRestrictNode, if the predicate contains constant true or false values. However, during parsing and compilation, expressions like 1=1 are not rewritten to TRUE, and we don&apos;t get any benefit from the boolean optimization code. This leads to more complex, and possibly less efficient, byte code being generated for the statements.&lt;/p&gt;

&lt;p&gt;Also, boolean constants are assigned a selectivity of 0.0 (false) or 1.0 (true), since they will always match no rows when false and all rows when true. The expression 1=1 does however get it&apos;s selectivity from the = operator, which means that it&apos;ll be 0.1. The same selectivity is assigned to 1=0. Other operators have different selectivity, so 2&amp;lt;3 has the selectivity 0.33, even though the actual selectivity of the expression is the same as 1=1 and TRUE, namely 1.0.&lt;/p&gt;

&lt;p&gt;This leads to oddities like the optimizer choosing a different plan when you change 2&amp;lt;3 to 1=1 in a WHERE clause. See &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/db-derby-user/200909.mbox/%3c25531166.post@talk.nabble.com%3e&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/db-derby-user/200909.mbox/%3c25531166.post@talk.nabble.com%3e&lt;/a&gt; for an example of that.&lt;/p&gt;

&lt;p&gt;If we could go through the query tree and replace occurrences of comparisons between constant values with a boolean constant at bind time, such queries would end up with simpler byte code, and the selectivity passed to the optimizer would be more accurate, possibly resulting in a better plan being chosen.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12438687">DERBY-4416</key>
            <summary>Handle comparison of two constants as a boolean constant</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Wed, 21 Oct 2009 12:41:07 +0100</created>
                <updated>Tue, 2 Feb 2010 09:56:16 +0000</updated>
                            <resolved>Mon, 16 Nov 2009 09:55:58 +0000</resolved>
                                    <version>10.5.3.0</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12768189" author="knutanders" created="Wed, 21 Oct 2009 13:10:46 +0100"  >&lt;p&gt;Attached is a patch (not for commit) that I&apos;ve experimented with. It adds a visitor that replaces (some) expressions that are guaranteed to evaluate to true or false with a boolean constant node. This visitor is used on the WHERE clauses and HAVING clauses from SelectNode.normExpressions() and on the ON clauses in JoinNode.normExpressions().&lt;/p&gt;

&lt;p&gt;I&apos;ve seen that for instance this statement&lt;/p&gt;

&lt;p&gt;  SELECT * FROM T WHERE 1=1&lt;/p&gt;

&lt;p&gt;is translated into a ProjectRestrictResultSet on top of a table scan without the patch, and simply to a table scan with the patch.&lt;/p&gt;

&lt;p&gt;I tested it with suites.All and derbyall, and saw three failures:&lt;/p&gt;

&lt;p&gt;1) lang/outerjoin.sql: Changed query plans. Looks like the expected changes, in that some ProjectRestrictResultSets are eliminated, but will have to check to be sure.&lt;/p&gt;

&lt;p&gt;2) lang/specjPlans.sql: Changed query plans. These also look benign, but will have to check.&lt;/p&gt;

&lt;p&gt;3) lang/logop.sql: Query that previously failed now succeeds and returns no rows. Expected output is below, and judging by the comment in the test, it looks as if the empty result that was actually supposed to be the expected one. The reason why it stops failing, is that (1=2) is rewritten to false and PredicateList.restorePredicates() is therefore able eliminate the other half of the AND node (2147483647 + 10 = 2) that causes integer overflow.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; &amp;#8211; ... and false and ... should get resolved to false&lt;br/&gt;
select x from s where 2147483647 + 10 = 2 and (1=2);&lt;br/&gt;
ERROR 22003: The resulting value is outside the range for the data type INTEGER.&lt;/p&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; &amp;#8211; ... and false and ... should get resolved to false&lt;br/&gt;
select x from s where 2147483647 + 10 = 2 and (1=2);&lt;br/&gt;
X          &lt;br/&gt;
-----------&lt;/p&gt;</comment>
                            <comment id="12768213" author="knutanders" created="Wed, 21 Oct 2009 13:54:32 +0100"  >&lt;p&gt;The visitor and the methods in the patch could probably have more general names, since they could be used to all sorts of expression-to-constant transformations.&lt;/p&gt;

&lt;p&gt;So instead of the ValueNode.getBooleanEquivalent() method in the current patch, we could have a ValueNode.getConstantEquivalent(). The override in BinaryRelationalOperatorNode would return a boolean constant like in the patch. In addition, possibly as part of separate issues later, overrides could be added to other nodes, like in BinaryArithmeticOperatorNode to return the result of arithmetic operations as a (non-boolean) constant.&lt;/p&gt;

&lt;p&gt;Currently, since the accept() methods call visit() on the parent node before the children, the patch is not able to fully rewrite expressions like ((1=1) = (3=3)) to true (well, this expression was probably disallowed by the recent &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-887&quot; title=&quot;Select statement returns wrong number of rows if you compare an integer column with a boolean expression in the where clause&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-887&quot;&gt;&lt;del&gt;DERBY-887&lt;/del&gt;&lt;/a&gt; commit, but it will probably be allowed again when the boolean data type is reintroduced). The rewriting stops at (true = true). Making BinaryRelationalOperatorNode.getBooleanEquivalent() call getBooleanEquivalent() on the left operand and the right operand before checking whether they are constant nodes, should fix this, I think.&lt;/p&gt;

&lt;p&gt;Adding an override in IsNullNode to handle IS NULL/IS NOT NULL should be fairly trivial too, I think.&lt;/p&gt;</comment>
                            <comment id="12768266" author="bryanpendleton" created="Wed, 21 Oct 2009 15:54:46 +0100"  >&lt;p&gt;I&apos;m not sure I understand your more-general idea.&lt;/p&gt;

&lt;p&gt;Would it mean that, e.g.,&lt;/p&gt;

&lt;p&gt;    select 1+2 from t&lt;/p&gt;

&lt;p&gt;would be transformed into&lt;/p&gt;

&lt;p&gt;   select 3 from t&lt;/p&gt;</comment>
                            <comment id="12768274" author="knutanders" created="Wed, 21 Oct 2009 16:10:49 +0100"  >&lt;p&gt;Yes, that&apos;s the idea. Or 3+1&amp;lt;4  --&amp;gt; 4&amp;lt;4 ---&amp;gt; false. I&apos;m not sure if we want to do it, but I thought that since it would be possible using the same mechanism, there&apos;s no reason to have &quot;boolean&quot; in the method/class names.&lt;/p&gt;</comment>
                            <comment id="12777555" author="knutanders" created="Fri, 13 Nov 2009 16:48:52 +0000"  >&lt;p&gt;Here&apos;s an updated patch with the visitor renamed to ConstantExpressionVisitor, the method in ValueNode renamed to evaluateConstantExpression(), and with updated comments.&lt;/p&gt;

&lt;p&gt;Description of the other changes from the previous patch:&lt;/p&gt;

&lt;p&gt;1) The invocation of the visitor is moved to DMLStatementNode.optimizeStatement(). The previous patch called it from SelectNode and JoinNode on WHERE/HAVING/ON clauses. As mentioned by Bryan, this transformation can be useful in other parts of the tree as well (as seen in VALUES 1+3, although evaluation of arithmetic operations hasn&apos;t implemented). I think it&apos;s cleaner to have the invocation at one single location. Also, since there might be sub-queries inside WHERE clauses, the old patch might traverse some parts of the tree many times.&lt;/p&gt;

&lt;p&gt;The visitor now walks the entire query tree between the preprocessing phase and the optimization phase. Doing it as late as possible is advantageous because then other simplifications (like the NOT elimination performed in preprocess()) increase the chances of finding expressions with a know value, but it should be performed before optimization so that the optimizer can take advantage of the more accurate selectivity predictions.&lt;/p&gt;

&lt;p&gt;2) JoinNode: Made acceptChildren() call accept() on joinPredicates. The previous patch visited the JoinNode a little earlier, when the ON clause was still represented by joinClause, whereas this patch visits the JoinNode after the predicates have been moved to joinPredicates. There are also other children of JoinNode that are not visited, but I didn&apos;t do anything with them for now.&lt;/p&gt;

&lt;p&gt;3) BinaryRelationalOperatorNode: Added rewriting for less-than and less-equals, which were forgotten in the previous patch.&lt;/p&gt;

&lt;p&gt;4) logop.out: Accept that a statement that used to fail with arithmetic overflow now succeeds because the arithmetic isn&apos;t performed at runtime. The statement that fails is&lt;br/&gt;
&amp;gt; select x from s where 2147483647 + 10 = 2 and (1=2);&lt;br/&gt;
whereas this almost identical one is expected to succeed&lt;br/&gt;
&amp;gt; select x from s where (1=2) and 2147483647 + 10 = 2;&lt;br/&gt;
I&apos;m not aware of anything in the SQL standard that requires us to evaluate the arithmetic expression first, so I think it&apos;s equally OK to pass the first statement as it is to pass the second statement. The comments in the test also indicate this.&lt;/p&gt;

&lt;p&gt;4) specjPlans.out: Removed unneeded ProjectRestrictResultSet from two of the query plans (they were there to enforce the restriction 1=1).&lt;/p&gt;

&lt;p&gt;5) outerjoin.out: Updated query plan from nested loop join to hash join in a join with 1=1 in the ON clause. New plan looks OK and the results are still correct. The plan probably changed because 1=1 and TRUE have different (estimated) selectivity.&lt;/p&gt;

&lt;p&gt;I haven&apos;t run all the regression tests on the latest revision of the patch. Will report back when I have the results.&lt;/p&gt;</comment>
                            <comment id="12777613" author="knutanders" created="Fri, 13 Nov 2009 19:19:07 +0000"  >&lt;p&gt;All the regression tests ran cleanly.&lt;/p&gt;</comment>
                            <comment id="12778279" author="knutanders" created="Mon, 16 Nov 2009 09:55:58 +0000"  >&lt;p&gt;Committed revision 880693.&lt;/p&gt;

&lt;p&gt;I&apos;m marking the issue as resolved. If there are other expressions that we want to rewrite using this mechanism, we can file separate issues for those improvements.&lt;/p&gt;</comment>
                            <comment id="12778356" author="dagw" created="Mon, 16 Nov 2009 14:33:31 +0000"  >&lt;p&gt;Thanks for this patch, Knut. The placement of accept for the new visitor in SMLStatementNode looks good.&lt;br/&gt;
+1.&lt;/p&gt;

&lt;p&gt;Nit: in BinaryRelationalOperatorNode#evaluateConstantExpressions&apos;s&lt;br/&gt;
Javadoc, the text in the @return tag is slightly misleading:&lt;/p&gt;

&lt;p&gt;@return a Boolean constant if the result of the operator is known, or&lt;br/&gt;
        the operator node otherwise&lt;/p&gt;

&lt;p&gt;One could be led to believe is is returning a Boolean object; I like better the phrasing you use for&lt;br/&gt;
#newBool: &quot;@return a node representing a Boolean constant&quot;.&lt;/p&gt;

</comment>
                            <comment id="12778370" author="knutanders" created="Mon, 16 Nov 2009 15:22:29 +0000"  >&lt;p&gt;Thanks, Dag! I changed the wording to this in revision 880791:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;@return a node representing a Boolean constant if the result of the&lt;/li&gt;
	&lt;li&gt;operator is known; otherwise, this operator node&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12438910">DERBY-4421</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12424863" name="d4416-1a.diff" size="17158" author="knutanders" created="Fri, 13 Nov 2009 16:48:52 +0000"/>
                            <attachment id="12424864" name="d4416-1a.stat" size="623" author="knutanders" created="Fri, 13 Nov 2009 16:48:52 +0000"/>
                            <attachment id="12422800" name="replaceExpressions.diff" size="5926" author="knutanders" created="Wed, 21 Oct 2009 13:10:46 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 21 Oct 2009 14:54:46 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31229</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0r8v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38232</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>