<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:27:10 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4565/DERBY-4565.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4565] Create concurrency test to stress sequence generators.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4565</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Create a concurrency test to find bottlenecks and bugs in sequence generators.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12457305">DERBY-4565</key>
            <summary>Create concurrency test to stress sequence generators.</summary>
                <type id="3" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/task.png">Task</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rhillegas">Rick Hillegas</assignee>
                                    <reporter username="rhillegas">Rick Hillegas</reporter>
                        <labels>
                    </labels>
                <created>Wed, 24 Feb 2010 16:28:00 +0000</created>
                <updated>Fri, 7 Oct 2011 18:26:25 +0100</updated>
                            <resolved>Fri, 16 Apr 2010 14:08:46 +0100</resolved>
                                    <version>10.6.1.0</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                    <component>Test</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12840736" author="rhillegas" created="Wed, 3 Mar 2010 17:11:40 +0000"  >&lt;p&gt;Attaching derby-4565-01-ad-firstRev.diff. This is a test client for testing the concurrency of sequence generators.&lt;/p&gt;

&lt;p&gt;Using this test client I am able to force a pile-up on a sequence generator with the following command. The pile-up consists of &quot;too much contention&quot; exceptions whenever the sequence generator is queried for a new value:&lt;/p&gt;

&lt;p&gt;java org.apache.derbyTesting.perf.clients.Runner \&lt;br/&gt;
    -driver org.apache.derby.jdbc.EmbeddedDriver \&lt;br/&gt;
    -init \&lt;br/&gt;
    -load seq_gen \&lt;br/&gt;
    -load_opts debugging=0,numberOfGenerators=5,tablesPerGenerator=10,insertsPerTransaction=100 \&lt;br/&gt;
    -gen b2b \&lt;br/&gt;
    -threads 10 \&lt;/p&gt;

&lt;p&gt;Increasing the size of the pre-allocated sequence range does not prevent pile-ups. I can eliminate the pile-ups by increasing the number of times that a frustrated thread retries its attempt to grab a sequence number. That is, the pile-ups disappear when I set SequenceUpdater.RETRY_COUNT = 100. With that modification, I still see occasional &quot;too much contention&quot; exceptions, but the threads do not pile-up.&lt;/p&gt;

&lt;p&gt;A variation on this solution, might be to eliminate the RETRY_COUNT and, instead, to let the threads keep retrying until they have exceeded the derby.locks.waitTimeout period. Or there may be some other modification we could make to the sequence generator.&lt;/p&gt;

&lt;p&gt;This patch does not change the behavior of Derby. The patch simply introduces a new concurrency test.&lt;/p&gt;

&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M      java/testing/org/apache/derbyTesting/perf/clients/Runner.java&lt;br/&gt;
A      java/testing/org/apache/derbyTesting/perf/clients/SequenceGeneratorConcurrency.java&lt;/p&gt;

&lt;p&gt;The new client for testing concurrent use of sequence generators.&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;M      java/testing/org/apache/derbyTesting/perf/clients/PoissonLoadGenerator.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/Client.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/SingleRecordSelectClient.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/BankTransactionClient.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/SingleRecordUpdateClient.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/IndexJoinClient.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/GroupByClient.java&lt;br/&gt;
M      java/testing/org/apache/derbyTesting/perf/clients/BackToBackLoadGenerator.java&lt;/p&gt;

&lt;p&gt;Added a new reporting method so that, on exit, the load generators can print client-specific statistics.&lt;/p&gt;</comment>
                            <comment id="12841184" author="knutanders" created="Thu, 4 Mar 2010 11:04:54 +0000"  >&lt;p&gt;Hi Rick,&lt;/p&gt;

&lt;p&gt;I see these &quot;too much contention&quot; exceptions too. The current retry count of 3 sounds somewhat low, as I can easily imagine that one threads comes in and grabs the entire pre-allocated range of 5 values (somewhat low too?) before the other thread manages to get one. I don&apos;t know how many times in a row it is reasonable to expect this to happen, so although I agree that it should be increased, I have no idea how much we should increase it.&lt;/p&gt;

&lt;p&gt;It would of course be better if we could get rid of the &quot;too much contention&quot; exceptions altogether. The need for allocating a new range is detected inside a synchronized block in SequenceGenerator. Is it possible to make that code only let one thread go ahead and allocate a new range, and tell the other threads to hold their horses until that thread has done its work?&lt;/p&gt;

&lt;p&gt;I added some extra instrumentation in SequenceUpdater.updateCurrentValueOnDisk() and saw that it quite frequently needed to do the update in the main transaction instead of the nested transaction. In fact, this happened more often than the &quot;too much contention&quot; exceptions in my environment. These could also contribute to the thread pile-up you saw. If we managed to get SequenceGenerator limit the number of threads that attempted to update the same generator on disk, it would also reduce the chances of having to escalate the update operation to the main transaction.&lt;/p&gt;</comment>
                            <comment id="12841197" author="knutanders" created="Thu, 4 Mar 2010 11:42:11 +0000"  >&lt;p&gt;In addition to the &quot;too much contention&quot; errors, my logs show that the test also frequently fails with lock timeouts or deadlocks when I run the test using the configuration specified above, probably because the update of the system table is escalated to the main transaction. Here&apos;s a sample deadlock:&lt;/p&gt;

&lt;p&gt;Failed Statement is: insert into t_3_5( a ) values ( next value for seq_3 )&lt;br/&gt;
ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:&lt;br/&gt;
Lock : ROW, SYSSEQUENCES, (1,10)&lt;br/&gt;
  Waiting XID : &lt;/p&gt;
{37240, X} , TEST, insert into t_3_5( a ) values ( next value for seq_3 )&lt;br/&gt;
  Granted XID : {36715, X} &lt;br/&gt;
Lock : ROW, SYSSEQUENCES, (1,8)&lt;br/&gt;
  Waiting XID : {36715, X} , TEST, insert into t_1_9( a ) values ( next value for seq_1 )&lt;br/&gt;
  Granted XID : {37240, X}
&lt;p&gt; &lt;br/&gt;
. The selected victim is XID : 37240.&lt;/p&gt;</comment>
                            <comment id="12841492" author="rhillegas" created="Thu, 4 Mar 2010 20:18:54 +0000"  >&lt;p&gt;Thanks for the analysis, Knut. I will ponder your suggestions. In the meantime, I have checked in the new concurrency test at subversion revision 919159.&lt;/p&gt;</comment>
                            <comment id="12842815" author="rhillegas" created="Mon, 8 Mar 2010 21:06:55 +0000"  >&lt;p&gt;Attaching derby-4565-02-aa-useWaitTimeout.diff. This patch eliminates the retry count. Instead, we now use the lock wait timeout to bound how long we attempt to allocate a new cache of sequence numbers. That is, we raise a &quot;too much contention&quot; exception only if we have looped longer than the timeout set by derby.locks.waitTimeout.&lt;/p&gt;

&lt;p&gt;With this change, the &quot;too much contention&quot; exceptions disappear. Throughput on the experiment now comes in around 350 tx/sec.&lt;/p&gt;

&lt;p&gt;A couple other experiments:&lt;/p&gt;

&lt;p&gt;1) I let only one session at a time try to allocate another block of sequence numbers in its main execution transaction. This reduced throughput to 100 tx/sec.&lt;/p&gt;

&lt;p&gt;2) I tried various larger sizes for the number of values pre-allocated in one gulp. The maximum chunk I tried was 10,000,000 values. This pushed the throughput up to 480 tx/sec. Most of that boost was achieved by raising the chunk size to only 100 values.&lt;/p&gt;

&lt;p&gt;3) I do see sessions failing to get a write lock immediately, and then falling back on their execution transactions.&lt;/p&gt;

&lt;p&gt;4) I don&apos;t see any lock timeout exceptions in the test case itself. That is, the test does not log any of these exceptions. Knut, is it possible that what you are seeing are the subtransactions failing to get a write lock immediately and then falling back on the parent transaction?&lt;/p&gt;

&lt;p&gt;I think this patch by itself is incremental improvement:&lt;/p&gt;

&lt;p&gt;A) It eliminates the &quot;too much contention&quot; exceptions.&lt;/p&gt;

&lt;p&gt;B) It makes it possible to adjust a pre-existing Derby knob in order to tune the concurrency of sequence generators.&lt;/p&gt;


&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;---------------&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/services/locks/LockTable.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/services/locks/LockSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/services/locks/ConcurrentLockSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/services/locks/AbstractPool.java&lt;br/&gt;
M      java/engine/org/apache/derby/iapi/services/locks/LockFactory.java&lt;/p&gt;

&lt;p&gt;Add a new method to the LockFactory so that the factory can report what the lock wait timeout is.&lt;/p&gt;

&lt;p&gt;---------------&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java&lt;/p&gt;

&lt;p&gt;Use the lock wait timeout to bound the number of times that a session tries to pre-allocate a chunk of sequence numbers.&lt;/p&gt;</comment>
                            <comment id="12843030" author="knutanders" created="Tue, 9 Mar 2010 12:53:05 +0000"  >&lt;p&gt;&amp;gt; 4) I don&apos;t see any lock timeout exceptions in the test case&lt;br/&gt;
&amp;gt; itself. That is, the test does not log any of these exceptions.&lt;br/&gt;
&amp;gt; Knut, is it possible that what you are seeing are the&lt;br/&gt;
&amp;gt; subtransactions failing to get a write lock immediately and then&lt;br/&gt;
&amp;gt; falling back on the parent transaction?&lt;/p&gt;

&lt;p&gt;No, I do see actual failures. I made the debug code in the test print&lt;br/&gt;
the SQLState of all exceptions and filtered out all the &quot;too much&lt;br/&gt;
contention&quot; errors, and saw that the timeout and deadlock errors were&lt;br/&gt;
propagated all the way up to the test client.&lt;/p&gt;</comment>
                            <comment id="12843036" author="knutanders" created="Tue, 9 Mar 2010 13:16:12 +0000"  >&lt;p&gt;I agree that the 02 patch looks like an improvement. Let&apos;s hope no one will have to wait that long, since the waiting thread will burn lots of CPU cycles doing nothing in that case...&lt;/p&gt;

&lt;p&gt;One other possible improvement is to wait with setting startTime until after the first iteration has failed to get a sequence number. That way we don&apos;t have to call System.currentTimeMillis() in the common case where the number is available immediately. I&apos;m not sure how expensive the call to currentTimeMillis() is, though. It could be expensive if it requires a switch to kernel mode on some platforms, but I don&apos;t know, so it might not be worthwhile.&lt;/p&gt;</comment>
                            <comment id="12843190" author="rhillegas" created="Tue, 9 Mar 2010 16:47:52 +0000"  >&lt;p&gt;Attaching a second rev of the second patch: derby-4565-02-ab-useWaitTimeout.diff. This version makes a couple additional changes:&lt;/p&gt;

&lt;p&gt;1) Fixes an NPE raised by the special test implementation of SequenceUpdater.&lt;/p&gt;

&lt;p&gt;2) Only calls System.currentTimeMillis() if a retry is necessary, as Knut suggested.&lt;/p&gt;

&lt;p&gt;3) Makes the test client report all Throwables and not just SQLExceptions.&lt;/p&gt;

&lt;p&gt;I am still not seeing timeout and deadlock errors when I turn on debugging. That is, the following command runs cleanly without intercepting and printing any errors:&lt;/p&gt;

&lt;p&gt;runjava org.apache.derbyTesting.perf.clients.Runner \&lt;br/&gt;
    -driver org.apache.derby.jdbc.EmbeddedDriver \&lt;br/&gt;
    -init \&lt;br/&gt;
    -load seq_gen \&lt;br/&gt;
    -load_opts debugging=1,numberOfGenerators=5,tablesPerGenerator=10,insertsPerTransaction=100 \&lt;br/&gt;
    -gen b2b \&lt;br/&gt;
    -threads 10 \&lt;/p&gt;

&lt;p&gt;Knut, if you apply the patch and run the command above (without changing the code in the patch), do you still see timeouts and deadlocks?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="12843573" author="rhillegas" created="Wed, 10 Mar 2010 14:31:24 +0000"  >&lt;p&gt;Committed derby-4565-02-ab-useWaitTimeout.diff at subversion revision 921365.&lt;/p&gt;</comment>
                            <comment id="12843578" author="knutanders" created="Wed, 10 Mar 2010 14:58:39 +0000"  >&lt;p&gt;&amp;gt; Knut, if you apply the patch and run the command above (without changing the code in the patch), do you still see timeouts and deadlocks? &lt;/p&gt;

&lt;p&gt;I&apos;m currently having problems reproducing it even without the patch. Not sure what has changed in my environment, but I&apos;ll run some more experiments before I give up...&lt;/p&gt;</comment>
                            <comment id="12857454" author="rhillegas" created="Thu, 15 Apr 2010 19:10:29 +0100"  >&lt;p&gt;Attaching and committing derby-4565-03-aa-academicTest.diff. This changes the SequenceGeneratorConcurrency test, making it possible to run the test without any tables. This helps isolate sequence generator behavior from other concurrency bottlenecks.&lt;/p&gt;</comment>
                            <comment id="12857514" author="rhillegas" created="Thu, 15 Apr 2010 20:57:22 +0100"  >&lt;p&gt;Attaching derby-4565-xx-deoptimized.diff and derby-4565-throughput.html.&lt;/p&gt;

&lt;p&gt;1) derby-4565-xx-deoptimized.diff is a patch which removes the optimization that pre-allocates ranges of sequence numbers. After applying this patch, each execution of &quot;next value for&quot; causes the engine to update the corresponding SYSSEQUENCES row.&lt;/p&gt;

&lt;p&gt;2) derby-4565-throughput.html describes some experiments I ran to compare transaction throughput with and without the optimization.&lt;/p&gt;

&lt;p&gt;Here is a summary of my findings:&lt;/p&gt;

&lt;p&gt;i) The throughput gain is impressive if your transaction simply grabs one number from a single sequence generator. On my dual-core Macbook Pro, I saw a 305% throughput boost in this case.&lt;/p&gt;

&lt;p&gt;ii) The throughput gain is less impressive if your transaction grabs 100 numbers from a single sequence generator. In this case the optimization boosted throughput only by 30%.&lt;/p&gt;

&lt;p&gt;iii) The throughput gain can be even less impressive if your transaction grabs a sequence number and stuffs it into a table. Here the benefits of the optimization may be swamped by other contention in the engine. In the worst case which I measured, the optimization only boosted throughput by 14%.&lt;/p&gt;

&lt;p&gt;In short, the added complexity of the optimization may seem more or less justified depending on the nature of your workload.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12325742">DERBY-712</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12524309">DERBY-5427</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12440016">DERBY-4437</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12525736">DERBY-5445</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12441858" name="ASF.LICENSE.NOT.GRANTED--derby-4565-03-aa-academicTest.diff" size="5429" author="rhillegas" created="Thu, 15 Apr 2010 19:10:29 +0100"/>
                            <attachment id="12441867" name="ASF.LICENSE.NOT.GRANTED--derby-4565-throughput.html" size="2946" author="rhillegas" created="Thu, 15 Apr 2010 20:57:22 +0100"/>
                            <attachment id="12441866" name="ASF.LICENSE.NOT.GRANTED--derby-4565-xx-deoptimized.diff" size="3841" author="rhillegas" created="Thu, 15 Apr 2010 20:57:22 +0100"/>
                            <attachment id="12437751" name="derby-4565-01-ad-firstRev.diff" size="19781" author="rhillegas" created="Wed, 3 Mar 2010 17:11:40 +0000"/>
                            <attachment id="12438229" name="derby-4565-02-aa-useWaitTimeout.diff" size="6942" author="rhillegas" created="Mon, 8 Mar 2010 21:06:55 +0000"/>
                            <attachment id="12438297" name="derby-4565-02-ab-useWaitTimeout.diff" size="8888" author="rhillegas" created="Tue, 9 Mar 2010 16:47:52 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 4 Mar 2010 11:04:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31278</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0f7z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36284</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>