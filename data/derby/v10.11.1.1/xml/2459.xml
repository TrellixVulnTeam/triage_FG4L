<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:10:54 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2459/DERBY-2459.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2459] Ordering on a CASE-expression casues a NullPointerException when using a UNION</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2459</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When an order by clause involves a CASE-expression as seen below, a NullPointerException is thrown. The error only occurs when two select statements are combined in a union (or union all).&lt;/p&gt;

&lt;p&gt;select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
from A1 t1&lt;br/&gt;
left outer join B1 t2 ON t2.id = t1.ref&lt;/p&gt;

&lt;p&gt;union all&lt;/p&gt;

&lt;p&gt;select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
from A2 t1&lt;br/&gt;
left outer join B2 t2 ON t2.id = t1.ref&lt;/p&gt;

&lt;p&gt;order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;/p&gt;


&lt;p&gt;--Use the following statement to reproduce the problem:&lt;/p&gt;

&lt;p&gt;create table A1&lt;br/&gt;
(&lt;br/&gt;
   id char(1)&lt;br/&gt;
  ,value int&lt;br/&gt;
  ,ref char(1)&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;create table A2&lt;br/&gt;
(&lt;br/&gt;
   id char(1)&lt;br/&gt;
  ,value int&lt;br/&gt;
  ,ref char(1)&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;create table B1&lt;br/&gt;
(&lt;br/&gt;
   id char(1)&lt;br/&gt;
  ,value int&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;create table B2&lt;br/&gt;
(&lt;br/&gt;
   id char(1)&lt;br/&gt;
  ,value int&lt;br/&gt;
);&lt;/p&gt;


&lt;p&gt;insert into A1 (id, value, ref) values (&apos;a&apos;, 12, &apos;e&apos;);&lt;br/&gt;
insert into A1 (id, value, ref) values (&apos;b&apos;, 1, null);&lt;br/&gt;
insert into A2 (id, value, ref) values (&apos;c&apos;, 3, &apos;g&apos;);&lt;br/&gt;
insert into A2 (id, value, ref) values (&apos;d&apos;, 8, null);&lt;/p&gt;

&lt;p&gt;insert into B1 (id, value) values (&apos;e&apos;, 4);&lt;br/&gt;
insert into B1 (id, value) values (&apos;f&apos;, 2);&lt;br/&gt;
insert into B2 (id, value) values (&apos;g&apos;, 5);&lt;/p&gt;</description>
                <environment>Java 1.5.0_06-b05 on Linux Ubuntu 5.10. Derby version 10.2.2</environment>
        <key id="12365097">DERBY-2459</key>
            <summary>Ordering on a CASE-expression casues a NullPointerException when using a UNION</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="bryanpendleton">Bryan Pendleton</assignee>
                                    <reporter username="gramark">Lars Gr&#229;mark</reporter>
                        <labels>
                    </labels>
                <created>Fri, 16 Mar 2007 10:39:59 +0000</created>
                <updated>Fri, 21 Jan 2011 17:49:58 +0000</updated>
                            <resolved>Tue, 5 Jun 2007 17:05:26 +0100</resolved>
                                    <version>10.1.3.1</version>
                    <version>10.1.3.2</version>
                    <version>10.2.1.6</version>
                    <version>10.2.2.0</version>
                    <version>10.2.2.1</version>
                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12481648" author="army" created="Fri, 16 Mar 2007 15:22:17 +0000"  >&lt;p&gt;I confirmed this bug with ibm142 against the latest trunk with the following stack trace:&lt;/p&gt;

&lt;p&gt;java.lang.NullPointerException&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.OrderByColumn.bindOrderByColumn(OrderByColumn.java:179)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.OrderByList.bindOrderByColumns(OrderByList.java:153)&lt;br/&gt;
	at org.apache.derby.impl.sql.compile.CursorNode.bindStatement(CursorNode.java:266)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:314)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:741)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:567)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:516)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:320)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:516)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:369)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:267)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.go(Main.java:203)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:169)&lt;br/&gt;
	at org.apache.derby.impl.tools.ij.Main14.main(Main14.java:56)&lt;br/&gt;
	at org.apache.derby.tools.ij.main(ij.java:71)&lt;/p&gt;

&lt;p&gt;I also ran it against 10.1 and the same problem occurs there.  So I&apos;m adding a couple of entries to the &quot;Affects version&quot; box.&lt;/p&gt;

&lt;p&gt;Thank you for filing this issue, Lars.&lt;/p&gt;</comment>
                            <comment id="12498378" author="bryanpendleton" created="Wed, 23 May 2007 22:19:34 +0100"  >&lt;p&gt;In the problem description, the CASE expression in the ORDER BY clause&lt;br/&gt;
is identical to the CASE expression in each of the SELECT statements in&lt;br/&gt;
the child table expressions of the UNION.&lt;/p&gt;

&lt;p&gt;The problem also occurs even if the CASE expression in the ORDER BY clause&lt;br/&gt;
is unique: for example, replacing the ORDER BY clause in the description by&lt;br/&gt;
  order by CASE WHEN t2.value IS NOT NULL THEN t1.id ELSE t1.ref END&lt;br/&gt;
still results in the NPE.&lt;/p&gt;</comment>
                            <comment id="12498379" author="bryanpendleton" created="Wed, 23 May 2007 22:20:25 +0100"  >&lt;p&gt;This issue, like &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1861&quot; title=&quot;Column ordering ASSERT when combining column references and expressions in same ORDER BY&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1861&quot;&gt;&lt;del&gt;DERBY-1861&lt;/del&gt;&lt;/a&gt;, involves &quot;pull up&quot; processing, so I&apos;m marking the two issues as related. &lt;/p&gt;</comment>
                            <comment id="12498387" author="bryanpendleton" created="Wed, 23 May 2007 22:37:18 +0100"  >&lt;p&gt;Here&apos;s a brief narrative description of how things end up going wrong:&lt;/p&gt;

&lt;p&gt;1) We are in CursorNode.bindStatement.&lt;br/&gt;
2) We perform &quot;pull up&quot; processing (see the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1861&quot; title=&quot;Column ordering ASSERT when combining column references and expressions in same ORDER BY&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1861&quot;&gt;&lt;del&gt;DERBY-1861&lt;/del&gt;&lt;/a&gt; writeup for background info)&lt;br/&gt;
to pull up the ORDER BY column into the result set, since the ORDER BY clause&lt;br/&gt;
neither specifies a simple column reference to a column already in the result set,&lt;br/&gt;
nor specifies a result column by column number. So we add a new virtual column&lt;br/&gt;
to the UnionNode&apos;s resultColumnList, causing it to have 3 columns.&lt;br/&gt;
3) Then CursorNode.bindStatement calls resultSet.bindResultColumns, which&lt;br/&gt;
ends up calling SetOperatorNode.buildRCL. This method simply discards the&lt;br/&gt;
resultColumnList from the UnionNode and replaces it by the resultColumnList of&lt;br/&gt;
the UnionNode&apos;s left child. This processing is intended to handle the situation&lt;br/&gt;
in which we had a SELECT * as one of the UnionNode&apos;s children, and the * has&lt;br/&gt;
now been replaced by the table&apos;s actual column list.&lt;/p&gt;

&lt;p&gt;But now the data structures are inconsistent: the OrderByColumn thinks that it&lt;br/&gt;
will be ResultColumn 3, but the UnionNode thinks that the ResultColumnList&lt;br/&gt;
has only 2 ResultColumns.&lt;/p&gt;

&lt;p&gt;A few steps later, CursorNode.bindStatement ends up calling OrderByColumn.&lt;br/&gt;
bindOrderByColumn, and it stumbles over the inconsistent data structures,&lt;br/&gt;
computes a NULL value for the resultColumn field of the OrderByColumn (since there&lt;br/&gt;
is no 3rd column in the ResultColumnList anymore), and gets a NPE.&lt;/p&gt;

&lt;p&gt;I&apos;ll have to think a bit more about how to fix this, but I wanted to get the&lt;br/&gt;
narrative description down to preserve it.&lt;/p&gt;</comment>
                            <comment id="12499195" author="bryanpendleton" created="Fri, 25 May 2007 19:24:14 +0100"  >&lt;p&gt;Three possible strategies to investigate, to start with:&lt;/p&gt;

&lt;p&gt;1) Defer pull-up processing to later in CursorNode.bindStatement,&lt;br/&gt;
as was discussed (but not implemented) in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1861&quot; title=&quot;Column ordering ASSERT when combining column references and expressions in same ORDER BY&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1861&quot;&gt;&lt;del&gt;DERBY-1861&lt;/del&gt;&lt;/a&gt;. As Army&lt;br/&gt;
noted in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1861&quot; title=&quot;Column ordering ASSERT when combining column references and expressions in same ORDER BY&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1861&quot;&gt;&lt;del&gt;DERBY-1861&lt;/del&gt;&lt;/a&gt;, it&apos;s not obvious why pull-up processing was&lt;br/&gt;
positioned so early in bind processing.&lt;br/&gt;
2) Modify pull-up processing so that when it pulls a result column&lt;br/&gt;
into the RCL of a UnionNode, it also pulls that column into the&lt;br/&gt;
UnionNode&apos;s children (possibly recursively?)&lt;br/&gt;
3) Modify SetOperatorNode.buildRCL so that, rather than entirely&lt;br/&gt;
replacing the UnionNode&apos;s RCL with its left child&apos;s, it instead&lt;br/&gt;
merges the two RCL&apos;s, retaining the pulled-up columns but&lt;br/&gt;
replacing the other columns with those of the left child.&lt;/p&gt;</comment>
                            <comment id="12499315" author="bryanpendleton" created="Sat, 26 May 2007 15:45:33 +0100"  >&lt;p&gt;Pursuing option #2 has advanced me to a point where I now get&lt;br/&gt;
through all of bind and optimize processing, and crash in generate&lt;br/&gt;
processing. I&apos;m not sure if this is still a problem with the basic data&lt;br/&gt;
structures, or if it&apos;s just the case that OrderByList.generate has never&lt;br/&gt;
been called with a CASE expression before. I suspect that I&apos;ve still&lt;br/&gt;
got a problem with bind processing, because the ColumnReference&lt;br/&gt;
information in the OrderByColumn seems to be wrong. I think the&lt;br/&gt;
ColRef in the ORDER BY&apos;s CASE statement didn&apos;t get bound to the&lt;br/&gt;
underlying result column properly. Here&apos;s a snip of the&lt;br/&gt;
new stack trace I&apos;m looking at:&lt;/p&gt;

&lt;p&gt;org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED sourceResultSetNumber expected to be &amp;gt;= 0 for T2.VALUE&lt;br/&gt;
    at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:162)&lt;br/&gt;
    at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:147)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.ColumnReference.generateExpression(ColumnReference.java:951)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.UnaryOperatorNode.generateExpression(UnaryOperatorNode.java:682)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.NotNode.generateExpression(NotNode.java:116)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.ConditionalNode.generateExpression(ConditionalNode.java:678)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.ResultColumn.generateExpression(ResultColumn.java:891)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.ResultColumnList.generateCore(ResultColumnList.java:1177)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generateMinion(ProjectRestrictNode.java:1515)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.ProjectRestrictNode.generate(ProjectRestrictNode.java:1302)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.UnionNode.generate(UnionNode.java:589)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.OrderByList.generate(OrderByList.java:402)&lt;br/&gt;
    at org.apache.derby.impl.sql.compile.OrderByNode.generate(OrderByNode.java:155)&lt;/p&gt;</comment>
                            <comment id="12499408" author="bryanpendleton" created="Sun, 27 May 2007 16:42:34 +0100"  >&lt;p&gt;I&apos;ve been staring at the SELECT statement for a while and found that I&apos;m&lt;br/&gt;
wholly confused by what it&apos;s supposed to mean. Here it is again, from the&lt;br/&gt;
original description:&lt;/p&gt;

&lt;p&gt;   select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
                from A1 t1 left outer join B1 t2 ON t2.id = t1.ref&lt;br/&gt;
union all&lt;br/&gt;
   select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
               from A2 t1 left outer join B2 t2 ON t2.id = t1.ref&lt;br/&gt;
order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END &lt;/p&gt;

&lt;p&gt;What is the ORDER BY supposed to apply to? I can see two possibilities:&lt;br/&gt;
1) It&apos;s supposed to order 1 or both of the intermediate SELECT statements. But&lt;br/&gt;
    that doesn&apos;t make any sense; the order of intermediate results is both&lt;br/&gt;
    irrelevant and undefined.&lt;br/&gt;
2) It&apos;s supposed to order the final results, those that come out of the UNION. But&lt;br/&gt;
    this is confusing to me, because by the time we get to the UNION, there aren&apos;t&lt;br/&gt;
    tables &quot;t1&quot; and &quot;t2&quot; anymore. Those tables have disappeared during the&lt;br/&gt;
    underlying SELECT join processing and all that&apos;s left at the time of the UNION&lt;br/&gt;
   processing is the collecting together of the rows from the child result sets.&lt;/p&gt;

&lt;p&gt;For the case expressions in the underlying SELECT statements, it&apos;s quite clear&lt;br/&gt;
what &quot;t2.value&quot; and &quot;t1.value&quot; are supposed to apply to, as there is a clear&lt;br/&gt;
definition of &quot;t2&quot; and &quot;t1&quot; in those clauses. But in the UNION part of the statement,&lt;br/&gt;
what do we mean by &quot;t2&quot; and &quot;t1&quot;?&lt;/p&gt;

&lt;p&gt;Is this statement supposed to be legal? If so, how does it work on other database&lt;br/&gt;
systems? Does anyone have access to another DBMS implementation to test&lt;br/&gt;
how this statement behaves there?&lt;/p&gt;</comment>
                            <comment id="12499411" author="bryanpendleton" created="Sun, 27 May 2007 17:23:21 +0100"  >&lt;p&gt;In the original statement, &quot;ORDER BY 2&quot; seems clear and&lt;br/&gt;
unambiguous. Furthermore, it works. That, at least, should&lt;br/&gt;
provide a workaround while we attempt to determine how the&lt;br/&gt;
ORDER BY CASE... form was intended to behave.&lt;/p&gt;</comment>
                            <comment id="12499430" author="bryanpendleton" created="Sun, 27 May 2007 19:52:48 +0100"  >&lt;p&gt;I don&apos;t know whether ORDER BY CASE ...&lt;br/&gt;
would be legal if the CASE expression mentioned only unqualified&lt;br/&gt;
column names which appeared in the left-most UNION child&apos;s result set.&lt;/p&gt;

&lt;p&gt;My opinion at this point is that the only things that should be legal for an&lt;br/&gt;
ORDER BY clause on a UNION is either simple unqualified column&lt;br/&gt;
references which refer to columns in the leftmost chlid&apos;s result set, or&lt;br/&gt;
column position numbers.&lt;/p&gt;

&lt;p&gt;I&apos;ll look into building a patch which implements those semantics.&lt;/p&gt;</comment>
                            <comment id="12499618" author="bryanpendleton" created="Mon, 28 May 2007 19:43:01 +0100"  >&lt;p&gt;Attached is rejectquery.diff, a patch proposal. This patch includes&lt;br/&gt;
a 2-line change to OrderByColumn to reject the query in the description.&lt;br/&gt;
The patch also includes a number of test cases which verify that the&lt;br/&gt;
query as stated fails as expected, some other similar queries are&lt;br/&gt;
rejected, but also that ORDER BY 2 can be used to order the rows correctly.&lt;/p&gt;

&lt;p&gt;Please let me know what you think of this patch.&lt;/p&gt;</comment>
                            <comment id="12499888" author="army" created="Tue, 29 May 2007 19:51:37 +0100"  >&lt;p&gt;&amp;gt; Is this statement supposed to be legal? If so, how does it work on other database systems? Does anyone&lt;br/&gt;
&amp;gt; have access to another DBMS implementation to test how this statement behaves there? &lt;/p&gt;

&lt;p&gt;I tried it out against DB2 v8 and it failed:&lt;/p&gt;

&lt;p&gt;  SQL0197N  A qualified column name is not allowed in the ORDER BY clause.&lt;br/&gt;
  SQLSTATE=42877&lt;/p&gt;

&lt;p&gt;When I replaced the ORDER BY clause with &quot;ORDER BY 2&quot;, it succeeded:&lt;/p&gt;

&lt;p&gt;ID 2&lt;br/&gt;
&amp;#8211; -----------&lt;br/&gt;
b            1&lt;br/&gt;
a            4&lt;br/&gt;
c            5&lt;br/&gt;
d            8&lt;/p&gt;

&lt;p&gt;  4 record(s) selected.&lt;/p&gt;

&lt;p&gt;&amp;gt; My opinion at this point is that the only things that should be legal for an ORDER BY clause on&lt;br/&gt;
&amp;gt; a UNION is either simple unqualified column references which refer to columns in the leftmost&lt;br/&gt;
&amp;gt; chlid&apos;s result set, or column position numbers. &lt;/p&gt;

&lt;p&gt;Seems at a glance to agree with the above results, for what it&apos;s worth.  That said, I wonder if it might be better to change the patch so that instead of throwing &quot;LANG_ORDER_BY_COLUMN_NOT_FOUND&quot;, we throw &quot;LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED&quot;...Or would it be too difficult to catch that specific scenario?  One thing that confuses me about the new test cases in your patch is the following:&lt;/p&gt;

&lt;p&gt;+ij&amp;gt; &amp;#8211; should fail, because the union&apos;s results can&apos;t be referenced this way&lt;br/&gt;
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref&lt;br/&gt;
+union all&lt;br/&gt;
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref&lt;br/&gt;
+order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END;&lt;br/&gt;
+ERROR 42X78: Column &apos;3&apos; is not in the result of the query expression.&lt;/p&gt;

&lt;p&gt;It&apos;s not immediately clear to me where &quot;Column &apos;3&apos;&quot; is coming from here?  Is that a pulled-up column?  If so, is a user going to be confused by this particular error message?&lt;/p&gt;

&lt;p&gt;Also, the following query does currently work and continues to work with your patch, which is good:&lt;/p&gt;

&lt;p&gt;  select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
  from A2 t1&lt;br/&gt;
    left outer join B2 t2 ON t2.id = t1.ref&lt;br/&gt;
  order by CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END &lt;/p&gt;

&lt;p&gt;Do you think it would be worth it to add this to the test cases in rejectquery.diff, just for sanity...?&lt;/p&gt;</comment>
                            <comment id="12499892" author="bryanpendleton" created="Tue, 29 May 2007 20:06:57 +0100"  >&lt;p&gt;Thanks Army for the review and suggestions! I agree that the current error&lt;br/&gt;
message is confusing, and I like your suggestion. I&apos;ll work on throwing a&lt;br/&gt;
better error message, and add the other test case you suggested, and&lt;br/&gt;
re-submit the patch anon.&lt;/p&gt;</comment>
                            <comment id="12500021" author="bryanpendleton" created="Wed, 30 May 2007 05:39:30 +0100"  >&lt;p&gt;rejectquery_v2.diff contains a new error message, hopefully&lt;br/&gt;
more helpful for this circumstance, and also adds an additional&lt;br/&gt;
test case to show that ORDER BY expressions are still valid&lt;br/&gt;
on simple SELECT statements, just not on SELECT UNIONs.&lt;/p&gt;</comment>
                            <comment id="12500185" author="army" created="Wed, 30 May 2007 17:33:31 +0100"  >&lt;p&gt;Thank you for the follow-up patch, Bryan.  Is there any reason you chose to use a new error message instead of the existing LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED (42877) error?  Is this just for the sake of clarity?&lt;/p&gt;

&lt;p&gt;Note that one of the test cases already returns 42877:&lt;/p&gt;

&lt;p&gt;+ij&amp;gt; &amp;#8211; should fail, because qualified column references can&apos;t refer to UNIONs&lt;br/&gt;
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
+from d2459_A1 t1 left outer join d2459_B1 t2 ON t2.id = t1.ref&lt;br/&gt;
+union all&lt;br/&gt;
+select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
+from d2459_A2 t1 left outer join d2459_B2 t2 ON t2.id = t1.ref&lt;br/&gt;
+order by t1.id;&lt;br/&gt;
+ERROR 42877: A qualified column name &apos;T1.ID&apos; is not allowed in the ORDER BY clause.&lt;/p&gt;

&lt;p&gt;which seems like an appropriate error message for the 42878 case, as well?  Of course, we&apos;ll also get this error if no qualified names are present:&lt;/p&gt;

&lt;p&gt;  select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
  from A1 t1&lt;br/&gt;
    left outer join B1 t2 ON t2.id = t1.ref&lt;/p&gt;

&lt;p&gt;  union all&lt;/p&gt;

&lt;p&gt;  select t1.id, CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END&lt;br/&gt;
  from A2 t1&lt;br/&gt;
    left outer join B2 t2 ON t2.id = t1.ref&lt;/p&gt;

&lt;p&gt;  order by CASE WHEN id IS NOT NULL THEN id ELSE 2 END &lt;/p&gt;

&lt;p&gt;so maybe 42877 isn&apos;t entirely appropriate either.  Hmm....&lt;/p&gt;

&lt;p&gt;I wonder if what we&apos;re trying to say here is that CASE statements as a whole are not allowed in an ORDER BY clause?  I.e. is there &lt;b&gt;any&lt;/b&gt; form of CASE statement in an ORDER that would (and should) actually work?  Or should we be throwing a more generic message saying something along the lines of &quot;Invalid ORDER BY expression.&quot;&lt;/p&gt;

&lt;p&gt;On a different note, I wonder if mentioning &quot;the target list of the first SELECT in the UNION&quot; is too implementation-specific.  This seems to correlate to the fact that Derby uses the RCL of the left child as the RCL of the UNION node.  But that&apos;s an implementation decision; from a user perspective I think we&apos;re just talking about the RCL of the UNION node itself.  As an example, take the following:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select i from tx1 union select j from tx2 order by i;&lt;br/&gt;
ERROR 42X78: Column &apos;I&apos; is not in the result of the query expression.&lt;/p&gt;

&lt;p&gt;In this case &quot;i&quot; is in fact &quot;an unqualified name referring to the target list of the first SELECT in the UNION&quot;--but the query still throws an error.  The reason is that the second SELECT has a different name, which means the RCL of the UNION has a generated name &quot;1&quot;.  So if the user wants to do an order by, s/he must specify the target column of the &lt;b&gt;UNION&lt;/b&gt;&apos;s RCL, which may or may not match the target list of the first SELECT in the UNION.&lt;br/&gt;
Sorry if all of this is being too picky; I&apos;m just sort of dumping my thoughts here.  I hope I&apos;m not discouraging or otherwise overwhelming you with this feedback.  When it comes down to it the error message that you have proposed is far better than an NPE, so if you just want to commit the patch as it is, I wouldn&apos;t complain...&lt;/p&gt;</comment>
                            <comment id="12500272" author="bryanpendleton" created="Thu, 31 May 2007 03:05:20 +0100"  >&lt;p&gt;Hi Army, thank you very much for continuing the discussion. I don&apos;t think this is&lt;br/&gt;
too picky; I think there is a lot to learn here.&lt;/p&gt;

&lt;p&gt;I didn&apos;t use 42877 as the error message because it required a column &quot;name&quot; as&lt;br/&gt;
an argument, and for&lt;br/&gt;
  ORDER BY CASE WHEN t2.value IS NOT NULL THEN t2.value ELSE t1.value END &lt;br/&gt;
I&apos;m not sure what to use as the &quot;name&quot;. At the point that the error is detected,&lt;br/&gt;
all we have is an OrderByColumn instance with a pointer to a ConditionalNode&lt;br/&gt;
instance which represents the entire CASE expression, and there is nothing like&lt;br/&gt;
a column name anywhere close at hand.&lt;/p&gt;

&lt;p&gt;I believe that with the current implementation, CASE expressions as a whole are&lt;br/&gt;
not allowed in the ORDER BY clause of a &lt;b&gt;UNION&lt;/b&gt; select. CASE expressions seem&lt;br/&gt;
to work correctly for a non-UNION select. I believe that Derby&apos;s current behavior&lt;br/&gt;
here is too restrictive; I think that there are valid CASE expressions for a UNION&lt;br/&gt;
select that &lt;b&gt;ought&lt;/b&gt; to work (such as the one you propose in your comment, which&lt;br/&gt;
uses only unqualified column references to valid columns in the UNION&apos;s target&lt;br/&gt;
list),  but the current implementation is lacking. I&apos;m not sure&lt;br/&gt;
how hard this would be to fix. For the time being, as you suggest, issuing a&lt;br/&gt;
comprehensible error message which reflects reality accurately seems far&lt;br/&gt;
preferable to crashing with an NPE.&lt;/p&gt;

&lt;p&gt;I am somewhat surprised at the results that you found for&lt;br/&gt;
   select i from tx1 union select j from tx2 order by i; &lt;br/&gt;
I expected that would work, which is why I worded the message that way.&lt;br/&gt;
But I can see the logic of the &quot;column names are present in the UNION only&lt;br/&gt;
if they match precisely in all UNION children&quot; behavior.&lt;/p&gt;

&lt;p&gt;You&apos;ve pointed out several excellent additional test cases for this area, so I think&lt;br/&gt;
the next step for me is to add more test cases to the patch, and to work on&lt;br/&gt;
re-wording the error message to try to more accurately describe the current&lt;br/&gt;
behavior and its restrictions. Let me give that a go.&lt;/p&gt;</comment>
                            <comment id="12500972" author="bryanpendleton" created="Sat, 2 Jun 2007 23:42:27 +0100"  >&lt;p&gt;Attached is rejectQuery_v3.diff:&lt;/p&gt;

&lt;p&gt;1) I updated the message to try to make it more clear that&lt;br/&gt;
the error involves an implementation restriction, not necessarily&lt;br/&gt;
a syntax error on the part of the user. &lt;/p&gt;

&lt;p&gt;2) I added a number of additional test cases, to try to explore&lt;br/&gt;
more areas of what is and isn&apos;t supported, including several&lt;br/&gt;
test cases suggested by Army in previous comments, and&lt;br/&gt;
several more related ones that occurred to me as I was thinking.&lt;/p&gt;

&lt;p&gt;My current feeling is that there is a definite implementation&lt;br/&gt;
restriction here: there are syntactically valid expressions that&lt;br/&gt;
which Derby does not currently support, due to the way that&lt;br/&gt;
the result set of the UNION node is managed.&lt;/p&gt;

&lt;p&gt;But I also feel that issuing a clear error message is preferable&lt;br/&gt;
to failing with an NPE, so I think that this patch is an improvement&lt;br/&gt;
over the current behavior.&lt;/p&gt;</comment>
                            <comment id="12501255" author="army" created="Mon, 4 Jun 2007 17:16:12 +0100"  >&lt;p&gt;The new error message looks good to me, and the extensive test cases are great.  Thank you for your patience with my feedback, Bryan.&lt;/p&gt;

&lt;p&gt;+1 to commit from me.&lt;/p&gt;</comment>
                            <comment id="12501603" author="bryanpendleton" created="Tue, 5 Jun 2007 17:05:26 +0100"  >&lt;p&gt;Thanks again for the reviews, Army! I committed the patch to&lt;br/&gt;
subversion as revision 544532. &lt;/p&gt;

&lt;p&gt;I think this change could be moved to prior release branches&lt;br/&gt;
in a straightforward fashion. However, I do not intend to do&lt;br/&gt;
that at this time.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12350104">DERBY-1861</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12358391" name="rejectquery.diff" size="8175" author="bryanpendleton" created="Mon, 28 May 2007 19:43:01 +0100"/>
                            <attachment id="12358503" name="rejectquery_v2.diff" size="9814" author="bryanpendleton" created="Wed, 30 May 2007 05:39:30 +0100"/>
                            <attachment id="12358761" name="rejectquery_v3.diff" size="17262" author="bryanpendleton" created="Sat, 2 Jun 2007 23:42:27 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 16 Mar 2007 15:22:17 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23062</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0mjj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37470</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>