<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:11:24 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-6214/DERBY-6214.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-6214] PreparedStatement.setObject(int, Object, Types.CLOB) fail with DerbyNet</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6214</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The issue is specific to the DerbyNet client driver, and doesn&apos;t seem to occur using embedded Derby.&lt;/p&gt;

&lt;p&gt; &quot;PreparedStatement.setObject(int, Object, Types.CLOB)&quot;. It seems to be a problem updating a CLOB column with a parameterized value using the DerbyNet client driver, and if the update SQL ends up updating more than one row. I attached a simple test case that just uses JDBC to reproduce the error. The exception looks like this:&lt;/p&gt;

&lt;p&gt;org.apache.derby.client.am.BatchUpdateException: Non-atomic batch failure.  The batch was submitted, but at least one exception occurred on an individual member of the batch. Use getNextException() to retrieve the exceptions for specific batched elements.&lt;br/&gt;
    at org.apache.derby.client.am.Agent.endBatchedReadChain(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.am.PreparedStatement.executeBatchRequestX(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.am.PreparedStatement.executeBatchX(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.am.PreparedStatement.executeBatch(Unknown Source)&lt;br/&gt;
    ...&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Error for batch element #0: An unexpected exception was thrown&lt;br/&gt;
    at org.apache.derby.client.am.Statement.completeExecute(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.net.NetStatementReply.parseEXCSQLSTTreply(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.net.NetStatementReply.readExecute(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.net.StatementReply.readExecute(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.net.NetPreparedStatement.readExecute_(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.am.PreparedStatement.readExecute(Unknown Source)&lt;br/&gt;
    ... 4 more&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Error for batch element #0: Java exception: &apos;Stream has already been read and end-of-file reached and cannot be re-used.: java.io.EOFException&apos;.&lt;br/&gt;
    at org.apache.derby.client.am.SqlException.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
    at org.apache.derby.client.am.SqlException.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
    ... 10 more&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12646245">DERBY-6214</key>
            <summary>PreparedStatement.setObject(int, Object, Types.CLOB) fail with DerbyNet</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="rqu">Rong Qu</reporter>
                        <labels>
                    </labels>
                <created>Mon, 6 May 2013 17:59:52 +0100</created>
                <updated>Wed, 5 Mar 2014 22:08:44 +0000</updated>
                                            <version>10.8.3.0</version>
                    <version>10.9.1.0</version>
                                                    <component>SQL</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="13649961" author="kmarsden" created="Mon, 6 May 2013 19:34:47 +0100"  >&lt;p&gt;Here is a revised reproduction which separates out the setup sql from the java. &lt;/p&gt;

&lt;p&gt;Commented out in the java program is a workaround which is to use setString rather than setObject.&lt;/p&gt;

&lt;p&gt; // Work around. setString works.&lt;br/&gt;
	    //ps.setString(1,&quot;Modified CLOB value 2!!!!!!!!!!&quot;); //2005);&lt;/p&gt;

&lt;p&gt;To run:&lt;/p&gt;

&lt;p&gt;java org.apace.derby.drda.NetworkServerControl start &amp;amp;&lt;/p&gt;

&lt;p&gt;java org.apache.derby.tools.ij Derby6214_setup.sql&lt;/p&gt;

&lt;p&gt; $java Derby6214&lt;br/&gt;
Exception in thread &quot;main&quot; org.apache.derby.client.am.BatchUpdateException: Non-atomic batch failure.  The batch was sub&lt;br/&gt;
mitted, but at least one exception occurred on an individual member of the batch. Use getNextException() to retrieve the&lt;br/&gt;
 exceptions for specific batched elements.&lt;br/&gt;
        at org.apache.derby.client.am.Agent.endBatchedReadChain(Agent.java:270)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.executeBatchRequestX(PreparedStatement.java:2359)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.executeBatchX(PreparedStatement.java:2192)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.executeBatch(PreparedStatement.java:1651)&lt;br/&gt;
        at Derby6214.main(Derby6214.java:29)&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Error for batch element #0: An unexpected exception was thrown&lt;br/&gt;
        at org.apache.derby.client.am.Statement.completeExecute(Statement.java:1604)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementReply.parseEXCSQLSTTreply(NetStatementReply.java:322)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementReply.readExecute(NetStatementReply.java:71)&lt;br/&gt;
        at org.apache.derby.client.net.StatementReply.readExecute(StatementReply.java:55)&lt;br/&gt;
        at org.apache.derby.client.net.NetPreparedStatement.readExecute_(NetPreparedStatement.java:185)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.readExecute(PreparedStatement.java:1810)&lt;br/&gt;
        at org.apache.derby.client.am.PreparedStatement.executeBatchRequestX(PreparedStatement.java:2325)&lt;br/&gt;
        ... 3 more&lt;br/&gt;
Caused by: org.apache.derby.client.am.SqlException: Error for batch element #0: Java exception: &apos;Stream has already been&lt;br/&gt;
 read and end-of-file reached and cannot be re-used.: java.io.EOFException&apos;.&lt;br/&gt;
        at org.apache.derby.client.am.SqlException.&amp;lt;init&amp;gt;(SqlException.java:292)&lt;br/&gt;
        at org.apache.derby.client.am.SqlException.&amp;lt;init&amp;gt;(SqlException.java:259)&lt;br/&gt;
        ... 10 more&lt;br/&gt;
~/repro/derby-6214 $&lt;/p&gt;

&lt;p&gt;The full exception from the derby.log is:&lt;/p&gt;



&lt;p&gt;Mon May 06 11:30:40 PDT 2013 Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_11,5,main&amp;#93;&lt;/span&gt; (XID = 168), (SESSIONID = 3), (DATABASE = ClobTest), (DRDAID = ??????&lt;cite&gt;.&lt;/cite&gt;??-653020578103681136&lt;/p&gt;
{2}
&lt;p&gt;), Failed Statement is: UPDATE Test3 SET C16 = ?, S05 = ?, I06 = ?, I07 = I07 + 1 WHERE S02 IN (?, ?) with 5 parameters begin parameter #1: CLOB(org.apache.derby.iapi.types.ReaderToUTF8Stream@de907da4) :end parameter begin parameter #2: GGGGGGGG :end parameter begin parameter #3: 4002 :end parameter begin parameter #4: AAAAA :end parameter begin parameter #5: EEEEE :end parameter &lt;br/&gt;
ERROR XSDA4: An unexpected exception was thrown&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:279)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.UpdateOperation.&amp;lt;init&amp;gt;(UpdateOperation.java:110)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.LoggableActions.actionUpdate(LoggableActions.java:80)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.StoredPage.doUpdateAtSlot(StoredPage.java:8703)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BasePage.updateAtSlot(BasePage.java:1064)&lt;br/&gt;
	at org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController.replace(GenericConglomerateController.java:486)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.RowChangerImpl.updateRow(RowChangerImpl.java:523)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.collectAffectedRows(UpdateResultSet.java:568)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:263)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:438)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:319)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1242)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1692)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(EmbedPreparedStatement.java:1347)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAStatement.execute(DRDAStatement.java:706)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.parseEXCSQLSTTobjects(DRDAConnThread.java:4332)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.parseEXCSQLSTT(DRDAConnThread.java:4149)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.processCommands(DRDAConnThread.java:1037)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.run(DRDAConnThread.java:295)&lt;br/&gt;
Caused by: java.io.EOFException: Stream has already been read and end-of-file reached and cannot be re-used.&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.read(ReaderToUTF8Stream.java:254)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.MemByteHolder.write(MemByteHolder.java:146)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.RememberBytesInputStream.fillBuf(RememberBytesInputStream.java:135)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.StoredPage.logColumn(StoredPage.java:6238)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.StoredPage.logRow(StoredPage.java:4013)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.UpdateOperation.writeOptionalDataToBuffer(UpdateOperation.java:255)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.UpdateOperation.&amp;lt;init&amp;gt;(UpdateOperation.java:106)&lt;br/&gt;
	... 17 more&lt;br/&gt;
============= begin nested exception, level (1) ===========&lt;br/&gt;
java.io.EOFException: Stream has already been read and end-of-file reached and cannot be re-used.&lt;br/&gt;
	at org.apache.derby.iapi.types.ReaderToUTF8Stream.read(ReaderToUTF8Stream.java:254)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.MemByteHolder.write(MemByteHolder.java:146)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.RememberBytesInputStream.fillBuf(RememberBytesInputStream.java:135)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.StoredPage.logColumn(StoredPage.java:6238)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.StoredPage.logRow(StoredPage.java:4013)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.UpdateOperation.writeOptionalDataToBuffer(UpdateOperation.java:255)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.UpdateOperation.&amp;lt;init&amp;gt;(UpdateOperation.java:106)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.LoggableActions.actionUpdate(LoggableActions.java:80)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.StoredPage.doUpdateAtSlot(StoredPage.java:8703)&lt;br/&gt;
	at org.apache.derby.impl.store.raw.data.BasePage.updateAtSlot(BasePage.java:1064)&lt;br/&gt;
	at org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController.replace(GenericConglomerateController.java:486)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.RowChangerImpl.updateRow(RowChangerImpl.java:523)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.collectAffectedRows(UpdateResultSet.java:568)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:263)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:438)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:319)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1242)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(EmbedPreparedStatement.java:1692)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(EmbedPreparedStatement.java:1347)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAStatement.execute(DRDAStatement.java:706)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.parseEXCSQLSTTobjects(DRDAConnThread.java:4332)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.parseEXCSQLSTT(DRDAConnThread.java:4149)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.processCommands(DRDAConnThread.java:1037)&lt;br/&gt;
	at org.apache.derby.impl.drda.DRDAConnThread.run(DRDAConnThread.java:295)&lt;br/&gt;
============= end nested exception, level (1) ===========&lt;br/&gt;
Cleanup action complete&lt;/p&gt;





















































</comment>
                            <comment id="13649980" author="mikem" created="Mon, 6 May 2013 19:50:33 +0100"  >&lt;p&gt;wonder if the client somehow creates a clob out of the string, but that clob is not set up to be read twice.  In the test&lt;br/&gt;
case multiple rows will be updated by the query, each time using the value set with setObject.&lt;/p&gt;

&lt;p&gt;Might also be interesting to see if problem is in embedded if the string is much longer forcing a stream.  Something bigger than 32k.&lt;/p&gt;</comment>
                            <comment id="13649997" author="kmarsden" created="Mon, 6 May 2013 20:05:38 +0100"  >&lt;p&gt;According to this reference chart 8.9.5, I was surprised to find that  setObject of a String to a Clob is not marked as something that should work.&lt;br/&gt;
&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We do have a history of it working in some contexts so it seems to make sense to fix this case to work the same way, but makes sense to bring down the priority especially since there is a work around. I am done with the work I plan to do on this issue.&lt;/p&gt;</comment>
                            <comment id="13652024" author="kmarsden" created="Wed, 8 May 2013 17:18:31 +0100"  >&lt;p&gt;Actually even setString says it converts to VARCHAR or LONGVARCHAR&lt;br/&gt;
&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html#setString(int,%20java.lang.String&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html#setString(int,%20java.lang.String&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Is setString valid with a CLOB target?&lt;br/&gt;
What is the correct (according to spec) way to set a value for a Clob, setCharacterStream?&lt;/p&gt;</comment>
                            <comment id="13652084" author="mikem" created="Wed, 8 May 2013 18:25:31 +0100"  >&lt;p&gt;any opinions if the following should be treated as part of the spec?  I was trying to find it in the java 7 or java 8 specs&lt;br/&gt;
and so far have not been able to.  As a &quot;guide&quot; maybe it is not complete.&lt;br/&gt;
&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;With respect to clob I know that some conversions that at first were not allowed, were then added as it matured.  &lt;/p&gt;

&lt;p&gt;Unfortunately setClob() documentation itself has no mention of data conversions. &lt;/p&gt;

&lt;p&gt;setClob() does have the following, but I interpret it in this situation as you should throw the exception if you have no CLOB support, not in the&lt;br/&gt;
case of not supporting a particular conversion:&lt;br/&gt;
SQLFeatureNotSupportedException - if targetSqlType is a ARRAY, BLOB, CLOB, DATALINK, JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF, ROWID, SQLXML or STRUCT data type and the JDBC driver does not support this data type&lt;/p&gt;

&lt;p&gt;It does seem like either Derby should throw a reasonable error if it does not support this setObject call or it should work.&lt;/p&gt;</comment>
                            <comment id="13654384" author="knutanders" created="Fri, 10 May 2013 12:30:51 +0100"  >&lt;p&gt;I don&apos;t think the getting started guide is part of the spec. However, chart 8.9.5 in the getting started guide looks very similar to Table B-5 in the JDBC 4.1 specification, except the latter shows mappings for more types (like NCLOB and SQLXML). Neither of the two tables say that a String object can be converted to a CLOB value by setObject(), so it seems such a conversion is an extension of the spec.&lt;/p&gt;</comment>
                            <comment id="13662090" author="mamtas" created="Mon, 20 May 2013 16:45:34 +0100"  >&lt;p&gt;I have been working on this jira for a little bit, specifically on the stand alone test case. I am attaching the test case as Derby6214_ver2.java. This test case is built on top of the test cases provided by Rong and Kathey. While working on the test, I found that we do not need to have batch processing to run into the problem so I have removed the batch add and execution part to make the test case simpler. The test creates the table(by first dropping the table if already exists) and loads data into it. (Change the url for the derby database as appropriate. Right now, the db location hard coded as c:/dellater/ClobTest).&lt;/p&gt;

&lt;p&gt;The test can be used to test both embedded and client server. Additionally, it shows that the workaround of using setString instead of setObject in client server case does not work for a fairly large string. &lt;/p&gt;


&lt;p&gt;The test takes three parameters&lt;br/&gt;
The first param&lt;br/&gt;
   if &quot;client&quot; is passed then test case will be run in network server environment. For this, you first have to start the&lt;br/&gt;
	network server before running the test.&lt;br/&gt;
   if not &quot;client&quot; is passed then test case will be run in embedded derby.&lt;br/&gt;
The second parameter &lt;br/&gt;
   if &apos;1&apos; is passed then test case will update only one row(this verifies that we work fine updating clob with just one row update)&lt;br/&gt;
   if not &apos;1&apos;, then test case will update two rows(this is one which runs into the bug)&lt;br/&gt;
The third parameter says to use the workaround of using setString instead of setObject&lt;br/&gt;
   if &apos;1&apos; is passed then test case will use the workaround of using setString rather than setObject on the clob column&lt;br/&gt;
	using a small string&lt;br/&gt;
   if &apos;2&apos; is passed then test case will use the workaround of using setString rather than setObject on the clob column&lt;br/&gt;
	using a very large string&lt;br/&gt;
   if &apos;3&apos; is passed then test case will use setObject on the clob column using small string&lt;br/&gt;
   if anything other than &apos;1&apos; or &apos;2&apos; or &apos;3&apos; is passed then test case will use setObject on the clob column using &lt;br/&gt;
	a very large string&lt;/p&gt;

&lt;p&gt;Now, here is the behavior for all these scenarios. I realize that this sounds pretty involved but it helps us establish what cases work and what cases break.&lt;/p&gt;

&lt;p&gt;Embed test cases work for all different combinations as shown below&lt;br/&gt;
1)Embed test case updating only one row and using setString with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 1 1&lt;br/&gt;
2)Embed test case updating only one row and using setString with very large string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 1 2&lt;br/&gt;
3)Embed test case updating only one row and using setObject with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 1 3&lt;br/&gt;
4)Embed test case updating only one row and using setObject with very large string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 1 4&lt;br/&gt;
5)Embed test case updating two rows and using setString with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 2 1&lt;br/&gt;
6)Embed test case updating two rows and using setString with very large string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 2 2&lt;br/&gt;
7)Embed test case updating two rows and using setObject with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 2 3&lt;br/&gt;
8)Embed test case updating two rows and using setObject with very large string - works fine&lt;br/&gt;
	java Derby6214_ver2 embed 2 4&lt;br/&gt;
In short, all the variations work in the embedded case.&lt;/p&gt;

&lt;p&gt;Moving on to the client server case.&lt;br/&gt;
1)Client server test case updating only one row and using setString with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 client 1 1&lt;br/&gt;
2)Client server test case updating only one row and using setString with very large string - works fine&lt;br/&gt;
	java Derby6214_ver2 client 1 2&lt;br/&gt;
3)Client server test case updating only one row and using setObject with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 client 1 3&lt;br/&gt;
4)Client server test case updating only one row and using setObject with very large string - works fine&lt;br/&gt;
	java Derby6214_ver2 client 1 4&lt;br/&gt;
5)Client server test case updating two rows and using setString with small string - works fine&lt;br/&gt;
	java Derby6214_ver2 client 2 1&lt;br/&gt;
6)Client server test case updating two rows and using setString with very large string - FAILS&lt;br/&gt;
	java Derby6214_ver2 client 2 2&lt;br/&gt;
7)Client server test case updating two rows and using setObject with small string - FAILS&lt;br/&gt;
	java Derby6214_ver2 client 2 3&lt;br/&gt;
7)Client server test case updating two rows and using setObject with very large string - FAILS&lt;br/&gt;
	java Derby6214_ver2 client 2 4&lt;/p&gt;

&lt;p&gt;Once the test is compiled, an eg of using the test for embedded updating just one row and using setString to update CLOB column with a small string would be as follows&lt;br/&gt;
java Derby6214_ver2 embed 1 1&lt;/p&gt;</comment>
                            <comment id="13665395" author="mamtas" created="Thu, 23 May 2013 18:39:20 +0100"  >&lt;p&gt;I found that the String size has to be 10923 characters for the setString workaround to fail. eg&lt;br/&gt;
        char[] c = new char&lt;span class=&quot;error&quot;&gt;&amp;#91;10922&amp;#93;&lt;/span&gt;;//works&lt;br/&gt;
        //fails with 10923 characters and more&lt;br/&gt;
        //passes with 10922 characters and less&lt;br/&gt;
        Arrays.fill(c, &apos;a&apos;); &lt;br/&gt;
The attached repro from last comment does setString testing with 530000 characters and that fails but it looks like it doesn&apos;t have to be that large a string. It will fail even with 10923 characters.&lt;/p&gt;</comment>
                            <comment id="13665534" author="mamtas" created="Thu, 23 May 2013 20:36:12 +0100"  >&lt;p&gt;I think the unique number of 10923 characters comes from the following code in the client side. Here we decide when to send the data as string vs stream&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 1366 in NetStatementRequest))	&lt;br/&gt;
	NetResultSetRequest(NetStatementRequest).computeProtocolTypesAndLengths(Object[], ColumnMetaData, int[][], Hashtable) line: 1366	&lt;br/&gt;
	NetResultSetRequest(NetStatementRequest).buildSQLDTAcommandData(int, ColumnMetaData, Object[]) line: 545	&lt;br/&gt;
	NetResultSetRequest(NetStatementRequest).writeExecute(NetPreparedStatement, Section, ColumnMetaData, Object[], int, boolean, boolean) line: 162	&lt;br/&gt;
	NetPreparedStatement.writeExecute_(Section, ColumnMetaData, Object[], int, boolean, boolean) line: 156	&lt;br/&gt;
	ClientPreparedStatement.writeExecute(Section, ColumnMetaData, Object[], int, boolean, boolean) line: 1832	&lt;br/&gt;
	ClientPreparedStatement.flowExecute(int) line: 2047	&lt;br/&gt;
	ClientPreparedStatement.executeX() line: 1620	&lt;br/&gt;
	ClientPreparedStatement.execute() line: 1605	&lt;br/&gt;
	MamtaJDBC.main(String[]) line: 84	&lt;/p&gt;

&lt;p&gt;                case Types.LONGVARCHAR:&lt;br/&gt;
                    // Is this the right thing to do  // should this be 32700&lt;br/&gt;
                    s = (String) inputRow&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;;&lt;br/&gt;
                    if (s == null || s.length() &amp;lt;= 32767 / 3) &lt;/p&gt;
{
                        lidAndLengths[i][0] = DRDAConstants.DRDA_TYPE_NLONGMIX;
                        lidAndLengths[i][1] = 32767;
                    }
&lt;p&gt; else {&lt;br/&gt;
                        // Flow the data as CLOB data if the data too large to for LONGVARCHAR&lt;br/&gt;
                        ByteArrayInputStream bais = null;&lt;br/&gt;
                        byte[] ba = null;&lt;br/&gt;
                        try &lt;/p&gt;
{
                            ba = s.getBytes(&quot;UTF-8&quot;);
                            bais = new ByteArrayInputStream(ba);
                            ClientClob c = new ClientClob(
                                netAgent_, bais, &quot;UTF-8&quot;, ba.length);

                            // inputRow[i] = c;
                            // Place the new Lob in the promototedParameter_ collection for
                            // NetStatementRequest use
                            promototedParameters_.put(i, c);

                            lidAndLengths[i][0] = DRDAConstants.DRDA_TYPE_NLOBCMIXED;
                            lidAndLengths[i][1] = buildPlaceholderLength(c.length());
                        }
&lt;p&gt; catch (UnsupportedEncodingException e) &lt;/p&gt;
{
                            throw new SqlException(netAgent_.logWriter_, 
                                new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
                                &quot;byte array&quot;, &quot;Clob&quot;);
                        }
&lt;p&gt;                    }&lt;br/&gt;
                    break;&lt;/p&gt;</comment>
                            <comment id="13665586" author="mikem" created="Thu, 23 May 2013 21:04:29 +0100"  >&lt;p&gt;32k/3 makes sense.  I think 32k is a drda on byte size of strings passed along.  The worst case for UTF-8 on java strings is 3 bytes per java character in a strings.&lt;/p&gt;</comment>
                            <comment id="13665597" author="mikem" created="Thu, 23 May 2013 21:07:13 +0100"  >&lt;p&gt;seems next would be good to understand what implementing object on the server side is being opened twice, and how it differs when running in embedded for clob case.  Seems from what you have posted above solving the Clob case probably solves the long setString() case also.&lt;/p&gt;</comment>
                            <comment id="13666010" author="mamtas" created="Fri, 24 May 2013 06:37:27 +0100"  >&lt;p&gt;Little more info on the exception raised by client server test cases. The exception is thrown by the server side code in org.apache.derby.iapi.types.ReaderToUTF8Stream:read(byte b[], int off, int len). The exception thrown is (&apos;Stream has already been read and end-of-file reached and cannot be re-used.: java.io.EOFException&apos;.)&lt;/p&gt;

&lt;p&gt;Part of org.apache.derby.iapi.types.ReaderToUTF8Stream:read is copied below for reference&lt;br/&gt;
public int read(byte b[], int off, int len) throws IOException {&lt;/p&gt;

&lt;p&gt;        // when stream has been read and eof reached, stream is closed&lt;br/&gt;
        // and buffer is set to null ( see close() method)&lt;br/&gt;
        // since stream cannot be re-used, check if stream is closed and &lt;br/&gt;
        // if so throw an EOFException&lt;br/&gt;
        if ( buffer == null ) &lt;br/&gt;
            throw new EOFException(MessageService.getTextMessage&lt;br/&gt;
                    (SQLState.STREAM_EOF));&lt;/p&gt;
</comment>
                            <comment id="13666014" author="mamtas" created="Fri, 24 May 2013 06:43:06 +0100"  >&lt;p&gt;Also, I found that client server case creates ReaderToUTF8Stream objects but embedded case does not create them.&lt;br/&gt;
In case of network server, we come to following to create ReaderToUTF8Stream when client code executes the prepared statement (after setting the prepared statment parameter values)&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;DRDAConnThread_2&amp;#93;&lt;/span&gt; (Suspended (breakpoint at line 836 in EmbedPreparedStatement))	&lt;br/&gt;
	EmbedPreparedStatement40(EmbedPreparedStatement).setCharacterStreamInternal(int, Reader, boolean, long) line: 836	&lt;br/&gt;
	EmbedPreparedStatement40(EmbedPreparedStatement).setCharacterStream(int, Reader) line: 1815	&lt;br/&gt;
	DRDAConnThread.setAsCharacterStream(DRDAStatement, int, EXTDTAReaderInputStream, boolean, String) line: 9453	&lt;br/&gt;
	DRDAConnThread.readAndSetExtParam(int, DRDAStatement, int, int, boolean) line: 5328	&lt;br/&gt;
	DRDAConnThread.readAndSetAllExtParams(DRDAStatement, boolean) line: 5257	&lt;br/&gt;
	DRDAConnThread.parseEXCSQLSTTobjects(DRDAStatement) line: 4509	&lt;br/&gt;
	DRDAConnThread.parseEXCSQLSTT() line: 4325	&lt;br/&gt;
	DRDAConnThread.processCommands() line: 1064	&lt;br/&gt;
	DRDAConnThread.run() line: 298	&lt;/p&gt;

&lt;p&gt;But in case of embedded, we do not create ReaderToUTF8Stream objects, instead following gets executed when the test program issues ps.setString(1,new String(c)) with large string&lt;br/&gt;
	SQLClob(SQLChar).setValue(String) line: 1496	&lt;br/&gt;
	EmbedPreparedStatement40(EmbedPreparedStatement).setString(int, String) line: 538	&lt;/p&gt;</comment>
                            <comment id="13666688" author="mikem" created="Fri, 24 May 2013 22:18:51 +0100"  >&lt;p&gt;so comparing embedded to client/server is likely not very useful in the setObject and setString case.  In embedded we have the actual string so there&lt;br/&gt;
is no stream, so nothing to get closed after draining, so no problem.  In client/server we are going to send a stream over and we are not going to know&lt;br/&gt;
if it is small or big so we probably can&apos;t just create an object in memory to &quot;back&quot; up the stream on the server side.&lt;/p&gt;

&lt;p&gt;I might suggest looking at embedded in one of the setStream cases with a stream larger than 32k, and see if it works for an update of more than one row.  If it&lt;br/&gt;
does it might lead to existing mechanism to save off a stream so that it can be reopened.  I believe there are existing holder objects that will take a stream and&lt;br/&gt;
buffer it to disk if need be so that you can read it again.  &lt;/p&gt;

&lt;p&gt;One thing I don&apos;t know is if it should be the job of server side client/server code that you are looking at to do this, of if it should be the job of sql execution engine&lt;br/&gt;
to recognize an input clob/blob/stream can&apos;t be read twice and it should do this work in the case of an update that might require updating more than one row.&lt;br/&gt;
I think we use to have generic embedded issues with blob/clob where it would instantiate them into memory in cases like this.  I thought those had been resolved,&lt;br/&gt;
but maybe this is a case that slipped through.    Should be clear if you follow the code for an embedded update of clob where user provides a stream.&lt;/p&gt;</comment>
                            <comment id="13668401" author="mamtas" created="Tue, 28 May 2013 17:16:05 +0100"  >&lt;p&gt;Hi Mike, thanks for taking the time on this issue. I used setCharacterStream in embedded case while updating 2 rows and indeed got the same failure as client-server case. I modified the test case to have following&lt;br/&gt;
        } else if (args&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;.equals(&quot;5&quot;)) &lt;/p&gt;
{
        	System.out.println(&quot;setCharacterStream with very large string&quot;);
                   CharAlphabet a1 = CharAlphabet.singleChar(&apos;a&apos;);
                   ps.setCharacterStream(1,
                        new LoopingAlphabetReader(50000, a1), 50000);
        }
&lt;p&gt;and got following exception&lt;br/&gt;
Caused by: java.io.EOFException: Stream has already been read and end-of-file reached and cannot be re-used.&lt;br/&gt;
        at org.apache.derby.iapi.types.ReaderToUTF8Stream.read(ReaderToUTF8Stream.java:258)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.MemByteHolder.write(MemByteHolder.java:146)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.RememberBytesInputStream.fillBuf(RememberBytesInputStream.java:135)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.StoredPage.logColumn(StoredPage.java:6242)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.StoredPage.logRow(StoredPage.java:4017)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.UpdateOperation.writeOptionalDataToBuffer(UpdateOperation.java:248)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.UpdateOperation.&amp;lt;init&amp;gt;(UpdateOperation.java:99)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.LoggableActions.actionUpdate(LoggableActions.java:80)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.StoredPage.doUpdateAtSlot(StoredPage.java:8707)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.data.BasePage.updateAtSlot(BasePage.java:1064)&lt;br/&gt;
        at org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController.replace(GenericConglomerateController.java:486)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.RowChangerImpl.updateRow(RowChangerImpl.java:523)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.UpdateResultSet.collectAffectedRows(UpdateResultSet.java:568)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.UpdateResultSet.open(UpdateResultSet.java:263)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:453)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:334)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1346)&lt;br/&gt;
        ... 3 more&lt;/p&gt;

&lt;p&gt;Like you mentioned, we should see if there are existing holder objects that will take a stream and buffer it to disk if need be so that you can read it again. I will look in the code to see if I can find something like that. Thanks&lt;/p&gt;</comment>
                            <comment id="13668498" author="mikem" created="Tue, 28 May 2013 19:02:20 +0100"  >&lt;p&gt;I am not sure where, but I believe at least in the clob/blob case we sometimes instantiate the object that is implemented as a stream.  I believe something in the&lt;br/&gt;
execution system should recognize when this is necessary.  &lt;/p&gt;

&lt;p&gt;Maybe try creating an index on a string column and using a stream to insert into the row.  Should need to read that stream twice once for base table and once for index.&lt;/p&gt;</comment>
                            <comment id="13668602" author="mikem" created="Tue, 28 May 2013 20:56:37 +0100"  >&lt;p&gt;for the client/server setString case, is there any way for the server side to &quot;know&quot; that the source data started as a string rather than a stream.  Or does it know length?&lt;br/&gt;
If so it might make sense for the server side to convert it back into a string if we can&apos;f easily fix the stream case.  &lt;/p&gt;</comment>
                            <comment id="13675638" author="mamtas" created="Wed, 5 Jun 2013 07:44:53 +0100"  >&lt;p&gt;I am looking at understanding the logic in case of network server for setString when a short string is passed and multiple rows are updated. This case works fine. I am investigating if when using setObject to set the value of a CLOB column with short string, if we can mimic the logic of setString and make setObject work for atleast short strings on CLOB column. &lt;/p&gt;</comment>
                            <comment id="13676294" author="mamtas" created="Wed, 5 Jun 2013 21:15:02 +0100"  >&lt;p&gt;We have a following check in NetStatementRequest when dealing with setString&lt;br/&gt;
                    s = (String) inputRow&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;;&lt;br/&gt;
                    if (s == null || s.length() &amp;lt;= 32767 / 3) &lt;/p&gt;
{
                        lidAndLengths[i][0] = DRDAConstants.DRDA_TYPE_NLONGMIX;
                        lidAndLengths[i][1] = 32767;
                    }
&lt;p&gt; else {&lt;br/&gt;
                        // Flow the data as CLOB data if the data too large to for LONGVARCHAR&lt;br/&gt;
in other words, we send the string as it is if it is less than or equal to 32767 / 3 but any larger string is send as CLOB data. I believe we can have a similar check for setObject using string on a CLOB datatype. If the string is less than or equal to 32767 / 3, we can choose to send it as string otherwise continue to do what we do today, which is to send it as stream. I am working on this change.&lt;/p&gt;</comment>
                            <comment id="13678500" author="mamtas" created="Fri, 7 Jun 2013 23:09:59 +0100"  >&lt;p&gt;Attaching a patch where setObject will now behave same as setString when dealing with smaller strings(length 10922 characters and smaller) and modifying more than one row through the UPDATE sql. Basically setObject(int, Object, Types.CLOB) will check if it is dealing with String and if if it is small enough, then it will get on the wire to the server as String. For longer strings, we still will use a stream. The stream case still runs into exception when we update more than one row. Would appreciate any feedback. One thing to note in the patch is the code touched in CrossConverters is also used by ResultSet.updateXXX and ResultSet.getXXX calls. Those methods don&apos;t need this special handling of String and that is why a boolean parameter has been introduced to differentiate the call coming from PreparedStatement.setXXX vs the ResultSet.updateXXX and ResultSet.getXXX.&lt;/p&gt;</comment>
                            <comment id="13679650" author="kmarsden" created="Mon, 10 Jun 2013 18:23:15 +0100"  >&lt;p&gt;Hi Mamta, This patch looks fine to me  for the targeted case you are fixing.&lt;/p&gt;</comment>
                            <comment id="13680463" author="mamtas" created="Tue, 11 Jun 2013 17:43:33 +0100"  >&lt;p&gt;Kathey, thanks for looking at the patch. I ran derbyall and junit suite with it and those tests ran fine. I am planning on adding some junite tests for ResultSet.updateObject and ResultSet.getObject since the patch for PreparedStatement.getObject has changed code which is shared by these 2 methods. &lt;/p&gt;</comment>
                            <comment id="13680603" author="mikem" created="Tue, 11 Jun 2013 21:02:26 +0100"  >&lt;p&gt;comments on patch and existing test.  I think at this point the goal for 6214 is to make setObject work as well as setString, and close out this issue with&lt;br/&gt;
the patch.  Then address large strings in another issue.  To this end:&lt;/p&gt;

&lt;p&gt;1) you should change comments in ParameterMappingTest that were written before the other issues were created.  For instance:&lt;br/&gt;
    &quot;once &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6214&quot; title=&quot;PreparedStatement.setObject(int, Object, Types.CLOB) fail with DerbyNet&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6214&quot;&gt;DERBY-6214&lt;/a&gt; is fixed, we can remove following check&quot;.&lt;br/&gt;
2) testDerby6214 is hard to understand what is going on.  Some comments about the i,j loop would help.  I also would at least rename i to something like numrows.&lt;br/&gt;
    helperTest could use more comments also.  I think the various cases could benefit from some comments like &quot;test small string less that critical xxxx length&quot;, &lt;br/&gt;
    test large string greater than xxx length.  The magic numbers for length come from code path zzz.   would be good to define what large string is and why, maybe a constant with a comment..&lt;br/&gt;
3) in CrossConverters.java:&lt;br/&gt;
    o in comments for setObject i think originalSetObject is false in the case of setXXX calls that are not setObject, but that is not clear from the comments.&lt;br/&gt;
    o there is more talk about magic number 32767/3, there should be one constant with a good name somewhere shared by all the code, and why it is important.&lt;br/&gt;
    o it would be nice to fix up comments for setObject that you have added to. it should start with saying what the routine is doing.  Is the following correct?:&lt;/p&gt;

&lt;p&gt;// Convert from string source to target type.&lt;br/&gt;
// In support of PS.setXXX, PS.updateXXX, and PS.getXXX &lt;/p&gt;

&lt;p&gt;    o you added the following with no comment as to why, I would prefer not to add an extra call level to this high traffic routine if possible.  Is it just to save some&lt;br/&gt;
       typing to change all the callse in the following setObject routine?  If so I would just rather see the code change made.  all the overriding based on num arguments can &lt;br/&gt;
       easily lead to bugs when making changes like this, other routine may start getting called that you don&apos;t expect.  :&lt;br/&gt;
    final Object setObject(int targetType, Object source) throws SqlException &lt;/p&gt;
{
        return setObject(targetType, source, false);
    }

&lt;p&gt;4) what problems result if you don&apos;t have the originalSetObject information?  It would be better if we did not have the special case if we can help it, just always send string in small string case.&lt;br/&gt;
    It seems likely there are existing problems with updateXXX also.  maybe just is not right for getXXX, not sure.  I&apos;d like to see if there is any way to fix this without adding a param/extra call to&lt;br/&gt;
this high traffic routine.&lt;/p&gt;


</comment>
                            <comment id="13681956" author="mamtas" created="Thu, 13 Jun 2013 07:41:35 +0100"  >&lt;p&gt;Thanks for looking at the patch, Mike. I am attaching another patch which addresses most of your comments. The files touched by this patch are as follows&lt;br/&gt;
$ svn stat -q&lt;br/&gt;
M       java\engine\org\apache\derby\iapi\reference\Limits.java&lt;br/&gt;
M       java\testing\org\apache\derbyTesting\functionTests\tests\jdbcapi\ParameterMappingTest.java&lt;br/&gt;
M       java\client\org\apache\derby\client\net\NetStatementRequest.java&lt;br/&gt;
M       java\client\org\apache\derby\client\am\CrossConverters.java&lt;br/&gt;
M       java\client\org\apache\derby\client\am\ClientPreparedStatement.java&lt;/p&gt;

&lt;p&gt;This patch makes PreparedStatement.setObject work same as PreparedStatement.setString for small strings(&amp;lt;=10922 characters in length). Additionally, I have modularized the tests from the previous patch and made changes to verify the updated data for that test. The changes to verify the updated data use ResultSet.getString and ResultSet.getObject thus verifying that those apis work fine with the changed made for PreparedStatement.setObject. In addition, I have added new tests for ResultSet.updateString and ResultSet.updateObject to make sure the changes for PreparedStatement.setObject has not broken these apis since they share the same code. I have added lot more comments into the code changes. I have also created a constant in java\engine\org\apache\derby\iapi\reference\Limits.java for the length 10922 so in the code, we use that constant rather than the actual number. I think it is ok to add the constant in the Limits file since I have seen other client code using constants from that file.&lt;/p&gt;

&lt;p&gt;Here is the response to some of the questions in your comments&lt;br/&gt;
********************************&lt;br/&gt;
 o you added the following with no comment as to why, I would prefer not to add an extra call level to this high traffic routine if possible. Is it just to save some&lt;br/&gt;
       typing to change all the callse in the following setObject routine? If so I would just rather see the code change made. all the overriding based on num arguments can &lt;br/&gt;
       easily lead to bugs when making changes like this, other routine may start getting called that you don&apos;t expect. :&lt;br/&gt;
    final Object setObject(int targetType, Object source) throws SqlException &lt;/p&gt;
{
        return setObject(targetType, source, false);
    }

&lt;p&gt;Yes, the reason for the new method is so that we don&apos;t have to change all the callers of CrossConverts.setObject(targetType, source) to have to pass the new parameter which will be false for all except ClientPreparedStatement.setObjectX method. I do see your point about this causing possible confusion and unintentional method being called. I can go ahead and change all the callers to pass false when they call this method and just have ClientPreparedStatement.setObjectX pass the value true. This will eliminate the need for a new method in CrossConverts class.&lt;br/&gt;
********************************&lt;/p&gt;


&lt;p&gt;********************************&lt;br/&gt;
4) what problems result if you don&apos;t have the originalSetObject information? It would be better if we did not have the special case if we can help it, just always send string in small string case.&lt;br/&gt;
    It seems likely there are existing problems with updateXXX also. maybe just is not right for getXXX, not sure. I&apos;d like to see if there is any way to fix this without adding a param/extra call to&lt;br/&gt;
this high traffic routine.&lt;/p&gt;

&lt;p&gt;When originally I didn&apos;t have the check in my code, it caused the existing junit test UpdatableResultSetTest to fail. Now, that I have added ResultSet.updateXXX calls test in my junit test, I see the same failure with that new junit test if I remove the originalSetObject information. The exception is as follows. I have not spent the reason behind the class cast exception but I can spend some time on it to see if it is easy to fix this exception so we do not need to have special parameter originalSetObject anymore.&lt;br/&gt;
1) testDerby6214updateXXX(org.apache.derbyTesting.functionTests.tests.jdbcapi.ParameterMappingTest)java.lang.ClassCastException: java.lang.String incompatible with java.sql.Clob&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.computeProtocolTypesAndLengths(NetStatementRequest.java:1462)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.buildSQLDTAcommandData(NetStatementRequest.java:545)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.writeExecute(NetStatementRequest.java:162)&lt;br/&gt;
        at org.apache.derby.client.net.NetPreparedStatement.writeExecute_(NetPreparedStatement.java:156)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.writeUpdateRow(ClientResultSet.java:4357)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.positionToCurrentRowAndUpdate(ClientResultSet.java:4098)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.updateRowX(ClientResultSet.java:3651)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.updateRow(ClientResultSet.java:3555)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.ParameterMappingTest.testDerby6214updateXXX(ParameterMappingTest.java:439)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)&lt;br/&gt;
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:117)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseJDBCTestCase.runBareOverridable(BaseJDBCTestCase.java:439)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseJDBCTestCase.runBare(BaseJDBCTestCase.java:456)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:24)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:21)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:25)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
********************************&lt;/p&gt;</comment>
                            <comment id="13685889" author="mamtas" created="Mon, 17 Jun 2013 20:35:19 +0100"  >&lt;p&gt;Just to recap, in this jira, we are trying to fix PreparedStatement.setObject(int, Object, Types.CLOB) when Object is of type String and that String object is less than or equal to 10922 characters. The 2 attached patches attempt to fix the problem by sending such Strings as String on the wire from client to server rather than stream(this matches the behavior for PreparedStatement.setString). If we decide to do the same for ResultSet.updateObject (since the code is shared by ResultSet.updateObject and PreparedStatement.setObject), it runs into following exception&lt;br/&gt;
.derbyTesting.functionTests.tests.jdbcapi.ParameterMappingTest)java.lang.ClassCastException: java.lang.String incompatible with java.sql.Clob &lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.computeProtocolTypesAndLengths(NetStatementRequest.java:1462) &lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.buildSQLDTAcommandData(NetStatementRequest.java:545) &lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.writeExecute(NetStatementRequest.java:162) &lt;br/&gt;
        at org.apache.derby.client.net.NetPreparedStatement.writeExecute_(NetPreparedStatement.java:156) &lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.writeUpdateRow(ClientResultSet.java:4357) &lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.positionToCurrentRowAndUpdate(ClientResultSet.java:4098) &lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.updateRowX(ClientResultSet.java:3651) &lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.updateRow(ClientResultSet.java:3555) &lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.ParameterMappingTest.testDerby6214updateXXX(ParameterMappingTest.java:439) &lt;/p&gt;

&lt;p&gt;I have been looking at this exception and it looks like when dealing with ResultSet.updateObject on a CLOB column, we have coded everywhere to look for Clob column. I tried changing the offending code line in the stack trace above and ran into same exception again at a different part of the code as shown below&lt;br/&gt;
java.lang.ClassCastException: java.lang.String incompatible with java.sql.Clob&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.buildEXTDTA(NetStatementRequest.java:1050)&lt;br/&gt;
        at org.apache.derby.client.net.NetStatementRequest.writeExecute(NetStatementRequest.java:168)&lt;br/&gt;
        at org.apache.derby.client.net.NetPreparedStatement.writeExecute_(NetPreparedStatement.java:156)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.writeUpdateRow(ClientResultSet.java:4368)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.positionToCurrentRowAndUpdate(ClientResultSet.java:4109)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.updateRowX(ClientResultSet.java:3662)&lt;br/&gt;
        at org.apache.derby.client.am.ClientResultSet.updateRow(ClientResultSet.java:3566)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.ParameterMappingTest.testDerby6214updateXXX(ParameterMappingTest.java:439)&lt;/p&gt;

&lt;p&gt;Fixing that by to accomodate String rather than Clob at this place resulted in same exception in another place. So I do not think we can avoid using a Clob object for ResultSet.updateObject for a CLOB column easily. I am looking at intercepting the String object from CrossConverts.setObject for ResultSet.updateObject and see if we can fix the problem that way rather than having a special case in highly reused code in CrossConverts.setObject. &lt;/p&gt;

&lt;p&gt;Additionally, I put println in CrossConverts.setObject where we see if we are dealing with a String less than or equal to 10922 characters for a CLOB object and ran existing junit and derbyall tests and found that this code gets called only by ParameterMappingTest(by the new junit test that I have added in my codeline) and by existing junit test in UpdatableResultSetTest. So, atleast from the test runs, it looks like the suggested code changes in the 2 patches are used only by ResultSet.updateObject  and PreparedStatement.setObject&lt;/p&gt;</comment>
                            <comment id="13702985" author="mamtas" created="Tue, 9 Jul 2013 07:46:06 +0100"  >&lt;p&gt;Since CrossConverters.setObject is heavily used by various PreparedStatement.setXXX, ResultSet.getXXX, Resultset.updateXXX methods, the only change I am proposing there is to check the length of the String object if the type of the column is ClientTypes.CLOB and if yes, then return a String object if the String is less than or equal to 10922 characters otherwise return it as a CLOB object. The caller would use the returned object (String or CLOB) other than the ResultSet.updateObject and ResultSet.updateString methods when they are working with CLOB columns. These methods are coded to expect a CLOB object from CrossConverters.setObject call, irrespective of the length of the String. Because of this, these 3 methods will convert the returned String object to CLOB so that the rest of the code does not break. The junit and derbyall run fine with this patch. Please let me know if there is any feedback.&lt;/p&gt;

&lt;p&gt;The ideal solution would be to not change the Client code at all and have the engine deal with reading the stream more than once when UPDATE can update more than one row and it is dealing with a stream.&lt;/p&gt;</comment>
                            <comment id="13921501" author="mamtas" created="Wed, 5 Mar 2014 22:08:44 +0000"  >&lt;p&gt;Not working on this currently&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12649752">DERBY-6232</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12650228">DERBY-6237</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12650819">DERBY-6245</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12586815" name="DERBY6214_patch1_diff.txt" size="6527" author="mamtas" created="Fri, 7 Jun 2013 23:09:59 +0100"/>
                            <attachment id="12586816" name="DERBY6214_patch1_stat.txt" size="246" author="mamtas" created="Fri, 7 Jun 2013 23:09:59 +0100"/>
                            <attachment id="12587569" name="DERBY6214_patch2_diff.txt" size="30251" author="mamtas" created="Thu, 13 Jun 2013 07:41:35 +0100"/>
                            <attachment id="12591388" name="DERBY6214_patch3_diff.txt" size="29356" author="mamtas" created="Tue, 9 Jul 2013 07:46:06 +0100"/>
                            <attachment id="12591389" name="DERBY6214_patch3_stat.txt" size="377" author="mamtas" created="Tue, 9 Jul 2013 07:46:06 +0100"/>
                            <attachment id="12581926" name="Derby6214.java" size="1172" author="kmarsden" created="Mon, 6 May 2013 19:34:47 +0100"/>
                            <attachment id="12581925" name="Derby6214_setup.sql" size="764" author="kmarsden" created="Mon, 6 May 2013 19:34:47 +0100"/>
                            <attachment id="12583842" name="Derby6214_ver2.java" size="2957" author="mamtas" created="Mon, 20 May 2013 16:45:34 +0100"/>
                            <attachment id="12581907" name="DerbyNet_client_test.sql" size="1687" author="rqu" created="Mon, 6 May 2013 18:03:22 +0100"/>
                            <attachment id="12581927" name="derby.log" size="22897" author="kmarsden" created="Mon, 6 May 2013 19:34:47 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 6 May 2013 18:34:47 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>326603</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    <customfieldvalue key="10427"><![CDATA[Workaround attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hze727:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>326948</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>