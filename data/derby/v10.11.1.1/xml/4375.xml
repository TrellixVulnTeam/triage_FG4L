<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:30:16 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4375/DERBY-4375.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4375] WEME6.2 : Handful of test fixtures in InbetweenTest are failing with java.sql.SQLException: The syntax of the string representation of a datetime value is incorrect.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4375</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;On weme6.2, 8 test fixtures from InBetweenTest are failing with following error&lt;br/&gt;
java.sql.SQLException: The syntax of the string representation of a datetime value is incorrect.&lt;/p&gt;

&lt;p&gt;The failing test fixtures are &lt;br/&gt;
1)testReproductionBeetle5135&lt;br/&gt;
2)testBeetle4316&lt;br/&gt;
3)testNestedQueries&lt;br/&gt;
4)testCheckQueries&lt;br/&gt;
5)testBigInList&lt;br/&gt;
6)testInBetween&lt;br/&gt;
7)testInList&lt;br/&gt;
8)testBetween&lt;/p&gt;

&lt;p&gt;The stack trace for testBetween looks as follows&lt;br/&gt;
1) testBetween(org.apache.derbyTesting.functionTests.tests.lang.InbetweenTest)java.sql.SQLException: The syntax of the string representation of a datetime value is incorrect.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.lang.InbetweenTest.createTestObjects(InbetweenTest.java:195)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.lang.InbetweenTest.testBetween(InbetweenTest.java:214)&lt;br/&gt;
	at java.lang.reflect.AccessibleObject.invokeV(AccessibleObject.java:195)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:109)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
Caused by: ERROR 22007: The syntax of the string representation of a datetime value is incorrect.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.DateTimeParser.parseInt(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLTimestamp.parseDateOrTimestamp(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLTimestamp.parseTimestamp(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLTimestamp.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.getTimestamp(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLChar.getTimestamp(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.SQLTimestamp.setFrom(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.DataType.setValue(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.DataType.normalize(Unknown Source)&lt;br/&gt;
	at org.apache.derby.iapi.types.DataTypeDescriptor.normalize(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeColumn(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.normalizeRow(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.NormalizeResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
	... 39 more&lt;/p&gt;
</description>
                <environment>weme 6.2 </environment>
        <key id="12435640">DERBY-4375</key>
            <summary>WEME6.2 : Handful of test fixtures in InbetweenTest are failing with java.sql.SQLException: The syntax of the string representation of a datetime value is incorrect.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="6">Invalid</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="mamtas">Mamta A. Satoor</reporter>
                        <labels>
                    </labels>
                <created>Mon, 14 Sep 2009 19:53:50 +0100</created>
                <updated>Fri, 21 Jan 2011 17:52:35 +0000</updated>
                            <resolved>Thu, 17 Sep 2009 21:40:23 +0100</resolved>
                                    <version>10.6.1.0</version>
                                                    <component>Test</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12755134" author="mamtas" created="Mon, 14 Sep 2009 19:54:18 +0100"  >&lt;p&gt;I wonder if anyone has noticed these kind of failures on Sun&apos;s J2ME testing.&lt;/p&gt;</comment>
                            <comment id="12755385" author="mamtas" created="Tue, 15 Sep 2009 07:33:34 +0100"  >&lt;p&gt;The failure seem to have started occuring after the old test inbetween.sql(based on old harness) was converted into a junit test as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4318&quot; title=&quot;convert inbetween.sql to JUNIT&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4318&quot;&gt;&lt;del&gt;DERBY-4318&lt;/del&gt;&lt;/a&gt;. The code that is failing is a new piece of test code which I do not think existed in the old test. &lt;br/&gt;
        st.executeUpdate(&lt;br/&gt;
            &quot; insert into bt2 values (28, 82, null, &apos;15:47:28&apos;, &quot;&lt;br/&gt;
            + &quot;&apos;&quot;&lt;ins&gt;Timestamp.valueOf(&quot;0000-00-00 15:47:28.0&quot;)&lt;/ins&gt;&quot;&apos;, null)&quot;);&lt;/p&gt;
</comment>
                            <comment id="12755492" author="bryanpendleton" created="Tue, 15 Sep 2009 14:53:55 +0100"  >&lt;p&gt;I agree, I don&apos;t think that statement existed in the old test. The corresponding section&lt;br/&gt;
of the old test looked like this:&lt;/p&gt;

&lt;p&gt;-insert into bt2 values (8, -800.0, &apos;1992-03-22&apos;, &apos;03:22:28&apos;, &apos;2007-01-04 16:17:23.303&apos;, &apos;2992-01-02&apos;);&lt;br/&gt;
-insert into bt2 values (1, 200.0, &apos;1998-03-22&apos;, &apos;13:22:28&apos;, &apos;2007-01-04 16:17:36.912&apos;, &apos;3999-08-08&apos;);&lt;br/&gt;
-insert into bt2 values (-8, 800, &apos;3999-08-08&apos;, &apos;02:28:22&apos;, &apos;2007-01-05 16:03:52.364&apos;, &apos;1992-01-02&apos;);&lt;br/&gt;
-insert into bt2 values (18, 180.00, &apos;2007-02-23&apos;, &apos;15:47:27&apos;, null, null);&lt;br/&gt;
-insert into bt2 values (22, 202.010, &apos;2007-02-23&apos;, &apos;15:47:27&apos;, null, null);&lt;br/&gt;
-insert into bt2 values (23, 322.002, null, &apos;15:47:28&apos;, null, null);&lt;br/&gt;
-insert into bt2 values (28, 82, null, &apos;15:47:28&apos;, &apos;2007-02-23 15:47:27.544&apos;, null);&lt;/p&gt;

&lt;p&gt;I think that the SQLToJUnit tool did something strange with the &apos;xxxxxxFILTERED-TIMESTAMPxxxxx&apos;&lt;br/&gt;
data in the &apos;inbetween.out&apos; file as it was converting it to JUnit, and I didn&apos;t catch this during&lt;br/&gt;
the code review (probably because the test passed on all the platforms I was running).&lt;/p&gt;

&lt;p&gt;What do you think we should do here? It&apos;s certainly a strange timestamp; is the WEME&lt;br/&gt;
platform justified in complaining about it?&lt;/p&gt;

&lt;p&gt;If you change the timestamp to &apos;2007-02-23 15:47:27.544&apos;, (the value from the original test),&lt;br/&gt;
does the test then pass?&lt;/p&gt;

&lt;p&gt;If so, that seems like a reasonable fix to me.&lt;/p&gt;</comment>
                            <comment id="12755647" author="mamtas" created="Tue, 15 Sep 2009 20:12:59 +0100"  >&lt;p&gt;I took Bryan&apos;s suggestion and changed the test to use Timestamp.valueOf(&quot;2007-02-23 15:47:27.544&quot;) rather than Timestamp.valueOf(&quot;0000-00-00 15:47:28.0&quot;). This makes the test pass on weme. The change went in with revision 815452. &lt;/p&gt;

&lt;p&gt;Also, I wrote a standalone very simple test case which demonstrates the problem with weme. I am wondering if this reproduces on any other implementation of J2ME. Would appreciate if someone can give it a try.&lt;/p&gt;</comment>
                            <comment id="12755650" author="mamtas" created="Tue, 15 Sep 2009 20:15:42 +0100"  >&lt;p&gt;A very simple repro (attaching as mamta.java) which demonstrates the problem with the datetime format with weme. I am wondering if this reproduces on any other implementation of J2ME. Would appreciate if someone can give it a try. &lt;/p&gt;</comment>
                            <comment id="12756105" author="mamtas" created="Wed, 16 Sep 2009 17:53:35 +0100"  >&lt;p&gt;BTW, the test is not as standalone as I claimed yesterday. Realized last night that I am actually using the helper class TestUtil for Derby test harness to reproduce the problem. TestUtil gets a JDBC connection which will/will not use DriverManager depending on what implementation of jvm is being used ie it will detect that DriverManager can&apos;t be used if working with J2ME.&lt;/p&gt;</comment>
                            <comment id="12756249" author="mamtas" created="Wed, 16 Sep 2009 22:59:24 +0100"  >&lt;p&gt;I am attaching (timeStampDiffValue.java) which is even simpler version of the problem. This test case does not require any JDBC connection. &lt;/p&gt;

&lt;p&gt;The problem is that the output of &lt;br/&gt;
    	Timestamp.valueOf(&quot;0000-00-00 15:47:28.0&quot;)&lt;br/&gt;
is different on weme compared to IBM jdk1.6 and Sun jdk1.6. The o/p on IBM 1.6 and Sun 1.6 is same&lt;/p&gt;

&lt;p&gt;Ouptut of  System.out.println(Timestamp.valueOf(&quot;0000-00-00 15:47:28.0&quot;));&lt;br/&gt;
a)on weme 6.2 is&lt;br/&gt;
2-11-30 15:47:28.0&lt;br/&gt;
b)on IBM jdk1.6&lt;br/&gt;
0002-11-30 15:47:28.0&lt;br/&gt;
3)on Sun jdk16&lt;br/&gt;
0002-11-30 15:47:28.0&lt;/p&gt;

&lt;p&gt;This probably should be raised with weme team but it is interesting to note how (&quot;0000-00-00 15:47:28.0&quot;) is interpreted as 0002-11-30 15:47:28.0 on IBM and Sun jdk. Does anyone has any clues on how that conversion might be happening?&lt;/p&gt;</comment>
                            <comment id="12756416" author="knutanders" created="Thu, 17 Sep 2009 09:29:48 +0100"  >&lt;p&gt;The javadoc for java.util.Date says:&lt;/p&gt;

&lt;p&gt;&amp;gt; In all cases, arguments given to methods for these purposes need not&lt;br/&gt;
&amp;gt; fall within the indicated ranges; for example, a date may be&lt;br/&gt;
&amp;gt; specified as January 32 and is interpreted as meaning February 1.&lt;/p&gt;

&lt;p&gt;This explains the month and day parts of the date. 0/0 is one month&lt;br/&gt;
and one day before 1/1. This should however give year -1, not year&lt;br/&gt;
2. I found this explanation in the bug database&lt;br/&gt;
(&lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=6278731&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://bugs.sun.com/view_bug.do?bug_id=6278731&lt;/a&gt;), where the evaluation&lt;br/&gt;
note says:&lt;/p&gt;

&lt;p&gt;&amp;gt; GregorianCalendar represents a date with ERA and YEAR. 0 and&lt;br/&gt;
&amp;gt; negative year values are converted to (1 - year) with an ERA change&lt;br/&gt;
&amp;gt; to support the Julian calendar year numbering.&lt;/p&gt;

&lt;p&gt;So the year becomes (1 - year) == (1 - -1) = 2.&lt;/p&gt;</comment>
                            <comment id="12756742" author="mamtas" created="Thu, 17 Sep 2009 20:59:33 +0100"  >&lt;p&gt;Knut, thanks for taking the time to explain how 0000-00-00 is converted to 0002-11-30&lt;/p&gt;</comment>
                            <comment id="12756767" author="mamtas" created="Thu, 17 Sep 2009 21:40:23 +0100"  >&lt;p&gt;The problem was with weme jdk. Kathey will file an issue with weme team.&lt;/p&gt;</comment>
                            <comment id="12757460" author="bryanpendleton" created="Fri, 18 Sep 2009 22:44:24 +0100"  >&lt;p&gt;Thank you Knut and Mamta for tracking this down and resolving it.&lt;/p&gt;

&lt;p&gt;I was a little bit puzzled by the &quot;11-30&quot; part of the result, since as Knut&lt;br/&gt;
observes, Month=0,Day=0 should be the month and day before 1/1, which&lt;br/&gt;
in my mind is December 31, not November 30.&lt;/p&gt;

&lt;p&gt;Indeed, when I wrote this little program:&lt;/p&gt;

&lt;p&gt;Calendar c = Calendar.getInstance();&lt;br/&gt;
c.set(0, 0, 0, 12, 13, 14);&lt;br/&gt;
System.out.println(c.getTime());&lt;/p&gt;

&lt;p&gt;It prints&lt;/p&gt;

&lt;p&gt;Wed Dec 31 12:13:14 PST 0002&lt;/p&gt;

&lt;p&gt;Which confirms Knut&apos;s understanding of the year 2 anomaly, and also computes&lt;br/&gt;
December 31 for Month=0,day=0, which is what I expected.&lt;/p&gt;

&lt;p&gt;So I looked a little bit further and I see that when Timestamp.valueOf() parses&lt;br/&gt;
its string argument and constructs its timestamp, it internally uses the constructor&lt;br/&gt;
&lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/sql/Timestamp.html#Timestamp%28int,%20int,%20int,%20int,%20int,%20int,%20int%29&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/j2se/1.4.2/docs/api/java/sql/Timestamp.html#Timestamp%28int,%20int,%20int,%20int,%20int,%20int,%20int%29&lt;/a&gt;&lt;br/&gt;
which expects that day_of_month is numbered from 1-31 but month is numbered from 0-11,&lt;br/&gt;
so Timestamp.valueOf() subtracts 1 from the month, meaning that&lt;/p&gt;

&lt;p&gt;Timestamp.valueOf(&quot;0000-00-00 15:47:28.0&quot;)); &lt;/p&gt;

&lt;p&gt;is actually analogous to the Calendar code:&lt;/p&gt;

&lt;p&gt;c = Calendar.getInstance();&lt;br/&gt;
c.set(0, -1, 0, 12, 13, 14);&lt;br/&gt;
System.out.println(c.getTime());&lt;/p&gt;

&lt;p&gt;and &lt;b&gt;that&lt;/b&gt; code, inded, prints:&lt;/p&gt;

&lt;p&gt;Sun Nov 30 12:13:14 PST 0002&lt;/p&gt;

&lt;p&gt;All of this is a long and roundabout way of saying that I completely agree with everything&lt;br/&gt;
Mamta and Knut discovered, but wanted to post this anyway just in case anyone else&lt;br/&gt;
was wondering about the December 31 vs November 30 bit like I was. Here&apos;s my complete&lt;br/&gt;
program, for the curious:&lt;/p&gt;

&lt;p&gt;import java.util.Calendar;&lt;br/&gt;
import java.sql.Timestamp;&lt;br/&gt;
public class Test&lt;br/&gt;
{&lt;br/&gt;
    public static void main(String []args)&lt;/p&gt;
    {
        System.out.println(Timestamp.valueOf(&quot;0000-00-00 15:47:28.0&quot;));

        Calendar c = Calendar.getInstance();
        c.set(0, 0, 0, 12, 13, 14);
        System.out.println(c.getTime());

        c.set(0, -1, 0, 12, 13, 14);
        System.out.println(c.getTime());
    }
&lt;p&gt;}&lt;/p&gt;</comment>
                            <comment id="12757941" author="mamtas" created="Mon, 21 Sep 2009 17:20:08 +0100"  >&lt;p&gt;This is very interesting, Bryan. I had thought that since Month=0,Day=0 is month and day before 1/1, we will apply the month part first and then the day part to it, in other workd, when we will apply month before 1, we will get Dec 31st and then we will apply day before, it will get us Nov 30th.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12419669" name="mamta.java" size="644" author="mamtas" created="Tue, 15 Sep 2009 20:15:42 +0100"/>
                            <attachment id="12419824" name="timeStampDiffValue.java" size="270" author="mamtas" created="Wed, 16 Sep 2009 22:59:24 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10369"><![CDATA[Regression Test Failure]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 15 Sep 2009 13:53:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24215</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0kyf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37213</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>