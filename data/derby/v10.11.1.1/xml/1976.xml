<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:11:30 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1976/DERBY-1976.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1976] Add new utility methods to BaseJDBCTestCase to make conversion of ij tests to JUnit easier.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1976</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;As part of my work for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1758&quot; title=&quot;Enable xmlSuite to run as part of derbyall in environments that have the required external jars.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1758&quot;&gt;&lt;del&gt;DERBY-1758&lt;/del&gt;&lt;/a&gt; I&apos;m trying to convert the SQL test lang/xml_general.sql into a JUnit test.  In doing so I&apos;ve found that there are several methods which would make such a conversion easier (and more applicable across different frameworks).&lt;/p&gt;

&lt;p&gt;In particular the methods I&apos;ve found useful (and for which I plan to post a patch) are:&lt;/p&gt;

&lt;p&gt; &amp;#8211; assertSQLState():&lt;/p&gt;

&lt;p&gt;  This method already exists, but I&apos;d like to expand it so that if the top-level exception doesn&apos;t have the target SQLSTATE, the method will look at nested exceptions (if any) and try to determine if any of them match the target SQLSTATE.&lt;/p&gt;

&lt;p&gt;  This added functionality is useful in cases where we have a generic top-level SQLException that in turn has a more specific (and probably more meaningful) nested exception that is really what we want to test.&lt;/p&gt;

&lt;p&gt;  For example, master/xml_general.out has the following lines:&lt;/p&gt;

&lt;p&gt;    ij&amp;gt; &amp;#8211; XML cannot be imported or exported.  These should all fail.&lt;br/&gt;
    CALL SYSCS_UTIL.SYSCS_EXPORT_TABLE (&lt;br/&gt;
      null, &apos;T1&apos;, &apos;xmlexport.del&apos;, null, null, null);&lt;br/&gt;
    ERROR 38000: The exception &apos;java.sql.SQLException: XML values are not allowed in top-level result sets; try using XMLSERIALIZE.&apos; was thrown while evaluating an expression.&lt;br/&gt;
    ERROR 42Z71: XML values are not allowed in top-level result sets; try using XMLSERIALIZE.&lt;/p&gt;

&lt;p&gt;  Since both 38000 and 42Z71 show up in the master file we&apos;re effectively checking both of them.  With JUnit we could check both by doing something like:&lt;/p&gt;

&lt;p&gt;    assertSQLState(&quot;38000&quot;, se);&lt;br/&gt;
    assertSQLState(&quot;42Z71&quot;, se.getNextException());&lt;/p&gt;

&lt;p&gt;but that doesn&apos;t appear to work for client/server configurations because we don&apos;t actually get chained exceptions in client/server; we just get a single exception whose content is the concatenation of the top-level exception&apos;s message with the nested exception&apos;s message.  That said, if we extend assertSQLSTATE() to check nested exceptions and make that check account for the different treatment of nested exceptions in client vs embedded vs jcc, then we can check both SQLSTATEs by making two calls with the same SQLException, namely:&lt;/p&gt;

&lt;p&gt;    assertSQLSTATE(&quot;38000&quot;, se);&lt;br/&gt;
    assertSQLSTATE(&quot;42Z71&quot;, se);&lt;/p&gt;

&lt;p&gt;  Or if we don&apos;t care about 38000 but are really just interested in 42Z71, then we just make the single call for the latter and ignore the former.  Either way the call to assertSQLState() should be enhanced such that it can handle nested exceptions for all frameworks/configurations.&lt;/p&gt;

&lt;p&gt; &amp;#8211; assertCompileError():&lt;/p&gt;

&lt;p&gt;  Again, this method already exists.  But I&apos;d like to extend it so that if the call to &quot;prepareStatement(query)&quot; succeeds, the method goes on to call &quot;execute()&quot; on the prepared statement.  The reason for this is that JCC defers preparation until execution time.  Thus if we expect a compile-time error in a test and we run it against JCC, the current method will throw an assertionfailure because JCC didn&apos;t actually try to compile the query (and thus didn&apos;t throw an error).  By adding a call to &quot;execute()&quot; we force JCC to compile and therefore make it so that the method behaves as expected in all frameworks.&lt;/p&gt;

&lt;p&gt; &amp;#8211; assertStatementError():&lt;/p&gt;

&lt;p&gt;  A more generic version of assertCompileError() that doesn&apos;t care when the error happens.  This method executes the query and processes (reads and discards) all rows in the result set(s) (if any) until it hits an error.  If no error is thrown then an assertion failure occurs.&lt;/p&gt;

&lt;p&gt;  This method is useful for checking execution-time errors-&lt;del&gt;especially data-specific ones such a divide-by-zero.  For example, assume we have a query that returns 3 rows successfully but is expected to throw an error on fourth row.  In embedded mode execution of the query will occur without an error and the first three calls to &quot;rs.next()&quot; will also succeed.  Only when the fourth call to &quot;rs.next()&quot; is made will the error occur.  In JCC, though, the error occurs right away as part of the call to &quot;execute()&quot;.  By having a method that doesn&apos;t care &lt;b&gt;when&lt;/b&gt; the error occurs&lt;/del&gt;&lt;del&gt;it just asserts that the error does in fact occur at some point&lt;/del&gt;-we make it easier to check for execution-time errors across all frameworks.&lt;/p&gt;

&lt;p&gt; &amp;#8211; assertDDLRowCount():&lt;/p&gt;

&lt;p&gt;  Executes a statement using &quot;executeUpdate()&quot; and asserts that the resultant row count matches an expected row count.  This method is itself just one line:&lt;/p&gt;

&lt;p&gt;+        assertEquals(&quot;DDL row count doesn&apos;t match.&quot;,&lt;br/&gt;
+            expectedRC, st.executeUpdate(query));&lt;/p&gt;

&lt;p&gt;but by putting it in a common place we avoid having to re-type (or copy-paste) the assertion failure message every single time we want to check row counts.  Not by any means necessary, but convenient enough to warrant inclusion in BaseJDBCTestCase, I think.&lt;/p&gt;

&lt;p&gt; &amp;#8211; assertRowCount():&lt;/p&gt;

&lt;p&gt;  Takes a result set and an expected row count and simply iterates through the result set, counting the number of rows.  Then asserts that the actual and expected row counts are the same.&lt;/p&gt;

&lt;p&gt; &amp;#8211; assertFullResultSet():&lt;/p&gt;

&lt;p&gt;  Takes a result set and a two-dimensional array and asserts that the two have equivalent rows and columns.  The first row in the 2-d array is expected to be the names of the columns and thus is compared to the metadata column names.  Subsequent rows in the array are then compared with the corresponding rows in the result set.&lt;/p&gt;

&lt;p&gt;  This method is useful when converting the output of a query from a .sql test into a JUnit test.  Test writers (or perhaps more importantly, some wouldn&apos;t-it-be-nice conversion tool) can create the 2-D array based on the master file and then call this method to verify that the rows and columns in the result set are all as expected.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12353448">DERBY-1976</key>
            <summary>Add new utility methods to BaseJDBCTestCase to make conversion of ij tests to JUnit easier.</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12330375">DERBY-1122</parent>
                                    <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="army">A B</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 Oct 2006 23:46:32 +0100</created>
                <updated>Sat, 21 Oct 2006 04:21:09 +0100</updated>
                            <resolved>Sat, 21 Oct 2006 04:20:58 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Test</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12443108" author="army" created="Tue, 17 Oct 2006 23:53:13 +0100"  >&lt;p&gt;Attaching a patch, d1976_v1.patch, that adds the methods described in the description for this issue.  For more details, please see the code comments.&lt;/p&gt;

&lt;p&gt;I ran the JUnit suite &quot;suites.All&quot; against ibm142, jdk142, ibm15, jdk15, and jdk16 on a Windows 2000 machine.  The only failure I saw was an intermittent failure in LobLengthTest on jdk15:&lt;/p&gt;

&lt;p&gt;There was 1 error:&lt;br/&gt;
1) testLongLobLengths(org.apache.derbyTesting.functionTests.tests.jdbcapi.LobLengthTest)&lt;br/&gt;
   java.sql.SQL Exception: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ001, SQLERRMC:&lt;br/&gt;
   org.apache.derby.shared.common.sanity.AssertFailure#ASSERT FAILED Container closed&lt;br/&gt;
   while IO operations are in progress.  This should not happen.#XJ001.U&lt;br/&gt;
        at org.apache.derby.client.am.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:46)&lt;br/&gt;
        at org.apache.derby.client.am.SqlException.getSQLException(SqlException.java:345)&lt;br/&gt;
        at org.apache.derby.client.am.Connection.commit(Connection.java:555)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseJDBCTestCase.commit(BaseJDBCTestCase.java:159)&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.LobLengthTest.tearDown(LobLengthTest.java:87)&lt;br/&gt;
        at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:76)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
        at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
   Caused by: org.apache.derby.client.am.SqlException: DERBY SQL error: SQLCODE: -1,&lt;br/&gt;
   SQLSTATE: XJ001, SQLERRMC: org.apache.derby.shared.common.sanity.AssertFailure#ASSERT&lt;br/&gt;
   FAILED Container closed while IO operations are in progress.  This should not happen.#XJ001.U&lt;br/&gt;
        at org.apache.derby.client.am.Connection.completeSqlca(Connection.java:1920)&lt;br/&gt;
        at org.apache.derby.client.net.NetConnectionReply.parseRDBCMMreply(NetConnectionReply.java:215)&lt;br/&gt;
        at org.apache.derby.client.net.NetConnectionReply.readLocalCommit(NetConnectionReply.java:147)&lt;br/&gt;
        at org.apache.derby.client.net.ConnectionReply.readLocalCommit(ConnectionReply.java:43)&lt;br/&gt;
        at org.apache.derby.client.net.NetConnection.readLocalCommit_(NetConnection.java:1574)&lt;br/&gt;
        at org.apache.derby.client.am.Connection.readCommit(Connection.java:639)&lt;br/&gt;
        at org.apache.derby.client.am.Connection.flowCommit(Connection.java:588)&lt;br/&gt;
        at org.apache.derby.client.am.Connection.commit(Connection.java:551)&lt;br/&gt;
        ... 33 more&lt;/p&gt;

&lt;p&gt;This error occurred once as part of suites.All but did not occur when I ran the test separately and also did not occur when I re-ran the suite a second time.  So I don&apos;t know if this is specific to jdk15 or not-- but in any event, I don&apos;t think this is related to my changes.&lt;/p&gt;

&lt;p&gt;Review comments/feedback/commit would be much appreciated...&lt;/p&gt;</comment>
                            <comment id="12443111" author="djd" created="Wed, 18 Oct 2006 00:00:02 +0100"  >&lt;p&gt;Some of these methods might be better in org.apache.derbyTesting.junit.JDBC&lt;/p&gt;

&lt;p&gt;E.g. expanding assertDrainResultSet to alos take a row count would provide better testing than a simple row count.&lt;/p&gt;

&lt;p&gt;assertDDLRowCount() would be better named as assertUpdateCount() since that&apos;s what I think it is testing.&lt;/p&gt;
</comment>
                            <comment id="12443558" author="army" created="Thu, 19 Oct 2006 16:44:59 +0100"  >&lt;p&gt;Attaching a second version of the patch, d1976_v2.patch, which has the following changes w.r.t to the _v1 patch (following based on Dan&apos;s comments):&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Moves &quot;assertFullResultSet()&quot; and its corresponding methods out of the BaseJDBCTestCase class and into the JDBC class.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Changes JDBC.assertDrainResults() to accept a row count and, if the row count is non-negative, to assert that the number of rows in the received result set matches the received row count.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removes assertRowCount() from BaseJDBCTestCase (it&apos;s now incorporated into JDBC.assertDrainResults() as mentioned above).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Renames &quot;assertDDLRowCount()&quot; to &quot;assertUpdateCount()&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I ran &quot;suites.All&quot; with ibm142 and jdk142 and saw no failures.  Unless there are any other review comments, I think this patch is ready for commit...&lt;/p&gt;</comment>
                            <comment id="12443571" author="djd" created="Thu, 19 Oct 2006 17:34:12 +0100"  >&lt;p&gt;Committed revision 465673.  - Thanks Army.&lt;/p&gt;</comment>
                            <comment id="12443578" author="djd" created="Thu, 19 Oct 2006 17:58:10 +0100"  >&lt;p&gt;I&apos;ve committed the patch but have some possible improvement ideas.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;JDBC.assertDrainResults(rs);&lt;br/&gt;
+		JDBC.assertDrainResults(rs, -1);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To avoid diffs like this and the calling requirement to have a -1 parameter, a typical solution is to overload the assertDrainResults method so there is one variant with a single argument (the result set) and that method calls the two argument one passing -1.&lt;/p&gt;

&lt;p&gt;I think passing the column names as the &quot;first/zeroth&quot; row of the results is not a good approach, subject to confusion during development and test failures.&lt;br/&gt;
For example, this assert:&lt;br/&gt;
+        // And finally, assert the row count.&lt;br/&gt;
+        Assert.assertEquals(&quot;Unexpected row count:&quot;, expectedRows.length, rows);&lt;br/&gt;
will be confusing when it fails because a ResultSet that returns three rows instead of seven will actually throw an assert saying:&lt;br/&gt;
  Unexpected row count: expected 8 got 4 (or similar text)&lt;br/&gt;
Very confusing when someone runs the same query in ij and sees three rows.&lt;br/&gt;
I think it would be clearer to explicitly pass in a String[] of column names or even separate out out checking of the ResultSetMetaData from&lt;br/&gt;
the checking of the data. Clarity is good.&lt;/p&gt;

&lt;p&gt;assertRowInResultSet() allows for the ResultSetMetaData to be from a different ResultSet or PreparedStatement. If that was not intentional then it&apos;s probably better not passing in the ResultSetMetaData, but instead obtaining from the ResultSet.&lt;/p&gt;

&lt;p&gt;For assertFullResultSet could make it clearer in its javadoc that the order of the ResultSet must match the order of the passed in data. it&apos;s there but hidden, a clear statement in the first sentence would help.&lt;/p&gt;

&lt;p&gt;I assume with assertRowInResultSet() that the expected value can be a Java null to indicate a SQL NULL, seems like it from the code, but it&apos;s not documented anywhere.&lt;/p&gt;

&lt;p&gt;When calling assertRowInResultSet() with asStrings=true the value obtained from getString() has trim called on it. I have two issues with this:&lt;br/&gt;
  1) This behaviour is not documented in the javadoc for the method.&lt;br/&gt;
  2) For a CHAR column I have to pass different values in the expected array depending on the setting of asStrings, this seems like an opportunity for confusion and mistakes.&lt;br/&gt;
         &quot;FRED    &quot;  if asStrings=false&lt;br/&gt;
         &quot;FRED&quot;      if asStrings=true&lt;/p&gt;


</comment>
                            <comment id="12443663" author="army" created="Thu, 19 Oct 2006 23:58:34 +0100"  >&lt;p&gt;&amp;gt; I&apos;ve committed the patch but have some possible improvement ideas. &lt;/p&gt;

&lt;p&gt;Thanks for committing, Dan, and for the further suggestions.&lt;/p&gt;

&lt;p&gt;I&apos;m attaching d1758_followup_v1.patch which address Dan&apos;s comments.&lt;/p&gt;

&lt;p&gt;&amp;gt; - JDBC.assertDrainResults(rs);&lt;br/&gt;
&amp;gt; + JDBC.assertDrainResults(rs, -1);&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; To avoid diffs like this and the calling requirement to have a -1 parameter, &lt;br/&gt;
&amp;gt; a typical solution is to overload the assertDrainResults method&lt;/p&gt;

&lt;p&gt;Changed as suggested.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think passing the column names as the &quot;first/zeroth&quot; row of the results is &lt;br/&gt;
&amp;gt; not a good approach, subject to confusion during development and test &lt;br/&gt;
&amp;gt; failures.&lt;/p&gt;

&lt;p&gt;Separated assertion of column names out into its own method, as requested.&lt;/p&gt;

&lt;p&gt;&amp;gt; assertRowInResultSet() allows for the ResultSetMetaData to be from a &lt;br/&gt;
&amp;gt; different ResultSet or PreparedStatement.&lt;/p&gt;

&lt;p&gt;Changed as suggested.&lt;/p&gt;

&lt;p&gt;&amp;gt; For assertFullResultSet could make it clearer in its javadoc that the order &lt;br/&gt;
&amp;gt; of the ResultSet must match the order of the passed in data.&lt;/p&gt;

&lt;p&gt;Updated javadoc to say this.&lt;/p&gt;

&lt;p&gt;&amp;gt; I assume with assertRowInResultSet() that the expected value can be a &lt;br/&gt;
&amp;gt; Java null to indicate a SQL NULL, seems like it from the code, but it&apos;s not &lt;br/&gt;
&amp;gt; documented anywhere.&lt;/p&gt;

&lt;p&gt;Updated javadoc to say this.&lt;/p&gt;

&lt;p&gt;&amp;gt; When calling assertRowInResultSet() with asStrings=true the value &lt;br/&gt;
&amp;gt; obtained from getString() has trim called on it. I have two issues with this:&lt;br/&gt;
&amp;gt; 1) This behaviour is not documented in the javadoc for the method.&lt;/p&gt;

&lt;p&gt;Updated javadoc to describe this behavior.&lt;/p&gt;

&lt;p&gt;&amp;gt;  2) For a CHAR column I have to pass different values in the expected array depending on the setting of asStrings, this seems like an opportunity for confusion and mistakes.&lt;br/&gt;
         &quot;FRED &quot; if asStrings=false&lt;br/&gt;
         &quot;FRED&quot; if asStrings=true&lt;/p&gt;

&lt;p&gt;In an attempt to make this clearer, I renamed the parameter  to &quot;asTrimmedStrings&quot; and made it so that, if true, the code will trim the expected value as well as the rs.getString() value.  This way anyone writing tests just has to decide whether or not they care about leading/trailing whitespace.  If so, then asTrimmedStrings should be false; otherwise such whitespace will be ignored (if present in the &quot;expected&quot; values).&lt;/p&gt;

&lt;p&gt;Is that, combined with the appropriate javadoc, any better?  If not, I&apos;m open to other suggestions...&lt;/p&gt;

&lt;p&gt;Thanks again for taking the time to provide feedback.&lt;/p&gt;</comment>
                            <comment id="12443668" author="djd" created="Fri, 20 Oct 2006 00:34:25 +0100"  >&lt;p&gt;Committed revision 465935 - patch  d1976_followup_v1.patch  - Thanks for making the improvements Army, the asTrimmedString was a cool idea.&lt;/p&gt;</comment>
                            <comment id="12443995" author="army" created="Sat, 21 Oct 2006 04:20:58 +0100"  >&lt;p&gt;Thank you for reviewing and committing the follow-up patch as well, Dan.  I verified the changes in trunk and so am closing this issue.  For an example test that uses the methods added in this issue, see the &quot;newJUnitTest&quot; patch attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1758&quot; title=&quot;Enable xmlSuite to run as part of derbyall in environments that have the required external jars.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1758&quot;&gt;&lt;del&gt;DERBY-1758&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12343301" name="d1976_followup_v1.patch" size="13272" author="army" created="Thu, 19 Oct 2006 23:58:34 +0100"/>
                            <attachment id="12343116" name="d1976_v1.patch" size="15644" author="army" created="Tue, 17 Oct 2006 23:53:13 +0100"/>
                            <attachment id="12343273" name="d1976_v2.patch" size="17757" author="army" created="Thu, 19 Oct 2006 16:44:59 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 17 Oct 2006 23:00:02 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30211</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy143r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40315</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>