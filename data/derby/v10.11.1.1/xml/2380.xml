<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:30:55 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2380/DERBY-2380.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2380] A statement plan holds onto resources such as its generated class even after it has been invalidated.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2380</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;An internal plan (instance of GenericPreparedStatement) can be invalidated by other SQL operations such as DROP TABLE or DROP INDEX.&lt;br/&gt;
When this happens the references to objects that are no longer useful such as the generated class and saved objects are held onto and thus use memory.&lt;br/&gt;
If the statement is re-compiled then these objects will be handled by garbage collection.&lt;/p&gt;

&lt;p&gt;If the statement is not recompiled though, then these objects will remain until the plan (GenericPreparedStatement) is garbage collected.&lt;br/&gt;
The plan being garbage collected can be held up for two reasons:&lt;br/&gt;
   1) The plan is in the statement cache. Note that only in some cases does it make sense to remove an invalid plan from the statement cache, e.g. a DROP TABLE should remove any plan that uses that table, but a DROP TRIGGER should not remove an INSERT from the cache, as it is likely the plan will be re-used and re-compiled. This  is a separate issue given that the memory usage can occur even if the plan is not in the cache.&lt;br/&gt;
   2) The application holds onto a JDBC PreparedStatement that uses the plan.&lt;/p&gt;

&lt;p&gt;Given an application should not be able to affect memory usage like this then the GenericPreparedStatement.makeInvalid() call should null out fields that hold references to objects that have become invalid.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12363830">DERBY-2380</key>
            <summary>A statement plan holds onto resources such as its generated class even after it has been invalidated.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                            <label>derby_triage10_5_2</label>
                    </labels>
                <created>Wed, 28 Feb 2007 21:21:45 +0000</created>
                <updated>Mon, 10 Feb 2014 14:28:28 +0000</updated>
                                            <version>10.0.2.0</version>
                    <version>10.0.2.1</version>
                    <version>10.1.1.0</version>
                    <version>10.1.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                    <version>10.2.2.0</version>
                    <version>10.3.1.4</version>
                                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12476806" author="djd" created="Thu, 1 Mar 2007 01:18:01 +0000"  >&lt;p&gt;First, some cleanup is needed for stored prepared statements (which are used for JDBC meta-data queries and triggers).&lt;br/&gt;
ExecSPSNode has this code (generate)&lt;/p&gt;

&lt;p&gt;		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;The following does a prepare on the underlying&lt;/li&gt;
		&lt;li&gt;statement if necessary.  The returned statement&lt;/li&gt;
		&lt;li&gt;is valid and its class is loaded up.&lt;br/&gt;
		*/&lt;br/&gt;
		ps = spsd.getPreparedStatement();&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;However the returned statement is &quot;partially valid&quot;, it&apos;s isValid field is set to false because SPSDescriptor performed a makeInvalid() on it when it compiles the stored plan the first time. SPSDescriptor then holds onto this &quot;partially valid&quot; to provide the compiled information for the real running of the statement through the internal  EXECUTE STATEMENT command. Applying the obvious fix for this bug, nulling out the compiled information, then leaves the prepared statement used by SPS in a fully invalid state, causing NullPointerExceptions as all the compiled information has been removed.&lt;/p&gt;

&lt;p&gt;Having a &quot;partially valid&quot; state is not a good design, it complicates the already hard to understand SPS code. Will be looking at ways to avoid this so that a makeInvalid() on a language prepared statement (plan) can always make the object invalid.&lt;/p&gt;</comment>
                            <comment id="12476933" author="djd" created="Thu, 1 Mar 2007 13:36:01 +0000"  >&lt;p&gt;A GenericPreparedStatement instance can used in various situations and the resuling handling of its state in these situations is awkward.&lt;br/&gt;
The various situations are in the statement cache and unused, in the cache and in use, referenced in a JDBC prepared statement with an activation, attached to an SPSDescriptor without an activation, in-use in a trigger.&lt;br/&gt;
The state handling involves a use-count (for existing activations), the check to see if the plan is being cache and the &quot;partially valid&quot; state for the SPS mentioned in the previous comment.&lt;/p&gt;

&lt;p&gt;Ideally just having a reference to a GenericPreparedStatement would keep it valid.&lt;/p&gt;

&lt;p&gt;Looking at ways to clean this up it seems that the root cause is the DependencyManager. The DependencyManager is implementing the Observer pattern but in a non-java way.&lt;br/&gt;
&lt;a href=&quot;http://www.research.umbc.edu/~tarr/dp/lectures/Observer.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.research.umbc.edu/~tarr/dp/lectures/Observer.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since the GenericPreparedStatement instance is held onto in a central DependencyManager object, then some state is needed as to when it should be removed from that list,handling dependencies the &quot;java way&quot; would instead mean the list of dependents is held in the object itself, not a central list.&lt;br/&gt;
Now the Java Observable class has some issues, but I wonder if the pattern should be applied here. Persistent dependencies cause some issues but I just wanted to throw my thoughts out there.&lt;/p&gt;</comment>
                            <comment id="12478685" author="djd" created="Wed, 7 Mar 2007 05:01:08 +0000"  >&lt;p&gt;In looking more at this issue (along with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2397&quot; title=&quot;Dropping SQL objects could be improved by reducing the number of classes required.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2397&quot;&gt;DERBY-2397&lt;/a&gt;) I think the dependency manager would be much cleaner if only persistent objects could be Providers.&lt;br/&gt;
Persistent objects are much better suited to the DependencyManager because there is a definite termination of the object, the DROP statement.&lt;/p&gt;

&lt;p&gt;This would mean GenericPreparedStatement  (GPS) would not be a Provider, i.e. no -one could create a dependency on a compiled plan.  This causes problems because now some action must be taken when a GPS is no longer in use, to invalidate anything that depends on it. Not performing the invalidation would lead to a memory leak in the dependency manager. This need to know who is using a GPS has lead to the usage count, the partially valid state, generally not a clean way of handling its lifecycle. Not having GPS be a Provider would mean GPS would be like a typical java object, having a reference to the object allows it to be used.&lt;br/&gt;
GPS is also (I think) the only non-persistent object that is a Provider.&lt;/p&gt;

&lt;p&gt;The only case where one plan depends on another  today is when a positioned update/delete plan (GPS) depends on the plan (GPS) for the open cursor.&lt;/p&gt;

&lt;p&gt;I don&apos;t think this dependency is needed because the positioned update/delete will depend on the table being modified during its compilation.&lt;br/&gt;
Thus if the cursor changes due to any change in the base table, then the positioned statement will be invalidated anyway.&lt;br/&gt;
The positioned code already has a different mechanism to handle when the cursor changes to a different plan (which isn&apos;t triggered by an invalidation on the original cursor, since the original cursor plan may still be valid).&lt;br/&gt;
Cursor change/invalidations are  tested for in CurrentOfTest. I also added some new test fixtures to cover additional situations where the positioned statement needs to be invalidated or work against a different cursor.&lt;/p&gt;

&lt;p&gt;I have changes where this GenericPreparedStatement is no longer implements Provider and thus the positioned update/delete - cursor dependency does not exist. This basically works though various errors change from &quot;cursor not found&quot; to &quot;cursor is closed&quot; and vice-versa. This would be a step to cleanup the life-cycle state of GenericPreparedStatement, thus leading to being able to null out its compile objects once it becomes invalid (ie. current plan is invalid but the object could be reprepared to make it valid again).&lt;/p&gt;

&lt;p&gt;The change in errors is interesting, it&apos;s basically because the old code always threw &apos;cursor is closed&apos; at runtime if the positioned update/delete could not find a matching cursor (having successfully compiled against one). I&apos;m not sure this is correct, I tried to mimic the old behaviour by throwing &apos;cursor not found&apos; if the connection does not have any open activations with that name, and &apos;cursor is closed&apos; if the connection has an open activation (ie. java.sql.PreparedStatement)  with that name, but no open result set. But I&apos;m not sure if that is valid, one viewpoint could be that if there is no open cursor then the cursor doesn&apos;t exist and thus there is no such error as &apos;cursor is closed&apos;. I couldn&apos;t see from the SQL spec any specific guidance on this (looking at DECLARE/OPEN and positioned UPDATE &amp;amp; DELETE), if anyone has any thoughts ...&lt;/p&gt;


</comment>
                            <comment id="12479610" author="mamtas" created="Fri, 9 Mar 2007 15:13:47 +0000"  >&lt;p&gt;Dan, one of the checkins that went for this Jira entry is 516286 and it says that there is no such state as a closed cursor, only open or non-existent. Does that mean that we don&apos;t need the SQLState XCL07 (Cursor &apos;&lt;/p&gt;
{0}
&lt;p&gt;&apos; is closed. Verify that autocommit is OFF.) anymore? &lt;/p&gt;</comment>
                            <comment id="12479643" author="djd" created="Fri, 9 Mar 2007 16:48:54 +0000"  >&lt;p&gt;Yes - XCL07 can be removed, wasn&apos;t sure how to do it at the time with the recent change to (half) an xml format.&lt;/p&gt;</comment>
                            <comment id="12727750" author="rhillegas" created="Mon, 6 Jul 2009 21:12:35 +0100"  >&lt;p&gt;Unassigning this issue since there has been no activity in more than a year.&lt;/p&gt;</comment>
                            <comment id="12727752" author="rhillegas" created="Mon, 6 Jul 2009 21:13:11 +0100"  >&lt;p&gt;Triaged for 10.5.2: assigned normal urgency.&lt;/p&gt;</comment>
                            <comment id="13894663" author="knutanders" created="Fri, 7 Feb 2014 16:03:34 +0000"  >&lt;p&gt;One possible incremental improvement is to clear the activation class in GenericPreparedStatement when the statement is invalidated. GenericStatement does this before repreparing a GPS, so the code is already prepared to handle the case where the activation class is null.&lt;/p&gt;

&lt;p&gt;The attached patch d2380-clear-activation-class.diff makes this change, and also refactors the code so that it&apos;s shared between reprepare and invalidate.&lt;/p&gt;

&lt;p&gt;All regression tests ran cleanly. I also hand-tested to see that the activation classes of invalidated statements could be garbage collected immediately. Without the patch, one had to wait until they had either been recompiled or evicted from the statement cache before they could be garbage collected.&lt;/p&gt;</comment>
                            <comment id="13896595" author="jira-bot" created="Mon, 10 Feb 2014 14:28:28 +0000"  >&lt;p&gt;Commit 1566635 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knutanders&quot; class=&quot;user-hover&quot; rel=&quot;knutanders&quot;&gt;Knut Anders Hatlen&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1566635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1566635&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2380&quot; title=&quot;A statement plan holds onto resources such as its generated class even after it has been invalidated.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2380&quot;&gt;DERBY-2380&lt;/a&gt;: Make the generated class eligible for gc once the statement is invalidated&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12387520">DERBY-3368</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12362990">DERBY-2344</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12379623">DERBY-3102</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12627644" name="d2380-clear-activation-class.diff" size="3196" author="knutanders" created="Fri, 7 Feb 2014 16:03:34 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 9 Mar 2007 15:13:47 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23030</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ij3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36820</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>