<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:38:25 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1866/DERBY-1866.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1866] Assert failure in sane mode for queries that used to work in 10.1.2.1</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1866</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Derby-1777 gives a database and a small program called &quot;ViewerInit&quot; that prepares a bunch of large queries involving nested subqueries, unions, and join predicates.  The actual bug described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt; is an NPE, and that&apos;s what the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt; addresses.&lt;/p&gt;

&lt;p&gt;However, once the NPEs are fixed, some of the queries in that same program now fail with ASSERT failures when running in SANE mode; this Jira issue is for addressing those assert failures.&lt;/p&gt;

&lt;p&gt;While this does constitute a regression, I don&apos;t know yet what the root cause of the problem is, so I hesitate to make it a 10.2 blocker--hence urgency is &quot;Normal&quot;.  I&apos;m still investigating the queries to try to track down where the problem is, but all I&apos;ve been able to deduce so far is that a) the assertion occurs for a scoped predicate and thus the pushing of join predicates into UNIONs is somehow involved, and b) in INSANE mode the query compiles without problem and appears (based on some early and very incomplete testing) to execute without problem.  But more investigation is required to determine if the execution/results are actually correct, and to understand more about why the assertion is being thrown.&lt;/p&gt;

&lt;p&gt;I&apos;m marking the fixin as 10.2.2.0 for now since I don&apos;t enough to make this a blocker for 10.2.1.  Hopefully more info will be forthcoming...&lt;/p&gt;</description>
                <environment></environment>
        <key id="12350272">DERBY-1866</key>
            <summary>Assert failure in sane mode for queries that used to work in 10.1.2.1</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="army">A B</reporter>
                        <labels>
                    </labels>
                <created>Tue, 19 Sep 2006 19:26:12 +0100</created>
                <updated>Mon, 5 Jul 2010 18:32:45 +0100</updated>
                            <resolved>Mon, 2 Oct 2006 17:08:20 +0100</resolved>
                                    <version>10.1.3.2</version>
                    <version>10.1.3.3</version>
                    <version>10.2.1.6</version>
                                    <fixVersion>10.1.3.3</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12435965" author="army" created="Tue, 19 Sep 2006 19:35:02 +0100"  >&lt;p&gt;Attaching a derby.log file that contains the ASSERT failure.  Note that the query in this case is slightly modified from one of the queries in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt; (the queries in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt; tend to take a very long time to compile; I shortened the query a bit and was still able to see the error).&lt;/p&gt;</comment>
                            <comment id="12436420" author="army" created="Thu, 21 Sep 2006 03:12:59 +0100"  >&lt;p&gt;Quick update on where things are with this issue:&lt;/p&gt;

&lt;p&gt;  1. I was (finally) able to come up with a quick and easy repro to &lt;br/&gt;
    demonstrate the ASSERT failure in SANE mode.  I&apos;m attaching &lt;br/&gt;
    a script, repro.sql, that can be run to show the failure.  The repro &lt;br/&gt;
    script also contains another query that is very similar to the first, &lt;br/&gt;
    but the second query appears to hang or otherwise run for a very, &lt;br/&gt;
    very long time, even though it should execute in about a second&lt;br/&gt;
     or so.&lt;/p&gt;

&lt;p&gt;  2. With the repro attached to this issue, attempts to run in INSANE mode will&lt;br/&gt;
     result in an IndexOutOfBounds error--so this issue does not just &quot;go away&quot;&lt;br/&gt;
     in insane mode; it is a legitimate regression.&lt;/p&gt;

&lt;p&gt;  3. Now the interesting thing: both of the repro queries SUCCEED as expected against&lt;br/&gt;
     the 10.1 codeline.  This means that the failures are not part of the initial&lt;br/&gt;
     optimizer work (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;) that went into 10.1, nor are they inherently caused&lt;br/&gt;
     by any of the recent optimizer changes that have been ported back to 10.1&lt;br/&gt;
     (namely, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1365&quot; title=&quot;Address potential problems with optimizer logic in some rarely-exercised code.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1365&quot;&gt;&lt;del&gt;DERBY-1365&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1633&quot; title=&quot;Regression: The fields of views are not being calculated properly since 10.1.2.4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1633&quot;&gt;&lt;del&gt;DERBY-1633&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1681&quot; title=&quot;Regression (wrong results): Join predicate can be ignored for left-most child in a chain of nested unions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1681&quot;&gt;&lt;del&gt;DERBY-1681&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1315&quot; title=&quot;Statement optimization/compilation fails with OutOfMemoryException in largeCodeGen test  with embedded and framework DerbyNetClient&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1315&quot;&gt;&lt;del&gt;DERBY-1315&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;     The repro script passes against the 10.1.3 jars and against a fully-synced&lt;br/&gt;
     10.1 codeline.  But it fails against the first 10.2 beta candidate and&lt;br/&gt;
     all subsequent candidates; it also fails against the current 10.2 codeline&lt;br/&gt;
     and the 10.3 trunk.&lt;/p&gt;

&lt;p&gt;     So my natural deduction was that some other optimizer-related change has&lt;br/&gt;
     been checked into 10.2 and 10.3 that is not in 10.1, and that&apos;s the cause&lt;br/&gt;
     of the failure.  But after I applied all such changes (that I could think&lt;br/&gt;
     of) to the 10.1 codeline, the repro scripts still pass in 10.1 and fail&lt;br/&gt;
     in 10.2/10.3.  The patches I ported to 10.1 (locally) were &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1357&quot; title=&quot;Short-circuit logic in optimizer appears to be incorrect...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1357&quot;&gt;&lt;del&gt;DERBY-1357&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
     &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-781&quot; title=&quot;Materialize subqueries in select list where possible to avoid creating invariant resultsets many times.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-781&quot;&gt;&lt;del&gt;DERBY-781&lt;/del&gt;&lt;/a&gt;, and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-634&quot; title=&quot;Subquery materialization can cause stack overflow&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-634&quot;&gt;&lt;del&gt;DERBY-634&lt;/del&gt;&lt;/a&gt;.  As far as I could tell based on a quick glance&lt;br/&gt;
     at the 10.2 release notes, no other optimizer changes were made after the&lt;br/&gt;
     10.1.3 release.  I also did a diff of the latest 10.1 trunk with the&lt;br/&gt;
     latest 10.3 trunk bewteen the files that have been involved in the&lt;br/&gt;
     recent optimizer work, and I couldn&apos;t see any diffs that might suggest&lt;br/&gt;
     why the repro queries pass for 10.1 but fail for everything else.&lt;/p&gt;

&lt;p&gt;I&apos;m still investigating the bizarre behavior for #3.  If anyone offhand can think of any changes that are in 10.2/10.3 but not in 10.1 that might be responsible for these failures, I&apos;d certainly appreciate the help.  Right now I&apos;m planning to 1) go back through the release notes for 10.2 more carefully to see if I&apos;ve missed anything, and 2) make sure all of the patches applied cleanly when I ported them (locally) to 10.1; maybe something went wrong somewhere...?&lt;/p&gt;

&lt;p&gt;In any event, to run the repro, do the following:&lt;/p&gt;

&lt;p&gt;&amp;gt; java -Dderby.optimizer.noTimeout=true org.apache.derby.tools.ij&lt;br/&gt;
ij&amp;gt; connect &apos;jdbc:derby:tstdb;create=true&apos;;&lt;br/&gt;
ij&amp;gt; run &apos;repro.sql&apos;;&lt;/p&gt;

&lt;p&gt;Against 10.2 and 10.3 you should see an ASSERT failure for the first query; if you comment out the first query, you should see an apparent hang for the second query.  But against 10.1, both queries run successfully and quickly (less than a second).&lt;/p&gt;
</comment>
                            <comment id="12436522" author="army" created="Thu, 21 Sep 2006 13:56:50 +0100"  >&lt;p&gt;Okay, forget about #3 above:&lt;/p&gt;

&lt;p&gt;After a night&apos;s sleep it occurred to me why the repro &quot;passes&quot; in 10.1 but not in 10.2 or 10.3.  The reason is that the repro relies on behavior dictated by optimizer overrides (DERBY-PROPERTIES), but such overrides are not recognized in 10.1 and thus they are treated as SQL comments and are ignored.&lt;/p&gt;

&lt;p&gt;I haven&apos;t tried it yet, but I imagine that if I ported the optimizer overrides patch to 10.1, the repro would fail there; similarly, if I remove the optimizer overrides from the repro queries, they will probably pass in 10.2 and 10.3.&lt;/p&gt;

&lt;p&gt;So short story: we do have a legitimate regression, and now that we have a repro, I&apos;m working to find the problem...&lt;/p&gt;</comment>
                            <comment id="12436559" author="rhillegas" created="Thu, 21 Sep 2006 16:40:57 +0100"  >&lt;p&gt;Thanks for looking into this, Army. I have a couple comments:&lt;/p&gt;

&lt;p&gt;1) What happens if you run the repro against an insane (e.g., production-ready) 10.2?&lt;/p&gt;

&lt;p&gt;2) I&apos;m confused about whether this is a regression. It sound as though, if you could force the query plan in 10.1 (as you can in 10.2), then the bug would surface in 10.1 as well. From your description, this seems like a pre-existing bug which we are now able to script and (eventually) fix because of optimizer overrides.&lt;/p&gt;</comment>
                            <comment id="12436569" author="army" created="Thu, 21 Sep 2006 17:02:52 +0100"  >&lt;p&gt;&amp;gt; 1) What happens if you run the repro against an insane (e.g., production-ready) 10.2? &lt;/p&gt;

&lt;p&gt;The result is an IndexOutOfBoundsException at execution time:&lt;/p&gt;

&lt;p&gt;ERROR 38000: The exception &apos;java.lang.ArrayIndexOutOfBoundsException: -1&apos; was thrown while evaluating an expression.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) I&apos;m confused about whether this is a regression.&lt;/p&gt;

&lt;p&gt;Good question, sorry for not being clear here.  This is a regression in the same way that &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1633&quot; title=&quot;Regression: The fields of views are not being calculated properly since 10.1.2.4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1633&quot;&gt;&lt;del&gt;DERBY-1633&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1781&quot; title=&quot;Process handles appear to be leaking in queries using an IN clause during concurrent DB access&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1781&quot;&gt;&lt;del&gt;DERBY-1781&lt;/del&gt;&lt;/a&gt;, etc. are regressions: namely, queries used to work correctly at one point in 10.2, but then as a result of optimizer changes (esp. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;) they no longer work.  As it turns out, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; was also ported back to 10.1.2.4 and thus the regressions also occur in the recent 10.1 codeline/release.  That&apos;s why the changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1633&quot; title=&quot;Regression: The fields of views are not being calculated properly since 10.1.2.4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1633&quot;&gt;&lt;del&gt;DERBY-1633&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1681&quot; title=&quot;Regression (wrong results): Join predicate can be ignored for left-most child in a chain of nested unions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1681&quot;&gt;&lt;del&gt;DERBY-1681&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;, and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1315&quot; title=&quot;Statement optimization/compilation fails with OutOfMemoryException in largeCodeGen test  with embedded and framework DerbyNetClient&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1315&quot;&gt;&lt;del&gt;DERBY-1315&lt;/del&gt;&lt;/a&gt; have all been ported back to 10.1.&lt;/p&gt;

&lt;p&gt;So if you define &quot;regression&quot; as &quot;worked in the latest 10.1 release but fails in 10.2&quot;, then neither this nor any of the other issues were technically &quot;regressions&quot; for 10.2--because they all demonstrate bugs that exist in 10.1.3 and 10.2 alike.  But the truth is that the queries &lt;b&gt;did&lt;/b&gt; work in 10.1 and they &lt;b&gt;did&lt;/b&gt; work in 10.2 before the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes went in, and now they don&apos;t work in either.&lt;/p&gt;

&lt;p&gt;&amp;gt; then the bug would surface in 10.1 as well. From your description, this seems like a &lt;br/&gt;
&amp;gt; pre-existing bug which we are now able to script and (eventually) fix because of&lt;br/&gt;
&amp;gt; optimizer overrides.&lt;/p&gt;

&lt;p&gt;Yes, &quot;pre-existing&quot; in 10.1 because the code that caused the regression was (unfortunately) ported back to 10.1, as well...&lt;/p&gt;

&lt;p&gt;I can&apos;t seem to put it in the right words, but hopefully that makes more sense...?&lt;/p&gt;</comment>
                            <comment id="12436572" author="rhillegas" created="Thu, 21 Sep 2006 17:12:20 +0100"  >&lt;p&gt;Thanks for the quick response, Army. Does this bug appear in the current 10.1.3 release?&lt;/p&gt;</comment>
                            <comment id="12436581" author="army" created="Thu, 21 Sep 2006 17:52:36 +0100"  >&lt;p&gt;&amp;gt; Does this bug appear in the current 10.1.3 release?&lt;/p&gt;

&lt;p&gt;Since 10.1.3 doesn&apos;t have support for optimizer overrides, I can&apos;t run the repro against it to see.  I also can&apos;t run the original query from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt; because the other regressions (esp. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1633&quot; title=&quot;Regression: The fields of views are not being calculated properly since 10.1.2.4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1633&quot;&gt;&lt;del&gt;DERBY-1633&lt;/del&gt;&lt;/a&gt;) haven&apos;t been fixed in the 10.1.3 release and thus will cause the query to fail before ever reaching the condition for this issue.&lt;/p&gt;

&lt;p&gt;But even though I can&apos;t demonstrate it easily, I&apos;m pretty sure the answer is &quot;Yes&quot;.  I tried to run the repro script with a set of 10.2 jars that was built before any of the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;&lt;del&gt;related changes went in (but after optimizer overrides were added) and the queries pass.  So the queries used to work in 10.2 and now they don&apos;t&lt;/del&gt;-and I&apos;d be very (pleasantly) surprised if the optimizer changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; weren&apos;t somehow responsible.  Given that, the 805 changes were ported to 10.1 so I imagine the issue exists in the 10.1.3 release, as well (it&apos;s just hidden behind the other regressions that have since been resolved).&lt;/p&gt;</comment>
                            <comment id="12436630" author="rhillegas" created="Thu, 21 Sep 2006 21:20:31 +0100"  >&lt;p&gt;Thanks, Army. As I understand it, this bug exists in the 10.1.3 release. It seems that, as far as this bug is concerned, 10.2 is no worse than 10.1.3. For that reason, I would not be inclined to hold up the 10.2 release for this bug fix.&lt;/p&gt;</comment>
                            <comment id="12436637" author="army" created="Thu, 21 Sep 2006 21:43:33 +0100"  >&lt;p&gt;&amp;gt; As I understand it, this bug exists in the 10.1.3 release. It seems that, as far as this bug is&lt;br/&gt;
&amp;gt; concerned, 10.2 is no worse than 10.1.3. For that reason, I would not be inclined to hold up&lt;br/&gt;
&amp;gt; the 10.2 release for this bug fix.&lt;/p&gt;

&lt;p&gt;Two things:&lt;/p&gt;

&lt;p&gt;  1. Are we going to mention the known issues (esp. regressions) that exist with the 10.2 release (aside from intentional behavioral changes) somewhere in the release notes?  I looked at the html file attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1860&quot; title=&quot;Create release notes for 10.2&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1860&quot;&gt;&lt;del&gt;DERBY-1860&lt;/del&gt;&lt;/a&gt; and didn&apos;t see any (the &quot;issues&quot; section just holds release notes for intentional behavior changes and/or fixes).  Are we just leaving it up to the users to navigate Jira to find outstanding issues like &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1866&quot; title=&quot;Assert failure in sane mode for queries that used to work in 10.1.2.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1866&quot;&gt;&lt;del&gt;DERBY-1866&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;  2. Just as a note, this reasoning for not holding up the release also applies to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1633&quot; title=&quot;Regression: The fields of views are not being calculated properly since 10.1.2.4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1633&quot;&gt;&lt;del&gt;DERBY-1633&lt;/del&gt;&lt;/a&gt;, and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1681&quot; title=&quot;Regression (wrong results): Join predicate can be ignored for left-most child in a chain of nested unions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1681&quot;&gt;&lt;del&gt;DERBY-1681&lt;/del&gt;&lt;/a&gt;, since all of those fail with 10.1.3 release, as well.  (Oh, and &lt;b&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1854&quot; title=&quot;SYSCS_COMPRESS_TABLE corrupts table with a single column which is both a primary key and a foreign key&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1854&quot;&gt;&lt;del&gt;DERBY-1854&lt;/del&gt;&lt;/a&gt;&lt;/b&gt;, for that matter!)  Am I to understand that if any of those was still unresolved, we&apos;d go ahead with the release nonetheless?  I&apos;m not disagreeing with the decision, just curious if the &quot;it&apos;s no worse than &amp;lt;previous release&amp;gt;&quot; rule is specific to this particular Jira or if it applies on a more general scale?&lt;/p&gt;

&lt;p&gt;Thanks for following through with this discussion and making a final decision!&lt;/p&gt;</comment>
                            <comment id="12437266" author="army" created="Mon, 25 Sep 2006 00:32:37 +0100"  >&lt;p&gt;Attaching a first patch for this issue, d1866_v1.patch.  In short, the problem was that, when pushing predicates to subqueries beneath UNIONs, the predicates were always being pushed to the &lt;b&gt;first&lt;/b&gt; table in the subquery&apos;s FROM list, regardless of whether or not that was actually the correct table.  Thus it was possible to push a predicate down to a base table to which it didn&apos;t apply, thereby leading to an assertion failure in sane mode and an index out of bounds exception in insane mode.&lt;/p&gt;

&lt;p&gt;For details on how this occurred and what the fix is, please refer to the code comments in the patch.  The d1866_v1 patch does the following:&lt;/p&gt;

&lt;p&gt;  1. Adds logic to ensure scoped predicates are only pushed&lt;br/&gt;
     to the appropriate base tables.&lt;/p&gt;

&lt;p&gt;  2. Adds one line to OptimizerImpl to solve the hang that&lt;br/&gt;
     was occuring for the second query shown in repro.sql.&lt;br/&gt;
     The problem there was just that one variable was not&lt;br/&gt;
     being properly reset when beginning a new round of&lt;br/&gt;
     optimization.&lt;/p&gt;

&lt;p&gt;  3. Adds some test cases to verify the changes for #1 and&lt;br/&gt;
     #2.&lt;/p&gt;

&lt;p&gt;Note that the patch is mostly just explanatory comments for existing and new logic, plus the test cases.&lt;/p&gt;

&lt;p&gt;I ran derbyall on Red Hat Linux with ibm142 using sane jars and there were no new failures.  I also ran the full ViewerInit program attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1777&quot; title=&quot;Regression: query works in 10.1.2.1 but fails with NullPointerException in 10.2.1.1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1777&quot;&gt;&lt;del&gt;DERBY-1777&lt;/del&gt;&lt;/a&gt; and the program ran to completion without error.  (Note that the queries took a very, very long time to compile, though (longest one took almost 40 minutes).  Unfortunate though that is, I think that&apos;s a separate and more general issue with Derby optimization of subqueries--one to be addressed further down the road...)&lt;/p&gt;

&lt;p&gt;I would appreciate any reviews of this patch--even if it&apos;s just a quick read of the code comments to see if they make sense.  Every little bit helps, and as I&apos;m sure everyone knows by now, optimizer changes are especially worthy of multiple reviews by as many people as possible...&lt;/p&gt;</comment>
                            <comment id="12437916" author="mikem" created="Tue, 26 Sep 2006 20:19:52 +0100"  >&lt;p&gt;I ran  a success full set of tests against this patch against windows XP and ibm 1.4.2. jvm.  I reviewed the changes and the extensive comments seemed to match up with what the code was doing.  Looked like good tests were being added for the problem.  I am no optimizer expert so I suggest at least one more reviewer before we consider moving this patch from the trunk to 10.2 codeline.  Am committing this to the trunk to get it more testing.&lt;/p&gt;

&lt;p&gt;If possible it would be good if anyone dependent on this change can test out the fix in the trunk and verify it works for&lt;br/&gt;
them.&lt;/p&gt;

&lt;p&gt;I committed this to the trunk:&lt;br/&gt;
m1_ibm142:5&amp;gt;svn commit&lt;/p&gt;

&lt;p&gt;Sending        java\engine\org\apache\derby\impl\sql\compile\OptimizerImpl.java&lt;br/&gt;
Sending        java\testing\org\apache\derbyTesting\functionTests\master\predicatePushdown.out&lt;br/&gt;
Sending        java\testing\org\apache\derbyTesting\functionTests\tests\lang\predicatePushdown.sql&lt;br/&gt;
Transmitting file data ...&lt;br/&gt;
Committed revision 450155.&lt;/p&gt;</comment>
                            <comment id="12438001" author="bryanpendleton" created="Wed, 27 Sep 2006 03:34:12 +0100"  >&lt;p&gt;Hi Army, I read through your code and tests; thanks for the clear and detailed comments!&lt;/p&gt;

&lt;p&gt;I noticed that the crucial bit of the change had to do with a comparison of table numbers;&lt;br/&gt;
I&apos;m not real familiar with how table numbers work, so I thought I&apos;d ask a pretty naive question:&lt;/p&gt;

&lt;p&gt;   at this point in the processing, have constructs like views and synonyms already been&lt;br/&gt;
   transformed and replaced by their underlying &quot;real&quot; tables?&lt;/p&gt;

&lt;p&gt;Also, and related:&lt;/p&gt;

&lt;p&gt;  If the optimizer is choosing to access an index for a table, rather than accessing the&lt;br/&gt;
  table itself, does the table number change depending on whether it is an index or&lt;br/&gt;
  a base table which is being processed by the ProjectRestrictNode?&lt;/p&gt;</comment>
                            <comment id="12438165" author="army" created="Wed, 27 Sep 2006 17:46:03 +0100"  >&lt;p&gt;Hi Bryan, thanks for looking at the patch and for being willing to ask some good questions.  Below are my (perhaps slightly lengthy) responses.  If this doesn&apos;t address your questions or leaves you with new questions, please don&apos;t hesitate to ask again...&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Army&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Q1: At this point in the processing, have constructs like views&lt;br/&gt;
   and synonyms already been transformed and replaced by their&lt;br/&gt;
   underlying &quot;real&quot; tables? &lt;/p&gt;

&lt;p&gt;Yes.  Transformations and table resolution occur during the &quot;binding&quot; and &quot;preprocessing&quot; stages of query compilation--and both of those stages occur before optimization begins.  So at this point a view will be represented by a ProjectRestrictNode whose child is a SelectNode, and a synonym will be represented by whatever FromTable it (the synonym) is actually referring to.&lt;/p&gt;

&lt;p&gt;Table numbers are also assigned during binding/preprocessing, so by the time we get to the code in d1866_v1.patch, all FromTables (aka  &quot;Optimizables&quot;) in the entire query will have an assigned table number (if required--in some cases it&apos;s not necessary and thus will be -1).  Additionally any column reference which points to one of those FromTables will have the table number for that FromTable stored locally (namely, in ColumnReference.tableNumber).&lt;/p&gt;

&lt;p&gt;Note that when a ColumnReference is &quot;remapped&quot; to point to a different FromTable, its local information-&lt;del&gt;including tableNumber&lt;/del&gt;&lt;del&gt;is updated accordingly.  Note also that a &quot;FromTable&quot; is not restricted to base tables&lt;/del&gt;-anything that can be specified in the FROM list of a SELECT query will be represented by some instance of FromTable, whether it be a subquery, a base table, a union node, etc.  Every FromTable has its own &quot;table number&quot;, with the exception of ProjectRestrictNodes.  For a PRN, if the PRN&apos;s child is itself a FromTable (as opposed to, say, a SelectNode) then the PRN&apos;s table number will be -1 and any attempts to &quot;get&quot; the PRN&apos;s table number will return the table number of the PRN&apos;s child.  If the PRN&apos;s child is not a FromTable, then the PRN will have it&apos;s own table number.&lt;/p&gt;

&lt;p&gt;Q2: If the optimizer is choosing to access an index for a table, rather&lt;br/&gt;
  than accessing the table itself, does the table number change depending&lt;br/&gt;
  on whether it is an index or a base table which is being processed&lt;br/&gt;
  by the ProjectRestrictNode?&lt;/p&gt;

&lt;p&gt;Great question.  Short answer is &quot;no&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The thing to note here is that &quot;table number&quot; is strictly a language-created, compilation time value to allow binding, preprocessing, optimization, and code generation to distinguish between the various FromTables in the original query.  A table number is not stored on disk and it is independent of the access path decisions (including whether or not an index is used) made by the optimizer.  Furthermore, there is no link between a given table number and the actual on-disk table that it points to.  Table number 0 could be for T1 in one query, T2 in another query, and T100 in a third query.&lt;/p&gt;

&lt;p&gt;As a simple (but admittedly meaningless) example, take the following query:&lt;/p&gt;

&lt;p&gt;  select t1.i, x1.j from t1, t1 x1 where t1.i = x1.j;&lt;/p&gt;

&lt;p&gt;At bind time Derby will assign every item in the FROM list a table number.  So in this case, &quot;T1&quot; gets table number 0 and &quot;T1 X1&quot; gets table number 1.  The fact that both FromTables are really pointing to the same base table doesn&apos;t matter.  For the duration of compilation/optimization, they are represented by two different instances of FromTable and are considered two different &quot;tables&quot;, each having its own table number.  (For the record, in this particular example the different FromTables will in fact point to the same underlying tableDescriptor field).&lt;/p&gt;

&lt;p&gt;Given that, the predicate &quot;t1.i = x1.j&quot; will have a left ColumnReference pointing to a FromBaseTable representing T1 with table number &quot;0&quot; and a right ColumnReference pointing to a different FromBaseTable representing X1 (i.e. T1 again) with table number &quot;1&quot;.&lt;/p&gt;

&lt;p&gt;If the optimizer then decides to use an index for T1, the table number doesn&apos;t change--the optimizer just decides that for &quot;the FromBaseTable whose table number is 0 we will use an index&quot;.  In fact, once assigned, the table number for a specific FromTable remains the same for the duration of the compilation of the statement.&lt;/p&gt;

&lt;p&gt;That was a round-about way of getting to the answer, but hopefully that&apos;s more helpful than confusing...&lt;/p&gt;

&lt;p&gt;As I said, if you still have questions/confusion, please do ask again.  It&apos;s always good to answer questions like these, as it makes me re-check what I think I &quot;know&quot; and forces me to verify my replies by looking at the code again...&lt;/p&gt;</comment>
                            <comment id="12438200" author="yipng" created="Wed, 27 Sep 2006 20:24:25 +0100"  >&lt;p&gt;Hi Army, I read through the patch and the changes seem reasonable to me.  &lt;/p&gt;

&lt;p&gt;You mentioned that:&lt;/p&gt;

&lt;p&gt;&quot;all FromTables (aka &quot;Optimizables&quot;) in the entire query will have an assigned table number (if required--in some cases it&apos;s not necessary and thus will be -1).&quot;  &lt;/p&gt;

&lt;p&gt;Can you elaborate on this?  In what circumstances where the table number will be -1?  &lt;/p&gt;

&lt;p&gt;tNum = ((FromTable)curTable).getTableNumber();&lt;br/&gt;
...&lt;br/&gt;
if (tNum &amp;gt;= 0)&lt;br/&gt;
    curTableNums.set(tNum);&lt;/p&gt;</comment>
                            <comment id="12438214" author="army" created="Wed, 27 Sep 2006 21:37:58 +0100"  >&lt;p&gt;Thanks for the review, Yip!&lt;/p&gt;

&lt;p&gt;&amp;gt; Can you elaborate on this? In what circumstances where the table number will be -1? &lt;/p&gt;

&lt;p&gt;I think the answer to this question was buried in my earlier reply, namely:&lt;/p&gt;

&lt;p&gt;&quot;For a ProjectRestrictNode, if the PRN&apos;s child is itself a FromTable (as opposed to, say, a SelectNode) then the PRN&apos;s table number can be -1 and any attempts to &quot;get&quot; the PRN&apos;s table number will return the table number of the PRN&apos;s child. If the PRN&apos;s child is not a FromTable, then the PRN will have it&apos;s own table number. &quot;&lt;/p&gt;

&lt;p&gt;That said, I think the check for &quot;tNum &amp;gt;= 0&quot; in this patch is probably unnecessary, since in the case just mentioned the call to &quot;getTableNumber()&quot; on a PRN will translate into a call to &quot;getTableNumber()&quot; on the child, which should then return a non-negative number.  I don&apos;t think it hurts to have the check in there, but since it&apos;s not expected to be -1, perhaps I can post a follow-up patch to remove the check and add an ASSERT to make sure that tNum is in fact positive...?&lt;/p&gt;</comment>
                            <comment id="12438215" author="yipng" created="Wed, 27 Sep 2006 21:44:44 +0100"  >&lt;p&gt;Right.  You mentioned one case where this can be -1 on your earlier reply, but I was wondering if there are any other cases where table number can be -1 since you mentioned there are some cases.  I think the extra check for tNum &amp;gt;= 0 is fine as is.   &lt;/p&gt;</comment>
                            <comment id="12438527" author="army" created="Thu, 28 Sep 2006 20:02:56 +0100"  >&lt;p&gt;&amp;gt; You mentioned one case where this can be -1 on your earlier reply,&lt;br/&gt;
&amp;gt; but I was wondering if there are any other cases where table number&lt;br/&gt;
&amp;gt; can be -1 since you mentioned there are some cases.&lt;/p&gt;

&lt;p&gt;Sorry for misunderstanding your question.  When I wrote &quot;some&quot; cases I intended that to mean that there are &quot;some&quot; cases where a ProjectRestrictNode (PRN)&apos;s tableNumber can be -1 (namely, if it&apos;s child is an Optimizable).  Since that&apos;s the only time I&apos;ve ever seen a negative table number when tracing through code, I&apos;ve been assuming that&apos;s the only case when it can happen.&lt;/p&gt;

&lt;p&gt;But inspired by your question, I decided to do a search through the codeline to see if there are any other situations when a table number can be -1 during optimization.  (Note: the emphasis here is on optimization, since that&apos;s the area of code at issue with this Jira).&lt;/p&gt;

&lt;p&gt;The only other case I found was for NormalizeResultSetNode, which is created for InsertNode and UpdateNode.  But NormalizeResultSetNodes are generated on top of a ResultSetNode to be optimized--they are not themselves optimized, which means that we wouldn&apos;t ever get to the code in d1866_v1.patch with a &quot;curTable&quot; that is a NormalizeResultSetNode.  So even though a NormalizeRSN can have a negative table number, that doesn&apos;t affect the proposed changes.&lt;/p&gt;

&lt;p&gt;Thus based on my understanding, the only time a FromTable&apos;s table number can be -1 during optimization is if it is in fact a ProjectRestrictNode with a non-FromTable subquery as its child.&lt;/p&gt;

&lt;p&gt;As a minor sort of sanity check for these results, I put a System.out in OptimizerImpl to print a message if we ever saw an Optimizable that had a negative table number but that was not a PRN, and then I ran derbylang.  The message was never printed.  This doesn&apos;t &quot;prove&quot; anything in particular, but it does lend evidence to the results of my code search...&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;Details on my search:&lt;/p&gt;

&lt;p&gt;Below are the classes I found that extend FromTable.  I looked to see 1) where the various classes were instantiated, and 2) where their table numbers were set (if at all).  The breakdown based on my searching is as follows:&lt;/p&gt;

&lt;p&gt;FromTables whose table numbers are always set during binding (and thus will not be -1 when it comes time to optimize):&lt;/p&gt;

&lt;p&gt; CurrentOfNode&lt;br/&gt;
 FromBaseTable&lt;br/&gt;
 FromSubquery&lt;br/&gt;
 FromVTI&lt;br/&gt;
 RowResultSetNode&lt;br/&gt;
 TableOperatorNode&lt;br/&gt;
 -&amp;gt;JoinNode (via inheritance from TableOp)&lt;br/&gt;
 ---&amp;gt;HalfOuterJoinNode (inheritance from TableOp)&lt;br/&gt;
 -&amp;gt;SetOperatorNode (inheritance from TableOp)&lt;br/&gt;
 ---&amp;gt;IntersectOrExceptNode (inheritance from TableOp)&lt;br/&gt;
 ---&amp;gt;UnionNode (inheritance from TableOp)&lt;/p&gt;

&lt;p&gt;FromTables that are only instantiated AFTER optimization has completed, and thus even though their table numbers can be -1, that won&apos;t affect optimization.&lt;/p&gt;

&lt;p&gt; IndexToBaseRowNode&lt;br/&gt;
 SingleChildResultSetNode&lt;br/&gt;
 -&amp;gt;DistinctNode&lt;br/&gt;
 -&amp;gt;GroupByNode&lt;br/&gt;
 -&amp;gt;HashTableNode&lt;br/&gt;
 -&amp;gt;MaterializeResultSetNode&lt;br/&gt;
 -&amp;gt;OrderByNode&lt;br/&gt;
 -&amp;gt;ScrollInsensitiveResultSetNode&lt;/p&gt;

&lt;p&gt;FromTables that can be instantiated during preprocessing but that may not have their table numbers set (these are the ones of interest to the current discussion):&lt;/p&gt;

&lt;p&gt; ProjectRestrictNode:&lt;/p&gt;

&lt;p&gt;  If created during preprocessing, table number will only be set in&lt;br/&gt;
  FromSubquery.extractSubquery(); in all other cases it will remain -1.&lt;/p&gt;

&lt;p&gt; NormalizeResultSetNode:&lt;/p&gt;

&lt;p&gt;  Instantiated during bind phase for InsertNode and UpdateNode&lt;br/&gt;
  but table number is not set.  So it will be -1.  However,&lt;br/&gt;
  a NormalizeresultSetNode never appears in an optimizer&apos;s&lt;br/&gt;
  optimizableList, and thus such a node will never actually&lt;br/&gt;
  be optimized.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Hopefully that&apos;s more in line with what you were asking?&lt;/p&gt;

&lt;p&gt;Thanks again for the review and great questions...&lt;/p&gt;</comment>
                            <comment id="12438534" author="yipng" created="Thu, 28 Sep 2006 20:34:16 +0100"  >&lt;p&gt;Yes, that is what I was looking for.  Thanks for the extensive analysis and explanation on the table number logic in the optimizer, Army.&lt;/p&gt;</comment>
                            <comment id="12439174" author="rhillegas" created="Mon, 2 Oct 2006 15:37:12 +0100"  >&lt;p&gt;Looks like this one made it into 10.2.1.&lt;/p&gt;</comment>
                            <comment id="12439190" author="mikem" created="Mon, 2 Oct 2006 16:29:45 +0100"  >&lt;p&gt;I backported this fix to both the 10.2 and 10.1 branches.&lt;/p&gt;</comment>
                            <comment id="12443563" author="army" created="Thu, 19 Oct 2006 17:20:52 +0100"  >&lt;p&gt;Fix is in 10.3, 10.2, and 10.1, and I haven&apos;t heard any follow-up feedback, so marking is as closed.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12348858">DERBY-1777</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12341513" name="d1866_v1.patch" size="18528" author="army" created="Mon, 25 Sep 2006 00:32:37 +0100"/>
                            <attachment id="12341143" name="derby.log" size="10132" author="army" created="Tue, 19 Sep 2006 19:35:02 +0100"/>
                            <attachment id="12341246" name="repro.sql" size="2120" author="army" created="Thu, 21 Sep 2006 03:12:59 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10420"><![CDATA[Regression]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 21 Sep 2006 15:40:57 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22761</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0pp3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37981</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>