<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:39:35 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2967/DERBY-2967.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2967] Single character does not match high value unicode character with collation TERRITORY_BASED</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2967</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;With TERRITORY_BASED collation &apos;_&apos; does not match  the character \uFA2D.  It is the same for english or norwegian. FOR collation UCS_BASIC it matches fine.  Could you tell me if this is a bug?&lt;br/&gt;
Here is a program to reproduce.&lt;/p&gt;


&lt;p&gt;import java.sql.*;&lt;/p&gt;

&lt;p&gt;public class HighCharacter {&lt;/p&gt;

&lt;p&gt;   public static void main(String args[]) throws Exception&lt;/p&gt;
   {
   System.out.println(&quot;\n Territory no_NO&quot;);
   Class.forName(&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;);
   Connection conn = DriverManager.getConnection(&quot;jdbc:derby:nordb;create=true;territory=no_NO;collation=TERRITORY_BASED&quot;);
   testLikeWithHighestValidCharacter(conn);
   conn.close();
   System.out.println(&quot;\n Territory en_US&quot;);
   conn = DriverManager.getConnection(&quot;jdbc:derby:endb;create=true;territory=en_US;collation=TERRITORY_BASED&quot;);
   testLikeWithHighestValidCharacter(conn);
   conn.close();
   System.out.println(&quot;\n Collation USC_BASIC&quot;);
   conn = DriverManager.getConnection(&quot;jdbc:derby:basicdb;create=true&quot;);
   testLikeWithHighestValidCharacter(conn);

   }


&lt;p&gt;public static  void testLikeWithHighestValidCharacter(Connection conn) throws SQLException {&lt;br/&gt;
   Statement stmt = conn.createStatement();&lt;br/&gt;
   try &lt;/p&gt;
{
   stmt.executeUpdate(&quot;drop table t1&quot;);
   }
&lt;p&gt;catch (SQLException se)&lt;/p&gt;
   {// drop failure ok.
   }
&lt;p&gt;   stmt.executeUpdate(&quot;create table t1(c11 int)&quot;);&lt;br/&gt;
   stmt.executeUpdate(&quot;insert into t1 values 1&quot;);&lt;/p&gt;

&lt;p&gt;   // \uFA2D - the highest valid character according to&lt;br/&gt;
   // Character.isDefined() of JDK 1.4;&lt;br/&gt;
   PreparedStatement ps =&lt;br/&gt;
   conn.prepareStatement(&quot;select 1 from t1 where &apos;\uFA2D&apos; like ?&quot;);&lt;br/&gt;
     String[] match = &lt;/p&gt;
{ &quot;%&quot;, &quot;_&quot;, &quot;\uFA2D&quot; }
&lt;p&gt;;&lt;/p&gt;

&lt;p&gt;   for (int i = 0; i &amp;lt; match.length; i++) &lt;/p&gt;
{
   System.out.println(&quot;select 1 from t1 where &apos;\\uFA2D&apos; like &quot; + match[i]);
   ps.setString(1, match[i]);
   ResultSet rs = ps.executeQuery();
   if( rs.next() &amp;amp;&amp;amp; rs.getString(1).equals(&quot;1&quot;))
       System.out.println(&quot;PASS&quot;);
   else          System.out.println(&quot;FAIL: no match&quot;);

   rs.close();
   }
&lt;p&gt;  }&lt;br/&gt;
}&lt;/p&gt;



&lt;p&gt;Mamta made some comments on this issue in the following thread:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nabble.com/Single-character-does-not-match-high-value-unicode-character-with-collation-TERRITORY_BASED.-Is-this-a-bug-tf4118767.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Single-character-does-not-match-high-value-unicode-character-with-collation-TERRITORY_BASED.-Is-this-a-bug-tf4118767.html&lt;/a&gt;&lt;/p&gt;

</description>
                <environment></environment>
        <key id="12374390">DERBY-2967</key>
            <summary>Single character does not match high value unicode character with collation TERRITORY_BASED</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                    </labels>
                <created>Mon, 23 Jul 2007 17:55:18 +0100</created>
                <updated>Wed, 28 Nov 2007 18:34:18 +0000</updated>
                            <resolved>Mon, 26 Nov 2007 20:21:12 +0000</resolved>
                                    <version>10.4.1.3</version>
                                    <fixVersion>10.3.2.1</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12518204" author="kmarsden" created="Tue, 7 Aug 2007 18:47:58 +0100"  >&lt;p&gt;I am looking at the current behavior where _ matches a single collation element instead of a single character and trying to understand what the new behavior would be.    Here is an example of the current behavior:  I insert into a table two rows:&lt;/p&gt;

&lt;p&gt; agrave = &quot;\u00C0&quot;;&lt;br/&gt;
agraveCombined =&quot;A\u0300&quot;;&lt;/p&gt;

&lt;p&gt;agrave is one character, agraveCombined is two but they match for = and like processing with a French TERRITORY_BASED database.  Here are some queries.&lt;/p&gt;

&lt;p&gt;jdbc:derby:frdb (TERRITORY_BASED - current)&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = &#192;&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE &#192;&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE A_&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;

&lt;p&gt;jdbc:derby:regdb (UCS_BASIC)&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = &#192;&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE &#192;&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE A_&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;


&lt;p&gt;So if _ is really supposed to match a single character and not a single collation element,&lt;br/&gt;
I think the results should be as follows:&lt;br/&gt;
jdbc:derby:frdb (TERRITORY_BASED)&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = &#192;&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE &#192;&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE A_  (agraveCombined)&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _  (agrave)&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __ (agraveCombined)&lt;/p&gt;

&lt;p&gt;Does that sound right?  How I might implement this I have no idea but just trying to get my head around how it should behave.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;

&lt;p&gt;See attached program TestFrench.java if you want to run.&lt;/p&gt;</comment>
                            <comment id="12518262" author="djd" created="Tue, 7 Aug 2007 22:25:50 +0100"  >&lt;p&gt;I would say neither (existing or proposed)  is correct, though only after looking at your example.&lt;/p&gt;

&lt;p&gt;The existing code is wrong because it is converting the &apos;_&apos; to a collation element then skipping that number of collation elements?&lt;/p&gt;

&lt;p&gt;The proposed results are wrong because in the French locale agraveCombined =&quot;A\u0300&quot; is a single character.&lt;br/&gt;
I assume the \u0300 is a &apos;Combining character&apos;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf#G30602&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf#G30602&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thus I think the results should be:&lt;/p&gt;

&lt;p&gt;0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE A_&lt;br/&gt;
2 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _ (agrave,agraveCombined)&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;

&lt;p&gt;As for implementing it, I think one has to use the getOffset/setOffset method on CollationElementIterator.&lt;/p&gt;

&lt;p&gt;E.g. along the lines of this to skip a character. The real solution would be more than this but you get the idea.&lt;/p&gt;

&lt;p&gt;   if (patternChar == &apos;_&apos;)&lt;br/&gt;
       iterator.setOffset(iterator.getOffset() + 1);&lt;/p&gt;





</comment>
                            <comment id="12518264" author="kmarsden" created="Tue, 7 Aug 2007 22:41:38 +0100"  >&lt;p&gt;Both String.length() and SQL LENGTH say agraveCombined =&quot;A\u0300&quot; is two characters.  Is this result wrong?&lt;br/&gt;
ij&amp;gt; select length(VC) from t;&lt;br/&gt;
1&lt;br/&gt;
-----------&lt;br/&gt;
1&lt;br/&gt;
2&lt;/p&gt;

&lt;p&gt;Do you think SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = &#192;  should still match two rows?&lt;/p&gt;</comment>
                            <comment id="12518269" author="djd" created="Tue, 7 Aug 2007 22:53:14 +0100"  >&lt;p&gt;String.length() returning two matches its definition so it seems to be correct.&lt;/p&gt;

&lt;p&gt;Is the SQL fLENGTH unction a standard function, does that say anything?&lt;/p&gt;

&lt;p&gt;&amp;gt; Do you think SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = &#192; should still match two rows? &lt;br/&gt;
Given what you said yes, I thought this issue was about LIKE and _ though.&lt;/p&gt;
</comment>
                            <comment id="12518548" author="kmarsden" created="Wed, 8 Aug 2007 21:58:14 +0100"  >&lt;p&gt;Dan said:&lt;/p&gt;

&lt;p&gt;&amp;gt;As for implementing it, I think one has to use the getOffset/setOffset method on CollationElementIterator.&lt;br/&gt;
&amp;gt;E.g. along the lines of this to skip a character. The real solution would be more than this but you get the idea.&lt;/p&gt;

&lt;p&gt;&amp;gt;   if (patternChar == &apos;_&apos;)&lt;br/&gt;
&amp;gt;       iterator.setOffset(iterator.getOffset() + 1);&lt;/p&gt;

&lt;p&gt;So for the Norwegian aa, which is one collation element but two characters, I think this code would set us back to the same offset where we started, since getOffset always returns the first character of the collation element.  That would leave us I think in an unpleasant loop.  &lt;/p&gt;

&lt;p&gt;Attaching TestNorway.java showing current behavior for Norwegian aa.&lt;/p&gt;

&lt;p&gt;default strength:TERTIARY&lt;br/&gt;
default decomposition:NO_DECOMPOSITION&lt;br/&gt;
aa.length()2&lt;br/&gt;
jdbc:derby:nordb&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE aa&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE a_&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;br/&gt;
jdbc:derby:regdb&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE a_&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;

&lt;p&gt;I think the correct results for nordb should be:&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE a_&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;

&lt;p&gt;I am going to try to look at another database product to compare behavior so I can better understand what needs to be implemented, because I am still a bit fuzzy on all this.&lt;/p&gt;
</comment>
                            <comment id="12518575" author="djd" created="Thu, 9 Aug 2007 00:20:25 +0100"  >&lt;p&gt;How about this to skip one logical character (not tested, just guessing from the apis)&lt;/p&gt;

&lt;p&gt;int currentChar = iterator.getOffset();&lt;br/&gt;
do &lt;/p&gt;
{
  iterator.next();
}
&lt;p&gt; while (iterator.getOffset() == currentChar)&lt;/p&gt;

&lt;p&gt;E.g. Norwegian  &apos;aa&apos; maps to a single collation element so getOffset() can only point to one of the characters in the underlying String.&lt;br/&gt;
Once getPosition changes it must have moved past the aa&lt;/p&gt;
</comment>
                            <comment id="12519120" author="kmarsden" created="Fri, 10 Aug 2007 22:08:06 +0100"  >&lt;p&gt;Below are the results run against DB2 v8.2 with  UCA400_NO collation.  _ doesn&apos;t seem to match to a single character in DB2, but it doesn&apos;t quite seem to be collation element either.&lt;/p&gt;

&lt;p&gt;HighCharacter.java&lt;/p&gt;

&lt;p&gt; Territory no_NO&lt;br/&gt;
select 1 from t1 where &apos;\uFA2D&apos; like %&lt;br/&gt;
PASS&lt;br/&gt;
select 1 from t1 where &apos;\uFA2D&apos; like _&lt;br/&gt;
FAIL: no match&lt;br/&gt;
select 1 from t1 where &apos;\uFA2D&apos; like ?&lt;br/&gt;
PASS&lt;/p&gt;

&lt;p&gt; Territory en_US&lt;br/&gt;
select 1 from t1 where &apos;\uFA2D&apos; like %&lt;br/&gt;
PASS&lt;br/&gt;
select 1 from t1 where &apos;\uFA2D&apos; like _&lt;br/&gt;
FAIL: no match&lt;br/&gt;
select 1 from t1 where &apos;\uFA2D&apos; like ?&lt;br/&gt;
PASS&lt;/p&gt;


&lt;p&gt;TestFrench.java&lt;/p&gt;


&lt;p&gt;jdbc:db2://localhost:50000/frdb&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = &#192;&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE &#192;&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE A_&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;


&lt;p&gt;TestNorway.java&lt;/p&gt;

&lt;p&gt;jdbc:db2://localhost:50000/nordb&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC = aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE aa&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE a_&lt;br/&gt;
0 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE _&lt;br/&gt;
1 rows matching SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM T WHERE VC LIKE __&lt;/p&gt;
</comment>
                            <comment id="12519145" author="kmarsden" created="Fri, 10 Aug 2007 23:28:18 +0100"  >&lt;p&gt;Unassigning myself from this issue for now.  It seems to me that the behavior is not all that straightforward.  I think I&apos;d rather leave to someone more familiar with collation to fix.  I hope the test cases are helpful.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;</comment>
                            <comment id="12522039" author="mamtas" created="Thu, 23 Aug 2007 07:21:29 +0100"  >&lt;p&gt;I spent some time on this Jira entry to explore Dan&apos;s suggestion for _ search in a string&lt;br/&gt;
*************&lt;br/&gt;
--Note that the iterator object is of type CollationElementIterator. &lt;br/&gt;
int currentChar = iterator.getOffset(); &lt;br/&gt;
do &lt;/p&gt;
{ 
  iterator.next(); 
}
&lt;p&gt; while (iterator.getOffset() == currentChar) &lt;br/&gt;
*************&lt;/p&gt;

&lt;p&gt;I believe the code suggested by Dan above will do the trick but I am not sure how to fit that logic in the current code inside the iapi.types.Like.like method (method starting at line 258) which is where the current implementation for _ resides. &lt;/p&gt;

&lt;p&gt;Some background information on the classes and methods involved in this discussion: There are 2 like methods inside WorkHorseForCollatorDatatypes(which handles collation sensitive methods for character string types with territory based collation) and they only differ in the sense that one accepts the escape DVD while the other one does not. Both these methods call the like method(starting at line 96) in iapi.types.Like. This like method ends up calling another like method in the same class (starting at line 258) which provides the actual implementation. Notice, that this like method does not work with CollationElementIterator. Instead, it expects the caller to send the int array containing the collation elements for string to be searched into, pattern to be looked and escape sequence. This is done for performance reasons. We do not want to construct the collation element arrary for the strings during every call to like. Instead, we want to construct it once and reuse it every subsequent time. And hence, the current implementation does not work with CollationElementIterator.&lt;/p&gt;

&lt;p&gt;As a solution, I am thinking that may be I should have another int array in WorkHorseForCollatorDatatypes, which will keep track of the starting position of the collation elements for each of the characters. We already have an int array, collationElementsForString, which holds the collation elements for all the characters that this WorkHorseForCollatorDatatypes holds. If we knew where the new collation elements start in collationElementsForString, we can just advance to the next character&apos;s collation element starting position when we find a _. &lt;/p&gt;

&lt;p&gt;Let me know if anyone has any feedback on this approach or has any other suggestions on fixing the problem.&lt;/p&gt;</comment>
                            <comment id="12523073" author="djd" created="Mon, 27 Aug 2007 19:07:58 +0100"  >&lt;p&gt;Are there any numbers for the performance benefit seen by using this int arrays over CollationElementIterator?&lt;/p&gt;

&lt;p&gt;One potential problem with the arrays is that the array is fully populated even if the value could be disqualified on the first character, that would seem to degrade performance, not improve it.&lt;/p&gt;</comment>
                            <comment id="12523324" author="mamtas" created="Tue, 28 Aug 2007 20:41:27 +0100"  >&lt;p&gt;I do not have any numbers for the performance results for int array vs CollationElementIterator. I searched Derby dev list and found few postings about how constructing an array before hand may not be not necessary for a check which would fail within say first few characters. I also found &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2699&quot; title=&quot;performance of like in territory based collation databases may be improved by changing way collation elements are calculated.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2699&quot;&gt;&lt;del&gt;DERBY-2699&lt;/del&gt;&lt;/a&gt; (performance of like in territory based collation databases may be improved by changing way collation elements are calculated.) which also talks about the same issue as your comment &quot;One potential problem with the arrays is that the array is fully populated even if the value could be disqualified on the first character, that would seem to degrade performance, not improve it. &quot; &lt;/p&gt;

&lt;p&gt;I will start investigating into using CollationElementIterator rather than an int array. This will fix both this Jira entry and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2699&quot; title=&quot;performance of like in territory based collation databases may be improved by changing way collation elements are calculated.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2699&quot;&gt;&lt;del&gt;DERBY-2699&lt;/del&gt;&lt;/a&gt; and possibly &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2698&quot; title=&quot;caching collation elements in WorkHorseForCollatorDatatypes may improve performance.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2698&quot;&gt;DERBY-2698&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If anyone has any comments please let me know.&lt;/p&gt;</comment>
                            <comment id="12526508" author="mamtas" created="Tue, 11 Sep 2007 17:11:46 +0100"  >&lt;p&gt;I have attached an intermediate patch. This patch rather than building the collation elements in advance, builds it as needed. The crucial parts that are left are&lt;br/&gt;
1)Implementing code for pattern &apos;%a&apos;, ie when % (which is match 0/more characters) is found, match remaining pattern after it.&lt;br/&gt;
2)The other item left is understanding the behavior of CollationElementIterator.next and previous. I have started a thread &quot;Question about next() and previous() on CollationElementIterator&quot; on that issue and hope to get some feedback on it.&lt;/p&gt;</comment>
                            <comment id="12527398" author="mamtas" created="Fri, 14 Sep 2007 09:13:02 +0100"  >&lt;p&gt;I talked with Dan briefly on my last patch(temp_diff.txt) and found that I was unaware of the fact that 2 or more different characters in a territory can have same collation element(s) value associated with them. &lt;br/&gt;
***********************\&lt;br/&gt;
(&lt;a href=&quot;http://www.unicode.org/reports/tr10/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.unicode.org/reports/tr10/&lt;/a&gt; Section 1.9.2 Non-Goals The Default Unicode Collation Element Table explicitly does not provide for the following features:&lt;br/&gt;
reversibility: from a Collation Element you are not guaranteed that you can recover the original character. &lt;br/&gt;
***********************/&lt;/p&gt;

&lt;p&gt;So, taking a fictious territory as an eg, it is possible that metacharacter &apos;_&apos;&apos;s collation element could have same value as say character &apos;a&apos;. Because of this, my approach to construct a CollationElementIterator on the entire pattern string will not yield expected results. I have worked on a new patch based on this fact and will post it in another couple minutes. Please disregard the earlier patch temp_diff.txt and temp_stat.txt&lt;/p&gt;</comment>
                            <comment id="12527405" author="mamtas" created="Fri, 14 Sep 2007 09:25:06 +0100"  >&lt;p&gt;Attaching a new patch (svn diff is attached as step1_iteratorbased_Sep1507_diff.txt and svn stat -q is attached as step1_iteratorbased_Sep1507_stat.txt). This patch does not build the collation elements for the value string in advance, instead it fetches the collation element from the CollationElementIterator as needed for the value string. In addition, it does not build CollationElementIterator on entire pattern string. The metacharacters in pattern are compated using their unicode values. Rest of the characters in pattern will have CollationElementIterator associated with them. In other words, for the pattern string, collation elements are used only for non-metacharacters. &lt;/p&gt;

&lt;p&gt;The new logic for LIKE implementation is as follows(This is really the javadoc for the iapi.types.Like:like(CollationElementIterator valueIterator, String pattern, String escape, RuleBasedCollator collator)). I do have 2 questions that I would appreciate help on. The 2 questions are at the end of the nice &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; javadoc below.&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This method will be called for character string types with territory&lt;/li&gt;
	&lt;li&gt;based collation. The logic of the method is as follows&lt;/li&gt;
	&lt;li&gt;A)If pattern string or value Iterator is null, then this method will&lt;/li&gt;
	&lt;li&gt;return null. Because the results of LIKE can&apos;t be established in such&lt;/li&gt;
	&lt;li&gt;a situation.&lt;/li&gt;
	&lt;li&gt;B)Intialize the pointer into pattern string to 0&lt;/li&gt;
	&lt;li&gt;C)Start the loop&lt;/li&gt;
	&lt;li&gt;a)Check if we have reached the end of value Iterator. If yes&lt;/li&gt;
	&lt;li&gt;1)Check if we have reached the end of pattern string. If yes&lt;/li&gt;
	&lt;li&gt;return TRUE.&lt;/li&gt;
	&lt;li&gt;2)Check if we pattern string only has % left. If yes, then&lt;/li&gt;
	&lt;li&gt;return TRUE.&lt;/li&gt;
	&lt;li&gt;3)If a1) and a2) not true, then return FALSE.&lt;/li&gt;
	&lt;li&gt;c)Start looking at pattern where the pointer is pointing and keep&lt;/li&gt;
	&lt;li&gt;going until you find end of pattern or one of the metacharacters&lt;/li&gt;
	&lt;li&gt;ie %, * or escape character.&lt;/li&gt;
	&lt;li&gt;d)Get a CollationElementIterator for the non-metacharacters found in&lt;/li&gt;
	&lt;li&gt;step c(using the Collator passed to this method. The same Collator&lt;/li&gt;
	&lt;li&gt;was used to construct a CollationElementIterator for value string).&lt;/li&gt;
	&lt;li&gt;and make sure that they match the collation elements found in&lt;/li&gt;
	&lt;li&gt;value CollationElementIterator. A mismatch would require us to&lt;/li&gt;
	&lt;li&gt;return FALSE from this method.&lt;/li&gt;
	&lt;li&gt;e)Do the checks performed by step Ca).&lt;/li&gt;
	&lt;li&gt;f)Check what metacharacter is the offset in pattern pointing to&lt;/li&gt;
	&lt;li&gt;1)If it is escape character, then convert the next character in&lt;/li&gt;
	&lt;li&gt;pattern to it&apos;s collation element(s) and compare those collation&lt;/li&gt;
	&lt;li&gt;elements to elements in valueIterator. If they do not match,&lt;/li&gt;
	&lt;li&gt;we need to return FALSE.&lt;/li&gt;
	&lt;li&gt;2)If it is not escape character, then check if it is a _. If yes,&lt;/li&gt;
	&lt;li&gt;then skip all the collation elements in valueIterator&lt;/li&gt;
	&lt;li&gt;corresponding to the next character in value.&lt;/li&gt;
	&lt;li&gt;3)If it is not escape character or a &apos;_&apos; character, then check if&lt;/li&gt;
	&lt;li&gt;it is a &apos;%&apos;. If not, then go back to step C). If yes, then check&lt;/li&gt;
	&lt;li&gt;if we have reached the end of pattern. If end of pattern, then we&lt;/li&gt;
	&lt;li&gt;can simply return from this method with TRUE return value. I have&lt;/li&gt;
	&lt;li&gt;a question Q1(written below). If the code in question in Q1 is not&lt;/li&gt;
	&lt;li&gt;satisified and we have not reached end of pattern, then check if&lt;/li&gt;
	&lt;li&gt;rest of the characters in pattern are all &apos;%&apos;. If yes, then we&lt;/li&gt;
	&lt;li&gt;can simply return from this method wil TRUE return value. I have&lt;/li&gt;
	&lt;li&gt;question Q2 at this point&lt;/li&gt;
	&lt;li&gt;Q1)I copied the code from the old method implementation which at&lt;/li&gt;
	&lt;li&gt;this point checks if we have reached the end of valueIterator&lt;/li&gt;
	&lt;li&gt;then we should return TRUE value. I think that is incorrect&lt;/li&gt;
	&lt;li&gt;because we have reached the end of valueIterator, but there&lt;/li&gt;
	&lt;li&gt;might be more characters in the pattern that we have not&lt;/li&gt;
	&lt;li&gt;matched yet.&lt;/li&gt;
	&lt;li&gt;Q2)What would be the best way to implement the logic to handle&lt;/li&gt;
	&lt;li&gt;valueIterator for a % found in the pattern.&lt;/li&gt;
	&lt;li&gt;g)Go back to step C).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12527628" author="mamtas" created="Fri, 14 Sep 2007 21:44:55 +0100"  >&lt;p&gt;The patch submitted by me will not work on Sun&apos;s jdks (I have tested Sun jdk142 and jdk15) because of the issues found with next() and previous() calls on CollationElementIterator with Sun&apos;s jdks (more info about this can be found at &lt;a href=&quot;http://www.nabble.com/Question-about-next%28%29-and-previous%28%29-on-CollationElementIterator.-tf4418042.html#a12601408&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/Question-about-next%28%29-and-previous%28%29-on-CollationElementIterator.-tf4418042.html#a12601408&lt;/a&gt;)&lt;/p&gt;</comment>
                            <comment id="12528131" author="kmarsden" created="Mon, 17 Sep 2007 20:45:55 +0100"  >&lt;p&gt;Mamta, will running with Sun JVM&apos;s cause the existing functionality to regress in some way or will it just mean that the bug you are fixing won&apos;t be fixed when running with Sun JVM&apos;s?&lt;/p&gt;</comment>
                            <comment id="12528994" author="mamtas" created="Thu, 20 Sep 2007 07:09:40 +0100"  >&lt;p&gt;Kathey, I am trying to see if I can rewrite my code using getOffset/setOffset rather than previous on CollationElementIterator. Assuming getOffset/setOffset work correctly with Sun JVM, we may be able to have a fix that works for Sun JVM as well. I am working on the changes right now and will post a patch if the changes seem to work fine.&lt;/p&gt;</comment>
                            <comment id="12529212" author="kmarsden" created="Thu, 20 Sep 2007 20:06:22 +0100"  >&lt;p&gt;I ran lang/FullCollationTest with the existing patch. I did not do a full analysis because I know there is a new patch coming, but I did seem some null pointer exceptions and an error which look like they may be an issue with the patch. I am attaching the results for your reference.&lt;/p&gt;
</comment>
                            <comment id="12529295" author="mamtas" created="Fri, 21 Sep 2007 01:11:32 +0100"  >&lt;p&gt;Kathey, I am pretty certain that the patch(which I am attaching to this jira entry, patch name patch2_with_setOffset_diff_Sep2007.txt)  I am working on will take of quite a few null ptr exceptions if not all. This patch is an attempt to use getOffset/setOffset rather than next/previous on CollationElementIterator because of the bug in Sun&apos;s JVM. The patch is not ready for commit and has quite a few printlns but I think that should not interfere with junit run. I am running some tests of my own right now and will fire the full collation test once those tests are done. In the mean time, if you happen have some cycles to try the full collation test on your machine with this collation patch, I will greatly appreciate that. Thanks&lt;/p&gt;</comment>
                            <comment id="12529483" author="kmarsden" created="Fri, 21 Sep 2007 17:31:28 +0100"  >&lt;p&gt;Mamta, thanks for all your work on this. You are right, the NPE&apos;s are gone!  I still see an exception:&lt;/p&gt;

&lt;p&gt;1) testWildcardAsEscape(org.apache.derbyTesting.functionTests.tests.lang.DynamicLikeOptimizationTest)java.sql.SQLException: Escape character must be followed by escape character, &apos;_&apos;, or &apos;%&apos;. It cannot be followed by any other character or be at the end of the pattern.&lt;br/&gt;
	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:202)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:391)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:1574)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1315)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:618)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeQuery(EmbedStatement.java:153)&lt;br/&gt;
	at org.apache.derbyTesting.functionTests.tests.lang.DynamicLikeOptimizationTest.testWildcardAsEscape(DynamicLikeOptimizationTest.java:181)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:95)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
	at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
	at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
Caused by: ERROR 22025: Escape character must be followed by escape character, &apos;_&apos;, or &apos;%&apos;. It cannot be followed by any other character or be at the end of the pattern.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:280)&lt;br/&gt;
	at org.apache.derby.iapi.types.Like.like(Like.java:382)&lt;br/&gt;
	at org.apache.derby.iapi.types.WorkHorseForCollatorDatatypes.like(WorkHorseForCollatorDatatypes.java:183)&lt;br/&gt;
	at org.apache.derby.iapi.types.CollatorSQLChar.like(CollatorSQLChar.java:186)&lt;br/&gt;
	at org.apache.derby.exe.ac9423444ax0115x2607x4835x00003dcd3cb40.e1(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:141)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:156)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:168)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(BasicNoPutResultSetImpl.java:248)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1225)&lt;br/&gt;
	... 44 more&lt;/p&gt;

&lt;p&gt;I have not reviewed the code yet. I will do that after you post the new patch.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;</comment>
                            <comment id="12529493" author="mamtas" created="Fri, 21 Sep 2007 17:55:59 +0100"  >&lt;p&gt;Kathey, I am looking at the escape character problem. &lt;/p&gt;</comment>
                            <comment id="12531903" author="mamtas" created="Tue, 2 Oct 2007 21:24:31 +0100"  >&lt;p&gt;Attaching patch DERBY2967_offset_based_diff_Oct02_07.txt which fixes &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt; for both IBM&apos;s jdks and Sun&apos;s jdks. The fix involves using CollationElementIterator to look through collation elements of a character string as needed rather than fetching them all into an array before hand. With the later approach, we may end up getting all the collation elements for a &lt;br/&gt;
really large string when we will be looking at say only first few of those collation elements because we have found a mismatch between value and pattern.&lt;/p&gt;

&lt;p&gt;The majority of the changes have gone into iapi.types.Like class. This class has two different implementation of SQL LIKE clause. One implementation is for UCS_BASIC character strings and the other one is for territory based character strings. The territory based implementation of LIKE clause has been changed in this patch. From a top level, this method does one to one comparison of collation elements for string that is being searched and the pattern that is being searched in that string. This one-to-one comparison is done for non-metacharacters in the pattern. As soon as we find a metacharacter in the pattern string, we do special processing depending on what kind of metacharacter we are dealing with.&lt;br/&gt;
1)Taking the simplest case of escape character as the metacharacter. If the user has provided an escape character, then as soon as we encounter the escape character in the pattern string, we check if the character following it is a metacharacter or&lt;br/&gt;
not. If not, we throw an exception. If the character indeed is a metacharacter, we convert that metacharacter into it&apos;s collation element(s) and look for the exact match of those collation element(s) into the CollationElementIterator for the value string.&lt;br/&gt;
2)Taking the next simplest case of _. When we find a _ in the pattern string, we advance in the CollationElementIterator for the value string by one character. This is where it gets tricky ie what is defined as one character in a particular locale. In Norwegian locale, &apos;b&apos; is a single character and so are &apos;aa&apos;. Both of these character strings translate into single collation element. But in Norwegian locale, evne though &apos;\uFA2D&apos; is one character, it translates into 2 collation elements. This advancing by one character and eating the right number of collation elements is implemented in a new method in Like.java class and the new method&apos;s name is advnaceByOne(CollationElementIterator).&lt;br/&gt;
3)Moving on to metacharacter %. A % can be satisfied by 0 to any number of characters in the value string. In order to determine how many characters will satisfy %, we have to start with 0 character and keep eating more and more characters until we find a match for the remaining pattern string and value string or until we reach end of value string but still non % characters left in pattern string. In the later case, we know we have ended up with a mismatch and we return a FALSE from the method.&lt;/p&gt;

&lt;p&gt;The javadoc(from Like.java&apos;s like(CollationElementIterator, int, String, int, String, RuleBasedCollator)) describes the implementation in little more detail and I have copied that here for reference. Note that in the following method, valueIterator is the CollationElementIterator for the character string that we are doing a search into.&lt;/p&gt;


&lt;p&gt;***************&lt;b&gt;beginning of javadoc&lt;/b&gt;****************&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This method will be called for character string types with territory&lt;/li&gt;
	&lt;li&gt;based collation to see if valueIterator matches the passed pattern&lt;/li&gt;
	&lt;li&gt;string. The logic of the method is described in following steps (I&lt;/li&gt;
	&lt;li&gt;have tried to put the step identifiers in the code below for reference).&lt;/li&gt;
	&lt;li&gt;A)If pattern string or value Iterator is null, then this method will&lt;/li&gt;
	&lt;li&gt;return null because the results of LIKE can&apos;t be established in such&lt;/li&gt;
	&lt;li&gt;a situation.&lt;/li&gt;
	&lt;li&gt;B)Start the loop&lt;/li&gt;
	&lt;li&gt;a)Check the lengths of valueIterator and pattern string to see if it&lt;/li&gt;
	&lt;li&gt;is time to return with TRUE/FALSE. The exact details of these checks&lt;/li&gt;
	&lt;li&gt;can be found in the javadoc method of&lt;/li&gt;
	&lt;li&gt;checkLengths(CollationElementIterator, String, int)&lt;/li&gt;
	&lt;li&gt;b)Start looking at pattern where the pointer is pointing and keep&lt;/li&gt;
	&lt;li&gt;going until you find end of pattern or you find one of the&lt;/li&gt;
	&lt;li&gt;metacharacters ie %, * or optional escape character.&lt;/li&gt;
	&lt;li&gt;c)Get a CollationElementIterator for the non-metacharacters found in&lt;/li&gt;
	&lt;li&gt;step b(using the Collator passed to this method. The same Collator&lt;/li&gt;
	&lt;li&gt;was used to construct valueIterator).&lt;/li&gt;
	&lt;li&gt;d)Make sure that collation elements found in step c) match the&lt;/li&gt;
	&lt;li&gt;collation elements in valueIterator. A mismatch would require us to&lt;/li&gt;
	&lt;li&gt;return FALSE from this method.&lt;/li&gt;
	&lt;li&gt;e)Check again the lengths of valueIterator and pattern string to see&lt;/li&gt;
	&lt;li&gt;if it is time toreturn with TRUE/FALSE. The exact details of these&lt;/li&gt;
	&lt;li&gt;checks can be found in the javadoc method of&lt;/li&gt;
	&lt;li&gt;checkLengths(CollationElementIterator, String, int)&lt;/li&gt;
	&lt;li&gt;f)If we are still here and didn&apos;t return from this method as a result&lt;/li&gt;
	&lt;li&gt;of step Be) then it means that we have to deal with the&lt;/li&gt;
	&lt;li&gt;metacharacter found in step Bc). Check what metacharacter is the&lt;/li&gt;
	&lt;li&gt;offset in pattern pointing to&lt;/li&gt;
	&lt;li&gt;1)If user has provided escape character and pattern is pointing to&lt;/li&gt;
	&lt;li&gt;one right now, then convert the next character in pattern to it&apos;s&lt;/li&gt;
	&lt;li&gt;collation element(s) and compare those collation elements to&lt;/li&gt;
	&lt;li&gt;elements in valueIterator. If they do not match, we need to return&lt;/li&gt;
	&lt;li&gt;FALSE.&lt;/li&gt;
	&lt;li&gt;2)If it is not escape character, then check if it is a &apos;%&apos;. If it is,&lt;/li&gt;
	&lt;li&gt;then increment the pointer in the pattern string by 1 and then&lt;/li&gt;
	&lt;li&gt;follow the involved algorithm below&lt;/li&gt;
	&lt;li&gt;First check if we have reached the end of pattern. If yes, then we&lt;/li&gt;
	&lt;li&gt;can simply return from this method with TRUE return value. If we&lt;/li&gt;
	&lt;li&gt;have not reached end of pattern, then check if rest of the&lt;/li&gt;
	&lt;li&gt;characters in pattern are all &apos;%&apos;. If yes, then we can simply&lt;/li&gt;
	&lt;li&gt;return from this method wil TRUE return value. If not all %, then&lt;/li&gt;
	&lt;li&gt;take rest of the pattern string and see if it matches rest of the&lt;/li&gt;
	&lt;li&gt;valueIterator(will be implemented by recursively calling this&lt;/li&gt;
	&lt;li&gt;method). If no match, then do the step Ba). If it is not time to&lt;/li&gt;
	&lt;li&gt;return because of step Ba), then advance the pointer in&lt;/li&gt;
	&lt;li&gt;valueIterator by one character and see if the valueIterator now&lt;/li&gt;
	&lt;li&gt;matches the rest of the pattern string. Keep going until we find&lt;/li&gt;
	&lt;li&gt;the match or mismatch.&lt;/li&gt;
	&lt;li&gt;3)If it is not escape character or %, then check if it is a _. If&lt;/li&gt;
	&lt;li&gt;yes, then skip all the collation elements in valueIterator&lt;/li&gt;
	&lt;li&gt;corresponding to the next character.&lt;/li&gt;
	&lt;li&gt;g)Go back to step B).&lt;br/&gt;
***************&lt;b&gt;end of javadoc&lt;/b&gt;****************&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I have changed SQLChar and WorkHorseForCollatorDatatypes to call this new method for territory based character string types in Like rather than the old implementation (I have removed the old implementation code from Like.java)&lt;/p&gt;

&lt;p&gt;I have added a new test in CollationTest. The existing tests for LIKE in CollationTest2 have been very handy during my testing of the code changes.&lt;/p&gt;

&lt;p&gt;In addition to the above tests, I have run full collation test under Norwegian territory. Following is the analysis of some of the test failures and fixes to subset of them.&lt;/p&gt;

&lt;p&gt;1)There are few existing tests that use character string &apos;aa&apos; in their testing. These existing test were written to run in UCS_BASIC collation and hence &apos;aa&apos; didn&apos;t cause a problem. But now when we run the full collation tests with say Norwegian territory based locale, the character string &apos;aa&apos; exhibit different behavior(because in Norwegian, it is treated as one character) and hence give the false impression of test failures. To avoid having to scan these false failures every time one runs full&lt;br/&gt;
collation tests with Norwegian territory, I have changed the test data in some tests. This has bring the test failures far lower when all the tests are run with territory based locale rather than UCS_BASIC.&lt;/p&gt;

&lt;p&gt;2)Few other failures in full collation test will be the error message string mismatch when running the tests in UCS_BASIC &lt;br/&gt;
vs territory based. For eg, LOB.out has error messages like following&lt;br/&gt;
ERROR 42818: Comparisons between &apos;CHAR (UCS_BASIC)&apos; and &apos;CLOB (UCS_BASIC)&apos; are not supported. Types must be comparable. String types must also have matching collation. If collation does not match, a possible solution is to cast operands to force them to the default collation (e.g. select tablename from sys.systables where CAST(tablename as VARCHAR(128)) = &apos;T1&apos;)&lt;br/&gt;
This error message will have TERRITORY BASED rather than UCS_BASIC in it&apos;s text when the test is run in territory based. So even though it might look like a test failure when LOB test in run in territory based locale, it is really not a test failure. I think there are 2 tests which will show diffs for this reason. They are LOB.sql and implicitConversoins.&lt;/p&gt;

&lt;p&gt;3)The diff in orderby.sql is also genuine because with UCS_BASIC database, &quot;Canada&quot; sorts before &quot;anaconda&quot; but with &lt;br/&gt;
TERRITORY_BASED database, &quot;anaconda&quot; sorts before &quot;Canada&quot;. &lt;/p&gt;

&lt;p&gt;4)The diffs in Nist tests dml068 and dml079 look genuine too because data is getting sorted in different order with TERRITORY_BASED database and UCS_BASIC database.&lt;/p&gt;

&lt;p&gt;5)DataSourceTest checks the format of Connection.toString and in case of a database created with terriotry based collation, the format of database string is alphabets/alphabets where as the test is looking for just alphabets for the database name.&lt;/p&gt;

&lt;p&gt;6)The diff in InListMultiProbeTest is expected because in a territory based database _ sorts before &apos;1&apos; whereas in a UCS_BASIC database, _ sorts after &apos;1&apos;. eg create and load a table using following script in both kinds of databases.&lt;br/&gt;
create table dellater(c1 char(1));&lt;br/&gt;
insert into dellater values(&apos;1&apos;),(&apos;_&apos;),(&apos;2&apos;);&lt;br/&gt;
Now, the result of following query differs in 2 kinds of databases&lt;br/&gt;
select * from dellater where c1 &amp;gt;= &apos;_&apos; order by c1;&lt;br/&gt;
TERRITORY BASED db&lt;br/&gt;
C1&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;_&lt;br/&gt;
1&lt;br/&gt;
2&lt;br/&gt;
3 rows selected&lt;/p&gt;

&lt;p&gt;UCS_BASIC db&lt;br/&gt;
C1&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;_&lt;br/&gt;
1 row selected&lt;/p&gt;

&lt;p&gt;7)Other than the ones mentioned above, there are few tests failing with assert exception but I do not think they are related to&lt;br/&gt;
changes that are in this patch. Kathey, I think you have run full collation tests in the past. I wonder if you had seen then &lt;br/&gt;
assert failures even before applying this current patch of mine.&lt;/p&gt;</comment>
                            <comment id="12531956" author="djd" created="Wed, 3 Oct 2007 00:15:47 +0100"  >&lt;p&gt;Looking carefully at the SQL Standard - section 8.5 SR 3 c) ii) 4) then currently (I think) Derby&apos;s LIKE with TERRITORY_BASED collation is not being implemented correctly.&lt;/p&gt;

&lt;p&gt;For a pattern like &apos;aa&apos; (norway) or &apos;ch&apos; (spain) then the SQL standard indicates that LIKE operates a character at a time. So the pattern is not the combination of &apos;aa&apos; or &apos;ch&apos;, but two separate characters &apos;a&apos; &apos;a&apos; or &apos;c&apos; &apos;h&apos; . The collation is only used when comparing this single (  &apos;exactly 1 (one)&apos; ) character.&lt;/p&gt;

&lt;p&gt;MySQL indicates this as well, stating LIKE performs matching on a per-character basis, thus it can produce different results to the = comparison operator.&lt;/p&gt;

&lt;p&gt;E.g. &apos;AA&apos;  LIKE &apos;&#197;&apos;  is FALSE, but &apos;AA&apos; = &apos;&#197;&apos; is TRUE&lt;/p&gt;

&lt;p&gt;This would indicate that during LIKE processing a CollationElementIterator should only ever be created on a single character,&lt;br/&gt;
though this does go back to Kathey&apos;s question of what is a single character (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3080&quot; title=&quot;With TERRITORY_BASED collation, when multiple characters map to a single collation element &amp;#39;_&amp;#39;  matches a single collation element rather than a single character&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3080&quot;&gt;&lt;del&gt;DERBY-3080&lt;/del&gt;&lt;/a&gt;). There seem to be three forms&lt;br/&gt;
that could be called a single character:&lt;/p&gt;

&lt;p&gt;1) A simple single Unicode codepoint such a &apos;&#197;&apos;   U+212B&lt;/p&gt;

&lt;p&gt;2) A single Unicode codepoint followed by one or more combining marks, e.g. U+0041 U+030A&lt;/p&gt;

&lt;p&gt;3) A contraction, where two or more characters &lt;b&gt;sort as if&lt;/b&gt; they were a single base character (e.g. CH in spanish)&lt;/p&gt;

&lt;p&gt;Unicode TR10 I think is saying that 1) and 2) are single characters, but 3) is not.&lt;/p&gt;

&lt;p&gt;(MySQL reference: &lt;a href=&quot;http://dev.mysql.com/doc/refman/4.1/en/string-comparison-functions.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dev.mysql.com/doc/refman/4.1/en/string-comparison-functions.html&lt;/a&gt;  )&lt;/p&gt;</comment>
                            <comment id="12532155" author="djd" created="Wed, 3 Oct 2007 17:32:10 +0100"  >&lt;p&gt;The SQL Standard also specifies what a single  character is: Section 4.2.8 indicates all UCS strings should be normalized as Normalization Form C (NFC) as defined by Unicode technical report 15.&lt;/p&gt;</comment>
                            <comment id="12532518" author="mamtas" created="Thu, 4 Oct 2007 21:25:11 +0100"  >&lt;p&gt;I spent some time on Unicode specification and SQL specification in regards to this Jira entry and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3080&quot; title=&quot;With TERRITORY_BASED collation, when multiple characters map to a single collation element &amp;#39;_&amp;#39;  matches a single collation element rather than a single character&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3080&quot;&gt;&lt;del&gt;DERBY-3080&lt;/del&gt;&lt;/a&gt;. SQL specification, Section 3.1.1.1 says this for character &quot;This is identical to the Unicode definition of abstract character. In ISO/IEC 9075, when the relevant character repertoire is UCS, a character can be thought of as that which is represented by one code point.&quot; The Unicode standard specifies a numeric value (code point) and a name for each of its characters. &lt;/p&gt;

&lt;p&gt;So, the question is, in say Norwegian, what do we call &quot;AA&quot;? Is it a character or something else? Unicode specificaiton has a concept of text elemenets and characters (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf&lt;/a&gt; Unicode chapter 2 Section 2.1 subtopic &quot;Text Elements, Characters, and Text Processes&quot;. Text elements are units in a text and there are several kinds of text elements, some of which are grapheme clusters(&quot;user-perceived characters&quot;), words, sentences etc. Characters are used to represent each of these different types of text elements. Grapheme clusters are what user perceives as a single character but they may or maynot be single characters underneath. For eg, &quot;ch&quot; in Slovakian is perceived by user as a single character (ie a grapheme cluster) but it is composed of 2 characters &quot;c&quot; and &quot;h&quot; as 2. Another eg would be &quot;AA&quot; in Norwegian. Unicode treats &quot;AA&quot; as a grapheme cluster which is composed of 2 characters &quot;A&quot; and &quot;A&quot;. (Unicode chapter 2 Figure 2.1 and &lt;a href=&quot;http://unicode.org/reports/tr29/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://unicode.org/reports/tr29/&lt;/a&gt; Section 1). &lt;/p&gt;

&lt;p&gt;So, coming to our question of should &quot;AA&quot; be treated as 2 characters in like but as one character in = operation? &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf&lt;/a&gt; chapter 2 Section 2.1 subtopic &quot;Text Elements, Characters, and Text Processes&quot; also talks about how something can be a text element for one kind of text processing but not for another kind of text processing. I think what we are discussing here is that for Norwegian, we want to treat &quot;AA&quot; as grapheme cluster when we are using an = operator eg &quot;AA&quot; = &apos;&#197;&apos; but &quot;AA&quot; is not a grapheme cluster when it is used in a LIKE operation eg &apos;AA&apos; LIKE &apos;&#197;&apos;. In other words, we want to use a CollationElementIterator on entire character string when we are dealing with = operator. But when working with LIKE operator, we want to generate a CollationElementIterator for one character at a time rather than one a grapheme cluster. This logic goes with what SQL spec wants us to do for = and LIKE. &lt;/p&gt;

&lt;p&gt;Quoting SQL spec for = Section 8.2 &amp;lt;comparison predicate&amp;gt; General Rules 3d) &quot;Depending on the collation, two strings may compare as equal even if they are of different lengths or contain different sequences of characters&quot;. &lt;/p&gt;

&lt;p&gt;Quoting SQL spec fo LIKE General Rules 3cii)&lt;br/&gt;
1) A substring of MCV(the string in which we are trying to find a match) is a sequence of 0 (zero) or more contiguous characters of MCV and each character of MCV is part of exactly one substring.&lt;br/&gt;
2) If the i-th substring of PCV(the pattern that we are looking for in MCV) is an arbitrary character specifier, then the i-th substring of MCV is any single character.&lt;br/&gt;
3) If the i-th substring of PCV is an arbitrary string specifier, then the i-th substring of MCV is any sequence of 0 (zero) or more characters.&lt;br/&gt;
4) If the i-th substring of PCV is a single character specifier, then the i-th substring of MCV contains exactly 1 (one) character that is equal to the character represented by the single character specifier according to the collation of the &amp;lt;like predicate&amp;gt;.&lt;br/&gt;
5) The number of substrings of MCV is equal to the number of substring specifiers of PCV.&lt;/p&gt;

&lt;p&gt;Based on above, I think the like method for territory based character string types has to deal with one character at a time in pattern and in value string. If the character in pattern is not a metacharacter, then we should convert it into it&apos;s collation element(s) and compare it with the collation elements(s) of the next character in value string. If the character in pattern is _, then we should eat next element in value string. If the character in pattern is escape character, then we should look at next character in pattern and convert it into it&apos;s collation element(s) and compare it with the collation element(s) of the next character in value string. Finally, if the character in pattern is %, then we should eat 0 to n character in value string until we find a match for rest of the pattern characters or we find a mismatch following the algorithm in this paragraph.&lt;/p&gt;</comment>
                            <comment id="12533261" author="mamtas" created="Tue, 9 Oct 2007 05:37:21 +0100"  >&lt;p&gt;Bernt Johnsen made following comments on the derby dev list&lt;/p&gt;

&lt;p&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Mamta A. Satoor (JIRA) wrote (2007-10-04 13:25:50):&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt; So, the question is, in say Norwegian, what do we call &quot;AA&quot;? Is it a&lt;br/&gt;
&amp;gt; character or something else? Unicode specificaiton has a concept of&lt;br/&gt;
&amp;gt; text elemenets and characters&lt;br/&gt;
&amp;gt; (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf&lt;/a&gt; Unicode&lt;br/&gt;
&amp;gt; chapter 2 Section 2.1 subtopic &quot;Text Elements, Characters, and Text&lt;br/&gt;
&amp;gt; Processes&quot;. Text elements are units in a text and there are several&lt;br/&gt;
&amp;gt; kinds of text elements, some of which are grapheme&lt;br/&gt;
&amp;gt; clusters(&quot;user-perceived characters&quot;), words, sentences&lt;br/&gt;
&amp;gt; etc. Characters are used to represent each of these different types&lt;br/&gt;
&amp;gt; of text elements. Grapheme clusters are what user perceives as a&lt;br/&gt;
&amp;gt; single character but they may or maynot be single characters&lt;br/&gt;
&amp;gt; underneath. For eg, &quot;ch&quot; in Slovakian is perceived by user as a&lt;br/&gt;
&amp;gt; single character (ie a grapheme cluster) but it is composed of 2&lt;br/&gt;
&amp;gt; characters &quot;c&quot; and &quot;h&quot; as 2. Another eg would be &quot;AA&quot; in&lt;br/&gt;
&amp;gt; Norwegian. Unicode treats &quot;AA&quot; as a grapheme cluster which is&lt;br/&gt;
&amp;gt; composed of 2 characters &quot;A&quot; and &quot;A&quot;. (Unicode chapter 2 Figure 2.1&lt;br/&gt;
&amp;gt; and &lt;a href=&quot;http://unicode.org/reports/tr29/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://unicode.org/reports/tr29/&lt;/a&gt; Section 1).&lt;/p&gt;


&lt;p&gt;The way I understand the Unicode standard, graphems and graphem&lt;br/&gt;
clusters are solely there for rendering while characters and combining&lt;br/&gt;
characters are there for text processing. Thus, we should not consider&lt;br/&gt;
graphemes when we are discussing SQL.&lt;/p&gt;

&lt;p&gt;In Norwegian, there are no combining character which make up &quot;aa&quot; and&lt;br/&gt;
thus &quot;aa&quot; is TWO characters. However, for sorting purposes, &quot;aa&quot; is&lt;br/&gt;
one text element. For all other purposes it is two text elements.&lt;/p&gt;

&lt;p&gt;My conclusion here is that &quot;aa&quot; = &quot;&#229;&quot; is false and &quot;aa&quot; LIKE &quot;&#229;&quot; is&lt;br/&gt;
false too, and that CHARACTER_LENGTH(&quot;aa&quot;) always gives 2.&lt;/p&gt;

&lt;p&gt;(REMARK: A person with the name &quot;H&#229;kon&quot; may not write his name&lt;br/&gt;
&quot;Haakon&quot; and vice versa. The strings are not equal, and it is not the&lt;br/&gt;
same name. They are, however, of the same origin (old Norse &quot;H&#225;konn&quot; I&lt;br/&gt;
think), pronounced the same way and they are sorted together).&lt;/p&gt;

&lt;p&gt;(REMARK 2 (and not relevant for this discussion): &quot;AA&quot; is not used in&lt;br/&gt;
modern Norwegian language. You will only find it in names of persons,&lt;br/&gt;
companies and organizations).&lt;/p&gt;


&lt;p&gt;Bernt&lt;br/&gt;
&quot;&lt;/p&gt;</comment>
                            <comment id="12533263" author="mamtas" created="Tue, 9 Oct 2007 05:48:20 +0100"  >&lt;p&gt;Bernt, I tend to disagree with &apos;aa&apos;=&apos;&#229;&apos; is false statement based on my understanding of SQL spec Section 8.2 &amp;lt;comparison predicate&amp;gt; General Rules 3c) and 3d). &lt;br/&gt;
3c) The result of the comparison of X and Y is given by the collation CS.&lt;br/&gt;
3d) Depending on the collation, two strings may compare as equal even if they are of different lengths or contain different sequences of characters.&lt;/p&gt;

&lt;p&gt;Based on these 2 rules, if the collation CS for Norwegian compares &apos;aa&apos; and &apos;&#229;&apos; as true, then the result of &apos;aa&apos;=&apos;&#229;&apos; will be true. In other words, if the collation elements for &apos;aa&apos; matches &apos;&#229;&apos;, then it means that collation CS compares them equal.&lt;/p&gt;

&lt;p&gt;I can see how a person with name &quot;H&#229;kon&quot; may not write his name &quot;Haakon&quot; or vice versa but I think if my interpretation of SQL spec is right, then SQL is going to treat &quot;H&#229;kon&quot;=&quot;Haakon&quot; depending on the collation CS. Do let me know if my understanding of SQL spec in this area is incorrect.&lt;/p&gt;</comment>
                            <comment id="12533306" author="bernt" created="Tue, 9 Oct 2007 10:03:54 +0100"  >&lt;p&gt;Mamta, you are right. SQL spec Section 4.2.2 also defines the relation between collation and comparision very clear. The downside is that most applications using collation must be very careful in the use of collation to get the correct semantics. Since &quot;H&#229;kon&quot; and &quot;Haakon&quot; as alternate ways of spelling the same name will be considered equal while &quot;Christian&quot; and &quot;Kristian&quot; which also is alternate spellings of another name will not. But, that is beside the point. The SQL standard is very clear.&lt;/p&gt;

&lt;p&gt;Then, to use the lingo from Unicode. &quot;aa&quot; will be one &lt;b&gt;text element&lt;/b&gt; (not a grapheme cluser) with regards to both sorting and comparision.&lt;/p&gt;</comment>
                            <comment id="12533310" author="bernt" created="Tue, 9 Oct 2007 10:12:38 +0100"  >&lt;p&gt;I also agree that even if &apos;aa&apos;=&apos;&#229;&apos; should be true with Norwegian collation, &apos;aa&apos; LIKE &apos;&#229;&apos; should give false according to secion 8.5 which says that LIKE is done on a character by character comparision. &apos;aa&apos; is two characters while &apos;&#229;&apos; is one.&lt;/p&gt;</comment>
                            <comment id="12533401" author="djd" created="Tue, 9 Oct 2007 17:08:55 +0100"  >&lt;p&gt;Actually I think the correct terminology for this is Contractions, from Unicode TR10 which is the specification for collation. The example given there (which avoids the &apos;aa&apos; not in use issue), is &apos;ch&apos; for Spanish.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://unicode.org/reports/tr10/#Contractions&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://unicode.org/reports/tr10/#Contractions&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12534114" author="mamtas" created="Thu, 11 Oct 2007 19:20:50 +0100"  >&lt;p&gt;I am attaching a new patch (DERBY2967_Oct11_07_diff.txt) which is much simpler than earlier patches because the implementation of LIKE for UCS_BASIC and territory based character string types do not differ much(based on SQL standard as explained in earlier few comments to this Jira entry). I have been able to change the existing code for LIKE (in Like.java) for UCS_BASIC character strings to support territory based character strings. The existing method in Like.java now gets a new parameter and it is RuleBasedCollator. For UCS_BASIC strings, this will be passed as NULL. We check if the RuleBasedCollator is NULL and if so then we do simple one character equality check for non-metacharacters in pattern and correspnding characters in value string. But if RuleBasedCollator is not NULL, then we use it to get collation element(s) for one character at a time for non-metacharacters in patterns and corresponding characters in value string and do the collation element(s) comparison to establish equality. &lt;/p&gt;

&lt;p&gt;In addition to the above mentioned change in Like.java, I have changed the callers of the method in Like.java to pass correct value for the RuleBasedCollator. &lt;/p&gt;

&lt;p&gt;Additionally, I have added a test to CollationTest.java for the code changes. Existing like tests in CollationTest2.java were very useful in the testing of my changes. And lastly, I changed few of the existing tests to use different character string values so that when we run the full collation tests, we do not see some of the test failures which are genuine because of the nature of their data. &lt;/p&gt;

&lt;p&gt;Would appreciate if someone has time to review the patch for me. I will plan on committing this early next week if there are no issues.&lt;/p&gt;</comment>
                            <comment id="12535339" author="mamtas" created="Tue, 16 Oct 2007 21:48:24 +0100"  >&lt;p&gt;Committed(revision 585261) DERBY2967_Oct11_07_diff.txt into main codeline with following commit comments&lt;/p&gt;

&lt;p&gt;Commiting the patch (DERBY2967_Oct11_07_diff.txt) attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;. The implementation of LIKE for UCS_BASIC and territory based character string types do not differ much(based on SQL standard as explained in comments to this Jira entry). I have been able to change the existing code for LIKE (in Like.java) for UCS_BASIC character strings to support territory based character strings. The existing method in Like.java now gets a new parameter and it is RuleBasedCollator. For UCS_BASIC strings, this will be passed as NULL. We check if the RuleBasedCollator is NULL and if so then we do simple one character equality check for non-metacharacters in pattern and correspnding characters in value string. But if RuleBasedCollator is not NULL, then we use it to get collation element(s) for one character at a time for non-metacharacters in patterns and corresponding characters in value string and do the collation element(s) comparison to establish equality. &lt;/p&gt;

&lt;p&gt;In addition to the above mentioned change in Like.java, I have changed the callers of the method in Like.java to pass correct value for the RuleBasedCollator. &lt;/p&gt;

&lt;p&gt;Additionally, I have added a test to CollationTest.java for the code changes. Existing like tests in CollationTest2.java were very useful in the testing of my changes. And lastly, I changed few of the existing tests to use different character string values so that when we run the full collation tests, we do not see some of the test failures which are genuine because of the nature of their data. &lt;/p&gt;

&lt;p&gt;File committed are as follows&lt;br/&gt;
M    java/engine/org/apache/derby/iapi/types/Like.java&lt;br/&gt;
M    java/engine/org/apache/derby/iapi/types/SQLChar.java&lt;br/&gt;
M    java/engine/org/apache/derby/iapi/types/WorkHorseForCollatorDatatypes.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/unitTests/lang/T_Like.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest2.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/DynamicLikeOptimizationTest.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/StreamsTest.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml068.sql&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/nist/xts729.sql&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/master/dml068.out&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/master/xts729.out&lt;/p&gt;</comment>
                            <comment id="12535479" author="knutanders" created="Wed, 17 Oct 2007 09:54:02 +0100"  >&lt;p&gt;I read the Oct 11 patch in the commit log and I have a question about checkEquality(). Sorry that I didn&apos;t comment before.&lt;/p&gt;

&lt;p&gt;It looks like checkEquality() will create two String objects and two CollationElementIterator objects per character we want to check. This sounds overly expensive to me. Do you think there is a cheaper way to achieve the same?&lt;/p&gt;

&lt;p&gt;I have a couple of ideas which may or may not work:&lt;/p&gt;

&lt;p&gt;a) We could use the compare() method instead of iterators. It caches and reuses the iterators across calls and therefore it might be more efficient. It would also simplify the code, since the else clause in checkEquality() could be rewritten to:&lt;/p&gt;

&lt;p&gt;} else &lt;/p&gt;
{//dealing with territory based character string
    return collator.compare(new String(pat, pLoc, 1), new String(val, vLoc, 1)) == 0:
}

&lt;p&gt;b) To eliminate &lt;b&gt;both&lt;/b&gt; the String allocations and the CollationElementIterator allocations, I think we could allocate one CollationElementIterator for each string (as opposed to each character) and use setOffset()/getOffset() to ensure that we work on one character at a time.&lt;/p&gt;</comment>
                            <comment id="12535953" author="mamtas" created="Thu, 18 Oct 2007 16:57:58 +0100"  >&lt;p&gt;Migrated changes from trunk(revision 585261) into 10.3(revision 586019) codeline with following commit comments&lt;/p&gt;

&lt;p&gt;Migrating changes (revision 585261) from trunk into 10.3 codeline. I had to make some manual changes after merging because CollationTest had few changes in main which were not part of 10.3 codeline. The commit comments for the trunk codeline checkin were as follows&lt;/p&gt;

&lt;p&gt;Commiting the patch (DERBY2967_Oct11_07_diff.txt) attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;. The implementation of LIKE for UCS_BASIC and territory based character string types do not differ much(based on SQL standard as explained in comments to this Jira entry). I have been able to change the existing code for LIKE (in Like.java) for UCS_BASIC character strings to support territory based character strings. The existing method in Like.java now gets a new parameter and it is RuleBasedCollator. For UCS_BASIC strings, this will be passed as NULL. We check if the RuleBasedCollator is NULL and if so then we do simple one character equality check for non-metacharacters in pattern and correspnding characters in value string. But if RuleBasedCollator is not NULL, then we use it to get collation element(s) for one character at a time for non-metacharacters in patterns and corresponding characters in value string and do the collation element(s) comparison to establish equality. &lt;/p&gt;

&lt;p&gt;In addition to the above mentioned change in Like.java, I have changed the callers of the method in Like.java to pass correct value for the RuleBasedCollator. &lt;/p&gt;

&lt;p&gt;Additionally, I have added a test to CollationTest.java for the code changes. Existing like tests in CollationTest2.java were very useful in the testing of my changes. And lastly, I changed few of the existing tests to use different character string values so that when we run the full collation tests, we do not see some of the test failures which are genuine because of the nature of their data. &lt;/p&gt;

&lt;p&gt;M    java/engine/org/apache/derby/iapi/types/Like.java&lt;br/&gt;
M    java/engine/org/apache/derby/iapi/types/SQLChar.java&lt;br/&gt;
M    java/engine/org/apache/derby/iapi/types/WorkHorseForCollatorDatatypes.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/unitTests/lang/T_Like.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest2.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/DynamicLikeOptimizationTest.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/lang/StreamsTest.java&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml068.sql&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/tests/nist/xts729.sql&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/master/dml068.out&lt;br/&gt;
M    java/testing/org/apache/derbyTesting/functionTests/master/xts729.out&lt;/p&gt;</comment>
                            <comment id="12535958" author="mamtas" created="Thu, 18 Oct 2007 17:09:46 +0100"  >&lt;p&gt;Thanks, Knut,  for checking my commit. I was hesitant too about all the objects creations.&lt;/p&gt;

&lt;p&gt;I think we can definitely make the first change suggested by you. I will go ahead and give it a try&lt;br/&gt;
************&lt;b&gt;part of the change suggested by Knut&lt;/b&gt;***************&lt;br/&gt;
a) We could use the compare() method instead of iterators. It caches and reuses the iterators across calls and therefore it might be more efficient. It would also simplify the code, since the else clause in checkEquality() could be rewritten to: &lt;/p&gt;

&lt;p&gt;} else &lt;/p&gt;
{//dealing with territory based character string 
    return collator.compare(new String(pat, pLoc, 1), new String(val, vLoc, 1)) == 0: 
}
&lt;p&gt; &lt;br/&gt;
************&lt;b&gt;end of part of the change suggested by Knut&lt;/b&gt;********&lt;/p&gt;

&lt;p&gt;But as for the second alternative, we can&apos;t create a CollationElementIerator for the entire string ahead of time for LIKE operation. Let me use an example to illustrate why. In Norway, the collation element(s) returned for string &apos;aa&apos; is not same as collation element(s) return for one &apos;a&apos; at a time. So, when the user has a WHERE clause  &apos;caad&apos; LIKE &apos;%a%&apos;, SQL spec requires us to return a TRUE for this WHERE clause. We will not implement that behavior if we generated collation elements for entire string &apos;caad&apos; at one shot. We need to break &apos;caad&apos; into four characters and have collation element for each one of those 4 characters. In Norway, if we generated collation elements for string &apos;caad&apos;, it will find only 3 characters in that string and those 3 characters will be &apos;c&apos;, &apos;aa&apos; and &apos;d&apos;.  Because of this, we have to generate collation element(s) one character at a time.&lt;/p&gt;

&lt;p&gt;Would love to hear if there are any other ideas to cut down on object creation.&lt;/p&gt;</comment>
                            <comment id="12535972" author="knutanders" created="Thu, 18 Oct 2007 18:00:08 +0100"  >&lt;p&gt;According to the javadoc for CollationElementIterator, setOffset() and getOffset() work on characters, not on collation elements, so I think you can use those methods to detect the aa case. If you have this code in locale no_NO:&lt;/p&gt;

&lt;p&gt;  CollationElementIterator it = collator.getCollationElementIterator(&quot;aa&quot;);&lt;br/&gt;
  int coll = it.next();&lt;/p&gt;

&lt;p&gt;I think it.getOffset() will return 0 before the call to next() and 2 after the call. So you&apos;ll notice that there are more than one character, and, if required, use a heavier test for that character.&lt;/p&gt;</comment>
                            <comment id="12535974" author="knutanders" created="Thu, 18 Oct 2007 18:08:59 +0100"  >&lt;p&gt;Another simple way to cut down the string allocations... I think you could express checkEquality() like this:&lt;/p&gt;

&lt;p&gt;    if (val&lt;span class=&quot;error&quot;&gt;&amp;#91;vLoc&amp;#93;&lt;/span&gt; == pat&lt;span class=&quot;error&quot;&gt;&amp;#91;pLoc&amp;#93;&lt;/span&gt;) &lt;/p&gt;
{
        // same character, so two strings consisting of this
        // single character must be equal regardless of territory
        return true;
    }
&lt;p&gt; else if (collator == null) &lt;/p&gt;
{
        // not same character, must be unequal in UCS_BASIC
        return false;
    }

&lt;p&gt;    String s1 = new String(val, vLoc, 1);&lt;br/&gt;
    String s1 = new String(pat, pLoc, 1);&lt;/p&gt;

&lt;p&gt;    return collator.compare(s1, s2) == 0;&lt;/p&gt;

&lt;p&gt;This would only allocate new objects if the characters are not equal.&lt;/p&gt;</comment>
                            <comment id="12535975" author="mamtas" created="Thu, 18 Oct 2007 18:14:29 +0100"  >&lt;p&gt;Knut, I really like the last suggestion because it will keep the code easy to understand. I think the earlier suggestion about using getOffset and setOffset will complicate the code and make it hard to understand and maintain.&lt;/p&gt;

&lt;p&gt;I will work on your last suggestion.&lt;/p&gt;

&lt;p&gt;*****&lt;b&gt;great suggestion by Knut to cut down on unnecessary objection creations&lt;/b&gt;***&lt;br/&gt;
Another simple way to cut down the string allocations... I think you could express checkEquality() like this: &lt;/p&gt;

&lt;p&gt;    if (val&lt;span class=&quot;error&quot;&gt;&amp;#91;vLoc&amp;#93;&lt;/span&gt; == pat&lt;span class=&quot;error&quot;&gt;&amp;#91;pLoc&amp;#93;&lt;/span&gt;) &lt;/p&gt;
{ 
        // same character, so two strings consisting of this 
        // single character must be equal regardless of territory 
        return true; 
    }
&lt;p&gt; else if (collator == null) &lt;/p&gt;
{ 
        // not same character, must be unequal in UCS_BASIC 
        return false; 
    }
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;    String s1 = new String(val, vLoc, 1); &lt;br/&gt;
    String s1 = new String(pat, pLoc, 1); &lt;/p&gt;

&lt;p&gt;    return collator.compare(s1, s2) == 0; &lt;/p&gt;

&lt;p&gt;This would only allocate new objects if the characters are not equal. &lt;br/&gt;
******************************************************************************************&lt;/p&gt;</comment>
                            <comment id="12535987" author="knutanders" created="Thu, 18 Oct 2007 18:36:14 +0100"  >&lt;p&gt;One more question: In the discussion above, I see that the special case where two strings of different length map to the same sequence of collation elements, has been discussed. What about two characters, c1 and c2, which have different Unicode codepoints, but map to the same sequence of collation elements. Should both c1 = c2 and c1 LIKE c2 be true? That&apos;s how it&apos;s implemented, but I&apos;m not sure whether c1 LIKE c2 should be true or false. I haven&apos;t checked what the standard says (and I&apos;m not sure I want to... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ), but it feels a bit strange that two different characters should be LIKE because they have the same collation elements, when &apos;aa&apos; is not LIKE &apos;&#229;&apos; because they are not the same single character. I understand how we can split the character sequence &apos;aa&apos; into the single characters &apos;a&apos; and &apos;a&apos;. I don&apos;t understand how we can take a single collation element &apos;aa&apos; and split it into two separate collation elements &apos;a&apos; and &apos;a&apos;. I&apos;m sure the standard says it&apos;s correctly implemented, and I guess its wording will make it quite clear, perhaps even logical, that it has to be that way. I just wanted to double check that we had verified it...&lt;/p&gt;</comment>
                            <comment id="12535993" author="knutanders" created="Thu, 18 Oct 2007 18:53:59 +0100"  >&lt;p&gt;I just realized how confusing my comment must have been... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m not questioning whether it&apos;s correct that &apos;aa&apos; LIKE &apos;&#229;&apos; is false. What I&apos;m questioning is whether we can split a string into its separate characters, possibly splitting a single collation element into multiple different elements, and then do a comparison of the collation elements on each single character. To me it feels like we should forget about the collation elements once we have split the string into characters, since the information about collation elements got lost in the process of splitting, and just do a simple codepoint comparison on the character level. Again, I&apos;m sure the standard says I&apos;m wrong...&lt;/p&gt;</comment>
                            <comment id="12536004" author="mamtas" created="Thu, 18 Oct 2007 19:36:12 +0100"  >&lt;p&gt;Knut, we can not ignore the collation and just compare the codepoint for territory based characters involved in LIKE operaiton. This is based of SQL spec for LIKE(Section 8.5) General Rules 3cii4) &lt;br/&gt;
4) If the i-th substring of PCV is a single character specifier, then the i-th substring of MCV contains exactly 1 (one) character that is equal to the character represented by the single character specifier according to the collation of the &amp;lt;like predicate&amp;gt;. &lt;/p&gt;

&lt;p&gt;Here it says that we need to establish the equality according to the collation of the &amp;lt;like predicate&amp;gt;.&lt;/p&gt;

&lt;p&gt;As always, let me know if I interpretation of SQL is incorrect.&lt;/p&gt;</comment>
                            <comment id="12536105" author="mamtas" created="Fri, 19 Oct 2007 05:54:57 +0100"  >&lt;p&gt;I have entered jira entry &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3136&quot; title=&quot;Cut down on object creations in LIKE clause implementation of territory based characters.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3136&quot;&gt;&lt;del&gt;DERBY-3136&lt;/del&gt;&lt;/a&gt; to improve on object creations.&lt;/p&gt;</comment>
                            <comment id="12536170" author="knutanders" created="Fri, 19 Oct 2007 11:12:57 +0100"  >&lt;p&gt;Thanks for pointing me to the right part of the standard, Mamta. I interpret general rule 3cii the same way as you do.&lt;/p&gt;</comment>
                            <comment id="12536570" author="mamtas" created="Mon, 22 Oct 2007 06:39:01 +0100"  >&lt;p&gt;The coding for this jira entry is over(I have created a new jira entry &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3136&quot; title=&quot;Cut down on object creations in LIKE clause implementation of territory based characters.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3136&quot;&gt;&lt;del&gt;DERBY-3136&lt;/del&gt;&lt;/a&gt; to improve on object creations). &lt;/p&gt;

&lt;p&gt;I am wondering though if we should include something in our documentation to show the difference between = and LIKE in a territory based database. For eg, even though &apos;aa&apos; = &apos;&#229;&apos; in Norwegian territory, &apos;aa&apos; LIKE &apos;&#229;&apos;  will not return true in Norwegian territory. That is, we probably should document somewhere that LIKE is entirely collation comparison of one character at a time in a territory based database.&lt;/p&gt;</comment>
                            <comment id="12536705" author="knutanders" created="Mon, 22 Oct 2007 16:21:22 +0100"  >&lt;p&gt;When you said &quot;even though &apos;aa&apos; = &apos;&#229;&apos; in Norwegian territory&quot;, do you mean the SQL = operator? That doesn&apos;t seem to work on trunk. Is there a JIRA issue I have missed?&lt;/p&gt;

&lt;p&gt;ij&amp;gt; connect &apos;jdbc:derby:nodb;create=true;territory=no_NO;collation=TERRITORY_BASED&apos;;&lt;br/&gt;
ij&amp;gt; select * from sysibm.sysdummy1 where &apos;&#229;&apos; = &apos;aa&apos;;&lt;br/&gt;
IBM&amp;amp;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;0 rows selected&lt;/p&gt;</comment>
                            <comment id="12536768" author="mamtas" created="Mon, 22 Oct 2007 18:59:43 +0100"  >&lt;p&gt;Knut, yes, I did mean the SQL = operation. Also, thanks for your testing.&lt;/p&gt;

&lt;p&gt;From various discussions in the past on Derby list about aa and &#229; in Norwegian, I made the assumption that the JVM&apos;s collation table for Norwegian must have same collation element for aa and &#229;. But that is not the case as shwon by your test case inside ij. I also wrote a very simple test case outside of Derby(copied below) which shows the collation elements for aa and &#229; are different in Norwegian and that is why the SQL operation &apos;aa&apos;=&apos;&#229;&apos; is returning false.&lt;/p&gt;

&lt;p&gt;RuleBasedCollator myCollator = (RuleBasedCollator)Collator.getInstance(new Locale(&quot;da&quot;,&quot;DK&quot;));&lt;/p&gt;

&lt;p&gt;System.out.println(&quot;what happens if iterator is on aa string&quot;);&lt;br/&gt;
CollationElementIterator aIterator = myCollator.getCollationElementIterator(&quot;aa&quot;);&lt;br/&gt;
System.out.println(&quot;next is &quot; + aIterator.next());&lt;br/&gt;
System.out.println(&quot;offset is &quot; + aIterator.getOffset());&lt;br/&gt;
System.out.println(&quot;next is &quot; + aIterator.next());&lt;br/&gt;
System.out.println(&quot;offset is &quot; + aIterator.getOffset());&lt;/p&gt;

&lt;p&gt;System.out.println(&quot;what happens if iterator is on &#229; string&quot;);&lt;br/&gt;
aIterator = myCollator.getCollationElementIterator(&quot;&#229;&quot;);&lt;br/&gt;
System.out.println(&quot;next is &quot; + aIterator.next());&lt;br/&gt;
System.out.println(&quot;offset is &quot; + aIterator.getOffset());&lt;br/&gt;
System.out.println(&quot;next is &quot; + aIterator.next());&lt;br/&gt;
System.out.println(&quot;offset is &quot; + aIterator.getOffset());&lt;/p&gt;

&lt;p&gt;Output of the code above&lt;br/&gt;
what happens if iterator is on aa string&lt;br/&gt;
next is 7405570&lt;br/&gt;
offset is 2&lt;br/&gt;
next is -1&lt;br/&gt;
offset is 2&lt;br/&gt;
what happens if iterator is on &#963; string&lt;br/&gt;
next is 7405568&lt;br/&gt;
offset is 1&lt;br/&gt;
next is -1&lt;br/&gt;
offset is 1&lt;/p&gt;

&lt;p&gt;So, my example to show different behavior of SQL LIKE and SQL = is not correct. &lt;/p&gt;

&lt;p&gt;I am wondering if anyone knows of any characters in a language where the characters are different but they have the same collation elements in that language. The test case is going to require different &lt;b&gt;number&lt;/b&gt; of characters in each side of =. Having different &lt;b&gt;number&lt;/b&gt; of characters(but same collation element(s)) is crucial to show the difference between = and LIKE.&lt;/p&gt;</comment>
                            <comment id="12536792" author="knutanders" created="Mon, 22 Oct 2007 19:59:37 +0100"  >&lt;p&gt;Thanks Mamta, that makes sense.&lt;/p&gt;

&lt;p&gt;&amp;gt; I am wondering if anyone knows of any characters in a language where&lt;br/&gt;
&amp;gt; the characters are different but they have the same collation&lt;br/&gt;
&amp;gt; elements in that language.&lt;/p&gt;

&lt;p&gt;FWIW, I grepped for &apos;=&apos; in the CollationData classes (they contain the&lt;br/&gt;
rules used by the locale-specific RuleBasedCollators) in OpenJDK but I&lt;br/&gt;
didn&apos;t find any multi-character sequences that had the same collation&lt;br/&gt;
elements as another character or sequence of characters.&lt;/p&gt;</comment>
                            <comment id="12539108" author="scotsmatrix" created="Wed, 31 Oct 2007 15:52:27 +0000"  >&lt;p&gt;I have opened Derby-3166 as a doc issue for this dev issue.  My impression is that LIKE only compares single characters and contractions (aa or ch) are not compared. Is there anything else that needs to be documented?  Please add any comments that you have about what needs to be updated in the docs to the new doc issue Derby-3166.  Thanks!&lt;/p&gt;</comment>
                            <comment id="12540281" author="mamtas" created="Mon, 5 Nov 2007 21:27:44 +0000"  >&lt;p&gt;Attached, please find the release notes for this Jira entry. I tend to be verbose with my notes, so please feel free to condense them or offer any other suggestions.&lt;/p&gt;

&lt;p&gt;Also, when I tried using &lt;br/&gt;
java org.apache.derbyBuild.ReleaseNoteReader releaseNotes.html&lt;br/&gt;
I kept getting following error&lt;br/&gt;
Exception in thread &quot;main&quot; java.io.UTFDataFormatException: Invalid byte 1 of 1-byte UTF-8 sequence.&lt;br/&gt;
        at org.apache.xerces.impl.io.UTF8Reader.invalidByte(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.impl.io.UTF8Reader.read(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.impl.XMLEntityScanner.load(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.impl.XMLEntityScanner.scanContent(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanContent(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.parsers.DOMParser.parse(Unknown Source)&lt;br/&gt;
        at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source)&lt;br/&gt;
        at javax.xml.parsers.DocumentBuilder.parse(DocumentBuilder.java:98)&lt;br/&gt;
        at org.apache.derbyBuild.ReleaseNoteReader.getReleaseNote(ReleaseNoteReader.java:130)&lt;br/&gt;
        at org.apache.derbyBuild.ReleaseNoteReader.main(ReleaseNoteReader.java:107)&lt;/p&gt;</comment>
                            <comment id="12540291" author="mamtas" created="Mon, 5 Nov 2007 22:45:05 +0000"  >&lt;p&gt;Attaching the release notes with proper name.  Kathey mentioned that &quot;I think the name should be releaseNote.html to get picked up by the release notes tool. Kathey&quot;&lt;/p&gt;</comment>
                            <comment id="12542846" author="kmarsden" created="Thu, 15 Nov 2007 18:54:40 +0000"  >&lt;p&gt;Can this issue be resolved?&lt;/p&gt;</comment>
                            <comment id="12545588" author="mamtas" created="Mon, 26 Nov 2007 20:21:12 +0000"  >&lt;p&gt;I have created a new jira entry &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3228&quot; title=&quot;Add a test case for collation where in some territory, more than one character sequence(say n characters and it is seq1) has same collation elements as some other character sequence(with &amp;gt;n or &amp;lt;n characters and say it is seq2) &quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3228&quot;&gt;DERBY-3228&lt;/a&gt; for the only remaining item for this jira entry which is adding a specific test case. (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3228&quot; title=&quot;Add a test case for collation where in some territory, more than one character sequence(say n characters and it is seq1) has same collation elements as some other character sequence(with &amp;gt;n or &amp;lt;n characters and say it is seq2) &quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3228&quot;&gt;DERBY-3228&lt;/a&gt;&apos;s description reads as &quot;Add a test case for collation where in some territory, more than one character sequence(say n characters and say that character sequence is seq1) has same collation elements as some other character sequence(with &amp;gt;n or &amp;lt;n characters and say that character sequence is seq2) so we can demonstrate that for that territory the predicate seq1=seq2 will return TRUE but predicate seq1 LIKE seq2 will return FALSE. The engine code changes for this test case went in as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;. More info if needed can be found there).&quot;&lt;/p&gt;

&lt;p&gt;Will go ahead and close this jira entry so that the release notes attached to it can be included as part of 10.3.2 release.&lt;/p&gt;</comment>
                            <comment id="12545603" author="kmarsden" created="Mon, 26 Nov 2007 21:03:27 +0000"  >&lt;p&gt;reattaching release note. There was some sort of problem with the original release note. It gave:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;generateReleaseNotes&amp;#93;&lt;/span&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;generateReleaseNotes&amp;#93;&lt;/span&gt; Unable to read or parse release note for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;: org.xml.sax.SAXParseException: Invalid byte&lt;br/&gt;
1 of 1-byte UTF-8 sequence.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;generateReleaseNotes&amp;#93;&lt;/span&gt; org.xml.sax.SAXParseException: Invalid byte 1 of 1-byte UTF-8 sequence.&lt;/p&gt;

&lt;p&gt;Content has not changed&lt;/p&gt;</comment>
                            <comment id="12545630" author="mamtas" created="Mon, 26 Nov 2007 22:26:40 +0000"  >&lt;p&gt;Kathey, thanks for trying to resolve the problem with release notes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;I had not intended to use any unprintable characters in the release notes. I noticed that you mail to derby-dev about release notes has ? characters(I guess those are the unprintable characters) in the &quot;Symptoms Seen by Applications Affected by Change&quot; section for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;. Those ? characters should really be just &apos;. I see that there are other places in &quot;Symptoms Seen by Applications Affected by Change&quot; where &apos; didn&apos;t get changed to unprintable characters. I am not sure why some of &apos; are getting treated as unprintable character. So, in short, wherever we see ? in the &quot;Symptoms Seen by Applications Affected by Change&quot; section for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2967&quot; title=&quot;Single character does not match high value unicode character with collation TERRITORY_BASED&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2967&quot;&gt;&lt;del&gt;DERBY-2967&lt;/del&gt;&lt;/a&gt;, we should really have &apos; there. &lt;/p&gt;

&lt;p&gt;Hope this is clear,&lt;br/&gt;
Mamta&lt;/p&gt;</comment>
                            <comment id="12546315" author="kmarsden" created="Wed, 28 Nov 2007 17:48:43 +0000"  >&lt;p&gt;Attach release note with &apos; instead of ? to try to get release note generator working.&lt;/p&gt;</comment>
                            <comment id="12546341" author="mamtas" created="Wed, 28 Nov 2007 18:34:18 +0000"  >&lt;p&gt;Kathey, I did a quick review of the release note and it looks good. Hope the release note generator works with it. Thanks&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12381565">DERBY-3166</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12345445">DERBY-1478</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12367589" name="DERBY2967_Oct11_07_diff.txt" size="34170" author="mamtas" created="Thu, 11 Oct 2007 19:20:50 +0100"/>
                            <attachment id="12367590" name="DERBY2967_Oct11_07_stat.txt" size="959" author="mamtas" created="Thu, 11 Oct 2007 19:20:50 +0100"/>
                            <attachment id="12366953" name="DERBY2967_offset_based_diff_Oct02_07.txt" size="47409" author="mamtas" created="Tue, 2 Oct 2007 21:24:31 +0100"/>
                            <attachment id="12366954" name="DERBY2967_offset_based_stat_Oct02_07.txt" size="797" author="mamtas" created="Tue, 2 Oct 2007 21:24:31 +0100"/>
                            <attachment id="12363344" name="TestFrench.java" size="3498" author="kmarsden" created="Tue, 7 Aug 2007 18:48:52 +0100"/>
                            <attachment id="12363442" name="TestNorway.java" size="3100" author="kmarsden" created="Wed, 8 Aug 2007 21:58:41 +0100"/>
                            <attachment id="12366307" name="fullcoll.out" size="189484" author="kmarsden" created="Thu, 20 Sep 2007 20:06:22 +0100"/>
                            <attachment id="12366376" name="patch2_setOffset_fullcoll.out" size="1609751" author="kmarsden" created="Fri, 21 Sep 2007 17:31:28 +0100"/>
                            <attachment id="12366320" name="patch2_with_setOffset_diff_Sep2007.txt" size="31266" author="mamtas" created="Fri, 21 Sep 2007 01:11:32 +0100"/>
                            <attachment id="12366321" name="patch2_with_setOffset_stat_Sep2007.txt" size="506" author="mamtas" created="Fri, 21 Sep 2007 01:11:32 +0100"/>
                            <attachment id="12370425" name="releaseNote.html" size="2069" author="kmarsden" created="Wed, 28 Nov 2007 17:48:43 +0000"/>
                            <attachment id="12370238" name="releaseNote.html" size="2069" author="kmarsden" created="Mon, 26 Nov 2007 21:03:27 +0000"/>
                            <attachment id="12365823" name="step1_iteratorbased_Sep1507_diff.txt" size="26407" author="mamtas" created="Fri, 14 Sep 2007 09:25:06 +0100"/>
                            <attachment id="12365824" name="step1_iteratorbased_Sep1507_stat.txt" size="291" author="mamtas" created="Fri, 14 Sep 2007 09:25:06 +0100"/>
                            <attachment id="12365572" name="temp_diff.txt" size="26540" author="mamtas" created="Tue, 11 Sep 2007 17:11:45 +0100"/>
                            <attachment id="12365573" name="temp_stat.txt" size="291" author="mamtas" created="Tue, 11 Sep 2007 17:11:46 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 7 Aug 2007 21:25:50 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23350</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy10nj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39756</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>