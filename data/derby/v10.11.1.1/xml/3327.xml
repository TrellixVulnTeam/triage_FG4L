<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:15:05 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3327/DERBY-3327.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3327] SQL roles: Implement authorization stack (and SQL session context to hold it)</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3327</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The current LanguageConnectionContext keeps the user authorization identifier for an SQL session.&lt;br/&gt;
The lcc is shared context also for nested connections (opened from stored procedures).&lt;br/&gt;
So far, for roles, the current role has been stored in the lcc also. However, SQL requires that&lt;br/&gt;
authorization identifers be pushed on a &quot;authorization stack&quot; when calling a stored procedure, cf.&lt;br/&gt;
SQL 2003, vol 2, section 4.34.1.1 and 4.27.3 and 10.4 GR 5h and i.&lt;br/&gt;
This allows a caller to keep its current role after a call even if changed by the stored procedure.&lt;/p&gt;

&lt;p&gt;This issue will implement the current role name part (&quot;cell&quot;) of the authorization stack. &lt;/p&gt;

&lt;p&gt;The authorization stack will be implemented as part of the SQL session context.&lt;br/&gt;
The patch will also implement the pushing of the current unqualified schema name part of&lt;br/&gt;
the SQL session context, cf. 10.4 GR 5a (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;</description>
                <environment></environment>
        <key id="12386518">DERBY-3327</key>
            <summary>SQL roles: Implement authorization stack (and SQL session context to hold it)</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="dagw">Dag H. Wanvik</reporter>
                        <labels>
                    </labels>
                <created>Thu, 17 Jan 2008 17:14:05 +0000</created>
                <updated>Mon, 20 Sep 2010 00:32:48 +0100</updated>
                            <resolved>Mon, 7 Jul 2008 09:36:50 +0100</resolved>
                                                    <fixVersion>10.5.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12560042" author="dagw" created="Thu, 17 Jan 2008 19:21:18 +0000"  >&lt;p&gt;This patch implements an authorization stack for roles. The basic idea&lt;br/&gt;
is as follows: For the top level, the current role is kept in the&lt;br/&gt;
lcc. For dynamic call contexts (while in nested connections opened&lt;br/&gt;
from a stored procedure/function), the current role is kept in the&lt;br/&gt;
activation of the calling statement. The lcc keeps a stack of call&lt;br/&gt;
activations to help initialize the activations so they know their&lt;br/&gt;
calling activation.&lt;/p&gt;

&lt;p&gt;If several nested connections are opened inside a stored procedure&lt;br/&gt;
they share the authorization context.&lt;/p&gt;

&lt;p&gt;If a dynamic result set is passed out referring to the current role&lt;br/&gt;
inside a stored procedure, the correct (nested) value will result,&lt;br/&gt;
since the activation of the call is still live.&lt;/p&gt;

&lt;p&gt;RolesTest has also been extended to test these semantics.&lt;br/&gt;
The patch also fixes a bug in SetRoleConstantAction.&lt;/p&gt;

&lt;p&gt;For review only at this point. I have run regression tests without any&lt;br/&gt;
errors. Any feedback is welcome!&lt;/p&gt;</comment>
                            <comment id="12560559" author="rhillegas" created="Fri, 18 Jan 2008 21:36:25 +0000"  >&lt;p&gt;Thanks for the patch, Dag. One item puzzled me: Is there a reason that getCurrentRole() and setCurrentRole() in BaseActivation are manipulating a field called nestedCurrentRole rather than a field called currentRole?&lt;/p&gt;</comment>
                            <comment id="12560598" author="dagw" created="Fri, 18 Jan 2008 23:22:30 +0000"  >&lt;p&gt;Thanks for looking at this, Rick!&lt;br/&gt;
Re your question:&lt;br/&gt;
Not really, just to emphaszie that this field will only ever hold the current role of a stored procedure scope; never&lt;br/&gt;
the outer scope. But since it can be confusing, I will change it to currentRole and leave the it to the comments&lt;br/&gt;
to explain this fact. &lt;/p&gt;

&lt;p&gt;Btw, I have vacillated a bit over whether to call the field holding the current role (a string)&lt;br/&gt;
currentRole, currentRoleName or currentRoleId. The standard uses the term &quot;authorization identifier&quot;&lt;br/&gt;
(generic for both user and role), but also plain &quot;role name&quot;. But in SQL section 5.4 I see the syntax is specified as&lt;/p&gt;

&lt;p&gt; &amp;lt;authorization identifier&amp;gt; ::=&lt;br/&gt;
       &amp;lt;role name&amp;gt;&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &amp;lt;user identifier&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;so I will rename fields and arguments whereever appropriate to currentRoleName and roleName at some point,&lt;br/&gt;
I think.  Also,the current code uses &quot;authorizationId&quot; for &lt;b&gt;user identifier&lt;/b&gt; in many places which can also be &lt;br/&gt;
confusing now that roles are introduced. This should probably be cleaned up as well.&lt;/p&gt;</comment>
                            <comment id="12560611" author="dagw" created="Sat, 19 Jan 2008 00:00:54 +0000"  >&lt;p&gt;Renamed nestedCurrentRole  to currentRole as Rick suggested. &lt;br/&gt;
Fixed up a few comments. &lt;/p&gt;</comment>
                            <comment id="12560989" author="knutanders" created="Mon, 21 Jan 2008 11:28:33 +0000"  >&lt;p&gt;What about changing the names of the methods instead? I don&apos;t think it&apos;s a bad idea to spell out the scope of the role, and I only read Rick&apos;s comment as saying that it would be good if the names matched.&lt;/p&gt;

&lt;p&gt;java.util.Stack is a synchronized collection, by the way, so you may want to consider using ArrayList instead. You have already added (push,pop)Caller() methods, so the stack abstraction will be preserved even with a different data structure.&lt;/p&gt;</comment>
                            <comment id="12561030" author="dagw" created="Mon, 21 Jan 2008 15:09:38 +0000"  >&lt;p&gt;Thanks for looking at this, Knut!&lt;/p&gt;

&lt;p&gt;a) naming: Sounds like a good idea. You OK with that, Rick?&lt;/p&gt;

&lt;p&gt;b) Yes, Stack is a bit heavy being based on Vector. I was looking at&lt;br/&gt;
   Deque which is the recommended stack abstraction, &lt;br/&gt;
   (cf. comment at top of &lt;a href=&quot;http://java.sun.com/javase/6/docs/api/java/util/Stack.html:&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/javase/6/docs/api/java/util/Stack.html:&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &quot;...A more complete and consistent set of LIFO stack operations is&lt;br/&gt;
     provided by the Deque interface and its implementations, which&lt;br/&gt;
     should be used in preference to this class.&quot;&lt;/p&gt;

&lt;p&gt;   but it is not available in 1.4, so ArrayList, although less&lt;br/&gt;
   descriptive, is sufficient and probably the better choice here, I&lt;br/&gt;
   agree.&lt;/p&gt;</comment>
                            <comment id="12561046" author="dagw" created="Mon, 21 Jan 2008 16:05:44 +0000"  >&lt;p&gt;New version of the patch, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-3, which addresses both a) and b) above.&lt;br/&gt;
Running regression tests over again.&lt;/p&gt;</comment>
                            <comment id="12561050" author="rhillegas" created="Mon, 21 Jan 2008 16:23:20 +0000"  >&lt;p&gt;Thanks for the new patch, Dag. Now that the method names and variable names agree, it&apos;s easier for me to read the code.&lt;/p&gt;

&lt;p&gt;What happens if you call popCallers() too many times? Will it fail gracefully or could this method use a little defensive logic?&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="12561069" author="dagw" created="Mon, 21 Jan 2008 17:09:57 +0000"  >&lt;p&gt;It will give an IndexOutOfBoundsException, but it should never happen unless there is a&lt;br/&gt;
coding error, so I chose not to add any logic. Better to make it fail early, I think?&lt;/p&gt;</comment>
                            <comment id="12561075" author="rhillegas" created="Mon, 21 Jan 2008 17:27:23 +0000"  >&lt;p&gt;Thanks, Dag. I agree that since this is an internal error (triggered by a bug in Derby) that the IndexOutOfBoundsException is good enough. Cheers-Rick&lt;/p&gt;</comment>
                            <comment id="12561181" author="djd" created="Tue, 22 Jan 2008 00:34:49 +0000"  >&lt;p&gt;One high level comment and some specific comments on the patch:&lt;/p&gt;

&lt;p&gt;high-level&lt;br/&gt;
--------------&lt;/p&gt;

&lt;p&gt;It seems somewhat strange that this is implemented as a stack of activations and because of that we end up needing to store role information in two different places, in the LCC if it&apos;s the top-level and the activation otherwise. Since the activation represents an individual statement is its job to hold SQL context information?&lt;/p&gt;

&lt;p&gt;Looking closer at the SQL standard (4.34.1.1 and 4.27.3) I&apos;m not sure the patch is implementing exactly what is described there.&lt;br/&gt;
One portion is the SQL-session context, that comes into being with the routine invocation. Then within the SQL-session context is an authorization stack.&lt;br/&gt;
The patch seems to be morphing the two into one, executing a routine creates just a role stack.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt; is an outstanding issue to handle SET SCHEMA within routines correctly, which I think falls into the SQL-session context logic, creating a morphed stack here might make it harder to fix that.&lt;/p&gt;

&lt;p&gt;Would it make more sense to have objects that followed the model described by the SQL specification, even if currently they are not fully utilized?&lt;/p&gt;

&lt;p&gt;Something like:&lt;br/&gt;
  SQLSessionContext - pushed for a routine call, stack maintained in the lcc&lt;br/&gt;
             has a field for schema (future for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
             has a field for authorization stack (stack of AuthorizationCell)&lt;/p&gt;

&lt;p&gt;   AuthorizationCell (see 4.34.1.1)&lt;br/&gt;
             field for user identifier&lt;br/&gt;
             field for role name&lt;/p&gt;


&lt;p&gt;Maybe the existing StatementContext class is already fulfilling the purpose of SQLSessionContext?????&lt;/p&gt;

&lt;p&gt;specific patch comments&lt;br/&gt;
----------------------------------&lt;/p&gt;

&lt;p&gt;For the field &apos;callers&apos; in GenericLanguageConnectionContext.java I think it&apos;s holding a stack of Activations. Could you state this in its javadoc.&lt;br/&gt;
(oh for Java 5 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In the javadoc comment for &apos;callers&apos; it says:&lt;/p&gt;

&lt;p&gt;   For the top level, the current role is kept here, cf. &apos;currentRole&apos;. &lt;/p&gt;

&lt;p&gt;Since this is the javadoc for callers, the here applies to callers, but I think you really mean the current class. Would this be correct?&lt;/p&gt;

&lt;p&gt;   For the top level, the current role is kept in this.currentRole.&lt;/p&gt;


&lt;p&gt;In BaseActivation can the comments for the field callActivation be javadoc comments, so that IDE&apos;s will pick them up.&lt;br/&gt;
Can comments be added for nestedCurrentRole.&lt;/p&gt;

&lt;p&gt;Even with the comments for BaseActivation.callActivation I became a little confused. Looking elsewhere I can see that callActivation is the activation of the enclosing CALL statement, that would have been useful in the javadoc. I&apos;m somewhat confused by the need for BaseActivation.callActivation and the stack in the LCC. It seems that the stack of activations is being kept twice, once in LCC and once through the activations. &lt;/p&gt;

&lt;p&gt;I wonder about the cost of this stack maintenance, for SQL routines that are defined as NO SQL it might be a significant overhead. E.g. SIN() function. Avoiding the context manipulation for those routines could be a follow on, but I&apos;d be interested in the overhead with this change.&lt;/p&gt;
</comment>
                            <comment id="12561182" author="dagw" created="Tue, 22 Jan 2008 00:37:21 +0000"  >&lt;p&gt;Re-ran regression tests then committed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-3 as svn 614071, resolving.&lt;/p&gt;</comment>
                            <comment id="12561183" author="dagw" created="Tue, 22 Jan 2008 00:40:17 +0000"  >&lt;p&gt;Sorry, Dan, I belatedly (I committed the patch) noticed you had further comments on this issue, thanks for looking at it!&lt;br/&gt;
I will reopen this issue and consider them.&lt;/p&gt;</comment>
                            <comment id="12561186" author="djd" created="Tue, 22 Jan 2008 00:49:40 +0000"  >&lt;p&gt;np - one other item is that according to section 10.4 routine invocation the order is:&lt;/p&gt;

&lt;p&gt;  GR2) Evaluate arguments&lt;br/&gt;
  GR5) Push new SQL-session context (RSC)&lt;br/&gt;
  GR7/8) Execute the routine&lt;/p&gt;

&lt;p&gt;The order in the patch is:&lt;br/&gt;
   A) Push new authorization context&lt;br/&gt;
   B) Evaluate arguments&lt;br/&gt;
   C) Execute the routine&lt;/p&gt;

&lt;p&gt;To match the order of the spec the new context would need to be part of the generated code.&lt;br/&gt;
Not sure if it makes any difference or not, but something to consider.&lt;/p&gt;

&lt;p&gt;Ok - one other item ...&lt;br/&gt;
   I don&apos;t think the patch addresses functions, since the lcc.pushCaller() is only set from  CallStatementResultSet.&lt;/p&gt;

&lt;p&gt;Performing the context setup in generated code would solve both of these issues.&lt;/p&gt;</comment>
                            <comment id="12561421" author="dagw" created="Tue, 22 Jan 2008 19:05:34 +0000"  >&lt;p&gt;I&apos;ll answer in two segments, the first on the specific patch comments,&lt;br/&gt;
then on the larger issues.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Specific patch comments&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; For the field &apos;callers&apos; in GenericLanguageConnectionContext.java I&lt;br/&gt;
&amp;gt; think it&apos;s holding a stack of Activations. Could you state this in&lt;br/&gt;
&amp;gt; its javadoc.  (oh for Java 5 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Yes, I thought I did say it (&quot;keeps track of which, if any, stored&lt;br/&gt;
procedure activations are active&quot;), but I will make it&lt;br/&gt;
clearer. Generics would have been nice here, yes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&amp;gt; In the javadoc comment for &apos;callers&apos; it says:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    For the top level, the current role is kept here, cf. &apos;currentRole&apos;.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Since this is the javadoc for callers, the here applies to callers,&lt;br/&gt;
&amp;gt; but I think you really mean the current class. Would this be&lt;br/&gt;
&amp;gt; correct?&lt;/p&gt;

&lt;p&gt;You are right. I have moved this comment to where it belongs, with&lt;br/&gt;
&quot;currentRole&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; In BaseActivation can the comments for the field callActivation be&lt;br/&gt;
&amp;gt; javadoc comments, so that IDE&apos;s will pick them up.&lt;/p&gt;

&lt;p&gt;Agree, will do.&lt;/p&gt;

&lt;p&gt;&amp;gt; Can comments be added for nestedCurrentRole.&lt;/p&gt;

&lt;p&gt;Agree, will do.&lt;/p&gt;

&lt;p&gt;&amp;gt; Even with the comments for BaseActivation.callActivation I became a&lt;br/&gt;
&amp;gt; little confused. Looking elsewhere I can see that callActivation is&lt;br/&gt;
&amp;gt; the activation of the enclosing CALL statement, that would have been&lt;br/&gt;
&amp;gt; useful in the javadoc. &lt;/p&gt;

&lt;p&gt;Adding an explicit statement about that.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m somewhat confused by the need for BaseActivation.callActivation&lt;br/&gt;
&amp;gt; and the stack in the LCC. It seems that the stack of activations is&lt;br/&gt;
&amp;gt; being kept twice, once in LCC and once through the activations.&lt;/p&gt;

&lt;p&gt;It&apos;s probably redundant, I will try again see if I can get rid of it.&lt;/p&gt;


&lt;p&gt;&amp;gt; I wonder about the cost of this stack maintenance, for SQL routines&lt;br/&gt;
&amp;gt; that are defined as NO SQL it might be a significant&lt;br/&gt;
&amp;gt; overhead. E.g. SIN() function. Avoiding the context manipulation for&lt;br/&gt;
&amp;gt; those routines could be a follow on, but I&apos;d be interested in the&lt;br/&gt;
&amp;gt; overhead with this change.&lt;/p&gt;

&lt;p&gt;Right. I&apos;ll run some tests. Moving the pushing to code generation (as&lt;br/&gt;
you also) should help us get rid of the overhead for NO SQL functions,&lt;br/&gt;
too.&lt;/p&gt;

&lt;p&gt;&amp;gt; np - one other item is that according to section 10.4 routine&lt;br/&gt;
&amp;gt; invocation the order is:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   GR2) Evaluate arguments&lt;br/&gt;
&amp;gt;   GR5) Push new SQL-session context (RSC)&lt;br/&gt;
&amp;gt;   GR7/8) Execute the routine&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The order in the patch is:&lt;br/&gt;
&amp;gt;    A) Push new authorization context&lt;br/&gt;
&amp;gt;    B) Evaluate arguments&lt;br/&gt;
&amp;gt;    C) Execute the routine&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; To match the order of the spec the new context would need to be part&lt;br/&gt;
&amp;gt; of the generated code.  Not sure if it makes any difference or not,&lt;br/&gt;
&amp;gt; but something to consider.&lt;/p&gt;

&lt;p&gt;I think as long as we run with invoker&apos;s right it does not matter, but&lt;br/&gt;
if/when we decide to add the ability to run with definer&apos;s rights it&lt;br/&gt;
would, since for example an argument refering CURRENT_USER would then&lt;br/&gt;
evaluate differently depending on whether the authorization stack was&lt;br/&gt;
pushed or not, so it would be good to do it in the right order,&lt;/p&gt;

&lt;p&gt;&amp;gt; I don&apos;t think the patch addresses functions, since the&lt;br/&gt;
&amp;gt; lcc.pushCaller() is only set from CallStatementResultSet.&lt;/p&gt;

&lt;p&gt;Yes, thanks. I had added a test (buggy!) which blind sided me there&lt;br/&gt;
for a while.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Larger issues&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; It seems somewhat strange that this is implemented as a stack of&lt;br/&gt;
&amp;gt; activations and because of that we end up needing to store role&lt;br/&gt;
&amp;gt; information in two different places, in the LCC if it&apos;s the&lt;br/&gt;
&amp;gt; top-level and the activation otherwise. Since the activation&lt;br/&gt;
&amp;gt; represents an individual statement is its job to hold SQL context&lt;br/&gt;
&amp;gt; information?&lt;/p&gt;

&lt;p&gt;It is a bit awkward, and it may be the wrong choice.  I would have&lt;br/&gt;
preferred an explicit representation of the new session context (SQL&lt;br/&gt;
10.4&apos;s &quot;RSC&quot;, perhaps called SQLSessionContext object, as you&lt;br/&gt;
suggest), but I did not find one &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I looked at ConnectionContext and&lt;br/&gt;
StatementContext but these classes seems to be available only at the&lt;br/&gt;
JDBC level. At execution time, it seems we have to rely on what&apos;s&lt;br/&gt;
reachable from the activation (lcc, transaction controller, result&lt;br/&gt;
set). Somehow, the activation needs to know its dynamic nesting so&lt;br/&gt;
that it can access the correct dynamic context. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt; would seem&lt;br/&gt;
to indicate we need to go this route at some point anyway, so I&apos;ll&lt;br/&gt;
have a go.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Looking closer at the SQL standard (4.34.1.1 and 4.27.3) I&apos;m not&lt;br/&gt;
&amp;gt; sure the patch is implementing exactly what is described there.  One&lt;br/&gt;
&amp;gt; portion is the SQL-session context, that comes into being with the&lt;br/&gt;
&amp;gt; routine invocation. Then within the SQL-session context is an&lt;br/&gt;
&amp;gt; authorization stack.  The patch seems to be morphing the two into&lt;br/&gt;
&amp;gt; one, executing a routine creates just a role stack.&lt;/p&gt;

&lt;p&gt;Right, although interpreting the standard literally (GR 5.h: &quot;copying&lt;br/&gt;
the authorization stack&quot;) seems to be inefficient, so some morphing&lt;br/&gt;
may be useful &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; Would it make more sense to have objects that followed the model&lt;br/&gt;
&amp;gt; described by the SQL specification, even if currently they are not&lt;br/&gt;
&amp;gt; fully utilized?&lt;/p&gt;

&lt;p&gt;Yes, I think so.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Something like:&lt;br/&gt;
&amp;gt;   SQLSessionContext - pushed for a routine call, stack maintained in the lcc&lt;br/&gt;
&amp;gt;              has a field for schema (future for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
&amp;gt;              has a field for authorization stack (stack of AuthorizationCell)&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    AuthorizationCell (see 4.34.1.1)&lt;br/&gt;
&amp;gt;              field for user identifier&lt;br/&gt;
&amp;gt;              field for role name&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Maybe the existing StatementContext class is already fulfilling the&lt;br/&gt;
&amp;gt; purpose of SQLSessionContext?????&lt;/p&gt;

&lt;p&gt;It does not seem to be reachable from the activation; being confined&lt;br/&gt;
to the JDBC level? A stack of StatementContext is kept in the lcc, but&lt;br/&gt;
the activation does not know which one represents it, AFAICT. I&apos;ll&lt;br/&gt;
have another look, perhaps it could be extended with the information&lt;br/&gt;
needed an allow references from the activation? I think it would be&lt;br/&gt;
better to add new SQLSessionContext, to keep the separation between&lt;br/&gt;
the JDBC and SQL level intact?&lt;/p&gt;

&lt;p&gt;Anyway, I&apos;ll first fix up the current solution with your comments and&lt;br/&gt;
then try to work on a more general solution.&lt;/p&gt;</comment>
                            <comment id="12561476" author="djd" created="Tue, 22 Jan 2008 21:29:00 +0000"  >&lt;p&gt;Thanks for the detailed reply&lt;/p&gt;

&lt;p&gt;StatementContexts are not for the JDBC layer, they are really for the SQL layer. The current statement context can be obtained using lcc.getStatementContext(). If an activation (or its result set) is being executed in any way  then it is the current statement context. Derby is only actively executing a single statement at any time for a connection.&lt;/p&gt;

&lt;p&gt;Another thought is that the context manager exists to handle pushing and popping of contexts, so should this existing paradigm be used to manage new contexts such as a SQLSessionContext or authentication stack. Then error cleanup would be handled consistently, rather than introducing a new mechanism with a different paradigm.&lt;/p&gt;

&lt;p&gt;The statement context may not match the SQLSessionContext in all cases (e.g. it maybe does for a procedure call but not for a function call).&lt;/p&gt;
</comment>
                            <comment id="12561507" author="dagw" created="Tue, 22 Jan 2008 23:01:15 +0000"  >&lt;p&gt;Thanks for the information, it is very useful!&lt;/p&gt;

&lt;p&gt;When you suggest the StatementContext may be sufficient to hold the SQL session context, I presume you mean the StatementContext of the calling statement? It has (about) the same lifetime as the procedure invocation - but see question below. So the activation and/or statementContext of, say, a nested &quot;VALUES CURRENT_USER&quot; would reference the parent (CALL) statement context to get at the nested SQL session context? If you meant the statement context of the &quot;VALUES CURRENT_USER&quot;, it has to get its session state from somewhere? (As I understand it, the lifetime of the statement context is limited to prepare and/or execution of a single statement.)&lt;/p&gt;

&lt;p&gt;What about the following case: I think the activations of dynamic result sets may need the dynamic context after the procedure has returned, say, if the statement yielding the result set references CURRENT_ROLE and that this is evaluated lazily only when the cursor is accessed (rs.next()). The statement context for the CALL has been popped (and reset) at that time (from GEnericPreparedStatement#execute), right? Would it be ok with the current model for it to stay live until the dynamic result set us closed? If not, perhaps a separate SQLConnectionContext (which could stay around longer) is better?&lt;/p&gt;

&lt;p&gt;Also, since the lcc.getStatementContext returns the current top context, it would not yield the right one if invoked by a dynamic result set of an activation after procedure return, I think?&lt;/p&gt;

&lt;p&gt;Sorry if I am misconstruing reality here; trying to understand more &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
</comment>
                            <comment id="12561513" author="djd" created="Tue, 22 Jan 2008 23:16:13 +0000"  >&lt;p&gt;&amp;gt; (As I understand it, the lifetime of the statement context is limited to prepare and/or execution of a single statement.) &lt;/p&gt;

&lt;p&gt;No, the statement context is set up during the ResultSet.next() or any positioning call as well. Code that is executing or fetching rows will have the most recently pushed statement context associated with it. This is so that a statement level exception error handling affects the currently executing statement.&lt;/p&gt;

&lt;p&gt;With a dynamic result I believe that when it is executing (e.g. a next() call) then the most recently pushed statement context will be associated with that result set and the activation/statement that created it.&lt;/p&gt;

&lt;p&gt;So I think I mean only that any statement would always just refer to its StatementContext, which is the most recently pushed one since the statement must be being executed.&lt;/p&gt;
</comment>
                            <comment id="12561741" author="dagw" created="Wed, 23 Jan 2008 17:18:46 +0000"  >&lt;p&gt;Thanks for helping me understand this better!. &lt;/p&gt;

&lt;p&gt;So, I can trust the correct statement context to be available at&lt;br/&gt;
execution time. But it still seems not to be sufficient?  The&lt;br/&gt;
statement context is initialized when pushed on the basis of read-only&lt;br/&gt;
information from EmbedStatement (which is a JDBC level object if I am&lt;br/&gt;
not mistaken again &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; whenever we are preparing/executing/using the&lt;br/&gt;
result set of a statement, but it does not have the lifetime of the&lt;br/&gt;
procedure so it can&apos;t hold the mutable state of current user, role and&lt;br/&gt;
schema?&lt;/p&gt;

&lt;p&gt;Those would have to be stored in a data structure that would persist&lt;br/&gt;
throughout the lifetime of the procedure, I think. First I looked the&lt;br/&gt;
statement context of the caller. But using the debugger I see that the&lt;br/&gt;
statement context of the call of not pushed back when the a next() is&lt;br/&gt;
performed outside the caller on the returned dynamic result set, so&lt;br/&gt;
even the statement context of the caller seems to have too short a&lt;br/&gt;
lifetime to hold the dynamic state of the nested scope.&lt;/p&gt;

&lt;p&gt;So unless I am still missing something here, I will try to work&lt;br/&gt;
towards a new context object to hold the nested SQL session state.&lt;/p&gt;</comment>
                            <comment id="12561747" author="djd" created="Wed, 23 Jan 2008 17:49:49 +0000"  >&lt;p&gt;Just to be clear, I&apos;m not recommending the StatementContext, just trying to ensure that some understanding of it exists before another context is added. The wrong approach would be to blindly add a new context just because StatementContext is not understood. I think there is probably some overlap between the StatementContext and a SQLSessionContext, but maybe StatementContext does not quite match the role of SQLSessionContext, but then what role is StatementContext implementing in the model defined by the SQL standard? Discussion like this is good to get an understanding.&lt;/p&gt;

&lt;p&gt;Maybe Activation is acting as the SQLSession context, as in your first patch?&lt;/p&gt;

&lt;p&gt;I think in the last comment you raise an interesting point: For a procedure that sets a role R and returns dynamic result sets, the role in force during the processing of those dynamic result sets needs to be R, even though the execute of the CALL returned (and thus R was popped from some stack).&lt;/p&gt;</comment>
                            <comment id="12561751" author="djd" created="Wed, 23 Jan 2008 18:09:58 +0000"  >&lt;p&gt;I see the point about dynamic result sets was already noted in the functional spec.&lt;/p&gt;

&lt;p&gt;Looking closely at SET ROLE I see it doesn&apos;t require a authorization stack (within a SQLSessionContext) because it only modifies the current role, it never pushes a new cell onto the authorization stack.&lt;/p&gt;

&lt;p&gt;So I&apos;m coming to thinking that the initial patch is basically correct, with the exception that there is no need to have a stack of activations or to link an activation to its caller. It seems to me the current stacking of StatementContexts has the required information already, upon execution the role of the activation needs to be taken from the role of the activation of currently executing statement (the most recently pushed StatementContext) or the lcc if there is no currently statement being executed.&lt;/p&gt;</comment>
                            <comment id="12561754" author="dagw" created="Wed, 23 Jan 2008 18:15:56 +0000"  >&lt;p&gt;&amp;gt; The wrong approach would be to blindly add a new&lt;br/&gt;
&amp;gt; context just because StatementContext is not understood. I think there&lt;br/&gt;
&amp;gt; is probably some overlap between the StatementContext and a&lt;br/&gt;
&amp;gt; SQLSessionContext, but maybe StatementContext does not quite match the&lt;br/&gt;
&amp;gt; role of SQLSessionContext, but then what role is StatementContext&lt;br/&gt;
&amp;gt; implementing in the model defined by the SQL standard? Discussion like&lt;br/&gt;
&amp;gt; this is good to get an understanding.&lt;/p&gt;

&lt;p&gt;I absolutely agree, I am happy to get your feedback on this, Dan!&lt;br/&gt;
I will try to find out where Statement context fits in by reading up&lt;br/&gt;
a bit in the standard.&lt;/p&gt;

&lt;p&gt;&amp;gt; Maybe Activation is acting as the SQLSession context, as in your first&lt;br/&gt;
&amp;gt; patch?&lt;br/&gt;
&amp;gt; I think in the last comment you raise an interesting point: For a&lt;br/&gt;
&amp;gt; procedure that sets a role R and returns dynamic result sets, the role&lt;br/&gt;
&amp;gt; in force during the processing of those dynamic result sets needs to&lt;br/&gt;
&amp;gt; be R, even though the execute of the CALL returned (and thus R was&lt;br/&gt;
&amp;gt; popped from some stack).&lt;/p&gt;

&lt;p&gt;I don&apos;t really grasp fully the design rationales involved in the&lt;br/&gt;
existing code here, I readily admit that. I used the activation of the&lt;br/&gt;
caller because it seems to have the correct lifetime to handle also&lt;br/&gt;
the dynamic result case (making R available after the call has&lt;br/&gt;
returned).&lt;/p&gt;

&lt;p&gt;What I don&apos;t like about that solution is that the asymmetry (lcc for&lt;br/&gt;
outer, caller activation for inner scopes); it would be nice to have a&lt;br/&gt;
SQLSessionContext uniformly available somehow from both the root&lt;br/&gt;
connection scope and inside the procedures...&lt;/p&gt;

</comment>
                            <comment id="12561772" author="dagw" created="Wed, 23 Jan 2008 18:58:08 +0000"  >&lt;p&gt;&amp;gt; Looking closely at SET ROLE I see it doesn&apos;t require a authorization&lt;br/&gt;
&amp;gt; stack (within a SQLSessionContext) because it only modifies the&lt;br/&gt;
&amp;gt; current role, it never pushes a new cell onto the authorization stack.&lt;/p&gt;

&lt;p&gt;Yes, thats how I understand it also, it just needs access to the top element&lt;br/&gt;
somehow, but does not need to see a stack.&lt;/p&gt;

&lt;p&gt;&amp;gt; So I&apos;m coming to thinking that the initial patch is basically correct,&lt;br/&gt;
&amp;gt; with the exception that there is no need to have a stack of&lt;br/&gt;
&amp;gt; activations or to link an activation to its caller. It seems to me the&lt;br/&gt;
&amp;gt; current stacking of StatementContexts has the required information&lt;br/&gt;
&amp;gt; already, upon execution the role of the activation needs to be taken&lt;br/&gt;
&amp;gt; from the role of the activation of currently executing statement (the&lt;br/&gt;
&amp;gt; most recently pushed StatementContext) or the lcc if there is no&lt;br/&gt;
&amp;gt; currently statement being executed.&lt;/p&gt;

&lt;p&gt;Thanks, I will investigate this.&lt;/p&gt;</comment>
                            <comment id="12569959" author="dagw" created="Mon, 18 Feb 2008 17:41:56 +0000"  >&lt;p&gt;A new version of a patch for this issue, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full. It builds&lt;br/&gt;
on the idea of the previous patch of using the activation to hold a&lt;br/&gt;
references to the SQL session context at execution time. This makes&lt;br/&gt;
the context available even after the original statement context has&lt;br/&gt;
gone (needed for dynamic result sets). The SQL session context has&lt;br/&gt;
been factored out into a separate class. The patch also makes the SQL&lt;br/&gt;
session context available at compile time via the statement&lt;br/&gt;
context. This is needed for the solution to work for current default&lt;br/&gt;
schema (in addition to current role). The current patch also solves&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Code is generated for routines (which can contain SQL) to push the SQL&lt;br/&gt;
session context. A new test, SQLSessionContextTest, has been factored&lt;br/&gt;
out from RolesTest which tests the stack semantics for both roles and&lt;br/&gt;
current default schema.&lt;/p&gt;

&lt;p&gt;Depending on feed-back, I may unbundle the changes for default current&lt;br/&gt;
schema in this patch and retain only the current role part to reduce&lt;br/&gt;
the risk; but I include it in this version of the patch as&lt;br/&gt;
proof-of-concept for review.&lt;/p&gt;

&lt;p&gt;I am not totally happy with schema side of the patch; some usages of&lt;br/&gt;
getCurrentSchemaName at execution time break the pattern in that they&lt;br/&gt;
do not (and in deed need not) use the activation argument variant, in&lt;br/&gt;
SpaceTable#getConglomInfo and inside&lt;br/&gt;
SystemProcedures#&lt;/p&gt;
{INSTALL|REPLACE|REMOVE}
&lt;p&gt;_JAR.&lt;br/&gt;
I have noted this in the code as a caveat.&lt;/p&gt;

&lt;p&gt;All regression tests pass.&lt;/p&gt;

&lt;p&gt;Detailed patch comment:&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/iapi/sql/execute/SQLSessionContext.java&lt;br/&gt;
A      java/engine/org/apache/derby/impl/sql/execute/SQLSessionContextImpl.java&lt;/p&gt;

&lt;p&gt;The new interface and implementation class which encapsulates the SQL&lt;br/&gt;
session context&lt;/p&gt;


&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/compile/SpecialFunctionNode.java&lt;/p&gt;

&lt;p&gt;Code changes for CURRENT_ROLE and CURRENT SCHEMA.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java&lt;/p&gt;

&lt;p&gt;Code generation to push SQL session context. There is no separate&lt;br/&gt;
stack; the statement context stack is used. Also an activation still has a&lt;br/&gt;
reference to the calling activation.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/iapi/sql/conn/StatementContext.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/conn/GenericStatementContext.java&lt;/p&gt;

&lt;p&gt;New methods to set and get and a field to hold the SQL session context&lt;br/&gt;
and associated activation, if any.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/iapi/sql/conn/LanguageConnectionContext.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java&lt;/p&gt;

&lt;p&gt;The exisisting fields &quot;sd&quot; (current default schema), currentRole and&lt;br/&gt;
the callers stack have been removed. Instead there is now a field&lt;br/&gt;
topLevelSSC which hold the top level SQL session context and&lt;br/&gt;
cachedInitialDefaultSchemaDescr, which is used to avoid having to&lt;br/&gt;
compute the initial default schema for the session more than once.&lt;/p&gt;

&lt;p&gt;The methods get/setDefaultSchema and getCurrentSchemaName now have two&lt;br/&gt;
variants one for use at compile-time and another for use at execution&lt;br/&gt;
time (activation argument). A new method, resetSchemaUsages, is used&lt;br/&gt;
to set refrences to a dropped schema back to the default value for all&lt;br/&gt;
occurences on the SQL session state stack.&lt;/p&gt;

&lt;p&gt;A new method, setupNestedSessionContext, is used to push the SQL&lt;br/&gt;
session context at routine invocation time, cf. StaticMethodCallNode.&lt;/p&gt;


&lt;p&gt;M      java/engine/org/apache/derby/iapi/sql/Activation.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/GenericActivationHolder.java&lt;/p&gt;

&lt;p&gt;Now hold both the calling activation if any (as earlier), and the SQL&lt;br/&gt;
session context. A new interface method to retrieve the SQL session&lt;br/&gt;
context has been added.&lt;/p&gt;


&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/execute/SetSchemaConstantAction.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/DropSchemaConstantAction.java&lt;/p&gt;

&lt;p&gt;Uses the new execution time variants so the correct SQL session&lt;br/&gt;
context can be used.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/execute/CallStatementResultSet.java&lt;/p&gt;

&lt;p&gt;Changed back to original; the changes having move to code generation,&lt;br/&gt;
see StaticMethodCallNode.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/BasicNoPutResultSetImpl.java&lt;/p&gt;

&lt;p&gt;Associates the current activation with the current statement context.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/impl/sql/GenericPreparedStatement.java&lt;/p&gt;

&lt;p&gt;Sets up activation with caller reference, same semantics, but now uses&lt;br/&gt;
the statement context instead of the callers stack in lcc.&lt;/p&gt;

&lt;p&gt;M      java/engine/org/apache/derby/iapi/sql/dictionary/SchemaDescriptor.java&lt;/p&gt;

&lt;p&gt;The drop method now takes an activation argument, and now calls&lt;br/&gt;
lcc#resetSchemaUsages to clean up.&lt;/p&gt;

&lt;p&gt;A      java/testing/org/apache/derbyTesting/functionTests/tests/lang/SQLSessionContextTest.java&lt;/p&gt;

&lt;p&gt;New test to check that stack semantics hold for roles end schema.&lt;/p&gt;

&lt;p&gt;M      java/testing/org/apache/derbyTesting/functionTests/tests/lang/RolesTest.java&lt;/p&gt;

&lt;p&gt;Slimmed down.&lt;/p&gt;

&lt;p&gt;M      java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java&lt;/p&gt;

&lt;p&gt;Added SQLSessionContextTest.&lt;/p&gt;
</comment>
                            <comment id="12570007" author="rhillegas" created="Mon, 18 Feb 2008 20:57:36 +0000"  >&lt;p&gt;Thanks for the patch, Dag. As usual, I don&apos;t have much to add that&apos;s substantive. Just a couple points:&lt;/p&gt;

&lt;p&gt;o I understand your misgivings about the management of the current schema. The existing code is pretty organic at this point.&lt;/p&gt;

&lt;p&gt;o There are a couple places in the LCC where you lookup the session context based on the Activation. It seems to me that a method like the following might be a useful abstraction:&lt;/p&gt;

&lt;p&gt;public SQLSessionContext    getCurrentSQLSessionContext( Activation caller )&lt;br/&gt;
{&lt;br/&gt;
		if (caller == null ) &lt;/p&gt;
{ return getTopLevelSQLSessionContext(); }
&lt;p&gt;		else &lt;/p&gt;
{ return caller.getNestedSQLSessionContext(); }
&lt;p&gt;}&lt;/p&gt;</comment>
                            <comment id="12570063" author="dagw" created="Tue, 19 Feb 2008 00:30:58 +0000"  >&lt;p&gt;Thanks for looking at this, Rick! As for for the abstraction suggestion,&lt;br/&gt;
I definitely agree.  Uploading &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full-b, which replaces &lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full (and earlier revs), which incorporates your suggestion!&lt;/p&gt;</comment>
                            <comment id="12570495" author="dagw" created="Tue, 19 Feb 2008 23:12:16 +0000"  >&lt;p&gt;Uploaded &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-c, which replaces earlier revs. This version cleans up the modularization a bit&lt;br/&gt;
by moving SQLSessionContext&lt;/p&gt;
{Impl}
&lt;p&gt;? to sql.conn rather than sql.execute since it is not only used at execution time,&lt;br/&gt;
and also removes the need to import the *Impl outside of its package by providing a create method in lcc.&lt;/p&gt;</comment>
                            <comment id="12570497" author="dagw" created="Tue, 19 Feb 2008 23:19:03 +0000"  >&lt;p&gt;Marking with Existing application impact and Release note needed, since the latest revision of the patch, in its solution for to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1331&quot; title=&quot;Derby&amp;#39;s &amp;quot;set schema&amp;quot; behavior is not compliant with SQL 2003 Foundation spec.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1331&quot;&gt;&lt;del&gt;DERBY-1331&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
changes the semantics of SET SCHEMA if performed in a nested connection (inside a routine).&lt;/p&gt;</comment>
                            <comment id="12572894" author="dagw" created="Wed, 27 Feb 2008 12:38:45 +0000"  >&lt;p&gt;Ran some performance tests to see if the new code for getting current schema&lt;br/&gt;
had any substantial impact on performance, but it seems not (a loop executing&lt;br/&gt;
CURRENT SCHEMA inside a stored procedure saw a 3-5% performance hit, which is&lt;br/&gt;
not unreasonable since access is no longer just a simple field access in lcc but &lt;br/&gt;
incurs 3 extra method calls).&lt;/p&gt;

&lt;p&gt;If there are no further comments, I will commit this patch in a few days.&lt;/p&gt;
</comment>
                            <comment id="12582179" author="dyret" created="Wed, 26 Mar 2008 08:46:50 +0000"  >&lt;p&gt;Pushing out to 10.5&lt;/p&gt;</comment>
                            <comment id="12583124" author="dagw" created="Fri, 28 Mar 2008 18:13:37 +0000"  >&lt;p&gt;Uploaded &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full-d, which replaces *-c.&lt;/p&gt;

&lt;p&gt;Added a new test case to check that the current schema&lt;br/&gt;
in pushed sql context stack frames is reset to the session&apos;s&lt;br/&gt;
default schema when a routine drops the schema (this reverting&lt;br/&gt;
is what happens to the current schema before this patch also).&lt;br/&gt;
I could not find anything in the standard about this, but it seems&lt;br/&gt;
the right behavior.&lt;/p&gt;

&lt;p&gt;Cleaned up some naming and javadocs. Regression test ran OK.&lt;/p&gt;</comment>
                            <comment id="12583169" author="rhillegas" created="Fri, 28 Mar 2008 19:57:19 +0000"  >&lt;p&gt;Thanks Dag,&lt;/p&gt;

&lt;p&gt;This sounds like reasonable and non-disruptive behavior to me.&lt;/p&gt;</comment>
                            <comment id="12584129" author="dagw" created="Tue, 1 Apr 2008 14:12:01 +0100"  >&lt;p&gt;Uploaded &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full-e which replaces *-d. &lt;/p&gt;

&lt;p&gt;No significant changes, just polishing:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Abstracted out some common code in GenericLanguageConnectionContext (&lt;br/&gt;
new parameterless getCurrentSQLSessionContext).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;More Javadoc improvements.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Regression tests ran OK. Will commit this version soon.&lt;/p&gt;</comment>
                            <comment id="12584589" author="dagw" created="Wed, 2 Apr 2008 15:34:29 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full-e committed as svn 643920.&lt;/p&gt;</comment>
                            <comment id="12584617" author="dagw" created="Wed, 2 Apr 2008 15:59:01 +0100"  >&lt;p&gt;Attaching a release note for the changed behavior of SET SCHEMA.&lt;/p&gt;</comment>
                            <comment id="12600434" author="kristwaa" created="Wed, 28 May 2008 12:02:33 +0100"  >&lt;p&gt;Is it feasible to backport the last fix/commit to the 10.4 branch?&lt;br/&gt;
If not, I will pull out the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3690&quot; title=&quot;EmbedPooledConnection doesn&amp;#39;t reset schema when creating a new logical connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3690&quot;&gt;&lt;del&gt;DERBY-3690&lt;/del&gt;&lt;/a&gt; from 10.4 as it depends on this one.&lt;/p&gt;

&lt;p&gt;I ran regression tests on 10.4 with the patch &apos;derby-3327-4-full-e.diff&apos; applied, and the only errors I got was in SQLSessionContextTest because roles are disabled. The errors happened during setup, so I do now know yet if the tests pass if we enable roles again (for testing only).&lt;/p&gt;</comment>
                            <comment id="12600618" author="dagw" created="Wed, 28 May 2008 22:52:25 +0100"  >&lt;p&gt;Uploading a 10.4 version of this patch, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full-e-10_4. The only difference&lt;br/&gt;
from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-4-full-e, is that the test is changed by commenting out the role test cases, since&lt;br/&gt;
roles is not a feature of 10.4. I verified that SQLSessionContextTest ran OK with the change on the&lt;br/&gt;
head of 10.4.&lt;/p&gt;

&lt;p&gt;To your question, Kristian, I don&apos;t think there is a problem applying this to 10.4.&lt;/p&gt;</comment>
                            <comment id="12600951" author="dagw" created="Thu, 29 May 2008 23:50:00 +0100"  >&lt;p&gt;I ran the regression tests on 10.4 with the modified patch. The only errors I saw were related to MBeans, cf&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/MBeans-errors-on-10.4-head-td17526725.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/MBeans-errors-on-10.4-head-td17526725.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Kristian, do you know exactly what changed behavior makes &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3690&quot; title=&quot;EmbedPooledConnection doesn&amp;#39;t reset schema when creating a new logical connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3690&quot;&gt;&lt;del&gt;DERBY-3690&lt;/del&gt;&lt;/a&gt; work? (The patch is supposed to change&lt;br/&gt;
the existing Derby behavior only if one changes the current schema inside stored routines cf attached releaseNote.html)&lt;br/&gt;
I would feel more comfortable committing it to the 10.4 branch if we knew...&lt;/p&gt;</comment>
                            <comment id="12601152" author="kristwaa" created="Fri, 30 May 2008 15:33:09 +0100"  >&lt;p&gt;Dag,&lt;/p&gt;

&lt;p&gt;I had a look and extracted the parts of your patch that I needed to run the failing tests successfully (see &apos;derby-3327-5a-extracted_initial_schema_patch.diff&apos;).&lt;br/&gt;
Seems to me the changed behavior is whether the data dictionary is queried or not when setting / returning the default schema.&lt;/p&gt;

&lt;p&gt;I haven&apos;t verified the patch excerpt, but I&apos;m running the regression tests now.&lt;/p&gt;</comment>
                            <comment id="12601605" author="dagw" created="Mon, 2 Jun 2008 12:56:09 +0100"  >&lt;p&gt;The extracted patch looks good to me for the 10.4 branch.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="12601607" author="kristwaa" created="Mon, 2 Jun 2008 12:59:26 +0100"  >&lt;p&gt;Regression tests on 10.4 ran without any failures:&lt;br/&gt;
  jars/sane/derby.jar] 10.4.1.4 - (661686M)&lt;br/&gt;
  suites.All: OK (10405 tests)&lt;br/&gt;
  derbyall: 100% Pass (274 tests passed)&lt;/p&gt;

&lt;p&gt;I&apos;m considering committing the 5a patch to the 10.4 branch to resolve &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3692&quot; title=&quot;&amp;#39;javax.transaction.xa.XAException&amp;#39; ++  in  &amp;#39;J2EEDataSourceTest&amp;#39; &quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3692&quot;&gt;&lt;del&gt;DERBY-3692&lt;/del&gt;&lt;/a&gt;. The other option is to pull out &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3690&quot; title=&quot;EmbedPooledConnection doesn&amp;#39;t reset schema when creating a new logical connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3690&quot;&gt;&lt;del&gt;DERBY-3690&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
The code in patch 5a is extracted from 4e_full, and the only thing changed is the handling of the initial schema descriptor.&lt;/p&gt;</comment>
                            <comment id="12601617" author="kristwaa" created="Mon, 2 Jun 2008 13:48:33 +0100"  >&lt;p&gt;Committed &apos;derby-3327-5a-extracted_initial_schema_patch.diff&apos; to 10.4 with revision 662416.&lt;br/&gt;
It is my understanding that nothing else of this issue will be backported to 10.4.&lt;/p&gt;

&lt;p&gt;Thanks for the feedback Dag!&lt;/p&gt;</comment>
                            <comment id="12602101" author="dagw" created="Tue, 3 Jun 2008 23:53:54 +0100"  >&lt;p&gt;Uploading &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-6, which removes a sanity check from&lt;br/&gt;
GenericLanguageConnectionContext.&lt;/p&gt;

&lt;p&gt;In GenericLanguageConnectionContext#getInitialDefaultSchemaDescriptor there was&lt;br/&gt;
a sanity check that the initial default schema value is always computed before&lt;br/&gt;
it is ever used by getDefaultSchema; that proved to not be the case in one code&lt;br/&gt;
path, cf. indicative check for null in DataDictionaryImpl#getSchemaDescriptor&lt;br/&gt;
near the end of that method.&lt;/p&gt;

&lt;p&gt;When chasing the recursion in the printing of the lock table for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3678&quot; title=&quot;StackOverflowException in deadlock trace&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3678&quot;&gt;&lt;del&gt;DERBY-3678&lt;/del&gt;&lt;/a&gt; I&lt;br/&gt;
noticed that the assert error was triggered, which removed the recursion at the&lt;br/&gt;
expense of the lock table being incompetely filled in as below (notice default&lt;br/&gt;
values, e.g. for CONTAINER_ID column);&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;STATE&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;TABLETYPE / LOCKOBJ &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;INDEXNAME / CONTAINER_ID / (MODE for LATCH only)  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;TABLENAME / CONGLOM_ID &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;The following row is the victim ***&lt;br/&gt;
151       |ROW          |S   |0        |(1,18) |WAIT |org.apache.derby.impl.services.locks.A|CONTAINERID |CONGLOMID |&lt;br/&gt;
:&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(The assert error was silently swallowed in TimeOut#buildLockTableString, see&lt;br/&gt;
 the comment &quot;//just don&apos;t do anything&quot;.&lt;/p&gt;


&lt;p&gt;If this is a valid code path or not I have yet to determine, but I remove the&lt;br/&gt;
sanity check for now; so the sane build will not work better than the insane.&lt;/p&gt;

&lt;p&gt;Regressions ran OK, modulo wisconsin, which i believe to be unrelated.&lt;/p&gt;</comment>
                            <comment id="12602103" author="dagw" created="Tue, 3 Jun 2008 23:57:31 +0100"  >&lt;p&gt;Committed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3327&quot; title=&quot;SQL roles: Implement authorization stack (and SQL session context to hold it)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3327&quot;&gt;&lt;del&gt;DERBY-3327&lt;/del&gt;&lt;/a&gt;-6 as svn 662911.&lt;/p&gt;</comment>
                            <comment id="12912300" author="dagw" created="Mon, 20 Sep 2010 00:32:48 +0100"  >&lt;p&gt;A bug in this machinery was uncovered and fixed as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4551&quot; title=&quot;Allow database user to execute stored procedures with same permissions as database owner and/or routine definer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4551&quot;&gt;&lt;del&gt;DERBY-4551&lt;/del&gt;&lt;/a&gt;, cf linked issue.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12359718">DERBY-2207</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12343199">DERBY-1331</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12405638">DERBY-3897</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12456504">DERBY-4551</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12396702">DERBY-3690</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12373581" name="DERBY-3327-1.diff" size="28340" author="dagw" created="Sat, 19 Jan 2008 00:07:55 +0000"/>
                            <attachment id="12373584" name="DERBY-3327-1.stat" size="775" author="dagw" created="Sat, 19 Jan 2008 00:24:53 +0000"/>
                            <attachment id="12373578" name="DERBY-3327-2.diff" size="28348" author="dagw" created="Sat, 19 Jan 2008 00:00:44 +0000"/>
                            <attachment id="12373583" name="DERBY-3327-2.stat" size="775" author="dagw" created="Sat, 19 Jan 2008 00:24:09 +0000"/>
                            <attachment id="12373685" name="DERBY-3327-3.diff" size="27787" author="dagw" created="Mon, 21 Jan 2008 16:05:44 +0000"/>
                            <attachment id="12373686" name="DERBY-3327-3.stat" size="775" author="dagw" created="Mon, 21 Jan 2008 16:05:44 +0000"/>
                            <attachment id="12375873" name="DERBY-3327-4-full-b.diff" size="86742" author="dagw" created="Tue, 19 Feb 2008 00:30:58 +0000"/>
                            <attachment id="12375874" name="DERBY-3327-4-full-b.stat" size="1649" author="dagw" created="Tue, 19 Feb 2008 00:30:58 +0000"/>
                            <attachment id="12375973" name="DERBY-3327-4-full-c.diff" size="86538" author="dagw" created="Tue, 19 Feb 2008 23:12:15 +0000"/>
                            <attachment id="12375974" name="DERBY-3327-4-full-c.stat" size="1643" author="dagw" created="Tue, 19 Feb 2008 23:12:16 +0000"/>
                            <attachment id="12378804" name="DERBY-3327-4-full-d.diff" size="88474" author="dagw" created="Fri, 28 Mar 2008 18:13:37 +0000"/>
                            <attachment id="12378805" name="DERBY-3327-4-full-d.stat" size="1643" author="dagw" created="Fri, 28 Mar 2008 18:13:37 +0000"/>
                            <attachment id="12382972" name="DERBY-3327-4-full-e-10_4.diff" size="88437" author="dagw" created="Wed, 28 May 2008 22:52:25 +0100"/>
                            <attachment id="12382973" name="DERBY-3327-4-full-e-10_4.stat" size="1643" author="dagw" created="Wed, 28 May 2008 22:52:25 +0100"/>
                            <attachment id="12379026" name="DERBY-3327-4-full-e.diff" size="87933" author="dagw" created="Tue, 1 Apr 2008 14:12:01 +0100"/>
                            <attachment id="12379027" name="DERBY-3327-4-full-e.stat" size="1643" author="dagw" created="Tue, 1 Apr 2008 14:12:01 +0100"/>
                            <attachment id="12375850" name="DERBY-3327-4-full.diff" size="87411" author="dagw" created="Mon, 18 Feb 2008 17:41:56 +0000"/>
                            <attachment id="12375851" name="DERBY-3327-4-full.stat" size="1649" author="dagw" created="Mon, 18 Feb 2008 17:41:56 +0000"/>
                            <attachment id="12383334" name="DERBY-3327-6.diff" size="733" author="dagw" created="Tue, 3 Jun 2008 23:53:54 +0100"/>
                            <attachment id="12383335" name="DERBY-3327-6.stat" size="88" author="dagw" created="Tue, 3 Jun 2008 23:53:54 +0100"/>
                            <attachment id="12383113" name="derby-3327-5a-extracted_initial_schema_patch.diff" size="3363" author="kristwaa" created="Fri, 30 May 2008 15:33:09 +0100"/>
                            <attachment id="12379142" name="releaseNote.html" size="3422" author="dagw" created="Wed, 2 Apr 2008 15:59:01 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10361"><![CDATA[Security]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 18 Jan 2008 21:36:25 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30809</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0pan:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37916</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>