<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:51:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-6554/DERBY-6554.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-6554] Too much contention followed by assert failure when accessing sequence in transaction that created it</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6554</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ij version 10.11
ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos; as c1;
ij&amp;gt; autocommit off;
ij&amp;gt; create sequence seq;
0 rows inserted/updated/deleted
ij&amp;gt; values next value for seq;
1          
-----------
ERROR X0Y84: Too much contention on sequence SEQ. This is probably caused by an uncommitted scan of the SYS.SYSSEQUENCES catalog. Do not query this catalog directly. Instead, use the SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE function to view the current value of a query generator.
ij&amp;gt; rollback;
ERROR 08003: No current connection.
ij&amp;gt; connect &apos;jdbc:derby:memory:db&apos; as c2;
ij(C2)&amp;gt; autocommit off;
ij(C2)&amp;gt; create sequence seq;
0 rows inserted/updated/deleted
ij(C2)&amp;gt; values next value for seq;
1          
-----------
ERROR 38000: The exception &apos;org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED Identity being changed on a live cacheable. Old uuidString = 0ddd00a9-0145-98ba-79df-000007d88b08&apos; was thrown while evaluating an expression.
ERROR XJ001: Java exception: &apos;ASSERT FAILED Identity being changed on a live cacheable. Old uuidString = 0ddd00a9-0145-98ba-79df-000007d88b08: org.apache.derby.shared.common.sanity.AssertFailure&apos;.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="12710537">DERBY-6554</key>
            <summary>Too much contention followed by assert failure when accessing sequence in transaction that created it</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                            <label>derby_backport_reject_10_10</label>
                    </labels>
                <created>Fri, 25 Apr 2014 12:53:41 +0100</created>
                <updated>Thu, 25 Sep 2014 21:54:06 +0100</updated>
                            <resolved>Mon, 19 May 2014 18:32:05 +0100</resolved>
                                    <version>10.9.1.0</version>
                    <version>10.10.2.0</version>
                    <version>10.11.1.1</version>
                                    <fixVersion>10.11.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13980956" author="rhillegas" created="Fri, 25 Apr 2014 13:46:55 +0100"  >&lt;p&gt;Thanks for logging this one. I&apos;ve seen that assert a couple times and never known how to trip it. This code path may be a red herring. But it may help us bag a bug on the main code path.&lt;/p&gt;</comment>
                            <comment id="13981052" author="knutanders" created="Fri, 25 Apr 2014 15:21:20 +0100"  >&lt;p&gt;I&apos;m actually seeing this with 10.10.2.0 too. But it is only seen with the debug version, since it&apos;s an assert failure.&lt;/p&gt;</comment>
                            <comment id="13981053" author="knutanders" created="Fri, 25 Apr 2014 15:23:47 +0100"  >&lt;p&gt;It reproduces with the debug version of 10.9.1.0 too.&lt;/p&gt;</comment>
                            <comment id="13981135" author="knutanders" created="Fri, 25 Apr 2014 16:24:47 +0100"  >&lt;p&gt;When I said it only reproduced with the debug version, that&apos;s not quite correct. The assert failure only reproduces with the debug version. The &quot;too much contention&quot; error happens with the non-debug version too. I don&apos;t think it&apos;s reasonable to see that error in this scenario, so I think that&apos;s a bug too.&lt;/p&gt;</comment>
                            <comment id="13983099" author="rhillegas" created="Mon, 28 Apr 2014 16:24:57 +0100"  >&lt;p&gt;This regression actually kills the connection, perhaps because of an assert failure:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ij version 10.11
ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos;;
ij&amp;gt; autocommit off;
ij&amp;gt; create sequence seq;
0 rows inserted/updated/deleted
ij&amp;gt; values next value for seq;
1          
-----------
ERROR X0Y84: Too much contention on sequence SEQ. This is probably caused by an uncommitted scan of the SYS.SYSSEQUENCES catalog. Do not query this catalog directly. Instead, use the SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE function to view the current value of a sequence generator.
ij&amp;gt; select count(*) from sys.systables;
ERROR 08003: No current connection.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13983364" author="rhillegas" created="Mon, 28 Apr 2014 19:29:16 +0100"  >&lt;p&gt;This is my analysis of what is going on:&lt;/p&gt;

&lt;p&gt;1) The CREATE SEQUENCE statement puts a row into SYS.SYSSEQUENCES and slaps an exclusive lock on it using the connection&apos;s execution transaction controller.&lt;/p&gt;

&lt;p&gt;2) The subsequent NEXT VALUE FOR statement is the first attempt to use the sequence generator. In trying to allocate the first range of values, it has to update that row in SYS.SYSSEQUENCES. It tries to do this in a nested subtransaction of the connection&apos;s execution transaction controller. But it can&apos;t get a lock on the row. It is blocked by the parent transaction.&lt;/p&gt;

&lt;p&gt;3) A &quot;too much contention&quot; exception is raised. That is a transaction severity error. While cleaning up the transaction, the DataDictionary trips over an assertion failure which makes the connection unusable:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;New exception raised during cleanup ASSERT FAILED Number of DDL Users is &amp;lt;= 0 when finishing a transaction
org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED Number of DDL Users is &amp;lt;= 0 when finishing a transaction
	at org.apache.derby.shared.common.sanity.SanityManager.ASSERT(SanityManager.java:120)
	at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.transactionFinished(DataDictionaryImpl.java:1325)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the script output showing the lock table just before the NEXT VALUE FOR statement. I also instrumented SequenceUpdater to print out the transaction id of the execution transaction. As you can see, it is the same transaction which holds the lock on the row in SYS.SYSSEQUENCES.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ij version 10.11
ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos;;
ij&amp;gt; autocommit off;
ij&amp;gt; create sequence seq;
0 rows inserted/updated/deleted
ij&amp;gt; select * from syscs_diag.lock_table;
XID            |TYPE |MODE|TABLENAME                                                                                                                       |LOCKNAME            |STATE|TABLETYPE|LOCK&amp;amp;|INDEXNAME                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
167            |ROW  |S   |SYSSCHEMAS                                                                                                                      |(1,17)              |GRANT|S        |2    |NULL                                                                                                                            
167            |TABLE|IS  |SYSSEQUENCES                                                                                                                    |Tablelock           |GRANT|S        |2    |NULL                                                                                                                            
167            |TABLE|IX  |SYSSEQUENCES                                                                                                                    |Tablelock           |GRANT|S        |3    |NULL                                                                                                                            
167            |TABLE|IS  |SYSCONGLOMERATES                                                                                                                |Tablelock           |GRANT|S        |2    |NULL                                                                                                                            
167            |TABLE|IS  |SYSSCHEMAS                                                                                                                      |Tablelock           |GRANT|S        |2    |NULL                                                                                                                            
167            |TABLE|IS  |SYSTABLES                                                                                                                       |Tablelock           |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,21)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |X   |SYSSEQUENCES                                                                                                                    |(1,7)               |GRANT|S        |3    |NULL                                                                                                                            
167            |TABLE|IS  |SYSCOLUMNS                                                                                                                      |Tablelock           |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,30)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,25)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCONGLOMERATES                                                                                                                |(6,10)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,24)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCONGLOMERATES                                                                                                                |(6,9)               |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,23)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCONGLOMERATES                                                                                                                |(6,8)               |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,22)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,29)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSTABLES                                                                                                                       |(1,27)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,28)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,27)              |GRANT|S        |2    |NULL                                                                                                                            
167            |ROW  |S   |SYSCOLUMNS                                                                                                                      |(4,26)              |GRANT|S        |2    |NULL                                                                                                                            

22 rows selected
ij&amp;gt; values next value for seq;
1          
-----------
XXX SequenceUpdater transaction id = 167
XXX SequenceUpdater transaction id = 167
ERROR X0Y84: Too much contention on sequence SEQ. This is probably caused by an uncommitted scan of the SYS.SYSSEQUENCES catalog. Do not query this catalog directly. Instead, use the SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE function to view the current value of a sequence generator.
ij&amp;gt; select count(*) from sys.systables;
ERROR 08003: No current connection.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;m unclear on the behavior of Derby nested subtransactions and I have a question about step 2). Is it expected that the subtransaction should be blocked by its parent transaction?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13983423" author="dagw" created="Mon, 28 Apr 2014 20:14:32 +0100"  >&lt;p&gt;I think we have seen that before, yes. I seem to remember we have code that, when failing to lock a resource in the sub-transaction, falls back to trying to use the parent transaction instead, in case it is a self-lock scenario (like the one you are seeing). But should one wait for lock time-out in this case before doing the fall-back? Probably not..&lt;br/&gt;
I think Knut has done some work with this mechanism..&lt;br/&gt;
See also &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3693&quot; title=&quot;Deadlocks accessing DB metadata&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3693&quot;&gt;&lt;del&gt;DERBY-3693&lt;/del&gt;&lt;/a&gt;, and the method RAMTRansaction#setNoLockWait and its usage.&lt;/p&gt;</comment>
                            <comment id="13983481" author="rhillegas" created="Mon, 28 Apr 2014 21:09:27 +0100"  >&lt;p&gt;OK. But we want to NEVER escalate into the parent transaction because those are the long-running locks which kill concurrency. We may need to build some complexity to handle the edge case of using a sequence generator in the transaction which created it. The discussion on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5493&quot; title=&quot;Same value returned by successive calls to a sequence generator.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5493&quot;&gt;&lt;del&gt;DERBY-5493&lt;/del&gt;&lt;/a&gt; suggests that we once thought that this limitation was fine. I&apos;ll give this some thought. Thanks.&lt;/p&gt;</comment>
                            <comment id="13983563" author="knutanders" created="Mon, 28 Apr 2014 22:19:51 +0100"  >&lt;p&gt;Could we perhaps try to lock it in the parent transaction no-wait before we give up with too much contention? Then we would use the parent transaction if the parent transaction already holds locks that would block others from using the sequence anyway, but not wait if there&apos;s some other transaction that&apos;s locking the sequence.&lt;/p&gt;

&lt;p&gt;Such a solution would open a small window for unwanted lock escalations, though. If another transaction holds a lock that prevents the subtransaction from doing its work, and releases the lock before it is retried in the main transaction, it would end up being locked in the main transaction even though it wasn&apos;t the main transaction that held the lock in the first place.&lt;/p&gt;</comment>
                            <comment id="13983600" author="dagw" created="Mon, 28 Apr 2014 22:36:41 +0100"  >&lt;p&gt;Why isn&apos;t the sub-transaction exclusive lock compatible with that of the parent transaction? I.e. why can&apos;t it be granted?&lt;/p&gt;</comment>
                            <comment id="13983833" author="rhillegas" created="Tue, 29 Apr 2014 02:06:57 +0100"  >&lt;p&gt;I&apos;m going to try the following approach unless people think that this won&apos;t work. The idea is to add a special code path for the situation when we are trying to use the sequence generator in the transaction which created it:&lt;/p&gt;

&lt;p&gt;1) When the CreateSequenceConstantAction creates a sequence, it will mark the associated SequenceUpdater with its execution TransactionController&apos;s transaction id (what comes back from getTransactionIdString()) plus an as yet not implemented commit/rollback counter obtained from the TransactionController. If someone can think of a better identifier for the execution transaction, I&apos;m happy to use that.&lt;/p&gt;

&lt;p&gt;2) When trying to update the sequence number on disk, the SequenceUpdater will check to see whether the current execution transaction is the one it was marked with. If so, we will use the execution transaction rather than a nested subtransaction to do the work.&lt;/p&gt;

&lt;p&gt;3) When TransactionController.commit() or abort() is called, we will bump the commit/rollback counter.&lt;/p&gt;

&lt;p&gt;There may be an edge-case on an edge-case to consider: creating and using a sequence inside the nested transaction context of a stored procedure.&lt;/p&gt;

&lt;p&gt;Your feedback is welcome.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13984099" author="knutanders" created="Tue, 29 Apr 2014 08:41:52 +0100"  >&lt;p&gt;Sounds like a promising approach that would only use the main transaction in cases where we know we already have exclusive access to the sequence.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why isn&apos;t the sub-transaction exclusive lock compatible with that of the parent transaction? I.e. why can&apos;t it be granted?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The lock manager doesn&apos;t currently check the relationship between the owing transactions when determining if two locks are compatible. It would be helpful if it did.&lt;/p&gt;</comment>
                            <comment id="13984311" author="rhillegas" created="Tue, 29 Apr 2014 14:59:50 +0100"  >&lt;p&gt;Attaching derby-6554-01-aa-useCreationTransaction.diff. I am running tests now.&lt;/p&gt;

&lt;p&gt;This implements the approach proposed above. It turns out that the transaction id returned by TransactionController.getTransactionIdString() is good enough and no additional counter is need.&lt;/p&gt;

&lt;p&gt;I also added a test case for the situation of a CREATE SEQUENCE statement inside a database procedure.&lt;/p&gt;


&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;--------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java&lt;/p&gt;

&lt;p&gt;Special code path when the execution transaction is the one which created the sequence.&lt;/p&gt;

&lt;p&gt;--------------&lt;/p&gt;

&lt;p&gt;M       java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;/p&gt;

&lt;p&gt;New method for stuffing the transaction id into the SequenceUpdater at CREATE SEQUENCE time.&lt;/p&gt;

&lt;p&gt;--------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/execute/CreateSequenceConstantAction.java&lt;/p&gt;

&lt;p&gt;Stuff the transaction id in the SequenceUpdater right after creating the sequence.&lt;/p&gt;

&lt;p&gt;--------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceTest.java&lt;/p&gt;

&lt;p&gt;Tests.&lt;/p&gt;</comment>
                            <comment id="13984378" author="knutanders" created="Tue, 29 Apr 2014 16:12:47 +0100"  >&lt;p&gt;Thanks, Rick. The patch made the repro pass. I also tested it together with the 02-ab patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6542&quot; title=&quot;Improve the concurrency of identity columns by using SYS.SYSSEQUENCES&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6542&quot;&gt;&lt;del&gt;DERBY-6542&lt;/del&gt;&lt;/a&gt; and verified that it fixed the corresponding problem for identity columns based on sequences.&lt;/p&gt;

&lt;p&gt;The problem seems to persist, though, if I increase the number of sequences (because sequence updaters get evicted from the cache and lose information about the creating transaction, perhaps?). See the attached D6554.java class, which produces the following output:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;java.sql.SQLException: Too much contention on sequence S25. This is probably caused by an uncommitted scan of the SYS.SYSSEQUENCES catalog. Do not query this catalog directly. Instead, use the SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE function to view the current value of a sequence generator.
java.sql.SQLException: Java exception: &apos;ASSERT FAILED base row not found: org.apache.derby.shared.common.sanity.AssertFailure&apos;.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13984576" author="rhillegas" created="Tue, 29 Apr 2014 18:49:59 +0100"  >&lt;p&gt;Attaching a new rev of the patch, derby-6554-01-ab-useCreationTransaction.diff. This fixes a howler in the previous version. This version also adjusts SequenceGeneratorTest to account for the fact that the SequenceUpdater is now instantiated when the sequence is created.&lt;/p&gt;

&lt;p&gt;I will give some thought to the new test case which Knut scripted.&lt;/p&gt;

&lt;p&gt;Touches the following additional file:&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceGeneratorTest.java&lt;/p&gt;</comment>
                            <comment id="13985721" author="mikem" created="Wed, 30 Apr 2014 17:45:37 +0100"  >&lt;p&gt;&amp;gt; Why isn&apos;t the sub-transaction exclusive lock compatible with that of the parent transaction? I.e. why can&apos;t it be granted?&lt;br/&gt;
The Derby recovery algorithms do not currently support compatible locking of parent transaction and child read/write transactions.  &lt;br/&gt;
I believe there are a number of problems and those problems are avoided by making sure the read/write sub transaction does not&lt;br/&gt;
change the same row that may have been changed by the parent transaction.  This was acceptable when the first specific use of&lt;br/&gt;
the read/write transaction was created, but we have added more use cases since then.&lt;/p&gt;

&lt;p&gt;Here is an example off the top of my head that would cause problems in the system if a read/write sub transaction locking was compatible&lt;br/&gt;
with parent.  The issue is that the subtransaction can commit separate from the parent and subsequently the parent xact may abort.&lt;/p&gt;

&lt;p&gt;1) parent transaction gets X lock on row A and changes it.&lt;br/&gt;
2) (if it were allowed) read/write substransaction gets lock on row A and changes it in an arbitrary different way.&lt;br/&gt;
3) subtransaction commits changes and releases locks&lt;br/&gt;
4) parent transaction aborts, and expects changes to row A to be backed out.  I believe this will crash the system currently if the&lt;br/&gt;
    above scenario was played through as it would try to apply undo log records in reverse, but would only look at log records associated&lt;br/&gt;
    with the parent transaction but will see a page version from the other transaction and not know what to do.&lt;/p&gt;

&lt;p&gt;note that read only substransactions do have compatible locking with parent as they present no recovery issues.  This is what the compiler&lt;br/&gt;
uses to get consistent plans but not conflict with user locking.&lt;/p&gt;</comment>
                            <comment id="13985725" author="mikem" created="Wed, 30 Apr 2014 17:48:28 +0100"  >&lt;p&gt;It might be interesting to think about if we could special case something about concurrency and recovery for something so special as&lt;br/&gt;
sequence values.  Currently all the sub transaction stuff and locking is very general purpose and fits sql standards.  But locking and recovery&lt;br/&gt;
of an internal column/row for sequences likely can break some of these rules. &lt;/p&gt;

&lt;p&gt;Just needed to make sure that someone interested in this knows that there is more to do than just allowing the lock to be granted.&lt;/p&gt;</comment>
                            <comment id="13985941" author="rhillegas" created="Wed, 30 Apr 2014 20:14:07 +0100"  >&lt;p&gt;Thanks, Mike. We may need to ask for your help in pushing this problem into the Store if people think that the following solution is too complex.&lt;/p&gt;

&lt;p&gt;Attaching derby-6554-01-ac-useCreationTransaction.diff. This patch attempts to address the D6554 problem case. This patch also addresses some other problems discovered while investigating D6554. I am running tests now.&lt;/p&gt;

&lt;p&gt;The solution, including the fix for D6554, now is:&lt;/p&gt;

&lt;p&gt;1) Remember the transaction id which created the sequence. This is saved in the SequenceUpdater which corresponds to the new sequence.&lt;/p&gt;

&lt;p&gt;2) A map of (sequenceID, creatingTransactionID) pairs is maintained so that we can restore the SequenceUpdater&apos;s creatingTransactionID after cache eviction. The map is not persistent. Rebooting the database clears it out.&lt;/p&gt;

&lt;p&gt;3) A good faith effort is made to garbage collect a (sequenceID, creatingTransactionID) pair and keep the map from growing indefinitely. However, there are cases when we won&apos;t know that it&apos;s ok to garbage collect a pair. I considered putting a hard limit on the size of the map. But I think that is brittle, particularly since I can&apos;t guarantee that the pair will eventually be garbage collected. This means that there is a resource-leak/denial-of-service defect with this solution. I think it is unlikely that any well behaved application will see this problem. And it is not clear to me that this is really a new vulnerability: in setting up such a situation, it is possible that you will hit some other resource limit first. But if people think this is a serious defect, then we will have to consider something fancier or abandon this approach.&lt;/p&gt;

&lt;p&gt;In developing this fix for D6554, I tripped across a bug in cache eviction: If there was an uncommitted CREATE SEQUENCE holding a lock on a SYS.SYSSEQUENCES row at cache eviction time, and the cache evicting transaction was not the transaction which created the sequence, then the Cacheable.clean() method would raise an exception when trying to flush the unused sequence values to disk. This, in turn, would short-circuit the clearing of the Cacheable identity. And that would raise an assertion when the Cacheable was re-used: &quot;Identity being changed on a live cacheable&quot;. To fix this, I have moved the identity-resetting logic into a finally block.&lt;/p&gt;

&lt;p&gt;Developing the fix for D6554 also concentrated my attention on this behavior of sequence generators: If a sequence generator is evicted from the cache and the evicting transaction can&apos;t write to SYS.SYSSEQUENCES, then gaps in the sequence will appear. I&apos;m aware of only two situations which give rise to this problem:&lt;/p&gt;

&lt;p&gt;1) An uncommitted CREATE SEQUENCE statement.&lt;/p&gt;

&lt;p&gt;2) Users who ignore our advice and scan SYS.SYSSEQUENCES.&lt;/p&gt;

&lt;p&gt;Finally, in order to reduce the likelihood that we will trip across cache eviction problems, I have increased the size of the sequence generator cache to 1000. Applications will need to adjust derby.language.sequenceGeneratorCacheSize if they need to create and use a lot of sequences in a single transaction.&lt;/p&gt;


&lt;p&gt;Touches the following additional file:&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/reference/Property.java&lt;/p&gt;</comment>
                            <comment id="13986086" author="rhillegas" created="Wed, 30 Apr 2014 22:09:49 +0100"  >&lt;p&gt;Tests passed cleanly for me on derby-6554-01-ac-useCreationTransaction.diff except for the failure in OnlineCompressTest tracked by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6502&quot; title=&quot;Failure in OnlineCompressTest&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6502&quot;&gt;&lt;del&gt;DERBY-6502&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13986113" author="mikem" created="Wed, 30 Apr 2014 22:28:42 +0100"  >&lt;p&gt;i have not followed the most recent discussion on this, just happened to notice the lock question.  I&apos;ll think&lt;br/&gt;
more but here are initial thoughts based on your description in the latest posting.  &lt;/p&gt;

&lt;p&gt;I think we had long discussions about this when you were first doing sequences and that is what led to &lt;br/&gt;
the too much contention error in the sequence implementation.  The proposed solution seems overly complex to me.  A lot&lt;br/&gt;
of mechanism to solve what should just be a locking issue with ddl in transaction.  I would lean toward what&lt;br/&gt;
knut suggests and just catch the error and retry in main transaction, to handle the creating transaction case.&lt;br/&gt;
And maybe tune how long you wait for lock in sub transaction to get fewer false escalations.&lt;/p&gt;

&lt;p&gt;I think the right next project to fix the issue with incorrectly escalating to parent is to fix the lock manager to throw deadlock&lt;br/&gt;
rather than lock wait when it can&apos;t get a lock because parent transaction holds it.  Not sure how hard that &lt;br/&gt;
project would be, but if necessary we could even special case the lock and lock path to make it easier if no one&lt;br/&gt;
was up to a general change to the lock manager.&lt;/p&gt;

&lt;p&gt;For sequences do you have some feel for the need to create and use sequences in the same transaction.  For&lt;br/&gt;
identity I have always been comfortable telling people to create the table and then use it in a different transaction&lt;br/&gt;
if they see poor performance/contention with in transaction work.  Basically is it reasonable to require a commit&lt;br/&gt;
after create sequence to get best performance.&lt;/p&gt;</comment>
                            <comment id="13986153" author="mikem" created="Wed, 30 Apr 2014 23:08:09 +0100"  >&lt;p&gt;Rick I have copied below from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5443&quot; title=&quot;reduce number of times sequence updater does it work on user thread rather than nested user thread.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5443&quot;&gt;&lt;del&gt;DERBY-5443&lt;/del&gt;&lt;/a&gt;, I think we are back to discussing the same problem that was marked fixed.  Could you update this description if necessary to reflect what sequencers do in trunk now, I have lost track.&lt;br/&gt;
I like option 1 the best but not sure if anyone with skills in the lock manager would be interested, I don&apos; like option 2 anymore and think option 3 may be the easiest solution, but need to understand what current implementation of sequencers do now.  &lt;/p&gt;

&lt;p&gt;Description of problem from around 03/Oct/11 14:47 in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5443&quot; title=&quot;reduce number of times sequence updater does it work on user thread rather than nested user thread.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5443&quot;&gt;&lt;del&gt;DERBY-5443&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;Currently the Sequence updater tries to do the system catalog update as part of the user thread, but in a nested user transaction. When this works&lt;br/&gt;
all is well as the nested user transaction is immediately committed and thus the throughput of all threads depending on allocating sequences is&lt;br/&gt;
optimized.&lt;/p&gt;

&lt;p&gt;In order to be able to commit the nested writable transaction independently the lock manager must treat the parent and nested transactions as two&lt;br/&gt;
independent transactions and locks held by the parent will thus block the child. And in effect any lock that is blocked by the parent is a deadlock,&lt;br/&gt;
but the lock manager does not understand this relationship and thus only will timeout and not recognize the implicit deadlock.&lt;/p&gt;

&lt;p&gt;Only 2 cases come to mind of the parent blocking the child in this manner for sequences:&lt;br/&gt;
1) ddl like create done in transaction followed by inserts into the table requiring sequence update.&lt;br/&gt;
2) users doing jdbc data dictionary lookups in a multistatment transaction resulting in holding locks on the system catalog rows and subsequently&lt;br/&gt;
doing inserts into the table requiring sequence updates.&lt;/p&gt;

&lt;p&gt;The sequence updater currently never waits for a lock in the nested transaction and assumes any blocked lock is this parent deadlock case. It&lt;br/&gt;
then falls back on doing the update in tranaction and then the system catalog lock remains until the user transaction commits which could then&lt;br/&gt;
hold hostage all other inserts into the table. This is ok in the above 2 cases as there is not any other choice since the user transaction is already&lt;br/&gt;
holding the system hostage.&lt;/p&gt;

&lt;p&gt;The problem is the case where it was not a deadlock but just another thread trying to do the sequence update. In this case the thread should&lt;br/&gt;
not be getting locks on the user thread.&lt;/p&gt;

&lt;p&gt;I am not sure best way to address this project but here are some ideas:&lt;br/&gt;
1) enhance lock manager to recognize the deadlock and then change to code to somehow do an immediately deadlock check for internal&lt;br/&gt;
nested transactions, no matter what the system default is. Then the code should go ahead and use the system wait timeout on this lock&lt;br/&gt;
and only fall over to using user transaction for deadlock (or maybe even throw a new &quot;self deadlock&quot; error that would only be possible for&lt;br/&gt;
internal transactions).&lt;/p&gt;

&lt;p&gt;2) somehow execute the internal system catalog update as part of a whole different transaction in the system. Would need a separate context.&lt;br/&gt;
Sort of like the background daemon threads. Then no self deadlock is possible and it could just go ahead and wait. The downside is that then&lt;br/&gt;
the code to &quot;wait&quot; for a new sequence becomes more complicated as it has to wait for an event from another thread. But seems like it could&lt;br/&gt;
designed with locks/synchonization blocks somehow.&lt;/p&gt;

&lt;p&gt;3) maybe add another lock synchronization that would only involve threads updating the sequences. So first an updater would request the&lt;br/&gt;
sequence updater lock (with a key specific to the table and a new type) and it could just wait on it. It should never be held by parent&lt;br/&gt;
transaction. Then it would still need the catalog row lock to do the update. I think with proper ordering this would insure that blocking on&lt;br/&gt;
the catalog row lock would only happen in the self deadlock case.&lt;/p&gt;

&lt;p&gt;Overall this problem is less important as the size of the chunk of sequence is tuned properly for the application, and ultimately best if derby&lt;br/&gt;
autotuned the chunk. &lt;/p&gt;</comment>
                            <comment id="13986571" author="rhillegas" created="Thu, 1 May 2014 14:36:08 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;Here are some responses to your previous two comments. I hope I am addressing your questions. Ask me again if I have inadvertently missed something.&lt;/p&gt;

&lt;p&gt;----------------------&lt;/p&gt;

&lt;p&gt;How likely/real is it that someone will use a sequence generator in the transaction which created it?&lt;/p&gt;

&lt;p&gt;Very unlikely. That is why this bug was discovered in the laboratory and not discovered in production. I think that most applications do their DDL first as part of application-installation. However, I suppose you could imagine an application which scales itself by cloning its schema on the fly. The cloning transaction might have to exercise the sequence generator during initialization. New connections would back up behind the cloning transaction, waiting for it to commit and signal that initialization had completed.&lt;/p&gt;

&lt;p&gt;---------------------------------&lt;/p&gt;

&lt;p&gt;What is SequenceUpdater doing today?&lt;/p&gt;

&lt;p&gt;There are 3 kinds of writes to SYS.SYSSEQUENCES:&lt;/p&gt;

&lt;p&gt;A) The initial row insertion by CREATE SEQUENCE.&lt;/p&gt;

&lt;p&gt;B) Periodic allocations of new ranges of sequence values.&lt;/p&gt;

&lt;p&gt;C) Flushing unused sequence values.&lt;/p&gt;

&lt;p&gt;i) This happens if the cache of sequence generators fills up and an active sequence generator has to be evicted from the cache. That is, merely using another, unrelated sequence generator can cause this to happen.&lt;/p&gt;

&lt;p&gt;ii) This also happens during DDL, which causes the DataDictionary to flush all of its caches.&lt;/p&gt;

&lt;p&gt;iii) This also happens during orderly database shutdown.&lt;/p&gt;

&lt;p&gt;Right now (not including the derby-6554-01-ac-useCreationTransaction.diff patch):&lt;/p&gt;

&lt;p&gt;A always happens in the user&apos;s execution transaction&lt;/p&gt;

&lt;p&gt;B and C only try to write to SYS.SYSSEQUENCES in a nested sub-transaction of the user&apos;s execution transaction. B and C never wait for a lock. Instead, if they can&apos;t get the lock, they timeout immediately and raise a &quot;too much contention&quot; exception.&lt;/p&gt;

&lt;p&gt;---------------------------------&lt;/p&gt;

&lt;p&gt;What if we changed this behavior so that B and C waited for the X lock and/or escalated into the parent transaction?&lt;/p&gt;

&lt;p&gt;This might be ok for B, although throughput might suffer.&lt;/p&gt;

&lt;p&gt;I think this would cause system freeze-ups for C.&lt;/p&gt;

&lt;p&gt;--------------------------------&lt;/p&gt;

&lt;p&gt;What if the LockManager raised a SelfDeadlock exception when a nested sub-transaction requested an X lock held by its parent transaction?&lt;/p&gt;

&lt;p&gt;I think this eliminates the troubling complexity of derby-6554-01-ac-useCreationTransaction.diff. SelfDeadlock would be the only case which caused us to escalate from the nested sub-transaction into the parent transaction. I think that this situation will only occur under the conditions of this bug: exercising a sequence generator in the transaction which created it. If anyone can think of another case which gives rise to this situation, then we&apos;ll need to think some more.&lt;/p&gt;

&lt;p&gt;I&apos;m happy to try my hand at this, provided that the experts are willing to coach me.&lt;/p&gt;

&lt;p&gt;With this extra explanation, does this still seem like the best approach to you?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13986617" author="rhillegas" created="Thu, 1 May 2014 15:12:51 +0100"  >&lt;p&gt;Attaching derby-6554-01-ad-bugfixes.diff.  This is the previous patch after removing the complex solution to this bug. This patch just contains the other bug fixes discovered while investigating this JIRA. I am running tests now.&lt;/p&gt;

&lt;p&gt;This patch does the following:&lt;/p&gt;

&lt;p&gt;1) Fixes a bug in re-use of the SequenceUpdater Cacheable after a&lt;br/&gt;
sequence generator is evicted from the cache.&lt;/p&gt;

&lt;p&gt;2) Removes an assertion which killed the connection while evicting a SequenceUpdater from the cache.&lt;/p&gt;

&lt;p&gt;3) Increases the size of the sequence generator cache to 1000.&lt;/p&gt;


&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/reference/Property.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceTest.java&lt;/p&gt;</comment>
                            <comment id="13986725" author="rhillegas" created="Thu, 1 May 2014 17:20:37 +0100"  >&lt;p&gt;Tests passed cleanly for me on derby-6554-01-ad-bugfixes.diff.&lt;/p&gt;</comment>
                            <comment id="13986736" author="jira-bot" created="Thu, 1 May 2014 17:30:45 +0100"  >&lt;p&gt;Commit 1591703 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rhillegas&quot; class=&quot;user-hover&quot; rel=&quot;rhillegas&quot;&gt;Rick Hillegas&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1591703&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1591703&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6554&quot; title=&quot;Too much contention followed by assert failure when accessing sequence in transaction that created it&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6554&quot;&gt;&lt;del&gt;DERBY-6554&lt;/del&gt;&lt;/a&gt;: Fix some bugs in cache management for sequence generators; commit derby-6554-01-ad-bugfixes.diff.&lt;/p&gt;</comment>
                            <comment id="13986766" author="mikem" created="Thu, 1 May 2014 18:00:24 +0100"  >&lt;p&gt;thanks for the explanation, i think it answers most.  May need more explanation on why &lt;br/&gt;
escalation causes:&lt;br/&gt;
&quot;I think this would cause system freeze-ups for C.&quot;&lt;/p&gt;
</comment>
                            <comment id="13986791" author="mikem" created="Thu, 1 May 2014 18:20:50 +0100"  >&lt;p&gt;I still lean toward some approach that defaults the work to a subtransaction, and then escalates &lt;br/&gt;
the work to the parent transaction based on some condition. &lt;/p&gt;

&lt;p&gt;Discounting the work involved I do believe the lock manager recognizing the self deadlock is the&lt;br/&gt;
best solution, if it could be implemented with negatively impacting the throughput of all locks through&lt;br/&gt;
the system.  A solution that updated the current deadlock algorithm to be executed after system set&lt;br/&gt;
deadlock wait time would be fine.  I am not sure if a solution that checked on every wait would be&lt;br/&gt;
good -but might be if you could do a simple check that only looked at the data of the lock in question&lt;br/&gt;
after it was noticed it had to wait.  I am not sure if the current lock manager data has the necessary child/parent relationships&lt;br/&gt;
necessary.   I have not looked at the lock manager since it was partially rewritten multiple years ago&lt;br/&gt;
so not sure how much I could help with this.&lt;/p&gt;


&lt;p&gt;I think the following will achieve the same result but no lock manager change, I do understand&lt;br/&gt;
how to do the locking part and would be happy to help if you would prefer this approach to the&lt;br/&gt;
lock manager change.  There is a cost of an extra lock request per sequencer update for this&lt;br/&gt;
approach.&lt;br/&gt;
1) change code to wait for the lock and on timeout retry in parent transaction, and if that fails I guess&lt;br/&gt;
     continue to throw too much contention.  Is there an argument to just not allow timeout in this case?&lt;/p&gt;

&lt;p&gt;2) implement the following that would require no lock manager code change:&lt;br/&gt;
    add new lock that will cause sub transaction to wait on other subtransactions but not on &lt;br/&gt;
    parent transactions, and then change subtracation to wait first on the new lock, and then to &lt;br/&gt;
    continue to nowait on the existing sequencer lock, with escalation code from 1 if it can&apos;t get&lt;br/&gt;
    lock.&lt;/p&gt;

&lt;p&gt;If this does not work for C) Flushing unused sequence values. - maybe there is some special case we&lt;br/&gt;
can use for that?&lt;/p&gt;</comment>
                            <comment id="13986795" author="mikem" created="Thu, 1 May 2014 18:29:31 +0100"  >&lt;p&gt;I think it would be a major compatibility issue for inserts into hard upgraded tables with identity columns  &lt;br/&gt;
to see &quot;too much contention&quot; errors on insert in the new release.    Hopefully we can come up with a &lt;br/&gt;
generic solution for both sequences and identity columns based on sequences.&lt;/p&gt;

&lt;p&gt;I assume that identity columns likely fail with timeouts and maybe deadlocks today, and likely much &lt;br/&gt;
less so when changed to use underlying sequences.  If we can&apos;t eliminate new &quot;too much contention&quot; &lt;br/&gt;
error we may want to consider mapping it to a lock timeout for identity columns for backward application&lt;br/&gt;
compatibility.  That way upgraded applications will both see the much improved performance of&lt;br/&gt;
identity columns without having to change properly coded applications that already handled&lt;br/&gt;
lock timeouts and deadlocks.  Not to mention they will possibly see way less of these errors&lt;br/&gt;
in the new release.&lt;/p&gt;</comment>
                            <comment id="13986842" author="rhillegas" created="Thu, 1 May 2014 19:27:50 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;&quot;I think this would cause system freeze-ups for C.&quot; This is what would happen when the cache is cleared, or a cache entry is evicted, or the system shuts down in an orderly way: An attempt is made to stuff the SYSSEQUENCES row with the next sequence number which would be doled out. Suppose that one user scanned SYSSEQUENCES or the lock escalated into his execution transaction. Then someone else tries to use another sequence which evicts the first sequence from the cache. Or someone else tries to do some cache-flushing DDL. Or someone else tries to bring down the database. That subsequent operation will block, perhaps twice, for the lock timeout period and will get an error message referring to the first sequence. Potentially lots of threads will back up behind these operations.&lt;/p&gt;</comment>
                            <comment id="13986844" author="rhillegas" created="Thu, 1 May 2014 19:33:01 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;I think that it would be trivial to raise a &quot;lock timeout&quot; for identity columns in the situations where we are currently raising &quot;too much contention&quot;. Thanks.&lt;/p&gt;</comment>
                            <comment id="13988130" author="rhillegas" created="Fri, 2 May 2014 20:33:47 +0100"  >&lt;p&gt;Attaching derby-6554-02-aa-selfDeadlock.diff. This is a first pass at fixing this bug by adding a new SelfDeadlock condition which is raised by the lock manager.&lt;/p&gt;

&lt;p&gt;The lock manager code has been changed as follows:&lt;/p&gt;

&lt;p&gt;1) Xact now has a field holding the TransactionId of its parent transaction. Usually, this field is null. However, it is non-null if the transaction was created by TransactionController.startNestedUserTransaction().&lt;/p&gt;

&lt;p&gt;2) LockControl uses this new information to determine if a parent transaction has been granted a lock which conflicts with a nested transaction&apos;s lock request.&lt;/p&gt;

&lt;p&gt;3) ConcurrentLockSet.lockObject() raises a SelfDeadlock exception if this is the case.&lt;/p&gt;

&lt;p&gt;This is my first attempt to touch this part of Derby so it is likely that I have misunderstood something important and put this code in the wrong place. I would appreciate review by the experts.&lt;/p&gt;

&lt;p&gt;I don&apos;t know if I&apos;ve allocated the SelfDeadlock exception out of the correct block of SQLStates. Technically, it is an internal error which should never escape to the user and is only used to communicate this edge-case condition to higher levels of the engine.&lt;/p&gt;


&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/loc/messages.xml&lt;br/&gt;
M       java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/p&gt;

&lt;p&gt;The new SelfDeadlock exception state.&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/store/raw/xact/TransactionFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/store/raw/RawStoreFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/services/locks/LockOwner.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/Xact.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/RAMTransaction.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/XactFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/InternalXact.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/RawStore.java&lt;/p&gt;

&lt;p&gt;Added a parent transaction id to transactions.&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/services/locks/LockControl.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/services/reflect/UpdateLoader.java&lt;/p&gt;

&lt;p&gt;Added a method to check whether any of the conflicting locks is owned by the parent transaction of the transaction which wants a lock.&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/services/locks/ConcurrentLockSet.java&lt;/p&gt;

&lt;p&gt;The lockObject() now raises a SelfDeadlock error if the parent of the requesting transaction has been granted a conflicting lock on the object.&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java&lt;/p&gt;

&lt;p&gt;Escalates to the parent (execution) transaction if a SelfDeadlock error is caught while trying to update SYS.SYSSEQUENCES in the nested transaction.&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceTest.java&lt;/p&gt;

&lt;p&gt;Test to verify that this bug is fixed.&lt;/p&gt;</comment>
                            <comment id="13989378" author="knutanders" created="Mon, 5 May 2014 10:30:16 +0100"  >&lt;p&gt;Looks like a fine approach to me. If I read the patch correctly, a nested transaction now will raise a self-deadlock if it is immediately blocked by its parent. In the more general case, where the parent is part of the lock cycle, but other transactions are involved in it too, it won&apos;t raise a self-deadlock. This sounds fine, since the case where multiple transactions are involved is where the too much contention error should be raised by design.&lt;/p&gt;

&lt;p&gt;I think I&apos;d prefer the SQLState to be something more similar to the ones for lock timeout and deadlock, so that it&apos;s more likely that existing application logic will be able to handle them sensibly if they ever leak out. With the current prefix (42), they will be reported as SQLSyntaxErrorException, which doesn&apos;t sound quite right. If the SQLState is changed to something that begins with 40, they will be reported as SQLTransactionRollbackException, same as lock timeout and deadlock.&lt;/p&gt;</comment>
                            <comment id="13989455" author="rhillegas" created="Mon, 5 May 2014 13:20:04 +0100"  >&lt;p&gt;Thanks, Knut. Attaching derby-6554-02-ab-selfDeadlock.diff. This patch moves the SelfDeadlock error into the 40* range. I am running tests now.&lt;/p&gt;

&lt;p&gt;Touches the same files as the previous rev of the patch.&lt;/p&gt;</comment>
                            <comment id="13989902" author="rhillegas" created="Mon, 5 May 2014 20:52:34 +0100"  >&lt;p&gt;Attaching D6554_2.java. This test fails with a SelfDeadlock error using the derby-6554-02-ab-selfDeadlock.diff patch. The test does the following:&lt;/p&gt;

&lt;p&gt;1) Creates and populates a table.&lt;/p&gt;

&lt;p&gt;2) Adds an index to the table.&lt;/p&gt;

&lt;p&gt;3) Then, in a single transaction, drops all the rows in the table and compresses the table.&lt;/p&gt;

&lt;p&gt;The table compression wants to do its work in a nested sub-transaction. This is a nested sub-transaction which we  haven&apos;t discussed yet. Does this case ring any bells?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13989910" author="rhillegas" created="Mon, 5 May 2014 20:59:22 +0100"  >&lt;p&gt;Here is a simple script which raises the same error:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;connect &apos;jdbc:derby:memory:db;create=true&apos;;

create table t(keycol int);

create index t_idx_keycol on t(keycol);

autocommit off;

delete from t;

call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(&apos;APP&apos;, &apos;T&apos;, 1, 1, 1);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13990670" author="rhillegas" created="Tue, 6 May 2014 15:15:03 +0100"  >&lt;p&gt;That use-case comes from the lang/compressTable.sql test. What is going on is this: The DELETE statement grabs an IX lock on the table. The SYSCS_INPLACE_COMPRESS_TABLE tries to grab an X lock on the table. The locks are incompatible. Without the patch, the test case fails on a lock timeout.&lt;/p&gt;

&lt;p&gt;I can get the test case to pass by adding another restriction: Raise SelfDeadlock only if the lock timeout is 0, that is, if we are supposed to abort the transaction when we can&apos;t immediately get the lock. This will result in a behavior change for the SYSCS_INPLACE_COMPRESS_TABLE case. We will raise a SelfDeadlock exception rather than a lock timeout exception. Is this behavior change ok? Other suggestions?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13990680" author="rhillegas" created="Tue, 6 May 2014 15:22:50 +0100"  >&lt;p&gt;Attaching derby-6554-02-ac-selfDeadlock.diff. This patch adds an extra restriction on when we raise SelfDeadlock: the requestor (that is, the nested sub-transaction) must be requesting an immediate, no-wait lock. I will run tests now.&lt;/p&gt;

&lt;p&gt;The conditions for SelfDeadlock now are:&lt;/p&gt;

&lt;p&gt;1) Must be a nested sub-transaction which is requesting the lock.&lt;/p&gt;

&lt;p&gt;2) The lock must be blocked by some other lock held by the parent transaction.&lt;/p&gt;

&lt;p&gt;3) The nested sub-transaction must have specified a lock timeout of 0.&lt;/p&gt;

&lt;p&gt;Touches the same files as the previous rev of the patch.&lt;/p&gt;</comment>
                            <comment id="13991646" author="knutanders" created="Wed, 7 May 2014 08:54:04 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I can get the test case to pass by adding another restriction: Raise SelfDeadlock only if the lock timeout is 0, that is, if we are supposed to abort the transaction when we can&apos;t immediately get the lock. This will result in a behavior change for the SYSCS_INPLACE_COMPRESS_TABLE case. We will raise a SelfDeadlock exception rather than a lock timeout exception. Is this behavior change ok?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure I fully understand this question. First it sounded as if adding the extra restriction would prevent SYSCS_INPLACE_COMPRESS_TABLE from raising SelfDeadlock. But the question seems to imply that adding the extra restriction will make it start raising SelfDeadlock rather than lock timeout in some cases. Exactly what does adding the extra restriction fix, and what behaviour change does it introduce?&lt;/p&gt;

&lt;p&gt;I think it is ok that SYSCS_INPLACE_COMPRESS_TABLE raises a lock timeout in this case (which it currently does?), since the reference manual says &quot;Tip: We recommend that you issue the SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE system procedure in auto-commit mode.&quot; Presumably that tip was added because of this issue.&lt;/p&gt;</comment>
                            <comment id="13992014" author="rhillegas" created="Wed, 7 May 2014 18:15:27 +0100"  >&lt;p&gt;Thanks for helping me think through these issues, Knut. Attaching derby-6554-02-ae-selfDeadlock_sps_compress.diff. This patch adds some more logic to catch SelfDeadlock in more nested transaction contexts and treat it like a LOCK_TIMEOUT.&lt;/p&gt;

&lt;p&gt;The only situation where SelfDeadlock should not be treated like LOCK_TIMEOUT is the sequence generator case.&lt;/p&gt;

&lt;p&gt;This patch makes the compilation of stored prepared statements (triggers) treat SelfDeadlock like LOCK_TIMEOUT. This patch also makes table compression treat SelfDeadlock like LOCK_TIMEOUT.&lt;/p&gt;

&lt;p&gt;At this point, we are back to the situation where table compression raises LOCK_TIMEOUT again so the user experience should be backward compatible.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13992138" author="rhillegas" created="Wed, 7 May 2014 20:23:37 +0100"  >&lt;p&gt;Tests passed cleanly for me on derby-6554-02-ae-selfDeadlock_sps_compress.diff. I would like to describe this patch in greater detail so that we can reason about whether this solution is adequate or needs more work.&lt;/p&gt;

&lt;p&gt;The bulk of the patch consists of a change to the lock manager to detect SelfDeadlock situations. The SelfDeadlock situation is as described above:&lt;/p&gt;

&lt;p&gt;1) Must be a nested sub-transaction which is requesting the lock.&lt;/p&gt;

&lt;p&gt;2) The lock must be blocked by some other lock held by the parent transaction.&lt;/p&gt;

&lt;p&gt;3) The nested sub-transaction must have specified a lock timeout of 0.&lt;/p&gt;

&lt;p&gt;SequenceUpdater has been changed so that it escalates locks into the parent transaction when it catches a SelfDeadlock.&lt;/p&gt;

&lt;p&gt;InsertResultSet and SPSDescriptor have been changed so that they treat SelfDeadlock the same way that they treat LockTimeout.&lt;/p&gt;

&lt;p&gt;HeapController.lockRowAtSlotNoWaitExclusive() has also been changed so that it treats SelfDeadlock just like LockTimeout. However, I would like the experts to evaluate whether that code is ok. It involves catching an exception in a situation which didn&apos;t previously involve exceptions. Exception processing is expensive. That may be ok if we can convince ourselves that SelfDeadlock will only be thrown in edge case situations. But if it is an ordinary situation on the main execution path, then we need a better solution. For the record, this situation arises when you run OnlineCompressTest. Here is the code:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    protected boolean lockRowAtSlotNoWaitExclusive(RecordHandle rh)
        throws StandardException
    {
        try {
            return(
                   open_conglom.getContainer().getLockingPolicy().
                   lockRecordForWrite
                   ( open_conglom.getRawTran(), rh, false, false) );
        }
        catch (StandardException se)
        {
            if ( se.isSelfDeadlock() ) { return false; }
            else { throw se; }
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t feel I&apos;m competent to evaluate whether this situation will arise on the main execution path. I would like advice from the experts.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
-Rick&lt;/p&gt;</comment>
                            <comment id="13992206" author="mikem" created="Wed, 7 May 2014 21:45:08 +0100"  >&lt;p&gt;can you comment on why you decided to throw a new exception on self deadlock rather than just throw &lt;br/&gt;
deadlock?  Just throwing deadlock would solve the problem if it ever leaks out, and seems the right choice.&lt;/p&gt;

&lt;p&gt;But, maybe you need the distinct error for a logic path.&lt;/p&gt;

&lt;p&gt;It is hard with java to guarantee that these exceptions which are meant to always be caught internally&lt;br/&gt;
never leak.  I think the only completely safe way is to create something different than a StandardException&lt;br/&gt;
and then explicitly declare it - but my guess is that is going to be painful with such a low level routine&lt;br/&gt;
that is likely used by a lot of paths.&lt;/p&gt;



&lt;p&gt;/mikem&lt;/p&gt;</comment>
                            <comment id="13992236" author="mikem" created="Wed, 7 May 2014 22:20:10 +0100"  >&lt;p&gt;Trying to think about the compress self deadlock issue.  &lt;/p&gt;

&lt;p&gt;o Before your change is a lock timeout ever raised in the case of 0 wait lock request?&lt;/p&gt;

&lt;p&gt;o Do any of your changes require a self deadlock exception to be raised in the case of 0 wait lock request?&lt;br/&gt;
   I with this new lock functionality that sequences will wait for some time for the lock now that self deadlock&lt;br/&gt;
   will return immediately so won&apos;t be following the 0 wait lock request code path.&lt;/p&gt;

&lt;p&gt;If possible it would seem better not to raise an exception at all in this case where the request to lock&lt;br/&gt;
 manager asked not to wait at all. &lt;/p&gt;

&lt;p&gt;The lock manager javadoc does not seem difinitive in what to expect for 0 wait locks, but as you&lt;br/&gt;
are seeing code seemed not to expect exceptions when specifying 0 wait locks.  Whatever we decide&lt;br/&gt;
it would be good to beef up the javadoc to say what should be expected.&lt;/p&gt;</comment>
                            <comment id="13992297" author="mikem" created="Wed, 7 May 2014 23:16:28 +0100"  >&lt;p&gt;Does the following work/make sense:&lt;/p&gt;

&lt;p&gt;Change lock manger to continue to return no exception if lock can not be granted if lock is 0 wait.  Hopefully&lt;br/&gt;
this would then limit impact on other parts of the code until they can be changed to take advantage of the&lt;br/&gt;
new functionality.&lt;/p&gt;

&lt;p&gt;Change lock manger to always check for self deadlock (if it has the available fields to check), if a &lt;br/&gt;
non-0 wait lock can not be granted, and throw exception if it is a self deadlock.  &lt;/p&gt;

&lt;p&gt;Change DataDictionaryImpl.java!updateCurrentSequenceValue to always wait for the lock, knowing that&lt;br/&gt;
it will be a 0 wait if it is a self deadlock, and then change caller to catch and retry on appropriate exception&lt;br/&gt;
thrown.  Not many comments in this routine, but I think all the wait inputs and complication was to take&lt;br/&gt;
care of the problem being solved by doing self deadlock detection.  So maybe both caller and this code&lt;br/&gt;
can be simplified by always waiting.  Not sure how much to wait - either user set wait, or internal hard&lt;br/&gt;
coded, or some combination of both - for instance may want to wait some in internal transaction even if&lt;br/&gt;
user has specified 0 wait for user locks.&lt;/p&gt;
</comment>
                            <comment id="13992840" author="rhillegas" created="Thu, 8 May 2014 16:22:03 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;Some responses to your comments:&lt;/p&gt;

&lt;p&gt;MM&amp;gt; can you comment on why you decided to throw a new exception on self deadlock rather than just throw &lt;br/&gt;
MM&amp;gt; deadlock? Just throwing deadlock would solve the problem if it ever leaks out, and seems the right choice.&lt;br/&gt;
MM&amp;gt; &lt;br/&gt;
MM&amp;gt; But, maybe you need the distinct error for a logic path.&lt;/p&gt;

&lt;p&gt;Yes, that is the problem. SequenceUpdater needs to distinguish a SelfDeadlock from an ordinary Deadlock.&lt;/p&gt;

&lt;p&gt;MM&amp;gt; &lt;br/&gt;
MM&amp;gt; It is hard with java to guarantee that these exceptions which are meant to always be caught internally&lt;br/&gt;
MM&amp;gt; never leak. I think the only completely safe way is to create something different than a StandardException&lt;br/&gt;
MM&amp;gt; and then explicitly declare it - but my guess is that is going to be painful with such a low level routine&lt;br/&gt;
MM&amp;gt; that is likely used by a lot of paths.&lt;/p&gt;

&lt;p&gt;I can create a SelfDeadlock subtype of StandardException. StandardException already has a few subtypes. But that won&apos;t address the performance question.&lt;/p&gt;

&lt;p&gt;MM&amp;gt; Trying to think about the compress self deadlock issue.&lt;br/&gt;
MM&amp;gt; &lt;br/&gt;
MM&amp;gt; o Before your change is a lock timeout ever raised in the case of 0 wait lock request?&lt;br/&gt;
MM&amp;gt; &lt;/p&gt;

&lt;p&gt;I don&apos;t think so. It appears to me that ConcurrentLockSet.lockObject() returns null if you can&apos;t get a lock immediately and (AbstractPool.noLockWait(timeout, compatibilitySpace) == true). But I don&apos;t understand what condition sets up the special &quot;else&quot; case in AbstractPool.noLockWait():&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    static boolean noLockWait(int timeout, CompatibilitySpace compat) {
        if (timeout == C_LockFactory.NO_WAIT) {
            return true;
        } else {
            LockOwner owner = compat.getOwner();
            return owner != null &amp;amp;&amp;amp; owner.noWait();
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MM&amp;gt; o Do any of your changes require a self deadlock exception to be raised in the case of 0 wait lock request?&lt;br/&gt;
MM&amp;gt; &lt;/p&gt;

&lt;p&gt;The requirement is that SequenceUpdater have a way to figure out that SelfDeadlock happened. That is, that it was blocked by its own (parent transaction) lock rather than by a lock held by another Connection. There are a lot of code layers between SequenceUpdater and ConcurrentLockSet. There may be some way to signal SelfDeadlock without raising an exception. This would involve changes to the ConglomerateController interface and maybe some other interfaces.&lt;/p&gt;

&lt;p&gt;MM&amp;gt; I with this new lock functionality that sequences will wait for some time for the lock now that self deadlock&lt;br/&gt;
MM&amp;gt; will return immediately so won&apos;t be following the 0 wait lock request code path.&lt;br/&gt;
MM&amp;gt; &lt;br/&gt;
MM&amp;gt; If possible it would seem better not to raise an exception at all in this case where the request to lock&lt;br/&gt;
MM&amp;gt; manager asked not to wait at all.&lt;/p&gt;

&lt;p&gt;Agreed.&lt;/p&gt;

&lt;p&gt;MM&amp;gt; Does the following work/make sense:&lt;br/&gt;
MM&amp;gt; &lt;br/&gt;
MM&amp;gt; Change lock manger to continue to return no exception if lock can not be granted if lock is 0 wait. Hopefully&lt;br/&gt;
MM&amp;gt; this would then limit impact on other parts of the code until they can be changed to take advantage of the&lt;br/&gt;
MM&amp;gt; new functionality.&lt;br/&gt;
MM&amp;gt; &lt;br/&gt;
MM&amp;gt; Change lock manger to always check for self deadlock (if it has the available fields to check), if a &lt;br/&gt;
MM&amp;gt; non-0 wait lock can not be granted, and throw exception if it is a self deadlock.&lt;br/&gt;
MM&amp;gt; &lt;br/&gt;
MM&amp;gt; Change DataDictionaryImpl.java!updateCurrentSequenceValue to always wait for the lock, knowing that&lt;br/&gt;
MM&amp;gt; it will be a 0 wait if it is a self deadlock, and then change caller to catch and retry on appropriate exception&lt;br/&gt;
MM&amp;gt; thrown. Not many comments in this routine, but I think all the wait inputs and complication was to take&lt;br/&gt;
MM&amp;gt; care of the problem being solved by doing self deadlock detection. So maybe both caller and this code&lt;br/&gt;
MM&amp;gt; can be simplified by always waiting. Not sure how much to wait - either user set wait, or internal hard&lt;br/&gt;
MM&amp;gt; coded, or some combination of both - for instance may want to wait some in internal transaction even if&lt;br/&gt;
MM&amp;gt; user has specified 0 wait for user locks&lt;/p&gt;

&lt;p&gt;Not sure I follow. I think what you are suggesting is the following:&lt;/p&gt;

&lt;p&gt;1) Have SequenceUpdater wait for the smallest non-zero timeout, 1 millisecond. The smaller the timeout the better. We want to prevent threads from piling up like a train wreck behind a request to allocate a new range of sequence values.&lt;/p&gt;

&lt;p&gt;2) Only raise SelfDeadlock if the timeout is non-zero.&lt;/p&gt;

&lt;p&gt;I think I would like to try another solution first:&lt;/p&gt;

&lt;p&gt;1) Currently, all negative values of derby.locks.waitTimeout are collapsed into a single meaning: WaitForever. We can give Integer.MIN_VALUE a special meaning: DontWaitButRaiseSelfDeadlockOnFailure&lt;/p&gt;

&lt;p&gt;2) The lock manager will raise SelfDeadlock only if the timeout value is DontWaitButRaiseSelfDeadlockOnFailure.&lt;/p&gt;

&lt;p&gt;3) At least initially, SequenceUpdater will be the only caller who requests a lock with a timeout of DontWaitButRaiseSelfDeadlockOnFailure.&lt;/p&gt;</comment>
                            <comment id="13992897" author="mikem" created="Thu, 8 May 2014 17:29:04 +0100"  >&lt;p&gt;I am not seeing email from apache right now, will continue talking here.&lt;/p&gt;

&lt;p&gt;I have no problem with raising the exception, and am not seeing why we need to have special cases&lt;br/&gt;
when we raise self deadlock.  I am not understanding why it is good to not wait in the subtransaction&lt;br/&gt;
if we know we are waiting for another thread to allocated the sequence.&lt;/p&gt;

&lt;p&gt;I am just not understanding the &quot;backing&quot; up problem.  I assumed that we would want to eliminate the&lt;br/&gt;
too much contention error by now waiting some reasonable amount of time (not minimum) in the nested&lt;br/&gt;
transaction if we knew for sure it was not a self deadlock.  I assume if nested transaction can&apos;t get lock,&lt;br/&gt;
and we know it is not self deadlock there is no work that thread can do at that point.  So the options are:&lt;br/&gt;
1) throw an error and fail the insert immediately&lt;br/&gt;
2) wait for whatever thread is doing the update to finish and then proceed&lt;/p&gt;</comment>
                            <comment id="13992909" author="mikem" created="Thu, 8 May 2014 17:44:08 +0100"  >&lt;p&gt;if you feel strongly it is important to not wait at all in the subtransaction for sequences, i don&apos;t think it is worth the effort to special case as you are suggesting.  In that case I see why you need the exception, and I will just revisit&lt;br/&gt;
thoughts on what to do for self deadlock on 0 wait scenario.    Would rather not see more complication&lt;br/&gt;
in the lock manager for this as you are suggesting.  Better to just teach the rest of the code to expect an&lt;br/&gt;
exception on self deadlock.  &lt;/p&gt;

&lt;p&gt;I still think we should throw self deadlock in the wait case no matter what.&lt;/p&gt;</comment>
                            <comment id="13993593" author="rhillegas" created="Fri, 9 May 2014 15:20:05 +0100"  >&lt;p&gt;None of us are getting Apache email right now, so I missed your latest comments, too. I am attaching a new rev of the patch. You can evaluate whether you think this version is better or worse than the previous rev.&lt;/p&gt;

&lt;p&gt;The new rev adds an extra argument to lockObject() so that callers can request how they want SelfDeadlock to be handled:&lt;/p&gt;

&lt;p&gt;1) Callers can ask that a SelfDeadlock exception be thrown. This option is useful when callers need to distinguish the SelfDeadlock situation from other situations in which a nested subtransaction can&apos;t get a lock immediately.&lt;/p&gt;

&lt;p&gt;2) Callers can ask for the existing behavior prior to the work on this issue. That is, lockObject() returns null if a lock can&apos;t be grabbed immediately and does not distinguish between SelfDeadlock and being blocked by another Connection&apos;s work.&lt;/p&gt;

&lt;p&gt;Attaching derby-6554-02-af-askToRaiseSelfDeadlock.diff. I am running tests.&lt;/p&gt;

&lt;p&gt;It became clear from the previous revs of this patch that there are many places where Derby attempts to do work in a nested sub-transa tion, hoping to get a lock immediately. The new code affected too many old code paths. And by the time we got to lockObject(), there was not enough context in the call arguments to let us isolate the SequenceUpdater case. &lt;/p&gt;

&lt;p&gt;So I am experimenting with a solution in which the caller has to explicitly request a SelfDeadlock exception when a nested subtransaction is blocked by its parent and it can&apos;t grab a lock immediately.&lt;/p&gt;

&lt;p&gt;This new patch adds a new argument to LockFactory.lockObject(): raiseSelfDeadlock. When this argument is set to true, lockObject() raises a SelfDeadlock exception. Otherwise, lockObject() behaves the way it did before this patch. The only code path which sets raiseSelfDeadlock is the code path starting with SequenceUpdater.&lt;/p&gt;

&lt;p&gt;There are 3 parts to this patch:&lt;/p&gt;

&lt;p&gt;1) Adding more state to transactions so that we can detect the self-deadlock between a nested subtransaction and its parent. This logic was in the previous revs of the patch.&lt;/p&gt;

&lt;p&gt;2) Adding the new raiseSelfDeadlock argument to LockFactory.lockObject(). These changes are new to this patch.&lt;/p&gt;

&lt;p&gt;3) Adjusting SequenceUpdater so that it escalates locks into the parent transaction when it detects a SelfDeadlock.&lt;/p&gt;

&lt;p&gt;Touches the following files:&lt;/p&gt;

&lt;p&gt;---------------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/services/locks/LockOwner.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/error/StandardException.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/store/raw/xact/TransactionFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/store/raw/RawStoreFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/services/reflect/UpdateLoader.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/services/locks/ConcurrentLockSet.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/services/locks/LockControl.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/RAMTransaction.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/Xact.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/XactFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/InternalXact.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/RawStore.java&lt;br/&gt;
M       java/engine/org/apache/derby/loc/messages.xml&lt;br/&gt;
M       java/shared/org/apache/derby/shared/common/reference/SQLState.java&lt;/p&gt;

&lt;p&gt;Changes for 1). Machinery to detect a self-deadlock between a subtransaction and its parent transaction. These changes were in the previous rev of the patch.&lt;/p&gt;

&lt;p&gt;---------------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/iapi/services/locks/LockFactory.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/services/locks/LockTable.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/services/locks/AbstractPool.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/PropertyConglomerate.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/store/raw/LockingPolicy.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/RowLocking2.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/RowLocking3.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/ContainerLocking2.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/ContainerLocking3.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/xact/NoLocking.java&lt;br/&gt;
M       java/engine/org/apache/derby/iapi/store/access/ConglomerateController.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/conglomerate/OpenConglomerate.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/conglomerate/GenericScanController.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/btree/BTreeController.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/access/heap/HeapController.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/data/BasePage.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/data/ReclaimSpaceHelper.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/store/raw/data/LogicalPageOperation.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/unitTests/services/T_User.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/unitTests/services/T_LockFactory.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/unitTests/store/T_AccessFactory.java&lt;br/&gt;
M       java/testing/org/apache/derbyTesting/unitTests/store/T_RawStoreFactory.java&lt;/p&gt;

&lt;p&gt;Changes for 2). New raiseSelfDeadlock argument for lockObject(). This includes changes to the conglomerate interfaces so that raiseSelfDeadlock behavior can be requested when opening conglomerates and fetching rows. These changes are new to this patch.&lt;/p&gt;

&lt;p&gt;---------------------&lt;/p&gt;

&lt;p&gt;M       java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java&lt;br/&gt;
M       java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java&lt;/p&gt;

&lt;p&gt;Request raiseSelfDeadlock behavior when updating rows in SYS.SYSSEQUENCES. The DataDictionaryImpl change is what&apos;s new to this patch.&lt;/p&gt;

&lt;p&gt;---------------------&lt;/p&gt;

&lt;p&gt;M       java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceTest.java&lt;/p&gt;

&lt;p&gt;Test the fix to this bug. This test case was in the previous rev of the patch.&lt;/p&gt;</comment>
                            <comment id="13993604" author="rhillegas" created="Fri, 9 May 2014 15:41:29 +0100"  >&lt;p&gt;If tests pass cleanly on that last rev of the patch, we can choose which behavior is better:&lt;/p&gt;

&lt;p&gt;1) derby-6554-02-ae-selfDeadlock_sps_compress.diff - This rev of the patch raises a SelfDeadlock exception whenever a parent transaction is blocking a nested subtransaction and the subtransaction can&apos;t get a lock immediately.&lt;/p&gt;

&lt;p&gt;2) derby-6554-02-af-askToRaiseSelfDeadlock.diff - This rev of the patch lets the caller choose whether a SelfDeadlock exception should be thrown or whether lockObject() should just return null if it can&apos;t grab a lock immediately. The null return value does not distinguish SelfDeadlock from BlockedByAnotherConnection.&lt;/p&gt;

&lt;p&gt;I think I understand your preference for the first solution. I can run an experiment with that patch to see what breaks if SelfDeadlock is raised when the caller is willing to wait. Having gotten to this point and seen how many parts of the code use nested subtransactions, I just want to raise a warning flag that this may break a lot of tests and create backward compatibility problems because SelfDeadlock will be thrown in cases where the user application is expecting LockTimeout. It may be better to pursue this improvement in a separate issue.&lt;/p&gt;</comment>
                            <comment id="13993605" author="rhillegas" created="Fri, 9 May 2014 15:45:52 +0100"  >&lt;p&gt;Tests passed cleanly on derby-6554-02-af-askToRaiseSelfDeadlock.diff.&lt;/p&gt;</comment>
                            <comment id="13993655" author="mikem" created="Fri, 9 May 2014 16:57:34 +0100"  >&lt;p&gt;I do prefer an option where the lockmanger just picks the behavior and the calling code deals with it.  Would&lt;br/&gt;
rather not add another knob to the lockmanager if we can help it.&lt;/p&gt;

&lt;p&gt;My preferred behavior would be:&lt;br/&gt;
o on 0 wait locks, continue to not throw exceptions even for self deadlocks.  This would mean changing&lt;br/&gt;
   sequence subtransaction to wait for lock rather than 0 wait so that it can &quot;know&quot; that a self deadlock &lt;br/&gt;
   has happened.&lt;/p&gt;

&lt;p&gt;o on non-0 wait locks, always check for self deadlock when lock can&apos;t be granted immediately and we&lt;br/&gt;
   have the info to check (which I believe will only be checked for subtransactions), and throw self &lt;br/&gt;
   deadlock exception if appropriate.&lt;/p&gt;

&lt;p&gt;Having said that I would welcome a sequence checkin that got us partway, with a separate JIRA &lt;br/&gt;
issue/work  to deal with possible fallout from always throwing self deadlock on wait.   Is there something &lt;br/&gt;
you can check in that passes tests (or maybe just  a few break that we can temp disable) without adding the lock interface change?  &lt;/p&gt;</comment>
                            <comment id="13993663" author="mikem" created="Fri, 9 May 2014 17:15:59 +0100"  >&lt;p&gt;I still am worried I don&apos;t understand the problem with waiting on locks in the sequence sub transaction.   Can you describe your preferred behavior for the system when we run out of allocated range, transaction A&lt;br/&gt;
get lock to allocate the range, and transaction B also needs one and I assume also tries to allocate the&lt;br/&gt;
range and will lock conflict with transaction A.&lt;/p&gt;</comment>
                            <comment id="13993866" author="rhillegas" created="Fri, 9 May 2014 20:45:59 +0100"  >&lt;p&gt;Attaching derby-6554-02-ag-raiseSelfDeadlockAlways.diff. This is a variation on derby-6554-02-ae-selfDeadlock_sps_compress.diff. This patch always raises a SelfDeadlock when one is detected, regardless of whether we&apos;re asked to wait. So this patch has the extra logic in HeapController.lockRowAtSlotNoWaitExclusive() which catches a SelfDeadlock and returns a null lock.&lt;/p&gt;

&lt;p&gt;Tests passed cleanly except for two errors:&lt;/p&gt;

&lt;p&gt;1) testDerby48SelfLockingRecoveryDeadlockDetectionOn() (in LazyDefaultSchemaCreationTest) now fails because an expected timeout isn&apos;t raised. The following script shows the problem. Without the patch, this script fails on a LOCK_TIMEOUT. With the patch, the script succeeds.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;connect &apos;jdbc:derby:memory:db;create=true&apos;;

call syscs_util.syscs_set_database_property( &apos;derby.locks.deadlockTrace&apos;, &apos;true&apos; );
call syscs_util.syscs_set_database_property( &apos;derby.locks.waitTimeout&apos;, &apos;1&apos; );
call syscs_util.syscs_set_database_property( &apos;derby.locks.deadlockTimeout&apos;, &apos;2&apos; );

connect &apos;jdbc:derby:memory:db;user=foo&apos;;

autocommit off;

set isolation serializable;

select count(*) from sys.sysschemas;

create table t1(i int);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2) The store unit tests had a failure in T_LockFactory. Not a lot of information in the failure report:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;********* Diff file derbyall/storeall/storeunit/TLockFactory.diff
*** Start: TLockFactory jdk1.8.0 storeall:storeunit 2014-05-09 08:28:09 ***
2 del
&amp;lt; -- Unit Test T_LockFactory finished
2 add
&amp;gt; Shutting down due to unit test failure.
Test Failed.
*** End:   TLockFactory jdk1.8.0 storeall:storeunit 2014-05-09 08:28:10 ***
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Mike, at this point I don&apos;t exactly remember what breaks if we wait for locks in SequenceUpdater. That logic was arrived at painfully a couple years back. We can certainly try putting waits back in. Maybe everything will be fine. Or maybe we will painfully rediscover why we did it this way. One reason you don&apos;t want to wait is because this logic is called during cache eviction/flushing and during orderly database shutdown. If there are locks on SYSSEQUENCES, then cache eviction will stall, ddl will stall, and orderly shutdown will block. If the lock timeout is infinite, this would be very bad. We could try waiting for the minimum time, a millisecond. I suspect that will cause pile-ups, but I&apos;m not sure. It also involves a change to the existing apis which is as big as the change in patch derby-6554-02-af-askToRaiseSelfDeadlock.diff. That is because the current store interfaces don&apos;t let you pass a lock timeout override down the call stack when you open a conglomerate or fetch a row.&lt;/p&gt;

&lt;p&gt;I&apos;ll be away for a week. Someone else is welcome to play around with this while I&apos;m gone and check in one of the solutions if they feel confident. Here&apos;s a summary of the candidate patches:&lt;/p&gt;

&lt;p&gt;1) derby-6554-02-ae-selfDeadlock_sps_compress.diff&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;passes the tests&lt;/li&gt;
	&lt;li&gt;raises a SelfDeadlock only if requested not to wait&lt;/li&gt;
	&lt;li&gt;forces HeapController.lockRowAtSlotNoWaitExclusive() to catch an exception&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2) derby-6554-02-af-askToRaiseSelfDeadlock.diff&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;passes the tests&lt;/li&gt;
	&lt;li&gt;SelfDeadlock is raised only if the caller asks for it&lt;/li&gt;
	&lt;li&gt;no change to HeapController.lockRowAtSlotNoWaitExclusive()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3) derby-6554-02-ag-raiseSelfDeadlockAlways.diff&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fails 2 tests (see above)&lt;/li&gt;
	&lt;li&gt;always raises SelfDeadlock, regardless of whether waiting was requested&lt;/li&gt;
	&lt;li&gt;forces HeapController.lockRowAtSlotNoWaitExclusive() to catch an exception&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All of these patches fix &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6554&quot; title=&quot;Too much contention followed by assert failure when accessing sequence in transaction that created it&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6554&quot;&gt;&lt;del&gt;DERBY-6554&lt;/del&gt;&lt;/a&gt;. But I don&apos;t think that any of these patches fits your preferences. The first two at least pass the tests.&lt;/p&gt;

&lt;p&gt;Thanks for helping me think through these issues.&lt;/p&gt;</comment>
                            <comment id="13993922" author="mikem" created="Fri, 9 May 2014 22:20:37 +0100"  >&lt;p&gt;thanks rick for the explanation, i keep forgetting about the shutdown and cache eviction case.  I&apos;ll think about&lt;br/&gt;
it some more while you are out.  But early thoughts would be to take incremental steps so as to not hold&lt;br/&gt;
up your sequence work any more:&lt;/p&gt;

&lt;p&gt;1) go with your patch #1 above as it seems to do what you need and passes tests.  I think it only slows&lt;br/&gt;
    down delete row reclamation with extra exceptions vs returns, so probably ok.  I am ok with the one&lt;br/&gt;
    store change for now as an incremental step.&lt;/p&gt;

&lt;p&gt;2) file a separate JIRA to put in self deadlock detection in for waiting locks.  With your patches the&lt;br/&gt;
    code is available and work just needs to be done on problems with rest of code.&lt;/p&gt;

&lt;p&gt;3) file a separate JIRA to change 0 wait locks to not throw an exception in self deadlock.  This will need&lt;br/&gt;
    a solution that works for sequences.  Not sure of solution at this point, would be easy if we can have&lt;br/&gt;
    sequences wait.   &lt;/p&gt;

&lt;p&gt;4) test and see if we think sequences would benefit from waiting.   If so figure out how to wait.  Current&lt;br/&gt;
    lock interfaces don&apos;t make it easy to set timeout&apos;s other than 0 and default.  &lt;br/&gt;
    I think we want sequences to wait at least as long as we expect another transaction&lt;br/&gt;
    to take to update the sequence and commit the transaction on a system that does a real I/O at commit&lt;br/&gt;
    time.   If waiting does not work out, may still want to try sleep retry now that we know we are not&lt;br/&gt;
    in self deadlock vs. sending an error to user.  All depends on doing this without negatively affecting&lt;br/&gt;
    the shutdown and cache clean cases.&lt;/p&gt;

&lt;p&gt;I would be interested in working on #2, as it ties in with work I would like to do to improve automatic&lt;br/&gt;
space reclamation.  I think some of the problems in this area are with self deadlock and waiting may&lt;br/&gt;
help.  It would be easier to work on this if we separated the dependencies.  Along with #2 I would look&lt;br/&gt;
at all the store nested transactions and make sure they are ready and do the right thing with self&lt;br/&gt;
deadlock.  I may need help with the language layer uses, but I don&apos;t think there are many other than&lt;br/&gt;
sequences and identity.&lt;/p&gt;</comment>
                            <comment id="13994242" author="jira-bot" created="Sat, 10 May 2014 14:55:50 +0100"  >&lt;p&gt;Commit 1593702 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rhillegas&quot; class=&quot;user-hover&quot; rel=&quot;rhillegas&quot;&gt;Rick Hillegas&lt;/a&gt; in branch &apos;code/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1593702&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1593702&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6554&quot; title=&quot;Too much contention followed by assert failure when accessing sequence in transaction that created it&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6554&quot;&gt;&lt;del&gt;DERBY-6554&lt;/del&gt;&lt;/a&gt;: Raise SelfDeadlock when a nested subtransaction can&apos;t immediately get a lock because it is blocked by its parent transaction; commit derby-6554-02-ae-selfDeadlock_sps_compress.diff.&lt;/p&gt;</comment>
                            <comment id="13994243" author="rhillegas" created="Sat, 10 May 2014 15:07:46 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;I have checked in derby-6554-02-ae-selfDeadlock_sps_compress.diff, the patch you prefer. I have also logged new, follow-on issues:&lt;/p&gt;

&lt;p&gt;o &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6572&quot; title=&quot;Raise SelfDeadlock exception when a nested sub transaction has to wait for a lock held by its parent transaction.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6572&quot;&gt;DERBY-6572&lt;/a&gt; - This is item 2 in your previous comment.&lt;/p&gt;

&lt;p&gt;o &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6573&quot; title=&quot;Don&amp;#39;t throw an exception if a nested sub transaction can&amp;#39;t immediately get a blocking lock held by its parent transaction.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6573&quot;&gt;DERBY-6573&lt;/a&gt; - This is item 3 in your previous comment.&lt;/p&gt;

&lt;p&gt;Hopefully, this is enough to get you going on item 2. Note that besides sequence/identity, the language layer uses nested sub transactions during trigger compilation (technically, during the compilation of any stored prepared statement).&lt;/p&gt;</comment>
                            <comment id="13994926" author="knutanders" created="Mon, 12 May 2014 09:21:49 +0100"  >&lt;p&gt;Sorry for the late response. I missed most of this discussion while the Apache mail server was down.&lt;/p&gt;

&lt;p&gt;Rick said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I don&apos;t think so. It appears to me that ConcurrentLockSet.lockObject() returns null if you can&apos;t get a lock immediately and (AbstractPool.noLockWait(timeout, compatibilitySpace) == true). But I don&apos;t understand what condition sets up the special &quot;else&quot; case in AbstractPool.noLockWait():&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; noLockWait(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; timeout, CompatibilitySpace compat) {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (timeout == C_LockFactory.NO_WAIT) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
            LockOwner owner = compat.getOwner();
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; owner != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; owner.noWait();
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;The else branch is currently used when storing SPSs and by the index statistics daemon. Look for callers of TransactionController.setNoLockWait(). In those cases, waiting is disabled for the entire transaction, even if a no-wait flag isn&apos;t given as argument to the scan. That means the lock manager will see a request for a timed wait, but it will handle it as a no-wait request because of the flag on the transaction.&lt;/p&gt;</comment>
                            <comment id="14002033" author="rhillegas" created="Mon, 19 May 2014 18:32:05 +0100"  >&lt;p&gt;It appears to me that this bug is fixed after checking in derby-6554-02-ae-selfDeadlock_sps_compress.diff. Follow-on issues have been created. I am resolving this issue.&lt;/p&gt;</comment>
                            <comment id="14147023" author="mikem" created="Wed, 24 Sep 2014 23:50:30 +0100"  >&lt;p&gt;I believe the changes are closely related to new code introduced in 10.11 and are not appropriate for backport.  To get this fix one must upgrade to 10.11 or higher release.  marking it as not appropriate for backport.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12708269">DERBY-6542</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12732287">DERBY-6692</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12713457">DERBY-6572</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12713458">DERBY-6573</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12642470" name="D6554.java" size="951" author="knutanders" created="Tue, 29 Apr 2014 16:12:47 +0100"/>
                            <attachment id="12643414" name="D6554_2.java" size="5914" author="rhillegas" created="Mon, 5 May 2014 20:52:34 +0100"/>
                            <attachment id="12642457" name="derby-6554-01-aa-useCreationTransaction.diff" size="9746" author="rhillegas" created="Tue, 29 Apr 2014 14:59:50 +0100"/>
                            <attachment id="12642501" name="derby-6554-01-ab-useCreationTransaction.diff" size="11479" author="rhillegas" created="Tue, 29 Apr 2014 18:49:59 +0100"/>
                            <attachment id="12642704" name="derby-6554-01-ac-useCreationTransaction.diff" size="21805" author="rhillegas" created="Wed, 30 Apr 2014 20:14:07 +0100"/>
                            <attachment id="12642849" name="derby-6554-01-ad-bugfixes.diff" size="10518" author="rhillegas" created="Thu, 1 May 2014 15:12:51 +0100"/>
                            <attachment id="12643098" name="derby-6554-02-aa-selfDeadlock.diff" size="21850" author="rhillegas" created="Fri, 2 May 2014 20:33:47 +0100"/>
                            <attachment id="12643354" name="derby-6554-02-ab-selfDeadlock.diff" size="21527" author="rhillegas" created="Mon, 5 May 2014 13:20:04 +0100"/>
                            <attachment id="12643578" name="derby-6554-02-ac-selfDeadlock.diff" size="22471" author="rhillegas" created="Tue, 6 May 2014 15:22:50 +0100"/>
                            <attachment id="12643803" name="derby-6554-02-ae-selfDeadlock_sps_compress.diff" size="25482" author="rhillegas" created="Wed, 7 May 2014 18:15:27 +0100"/>
                            <attachment id="12644112" name="derby-6554-02-af-askToRaiseSelfDeadlock.diff" size="57562" author="rhillegas" created="Fri, 9 May 2014 15:20:05 +0100"/>
                            <attachment id="12644173" name="derby-6554-02-ag-raiseSelfDeadlockAlways.diff" size="25357" author="rhillegas" created="Fri, 9 May 2014 20:45:59 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 25 Apr 2014 12:46:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>388858</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hzou5b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>389104</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10050"><![CDATA[Blocker]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>