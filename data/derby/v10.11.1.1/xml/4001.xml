<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:48:24 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-4001/DERBY-4001.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-4001] Sequence comparison with &quot;ALL&quot; does not yield correct results</title>
                <link>https://issues.apache.org/jira/browse/DERBY-4001</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>
&lt;p&gt;A query involving &quot;&amp;lt; ALL&quot; does not yield the right results for decimal datatype. &quot;&amp;lt; ANY&quot; works, though.&lt;/p&gt;

&lt;p&gt;To reproduce the issue:&lt;/p&gt;

&lt;p&gt;% create table t1(col1 decimal(10,5));&lt;br/&gt;
% insert into t1 values (-21483.64800);&lt;br/&gt;
% insert into t1 values (74837.00000);&lt;br/&gt;
% select col1 from t1 where col1 &amp;lt; ALL (select 0.0 from t1);&lt;/p&gt;

&lt;p&gt;The above yields no results whereas it should return the first row.&lt;/p&gt;</description>
                <environment>Windows</environment>
        <key id="12411669">DERBY-4001</key>
            <summary>Sequence comparison with &quot;ALL&quot; does not yield correct results</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="viyer">Venkateswaran Iyer</reporter>
                        <labels>
                    </labels>
                <created>Mon, 5 Jan 2009 07:16:59 +0000</created>
                <updated>Fri, 21 Jan 2011 17:52:11 +0000</updated>
                            <resolved>Tue, 28 Apr 2009 08:48:47 +0100</resolved>
                                    <version>10.3.2.1</version>
                                    <fixVersion>10.5.2.0</fixVersion>
                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12660707" author="knutanders" created="Mon, 5 Jan 2009 10:13:54 +0000"  >&lt;p&gt;I tried to reproduce the issue, but in my environment (OpenSolaris, java 1.6.0_10) the query does return the first row. I tried both Derby 10.3.2.1, where the problem was reported, and Derby 10.4.2.0.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t1(col1 decimal(10,5));&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t1 values (-21483.64800);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t1 values (74837.00000);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select col1 from t1 where col1 &amp;lt; ALL (select 0.0 from t1);&lt;br/&gt;
COL1        &lt;br/&gt;
------------&lt;br/&gt;
-21483.64800&lt;/p&gt;

&lt;p&gt;1 row selected&lt;/p&gt;</comment>
                            <comment id="12660858" author="viyer" created="Mon, 5 Jan 2009 18:59:05 +0000"  >&lt;p&gt;I forgot to add that the column has to be declared with a &quot;NOT NULL&quot; constraint. Attached the output from ij.&lt;/p&gt;


&lt;p&gt;======================&lt;/p&gt;

&lt;p&gt;C:\apps\derby\db-derby-10.4.2.0-bin\db-derby-10.4.2.0-bin\bin&amp;gt;ij&lt;br/&gt;
ij version 10.4&lt;br/&gt;
ij&amp;gt; connect .........................................&lt;br/&gt;
ij&amp;gt; drop table t2;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table t2(acdecimal decimal(10,5) not null);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t2 values (-21483.648);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t2 values (74387);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t2;&lt;br/&gt;
ACDECIMAL&lt;br/&gt;
------------&lt;br/&gt;
-21483.64800&lt;br/&gt;
74387.00000&lt;/p&gt;

&lt;p&gt;2 rows selected&lt;br/&gt;
ij&amp;gt; select acdecimal from t2 where acdecimal &amp;lt; all (select 0.0 from t2);&lt;br/&gt;
ACDECIMAL&lt;br/&gt;
------------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;br/&gt;
ij&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12661174" author="knutanders" created="Tue, 6 Jan 2009 15:52:27 +0000"  >&lt;p&gt;Thanks. I see the issue too when I add NOT NULL.&lt;/p&gt;</comment>
                            <comment id="12661184" author="knutanders" created="Tue, 6 Jan 2009 16:09:04 +0000"  >&lt;p&gt;The problem does not seem to be limited to the decimal data type:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t(x varchar(10) not null);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t values &apos;a&apos;,&apos;b&apos;,&apos;c&apos;;&lt;br/&gt;
3 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select x from t where x &amp;lt; ALL (select &apos;b&apos; from t);&lt;br/&gt;
X         &lt;br/&gt;
----------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;/p&gt;

&lt;p&gt;(Should have returned one row. Works as expected if the NOT NULL constraint is removed.)&lt;/p&gt;</comment>
                            <comment id="12661206" author="knutanders" created="Tue, 6 Jan 2009 17:07:55 +0000"  >&lt;p&gt;SubqueryNode apparently rewrites queries with ALL differently depending on whether the columns are nullable or not. Since we only see this problem when the column isn&apos;t nullable, that&apos;s probably a good starting point for tracking down the bug. Here&apos;s a comment from SubqueryNode.pushNewPredicate():&lt;/p&gt;

&lt;p&gt;		/* For NOT IN or ALL, and if either side of the comparison is nullable, and the&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;subquery can not be flattened (because of that), we need to add IS NULL node&lt;/li&gt;
	&lt;li&gt;on top of the nullables, such that the behavior is (beetle 5173):&lt;br/&gt;
		 *&lt;/li&gt;
	&lt;li&gt;(1) If we have nulls in right operand, no row is returned.&lt;/li&gt;
	&lt;li&gt;(2) If subquery result is empty before applying join predicate, every&lt;/li&gt;
	&lt;li&gt;left row (including NULLs) is returned.&lt;/li&gt;
	&lt;li&gt;(3) Otherwise, return 
{all left row}
&lt;p&gt; - &lt;/p&gt;
{NULLs}
&lt;p&gt;		 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12688706" author="knutanders" created="Tue, 24 Mar 2009 14:57:58 +0000"  >&lt;p&gt;The query &quot;SELECT x FROM t WHERE x &amp;lt; ALL (SELECT &apos;b&apos; FROM t)&quot; will be&lt;br/&gt;
rewritten internally to a not exists join between &quot;SELECT x FROM t t1&quot;&lt;br/&gt;
(left side) and &quot;SELECT * FROM t t2&quot; (right side) with t1.x &amp;gt;= &apos;b&apos; as&lt;br/&gt;
the join condition. All is correct so far.&lt;/p&gt;

&lt;p&gt;But then at some point (not sure where), the optimizer decides that&lt;br/&gt;
the join condition should be pushed down into the scan on the left&lt;br/&gt;
side of the join. However, there are a some problems with pushing&lt;br/&gt;
predicates into the left side of a not exists join:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the condition would probably have to be negated, otherwise you&apos;ll&lt;br/&gt;
    end up with just the uninteresting rows from the left side (those&lt;br/&gt;
    rows that have a match in the right result set and should&lt;br/&gt;
    therefore be filtered out of the join result).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;even if the join condition is negated negated before it is pushed,&lt;br/&gt;
    I think you&apos;ll still need to keep the original join condition and&lt;br/&gt;
    apply it on the right side of the join (or perhaps change the not&lt;br/&gt;
    exists join to an exists join). If we remove the original join&lt;br/&gt;
    condition, all the rows returned from the left side will have a&lt;br/&gt;
    match in the right side result, and they will be removed from the&lt;br/&gt;
    result when they should have been kept&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if the right side of the join happens to be empty, all the rows&lt;br/&gt;
    from the left side should be returned, so in that case the pushed&lt;br/&gt;
    predicate shouldn&apos;t be used to restrict the left side&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The condition is not negated before it is pushed, though, so the left&lt;br/&gt;
side of the join will give you all the rows you are not interested&lt;br/&gt;
in. The result of the join will be empty if the right side is not&lt;br/&gt;
empty, and it might miss some rows if the right side is empty.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;p&gt;CREATE TABLE T1 (X INT NOT NULL);&lt;br/&gt;
INSERT INTO T1 VALUES (1),(2),(3);&lt;/p&gt;

&lt;p&gt;These queries are expected to return 3 rows, but they return 0 rows:&lt;/p&gt;

&lt;p&gt;SELECT * FROM T1 WHERE X &amp;lt; ALL (SELECT 100 FROM T1);&lt;br/&gt;
SELECT * FROM T1 WHERE NOT X &amp;gt; ANY (SELECT 100 FROM T1);&lt;/p&gt;

&lt;p&gt;(They reason why they return 0 rows is that the join condition&lt;br/&gt;
(X&amp;gt;=100) is pushed to the left side of the not exists join, so that no&lt;br/&gt;
rows are returned from the left side.)&lt;/p&gt;

&lt;p&gt;This query is expected to return 3 rows, but it returns 1 row:&lt;/p&gt;

&lt;p&gt;SELECT * FROM T1 WHERE X &amp;lt; ALL (SELECT 3 FROM T1 WHERE X = 100);&lt;/p&gt;

&lt;p&gt;(Similarly here, the join condition (X&amp;gt;=3) is pushed to the left side&lt;br/&gt;
without being negated. This condition happens to match one row, and it&lt;br/&gt;
is returned because the right side of the join is empty. Since the ALL&lt;br/&gt;
subquery is empty, all three rows should have been returned.)&lt;/p&gt;</comment>
                            <comment id="12688716" author="knutanders" created="Tue, 24 Mar 2009 15:30:06 +0000"  >&lt;p&gt;This problem can also be seen if we use a NOT EXISTS subquery&lt;br/&gt;
directly:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t(x int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t values (1),(2),(3);&lt;br/&gt;
3 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t t1 where not exists (select * from t t2 where t1.x &amp;gt; 100);&lt;br/&gt;
X          &lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;/p&gt;

&lt;p&gt;The query above should have returned all three rows since the subquery&lt;br/&gt;
is always empty and therefore NOT EXISTS (...) should always evaluate&lt;br/&gt;
to true.&lt;/p&gt;</comment>
                            <comment id="12689894" author="knutanders" created="Fri, 27 Mar 2009 13:38:26 +0000"  >&lt;p&gt;Same problem exists for NOT IN queries when both sides are not nullable (they get rewritten to NOT EXISTS in that case).&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t(x int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t values 1,2,3;&lt;br/&gt;
3 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t where x not in (select x from t where 1&amp;lt;&amp;gt;1); &amp;#8211; ok, not rewritten because x is nullable&lt;br/&gt;
X          &lt;br/&gt;
-----------&lt;br/&gt;
1          &lt;br/&gt;
2          &lt;br/&gt;
3          &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;br/&gt;
ij&amp;gt; alter table t alter column x not null;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t where x not in (select x from t where 1&amp;lt;&amp;gt;1); &amp;#8211; wrong result, query rewritten to NOT EXISTS because x is not nullable&lt;br/&gt;
X          &lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;/p&gt;</comment>
                            <comment id="12689909" author="knutanders" created="Fri, 27 Mar 2009 14:20:36 +0000"  >&lt;p&gt;I&apos;m beginning to think that we should stop flattening NOT EXISTS (and ALL and NOT IN queries that are rewritten to NOT EXISTS), at least in some of the cases. In general, it it not safe to flatten a NOT EXISTS join because the join predicate should have the opposite effect on the left side and the right side of the join, and also because it should not in any case filter out rows on the left side if the right side happens to be empty.&lt;/p&gt;

&lt;p&gt;The only case where I believe that it is safe to flatten a NOT EXISTS join, is when the join predicate does not have any effect on the left side. (Does not have any effect on the left side does not mean that all predicates that don&apos;t reference the table on the left side are OK, since a predicate that always evaluates to false, like 1&amp;lt;&amp;gt;1, would still have an effect on the left side of the join.) It might be possible to detect this condition in SubqueryNode.preprocess() when we set the flattenableNotExists flag, which is where we decide whether or not the query should be flattened.&lt;/p&gt;

&lt;p&gt;It looks like flattening of NOT EXISTS, ALL and NOT IN was added in Beetle 5173, and there are some test cases in lang/subqueryFlattening.sql that check that the queries actually are flattened, so I guess we should try to continue flattening the queries that are safe to flatten.&lt;/p&gt;</comment>
                            <comment id="12698231" author="bryanpendleton" created="Sun, 12 Apr 2009 17:12:05 +0100"  >&lt;p&gt;+1 to the suggestion to cease flattening NOT EXISTS, although if you think you can tell&lt;br/&gt;
the difference between queries that are safe to flatten, and those that aren&apos;t, that would be fine too. &lt;/p&gt;

&lt;p&gt;What are the example queries in subqueryFlattening that involve flattening of NOT EXISTS?&lt;/p&gt;</comment>
                            <comment id="12698772" author="knutanders" created="Tue, 14 Apr 2009 14:36:00 +0100"  >&lt;p&gt;I had another look at the code, and I think I&apos;ve found a way to&lt;br/&gt;
distinguish between safe and unsafe queries. See the attached patch&lt;br/&gt;
(which lacks comments and test cases, and is not ready for commit).&lt;/p&gt;

&lt;p&gt;lang/subqueryFlattening.sql runs cleanly with the patch, so all the&lt;br/&gt;
queries that the test expected to be flattened are still flattened.&lt;/p&gt;

&lt;p&gt;There are three essential changes in the patch:&lt;/p&gt;

&lt;p&gt;1) ProjectRestrictNode.pullOptPredicates()&lt;/p&gt;

&lt;p&gt;Don&apos;t pull any predicates if the from table is marked as a not exists&lt;br/&gt;
table. This way the flattening of queries like the ones below will&lt;br/&gt;
work, because the predicate 1&amp;lt;&amp;gt;1 is not pulled out and applied on the&lt;br/&gt;
outer table.&lt;/p&gt;

&lt;p&gt;  SELECT * FROM T WHERE NOT EXISTS (SELECT * FROM T WHERE 1&amp;lt;&amp;gt;1)&lt;br/&gt;
  SELECT * FROM T WHERE X &amp;lt; ALL (SELECT X FROM T WHERE 1&amp;lt;&amp;gt;1)&lt;br/&gt;
  SELECT * FROM T WHERE X NOT IN (SELECT X FROM T WHERE 1&amp;lt;&amp;gt;1)&lt;/p&gt;

&lt;p&gt;2) SubqueryNode.preprocess()&lt;/p&gt;

&lt;p&gt;Don&apos;t allow not exists flattening unless all the predicates in the&lt;br/&gt;
subquery reference the base table of the inner query. When all the&lt;br/&gt;
predicates reference that table, none of them will be used in the&lt;br/&gt;
outer query, so they won&apos;t cause any trouble for the flattening. This&lt;br/&gt;
makes queries like the one below work:&lt;/p&gt;

&lt;p&gt;  SELECT * FROM T T1 WHERE NOT EXISTS (SELECT * FROM T T2 WHERE T1.X &amp;gt; 100)&lt;/p&gt;

&lt;p&gt;No flattening will happen in this case, though.&lt;/p&gt;

&lt;p&gt;Although it may sound like (2) would prevent the example queries in&lt;br/&gt;
(1) from being flattened, that&apos;s not the case. This is because simple&lt;br/&gt;
predicates like 1&amp;lt;&amp;gt;1 are pushed down before SubqueryNode.preprocess()&lt;br/&gt;
gets to the flattening, so it doesn&apos;t see those predicates. The&lt;br/&gt;
flattening is still safe, since we have made sure that those&lt;br/&gt;
predicates won&apos;t be pulled out again.&lt;/p&gt;

&lt;p&gt;3) SubqueryNode.preprocess()&lt;/p&gt;

&lt;p&gt;If an ALL subquery or a NOT IN subquery is flattened, a new join&lt;br/&gt;
condition is created, for instance&lt;/p&gt;

&lt;p&gt;   WHERE X &amp;lt; ALL (SELECT Y ...) results in the join condition X &amp;gt;= Y&lt;br/&gt;
and&lt;br/&gt;
   WHERE X NOT IN (SELECT Y ...) results in the join condition X = Y&lt;/p&gt;

&lt;p&gt;The patch adds a check so that the flattening only happens if the&lt;br/&gt;
right side of the join condition references the base table of the&lt;br/&gt;
subquery. If it does, we know that the join condition cannot be used&lt;br/&gt;
to filter rows from the outer table, so it&apos;s safe to do the&lt;br/&gt;
flattening. This prevents queries like the ones below from being&lt;br/&gt;
flattened, and they now work as expected:&lt;/p&gt;

&lt;p&gt;  SELECT * FROM T WHERE X &amp;lt; ALL (SELECT 100 FROM T)&lt;br/&gt;
  SELECT * FROM T T1 WHERE X = ALL (SELECT T1.X FROM T)&lt;br/&gt;
  SELECT * FROM T WHERE X NOT IN (SELECT 100 FROM T)&lt;br/&gt;
  SELECT * FROM T T1 WHERE X NOT IN (SELECT T1.X+100 FROM T)&lt;/p&gt;</comment>
                            <comment id="12698776" author="knutanders" created="Tue, 14 Apr 2009 14:51:41 +0100"  >&lt;p&gt;Bryan asked which NOT EXISTS queries lang/subqueryFlattening.sql&lt;br/&gt;
expected to be flattened. Here are the ones I found (some of them are&lt;br/&gt;
executed multiple times with different nullability constraints).&lt;/p&gt;

&lt;p&gt;NOT EXISTS (flattened to NOT EXISTS JOIN):&lt;/p&gt;

&lt;p&gt;  SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM&lt;br/&gt;
  ( SELECT ID FROM DOCS WHERE&lt;br/&gt;
          ( NOT EXISTS  (SELECT ID FROM COLLS WHERE DOCS.ID = COLLS.ID&lt;br/&gt;
  AND COLLID IN (-2,1) ) )&lt;br/&gt;
  ) AS TAB;&lt;/p&gt;

&lt;p&gt;  select * from t1 where not exists (select * from t2 where&lt;br/&gt;
  t1.c1=t2.c1);&lt;/p&gt;

&lt;p&gt;NOT IN (flattened to NOT EXISTS JOIN):&lt;/p&gt;

&lt;p&gt;  SELECT COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; FROM&lt;br/&gt;
  ( SELECT ID FROM DOCS WHERE&lt;br/&gt;
          ( ID NOT IN (SELECT ID FROM COLLS WHERE COLLID IN (-2,1) ) )&lt;br/&gt;
  ) AS TAB;&lt;/p&gt;

&lt;p&gt;ALL (flattened to NOT EXISTS JOIN):&lt;/p&gt;

&lt;p&gt;  SELECT count(ID) FROM DOCS WHERE ID = ALL (SELECT ID FROM COLLS WHERE COLLID IN (-2,1) );&lt;br/&gt;
  SELECT count(ID) FROM DOCS WHERE ID &amp;lt; ALL (SELECT ID FROM COLLS WHERE COLLID IN (-2,1) );&lt;br/&gt;
  SELECT count(ID) FROM DOCS WHERE ID &amp;lt;&amp;gt; ALL (SELECT ID FROM COLLS WHERE COLLID IN (-2,1) );&lt;/p&gt;</comment>
                            <comment id="12699497" author="bryanpendleton" created="Thu, 16 Apr 2009 03:43:29 +0100"  >&lt;p&gt;Nice clear explanation of the behavior, and of the approach. Thanks much for putting this together!&lt;/p&gt;</comment>
                            <comment id="12700114" author="knutanders" created="Fri, 17 Apr 2009 11:17:49 +0100"  >&lt;p&gt;Attaching a patch - d4001-1a-test.diff - which adds a (not yet enabled) test for this bug. I&apos;ve written test cases for all the problematic cases I&apos;ve found. All the queries (except two which I included for completeness and marked with a comment) fail without the fixes suggested in an earlier comment. The test checks both that the correct rows are returned and whether or not the queries are flattened.&lt;/p&gt;

&lt;p&gt;Committed revision 765930.&lt;/p&gt;</comment>
                            <comment id="12701153" author="knutanders" created="Tue, 21 Apr 2009 14:30:45 +0100"  >&lt;p&gt;This patch (d4001-2a-code.diff) is the same as dontFlatten.diff, only that it adds comments and also enables SubqueryFlatteningTest as part of the regression test suite. Derbyall and suites.All ran cleanly with the dontFlatten.diff patch, but I&apos;m rerunning the tests now in case I accidentally changed something I didn&apos;t mean to change.&lt;/p&gt;</comment>
                            <comment id="12703527" author="knutanders" created="Tue, 28 Apr 2009 08:48:47 +0100"  >&lt;p&gt;Committed revision 769273.&lt;/p&gt;</comment>
                            <comment id="12703610" author="knutanders" created="Tue, 28 Apr 2009 12:43:51 +0100"  >&lt;p&gt;Merged to 10.5 and committed revision 769344.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12436312">DERBY-4385</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12405748" name="d4001-1a-test.diff" size="13343" author="knutanders" created="Fri, 17 Apr 2009 11:17:49 +0100"/>
                            <attachment id="12406030" name="d4001-2a-code.diff" size="11193" author="knutanders" created="Tue, 21 Apr 2009 14:30:44 +0100"/>
                            <attachment id="12405416" name="dontFlatten.diff" size="6627" author="knutanders" created="Tue, 14 Apr 2009 14:36:00 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 5 Jan 2009 10:13:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23965</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0l9b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37262</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>