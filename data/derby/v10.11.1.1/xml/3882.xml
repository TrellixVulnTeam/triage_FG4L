<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:48:09 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3882/DERBY-3882.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3882] Expensive cursor name lookup in network server</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3882</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I have sometimes seen in a profiler that an unreasonably high amount of the CPU time is spent in GenericLanguageConnectionContext.lookupCursorActivation() when the network server is running. That method is used to check that there is no active statement in the current transaction with the same cursor name as the statement currently being executed, and it is normally only used if the executing statement has a cursor name. None of the client-side statements had a cursor name when I saw this.&lt;/p&gt;

&lt;p&gt;The method is always called when the network server executes a statement because the network server assigns a cursor name to each statement even if no cursor name has been set on the client side. If the list of open statements is short, the method is relatively cheap. If one uses ClientConnectionPoolDataSource with the JDBC statement cache, the list of open statements can however be quite long, and lookupCursorActivation() needs to spend a fair amount of time iterating over the list and comparing strings.&lt;/p&gt;

&lt;p&gt;The time spent looking for duplicate names in lookupCursorActivation() is actually wasted time when it is called from the network server, since the network server assigns unique names to the statements it executes, even when there are duplicate names on the client. It would be good if we could reduce the cost of this operation, or perhaps eliminate it completely when the client doesn&apos;t use cursor names.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12405174">DERBY-3882</key>
            <summary>Expensive cursor name lookup in network server</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Thu, 25 Sep 2008 21:08:37 +0100</created>
                <updated>Fri, 25 Sep 2009 11:09:27 +0100</updated>
                            <resolved>Fri, 25 Sep 2009 11:09:27 +0100</resolved>
                                    <version>10.4.2.0</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>Network Server</component>
                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12634598" author="knutanders" created="Thu, 25 Sep 2008 21:24:57 +0100"  >&lt;p&gt;The network server always sets the cursor name since it doesn&apos;t know if the client has set a cursor name or not. If we had a way in DRDA to tell the server that the client has called Statement.setCursorName(), the server didn&apos;t have to set the cursor name in the normal case, and the lookup method wouldn&apos;t be called. I haven&apos;t found any way to set the cursor name in the DRDA spec, but we always have the possibility to define a product-specific code point. Such a solution could also help us getting rid of the where-current-of rewrite in the client driver, which causes bugs like &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1433&quot; title=&quot;Client driver does not handle string literals containing &amp;quot;where current of&amp;quot; correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1433&quot;&gt;DERBY-1433&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12634607" author="knutanders" created="Thu, 25 Sep 2008 21:41:52 +0100"  >&lt;p&gt;A simple hack that seems to reduce the cost of lookupCursorActivation() to some degree, is to compare the hash codes of the cursor names before we compare the full strings. That is, change &quot;if (cursorName.equals(executingCursorName))&quot; to &quot;if (cursorName.hashCode() == executingCursorName.hashCode() &amp;amp;&amp;amp; cursorName.equals(executingCursorName))&quot;. The reason why this is cheaper, is that most implementations of the String.hashCode() cache the hash value, so after the warmup it is not necessary to read the contents of the strings, and we only call String.equals() if there is a name collision.&lt;/p&gt;</comment>
                            <comment id="12634916" author="dagw" created="Fri, 26 Sep 2008 17:18:53 +0100"  >&lt;p&gt;&amp;gt; I haven&apos;t found any way to set the cursor name in the DRDA spec, but&lt;br/&gt;
&amp;gt; we always have the possibility to define a product-specific code&lt;br/&gt;
&amp;gt; point. Such a solution could also help us getting rid of the&lt;br/&gt;
&amp;gt; where-current-of rewrite in the client driver, which causes bugs like&lt;br/&gt;
&amp;gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1433&quot; title=&quot;Client driver does not handle string literals containing &amp;quot;where current of&amp;quot; correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1433&quot;&gt;DERBY-1433&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This seems a good way to evolve this. It seems better to improve the&lt;br/&gt;
communication between the client and the server; this should help&lt;br/&gt;
reduce the need for special hacks on the client. On the downside, the&lt;br/&gt;
client would still need to handle older servers for a while, so it could take&lt;br/&gt;
some time to get rid of the old cruft.&lt;/p&gt;</comment>
                            <comment id="12758175" author="knutanders" created="Tue, 22 Sep 2009 09:49:19 +0100"  >&lt;p&gt;Here&apos;s a patch which implements the simple approach using String.hashCode(). I&lt;br/&gt;
suggest that we go for that approach for now since changing the protocol would&lt;br/&gt;
be a bigger task and riskier. It seems to be sufficient in order to get the&lt;br/&gt;
method off the profiler&apos;s list of big CPU consumers in my environment, and we&lt;br/&gt;
can always revisit the issue and change the network protocol later if someone&lt;br/&gt;
has a load where the simple fix is not sufficient.&lt;/p&gt;

&lt;p&gt;The patch makes GenericLanguageConnectionContext.lookupCursorActivation() check&lt;br/&gt;
the hash codes of the two strings before calling String.equals(), and it skips&lt;br/&gt;
equals() if the hash codes are different, as strings with different hash codes&lt;br/&gt;
are never equal. This exploits the fact that the most common implementations of&lt;br/&gt;
java.lang.String cache the hash code, so that computing and comparing the hash&lt;br/&gt;
codes will be reduced to a simple comparison of two integer fields after&lt;br/&gt;
warm-up.&lt;/p&gt;

&lt;p&gt;I&apos;ve also attached a small test class (Cursor.java) to show the effect of the&lt;br/&gt;
patch. It repeatedly executes &quot;VALUES 1&quot; in an embedded connection with 50 open&lt;br/&gt;
statements, and each statement has a cursor name. &quot;VALUES 1&quot; is executed 2&lt;br/&gt;
million times for warm-up and then 2 million times again with the time being&lt;br/&gt;
recorded. Running the test 10 times with trunk and 10 times with the patch (on&lt;br/&gt;
OpenSolaris, Java version 1.6.0_15), it needed on average ~30% shorter time to&lt;br/&gt;
complete with the patched version. Average/min/max time in seconds for the runs&lt;br/&gt;
is shown below.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select name, avg(tps) &quot;AVG&quot;, min(tps) &quot;MIN&quot;, max(tps) &quot;MAX&quot; from results group by name;&lt;br/&gt;
NAME    |AVG          |MIN          |MAX          &lt;br/&gt;
--------------------------------------------------&lt;br/&gt;
d3882   |9.0245       |8.515        |9.867        &lt;br/&gt;
trunk   |12.968401    |11.732       |14.372       &lt;/p&gt;

&lt;p&gt;2 rows selected&lt;/p&gt;

&lt;p&gt;All the regression tests ran cleanly with the patch.&lt;/p&gt;</comment>
                            <comment id="12758253" author="bryanpendleton" created="Tue, 22 Sep 2009 15:12:40 +0100"  >&lt;p&gt;&amp;gt; it needed on average ~30% shorter time&lt;/p&gt;

&lt;p&gt;Wow!&lt;/p&gt;

&lt;p&gt;Is this because this particular benchmark has many open named statements&lt;br/&gt;
for the connection? I guess that if the connection has 50 open named statements,&lt;br/&gt;
we call String.equals on average 25 times to find the one we want? Does this&lt;br/&gt;
indicate that we ought to have a hash table here rather than a sequential lookup?&lt;/p&gt;

&lt;p&gt;I&apos;m a bit surprised that String.equals doesn&apos;t itself make this optimization. Is this&lt;br/&gt;
worth raising with the JDK itself?&lt;/p&gt;

&lt;p&gt;Your optimization seems reasonable to me, though clearly we don&apos;t want to&lt;br/&gt;
go through this complexity for &lt;b&gt;every&lt;/b&gt; call to String.equals, just the ones where&lt;br/&gt;
the performance win justifies it.&lt;/p&gt;</comment>
                            <comment id="12758705" author="knutanders" created="Wed, 23 Sep 2009 14:49:33 +0100"  >&lt;p&gt;I think the reason why it&apos;s not used as a general optimization technique for String.equals() is that there are some conditions that must be satisfied before it actually is an optimization:&lt;/p&gt;

&lt;p&gt;1) The same String objects must be compared multiple times, otherwise the cost of calculating the hash codes will be too high compared to the benefit.&lt;/p&gt;

&lt;p&gt;2) There&apos;s nothing to gain by comparing the hash codes if the Strings are equal, so it only speeds up the comparisons where we expect a high number of mismatches.&lt;/p&gt;

&lt;p&gt;3) String.equals() is very fast if the strings have different lengths or if the strings differ in one of the first characters, so the optimization has the best effect when comparing strings of the same length with a common prefix.&lt;/p&gt;

&lt;p&gt;The cursor names generated by the network client satisfy all of these conditions. They are on the form SQL_CURLH000C + serial#, which means they are not equal, have a common prefix, and are likely to have the same length. Also, the names are stored in the activation on the server, so they&apos;ll be reused and benefit from the caching of the hash code.&lt;/p&gt;

&lt;p&gt;Another reason is, as you mentioned, that a hash table is normally used for such lookups. A hash table could be used in this case as well, but there are some complicating issues that may make it too complex to justify it:&lt;/p&gt;

&lt;p&gt;a) The cursor names are not unique within a connection (open cursors cannot have the same name, but open statements can share the same name as long as they don&apos;t have open cursors at the same time). This means that one key (cursor name) can map to many values, so some sort of multi-map must be implemented. In the normal embedded case with no cursor name, all activations will be located in the same bucket (key=null).&lt;/p&gt;

&lt;p&gt;b) A statement can change its cursor name any time. Currently, this is done by simply changing the cursorName field in the activation. If we store the activation list in a hash table, changing the cursor name means that we also need to move the activation from one bucket to another.&lt;/p&gt;

&lt;p&gt;c) There&apos;s some code to reclaim memory if the activation list has been big and later shrinks. I&apos;d imagine that this code would be somewhat more complex too if the list is transformed into a multi-map.&lt;/p&gt;

&lt;p&gt;That said, I&apos;m all for replacing the list with a data structure that&apos;s more suited for effective lookups. I&apos;d suggest that we go for the current patch proposal for now, since it looks simple and rather harmless, and then revisit the issue and try to come up with a more efficient data structure if this optimization turns out to be insufficient.&lt;/p&gt;</comment>
                            <comment id="12758770" author="bryanpendleton" created="Wed, 23 Sep 2009 17:48:37 +0100"  >&lt;p&gt;Thanks very much for the thorough and clear explanation; it is quite helpful to understand&lt;br/&gt;
why this optimization works in this case.&lt;/p&gt;

&lt;p&gt;I agree that we should proceed with the current proposal.&lt;/p&gt;</comment>
                            <comment id="12759472" author="knutanders" created="Fri, 25 Sep 2009 11:09:27 +0100"  >&lt;p&gt;Committed revision 818807.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12420266" name="Cursors.java" size="1069" author="knutanders" created="Tue, 22 Sep 2009 09:49:19 +0100"/>
                            <attachment id="12420265" name="check_hash.diff" size="1747" author="knutanders" created="Tue, 22 Sep 2009 09:49:19 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 26 Sep 2008 16:18:53 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31040</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0rr3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38314</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>