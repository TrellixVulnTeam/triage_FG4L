<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:32:07 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3064/DERBY-3064.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3064] Implement the LogShipper that will enable the shipping of Log records from the master to the slave</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3064</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description></description>
                <environment></environment>
        <key id="12377881">DERBY-3064</key>
            <summary>Implement the LogShipper that will enable the shipping of Log records from the master to the slave</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12373499">DERBY-2922</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="narayanan">V.Narayanan</assignee>
                                    <reporter username="narayanan">V.Narayanan</reporter>
                        <labels>
                    </labels>
                <created>Mon, 10 Sep 2007 11:38:31 +0100</created>
                <updated>Fri, 21 Jan 2011 18:17:07 +0000</updated>
                            <resolved>Thu, 3 Jan 2008 09:21:32 +0000</resolved>
                                                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>Miscellaneous</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12526121" author="narayanan" created="Mon, 10 Sep 2007 11:43:02 +0100"  >&lt;p&gt;The Log shipper will be in charge of shipping the Log Record&lt;br/&gt;
chunks from the master to the slave. The shipping needs to&lt;br/&gt;
happen Asynchronously as well as in a forced manner. An example&lt;br/&gt;
of a situation where the forced shipping would be needed would&lt;br/&gt;
be when the Log buffer becomes full and it needs to be emptied&lt;br/&gt;
to enable addition of further log records.&lt;/p&gt;</comment>
                            <comment id="12526129" author="narayanan" created="Mon, 10 Sep 2007 12:25:44 +0100"  >&lt;p&gt;This patch contains a preliminary implementation of the LogShipper.&lt;br/&gt;
The patch depends on the Network code (Derby-2921) and can be considered &lt;br/&gt;
for a commit only after the Network code is accepted.&lt;/p&gt;

&lt;p&gt;Please find below a File by File explanation of the LogShipper code&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication/master/ReplicationAsynchronousLogShipper.java&lt;/p&gt;

&lt;p&gt;This class creates a DaemonService that periodically sends the log record chunks to&lt;br/&gt;
the slave. Since it uses the DaemonService by subcribing to it the interval at which&lt;br/&gt;
the LogChunks are sent depends on the DaemonService.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/impl/services/replication/master/ReplicationForcedLogShipper.java&lt;/p&gt;

&lt;p&gt;This class allows you to send a chunk of log from the buffer thus freeing up&lt;br/&gt;
the buffer. The ReplicationFOrcedLogShipper and the ReplicationAsynchronousLogShipper&lt;br/&gt;
are synchronized on the LogBuffer.&lt;/p&gt;

&lt;p&gt;A      java/engine/org/apache/derby/iapi/services/replication/master/ReplicationLogShippingFactory.java&lt;/p&gt;

&lt;p&gt;This is the common interface to the ReplicationForcedLogShipper that will allow the code to&lt;br/&gt;
request the freeing of the Log buffer and enable a Log chunk transfer.&lt;/p&gt;</comment>
                            <comment id="12526154" author="jorgenlo" created="Mon, 10 Sep 2007 13:36:46 +0100"  >&lt;p&gt;Thank you for addressing this issue, Narayanan. &lt;/p&gt;

&lt;p&gt;I had a look at the preliminary patch and have some questions.&lt;/p&gt;


&lt;p&gt;1. I think &quot;Factory&quot; is used for object creation in cases where the object creation work is hidden from the caller. This is the case for bootable services since the boot method does this masking. In the log shipping case, however, I don&apos;t think &quot;Factory&quot; is a good name. Maybe you could just call the interface (Replication)LogShipper?&lt;/p&gt;

&lt;p&gt;2. The package names are very long. Since the package already contains &quot;replication.master&quot;, maybe we could shave off some characters in the class names? &quot;Replication&quot; could, e.g., be removed. Just a thought.&lt;/p&gt;

&lt;p&gt;3. Since you already have commented the variables, I think you should add another * (/* -&amp;gt; /**) so that the comments become javadoc&lt;/p&gt;

&lt;p&gt;4. I think the Daemon should be created by the MasterController since that class will be managing everything on the master side&lt;/p&gt;

&lt;p&gt;5. AsynchLogShipper does not need to know about the transmitter since Forced... does the log shipping. The same goes for the log buffer.&lt;/p&gt;

&lt;p&gt;6. How do you intend to create the log shipping service? I see that Forced... implements the interface, but that the creator of Asynch... creates a Forced... object. In MasterController, we would want to create an instance of the interface. Maybe Asynch could extend Forced? Again, just a thought. With that design, all replication strategy specific methods like Forced#flushedInstance could be made abstract, and adding other replication strategies (like 2-safe) later would be really simple.&lt;/p&gt;

&lt;p&gt;7. The javadoc for forceFlush is not describing the behavior of the method&lt;/p&gt;

&lt;p&gt;8. I am concerned about the eternal loop in performWork. I guess this will be way too active, especially in low workload cases. Also, control should be returned from the performWork method. It should be up to the DaemonService to determine when it wants to ship log. A slight improvement could be to let shipALogChunk returned the boolean return from LogBuffer#next, and change performWork to look something like this:&lt;/p&gt;

&lt;p&gt;performWork() {&lt;br/&gt;
   boolean sentSomething = true;&lt;br/&gt;
   while (sentSomething) &lt;/p&gt;
{
      sentSomething = forcedLogShipper.shipALogChunk();
   }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;or even&lt;/p&gt;

&lt;p&gt;performWork() {&lt;br/&gt;
   if (currentTimeMillis &amp;gt;= (timeOfLastLogShipment + shipmentWaitTime) {&lt;br/&gt;
      boolean sentSomething = true;&lt;br/&gt;
      while (sentSomething) &lt;/p&gt;
{
         sentSomething = forcedLogShipper.shipALogChunk();
      }
&lt;p&gt;   }&lt;br/&gt;
}&lt;/p&gt;
</comment>
                            <comment id="12529772" author="narayanan" created="Mon, 24 Sep 2007 02:23:53 +0100"  >&lt;p&gt;In keeping with the design diagrams introduced in Derby-2872 I have modified the&lt;br/&gt;
LogShipper design. Pls find below a basic description of the changes that will be&lt;br/&gt;
introduced in this issue.&lt;/p&gt;

&lt;p&gt;LogShipper Design&lt;br/&gt;
-----------------&lt;/p&gt;

&lt;p&gt;As part of this work the following changes are required&lt;/p&gt;

&lt;p&gt;The AsynchronousLogShipper that enables periodic and force flushing of the Log Buffer&lt;br/&gt;
is needed. &lt;/p&gt;

&lt;p&gt;The MasterController is modified to start up the LogShipping module&lt;br/&gt;
and to call a flush on the buffer when the LogBufferFullException is thrown.&lt;/p&gt;

&lt;p&gt;AsynchronousLogShipper&lt;br/&gt;
----------------------&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Handles periodic shipping of log chunks from the log buffer to the&lt;br/&gt;
  slave&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Allows for force flushing of the log Buffer by the MasterController&lt;br/&gt;
  when the MasterController gets a LogBufferFullException from the&lt;br/&gt;
  LogBuffer.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Design of the class&lt;br/&gt;
-------------------&lt;/p&gt;

&lt;p&gt;Implements interfaces - Serviceable, LogShipper&lt;/p&gt;

&lt;p&gt;Constructor&lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;Accepts the ReplicationLogBuffer, shippingDaemon and the transmitInterval.&lt;/p&gt;

&lt;p&gt;Subscribes to the ShippingDaemon.&lt;/p&gt;


&lt;p&gt;Methods&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;shipALogChunk&lt;br/&gt;
-------------&lt;/p&gt;

&lt;p&gt;Checks to see if a log record chunk is available in the logBuffer for transmission&lt;/p&gt;

&lt;p&gt;If yes removes this log record chunk and transmits it to the slave.&lt;/p&gt;

&lt;p&gt;updates the lastTransmitTime to reflect the current time at which the transmit was done.&lt;/p&gt;


&lt;p&gt;flushedInstance&lt;br/&gt;
---------------&lt;/p&gt;

&lt;p&gt;LogShipper interface method.&lt;/p&gt;

&lt;p&gt;Used to update the latest instance of the log record that has been flushed to the disk.&lt;/p&gt;

&lt;p&gt;This method will not have any implementation.&lt;/p&gt;

&lt;p&gt;forceFlush&lt;br/&gt;
----------&lt;/p&gt;

&lt;p&gt;Forces a chunk of the log record from the log buffer to be sent to the&lt;br/&gt;
slave, freeing space in the log buffer.&lt;/p&gt;

&lt;p&gt;calls shipALogChunk to ship the log chunk from the buffer.&lt;/p&gt;

&lt;p&gt;serviceASAP&lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;Serviceable interface method. Returns false.&lt;/p&gt;

&lt;p&gt;serviceImmediately&lt;br/&gt;
------------------&lt;/p&gt;

&lt;p&gt;Serviceable interface method. Returns false.&lt;/p&gt;

&lt;p&gt;performWork&lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;Gets the current time and subtracts the lastTransmitTime from it to get the time interval&lt;br/&gt;
between transmissions.&lt;/p&gt;

&lt;p&gt;Checks to see if the time interval calculate above is greater than or equal to the&lt;br/&gt;
transmitInterval. If yes calls shipALogChunk. If no the method returns without doing anything.&lt;/p&gt;


&lt;p&gt;Changes to the MasterController class&lt;br/&gt;
-------------------------------------&lt;/p&gt;

&lt;p&gt;startMaster&lt;br/&gt;
-----------&lt;/p&gt;

&lt;p&gt;The LogShipper is initialized here.&lt;/p&gt;

&lt;p&gt;appendLogRecord&lt;br/&gt;
---------------&lt;/p&gt;

&lt;p&gt;when a LogBufferFullException is thrown we call&lt;br/&gt;
AsynchronousLogShipper.forceFlush&lt;/p&gt;</comment>
                            <comment id="12529808" author="oysteing" created="Mon, 24 Sep 2007 10:06:32 +0100"  >&lt;p&gt;Thanks for the desgin overview, Narayanan.  I have a few questions&lt;br/&gt;
around the scheduling of the shipping:&lt;/p&gt;

&lt;p&gt;1. If I understand you correctly, log records will be shipped either&lt;br/&gt;
   when the log buffer is full or when a timeout occur. If the traffic&lt;br/&gt;
   is high so that the time it takes to fill the log buffer is&lt;br/&gt;
   normally less than the timeout, this means that log will only be&lt;br/&gt;
   sent when the log buffer is full.  Would it not be better to try to&lt;br/&gt;
   keep the log shipping ahead so that it never goes full?&lt;/p&gt;

&lt;p&gt;2. It seems like you suggest that the shipping thread will continously&lt;br/&gt;
   check to see whether the timeout has expired.  Generally, such&lt;br/&gt;
   busy-waits should be avoided.  I think you should introduce a timer&lt;br/&gt;
   or something so that the thread can be suspended until it is time&lt;br/&gt;
   to ship log records.&lt;/p&gt;

&lt;p&gt;3. You mention a ShippingDeamon, but it is not described what it is or&lt;br/&gt;
   how it works. Is this a new thread that you will introduce or will&lt;br/&gt;
   the LogShipper be run in the existing background thread?&lt;/p&gt;
</comment>
                            <comment id="12529813" author="narayanan" created="Mon, 24 Sep 2007 10:31:16 +0100"  >&lt;p&gt;&amp;gt;1. If I understand you correctly, log records will be shipped either&lt;br/&gt;
&amp;gt;   when the log buffer is full or when a timeout occur. If the traffic&lt;br/&gt;
&amp;gt;   is high so that the time it takes to fill the log buffer is&lt;br/&gt;
&amp;gt;   normally less than the timeout, this means that log will only be&lt;br/&gt;
&amp;gt;   sent when the log buffer is full. Would it not be better to try to&lt;br/&gt;
&amp;gt;   keep the log shipping ahead so that it never goes full?&lt;/p&gt;

&lt;p&gt;What we can do is we start with a default value for transmit interval.&lt;br/&gt;
For theory sake let us assume it is 3 seconds.&lt;/p&gt;

&lt;p&gt;Suppose the condition stated on your comments arise, we maintain a counter&lt;br/&gt;
that keeps track of the number of times force flush is called, if this counter&lt;br/&gt;
value exceeds a certain value we can replace the transmit interval with&lt;br/&gt;
the last transmit interval we obtained.&lt;/p&gt;

&lt;p&gt;Thus this would automatically take care of the case of heavy load.&lt;/p&gt;

&lt;p&gt;A similar check should run in performWork to take care of high load.&lt;/p&gt;

&lt;p&gt;Both these counters should be reset when the other method is called.&lt;/p&gt;

&lt;p&gt;The counter for forceFlush is reset when performWork is called and vice-versa.&lt;/p&gt;

&lt;p&gt;I however do not want to do this in the first version of the patch for this issue. &lt;br/&gt;
I will submit the first version assuming a static time interval, keep this issue&lt;br/&gt;
open and change it in the next version if this is OK with the community.&lt;/p&gt;

&lt;p&gt;I feel this will put in the essential features first and the improvements later.&lt;/p&gt;

&lt;p&gt;&amp;gt;2. It seems like you suggest that the shipping thread will continously&lt;br/&gt;
&amp;gt;   check to see whether the timeout has expired. Generally, such&lt;br/&gt;
&amp;gt;   busy-waits should be avoided. I think you should introduce a timer&lt;br/&gt;
&amp;gt;   or something so that the thread can be suspended until it is time&lt;br/&gt;
&amp;gt;   to ship log records. &lt;/p&gt;

&lt;p&gt;I have introduced the time concept to overcome the limitation imposed by&lt;br/&gt;
DaemonFactory.&lt;/p&gt;

&lt;p&gt;The DaemonFactory would call performWork (i.e.) ship log records at its own&lt;br/&gt;
convinience. As i understand it we cannot configure DaemonFactory to transmit&lt;br/&gt;
at our mentioned time interval.&lt;/p&gt;

&lt;p&gt;So, When performWork is called entirely depends on how good DaemonFactory is feeling &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We do not want this to happen, because what if this is too soon for us or what if it&lt;br/&gt;
is too late.&lt;/p&gt;

&lt;p&gt;Hence we introduce a transmit interval variable that calculates the difference between the&lt;br/&gt;
last call and the current call of performWork or rather shipALogChunk(forceFlush also)&lt;/p&gt;

&lt;p&gt;&amp;gt;3. You mention a ShippingDeamon, but it is not described what it is or&lt;br/&gt;
&amp;gt;   how it works. Is this a new thread that you will introduce or will&lt;br/&gt;
&amp;gt;   the LogShipper be run in the existing background thread? &lt;/p&gt;

&lt;p&gt;Sorry about being ambiguous here. ShippingDaemon is Derby&apos;s DaemonService that is booted&lt;br/&gt;
up and is not a thread I introduce.&lt;/p&gt;</comment>
                            <comment id="12529815" author="narayanan" created="Mon, 24 Sep 2007 10:50:19 +0100"  >&lt;p&gt;&quot;I have introduced the time concept to overcome the limitation imposed by&lt;br/&gt;
DaemonFactory. &quot;&lt;/p&gt;

&lt;p&gt;Should have been DaemonService. We create the Daemon from the DaemonFactory.&lt;/p&gt;</comment>
                            <comment id="12529834" author="narayanan" created="Mon, 24 Sep 2007 11:57:16 +0100"  >&lt;p&gt;&amp;gt;If I understand you correctly, this time interval will only be helpful in the &quot;too soon&quot; case, not the &amp;gt;&quot;too late&quot; case.&lt;/p&gt;

&lt;p&gt;&amp;gt;When I wrote version 2 of the proof of concept patches (see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2872&quot; title=&quot;Add Replication functionality to Derby&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2872&quot;&gt;&lt;del&gt;DERBY-2872&lt;/del&gt;&lt;/a&gt;), I used a Daemon to &amp;gt;read log records at the slave side. I basically had:&lt;/p&gt;

&lt;p&gt;&amp;gt;performWork &lt;/p&gt;
{
&amp;gt;  if (messageWaitingForProcess) processMessage();
&amp;gt;}

&lt;p&gt;&amp;gt;The waiting interval between each time performWork was called was way too high for this usage &amp;gt;(in the order of 3-10 seconds). This interval is probably too high for the log shipper as well, so &amp;gt;my guess is that you&apos;ll need something similar to an eternal loop with a wait(millis) somewhere in &amp;gt;this package. &lt;/p&gt;

&lt;p&gt;Does this mean atleast in the case of log shipper we would be forced to use threading since the DaemonService interval cannot be varied?&lt;/p&gt;

&lt;p&gt;Guess I have a LogShipper specific answer for DaemonService vs Threads if I am right.&lt;/p&gt;</comment>
                            <comment id="12529838" author="jorgenlo" created="Mon, 24 Sep 2007 12:51:35 +0100"  >&lt;p&gt;&amp;gt; Does this mean atleast in the case of log shipper we would be forced to use threading since the DaemonService interval cannot be varied?&lt;/p&gt;

&lt;p&gt;In the general case, we should use DaemonService whenever possible to keep uniformity with existing Derby code. As far as I have seen, no Derby class implements Runnable... &lt;/p&gt;

&lt;p&gt;In this case, however, a separate &quot;homemade&quot; thread may be better since you&apos;ll have to use an eternal loop. The API of  DaemonService/Factory says that the performWork method should not take much time. Eternal loops hardly fit that description &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;Unless someone has a strong argument for not creating a thread (as opposed to using Derby&apos;s DaemonService), I think you should go for a normal Java thread in this particular case.&lt;/p&gt;</comment>
                            <comment id="12529842" author="oysteing" created="Mon, 24 Sep 2007 13:16:27 +0100"  >&lt;p&gt;V.Narayanan (JIRA) wrote:&lt;br/&gt;
&amp;gt; I however do not want to do this in the first version of the patch&lt;br/&gt;
&amp;gt; for this issue. I will submit the first version assuming a static&lt;br/&gt;
&amp;gt; time interval, keep this issue open and change it in the next&lt;br/&gt;
&amp;gt; version if this is OK with the community.&lt;/p&gt;

&lt;p&gt;Sounds good to me. A static, but configurable, timeout interval&lt;br/&gt;
should probably be good-enough for most cases.&lt;/p&gt;

&lt;p&gt;&amp;gt; The DaemonFactory would call performWork (i.e.) ship log records at its own&lt;br/&gt;
&amp;gt; convinience. As i understand it we cannot configure DaemonFactory to transmit&lt;br/&gt;
&amp;gt; at our mentioned time interval.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; So, When performWork is called entirely depends on how good&lt;br/&gt;
&amp;gt; DaemonFactory is feeling &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; We do not want this to happen, because what if this is too soon for&lt;br/&gt;
&amp;gt; us or what if it is too late.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Hence we introduce a transmit interval variable that calculates the&lt;br/&gt;
&amp;gt; difference between the last call and the current call of performWork&lt;br/&gt;
&amp;gt; or rather shipALogChunk(forceFlush also)&lt;/p&gt;

&lt;p&gt;My concern is that if the Daemon Service have very little else to do,&lt;br/&gt;
it will continously call LogShipper#performWork and use a lot of&lt;br/&gt;
unecessary CPU for checking the time.&lt;/p&gt;

&lt;p&gt;&amp;gt; Sorry about being ambiguous here. ShippingDaemon is Derby&apos;s&lt;br/&gt;
&amp;gt; DaemonService that is booted up and is not a thread I introduce.&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;Using a separate thread would probably give you more flexibility with&lt;br/&gt;
respect to how log shipping is scheduled.&lt;/p&gt;</comment>
                            <comment id="12530373" author="narayanan" created="Wed, 26 Sep 2007 07:41:55 +0100"  >&lt;p&gt;Thank you for the comments and guidance Oystein and Jorgen.&lt;/p&gt;

&lt;p&gt;Pls find a patch attached containing the preliminary implementation of the&lt;br/&gt;
log shipper.&lt;/p&gt;

&lt;p&gt;The patch keeps to the design posted earlier, however, the code that&lt;br/&gt;
invokes the log shipper from the MasterController is not present since&lt;br/&gt;
I thought that should be done as a seperate integration issue or atleast&lt;br/&gt;
as a follow-up patch in this issue.&lt;/p&gt;</comment>
                            <comment id="12530385" author="narayanan" created="Wed, 26 Sep 2007 09:34:38 +0100"  >&lt;p&gt;&amp;gt; Jorgen says&lt;br/&gt;
&amp;gt; In the general case, we should use DaemonService whenever possible to keep uniformity with &amp;gt;existing Derby code. As far as I have seen, no Derby class implements Runnable...   &lt;/p&gt;

&lt;p&gt;well, actually it is used in DRDAConnThread &lt;/p&gt;</comment>
                            <comment id="12530407" author="oysteing" created="Wed, 26 Sep 2007 11:19:14 +0100"  >&lt;p&gt;Thanks for the patch, Narayanan.  It looks good and is very well&lt;br/&gt;
documented.  Except for my first three issues, my comments are minor:&lt;/p&gt;

&lt;p&gt;1. I do not see the need for recording lastShippingTime. When a&lt;br/&gt;
   forceFlush is made, I do not think you would want to delay the next&lt;br/&gt;
   regular sending of log records since there will still be more log&lt;br/&gt;
   to send after the forceFlush has sent one chunk.  Rather, I think&lt;br/&gt;
   you would want to notify the log shipping thread that it is time&lt;br/&gt;
   for another send.  Hence, I suggest that you drop testing for time,&lt;br/&gt;
   and use wait() instead of sleep() so that it is possible to wake up&lt;br/&gt;
   the thread while it is waiting.&lt;/p&gt;

&lt;p&gt;2. It seems like shipALogChunk will send a message even if there is no&lt;br/&gt;
   log records to send.  Should not the sending also be part of the&lt;br/&gt;
   body of the if statement?&lt;/p&gt;

&lt;p&gt;3. I would think you need some way for the master controller to stop&lt;br/&gt;
   log shipping (e.g., when replication is stopped).  In other words,&lt;br/&gt;
   the LogShipper interface need a stop method, and the loop needs to&lt;br/&gt;
   test for whether it should stop.&lt;/p&gt;

&lt;p&gt;4. Why are exceptions from shipALogChunk handled differently by run()&lt;br/&gt;
   and forceFlush()?  Maybe you could let shipALogChunk handle the&lt;br/&gt;
   exceptions instead so you do not have to do it in two places?&lt;/p&gt;

&lt;p&gt;5. I suggest dropping &apos;Replication&apos; from the name of&lt;br/&gt;
   &apos;ReplicationAsynchronousLogShipper&apos;.  Would make it a bit shorter,&lt;br/&gt;
   and I think it is evident that we are talking about replication&lt;br/&gt;
   here.&lt;/p&gt;

&lt;p&gt;6. The constructor is declared to throw a StandardException and the&lt;br/&gt;
   javadoc says it may happen when you &apos;register to the shipping&lt;br/&gt;
   daemon&quot;.  Is this preparing for something that will be added later?&lt;/p&gt;

&lt;p&gt;7. In both files there is a typo in the javadoc for flushedInstance&lt;br/&gt;
   (&apos;latestInstanceFlishedToDisk&apos;).&lt;/p&gt;

&lt;p&gt;8. For ReplicationAsynchronousLogShipper#flushedInstance, I think you&lt;br/&gt;
   should include in the javadoc that calling it will have no effect.&lt;/p&gt;</comment>
                            <comment id="12530410" author="narayanan" created="Wed, 26 Sep 2007 11:35:30 +0100"  >&lt;p&gt;Thank you for the comments and the reviews oystein.&lt;/p&gt;

&lt;p&gt;&amp;gt;4. Why are exceptions from shipALogChunk handled differently by run()&lt;br/&gt;
&amp;gt;   and forceFlush()? Maybe you could let shipALogChunk handle the&lt;br/&gt;
&amp;gt;   exceptions instead so you do not have to do it in two places? &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;It is not possible to throw exceptions from the run method, hence I throw it as&lt;br/&gt;
   RuntimeExceptions.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;forceFlush is a method that might have a different implementation if in future&lt;br/&gt;
  we decide we are going to implement a more sophisticated LogShipper, but the&lt;br/&gt;
  basic interface should remain common. So the exception that is thrown should&lt;br/&gt;
  be the same irrespective of the implementation.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  So the best way of making the exceptions thrown in derby uniform is using the&lt;br/&gt;
  Derby StandardException&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I thought about handling the exceptions in shipALogChunk itself, but we need&lt;br/&gt;
   some way of informing the MasterController that the shipping has failed. We need&lt;br/&gt;
   the MasterController to be informed of the exception.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   Handling the exceptions inside shipALogChunk would muffle the exceptions inside&lt;br/&gt;
   this method.&lt;/p&gt;

&lt;p&gt;The above three considerations were what forced me to go in for the heterogeneity &lt;br/&gt;
in handling the exceptions between the two methods.&lt;/p&gt;</comment>
                            <comment id="12530420" author="oysteing" created="Wed, 26 Sep 2007 12:30:11 +0100"  >&lt;p&gt;V.Narayanan (JIRA) wrote:&lt;br/&gt;
&amp;gt;&amp;gt; 4. Why are exceptions from shipALogChunk handled differently by run()&lt;br/&gt;
&amp;gt;&amp;gt;   and forceFlush()? Maybe you could let shipALogChunk handle the&lt;br/&gt;
&amp;gt;&amp;gt;   exceptions instead so you do not have to do it in two places? &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * It is not possible to throw exceptions from the run method, hence&lt;br/&gt;
&amp;gt;   I throw it as RuntimeExceptions.&lt;/p&gt;

&lt;p&gt;AFAIK, throwing an unchecked exception from the run method, will just&lt;br/&gt;
cause the thread to stop, and the exception will not be seen by other&lt;br/&gt;
threads.  Hence, a thread should try to deal with its own exceptions,&lt;br/&gt;
and only throw unchecked exceptions if there is no way to recover from&lt;br/&gt;
the failure.  &lt;/p&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;&amp;gt; * I thought about handling the exceptions in shipALogChunk itself,&lt;br/&gt;
&amp;gt;   but we need some way of informing the MasterController that the&lt;br/&gt;
&amp;gt;   shipping has failed. We need the MasterController to be informed&lt;br/&gt;
&amp;gt;   of the exception.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   Handling the exceptions inside shipALogChunk would muffle the&lt;br/&gt;
&amp;gt;   exceptions inside this method.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The above three considerations were what forced me to go in for the&lt;br/&gt;
&amp;gt; heterogeneity in handling the exceptions between the two methods.&lt;/p&gt;

&lt;p&gt;I understand.  Makes sense.  &lt;/p&gt;

&lt;p&gt;Maybe there is a need for the MasterController to provide a method to&lt;br/&gt;
be called by the log shipping thread to inform it when errors occurs.&lt;/p&gt;</comment>
                            <comment id="12530434" author="narayanan" created="Wed, 26 Sep 2007 13:28:12 +0100"  >&lt;p&gt;Thank you for the comments Oystein&lt;/p&gt;

&lt;p&gt;&amp;gt;Maybe there is a need for the MasterController to provide a method to&lt;br/&gt;
&amp;gt;be called by the log shipping thread to inform it when errors occurs. &lt;/p&gt;

&lt;p&gt;This is a very good suggestion&lt;/p&gt;

&lt;p&gt;I plan to do the following for this.&lt;/p&gt;

&lt;p&gt;1) Introduce a method in MasterFactory called handleExceptions(Exception e)&lt;/p&gt;

&lt;p&gt;2) The implementation of handleExceptions in the MasterController will then &lt;br/&gt;
   run instanceof checks the exceptions obtained e.&lt;/p&gt;

&lt;p&gt;3) AsynchronousLogShipper constructor will be modified to accept the MasterFactory&lt;br/&gt;
   implementation(Master Controller).&lt;/p&gt;

&lt;p&gt;4) I will catch all exceptions in the LogShipper and call handleExceptions for&lt;br/&gt;
   all of them&lt;/p&gt;

&lt;p&gt;5) For now in the handleExceptions class I propose to throw all the exceptions&lt;br/&gt;
   obtained in StandardExceptions with appropriate SQLStates. More specific&lt;br/&gt;
   handling of the exceptions thrown can be handled later&lt;/p&gt;

&lt;p&gt;&amp;gt;1. I do not see the need for recording lastShippingTime. When a&lt;br/&gt;
&amp;gt;   forceFlush is made, I do not think you would want to delay the next&lt;br/&gt;
&amp;gt;   regular sending of log records since there will still be more log&lt;br/&gt;
&amp;gt;   to send after the forceFlush has sent one chunk. Rather, I think&lt;br/&gt;
&amp;gt;   you would want to notify the log shipping thread that it is time&lt;br/&gt;
&amp;gt;   for another send. Hence, I suggest that you drop testing for time,&lt;br/&gt;
&amp;gt;   and use wait() instead of sleep() so that it is possible to wake up&lt;br/&gt;
&amp;gt;   the thread while it is waiting. &lt;/p&gt;

&lt;p&gt;lastShippingTime can be very useful when you want to improve the LogShipper&lt;br/&gt;
to automatically adjust shipping interval.&lt;/p&gt;

&lt;p&gt;lastShippingTime - current time will give the time interval at which the&lt;br/&gt;
forceFlush keeps getting called. This difference can then act as the next&lt;br/&gt;
shipping interval.&lt;/p&gt;

&lt;p&gt;But this is an improvement and can wait until later.&lt;/p&gt;

&lt;p&gt;I will remove it and use wait(long interval) as you say.&lt;/p&gt;

&lt;p&gt;Thanks once again for your comments.&lt;/p&gt;</comment>
                            <comment id="12530437" author="oysteing" created="Wed, 26 Sep 2007 13:57:30 +0100"  >&lt;p&gt;Your plan for handleExceptions sounds good.  You need to decide whether this is a general method that may be called from any of MasterController&apos;s components or this is only to be used by LogShipper.  If the former, handleException needs to be told which component has failed.  If the latter, you should probably use a more specific name.&lt;/p&gt;

&lt;p&gt;If you want to adjust the shipping interval, you can adjust the parameter to wait() directly.  I am not sure you need lastShippingTime for that.&lt;/p&gt;</comment>
                            <comment id="12530669" author="narayanan" created="Thu, 27 Sep 2007 10:31:13 +0100"  >&lt;p&gt;I will keep to one method to handle the exceptions for now. I will write the method assuming that only log shipper will be using it. I will extend it later.&lt;/p&gt;</comment>
                            <comment id="12530922" author="narayanan" created="Fri, 28 Sep 2007 07:44:17 +0100"  >&lt;p&gt;While working on creating the handleExceptions method in&lt;br/&gt;
MasterController, I understood that there are two ways of&lt;br/&gt;
doing this.&lt;/p&gt;

&lt;p&gt;1) Make LogShipper throw a StandardException in which case we&lt;br/&gt;
   can add more specific information in the exception, for e.g.&lt;/p&gt;

&lt;p&gt;   When a NoSuchElementException in the run() method of the &lt;br/&gt;
   LogShipper class we could create a StandardException that&lt;br/&gt;
   contains a text that says&lt;/p&gt;

&lt;p&gt;   &quot;Error occurred while trying to retrieve log chunks from the&lt;br/&gt;
   log buffer&quot;&lt;/p&gt;


&lt;p&gt;2) If we however throw it as the NoSuchElementException, in the&lt;br/&gt;
   handleExceptions method all we would say is that&lt;/p&gt;

&lt;p&gt;   &quot;Error occurred during log shipping&quot;&lt;/p&gt;


&lt;p&gt;   The master controller I realize does not need to do much in this&lt;br/&gt;
   case except for wrap it in the StandardException and throw it.&lt;/p&gt;


&lt;p&gt;   2) Would be useful if we want the Master controller to do a exception&lt;br/&gt;
   specific action. This case would arise when we get an IOException&lt;br/&gt;
   during transmission of the log record.Since the MasterController is what &lt;br/&gt;
   creates the ReplicationNetworkMessageTransmit instance it should be &lt;br/&gt;
   responsible for reconnect. In certain other cases all the master controller &lt;br/&gt;
   would do is to throw the exception back.&lt;/p&gt;

&lt;p&gt;   We can also argue in the favour of 1) saying that to do a transmitter.initConnection()&lt;br/&gt;
   why would you go back to the MasterController. We are after all not re-initializing&lt;br/&gt;
   the connection. We are attempting a re-connect in the already initialized&lt;br/&gt;
   network framework. If the reconnection fails we can throw this exception then.&lt;/p&gt;

&lt;p&gt;   I am tending towards 1) since I do not feel it would be right for the LogShipper to go&lt;br/&gt;
   to the MasterController for all the exceptions it gets, and atleast not for attempting a&lt;br/&gt;
   reconnect in the network framework.&lt;/p&gt;</comment>
                            <comment id="12530938" author="jorgenlo" created="Fri, 28 Sep 2007 08:56:30 +0100"  >&lt;p&gt;If I understand you correctly, you are asking two questions: &lt;/p&gt;

&lt;p&gt;Q1. Should LogShipper throw all exceptions to MasterController even in cases where it can do something meaningful with it?&lt;/p&gt;

&lt;p&gt;Q2. Should the LogShipper wrap exceptions in StandardExceptions before throwing them to MasterController.&lt;/p&gt;


&lt;p&gt;A1. As a general rule of thumb when it comes to exceptions, I think you need to decide whether or not your code can do anything about it or if it needs to be handled by code at a higher level. If your code can handle it, you may fix the problem and not throw the exception further (in this case from LogShipper to MasterController).&lt;/p&gt;

&lt;p&gt;A2. I don&apos;t think you should wrap an exception in a StandardException at any lower level than MasterController; let the controller decide which exceptions are fatal and which can be handled. That is easier to do with the original exception at hand than with a StandardException.&lt;/p&gt;

&lt;p&gt;Of course, nothing but StandardException should be seen outside the replication package, so MasterController has to wrap before throwing.&lt;/p&gt;


&lt;p&gt;As I see it, your alternatives are not mutually exclusive. I think you can actually do a little bit of alternative 1) and a little bit of alternative 2) :-D &lt;/p&gt;</comment>
                            <comment id="12531418" author="narayanan" created="Mon, 1 Oct 2007 07:49:56 +0100"  >&lt;p&gt;Thank you for the earlier comments Oystein. I have addressed all the&lt;br/&gt;
issues pointed out in this patch.&lt;/p&gt;

&lt;p&gt;I have used the handledExceptions method and have followed Jorgen&apos;s&lt;br/&gt;
suggestion in making AsynchronousLogShipper handle the exceptions&lt;br/&gt;
to the master controller without wrapping them.&lt;/p&gt;

&lt;p&gt;I have however made handleExceptions carry no implementation in&lt;br/&gt;
MasterController for now. I think handleException should probably&lt;br/&gt;
raise a event that says that an exception had occurred during&lt;br/&gt;
log shipping and needs to be handled, so that the master controller&lt;br/&gt;
can break away from whatever it is doing currently and handle the&lt;br/&gt;
failure.&lt;/p&gt;

&lt;p&gt;I however thought this could be postponed to the patch that integrates&lt;br/&gt;
the log shipper into the master controller.&lt;/p&gt;</comment>
                            <comment id="12531499" author="oysteing" created="Mon, 1 Oct 2007 13:18:49 +0100"  >&lt;p&gt;Thanks for addressing my comments.  I have a few follw-up issues and&lt;br/&gt;
some issues that I did not think of the previous time:&lt;/p&gt;

&lt;p&gt; 9. I am not sure it is right to put the LogShipper in iapi.  As far&lt;br/&gt;
    as I can tell the MasterFactory will be the mediator for the rest&lt;br/&gt;
    of the system with respect to replication.  Hence, I do not think&lt;br/&gt;
    it is necessary for LogShipper to be visible outside the master&lt;br/&gt;
    package.&lt;/p&gt;

&lt;p&gt;10. Along the same lines, maybe the AsynchronousLogShipper could&lt;br/&gt;
    relate directly to the MasterController, instead of MasterFactory?&lt;br/&gt;
    I am not quite sure about this, but it seems to me that&lt;br/&gt;
    handleException might as well be a package private method in&lt;br/&gt;
    MasterController.&lt;/p&gt;

&lt;p&gt;11. AsynchronousLogShipper, unused import: SQLState&lt;/p&gt;

&lt;p&gt;12. AsynchronousLogShipper, constructor: You have removed the&lt;br/&gt;
    exception from the javadoc, but not the throws list.&lt;/p&gt;

&lt;p&gt;13. AsynchronousLogShipper#run:  &lt;br/&gt;
    a) &quot;when the shipper is informed to perform its periodic shipping&lt;br/&gt;
       also.&quot; I feel this sentence is a bit unclear. What does is mean&lt;br/&gt;
       to be &quot;informed to perform its periodic shipping&quot;?&lt;/p&gt;

&lt;p&gt;    b) I think the interrupted exception should be caught and ignored.&lt;br/&gt;
       This will make it possible for someone to immediately stop the&lt;br/&gt;
       shipping thread in a controlled way by first setting the stop&lt;br/&gt;
       flag and then interrupting the thread.&lt;/p&gt;

&lt;p&gt;14. AsynchronousLogShipper#shipALogChunk/forceFlush: I am not sure&lt;br/&gt;
    that it is a good idea to call handleException when you are not in&lt;br/&gt;
    the log shipping thread.  In that case, one might as well just let&lt;br/&gt;
    the exception go up to the MasterController directly.  I would&lt;br/&gt;
    also think it is the master controller that should decide whether&lt;br/&gt;
    or not to reconnect, not the log shipper on its own.  With respect&lt;br/&gt;
    to NoSuchElementException, I think you have better knowledge of&lt;br/&gt;
    the context in which it is happening here than the&lt;br/&gt;
    MasterController will have, and it might be a good idea that the&lt;br/&gt;
    log shipper decides how to handle it.  Since it will occur if you&lt;br/&gt;
    do not get any data even if next() return true, something fatal&lt;br/&gt;
    must have happened, and I guess you might as well report back a&lt;br/&gt;
    fatal replication error.&lt;/p&gt;

&lt;p&gt;15. AsynchronousLogShipper#forceFlush: Why use notifyAll() when there&lt;br/&gt;
    should be only one thread waiting?  I would use notify() instead.&lt;/p&gt;

&lt;p&gt;16. AsynchronousLogShipper#stopLogShippment: Typo: there should be&lt;br/&gt;
    only one &apos;p&apos; in shipment.&lt;/p&gt;</comment>
                            <comment id="12531707" author="narayanan" created="Tue, 2 Oct 2007 09:03:45 +0100"  >&lt;p&gt;Thank you for the comments on the patch Oystein. I have addressed all the&lt;br/&gt;
issues pointed out. Some explanation for the changes made follows.&lt;/p&gt;

&lt;p&gt;&amp;gt; AsynchronousLogShipper, unused import: SQLState&lt;/p&gt;

&lt;p&gt;In order to address your comment related to NoSuchElementException I am&lt;br/&gt;
throwing a StandardException with SQLState as SQLState.REPLICATION_FATAL_ERROR.&lt;br/&gt;
I therefore have retained this import.&lt;/p&gt;

&lt;p&gt;&amp;gt;&quot;when the shipper is informed to perform its periodic shipping&lt;br/&gt;
&amp;gt;also.&quot; I feel this sentence is a bit unclear. What does is mean&lt;br/&gt;
&amp;gt;to be &quot;informed to perform its periodic shipping&quot;? &lt;/p&gt;

&lt;p&gt;I meant when a forceFlush wakes up the periodic shipping thread. I have however&lt;br/&gt;
rephrased it to say&lt;/p&gt;

&lt;p&gt;&quot;  The log shipping happens at the configured shipping intervals unless a&lt;br/&gt;
   force flush happens, which triggers periodic shipping also since there&lt;br/&gt;
   will still be more log to send after the forceFlush has sent one chunk. &quot;&lt;/p&gt;

&lt;p&gt;&amp;gt;AsynchronousLogShipper#shipALogChunk/forceFlush: I am not sure&lt;br/&gt;
&amp;gt;that it is a good idea to call handleException when you are not in&lt;br/&gt;
&amp;gt;the log shipping thread. In that case, one might as well just let&lt;br/&gt;
&amp;gt;the exception go up to the MasterController directly. I would&lt;br/&gt;
&amp;gt;also think it is the master controller that should decide whether&lt;br/&gt;
&amp;gt;or not to reconnect, not the log shipper on its own. With respect&lt;br/&gt;
&amp;gt;to NoSuchElementException, I think you have better knowledge of&lt;br/&gt;
&amp;gt;the context in which it is happening here than the&lt;br/&gt;
&amp;gt;MasterController will have, and it might be a good idea that the&lt;br/&gt;
&amp;gt;log shipper decides how to handle it. Since it will occur if you&lt;br/&gt;
&amp;gt;do not get any data even if next() return true, something fatal&lt;br/&gt;
&amp;gt;must have happened, and I guess you might as well report back a&lt;br/&gt;
&amp;gt;fatal replication error. &lt;/p&gt;

&lt;p&gt;I have changed the shipALogChunk() method to throw its exceptions so that&lt;br/&gt;
the run() and the forceFlush() may handle them apropos.&lt;/p&gt;

&lt;p&gt;I now catch the NoSuchElementException and wrap it in a StandardException&lt;br/&gt;
with a SQLState as SQLState.REPLICATION_FATAL_ERROR.&lt;/p&gt;

&lt;p&gt;The IOException caused by a connection failure is also thrown, no reconnect&lt;br/&gt;
is attempted.&lt;/p&gt;

&lt;p&gt;forceFlush() throws all its exceptions to master controller. I am wrapping the&lt;br/&gt;
IOException obtained while calling shipALogChunk in a StandardException since&lt;br/&gt;
its signature in LogShipper mandates that a StandardException is what is throw.&lt;/p&gt;

&lt;p&gt;run() calls handleExceptions.&lt;/p&gt;</comment>
                            <comment id="12531728" author="oysteing" created="Tue, 2 Oct 2007 10:38:50 +0100"  >&lt;p&gt;All looks very good, except that it seems I did not explain what I&lt;br/&gt;
meant in comment 14 well enough.  I suggest shipALogChunk and&lt;br/&gt;
forceFlush does NOT call handleExceptions, nor catch exceptions they&lt;br/&gt;
are not going to deal with.  In other words, I think all exceptions&lt;br/&gt;
except the NoSuchElementExcpetion should not be caught, but left to&lt;br/&gt;
the caller (the log shipper thread or the master controller to deal&lt;br/&gt;
with).&lt;/p&gt;

&lt;p&gt;In addition, I have a few VERY minor comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Import of PriviligedActionException is no longer needed&lt;/li&gt;
	&lt;li&gt;mesg does no longer need to be declared outside the loop&lt;/li&gt;
	&lt;li&gt;It is probably good to explain why NoSuchElementExcpetion is fatal.&lt;/li&gt;
	&lt;li&gt;Why create a new SQLState?  Could not XRE03 be used?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12531788" author="narayanan" created="Tue, 2 Oct 2007 14:14:25 +0100"  >&lt;p&gt;Thanks once again for the comments and reviews Oystein.&lt;/p&gt;

&lt;p&gt;Pls find patch attached that fixes all the issues pointed out.&lt;/p&gt;</comment>
                            <comment id="12532043" author="oysteing" created="Wed, 3 Oct 2007 10:11:30 +0100"  >&lt;p&gt;Patch LogShipperImpl_v5.diff committed at revision 581534&lt;/p&gt;</comment>
                            <comment id="12532069" author="knutanders" created="Wed, 3 Oct 2007 13:14:38 +0100"  >&lt;p&gt;I don&apos;t quite understand this part of the patch:&lt;/p&gt;

&lt;p&gt;+        } catch (NoSuchElementException nse) &lt;/p&gt;
{
+            //Although next() returns true a request for data on the buffer
+            //fails implying that there has been a fatal exception in the
+            //buffer.
+            masterController.handleExceptions(StandardException.newException
+                (SQLState.REPLICATION_UNEXPECTED_EXCEPTION, nse));
+        }

&lt;p&gt;Is there something special about NoSuchElementException compared to other runtime exceptions like NullPointerException?&lt;/p&gt;

&lt;p&gt;If the problem is that run() swallows runtime exceptions, wouldn&apos;t it be better to add a generic &quot;catch (RuntimeException re)&quot; clause in the run() method and handle the exception there? That way you would solve the problem both for NoSuchElementException and for other unexpected exceptions.&lt;/p&gt;</comment>
                            <comment id="12535544" author="narayanan" created="Wed, 17 Oct 2007 14:21:07 +0100"  >&lt;p&gt;I intend to use the same issue for log shipper integration with the master controller. hence I am re-opening the issue.&lt;/p&gt;</comment>
                            <comment id="12535545" author="narayanan" created="Wed, 17 Oct 2007 14:25:29 +0100"  >&lt;p&gt;While working on the integration of the log shipper into the MasterController(MC) I will be introducing code that will log MC startup,&lt;br/&gt;
any failures that occur and MC shutdown in derby.log. &lt;/p&gt;

&lt;p&gt;while printing messages in derby.log a distinction ought to be made with respect to the messages that will be printed&lt;br/&gt;
always and the messages that will be printed only during debug(sane) mode.&lt;/p&gt;

&lt;p&gt;With respect to replication and this patch the following messages will be printed irrespective of whether the debug mode is on or not&lt;/p&gt;

&lt;p&gt;1) Replication(MC) startup&lt;br/&gt;
2) Error conditions that occur while MC (log shipping) is running&lt;br/&gt;
3) Replication(MC) shutdown&lt;/p&gt;</comment>
                            <comment id="12536220" author="narayanan" created="Fri, 19 Oct 2007 14:43:46 +0100"  >&lt;p&gt;Pls find attached the patch that handles the integration of the log shipper and the master&lt;br/&gt;
controller. I am running tests on the patch and shall report the results as soon as the tests&lt;br/&gt;
complete.&lt;/p&gt;

&lt;p&gt;I request the patch to please be considered for reviews and comments.&lt;/p&gt;</comment>
                            <comment id="12537882" author="oysteing" created="Fri, 26 Oct 2007 09:57:39 +0100"  >&lt;p&gt;Narayanan, thanks for the patch.  Here are my comments and questions:&lt;/p&gt;

&lt;p&gt;1. AsynchronousLogShipper#shipALogChunk: If resending of&lt;br/&gt;
   failedChunk fails, the current code will set failedChunk to null.&lt;br/&gt;
   Is that intentional?  &lt;/p&gt;

&lt;p&gt;2. MasterController#setupConnection: Why are IOEXcecptions not&lt;br/&gt;
   reported?  Maybe the IOException could contain useful information&lt;br/&gt;
   to figure out a network problem.&lt;/p&gt;

&lt;p&gt;3. MasterController#startMaster: &lt;/p&gt;

&lt;p&gt;   a) Do you depend on the thread to be interrupted before you give up&lt;br/&gt;
      attempting to start replication?  (Same issue with&lt;br/&gt;
      handleException)&lt;/p&gt;

&lt;p&gt;   b) InterruptedExceptions are normally trapped since they occur when&lt;br/&gt;
      some code intentionally interrupts the thread.&lt;/p&gt;

&lt;p&gt;4. MasterController#stopMaster: &lt;/p&gt;

&lt;p&gt;   a) The setting of the stop state is not synchronized with the log&lt;br/&gt;
      shipper thread.  Hence, you have no guarantee for when the log&lt;br/&gt;
      shipper thread will see that the stop field has changed.  If you&lt;br/&gt;
      make AsynchronousLogShipper#shipALogChunk volatile, it will be&lt;br/&gt;
      guaranteed that updates to the field are visible to other&lt;br/&gt;
      threads. (An alternative is to make stopLogShipment&lt;br/&gt;
      synchronized, but that is probably more expensive).&lt;/p&gt;

&lt;p&gt;   b) Maybe you should interrupt the log shipper thread to make sure&lt;br/&gt;
      it stops immediately?&lt;/p&gt;

&lt;p&gt;5. Do you plan to internationalize the derby.log messages in a later&lt;br/&gt;
   patch?&lt;/p&gt;

&lt;p&gt;6. I suggest you make a method that log the error message, print the&lt;br/&gt;
   stack and stop the master, so you do not have to repeat that many&lt;br/&gt;
   times.&lt;/p&gt;


</comment>
                            <comment id="12537889" author="oysteing" created="Fri, 26 Oct 2007 10:20:43 +0100"  >&lt;p&gt;Some additional minor comments:&lt;/p&gt;

&lt;p&gt;7. There is  an unused import of SanityManager in MasterController.java&lt;/p&gt;

&lt;p&gt;8. MasterController#startMaster(handleExceptions: Thread.sleep is&lt;br/&gt;
   static, so there is no need to call currentThread().&lt;/p&gt;
</comment>
                            <comment id="12538488" author="narayanan" created="Mon, 29 Oct 2007 13:16:13 +0000"  >&lt;p&gt;Thank you for the comments and reviews Oystein.&lt;/p&gt;

&lt;p&gt;&amp;gt;1. AsynchronousLogShipper#shipALogChunk: If resending of&lt;br/&gt;
&amp;gt;   failedChunk fails, the current code will set failedChunk to null.&lt;br/&gt;
&amp;gt;   Is that intentional?&lt;/p&gt;

&lt;p&gt;I guess you are referring to failedChunk being assigned mesg. When&lt;br/&gt;
failedChunk transmission fails then mesg would also be null. &lt;/p&gt;

&lt;p&gt;It was my mistake and was not intentional.&lt;/p&gt;

&lt;p&gt;I have overcome this by doing&lt;/p&gt;

&lt;p&gt;failedChunk = (mesg==null) ? failedChunk : mesg;&lt;/p&gt;

&lt;p&gt;mesg is null would imply that a transmission of the failedChunk was being&lt;br/&gt;
attempted and failedChunk would not be lost now.&lt;/p&gt;

&lt;p&gt;&amp;gt;2. MasterController#setupConnection: Why are IOEXcecptions not&lt;br/&gt;
&amp;gt;   reported? Maybe the IOException could contain useful information&lt;br/&gt;
&amp;gt;   to figure out a network problem.&lt;/p&gt;

&lt;p&gt;I initially thought of reporting IOExceptions here, but IOExceptions&lt;br/&gt;
cause setupConnection to return false and a next reconnect is attempted&lt;br/&gt;
in half a second. Reporting this failure in log would cause a&lt;br/&gt;
IOException to be printed in the log every half a second. Would&apos;nt this&lt;br/&gt;
amount to flooding the log? All these IOEXceptions being registered would&lt;br/&gt;
contain the same information stating a socket connection exception. So I was&lt;br/&gt;
afraid that it would contain the same information being repeated too many times.&lt;/p&gt;

&lt;p&gt;&amp;gt;3. MasterController#startMaster:&lt;/p&gt;

&lt;p&gt;&amp;gt;   a) Do you depend on the thread to be interrupted before you give up&lt;br/&gt;
&amp;gt;      attempting to start replication? (Same issue with&lt;br/&gt;
&amp;gt;      handleException)&lt;/p&gt;

&lt;p&gt;Yes, the attempt to connect to the slave will persist until it is interrupted.&lt;br/&gt;
One thing I can do is to ensure that the attempts are stopped when the user calls&lt;br/&gt;
stopreplication. I have attempted to link stopMaster() with this. I did this because&lt;br/&gt;
upon retrospection it did not seen right to me that a network connection is attempted &lt;br/&gt;
while the user has called stopreplication.&lt;/p&gt;

&lt;p&gt;&amp;gt;   b) InterruptedExceptions are normally trapped since they occur when&lt;br/&gt;
&amp;gt;      some code intentionally interrupts the thread.&lt;/p&gt;

&lt;p&gt;I was throwing the interrupted exception obtained from Thread.currentThread().sleep(500);.&lt;br/&gt;
I have changed it to simply log the exception and throw it no more.&lt;/p&gt;

&lt;p&gt;&amp;gt;4. MasterController#stopMaster:&lt;/p&gt;

&lt;p&gt;&amp;gt;   a) The setting of the stop state is not synchronized with the log&lt;br/&gt;
&amp;gt;      shipper thread. Hence, you have no guarantee for when the log&lt;br/&gt;
&amp;gt;      shipper thread will see that the stop field has changed. If you&lt;br/&gt;
&amp;gt;      make AsynchronousLogShipper#shipALogChunk volatile, it will be&lt;br/&gt;
&amp;gt;      guaranteed that updates to the field are visible to other&lt;br/&gt;
&amp;gt;      threads. (An alternative is to make stopLogShipment&lt;br/&gt;
&amp;gt;      synchronized, but that is probably more expensive).&lt;/p&gt;

&lt;p&gt;&amp;gt;   b) Maybe you should interrupt the log shipper thread to make sure&lt;br/&gt;
&amp;gt;      it stops immediately?&lt;/p&gt;

&lt;p&gt;I have interrupted the log shipper thread and consequently removed the stopShipping&lt;br/&gt;
check from the run() method. I instead have introduced a while(true) loop. I have however&lt;br/&gt;
retained the stopShipping check inorder to ensure that a forceFlush call after stopreplication&lt;br/&gt;
does not succeed.&lt;/p&gt;

&lt;p&gt;&amp;gt;5. Do you plan to internationalize the derby.log messages in a later&lt;br/&gt;
&amp;gt;   patch?&lt;/p&gt;

&lt;p&gt;Yes, I was hoping that this could be done in a follow up patch if this would be OK&lt;br/&gt;
with you.&lt;/p&gt;

&lt;p&gt;&amp;gt;6. I suggest you make a method that log the error message, print the&lt;br/&gt;
&amp;gt;   stack and stop the master, so you do not have to repeat that many&lt;br/&gt;
&amp;gt;   times. &lt;/p&gt;

&lt;p&gt;Introduced printStackAndStopMaster that does the sequence. I thought I could&lt;br/&gt;
move the printErrorStack code also in but doing that seemed to clutter a three&lt;br/&gt;
step process being modularized. So decided to let it remain this way.&lt;/p&gt;

&lt;p&gt;&amp;gt;7. There is an unused import of SanityManager in MasterController.java&lt;/p&gt;

&lt;p&gt;I have removed this unused import.&lt;/p&gt;

&lt;p&gt;&amp;gt;8. MasterController#startMaster(handleExceptions: Thread.sleep is&lt;br/&gt;
&amp;gt;   static, so there is no need to call currentThread().&lt;/p&gt;

&lt;p&gt;changed it to Thread.sleep in handleExceptions also.&lt;/p&gt;</comment>
                            <comment id="12538504" author="knutanders" created="Mon, 29 Oct 2007 14:10:09 +0000"  >&lt;p&gt;Do we need try/catch here? (in MasterController.startMaster)&lt;/p&gt;

&lt;p&gt;+        try &lt;/p&gt;
{
+            logFactory.startReplicationMasterRole(this);
+        }
&lt;p&gt; catch (StandardException se) &lt;/p&gt;
{
+            Monitor.logMessage(REPLICATION_MESSAGE_HEADER + 
+                    &quot;Exception occurred while trying to start replication&quot; +
+                    &quot; Master role.&quot;);
+            printErrorStack(se);
+            throw StandardException.newException
+                    (SQLState.REPLICATION_UNEXPECTED_EXCEPTION, se);
+        }

&lt;p&gt;The method is declared as &quot;throws StandardException&quot;, so there&apos;s no need to wrap se, I think. And exceptions are automatically logged in accordance with derby.stream.error.logSeverityLevel anyway, aren&apos;t they? If the user has requested no error logging, I&apos;m not sure if we should ignore that request. (If the user is never going to see the exception, I think it&apos;s a good idea to log it, but in startMaster() the exception will propagate out to the user, if I understand correctly.)&lt;/p&gt;</comment>
                            <comment id="12538513" author="knutanders" created="Mon, 29 Oct 2007 14:54:27 +0000"  >&lt;p&gt;&amp;gt; I have overcome this by doing&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; failedChunk = (mesg==null) ? failedChunk : mesg;&lt;/p&gt;

&lt;p&gt;I think this would be clearer if written as&lt;/p&gt;

&lt;p&gt;if (mesg != null} &lt;/p&gt;
{
    failedChunk = mesg;
}

&lt;p&gt;Then it&apos;s clearer that nothing happens if mesg==null.&lt;/p&gt;

&lt;p&gt;&amp;gt; I have interrupted the log shipper thread and consequently removed&lt;br/&gt;
&amp;gt; the stopShipping check from the run() method. I instead have&lt;br/&gt;
&amp;gt; introduced a while(true) loop. I have however retained the&lt;br/&gt;
&amp;gt; stopShipping check inorder to ensure that a forceFlush call after&lt;br/&gt;
&amp;gt; stopreplication does not succeed.&lt;/p&gt;

&lt;p&gt;I don&apos;t think you can remove the stopShipping check just because the&lt;br/&gt;
thread is interrupted. An interrupt does not stop the thread, but&lt;br/&gt;
blocking I/O operations will fail, and calls to sleep() or wait()&lt;br/&gt;
throw InterruptedException. As far as I can see, run() still silently&lt;br/&gt;
ignores InterruptedException, so the loop will just continue.&lt;/p&gt;

&lt;p&gt;Anyway, I&apos;m not sure we should rely on Thread.interrupt() to stop a&lt;br/&gt;
thread since it is hard to predict the state of the thread after it&lt;br/&gt;
has been interrupted. In general, I think wait()/notify() is a better&lt;br/&gt;
mechanism than sleep()/interrupt().&lt;/p&gt;

&lt;p&gt;&amp;gt; b) InterruptedExceptions are normally trapped since they occur when&lt;br/&gt;
&amp;gt; some code intentionally interrupts the thread.&lt;/p&gt;

&lt;p&gt;I think the normal way to handle InterruptedException in Derby is&lt;/p&gt;

&lt;p&gt;catch (InterruptedException ie) &lt;/p&gt;
{
    throw StandardException.interrupt(ie);
}

&lt;p&gt;&amp;gt; I initially thought of reporting IOExceptions here, but IOExceptions&lt;br/&gt;
&amp;gt; cause setupConnection to return false and a next reconnect is&lt;br/&gt;
&amp;gt; attempted in half a second. Reporting this failure in log would&lt;br/&gt;
&amp;gt; cause a IOException to be printed in the log every half a&lt;br/&gt;
&amp;gt; second. Would&apos;nt this amount to flooding the log? All these&lt;br/&gt;
&amp;gt; IOEXceptions being registered would contain the same information&lt;br/&gt;
&amp;gt; stating a socket connection exception. So I was afraid that it would&lt;br/&gt;
&amp;gt; contain the same information being repeated too many times.&lt;/p&gt;

&lt;p&gt;If this is always a socket connection exception, could the catch&lt;br/&gt;
clause be narrowed down to java.net.ConnectException instead of&lt;br/&gt;
java.io.Exception?&lt;/p&gt;

&lt;p&gt;Also, should we give up and fail gracefully after a certain number of&lt;br/&gt;
retries?&lt;/p&gt;</comment>
                            <comment id="12538704" author="jorgenlo" created="Tue, 30 Oct 2007 08:51:47 +0000"  >&lt;p&gt;&amp;gt; (snip) And exceptions are automatically logged in accordance with derby.stream.error.logSeverityLevel anyway, aren&apos;t they? If the user has requested no error logging, I&apos;m not sure if we should ignore that request. (If the user is never going to see the exception, I think it&apos;s a good idea to log it, but in startMaster() the exception will propagate out to the user, if I understand correctly.)&lt;/p&gt;

&lt;p&gt;Knut,&lt;br/&gt;
You are right about startMaster - exceptions thrown from this method would propagate back to the user. Apart from that single method, however, the methods in MasterController are called by either&lt;/p&gt;

&lt;p&gt;1. a user transaction thread executing normal transactions, or&lt;br/&gt;
2. the checkpoint daemon, or&lt;br/&gt;
3. the log shipper thread&lt;/p&gt;

&lt;p&gt;Thus, we need a plan for what to do with exceptions from these methods. Even though it would be possible to propagate a (wrapped) ReplicationLogBufferFull exception back to a random user who is executing a transaction (scenario 1.), I&apos;m not sure that&apos;s the right address for these messages. That&apos;s why exceptions are currently not thrown to the callers of the MasterFactory (interface of MC) methods.&lt;/p&gt;

&lt;p&gt;Would it suffice to use MC#printErrorStack for exceptions in all methods except startMaster, and let MC#printErrorStack print error messages based on the value of a property, e.g. &quot;derby.replication.verbose&quot;? The property could, e.g., correspond to the same logSeverityLevel used for other exceptions. That way, the amount of information written to derby.log can be controlled.&lt;/p&gt;

&lt;p&gt;If this sounds like a good idea, I will add the aforementioned property in a SlaveController patch that will make use of the functionality added in Derby-3071.&lt;/p&gt;</comment>
                            <comment id="12538715" author="knutanders" created="Tue, 30 Oct 2007 09:49:30 +0000"  >&lt;p&gt;Sounds like a good plan, J&#248;rgen. I guess it would be best if the default is to log all exceptions that are not observable any other way (derby.replication.verbose=true).&lt;/p&gt;</comment>
                            <comment id="12544862" author="narayanan" created="Thu, 22 Nov 2007 18:29:36 +0000"  >&lt;p&gt;In this patch&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I have addressed the issues pointed out with respect to logging&lt;br/&gt;
   in the MasterController.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I have followed the same pattern as in SlaveController in extending&lt;br/&gt;
  the ReplicationLogger and using the logError method. I however thought&lt;br/&gt;
  it would have been better to have had logError as a static method in the&lt;br/&gt;
  ReplicationLogger class rather than extending the class into the controllers.&lt;br/&gt;
  I decided not to disturb the structure of the classes for now.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I have not run tests on the patch. I shall run the tests and shall revert back.&lt;/p&gt;</comment>
                            <comment id="12547767" author="oysteing" created="Mon, 3 Dec 2007 08:53:17 +0000"  >&lt;p&gt;Thanks, for the patch Narayanan.  Most of my comments are just&lt;br/&gt;
cosmetical issues: &lt;/p&gt;

&lt;p&gt;9. MasterController:&lt;/p&gt;

&lt;p&gt;   a) I think startMaster() needs to have a timeout for how long it&lt;br/&gt;
      should wait before it tells the caller that it was not able to&lt;br/&gt;
      connect to the slave.&lt;/p&gt;

&lt;p&gt;   b) setupConnection(): I am not sure, but will it always be OK to&lt;br/&gt;
      not to propagate the content of IOExcpetion?  Will there never&lt;br/&gt;
      be any interesting info that could help a user diagnose why a&lt;br/&gt;
      connection is not established?&lt;/p&gt;

&lt;p&gt;   c) Unused imports: PrivilegedActionException, ErrorStringBuilder&lt;/p&gt;

&lt;p&gt;   d) Class declaration: Non-intuitive breakage of lines for&lt;br/&gt;
      implements/extends.&lt;/p&gt;

&lt;p&gt;   e) Unnecessary white-space diff after declaration of&lt;br/&gt;
      DEFAULT_LOG_BUFFER_SIZE.&lt;/p&gt;

&lt;p&gt;   f) I agree that setUpConnection should be moved, but it is still in&lt;br/&gt;
      the wrong place (under methods from ModuleSupportable interface)&lt;/p&gt;

&lt;p&gt;   g) I think the JavaDoc for handleExceptions should say that it only&lt;br/&gt;
      handles IOException and StandardException.&lt;/p&gt;

&lt;p&gt;10. AsynchronousLogShipper&lt;/p&gt;

&lt;p&gt;   a) I do not understand why you let the LogShipper continue after it&lt;br/&gt;
      is has been interrupted.  It seems like interrupt is only used&lt;br/&gt;
      when the thread is to be terminated.  Maybe you should just&lt;br/&gt;
      terminate the thread here.&lt;/p&gt;

&lt;p&gt;   b) What is the purpose of stopLogShipment()?  It does not seem to&lt;br/&gt;
      stop the LogShipper from sending log anymore.  I do not&lt;br/&gt;
      understand why you have changed run() to &apos;while(true)&apos; instead&lt;br/&gt;
      of &apos;while(!stopShipping)&apos;.&lt;/p&gt;


&lt;p&gt;11. messages.xml&lt;/p&gt;

&lt;p&gt;   a) I think messages needs to have a parameter for database name&lt;br/&gt;
      (slave messages does).  If the master is replication several&lt;br/&gt;
      databases, the users needs to be told which one has terminated.&lt;/p&gt;

&lt;p&gt;   b) Last message name should be R010, not R008.&lt;/p&gt;</comment>
                            <comment id="12548477" author="narayanan" created="Wed, 5 Dec 2007 00:26:08 +0000"  >&lt;p&gt;Thank you for the detailed comments Oystein.&lt;/p&gt;

&lt;p&gt;&amp;gt;9. MasterController:&lt;/p&gt;

&lt;p&gt;&amp;gt;   a) I think startMaster() needs to have a timeout for how long it&lt;br/&gt;
&amp;gt;      should wait before it tells the caller that it was not able to&lt;br/&gt;
&amp;gt;      connect to the slave.&lt;/p&gt;

&lt;p&gt;I have addressed this issue by using a timeout of 5 seconds for now (This&lt;br/&gt;
will be changed to be configurable in a later patch). I have left the&lt;br/&gt;
sleep period unchanged for now. One issue that remains is what happens if&lt;br/&gt;
the timeout is lesser than the sleep period. &lt;/p&gt;

&lt;p&gt;Would this mean that we should derive the sleep period from the timeout?&lt;/p&gt;

&lt;p&gt;For example we could assume that we will always have 5 re-connect attempts and&lt;br/&gt;
divide the timeout set by the user by 5 and use that as the sleep intervals.&lt;/p&gt;


&lt;p&gt;&amp;gt;   b) setupConnection(): I am not sure, but will it always be OK to&lt;br/&gt;
&amp;gt;      not to propagate the content of IOExcpetion? Will there never&lt;br/&gt;
&amp;gt;      be any interesting info that could help a user diagnose why a&lt;br/&gt;
&amp;gt;      connection is not established?&lt;/p&gt;

&lt;p&gt;since we attempt a re-connect when this method returns false is doing this&lt;/p&gt;

&lt;p&gt;logError(MessageId.REPLICATION_MASTER_RECONN, ioe, dbname);&lt;/p&gt;

&lt;p&gt;before returning false OK ?&lt;/p&gt;

&lt;p&gt;&amp;gt;   c) Unused imports: PrivilegedActionException, ErrorStringBuilder&lt;/p&gt;

&lt;p&gt;fixed&lt;/p&gt;

&lt;p&gt;&amp;gt;   d) Class declaration: Non-intuitive breakage of lines for&lt;br/&gt;
&amp;gt;      implements/extends.&lt;/p&gt;

&lt;p&gt;moved the implements keyword to the next line along with the the interfaces&lt;br/&gt;
being implemented.&lt;/p&gt;

&lt;p&gt;&amp;gt;   e) Unnecessary white-space diff after declaration of&lt;br/&gt;
&amp;gt;      DEFAULT_LOG_BUFFER_SIZE.&lt;/p&gt;

&lt;p&gt;fixed&lt;/p&gt;

&lt;p&gt;&amp;gt;   f) I agree that setUpConnection should be moved, but it is still in&lt;br/&gt;
&amp;gt;      the wrong place (under methods from ModuleSupportable interface)&lt;/p&gt;

&lt;p&gt;moved it to the end of the class along with handleException method.&lt;/p&gt;

&lt;p&gt;&amp;gt;   g) I think the JavaDoc for handleExceptions should say that it only&lt;br/&gt;
&amp;gt;      handles IOException and StandardException.&lt;/p&gt;

&lt;p&gt;changed the javadoc to&lt;/p&gt;

&lt;p&gt;     &quot; Used to handle the exceptions (IOException and StandardException) from &lt;br/&gt;
       the log shipper.&quot;&lt;/p&gt;


&lt;p&gt;&amp;gt;10. AsynchronousLogShipper&lt;/p&gt;

&lt;p&gt;&amp;gt;   a) I do not understand why you let the LogShipper continue after it&lt;br/&gt;
&amp;gt;      is has been interrupted. It seems like interrupt is only used&lt;br/&gt;
&amp;gt;      when the thread is to be terminated. Maybe you should just&lt;br/&gt;
&amp;gt;      terminate the thread here.&lt;/p&gt;

&lt;p&gt;The method returns upon an interrupted exception now.&lt;/p&gt;

&lt;p&gt;&amp;gt;   b) What is the purpose of stopLogShipment()? It does not seem to&lt;br/&gt;
&amp;gt;      stop the LogShipper from sending log anymore. I do not&lt;br/&gt;
&amp;gt;      understand why you have changed run() to &apos;while(true)&apos; instead&lt;br/&gt;
&amp;gt;      of &apos;while(!stopShipping)&apos;.&lt;/p&gt;

&lt;p&gt;changed while(true) to while(!stopShipping). stopShipping was being used&lt;br/&gt;
by forceFlush earlier.&lt;/p&gt;


&lt;p&gt;&amp;gt;11. messages.xml&lt;/p&gt;

&lt;p&gt;&amp;gt;   a) I think messages needs to have a parameter for database name&lt;br/&gt;
&amp;gt;      (slave messages does). If the master is replication several&lt;br/&gt;
&amp;gt;      databases, the users needs to be told which one has terminated.&lt;/p&gt;

&lt;p&gt;fixed&lt;/p&gt;

&lt;p&gt;&amp;gt;   b) Last message name should be R010, not R008. &lt;/p&gt;

&lt;p&gt;fixed&lt;/p&gt;

&lt;p&gt;Thanks once again for the comments. I really appreciate your detailed review.&lt;/p&gt;</comment>
                            <comment id="12548660" author="oysteing" created="Wed, 5 Dec 2007 13:11:28 +0000"  >&lt;p&gt;Thanks for the new patch Narayanan and for fixing all the minor nits I&lt;br/&gt;
pointed out.  I have some follow-up with respect to the initial&lt;br/&gt;
connection:&lt;/p&gt;

&lt;p&gt;9. a) Will a timeout at this level work?  As far as I can tell you&lt;br/&gt;
      have not set any timeout on the socket.  Is there a default&lt;br/&gt;
      timeout, or do you risk that getting the connection may hang for&lt;br/&gt;
      much longer than the desired timeout?&lt;/p&gt;

&lt;p&gt;   b) Don&apos;t you risk that the same error message may be written to&lt;br/&gt;
      derby.log very many times before the timeout occurs?  An&lt;br/&gt;
      alternative could be to link the last received IOExcpetion to&lt;br/&gt;
      the exception thrown when it times out.&lt;/p&gt;

&lt;p&gt;MasterFactory:  Is SLAVE_DB a good name here?  It seems to me that we&lt;br/&gt;
are talking about the database at the master here.&lt;/p&gt;


</comment>
                            <comment id="12549388" author="narayanan" created="Fri, 7 Dec 2007 12:27:49 +0000"  >&lt;p&gt;&amp;gt;9. a) Will a timeout at this level work? As far as I can tell you&lt;br/&gt;
&amp;gt;      have not set any timeout on the socket. Is there a default&lt;br/&gt;
&amp;gt;      timeout, or do you risk that getting the connection may hang for&lt;br/&gt;
&amp;gt;      much longer than the desired timeout?&lt;/p&gt;

&lt;p&gt;&amp;gt;   b) Don&apos;t you risk that the same error message may be written to&lt;br/&gt;
&amp;gt;      derby.log very many times before the timeout occurs? An&lt;br/&gt;
&amp;gt;      alternative could be to link the last received IOExcpetion to&lt;br/&gt;
&amp;gt;      the exception thrown when it times out.&lt;/p&gt;

&lt;p&gt;I have changed the patch to use socket timeout. I have removed the earlier timeouts used at&lt;br/&gt;
this level. IOExceptions are now being thrown, since overshooting the time interval would now&lt;br/&gt;
throw a SocketTimeoutException rather than a IOException.&lt;/p&gt;

&lt;p&gt;&amp;gt;MasterFactory: Is SLAVE_DB a good name here? It seems to me that we&lt;br/&gt;
&amp;gt;are talking about the database at the master here.&lt;/p&gt;

&lt;p&gt;Changed it to MASTER_DB&lt;/p&gt;</comment>
                            <comment id="12549433" author="oysteing" created="Fri, 7 Dec 2007 15:16:45 +0000"  >&lt;p&gt;I must admit, I do not have deep knowledge about Socket communication&lt;br/&gt;
in Java. If specifying timeout on connect, what type of errors will&lt;br/&gt;
cause connect to throw an exception before it times out?  Will all&lt;br/&gt;
such errors mean that a retry will probably also fail?  With the new&lt;br/&gt;
patch the master seems to give up on the first attempt.  Depending on&lt;br/&gt;
the answer to my question above, this may be OK.&lt;/p&gt;

&lt;p&gt;I thought the idea with respect to network failures during replication&lt;br/&gt;
was to keep on trying until the log buffer is full.  However, with the&lt;br/&gt;
new patch it seems to be timeout-based with the same timeout as for&lt;br/&gt;
start of replication.&lt;/p&gt;

&lt;p&gt;Minor: Some white-space has been added to previously empty lines.&lt;/p&gt;</comment>
                            <comment id="12550015" author="narayanan" created="Mon, 10 Dec 2007 11:04:16 +0000"  >&lt;p&gt;1) when you attempt the first connect&lt;br/&gt;
2) when a connection failure occurs&lt;/p&gt;

&lt;p&gt;1) I believe that if an IOException occurs here we should log the exception and exit. &lt;br/&gt;
   User can handle the cause of the exception here and can restart replication after &lt;br/&gt;
   correcting the problem. We do not know the severity of the cause of the IOException. &lt;br/&gt;
   So it is very difficult to distinguish between when we should stop and re-try based&lt;br/&gt;
   on the cause. So I believe here we should exit when a timeout occurs.&lt;/p&gt;

&lt;p&gt;2) Here we should re-try if a timeout or a IOException occurs. This would take care of&lt;br/&gt;
   the case for example when the network connection goes down and comes back again. Also&lt;br/&gt;
   if the log buffer is full and the network is down we fail aborting reconnect attempts.&lt;/p&gt;

&lt;p&gt;Does this sound OK to you?&lt;/p&gt;</comment>
                            <comment id="12550017" author="narayanan" created="Mon, 10 Dec 2007 11:05:16 +0000"  >&lt;p&gt;should have started the comment with &quot;we have two cases in consideration here&quot;. Sorry about that.&lt;/p&gt;</comment>
                            <comment id="12550066" author="oysteing" created="Mon, 10 Dec 2007 13:27:50 +0000"  >&lt;p&gt;Narayanan, I agree with your analysis with respect to connection failures.&lt;/p&gt;</comment>
                            <comment id="12550373" author="narayanan" created="Tue, 11 Dec 2007 09:36:55 +0000"  >&lt;p&gt;I have modified the patch to conform to the earlier discussion.&lt;br/&gt;
Thanks once again for the reviews and comments Oystein and&lt;br/&gt;
Jorgen.&lt;/p&gt;</comment>
                            <comment id="12550458" author="oysteing" created="Tue, 11 Dec 2007 14:40:54 +0000"  >&lt;p&gt;Thanks for your newest patch, Narayanan.&lt;br/&gt;
Patch, LogShipperIntegration_v6.diff, addresses all my comments.&lt;br/&gt;
Committed as revision 693260.&lt;/p&gt;</comment>
                            <comment id="12555514" author="narayanan" created="Thu, 3 Jan 2008 09:21:32 +0000"  >&lt;p&gt;All the patches for this issue have been committed&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12383494">DERBY-3235</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12365467" name="LogShipperImpl_v1.diff" size="13801" author="narayanan" created="Mon, 10 Sep 2007 12:25:44 +0100"/>
                            <attachment id="12365468" name="LogShipperImpl_v1.stat" size="314" author="narayanan" created="Mon, 10 Sep 2007 12:25:44 +0100"/>
                            <attachment id="12366576" name="LogShipperImpl_v2.diff" size="11366" author="narayanan" created="Wed, 26 Sep 2007 07:41:55 +0100"/>
                            <attachment id="12366577" name="LogShipperImpl_v2.stat" size="220" author="narayanan" created="Wed, 26 Sep 2007 07:41:55 +0100"/>
                            <attachment id="12366828" name="LogShipperImpl_v3.diff" size="13868" author="narayanan" created="Mon, 1 Oct 2007 07:49:56 +0100"/>
                            <attachment id="12366829" name="LogShipperImpl_v3.stat" size="361" author="narayanan" created="Mon, 1 Oct 2007 07:49:56 +0100"/>
                            <attachment id="12366886" name="LogShipperImpl_v4.diff" size="14214" author="narayanan" created="Tue, 2 Oct 2007 09:03:45 +0100"/>
                            <attachment id="12366887" name="LogShipperImpl_v4.stat" size="400" author="narayanan" created="Tue, 2 Oct 2007 09:03:45 +0100"/>
                            <attachment id="12366912" name="LogShipperImpl_v5.diff" size="13316" author="narayanan" created="Tue, 2 Oct 2007 14:14:24 +0100"/>
                            <attachment id="12366913" name="LogShipperImpl_v5.stat" size="273" author="narayanan" created="Tue, 2 Oct 2007 14:14:25 +0100"/>
                            <attachment id="12368013" name="LogShipperIntegration_v1.diff" size="15562" author="narayanan" created="Fri, 19 Oct 2007 14:43:46 +0100"/>
                            <attachment id="12368014" name="LogShipperIntegration_v1.stat" size="215" author="narayanan" created="Fri, 19 Oct 2007 14:43:46 +0100"/>
                            <attachment id="12368597" name="LogShipperIntegration_v2.diff" size="15078" author="narayanan" created="Mon, 29 Oct 2007 13:16:13 +0000"/>
                            <attachment id="12368598" name="LogShipperIntegration_v2.stat" size="188" author="narayanan" created="Mon, 29 Oct 2007 13:16:13 +0000"/>
                            <attachment id="12370081" name="LogShipperIntegration_v3.diff" size="15546" author="narayanan" created="Thu, 22 Nov 2007 18:29:36 +0000"/>
                            <attachment id="12370082" name="LogShipperIntegration_v3.stat" size="316" author="narayanan" created="Thu, 22 Nov 2007 18:29:36 +0000"/>
                            <attachment id="12370984" name="LogShipperIntegration_v4.diff" size="18912" author="narayanan" created="Wed, 5 Dec 2007 00:26:07 +0000"/>
                            <attachment id="12370985" name="LogShipperIntegration_v4.stat" size="478" author="narayanan" created="Wed, 5 Dec 2007 00:26:08 +0000"/>
                            <attachment id="12371224" name="LogShipperIntegration_v5.diff" size="20472" author="narayanan" created="Fri, 7 Dec 2007 12:27:48 +0000"/>
                            <attachment id="12371225" name="LogShipperIntegration_v5.stat" size="576" author="narayanan" created="Fri, 7 Dec 2007 12:27:49 +0000"/>
                            <attachment id="12371416" name="LogShipperIntegration_v6.diff" size="20545" author="narayanan" created="Tue, 11 Dec 2007 09:36:55 +0000"/>
                            <attachment id="12371417" name="LogShipperIntegration_v6.stat" size="603" author="narayanan" created="Tue, 11 Dec 2007 09:36:55 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 10 Sep 2007 12:36:46 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30713</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0jyn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37052</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>