<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:29:08 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1196/DERBY-1196.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1196] Network server closes  prepared statements  prematurely if  exception occurs during OPNQRY  and can cause &quot;&apos;Statement&apos; already closed&quot; exception on reexecution</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1196</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;There is a bug in  Network Server that it closes prepared statements if&lt;br/&gt;
an error occurs during execution on OPNQRY (usually PreparedStatement.execute())&lt;br/&gt;
Basically the problem is this code in DRDAConnThread.java&lt;br/&gt;
processCommands() which catches any exception that occurs during  OPNQRY&lt;br/&gt;
and closes the prepared statement .  OPNQRY is just the statement execution and any statement level exceptions should not cause the statement to be closed.&lt;/p&gt;

&lt;p&gt;catch (SQLException e)&lt;br/&gt;
                    {&lt;br/&gt;
                        writer.clearDSSesBackToMark(writerMark);&lt;br/&gt;
                        try &lt;/p&gt;
{
                            // Try to cleanup if we hit an error.
                            if (ps != null)
                                ps.close();
                            writeOPNQFLRM(e);
                        }
&lt;p&gt;                        catch (SQLException pse) {}&lt;br/&gt;
                        errorInChain(e);&lt;br/&gt;
                    }&lt;/p&gt;


&lt;p&gt;There are cases in jdbcapi/setTransactionIsolation when run with JCC that trigger this case and yield a &lt;br/&gt;
&apos;Statement&apos; already closed message. &lt;/p&gt;

&lt;p&gt;This was the core issue with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1047&quot; title=&quot;[xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &amp;#39;Statement&amp;#39; already closed.&amp;#39;  when used after the global transaction ends&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1047&quot;&gt;&lt;del&gt;DERBY-1047&lt;/del&gt;&lt;/a&gt; but there were problems with the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1047&quot; title=&quot;[xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &amp;#39;Statement&amp;#39; already closed.&amp;#39;  when used after the global transaction ends&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1047&quot;&gt;&lt;del&gt;DERBY-1047&lt;/del&gt;&lt;/a&gt; Jira entry in that the description of the problem was wrong and also the issue itself no longer occurs with the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1158&quot; title=&quot;Allow use of Statements created in local transaction with default holdability to be used in global transactions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1158&quot;&gt;&lt;del&gt;DERBY-1158&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1047&quot; title=&quot;[xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &amp;#39;Statement&amp;#39; already closed.&amp;#39;  when used after the global transaction ends&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1047&quot;&gt;&lt;del&gt;DERBY-1047&lt;/del&gt;&lt;/a&gt; will be closed invalid and this issue will be used to  track  the fix.&lt;/p&gt;




</description>
                <environment></environment>
        <key id="12331833">DERBY-1196</key>
            <summary>Network server closes  prepared statements  prematurely if  exception occurs during OPNQRY  and can cause &quot;&apos;Statement&apos; already closed&quot; exception on reexecution</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kmarsden">Kathey Marsden</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                    </labels>
                <created>Mon, 10 Apr 2006 01:34:51 +0100</created>
                <updated>Thu, 13 Apr 2006 01:32:09 +0100</updated>
                            <resolved>Mon, 10 Apr 2006 02:10:21 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>Network Server</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12373781" author="kmarsden" created="Mon, 10 Apr 2006 02:10:21 +0100"  >&lt;p&gt;Checked this fix into the trunk:&lt;/p&gt;

&lt;p&gt;Date: Sun Apr  9 10:05:51 2006&lt;br/&gt;
New Revision: 392781&lt;/p&gt;

&lt;p&gt;URL: &lt;a href=&quot;http://svn.apache.org/viewcvs?rev=392781&amp;amp;view=rev&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs?rev=392781&amp;amp;view=rev&lt;/a&gt;&lt;br/&gt;
Log:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1196&quot; title=&quot;Network server closes  prepared statements  prematurely if  exception occurs during OPNQRY  and can cause &amp;quot;&amp;#39;Statement&amp;#39; already closed&amp;quot; exception on reexecution&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1196&quot;&gt;&lt;del&gt;DERBY-1196&lt;/del&gt;&lt;/a&gt; Network server closes prepared statements prematurely if exception occurs during OPNQRY &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Takes out close of prepared statement on exception in OPNQRY in DRDAConnThread processCommands&lt;/li&gt;
	&lt;li&gt;Updates the JCC master for derbnet/setTransactionIsolation.&lt;br/&gt;
  This test was getting Statement already closed errors for valid statements with JCC that are no longer in the master.&lt;/li&gt;
	&lt;li&gt;Enables test for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1047&quot; title=&quot;[xa] With client xa, a PreparedStatement  created before the global transaction starts  gives  java.sql.SQLException: &amp;#39;Statement&amp;#39; already closed.&amp;#39;  when used after the global transaction ends&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1047&quot;&gt;&lt;del&gt;DERBY-1047&lt;/del&gt;&lt;/a&gt; in checkDataSource ( Note this case actually passes withtout the fix because of the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1158&quot; title=&quot;Allow use of Statements created in local transaction with default holdability to be used in global transactions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1158&quot;&gt;&lt;del&gt;DERBY-1158&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12374119" author="army" created="Wed, 12 Apr 2006 09:18:40 +0100"  >&lt;p&gt;The checkin for this issue is causing a new failure in the ODBC tests that I&apos;ve been running--but I&apos;m not sure if it&apos;s a &quot;regression&quot; or not.  Please keep reading for more details.&lt;/p&gt;

&lt;p&gt;The ODBC test that is seeing the failure is attempting to execute a SELECT query with 5 sets of parameters in a batch-like fashion, where the middle set fails with an execution-time error.  Prior to the fix for this issue the ODBC client could retrieve the 1st and 2nd result sets, would see an &quot;invalid cursor state&quot; for the 3rd result set, and then attempts to retrieve the 4th and 5th result sets would result in a &quot;statement is already closed&quot; error.  After the fix, though, that same situation leads to an ASSERT failure in the Derby engine:&lt;/p&gt;

&lt;p&gt;org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED ProjectRestrictResultSet already open&lt;br/&gt;
	at org.apache.derby.shared.common.sanity.SanityManager.ASSERT(SanityManager.java(Compiled Code))&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:154)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.SortResultSet.openCore(SortResultSet.java:251)&lt;br/&gt;
...&lt;/p&gt;

&lt;p&gt;I wrote code to try to do the same thing using the PreparedStatement.addBatch() functionality with the Java clients, but both the Derby Client and the JCC client  throw client-side errors saying: &quot;Batching of queries not allowed by J2EE compliance.&quot;  Derby embedded fails as well, but with an error saying &quot;Statement.executeUpdate() cannot be called with a statement that returns a ResultSet.&quot;&lt;/p&gt;

&lt;p&gt;It appears that, somehow, the ODBC client is able to get this batch-like behavior to work with the Network Server, even though there doesn&apos;t appear to be a way to do it from Java.  Or at least that&apos;s true based on my own little experiments: namely, if I remove the execution-time error from the above scenario, the server will correctly execute all five queries and return 5 result sets, which the ODBC client can then retrieve and process as normal using the ODBC equivalent to &quot;getMoreResults()&quot; and &quot;getResultSet()&quot;.&lt;/p&gt;

&lt;p&gt;So I&apos;m wondering if this constitutes a regression or not?  The apparent regressed behavior is not visible from Java because both clients (and Derby embedded) disallow the operation.  But the behavior does appear to have &quot;regressed&quot; for ODBC clients that allow batch-like execution of SELECT queries.  Of course, I&apos;m not sure what the ODBC behavior is supposed to be in the case of a failed query-&lt;del&gt;with DB2, the failed query simply won&apos;t return a result set, so only 4 result sets will be returned to the client.  Derby Network Server has never matched that behavior&lt;/del&gt;-before the fix for this issue we returned 2 result sets and then closed the prepared statement; after the fix we return 2 result sets and then fail with an assert.&lt;/p&gt;

&lt;p&gt;So in short: is this a case of regressed behavior, or a case of functionality that has never technically worked (at least not correctly) failing in a different way?  If it&apos;s not a regression, then what&apos;s the best way to address this?&lt;/p&gt;</comment>
                            <comment id="12374120" author="army" created="Wed, 12 Apr 2006 09:42:05 +0100"  >&lt;p&gt;As a follow-up comment, for what it&apos;s worth, I commented out two places where we have ASSERT checks (one in ProjectRestrictResultSet and one in TableScanResultSet) and when I did, things actually worked quite well.  Namely, the ODBC client was able to fetch the 1st and 2nd result sets, then it received an &quot;invalid cursor state&quot; for the 3rd result set, and finally was able to retrieve the 4th and 5th result sets without a problem.&lt;/p&gt;

&lt;p&gt;This means that if I was to run the ODBC tests against an insane build, the queries would actually &quot;work&quot; in a manner of speaking.&lt;/p&gt;

&lt;p&gt;The comments for the ASSERT check in ProjectRestrictNode say the following:&lt;/p&gt;

&lt;p&gt;		// REVISIT: through the direct DB API, this needs to be an&lt;br/&gt;
		// error, not an ASSERT; users can open twice. Only through JDBC&lt;br/&gt;
		// is access to open controlled and ensured valid.&lt;br/&gt;
		if (SanityManager.DEBUG)&lt;br/&gt;
		    SanityManager.ASSERT( ! isOpen, &quot;ProjectRestrictResultSet already open&quot;);&lt;/p&gt;

&lt;p&gt;Perhaps this part of the code has to be &quot;revisited&quot;, as the comment says...?&lt;/p&gt;

&lt;p&gt;I don&apos;t know if that&apos;s helpful or not; I&apos;m just posting I&apos;ve observed...&lt;/p&gt;</comment>
                            <comment id="12374121" author="kmarsden" created="Wed, 12 Apr 2006 09:58:57 +0100"  >&lt;p&gt;Since really network server is a DRDA to JDBC converter,  it translates the DRDA into embedded calls.  &lt;br/&gt;
Since DRDA does not have the protocol for  batched statements,  The clients generally  just flow repeated executions which the server executes one by one.   OPNQRY  converts to the embedded call PreparedStatement.execute().   I don&apos;t think it uses any internal API&apos;s for this code path.&lt;br/&gt;
Do you know what direct DB API means?&lt;/p&gt;</comment>
                            <comment id="12374193" author="kmarsden" created="Wed, 12 Apr 2006 23:26:29 +0100"  >&lt;p&gt;It seems like there must be an embedded reproduction for the ASSERTION.  From the description it seems like:&lt;/p&gt;

&lt;p&gt;1) The statement was executed (PreparedStatement.execute() )once and got some exception.&lt;br/&gt;
    This exception used result in the statement getting closed, but no longer is that the case.&lt;br/&gt;
2) The statement gets executed a second time and gets this ASSERTION because the result set is open&lt;/p&gt;

&lt;p&gt;I am curious what the original exception was.     It seems like the best course of action is to get an embedded repro for the ASSERTION and then fix that bug.  It seems like either the embedded driver should have closed the result set with the original exception or  as  the comment says, the exception that the result set is still open should be a real error.  We&apos;d have to see what the original exception was  to know which is the case.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;




</comment>
                            <comment id="12374197" author="army" created="Wed, 12 Apr 2006 23:43:34 +0100"  >&lt;p&gt;&amp;gt; Do you know what direct DB API means? &lt;/p&gt;

&lt;p&gt;No, I do not...&lt;/p&gt;

&lt;p&gt;&amp;gt; I am curious what the original exception was.&lt;/p&gt;

&lt;p&gt;It was a divide-by-zero exception.&lt;/p&gt;

&lt;p&gt;&amp;gt; It seems like the best course of action is to get an embedded repro for the ASSERTION. &lt;/p&gt;

&lt;p&gt;Okay, I will see if I can do that based on your 2-step scenario (thanks for breaking it down).&lt;/p&gt;

&lt;p&gt;&amp;gt; It seems like either the embedded driver should have closed the result set with the&lt;br/&gt;
&amp;gt; original exception or as the comment says, the exception that the result set is still&lt;br/&gt;
&amp;gt; open should be a real error.&lt;/p&gt;

&lt;p&gt;So given that the exception is a divide-by-zero error, which behavior would seem like the correct one?  For the record, the behavior I see when I remove the ASSERTs matches at least one version of DB2 server--that doesn&apos;t necessarily mean it&apos;s right, but it does suggest that just closing the result set is a viable option, as opposed to throwing the error.&lt;/p&gt;

&lt;p&gt;I&apos;ll try to get an embedded reproduction and will post the results.  Thanks for the feedback.&lt;/p&gt;</comment>
                            <comment id="12374211" author="army" created="Thu, 13 Apr 2006 01:32:09 +0100"  >&lt;p&gt;With Kathey&apos;s suggestion I was able to write a simple reproduction for the ASSERT failure.  I created a new issue, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1208&quot; title=&quot;Attempts to reuse a prepared statement after an execution-time error causes ASSERT failure in SANE mode, but work fine in INSANE.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1208&quot;&gt;DERBY-1208&lt;/a&gt;, and attached the repro to that issue.  Since the problem reproduces against embedded mode, I think it&apos;s safe to say that it is not a regression caused by changes for this issue (1196).  So sorry for the miscue--and thanks again to Kathey for the input.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 12 Apr 2006 08:18:40 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22364</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy16sv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40752</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>