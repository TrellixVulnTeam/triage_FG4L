<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:20:36 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3093/DERBY-3093.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3093] Intermittent transaction failure caused by internal duplicate savepoint name for triggers</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3093</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;While running our app overnight, performing some intensive database operations (primarily deletes), we experienced a transaction failure, with error message &quot;A SAVEPOINT with the passed name already exists in the current transaction&quot;.  This failure appears to be very intermittent, as I&apos;ve run the same operation successfully for hours and hours without failure.  Some more information:&lt;/p&gt;

&lt;p&gt;1.  I see that there are four JIRA issues which report the same message (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2773&quot; title=&quot; testGrantRevokeDDL(org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeDDLTest) throws java.sql.SQLException: The exception &amp;#39;java.sql.SQLException: A SAVEPOINT with the passed name already exists in the current transaction.&amp;#39; &quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2773&quot;&gt;&lt;del&gt;DERBY-2773&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1457&quot; title=&quot;lang/triggerGeneral.sql fails intermittently&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1457&quot;&gt;&lt;del&gt;DERBY-1457&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2808&quot; title=&quot;triggerRecursion.sql and triggerGeneral.sql intermittently fail with SAVEPOINT error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2808&quot;&gt;&lt;del&gt;DERBY-2808&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2804&quot; title=&quot;predicatesIntoViews.sql fails (intermittently?) with SAVEPOINT error w/ IBM 15 on Linux.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2804&quot;&gt;&lt;del&gt;DERBY-2804&lt;/del&gt;&lt;/a&gt;).  I am not sure to what extent if any, the problem I experienced is related to these issues.&lt;/p&gt;

&lt;p&gt;&#8226;	At least three of the above JIRA issues are related to triggers.  Our transaction failure occurred while performing a delete in a table which has delete triggers.&lt;br/&gt;
&#8226;	We aren&apos;t using savepoints explicitly.  Of course, it can be seen in the stack trace that the trigger operation is setting a savepoint.&lt;br/&gt;
&#8226;	One of the JIRA issues mentions exceeding maximum depth of nested triggers.  Not sure what a nested trigger is, but the trigger we are performing should not (in theory) cause another trigger event.&lt;/p&gt;

&lt;p&gt;2.  Here&apos;s the stack trace:&lt;/p&gt;

&lt;p&gt;Caused by: java.sql.SQLException: A SAVEPOINT with the passed name already exists in the current transaction.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)&lt;br/&gt;
        at com.referentia.sdf.monitor.samplebase.derby.DerbySampleBase$3.perform(DerbySampleBase.java:682)&lt;br/&gt;
        at com.referentia.sdf.monitor.samplebase.derby.DerbySampleBase.performInTransaction(DerbySampleBase.java:2747)&lt;br/&gt;
        ... 7 more&lt;br/&gt;
Caused by: java.sql.SQLException: A SAVEPOINT with the passed name already exists in the current transaction.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)&lt;br/&gt;
        ... 18 more&lt;br/&gt;
Caused by: ERROR 3B501: A SAVEPOINT with the passed name already exists in the current transaction.&lt;br/&gt;
        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.raw.xact.Xact.setSavePoint(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.store.access.RAMTransaction.setSavePoint(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericStatementContext.setSavePoint(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.GenericTriggerExecutor.executeSPS(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.RowTriggerExecutor.fireTrigger(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.TriggerEventActivator.notifyEvent(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.DeleteResultSet.fireAfterTriggers(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.execute.DeleteResultSet.open(Unknown Source)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
        ... 12 more&lt;/p&gt;

&lt;p&gt;3.  Here are the relevant tables and triggers. We have different tables for different &quot;sample&quot; data types  in our application (currently int, long, float, double, Boolean, string).  I have shown the int_sample table; the other tables are identical but have a different data type for the value field.  &lt;/p&gt;

&lt;p&gt;Sample records are first class; time records are second class - they only exist to support sample records.  When there are no remaining sample records for a given time record, the time record can be removed.  It is the job of the trigger to perform this cleanup:  when a record is deleted from any of the sample tables, the time record corresponding to *_sample.fk_time_id is deleted only if there are no remaining records in any of the sample tables which have the same fk_time_id.  So although there are cascading deletes (deleting a time record deletes all of its samples), the trigger should not recurse because the trigger only deletes when there are no associated records.&lt;/p&gt;

&lt;p&gt;create table time (&lt;br/&gt;
  id                  int not null generated always as identity,&lt;br/&gt;
  time                timestamp not null,&lt;/p&gt;

&lt;p&gt;  constraint time_pk primary key (id),&lt;br/&gt;
  constraint time_unique unique (time)&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;create table int_sample (&lt;br/&gt;
  fk_band_id          int not null,&lt;br/&gt;
  fk_time_id          int not null,&lt;br/&gt;
  value               int not null,&lt;/p&gt;

&lt;p&gt;  constraint int_sample_pk primary key (fk_band_id, fk_time_id),&lt;br/&gt;
  constraint int_sample_fk_band foreign key (fk_band_id) references band (id) on delete cascade,&lt;br/&gt;
  constraint int_sample_fk_time foreign key (fk_time_id) references time (id) on delete cascade&lt;br/&gt;
);&lt;/p&gt;

&lt;p&gt;create trigger cascade_delete_unused_time_for_int_sample_trigger&lt;br/&gt;
  after delete on int_sample&lt;br/&gt;
  referencing old as oldrow&lt;br/&gt;
  for each row&lt;br/&gt;
  delete from time where &lt;br/&gt;
  time.id = oldrow.fk_time_id&lt;br/&gt;
  and id not in (select fk_time_id from int_sample) &lt;br/&gt;
  and id not in (select fk_time_id from long_sample) &lt;br/&gt;
  and id not in (select fk_time_id from float_sample) &lt;br/&gt;
  and id not in (select fk_time_id from double_sample) &lt;br/&gt;
  and id not in (select fk_time_id from boolean_sample) &lt;br/&gt;
  and id not in (select fk_time_id from string_sample);&lt;/p&gt;

&lt;p&gt;4.  Invocation.  This is very rough pseudocode focusing on the core logic.  In reality, there&apos;s a lot more code, but I&apos;m doing the usual stuff, such as using prepared statements, and closing all resources when done.  The key thing is that I&apos;m using two statements in a nested fashion; in the outer statement, I iterate over records in the time table, and in the inner loop I use a second statement to delete records in one of the sample tables.  I can provide the actual code if desired.&lt;/p&gt;

&lt;p&gt;deleteSamples(int bandId, String sampleTable, Object someQueryCriteria) {&lt;br/&gt;
  within transaction {&lt;br/&gt;
    create stmt1 iterating over time ids in time table (restricted by someQueryCriteria)&lt;br/&gt;
      for (time_id in stmt1) &lt;/p&gt;
{
        PreparedStatement stmt2 = conn.prepareStatement(String.format(
        &quot;delete from %s where fk_band_id = ? and fk_time_id = ?&quot;, sampleTable));
        set stmt2 parameters and executeUpdate()
    }
&lt;p&gt;  }&lt;br/&gt;
}&lt;/p&gt;</description>
                <environment>Java 1.6.0_02&lt;br/&gt;
</environment>
        <key id="12379326">DERBY-3093</key>
            <summary>Intermittent transaction failure caused by internal duplicate savepoint name for triggers</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="james.f.adams">James F. Adams</assignee>
                                    <reporter username="jn">Jim Newsham</reporter>
                        <labels>
                    </labels>
                <created>Fri, 28 Sep 2007 22:20:59 +0100</created>
                <updated>Fri, 21 Jan 2011 17:50:53 +0000</updated>
                            <resolved>Fri, 26 Oct 2007 02:20:23 +0100</resolved>
                                    <version>10.1.3.1</version>
                    <version>10.2.2.0</version>
                    <version>10.3.1.4</version>
                                    <fixVersion>10.1.3.2</fixVersion>
                    <fixVersion>10.2.2.1</fixVersion>
                    <fixVersion>10.3.2.1</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12535384" author="james.f.adams" created="Wed, 17 Oct 2007 01:42:33 +0100"  >&lt;p&gt;In briefly looking into this issue I noticed that the internal savepoint name is created in GenericStatementContext&apos;s constructor with the following line of code:&lt;/p&gt;

&lt;p&gt;		internalSavePointName = &quot;ISSP&quot; + hashCode();&lt;/p&gt;

&lt;p&gt;From the javadoc for Object:&lt;/p&gt;

&lt;p&gt;It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables. &lt;/p&gt;

&lt;p&gt; As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)&lt;/p&gt;

&lt;p&gt;Another method of creating unique names should be implemented.&lt;/p&gt;
</comment>
                            <comment id="12535673" author="knutanders" created="Wed, 17 Oct 2007 19:53:49 +0100"  >&lt;p&gt;That&apos;s a good catch, James! Seems like you have found the bug. If the savepoint name only needs to be unique within a transaction, I think we can fix it by maintaining a counter in GenericLanguageConnectionContext and adding a getUniqueSavepointName() method which returns &quot;ISSP1&quot;, &quot;ISSP2&quot;, ...&lt;/p&gt;</comment>
                            <comment id="12536446" author="james.f.adams" created="Sat, 20 Oct 2007 18:14:07 +0100"  >&lt;p&gt;Attached is a patch proposal (derby-3093_diff.txt) for review.&lt;/p&gt;

&lt;p&gt;Files modified: org.apache.derby.impl.sql.conn.GenericStatementContext.java&lt;/p&gt;

&lt;p&gt;I changed the way the internal savepoint name isgenerated that should provide unique savepoint names.&lt;/p&gt;

&lt;p&gt;Derbyall and suites.All ran cleanly. &lt;/p&gt;</comment>
                            <comment id="12536476" author="knutanders" created="Sat, 20 Oct 2007 23:35:09 +0100"  >&lt;p&gt;Thanks for the patch. It looks like a good solution to me. I&apos;ll run some tests and commit it.&lt;/p&gt;</comment>
                            <comment id="12536478" author="bryanpendleton" created="Sun, 21 Oct 2007 01:45:21 +0100"  >&lt;p&gt;Thanks for working on this problem James!&lt;/p&gt;

&lt;p&gt;Two questions:&lt;/p&gt;

&lt;p&gt;1) The comments in the JIRA issue talked about making a counter which was unique-per-transaction,&lt;br/&gt;
but the patch looks like it chose a static field instead. Your solution seems fine to me, but since I&lt;br/&gt;
noticed this I thought I&apos;d mention it, and make sure that this was intentional.&lt;/p&gt;

&lt;p&gt;2) It would be nice to have a test program for this situation, particularly since the problem was&lt;br/&gt;
intermittent. Is there a way to describe a test that demonstrates the superiority of the new&lt;br/&gt;
savepoint naming technique?&lt;/p&gt;</comment>
                            <comment id="12536517" author="kristwaa" created="Sun, 21 Oct 2007 19:21:03 +0100"  >&lt;p&gt;Fixed typo in summary (typo was in a keyword, fixed it to make searching easier) and classified the bug as SQL. Also added version 10.2.2.0 and 10.1.3.1 to the affects list, as the same naming scheme is used there.&lt;br/&gt;
In my opinion, this fix should at least be ported to the 10.2 branch, possibly also the 10.1 branch.&lt;/p&gt;</comment>
                            <comment id="12536529" author="james.f.adams" created="Sun, 21 Oct 2007 20:22:44 +0100"  >&lt;p&gt;Bryan,&lt;/p&gt;

&lt;p&gt;With regards to your comments:&lt;/p&gt;

&lt;p&gt;1) Yes it was intentional.  It seemed the most straight forward to implement the name creation without making it unique per transaction.&lt;br/&gt;
2) I am not sure how we could test this but any suggestions are of course welcome.&lt;/p&gt;</comment>
                            <comment id="12536540" author="knutanders" created="Sun, 21 Oct 2007 22:21:22 +0100"  >&lt;p&gt;When I suggested a savepoint name that was unique within a transaction, instead of a globally unique name, it was primarily to avoid the need for synchronization. But when I thought more about it, I think that it would be unnecessarily complex without adding significant value, so James&apos;s simpler solution sounds better to me.&lt;/p&gt;

&lt;p&gt;Committed the patch to trunk with revision 586956 and to 10.3 with revision 586957.&lt;/p&gt;

&lt;p&gt;I intend to commit the fix on the 10.2 branch as well, as requested by Kristian.&lt;/p&gt;</comment>
                            <comment id="12536542" author="knutanders" created="Sun, 21 Oct 2007 22:32:49 +0100"  >&lt;p&gt;As to Bryan&apos;s questions about tests, I think this bug is inherently intermittent, and even if we were able to write a test to reproduce it, it would probably be very sensitive to JVM and gc/timing. Combined with the low probability of reintroducing this bug, and the fact that we already have tests that will start failing intermittently if it is reintroduced, I feel comfortable with committing the patch without adding tests.&lt;/p&gt;</comment>
                            <comment id="12536545" author="bryanpendleton" created="Sun, 21 Oct 2007 23:13:51 +0100"  >&lt;p&gt;&amp;gt; James&apos;s simpler solution sounds better&lt;/p&gt;

&lt;p&gt;I agree. The new code is simple and clear. Thanks for the follow-up!&lt;/p&gt;</comment>
                            <comment id="12536565" author="myrna" created="Mon, 22 Oct 2007 05:26:32 +0100"  >&lt;p&gt;I am hoping that this issue is the cause of the intermittent test failures that have been reported with some of the IBM jvms, see &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2808&quot; title=&quot;triggerRecursion.sql and triggerGeneral.sql intermittently fail with SAVEPOINT error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2808&quot;&gt;&lt;del&gt;DERBY-2808&lt;/del&gt;&lt;/a&gt;, and see for instance &lt;a href=&quot;http://people.apache.org/~fuzzylogic/derby_test_results/main/testSummary-582051.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://people.apache.org/~fuzzylogic/derby_test_results/main/testSummary-582051.html&lt;/a&gt;&lt;br/&gt;
(Although, apparently, these results haven&apos;t been updated for several weeks).&lt;/p&gt;

&lt;p&gt;I&apos;ll keep an eye out for new reports, or run some tests myself, and see if we can close that one off as a duplicate, or as &apos;fixed&apos;.&lt;/p&gt;

</comment>
                            <comment id="12536597" author="knutanders" created="Mon, 22 Oct 2007 09:47:53 +0100"  >&lt;p&gt;Committed to 10.2 with revision 587034.&lt;/p&gt;

&lt;p&gt;Thanks James for fixing the bug, and Myrna for volunteering to keep an eye on the other failures.&lt;/p&gt;</comment>
                            <comment id="12536722" author="djd" created="Mon, 22 Oct 2007 17:03:41 +0100"  >&lt;p&gt;I&apos;m close to -1 on this patch, it introduces a single point of synchronization where one is not required. Knut Anders (I think?) has already shown the cost of one of these in Derby with the synchronization required for ensuring the statement plan is up to date.&lt;/p&gt;</comment>
                            <comment id="12536770" author="knutanders" created="Mon, 22 Oct 2007 19:01:48 +0100"  >&lt;p&gt;Isn&apos;t this a cost that you only get when you prepare a statement, not during execution? But Dan is right, that was the reason why I initially suggested names unique only within transaction.&lt;/p&gt;

&lt;p&gt;Still, without the patch, Derby&apos;s behaviour is buggy, so I don&apos;t think backing the patch out will improve the situation. Anyone is free to improve the code, though.&lt;/p&gt;</comment>
                            <comment id="12536782" author="djd" created="Mon, 22 Oct 2007 19:20:58 +0100"  >&lt;p&gt;No, this is an execution time cost for every statement. Though the first two statements on the stack will not hit this as Derby caches two statement contexts per connection.&lt;/p&gt;

&lt;p&gt;Non-final static fields are really something to be avoided in Java, especially in Derby. This synchronizes statements across all connections in all databases using the same Derby version within a single vm.&lt;/p&gt;</comment>
                            <comment id="12536801" author="knutanders" created="Mon, 22 Oct 2007 20:15:58 +0100"  >&lt;p&gt;Thanks Dan. In that case I agree that this should be addressed before the issue is closed. James, are you willing to work on making the proposed changes?&lt;/p&gt;</comment>
                            <comment id="12536814" author="mikem" created="Mon, 22 Oct 2007 21:01:23 +0100"  >&lt;p&gt;Given dan&apos;s observation will this be backed out of the branches until the correct fix is available.  &lt;br/&gt;
If someone is signed up to work on it actively I am not as concerned about the trunk.&lt;/p&gt;</comment>
                            <comment id="12536873" author="james.f.adams" created="Tue, 23 Oct 2007 01:38:36 +0100"  >&lt;p&gt;I will attempt to make the necessary changes.&lt;/p&gt;

&lt;p&gt;In looking a bit further I found that the LanguageConnectionContext that is passed into the constructor for GenericStatementContext has a method called getUniqueSavepointName that has the following description:&lt;/p&gt;

&lt;p&gt;                                   Get a connection unique system generated name for an unnamed savepoint.&lt;/p&gt;

&lt;p&gt;Would it be appropriate to use this method to create the savepoint name?  If so I will create a new patch that incorporates it.&lt;/p&gt;</comment>
                            <comment id="12536943" author="knutanders" created="Tue, 23 Oct 2007 09:23:15 +0100"  >&lt;p&gt;Mike, I have backed out the fix from 10.2 and 10.3. Leaving it in trunk since James said he&apos;ll make the improvements.&lt;/p&gt;</comment>
                            <comment id="12536947" author="knutanders" created="Tue, 23 Oct 2007 10:08:12 +0100"  >&lt;p&gt;James, I think LanguageConnectionContext.getUniqueSavepointName() should work. That is, unless there&apos;s a possibility that two LCC instances have the same TransactionController, it shouldn&apos;t cause duplicate savepoint names. It would be great if someone who&apos;s more familiar with this area of the code could comment on whether that&apos;s possible.&lt;/p&gt;</comment>
                            <comment id="12537035" author="djd" created="Tue, 23 Oct 2007 16:04:08 +0100"  >&lt;p&gt;getUniqueSavepointName will work - good find.&lt;/p&gt;

&lt;p&gt;The main relationship for these objects is:&lt;/p&gt;

&lt;p&gt;EmbedConnection   1-1  LanguageConnectionContext  1-1* TransactionController&lt;/p&gt;

&lt;p&gt;Only one thread is active within these objects at any time (save for garbage collection), this is enforced by synchronization at the JDBC (EmbedConnection) layer.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;A nested internal transaction leads to another TransactionController but not relevant here.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12537175" author="james.f.adams" created="Wed, 24 Oct 2007 01:00:46 +0100"  >&lt;p&gt;Attached is an updated patch proposal that uses LanguageConnectionContext.getUniqueSavepointName to generate the savepoint names.  The test cannons for savepointJdbc30_JSR169 and savepointJdbc30_XA needed to be modified as some exception text was affected by the change.&lt;/p&gt;

&lt;p&gt;Ran Derbyall and suites.All with no new errors.&lt;/p&gt;</comment>
                            <comment id="12537181" author="djd" created="Wed, 24 Oct 2007 01:31:36 +0100"  >&lt;p&gt;I think we can just use getUniqueSavepointName() as-is.&lt;/p&gt;

&lt;p&gt;ie. replace&lt;/p&gt;

&lt;p&gt;internalSavePointName = &quot;ISSP&quot; + lcc.getUniqueSavepointName();&lt;/p&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;p&gt;internalSavePointName = lcc.getUniqueSavepointName();&lt;/p&gt;</comment>
                            <comment id="12537194" author="james.f.adams" created="Wed, 24 Oct 2007 04:24:41 +0100"  >&lt;p&gt;Updated patch replacing&lt;/p&gt;

&lt;p&gt;internalSavePointName = &quot;ISSP&quot; + lcc.getUniqueSavepointName();&lt;/p&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;p&gt;internalSavePointName = lcc.getUniqueSavepointName();&lt;/p&gt;


&lt;p&gt;Ran Derbyall and suites.All with no new errors.&lt;/p&gt;</comment>
                            <comment id="12537569" author="knutanders" created="Thu, 25 Oct 2007 12:28:44 +0100"  >&lt;p&gt;The fix looks good and the changes to the master files make sense. All tests ran cleanly in my environment. Committed revision 588202.&lt;/p&gt;</comment>
                            <comment id="12542005" author="myrna" created="Tue, 13 Nov 2007 00:38:24 +0000"  >&lt;p&gt;The improved fix went in more than two weeks ago, and it seems to have made a difference in the occurrences of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2808&quot; title=&quot;triggerRecursion.sql and triggerGeneral.sql intermittently fail with SAVEPOINT error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2808&quot;&gt;&lt;del&gt;DERBY-2808&lt;/del&gt;&lt;/a&gt; in trunk.&lt;/p&gt;

&lt;p&gt;Any objections to backporting this to 10.3, 10.2 and 10.1?&lt;/p&gt;

</comment>
                            <comment id="12543617" author="kmarsden" created="Mon, 19 Nov 2007 17:18:13 +0000"  >&lt;p&gt;I plan to merge this fix to 10.3. Please let me know if you have any concerns.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12371073">DERBY-2773</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12371419">DERBY-2804</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12371504">DERBY-2808</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12368263" name="derby-3093-2_diff.txt" size="4829" author="james.f.adams" created="Wed, 24 Oct 2007 01:00:44 +0100"/>
                            <attachment id="12368267" name="derby-3093-3_diff.txt" size="4820" author="james.f.adams" created="Wed, 24 Oct 2007 04:24:41 +0100"/>
                            <attachment id="12368078" name="derby-3093_diff.txt" size="1223" author="james.f.adams" created="Sat, 20 Oct 2007 18:14:07 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 17 Oct 2007 00:42:33 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23426</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0m0v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37386</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>