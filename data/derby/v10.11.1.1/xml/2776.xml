<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:41:41 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2776/DERBY-2776.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2776] Internally generated CAST nodes should not use the collation of the current compilation schema. Instead they should use collation of target type passed to it.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2776</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;As per the wiki page &lt;a href=&quot;http://wiki.apache.org/db-derby/BuiltInLanguageBasedOrderingDERBY-1478&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/BuiltInLanguageBasedOrderingDERBY-1478&lt;/a&gt;, Section Collation Determination, Rule 4), result of CAST will take the collation of the current compilation schema. This is what Derby 10.3 codeline has implemented for CAST in the CastNode.bindCastNodeOnly() method.&lt;/p&gt;

&lt;p&gt;But that is not the right thing to do for CAST nodes that get generated internally. One specific example of such a case&lt;/p&gt;

&lt;p&gt;connect &apos;jdbc:derby:c:/dellater/db1Norway;create=true;territory=no;collation=TERRITORY_BASED&apos;;&lt;br/&gt;
create table t (id int, type char(10), typeVarchar varchar(10));&lt;br/&gt;
insert into t values (1,&apos;CAR&apos;,&apos;CAR&apos;),(2,&apos;SUV&apos;,&apos;SUV&apos;); &lt;br/&gt;
set schema sys;&lt;br/&gt;
SELECT  type FROM app.t WHERE CASE WHEN 1=1 THEN type ELSE typevarchar END = type; &amp;#8211; the sql in question&lt;/p&gt;

&lt;p&gt;Note that the DTD associated with THEN clause expression is of type CHAR and the DTD associated with ELSE clause expression is of type VARCHAR. And in Derby, VARCHAR has higher type precedence than CHAR.&lt;/p&gt;

&lt;p&gt;Now, during the compilation of the SELECT statement above, the ConditionalNode.bindExpression makes following call which causes ConditionalNode to have a DTD which has same properties as the DTD of ELSE clause expression which is of type VARCHAR(since VARCHAR has higher type precedence than CHAR) with collation type of territory based and collation derivation of IMPLICIT. So far, so good. &lt;br/&gt;
  setType(thenElseList.getDominantTypeServices());&lt;/p&gt;

&lt;p&gt;Later, the ConditionalNode.bindExpression has following if statement which will return true for our specific SELECT statement&lt;br/&gt;
  if (thenTypeId.typePrecedence() != condTypeId.typePrecedence())&lt;br/&gt;
This is because the datatype(CHAR) of &quot;type&quot; in THEN clause does not have same type precedence as datatype(VARCHAR) of ConditionalNode and so the code inside the if statement in ConditionalNode.bindExpression generates a CAST node on the top of the THEN clause expression and that CAST node uses the SAME physical DTD of the ConditionalNode, which in this case is a VARCHAR datatype with collation type of territory based and collation derivation of IMPLICIT. Next,  ConditionalNode.bindExpression calls bind on the newly created cast node using following&lt;br/&gt;
   cast = cast.bindExpression(fromList, &lt;br/&gt;
           subqueryList,&lt;br/&gt;
           aggregateVector);&lt;br/&gt;
During the bind of the CAST, we always have the CAST node take the collation of the current compilation schema, which in this case is SYS and hence we end up assigining collation type of UCS_BASIC to DTD associated with the CAST node.. But since the CAST is associated with the same physical DTD that is used by the ConditionalNode, the ConditionalNode ends up having it&apos;s collation type changed from territory based to UCS_BASIC and this causes the above SELECT statement to fail at compilation time because of mismatch of collation type between CASE... = type. The left hand side of CASE... = type ends up having collation of UCS_BASIC whereas right hand side &quot;type&quot; has collation type of territory based and hence the SELECT compilation fails. This is incorrect behavior. The CASE node should have held on to it&apos;s collation type of territory based. &lt;/p&gt;

&lt;p&gt;Possible solution to the problem as discussed on Derby mailing list under title &quot;Collation info of internally generated CAST node&apos;&lt;br/&gt;
The setting of CAST node&apos;s collation type to current compilation schema&apos;s collation type can be moved out of CastNode.bindCastNodeOnly() method and into CastNode.bindExpression (). I checked through Derby code for internally generated CAST nodes and noticed that except for ConditionalNode, everywhere else, after the CAST node is created, we call CastNode.bindCastNodeOnly() method on it. For some unknown reason, ConditionalNode doesn&apos;t call just CastNode.bindCastNodeOnly() but instead calls CastNode.bindExpression(). So, the complete fix to the problem could be to have ConditionalNode call CastNode.bindCastNodeOnly() instead of CastNode.bindExpression() and the collation type setting moved into CastNode.bindExpression() from CastNode.bindCastNodeOnly().&lt;/p&gt;

&lt;p&gt;This solution will be cleaner if with the above solution to also have an explicit boolean field in CastNode that indicates if the CAST is internal or not. The use of different methods (as above) probably works, but those current method names don&apos;t imply the behaviour we are expecting them to implement. So there&apos;s some chance in the future that a new call may&lt;br/&gt;
break the assumptions. Having explicit code would be clear and easy to understand.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12371159">DERBY-2776</key>
            <summary>Internally generated CAST nodes should not use the collation of the current compilation schema. Instead they should use collation of target type passed to it.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="mamtas">Mamta A. Satoor</reporter>
                        <labels>
                    </labels>
                <created>Thu, 7 Jun 2007 18:58:41 +0100</created>
                <updated>Fri, 6 Jul 2007 15:42:20 +0100</updated>
                            <resolved>Fri, 6 Jul 2007 15:42:20 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12508407" author="mamtas" created="Wed, 27 Jun 2007 05:21:20 +0100"  >&lt;p&gt;Committed the patch for this jira entry into main codeline (10.4) using revision 551033. The commit comments are as follows. This should be ported to 10.3 codeline.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2776&quot; title=&quot;Internally generated CAST nodes should not use the collation of the current compilation schema. Instead they should use collation of target type passed to it.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2776&quot;&gt;&lt;del&gt;DERBY-2776&lt;/del&gt;&lt;/a&gt; Internally generated CAST nodes should not pick up the collation of the current schema. In order to implement this, the CAST nodes generated directly by the user sql (parser) will set a flag on the cast node to indicate that they are externally generated CAST nodes. During the bind phase of a CAST node, we will check if the node is externally generated. If yes, then we will have it pick up &lt;br/&gt;
the collation of the compilation schema otherwise we will leave the collation unchanged.&lt;/p&gt;</comment>
                            <comment id="12508760" author="mamtas" created="Thu, 28 Jun 2007 08:48:38 +0100"  >&lt;p&gt;With revision 551485, now the changes have been commited to 10.3 codeline also.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12368325">DERBY-2599</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23237</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy11hj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39891</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>