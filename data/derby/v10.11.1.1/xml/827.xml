<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:21:21 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-827/DERBY-827.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-827] Performance can be improved by re-using language ResultSets across Activation executions.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-827</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;&amp;gt;Shouldn&apos;t DistinctScalarAggregateRS implement a close or a finish method&lt;br/&gt;
&amp;gt;&amp;gt;(not sure what the difference is) and close the scan controller there.&lt;/p&gt;


&lt;p&gt;The close() and finish() methods are actually explained in their javadoc&lt;br/&gt;
in the language org.apache.derby.iapi.sql.ResultSet class.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;note this is not a JDBC java.sql.ResultSet object&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;close() -  Tells the system that there will be no more calls to&lt;br/&gt;
getNextRow() (until the next open() call)&lt;/p&gt;

&lt;p&gt;finish() - Tells the system that there will be no more access to any&lt;br/&gt;
database information via this result set&lt;/p&gt;

&lt;p&gt;So close means the ResultSet may be opened again for more access, while&lt;br/&gt;
finish means it will not be used again.&lt;/p&gt;

&lt;p&gt;However, their use in the code always doesn&apos;t match that, and that does&lt;br/&gt;
cause confusion, at least to me.&lt;/p&gt;

&lt;p&gt;Language ResultSets (not JDBC ones) can be and are opened multiple&lt;br/&gt;
times, for example when scanning a table multiple times within a join.&lt;/p&gt;

&lt;p&gt;An Activation, which represents the internal state of&lt;br/&gt;
java.sql.PreparedStatement object &amp;amp; has the lifetime of the&lt;br/&gt;
java.sql.PreparedStatement, contains a top-level language ResultSet.&lt;br/&gt;
This top-level language ResultSet provides the execution of the SQL&lt;br/&gt;
statement, DML, DDL or a query. The top-level ResultSet may contain&lt;br/&gt;
other ResultSets and could be seen as a tree structure. For the simple&lt;br/&gt;
case of a primary key lookup query like:&lt;/p&gt;

&lt;p&gt;   select name from customer where id = ?&lt;/p&gt;

&lt;p&gt;The activation would contain this:&lt;/p&gt;

&lt;p&gt;top result set&lt;br/&gt;
ProjectRestrictRS &amp;lt;&amp;lt; IndexRowToBaseRowRS &amp;lt;&amp;lt; TableScanRS&lt;/p&gt;

&lt;p&gt;Now for some reason, even though the api of ResultSet say they can be&lt;br/&gt;
re-used, and in some cases they are, this result set tree is thrown away&lt;br/&gt;
after each execution. That is, the top result set has its finish()&lt;br/&gt;
method called and then the activation removes its reference to it. Then&lt;br/&gt;
on the next execution a new (identical) tree is set up.&lt;/p&gt;

&lt;p&gt;There is potential for a huge performance gain if this top level result&lt;br/&gt;
set and its tree are re-used and have the same lifetime as the&lt;br/&gt;
Activation. The saving comes in two forms, not having to create many&lt;br/&gt;
objects on each execution, and not creating short-lived objects for the&lt;br/&gt;
garbage collector to handle.&lt;/p&gt;

&lt;p&gt;I made a simple fix, it&apos;s a couple of lines of code, just calling close&lt;br/&gt;
&amp;amp; finish at the correct times, and for the above simple primary key&lt;br/&gt;
lookup query, the performance went from 17,300 to 24,000 selects per&lt;br/&gt;
second (cached data, single user). I&apos;ll post a patch shortly as an&lt;br/&gt;
indication of the direction, once I can separate it from other changes&lt;br/&gt;
in my client.&lt;/p&gt;

&lt;p&gt;However, I&apos;m running the Derby tests and there are some (maybe 25-30)&lt;br/&gt;
failures, I think because not all the language ResultSet implementations&lt;br/&gt;
are correctly written to be re-opened. Interestingly, the first failure&lt;br/&gt;
I saw was in an aggregrate test, which goes back to the issue Manish saw.&lt;/p&gt;

&lt;p&gt;Even if derbyall passed I would be nervous about submitting this patch&lt;br/&gt;
for real, because I don&apos;t think there&apos;s a lot of testing using repeat&lt;br/&gt;
executions of PreparedStatements in the tests. The ij tests mainly use&lt;br/&gt;
Statement, this is a single use of an activation so this change would&lt;br/&gt;
not affect them. Thus such a patch could regress Derby by making it more&lt;br/&gt;
likely existing bugs would be exposed.&lt;/p&gt;

&lt;p&gt;Given the performance gains, I think we need to start re-using&lt;br/&gt;
ResultSets from Activation, and devise a way to ensure the testing&lt;br/&gt;
covers the re-use. The main issue is there is a large number of&lt;br/&gt;
ResultSet implementations to cover.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12327853">DERBY-827</key>
            <summary>Performance can be improved by re-using language ResultSets across Activation executions.</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dyret">Dyre Tjeldvoll</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                    </labels>
                <created>Fri, 20 Jan 2006 05:09:52 +0000</created>
                <updated>Wed, 3 Sep 2014 10:14:39 +0100</updated>
                            <resolved>Tue, 14 Aug 2007 07:45:22 +0100</resolved>
                                                    <fixVersion>10.3.1.4</fixVersion>
                                        <due></due>
                            <votes>3</votes>
                                    <watches>1</watches>
                                                                                                            <comments>
                            <comment id="12363294" author="djd" created="Fri, 20 Jan 2006 05:14:34 +0000"  >&lt;p&gt;Patch that re-uses language ResultSets across activation executions.&lt;br/&gt;
This is a draft patch to enable further testing only, around 25-30 tests fail with this patch.&lt;br/&gt;
Some possibly due to incorrect close logic in ResultSet implementations,&lt;br/&gt;
Some probably due to changes in runtime statistics output for items like the execution count.&lt;/p&gt;

&lt;p&gt;M      java\engine\org\apache\derby\impl\sql\execute\NoPutResultSetImpl.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\execute\BaseActivation.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\GenericActivationHolder.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\jdbc\EmbedResultSet.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\jdbc\EmbedStatement.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\sql\Activation.java&lt;/p&gt;</comment>
                            <comment id="12436640" author="djd" created="Thu, 21 Sep 2006 22:00:42 +0100"  >&lt;p&gt;Updated version of the patch, accounting for the fact some of the changes were made under &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1142&quot; title=&quot;Metadata calls leak memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1142&quot;&gt;&lt;del&gt;DERBY-1142&lt;/del&gt;&lt;/a&gt;. This is still an example patch, much more work is needed to ensure ResultSet implementations work as expected and can safely be re-used. Plus more testing of repeated use of PreparedStatements.&lt;/p&gt;</comment>
                            <comment id="12473644" author="dyret" created="Fri, 16 Feb 2007 08:54:35 +0000"  >&lt;p&gt;I&apos;ve attached a preliminary (hence no ASF license) patch that creates a new junit test that attempts to fill the mentioned gap in the existing test suites. The new test instantiates all ResultSets returned from GenericResultSetFactory from a PreparedStatement that is executed repeatedly. &lt;/p&gt;

&lt;p&gt;At this point all ResultSets except InsertVTIResultSet, DeleteVTIResultSet, UpdateVTIResultSet and MaterializedResultSet are created. According to the EMMA reports these ResultSets are never created when running derbyall or the junit tests, so I don&apos;t know how to write a test case that does.&lt;/p&gt;

&lt;p&gt;The preliminary version of this patch adds a println to the ResultSetFactory which shows the ResultSets that are instantiated and the Statement ID and query that did so. This makes it easier to see if the test does what it is supposed to, but would obviously have to be removed in a final version of the patch. &lt;/p&gt;

&lt;p&gt;Reviews/comments would be much appreciated. Thanks.&lt;/p&gt;</comment>
                            <comment id="12473703" author="dyret" created="Fri, 16 Feb 2007 13:49:06 +0000"  >&lt;p&gt;I tried to run the new test with latest version of Dan&apos;s patch, but only one test case, testLastIndexKeyResultSet fails. When I think about it I think it could be because this test case is one of few where the underlying table/data is changed between each execution of the PreparedStatement.&lt;/p&gt;
</comment>
                            <comment id="12473707" author="djd" created="Fri, 16 Feb 2007 14:04:33 +0000"  >&lt;p&gt;Thanks for working on this. I would recommend not using the ASF licence flag as an indicator for if the patch is ready to be used or not. I think a simple comment with the attachment is fine.&lt;br/&gt;
By not clicking the ASF licence flag you stop others from working on the patch, thus removing the chance for community development.&lt;/p&gt;</comment>
                            <comment id="12473792" author="dyret" created="Fri, 16 Feb 2007 19:10:10 +0000"  >&lt;p&gt;Attaching a modified test with better result checking, and that deletes rows from the underlying tables while executing PreparedStatements. (with ASF license this time, but it still isn&apos;t ready for inclusion).&lt;/p&gt;</comment>
                            <comment id="12473801" author="djd" created="Fri, 16 Feb 2007 19:32:53 +0000"  >&lt;p&gt;Thanks for marking it asf, makes it easier for others to look at it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Just looking at the test I couldn&apos;t see any described reason as to why the test breaks the model of a single connection per fixture and instead uses a shared connection and has code to manage a prepared statement cache. Is this addiitonal complexity (and more chance for bugs &amp;amp; confusion) needed for the test, or is it an attempt to make the test go faster? I think a cleaner approach to sharing connections across fixtures would be to have a connection pooling decorator, so that the test continues to look &amp;amp; feel like other tests.&lt;/p&gt;</comment>
                            <comment id="12474148" author="dyret" created="Mon, 19 Feb 2007 12:13:03 +0000"  >&lt;p&gt;It was not to make the test go faster. The goal was to reuse any PreparedStatement as much as possible. I admit that as the test stands this does not buy you all that much. I had originally planned to have many more (smaller) test cases where each test case reused a ps with different parameter values, (I was told that the JUnit way was to have small and simple test cases). In the end I gave up on that approach since the number of test cases became  unmanageable. But even now, the cache lets the PreparedStatements for creating tables and filling them (which is done in the beginning of most test cases) be reused. The same is true for some of the selects that are executed to verify that the content of a table is correct.&lt;/p&gt;

&lt;p&gt;But if the added complexity outweighs the benefit of repeated execution of all PreparedStatements, then I can always change it. I may have to add another test case or two if some ResultSets only get created from PreparedStatements that are shared across test cases through the cache. &lt;/p&gt;

&lt;p&gt;Not sure about how the connection pool decorator would work. It would have to be a very special pool with only one entry, since the goal isn&apos;t to improve speed, but to force every instance of a query to use an existing prepared statement if available.  &lt;/p&gt;</comment>
                            <comment id="12474214" author="djd" created="Mon, 19 Feb 2007 16:00:21 +0000"  >&lt;p&gt;Dyre&amp;gt; I had originally planned to have many more (smaller) test cases where each test case reused a ps with different parameter values, (I was told that the JUnit way was to have small and simple test cases). In the end I gave up on that approach since the number of test cases became  unmanageable.&lt;/p&gt;

&lt;p&gt;That&apos;s how I&apos;d thought the test would be, I&apos;m intrigued by what made it unmanageable, a fixture is just a Java method.&lt;/p&gt;</comment>
                            <comment id="12474379" author="dyret" created="Tue, 20 Feb 2007 08:59:35 +0000"  >&lt;p&gt;Now I&apos;m utterly confused. Just to be clear: What I&apos;ve been calling a &quot;test case&quot;, that is what you refer to as a &quot;fixture&quot;? (a method in the JUnit class that has the prefix &quot;test&quot;)&lt;/p&gt;

&lt;p&gt;Assuming that is true:&lt;/p&gt;

&lt;p&gt;You want each fixture to execute a prepared statement only once with a given set of parameters?&lt;br/&gt;
But you don&apos;t want a framework for sharing connections/prepared statements between fixtures?&lt;/p&gt;

&lt;p&gt;Sorry for being slow here, but I don&apos;t see how I can satisfy both these requirements AND execute the same prepared statement multiple times. That WAS the primary goal, wasn&apos;t it? &lt;/p&gt;

&lt;p&gt;Could you perhaps re-write one of the fixtures the way you think it should be and post it? That would be really helpful. &lt;/p&gt;</comment>
                            <comment id="12474456" author="djd" created="Tue, 20 Feb 2007 14:44:58 +0000"  >&lt;p&gt;Yes, fixture = test case&lt;/p&gt;

&lt;p&gt;Sorry, I meant to say that each fixture would prepare its own statement and then execute it multiple times. i thpught that&apos;s what you had meant by &quot;each test case reused a ps with different parameter values&quot;.&lt;/p&gt;

&lt;p&gt;public void testSomething() {&lt;br/&gt;
    PreparedStatement ps = prepareStatement(&quot;some SQL&quot;);&lt;/p&gt;

&lt;p&gt;     for at least three times &lt;/p&gt;
{
         // set the parameters (at least once without reseting so same values are used)
         // execute
         // check results
     }

&lt;p&gt;      ps.close();&lt;br/&gt;
}&lt;/p&gt;
</comment>
                            <comment id="12474516" author="dyret" created="Tue, 20 Feb 2007 18:11:07 +0000"  >&lt;p&gt;Thanks for the clarification. I&apos;ll upload a new patch when I&apos;ve added &apos;repeat execution with existing values&apos;-testing where it applies. &lt;/p&gt;

&lt;p&gt;Not all PreparedStatements in this test have parameters. Sometimes I don&apos;t see how to add a parameter that will actually affect the ResultSets that are created/tested. E.g. some of the joins can always be parameterized by adding &apos;where col = ?&apos; but I think that will only feed the result through a ProjectRestrictResultSet? And changing the parameter will then only affect the ProjectRestrictResultSet? I&apos;m not sure, but that&apos;s how it looks...&lt;/p&gt;

&lt;p&gt;Also the ps used to create OnceResultSets seems like a candidate for adding parameters. But when I tried that it no longer created OnceResultSets... Maybe not that strange, given the name, but I thought I&apos;d ask...&lt;/p&gt;</comment>
                            <comment id="12474790" author="dyret" created="Wed, 21 Feb 2007 18:42:13 +0000"  >&lt;p&gt;Forget the Q about OnceResultSet. Figured it out...&lt;/p&gt;</comment>
                            <comment id="12476089" author="dyret" created="Tue, 27 Feb 2007 08:03:57 +0000"  >&lt;p&gt;I&apos;ve attached a complete patch (v1) for the new test. It runs cleanly on trunk, but two fixtures fail when running with derby827_update920.txt applied. The new test has been added to lang._Suite. Please comment/review.&lt;/p&gt;</comment>
                            <comment id="12476182" author="dyret" created="Tue, 27 Feb 2007 14:26:52 +0000"  >&lt;p&gt;The two fixtures are testLastIndexKeyResultSet and testOnceResultSet. &lt;/p&gt;

&lt;p&gt;I don&apos;t yet know what is causing the second failure, but the first is caused by the boolean member variable LastIndexKeyResultSet.returnedRow not being set to false in LastIndexKeyResultSet.close(). If this variable is true, the RS will clear its &apos;currentRow&apos; variable before returning it. Re-executing a ps that has created a LastIndexKeyResultSet will then give an empty result, rather than the max as it did on the first execution.&lt;/p&gt;

&lt;p&gt;Would it not have been better to throw an exception when returnedRow is true? Isn&apos;t this an error for this type of RS?&lt;/p&gt;</comment>
                            <comment id="12476355" author="dyret" created="Tue, 27 Feb 2007 20:08:37 +0000"  >&lt;p&gt;The failure in testOnceResultSet happens because the startKeyGetter of the TableScanResultSet returns the same key when the PS is re-executed even though this key depends on the PS-parameters and the current content of the emp table. &lt;/p&gt;

&lt;p&gt;This seems related to how the startKeyGetter code is generated from a OnceResultSet. For an &quot;ordinary&quot; query (select * from emp where name = ?),  &lt;br/&gt;
startKeyGetter returns the correct key (the current parameter value). OnceResultSet.getNextRowCore() only gets called the first time the PS gets executed, and then it returns &apos;ASHOK&apos;. Seems like somehow this value gets &quot;hard coded&quot; into the startKeyGetter code...&lt;/p&gt;

&lt;p&gt;Example:&lt;br/&gt;
prepare tst2 as &apos;select * from emp where name = (select name from emp where c0 &amp;lt;= ? intersect select name from emp where c0 &amp;gt;= ?)&apos;;&lt;/p&gt;

&lt;p&gt;execute tst2 using &apos;values (1,1)&apos;;&lt;br/&gt;
&amp;#8211; =&amp;gt; ASHOK&lt;br/&gt;
execute tst2 using &apos;values (2,2)&apos;;&lt;br/&gt;
&amp;#8211; =&amp;gt; still ASHOK, but should be JOHN&lt;/p&gt;

&lt;p&gt;prepare tst3 as &apos;select * from emp where name = ?&apos;;&lt;br/&gt;
execute tst3 using &apos;values (&apos;&apos;ASHOK&apos;&apos;)&apos;;&lt;br/&gt;
&amp;#8211; =&amp;gt; ASHOK as expected&lt;br/&gt;
execute tst3 using &apos;values (&apos;&apos;ROBIN&apos;&apos;)&apos;;&lt;br/&gt;
&amp;#8211; =&amp;gt; ROBIN as expected&lt;br/&gt;
execute tst3 using &apos;values (&apos;&apos;LILY2&apos;&apos;)&apos;;&lt;br/&gt;
&amp;#8211; =&amp;gt; LILY2 as expected&lt;/p&gt;</comment>
                            <comment id="12476681" author="dyret" created="Wed, 28 Feb 2007 19:16:05 +0000"  >&lt;p&gt;I can get the testOnceResultSet fixture to pass also, by doing&lt;/p&gt;

&lt;p&gt;A) Call reinitialize on all Qualifiers in TableScanResultSet.close(), and &lt;/p&gt;

&lt;p&gt;b) Change the following in SubqueryNode.java (I&apos;ve added &apos;&amp;amp;&amp;amp; false&apos; to the if-test. Effectively always choosing the else case)&lt;br/&gt;
 		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;If we have an expression subquery, then we&lt;/li&gt;
		&lt;li&gt;can materialize it if it has no correlated&lt;/li&gt;
		&lt;li&gt;column references and is invariant.&lt;br/&gt;
		*/&lt;br/&gt;
		if (isMaterializable() &amp;amp;&amp;amp; false)&lt;br/&gt;
		
{
			LocalField lf = generateMaterialization(acb, mb, subqueryTypeString);
			mbex.getField(lf);

		}
&lt;p&gt; else &lt;/p&gt;
{
			/* Generate the call to the new method */
			mbex.pushThis();
			mbex.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, mb.getName(), subqueryTypeString, 0);
		}&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;a) seems rather innocent, but b) seems problematic. Does it mean that all rows that are to be qualified need to evaluate the subquery repeatedly?&lt;/p&gt;

&lt;p&gt;I see that the resultsets in the subquery don&apos;t get created until the query is executed the first time. So obviously the generated byte code knows how to evaluate the entire subquery. The question is how to tell it to do that again when the TableScanResultSet is opened again, but not for each row...&lt;/p&gt;
</comment>
                            <comment id="12477237" author="knutanders" created="Fri, 2 Mar 2007 09:43:28 +0000"  >&lt;p&gt;Thanks for writing the test, Dyre. I think it is a valuable addition&lt;br/&gt;
to the test suite. I committed rsfromps.v1 with revision 513679.&lt;/p&gt;

&lt;p&gt;Some small comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertRow() and assertResultSet() duplicate functionality that is&lt;br/&gt;
    already implemented in JDBC.assertRowInResultSet() and&lt;br/&gt;
    JDBC.assertFullResultSet(). Perhaps they can be reused?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the use of try/finally in assertResultSet() might hide the&lt;br/&gt;
    original error if an exception is thrown from within the finally&lt;br/&gt;
    block.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the suite() method only runs the test in embedded mode. I think&lt;br/&gt;
    this is OK since it&apos;s a test of language result sets, but it would&lt;br/&gt;
    be good if there were a comment stating that explicitly. Or the&lt;br/&gt;
    test could be enabled in network client mode too (could be&lt;br/&gt;
    achieved by creating two test suites where one of them is wrapped&lt;br/&gt;
    by TestConfiguration.clientServerDecorator()).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;perhaps the empty test methods (those flagged with TODO) should be&lt;br/&gt;
    commented out? Now JUnit will report that they ran successfully&lt;br/&gt;
    whereas they haven&apos;t actually tested anything.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12477244" author="dyret" created="Fri, 2 Mar 2007 10:16:24 +0000"  >&lt;p&gt;Thanks for looking at the test Knut-Anders. I&apos;ll try to make a&lt;br/&gt;
followup-patch which addresses your comments.&lt;/p&gt;

&lt;p&gt;I did some more poking around in a debugger and I now think that&lt;br/&gt;
materialization of subqueries whose values are used as qualifiers&lt;br/&gt;
in table scans, is unnecessary. The qualifier actually caches the&lt;br/&gt;
value itself after the first invocation of the byte code, so&lt;br/&gt;
optimizing the byte code to return a cached value also, seems&lt;br/&gt;
redundant. This may be different in cases where the subquery isn&apos;t&lt;br/&gt;
used as a qualifier.&lt;/p&gt;

&lt;p&gt;I think the byte code generation for sub queries must be changed so&lt;br/&gt;
that it matches the changes in derby827_update920.txt, and keeps a&lt;br/&gt;
reference to internal resultsets created by the subquery during the&lt;br/&gt;
initial execution. Subsequent executions would only check for a valid&lt;br/&gt;
result set tree and then return. That way the resultsets from the&lt;br/&gt;
subquery can be reused also.&lt;/p&gt;

&lt;p&gt;I&apos;m not quite sure what should go in the Activation.execute() stage,&lt;br/&gt;
and what should go into the ResultSet.open() stage. It seems like the&lt;br/&gt;
execute() stage is responsible for creating the resultset tree, and&lt;br/&gt;
that ResultSet.open() should propagate to open() (openCore()) calls&lt;br/&gt;
down the tree? That would give the execute() stage very little to do&lt;br/&gt;
when the result sets are already there? Anyway, with this strategy&lt;br/&gt;
TableScanResultSet.close() would invalidate the qaulifier cache, and&lt;br/&gt;
the next use of the qualifier would trigger a sequence of open calls&lt;br/&gt;
to the subquery result set tree.&lt;/p&gt;

&lt;p&gt;Materialization of subqueries becomes a problem here, beacuse with it&lt;br/&gt;
one needs some way of invalidating the materialization (as well as the&lt;br/&gt;
qualifier cache) when a single execution is complete. Assuming that&apos;s&lt;br/&gt;
doable somehow, which stage should then be responsible for placing a&lt;br/&gt;
new qualifier inside the TableScanResultSet? Seems kind of awkward to&lt;br/&gt;
let rs.open() manipulate its own state that way. On the other hand,&lt;br/&gt;
letting the execution stage re-open the subquery result set tree to&lt;br/&gt;
get the new materialization and stuff into the existing&lt;br/&gt;
TableScanResultSet doesn&apos;t seem very clean either...&lt;/p&gt;

&lt;p&gt;Feel free to provide opinions/comments/suggestions/advice...&lt;/p&gt;</comment>
                            <comment id="12481947" author="dyret" created="Sun, 18 Mar 2007 14:55:09 +0000"  >&lt;p&gt;It does not seem like this issue is anyone&apos;s itch but mine,&lt;br/&gt;
but I thought I&apos;d nevertheless record what what I found so&lt;br/&gt;
far. I&apos;ve tried running the JUnit tests with the patch to&lt;br/&gt;
see what&apos;s causing the failures (there are a few).&lt;/p&gt;

&lt;p&gt;A subset of the failures seem to be due to the fact that the&lt;br/&gt;
ownership of SQLChar&apos;s FormatIdStream (inherited by SQLClob) is&lt;br/&gt;
unclear. SQLChar itself seems to use the state of this stream as&lt;br/&gt;
part of its own state. Specifically, it assumes that if its&lt;br/&gt;
&apos;value&apos; and &apos;rawData&apos; members are null but &apos;stream&apos; member isn&apos;t,&lt;br/&gt;
then it can read its value from the stream.&lt;/p&gt;

&lt;p&gt;But when doing EmbedResultSet.getClob() the very same&lt;br/&gt;
stream is passed to the client which may do anything with it. The&lt;br/&gt;
problem occurs when the reused XResultSet calls openCore() which&lt;br/&gt;
tries to clone the candidate row which still referencs exhausted&lt;br/&gt;
stream. The cloning fails with an exception.&lt;/p&gt;

&lt;p&gt;So should XResultSet.close() simply set all stream references in&lt;br/&gt;
the candidate row to null? Or should this be done sooner? An&lt;br/&gt;
annoyance is that SQLChar.toString() depends on getString() which&lt;br/&gt;
in turn depends on the stream. So at any point after giving the&lt;br/&gt;
stream to the client it may be unsafe to call toString() on the&lt;br/&gt;
SQLChar object (and thereby on the candidate row).&lt;/p&gt;</comment>
                            <comment id="12482065" author="dyret" created="Mon, 19 Mar 2007 12:26:12 +0000"  >&lt;p&gt;I tried adding the following to BulkTableScanResultSet.close():&lt;/p&gt;

&lt;p&gt;		// Set the candidate back to NULL to prepare for another open&lt;br/&gt;
		DataValueDescriptor[] c = candidate.getRowArray();&lt;br/&gt;
		if (c != null) {&lt;br/&gt;
			for (int i = 0; i &amp;lt; c.length; ++i) &lt;/p&gt;
{
				if (c[i] == null) continue;
				c[i] = c[i].getNewNull();
			}
&lt;p&gt;		}&lt;/p&gt;

&lt;p&gt;I would have preferred to use c&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;.setToNull(), since that would&lt;br/&gt;
reuse the DataValueDescriptor objects, (ideally one should be&lt;br/&gt;
able to reuse BulkTableScanResultSet.rowArray and associated&lt;br/&gt;
obejcts as well), but this doesn&apos;t work for all implementations&lt;br/&gt;
of DataValueDescriptor (e.g. HeapRowLoaction which will trigger&lt;br/&gt;
an ASSERT when doing this). &lt;/p&gt;

&lt;p&gt;Another alternative would be to switch on the real type of the&lt;br/&gt;
DataValueDescriptor and only call setToNull() for types that have&lt;br/&gt;
a stream (brittle and not very clean IMHO). Yet another&lt;br/&gt;
possibility would be null out the DVDs in the openCore() method&lt;br/&gt;
before cloning. This naturally leads to the question of why&lt;br/&gt;
openCore() wants a clone rather than a null copy...?&lt;/p&gt;

&lt;p&gt;With this change suites.All has 5 failures and 0 errors. 1 of&lt;br/&gt;
those failures are the testOnceResultSet failure mentioned&lt;br/&gt;
previously.&lt;/p&gt;</comment>
                            <comment id="12482333" author="dyret" created="Tue, 20 Mar 2007 08:26:18 +0000"  >&lt;p&gt;Of the 5 remaining failures in suites.All 3 come from&lt;br/&gt;
lang.TimeHandlingTest. The problem here seems to be yet another&lt;br/&gt;
variant of the &quot;byte code with stale values&quot;&lt;br/&gt;
problem. Specifically the RowResultSet created when using&lt;br/&gt;
CURRENT_TIMESTAMP, does not reset the byte code when it is closed&lt;br/&gt;
or opened again. The byte code appears to instantiate a&lt;br/&gt;
CurrentDatetime object that&apos;s reused for all subsequent&lt;br/&gt;
executions. Interestingly, this class has a finish() method that&lt;br/&gt;
resets it, but I don&apos;t understand how I call that method from say,&lt;br/&gt;
RowResultSet.close().&lt;/p&gt;</comment>
                            <comment id="12482396" author="djd" created="Tue, 20 Mar 2007 14:01:14 +0000"  >&lt;p&gt;I&apos;ll try and look into the CURRENT_TIMESTAMP issue, in writing that test I tried to understand how the current time was implemented.&lt;br/&gt;
The next execute of the activation automatically resets the current time value for the statement, which is held in the activation.&lt;br/&gt;
Maybe RowResultSet is only expecting constants?&lt;/p&gt;</comment>
                            <comment id="12482489" author="djd" created="Tue, 20 Mar 2007 19:14:20 +0000"  >&lt;p&gt;Is there a patch that changes the system to re-use the result sets? My patch from 21 Sep 06, by accident, has some additional unrelated changes to the time datatypes. So I was wondering if there&apos;s a new version that also includes and fixups to the ResultSets that you have been making?&lt;/p&gt;</comment>
                            <comment id="12482496" author="djd" created="Tue, 20 Mar 2007 19:28:04 +0000"  >&lt;p&gt;ps. I hope those unrelated changes are not causing the diffs you are seeing &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12482760" author="dyret" created="Wed, 21 Mar 2007 13:34:46 +0000"  >&lt;p&gt;Hi Dan, thanks for the feedback &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I&apos;ll try to answer your questions.&lt;/p&gt;

&lt;p&gt;Dan&amp;gt; Maybe RowResultSet is only expecting constants?&lt;/p&gt;

&lt;p&gt;Maybe. What I see is that calling&lt;br/&gt;
currentRow = (ExecRow) row.invoke(activation);&lt;br/&gt;
(in RowResultSet.getNextRowCore()) always returns the same set of&lt;br/&gt;
values for the columns, even for CURRENT_TIMESTAMP columns. &lt;/p&gt;


&lt;p&gt;Dan&amp;gt; Is there a patch that changes the system to re-use the result sets? &lt;/p&gt;

&lt;p&gt;Uh, I was under the impression that derby827_update920.txt did&lt;br/&gt;
just that. Anyway, that&apos;s the patch I have been running with,&lt;br/&gt;
plus the additional fixes I&apos;ve described in my comments.&lt;/p&gt;

&lt;p&gt;Dan&amp;gt; So I was wondering if there&apos;s a new version that also&lt;br/&gt;
includes and fixups to the ResultSets that you have been making?&lt;/p&gt;

&lt;p&gt;No, I have not created a new patch, mostly because even though&lt;br/&gt;
the fixups seemed to remove the symptoms, I wasn&apos;t sure that they&lt;br/&gt;
were really the best (most general) solution. But I can do that,&lt;br/&gt;
I just need to extract those changes from my sandbox.&lt;/p&gt;

&lt;p&gt;Dan&amp;gt; I hope those unrelated changes are not causing the diffs you are seeing&lt;/p&gt;

&lt;p&gt;I&apos;m not sure what the relation between SQLTime and&lt;br/&gt;
SQLTimestamp (which were modified in derby827_update920.txt) and&lt;br/&gt;
impl/sql/execute/CurrentDatetime.java is. From my tracing it&lt;br/&gt;
seemed like the latter is responsible for the cached&lt;br/&gt;
CURRENT_TIMESTAMP. At least I reached a breakpoint in&lt;br/&gt;
CurrentDatetime.getCurrentTimestamp() and the call-stack in the&lt;br/&gt;
debugger suggested that the call to this method came from&lt;br/&gt;
generated byte code.&lt;/p&gt;

&lt;p&gt;I also checked CurrentDateTimeOperatorNode.generateExpression()&lt;br/&gt;
which has the following:&lt;/p&gt;

&lt;p&gt;			case CURRENT_TIMESTAMP: &lt;br/&gt;
				acb.getCurrentTimestampExpression(mb);&lt;br/&gt;
				break;&lt;/p&gt;

&lt;p&gt;ExpressionClassBuilder.getCurrentTimeStampExpression() looks like this:&lt;/p&gt;

&lt;p&gt;void getCurrentTimestampExpression(MethodBuilder mb) {&lt;br/&gt;
		// do any needed setup&lt;br/&gt;
		LocalField lf = getCurrentSetup();&lt;/p&gt;

&lt;p&gt;		// generated Java:&lt;br/&gt;
		//	  this.cdt.getCurrentTimestamp();&lt;br/&gt;
		mb.getField(lf);&lt;br/&gt;
		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,&lt;br/&gt;
			&quot;getCurrentTimestamp&quot;, &quot;java.sql.Timestamp&quot;, 0);&lt;/p&gt;

&lt;p&gt;So, my gut feeling is that those unrelated changes aren&apos;t to&lt;br/&gt;
blame, but I don&apos;t know...&lt;/p&gt;</comment>
                            <comment id="12482775" author="djd" created="Wed, 21 Mar 2007 14:25:19 +0000"  >&lt;p&gt;The getCurrentSetup() method called seems to set the generated execute() method correctly to call the forget() method of CurrentDateTime.&lt;br/&gt;
This should reset the CurrentDateTime on each execution of the activation.&lt;br/&gt;
(See ActivationClassBuilder.getCurrentSetup())&lt;/p&gt;

&lt;p&gt;If the forget wasn&apos;t been called that could cause the time not to be reset, but since activations are reused today and current timestamp seems to work ok, it doesn&apos;t seem like that is the problem.&lt;/p&gt;</comment>
                            <comment id="12482778" author="djd" created="Wed, 21 Mar 2007 14:31:26 +0000"  >&lt;p&gt;one more comment on the patch (derby827_update920.txt), it was an example patch of the intended direction.&lt;br/&gt;
It might need confirming that the functionality is correct and it does set up the re-use the result sets correctly in all situations.&lt;br/&gt;
It worked for me for the simple primary key lookup that I was testing with, no guarantees it does the right thing in all situations.&lt;br/&gt;
I don&apos;t know of any issues, but just wanted to throw that out there.&lt;/p&gt;</comment>
                            <comment id="12482796" author="dyret" created="Wed, 21 Mar 2007 15:20:32 +0000"  >&lt;p&gt;Here is a patch with ONLY the extra fixups that I&apos;ve been playing with. With only this patch applied to trunk suites.All runs without failures.&lt;/p&gt;</comment>
                            <comment id="12482820" author="dyret" created="Wed, 21 Mar 2007 16:22:59 +0000"  >&lt;p&gt;I realize that the patch is experimental, but it is the best&lt;br/&gt;
starting point I have &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Thanks for the explanation of getCurrentSetup(). In the debugger&lt;br/&gt;
I have seen forget() being called from the first call to&lt;br/&gt;
activation.execute(). But the next time activation.execute() gets&lt;br/&gt;
called not much is happening. &lt;/p&gt;

&lt;p&gt;So, somehow, much of the code is omitted when&lt;br/&gt;
activation.execute() is called the second time. I ran the&lt;br/&gt;
test (TimeHandlingTest.java) with some tracing and this is what I&lt;br/&gt;
get (right before the error occurs):&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): activation.e&lt;br/&gt;
xecute(): INSERT INTO TIME_ALL(ID, C_TS) VALUES (?, CURRENT TIMESTAMP)&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.forget()&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs.open()&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime FRESH TS&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-21 17:04:01.594&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-21 17:04:01.594&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-21 17:04:01.594&lt;br/&gt;
class org.apache.derby.impl.sql.execute.RowResultSet.getNextRowCore() currentRow&lt;br/&gt;
=&lt;/p&gt;
{ 1, NULL, NULL, 2007-03-21 17:04:01.594, 17:04:01, 17:04:01, 2007-03-21 17:04:
01.594, 2007-03-21 17:04:01.594 }
&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs opened&lt;br/&gt;
&amp;#8211; First execution OK current timestamp is 17:04:01.594&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): activation.e&lt;br/&gt;
xecute(): SELECT C_TS, D_TS0, D_TS1 FROM TIME_ALL WHERE ID = ?&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs.open()&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs opened&lt;br/&gt;
&amp;#8211; SELECT OK&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): activation.e&lt;br/&gt;
xecute(): INSERT INTO TIME_ALL(ID, C_TS) VALUES (?, CURRENT TIMESTAMP)&lt;br/&gt;
&amp;#8211; Oops, no call to finish here&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs.open()&lt;br/&gt;
&amp;#8211; Oops, no FRESH TS here&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-21 17:04:01.594&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-21 17:04:01.594&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-21 17:04:01.594&lt;br/&gt;
class org.apache.derby.impl.sql.execute.RowResultSet.getNextRowCore() currentRow&lt;br/&gt;
=&lt;/p&gt;
{ 2, NULL, NULL, 2007-03-21 17:04:01.594, 17:04:01, 17:04:01, 2007-03-21 17:04:
01.594, 2007-03-21 17:04:01.594 }
&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs opened&lt;br/&gt;
&amp;#8211; Second execution is still giving 17:04:01.594&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): activation.e&lt;br/&gt;
xecute(): SELECT C_TS, D_TS0, D_TS1 FROM TIME_ALL WHERE ID = ?&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs.open()&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs opened&lt;br/&gt;
&amp;#8211; SELECT returns the same value as before&lt;/p&gt;

&lt;p&gt;junit.framework.AssertionFailedError: CURRENT TIME before start of statement&lt;br/&gt;
&amp;#8211; Triggers junit assert&lt;/p&gt;

&lt;p&gt;I can create a patch with this trace, if that is of any use...&lt;/p&gt;</comment>
                            <comment id="12482855" author="djd" created="Wed, 21 Mar 2007 17:54:29 +0000"  >&lt;p&gt;The issue is in StatementNode.generate().&lt;/p&gt;

&lt;p&gt;I think the generated code will be somewhat equivalent to:&lt;/p&gt;

&lt;p&gt;   if (resultSet == null)&lt;/p&gt;
   {
      resultSet = ...
      cdt.forget();
   }
&lt;p&gt;   else&lt;br/&gt;
   {&lt;/p&gt;

&lt;p&gt;   }&lt;br/&gt;
   return resultSet;&lt;/p&gt;

&lt;p&gt;This works fine when the top level result set is never reused, but breaks once the result set is re-used,&lt;br/&gt;
since the intention for the forget() call would be once per execution, but re-using the result set changes it to once per activation.&lt;/p&gt;

&lt;p&gt;Some cleanup/clarification is needed here for this issue as the execute() method is being used both to generate a result set tree&lt;br/&gt;
and perform per-execution tasks.&lt;/p&gt;
</comment>
                            <comment id="12482879" author="djd" created="Wed, 21 Mar 2007 19:08:45 +0000"  >&lt;p&gt;d827_execute_cleanup is a patch that cleans up the generation of the execute method and cleans up comments to reflect reality.&lt;br/&gt;
E.g. that fillResultSet() is required to create a result set, not just an artifact of a code generation limit (which no longer exists anyway).&lt;/p&gt;

&lt;p&gt;I think this will fix the problem with current_timestamp you are seeing, &lt;/p&gt;

&lt;p&gt;I&apos;ve run limited testing on this, will run the complete tests, this can be committed independent of any re-use of ResultSet change, it&apos;s basically just cleanup that clarifies how execute &amp;amp; fillResultSet work.&lt;/p&gt;</comment>
                            <comment id="12482963" author="djd" created="Wed, 21 Mar 2007 23:55:40 +0000"  >&lt;p&gt;Tests pass for d827_execute_cleanup (derbyall &amp;amp; suites.All on IBM 1.5). Any feedback on the patch or if it solves the failures in current timestamp would be useful.&lt;/p&gt;</comment>
                            <comment id="12483080" author="dyret" created="Thu, 22 Mar 2007 09:56:11 +0000"  >&lt;p&gt;Thank you for looking at this. I have tried running with your&lt;br/&gt;
patch in my sandbox with tracing and it does indeed seem to solve&lt;br/&gt;
the problem I was seeing. However TimeHandlingTest still does&lt;br/&gt;
not pass when reusing resultsets, but this seems to be due to an&lt;br/&gt;
unrelated &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; problem. &lt;/p&gt;

&lt;p&gt;The problem appears to be that CurrentDatetime gets the current&lt;br/&gt;
time by instantiating a java.util.Date object, but the test&lt;br/&gt;
calculates the current time after the query has executed by&lt;br/&gt;
instantiating a java.sql.Timestamp object with the value returned&lt;br/&gt;
from System.currentTimeMillis(). When the test fails the number&lt;br/&gt;
of ms returned from java.util.Date.getTime() is typically 1-2&lt;br/&gt;
higher than the value used to create the java.sql.Timestamp (even&lt;br/&gt;
though this value was obtained AFTER the query had executed):&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.compile.ActivationClassBuilder.getCurrentSetup()&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.&amp;lt;init&amp;gt;&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): activation.e&lt;br/&gt;
xecute(): VALUES (CURRENT TIMESTAMP, CURRENT_TIMESTAMP),(CURRENT TIMESTAMP, CURR&lt;br/&gt;
ENT_TIMESTAMP),(CURRENT TIMESTAMP, CURRENT_TIMESTAMP)&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.forget()&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs.open()&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.forget()&lt;br/&gt;
class org.apache.derby.impl.sql.GenericPreparedStatement.execute(): rs opened&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime FRESH TS&lt;br/&gt;
currentDatetime.getTime()=1174555658423&lt;br/&gt;
&amp;#8211; First row&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-22 10:27:38.423&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-22 10:27:38.423&lt;br/&gt;
class org.apache.derby.impl.sql.execute.RowResultSet.getNextRowCore() currentRow&lt;br/&gt;
=&lt;/p&gt;
{ 2007-03-22 10:27:38.423, 2007-03-22 10:27:38.423 }
&lt;p&gt;&amp;#8211; OK so far&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.execute.CurrentDatetime.forget()&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime FRESH TS&lt;br/&gt;
currentDatetime.getTime()=1174555658426&lt;br/&gt;
&amp;#8211; This value is higher than the test expects, see below&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-22 10:27:38.426&lt;br/&gt;
class org.apache.derby.impl.sql.execute.CurrentDatetime.getCurrentTimestamp()=20&lt;br/&gt;
07-03-22 10:27:38.426&lt;br/&gt;
class org.apache.derby.impl.sql.execute.RowResultSet.getNextRowCore() currentRow&lt;br/&gt;
=&lt;/p&gt;
{ 2007-03-22 10:27:38.426, 2007-03-22 10:27:38.426 }
&lt;p&gt;&amp;#8211; Second row&lt;/p&gt;

&lt;p&gt;junit.framework.AssertionFailedError: CURRENT TIME after end of statement tsv=20&lt;br/&gt;
07-03-22 10:27:38.426 et=2007-03-22 10:27:38.424 start=1174555658411 end=1174555&lt;br/&gt;
658424&lt;br/&gt;
&amp;#8211; Fails because end=1174555658424 &amp;lt; currentDatetime.getTime()=1174555658426&lt;/p&gt;

&lt;p&gt;But I don&apos;t think this problem is related so please go ahead and commit &lt;br/&gt;
d827_execute_cleanup &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12483100" author="dyret" created="Thu, 22 Mar 2007 10:59:43 +0000"  >&lt;p&gt;Actually the analysis I presented in my previous comment is&lt;br/&gt;
completely wrong. Please disregard. The failure was caused by&lt;br/&gt;
some experimental debug code I had forgotten to remove. &lt;br/&gt;
Sorry about the confusion. TimeHandlingTest now passes for me.&lt;/p&gt;</comment>
                            <comment id="12483229" author="dyret" created="Thu, 22 Mar 2007 17:25:10 +0000"  >&lt;p&gt;I have run suites.All with ONLY derby827_update920.txt and&lt;br/&gt;
d827_execute_method_cleanup.txt to verify that&lt;br/&gt;
derby-827.extra.diff is still needed, and then I see 6 errors and 1&lt;br/&gt;
failure. After applying derby-827.extra.diff also, I see 3 errors:&lt;/p&gt;

&lt;p&gt;jdbcapi.AutoGenJDBC30Test.testResultSetGarbageCollection():&lt;br/&gt;
&quot;ASSERT FAILED you cannot insert rows after starting to drain&quot;&lt;/p&gt;

&lt;p&gt;and&lt;br/&gt;
jdbcapi.DriverMgrAuthenticationTest&lt;br/&gt;
jdbcapi.PoolDSAuthenticationTest&lt;/p&gt;

&lt;p&gt;the first fails consistently, but the latter two pass when the test is run separately.&lt;br/&gt;
Not sure what is going on there. &lt;/p&gt;

&lt;p&gt;But, at any rate, it seems reasonable to conclude that&lt;br/&gt;
d827_execute_method_cleanup.txt fixes both the timestamp issue AND the&lt;br/&gt;
OnceResultSet sub-query problem. Excellent work! Thanks Dan &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12483236" author="djd" created="Thu, 22 Mar 2007 17:34:00 +0000"  >&lt;p&gt;Great I will commit d827_execute_method_cleanup.txt.&lt;/p&gt;

&lt;p&gt;Just to be a broken record on the derby827_update920.txt patch, the changes to the SQLTime/Date/Timestamp classes are not intended for this bug and should just be discarded.&lt;/p&gt;</comment>
                            <comment id="12483283" author="dyret" created="Thu, 22 Mar 2007 19:26:36 +0000"  >&lt;p&gt;I think I&apos;ve figured out what the failure in&lt;br/&gt;
jdbcapi.AutoGenJDBC30Test.testResultSetGarbageCollection() is all&lt;br/&gt;
about. InsertResultSet doesn&apos;t implement its own close() method,&lt;br/&gt;
so when close() is called, only some super.close() gets&lt;br/&gt;
called. This is probably not a good idea since InsertResultSet&lt;br/&gt;
has quite a bit of specific state information that probably needs&lt;br/&gt;
to be reset before one can re-use it. This particular problem occurs&lt;br/&gt;
because InsertResultSet.autoGeneratedKeysRowsHolder.close() never&lt;br/&gt;
gets called, and hence autoGeneratedKeysRowsHolder.state is never&lt;br/&gt;
set back to its initial value. This, in turn, triggers the&lt;br/&gt;
ASSERT.&lt;/p&gt;

&lt;p&gt;Adding &lt;/p&gt;

&lt;p&gt;  public void close() throws StandardException &lt;/p&gt;
{
        super.close();
        if (autoGeneratedKeysRowsHolder != null) autoGeneratedKeysRowsHolder.close();
  }

&lt;p&gt;to InsertResultSet makes the test pass. But I&apos;m wondering if it&lt;br/&gt;
wouldn&apos;t be good to close/reset some (all?) of the other data&lt;br/&gt;
members, as well.&lt;/p&gt;</comment>
                            <comment id="12483616" author="dyret" created="Fri, 23 Mar 2007 14:28:46 +0000"  >&lt;p&gt;Inspired by the initial discussion in this issue and my own&lt;br/&gt;
observations, I have compiled and attached 3 lists:&lt;/p&gt;

&lt;p&gt;noclose_nofinish.txt: Lang ResultSets that neither override&lt;br/&gt;
close() nor finish() noclose_finish.txt: Lang ResultSets that&lt;br/&gt;
don&apos;t override close() but overrides finish() close_nofinish.txt:&lt;br/&gt;
Lang ResultSets that override close() but not finish()&lt;/p&gt;

&lt;p&gt;The explanation of the difference between close() and finish() makes sense to me, &lt;br/&gt;
but how does cleanUp() fit into this? &lt;/p&gt;

&lt;p&gt;Looking at DeleteResultSet as an example, it seems like cleanUp()&lt;br/&gt;
gets called at the end of open(). Presumably the author of the&lt;br/&gt;
class knew that all the cleanup could be done at the end of open,&lt;br/&gt;
and by calling the method &apos;cleanUp()&apos; rather than &apos;close()&apos; no&lt;br/&gt;
extra work would have to be done when the&lt;br/&gt;
ResultSet was closed. Maybe. I&apos;m just guessing here...&lt;/p&gt;</comment>
                            <comment id="12483857" author="dyret" created="Sat, 24 Mar 2007 16:45:19 +0000"  >&lt;p&gt;Dan&amp;gt; Just to be a broken record on the derby827_update920.txt&lt;br/&gt;
patch, the changes to the SQLTime/Date/Timestamp classes are not&lt;br/&gt;
intended for this bug and should just be discarded.&lt;/p&gt;

&lt;p&gt;I actually don&apos;t think this is a problem. Whenever I apply&lt;br/&gt;
derby827_update920.txt, I first revert to revision 448292 (which&lt;br/&gt;
the patch was created from) and then do svn up. The changes to&lt;br/&gt;
SQLTime/Date/Timestamp must have been added in some later&lt;br/&gt;
revision and svn is smart enough to see this and not&lt;br/&gt;
complain about it. After updating to HEAD svn stat shows that&lt;br/&gt;
SQLTime/Date/Timestamp have no local modifications.&lt;/p&gt;

&lt;p&gt;Here is the output from svn stat in my current sandbox:&lt;/p&gt;

&lt;p&gt;dt136804@khepri29~/exp/derby-clean$ svn stat &lt;br/&gt;
?      derby-827.extra.diff&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/LastIndexKeyResultSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/BulkTableScanResultSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/execute/AnyResultSet.java&lt;br/&gt;
M      java/engine/org/apache/derby/impl/sql/GenericActivationHolder.java&lt;br/&gt;
M      java/engine/org/apache/derby/iapi/sql/Activation.java&lt;br/&gt;
X      tools/testing/derby&lt;/p&gt;</comment>
                            <comment id="12483862" author="dyret" created="Sat, 24 Mar 2007 17:39:29 +0000"  >&lt;p&gt;Dyre&amp;gt; ...how does cleanUp() fit into this?&lt;/p&gt;

&lt;p&gt;I figured it out. I mistakenly thought that &apos;BasicNoPutResultSet&apos;&lt;br/&gt;
and &apos;NoRowsResultSetImpl&apos; implement &apos;java.sql.ResultSet&apos;, when&lt;br/&gt;
they, in fact, implement org.apache.derby.iapi.sql.ResultSet. The&lt;br/&gt;
javadoc for the latter clearly describes purpose of each&lt;br/&gt;
method (also cleanUp()). &lt;/p&gt;

&lt;p&gt;But this makes me think that all lang ResultSets should either&lt;br/&gt;
override all three methods, or clearly document why that isn&apos;t&lt;br/&gt;
required. When a method is missing in a class, it is difficult to&lt;br/&gt;
know if the method was intentionally left out or simply&lt;br/&gt;
forgotten. It also makes it difficult to know if a later change&lt;br/&gt;
actually requires you to start overriding a method.&lt;/p&gt;

&lt;p&gt;Given that the javadoc for cleanUp() says &apos;Tells the system to&lt;br/&gt;
clean up on an error&apos;, its use in DeleteResultSet (called at the&lt;br/&gt;
end of every open()) seems a bit strange.&lt;/p&gt;</comment>
                            <comment id="12483884" author="djd" created="Sat, 24 Mar 2007 21:09:21 +0000"  >&lt;p&gt;&amp;gt; Given that the javadoc for cleanUp() says &apos;Tells the system to&lt;br/&gt;
&amp;gt; clean up on an error&apos;, its use in DeleteResultSet (called at the&lt;br/&gt;
&amp;gt; end of every open()) seems a bit strange.&lt;/p&gt;

&lt;p&gt;Language ResultSets that do not return rows (ie. DML &amp;amp; DDL) perform all of their action in the open method,&lt;br/&gt;
thus the end of the open method is the correct time to clean up and close any open resources etc. I guess in&lt;br/&gt;
the delete case the clean up for an error is the same as the clean up for the non-error case, thus the code is&lt;br/&gt;
being shared. Of course more comments in the code would probably make this clear.&lt;/p&gt;</comment>
                            <comment id="12483886" author="djd" created="Sat, 24 Mar 2007 21:14:26 +0000"  >&lt;p&gt;and the javadoc for cleanUp saying &apos;Tells the system to clean up on an error&apos; I think is wrong, at least it&apos;s misleading.&lt;/p&gt;

&lt;p&gt;The method does not tell the system anything, it (I assume) is called when there is an error and the ResultSet will not be used anymore until another open.&lt;/p&gt;

&lt;p&gt;A better comment might be:&lt;/p&gt;

&lt;p&gt;  Clean up resources for this ResultSet after an error. &lt;span class=&quot;error&quot;&gt;&amp;#91;add some information about state change to close, if it&amp;#39;s driven by this method or not&amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="12483888" author="djd" created="Sat, 24 Mar 2007 21:40:34 +0000"  >&lt;p&gt;By the way, Dyre, I see this bug as a great example of open source open development. There&apos;s been incremental patches, resulting in ideas, and a test being committed before any changes (a good thing &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. There&apos;s been discussion, mistakes which are just accepted, experimental patches, analysis by you that made it quicker for me to guess where a problem might be. You&apos;ve even continued with the open approach even when it seemed no-one was listening, when in reality I think it was just no-one had any value to add beyond your excellent analysis.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="12484363" author="dyret" created="Tue, 27 Mar 2007 10:02:34 +0100"  >&lt;p&gt;I&apos;m glad some of my rambling proved useful. suites.All now pass&lt;br/&gt;
when re-using resultsets, but there are still som failures in&lt;br/&gt;
derbyall that I&apos;m looking at. One is that&lt;/p&gt;

&lt;p&gt;lang/altertable.sql fails with &lt;/p&gt;

&lt;p&gt;ERROR XSAI2: The conglomerate (1,568) requested does not exist.&lt;/p&gt;

&lt;p&gt;which seems to come from MiscResultSet.open():&lt;/p&gt;

&lt;p&gt;public void open() throws StandardException&lt;/p&gt;
	{
		constantAction.executeConstantAction(activation);
		super.close();
	}

&lt;p&gt;constantAction is a private member which only gets set in the&lt;br/&gt;
constructor. It seems like this member somehow gets stale,&lt;br/&gt;
because if that line is changed to&lt;/p&gt;

&lt;p&gt;activation.getConstantAction().executeConstantAction(activation);&lt;/p&gt;

&lt;p&gt;so that the constantAction is obtained from the activation on&lt;br/&gt;
each open, the test passes. But is this correct? That is, do we&lt;br/&gt;
expect to have to call getConstantAction() again for each open?&lt;/p&gt;</comment>
                            <comment id="12484429" author="dyret" created="Tue, 27 Mar 2007 12:11:11 +0100"  >&lt;p&gt;lang/staleplans.sql is another failure in derbyall, but the&lt;br/&gt;
difference in output is only due to different query&lt;br/&gt;
plans. Specifically &apos;Number of opens&apos; and &apos;Rows seen&apos; in the&lt;br/&gt;
query plans are different when the result sets are re-used. But&lt;br/&gt;
what is the correct way of fixing this? I think it is possible to&lt;br/&gt;
reset these variables in close() so that the output is the same&lt;br/&gt;
as before, but it seem rather silly to always report the number&lt;br/&gt;
of opens as 1, when the result sets actually has been opened (and&lt;br/&gt;
closed) many times. Does the optimizer use these numbers in any&lt;br/&gt;
way? And if so, will it be affected by the change?&lt;/p&gt;</comment>
                            <comment id="12484487" author="army" created="Tue, 27 Mar 2007 16:43:54 +0100"  >&lt;p&gt;&amp;gt; I think it is possible to reset these variables in close() so that the output is the same as before,&lt;br/&gt;
&amp;gt; but it It seem rather silly to always report the number of opens as 1, when the result sets&lt;br/&gt;
&amp;gt; actually has been opened (and closed) many times.&lt;/p&gt;

&lt;p&gt;I tend to agree with this, though I&apos;m not sure what the best way around it would be...&lt;/p&gt;

&lt;p&gt;I think the intent of &quot;number of opens&quot; is to record how many times a result set was opened for a &lt;em&gt;single&lt;/em&gt; execution (which can be more than 1--namely, if &quot;reopenCore()&quot; is called).  So is there any way to tell the difference between &quot;reopens&quot; that occur within a single execution vs &quot;reopens&quot; that occur because of multiple executions of the same statement?  For example, is it true that &quot;openCore()&quot; will only be called once per statement execution while &quot;reopenCore()&quot; may be called multiple times per statement execution?  If so, could we reset numOpens in the &quot;openCore()&quot; method instead of in the &quot;close()&quot; method (since the latter may be called several times per execution)?  My apologies if that was already covered in earlier discussions; if so, please feel free to ignore me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; Does the optimizer use these numbers in any way? And if so, will it be affected by the change?&lt;/p&gt;

&lt;p&gt;Based on my very limited experience with result sets (most of which came from working on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-47&quot; title=&quot;Some possible improvements to IN optimization&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-47&quot;&gt;&lt;del&gt;DERBY-47&lt;/del&gt;&lt;/a&gt;), I don&apos;t think the optimizer uses &quot;number of opens&quot; nor &quot;rows seen&quot; in its estimates.  But please keep in mind that I could be wrong here...&lt;/p&gt;

&lt;p&gt;The one thing I noticed was that the value of &quot;rows this scan&quot; is, in certain situations, written to store and &lt;b&gt;that&lt;/b&gt; value can affect estimates (because the optimizer can use that to guess how many rows will be returned from a table).  For more see the &quot;setRowCountIfPossible()&quot; method in exec/TableScanResultSet.java.  I don&apos;t know the details on how that works but I don&apos;t think &quot;rows seen&quot; nor &quot;number of opens&quot; directly affects the rowsThisScan value...&lt;/p&gt;

&lt;p&gt;But again, that&apos;s just speculation based on limited experience.  If anyone out there knows more hopefully s/he will post here...&lt;/p&gt;</comment>
                            <comment id="12484782" author="dyret" created="Wed, 28 Mar 2007 10:16:31 +0100"  >&lt;p&gt;Thanks for the feedback AB. Here are some answers:&lt;/p&gt;

&lt;p&gt;AB&amp;gt; If so, could we reset numOpens in the &quot;openCore()&quot; method&lt;br/&gt;
instead of in the &quot;close()&quot; method (since the latter may be&lt;br/&gt;
called several times per execution)?&lt;/p&gt;

&lt;p&gt;I think so. It seems consistent with what I&apos;ve seen so far, but I&apos;m&lt;br/&gt;
not certain.&lt;/p&gt;

&lt;p&gt;AB&amp;gt; I don&apos;t know the details on how that works but I don&apos;t&lt;br/&gt;
think &quot;rows seen&quot; nor &quot;number of opens&quot; directly affects the&lt;br/&gt;
rowsThisScan value...&lt;/p&gt;

&lt;p&gt;That is promising. I&apos;ve not seen a diff for &quot;rows this scan&quot;, but&lt;br/&gt;
I guess that could be because there wasn&apos;t one in the tests that&lt;br/&gt;
dump the query plan...&lt;/p&gt;</comment>
                            <comment id="12485129" author="dyret" created="Thu, 29 Mar 2007 10:43:42 +0100"  >&lt;p&gt;Here is the repro (test_inbetween.sql) requested by AB as well as a snapshot patch of&lt;br/&gt;
my sandbox (includes Dan&apos;s changes and my fixups) (derby-827.snapshot.diff). Feel free to&lt;br/&gt;
comment on the patch, but please note that it is work in&lt;br/&gt;
progress, (that means I will ignore any comments about missing&lt;br/&gt;
comments and/or poor indentation).&lt;/p&gt;

&lt;p&gt;The patch traces creation of all language result sets, and this&lt;br/&gt;
creates a lot of output. This means that no diff-based tests&lt;br/&gt;
will pass with this patch. Most of this output can be removed by&lt;br/&gt;
reverting GenericResultSetFactory.java after applying the patch.&lt;/p&gt;</comment>
                            <comment id="12485373" author="army" created="Fri, 30 Mar 2007 00:18:22 +0100"  >&lt;p&gt;In a thread on derby-dev I wrote the following:&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; I think the approach would be to generate the array of probe values &lt;br/&gt;
&amp;gt;&amp;gt; as a &quot;saved object&quot;, which can then be retrieved from the activation &lt;br/&gt;
&amp;gt;&amp;gt; just like any other saved object.  My perhaps slightly uninformed&lt;br/&gt;
&amp;gt;&amp;gt; guess is that this shouldn&apos;t be too difficult--maybe a day or two of&lt;br/&gt;
&amp;gt;&amp;gt; coding?&lt;/p&gt;

&lt;p&gt;It turns out my guess was indeed misinformed.  I looked at the various places where existing code calls &quot;addSavedObject()&quot; and in all cases the object being passed in is a specific compile-time object.  That&apos;s also what the javadoc for addSavedObject() indicates.  But in the case of IN list probing values the object of interest (namely, an array of DataValueDescriptors) does not exist until execution time because we create it as part of code generation.  So use of saved objects is not going to work here.&lt;/p&gt;

&lt;p&gt;That said, the generated values for parameters are &quot;pluggable&quot;, meaning that if we generate some DataValueDescriptor for a parameter p1, then whatever value is bound to p1 will end up in the generated DataValueDescriptor at execution time. If we re-execute the statement with a different value assigned to p1, then the generated DataValueDescriptor will end up with new value, as well.  Given that, I think all we need to do is save off the DataValueDescriptor array that we receive in the MultiProbeTableScanResultSet constructor, and then &quot;reload&quot; from that array on every call to &quot;openCore()&quot;.  The relevant code changes are pretty small; I&apos;m attaching them as multiprobe_notTested.patch.&lt;/p&gt;

&lt;p&gt;With these simple changes to MultiProbeTableScanResultSet, the &quot;test_inbetween.sql&quot; script that you attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-827&quot; title=&quot;Performance can be improved by re-using language ResultSets across Activation executions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-827&quot;&gt;&lt;del&gt;DERBY-827&lt;/del&gt;&lt;/a&gt; returned the correct results (even after applying derby-827.snapshot.diff).&lt;/p&gt;

&lt;p&gt;I haven&apos;t tested this at all, though (aside from running test_inbetween.sql), so please take this suggestion with caution.  Just something I thought of when I realized that the savedObject approach wasn&apos;t going to work...&lt;/p&gt;</comment>
                            <comment id="12485378" author="djd" created="Fri, 30 Mar 2007 00:30:55 +0100"  >&lt;p&gt;Dyre&amp;gt;&lt;br/&gt;
-----------------------&lt;br/&gt;
constantAction is a private member which only gets set in the&lt;br/&gt;
constructor. It seems like this member somehow gets stale,&lt;br/&gt;
because if that line is changed to&lt;/p&gt;

&lt;p&gt;activation.getConstantAction().executeConstantAction(activation);&lt;/p&gt;

&lt;p&gt;so that the constantAction is obtained from the activation on&lt;br/&gt;
each open, the test passes. But is this correct? &lt;br/&gt;
---------------------------------------------------------&lt;/p&gt;

&lt;p&gt;I don&apos; t think that&apos;&apos;s a correct change, it&apos;s strange it seems to be fixing something.&lt;br/&gt;
ConstantActions are constant and created once at compile time, and then passed over to the execution time.&lt;br/&gt;
Thus activation.getConstantAction() should return the same value.&lt;/p&gt;

&lt;p&gt;Do you know which statement was causing this, basically I think the statement should have been invalidated once it was executed,&lt;br/&gt;
thus any future execution should be a recompile?&lt;/p&gt;
</comment>
                            <comment id="12485450" author="dyret" created="Fri, 30 Mar 2007 10:23:53 +0100"  >&lt;p&gt;AB&amp;gt; The relevant code changes are pretty small; I&apos;m attaching &lt;br/&gt;
AB&amp;gt; them as multiprobe_notTested.patch. &lt;/p&gt;

&lt;p&gt;Great! I&apos;m looking forward to testing it. Thanks. I&apos;ll post my&lt;br/&gt;
findings here when I&apos;m done.&lt;/p&gt;

&lt;p&gt;Dan&amp;gt; Do you know which statement was causing this, basically I&lt;br/&gt;
Dan&amp;gt; think the statement should have been invalidated once it was&lt;br/&gt;
Dan&amp;gt; executed, thus any future execution should be a recompile?&lt;/p&gt;

&lt;p&gt;Not off the top my head. But I&apos;ll revert the (incorrect) change I&lt;br/&gt;
made and dig into it some more.&lt;/p&gt;</comment>
                            <comment id="12485510" author="dyret" created="Fri, 30 Mar 2007 15:05:14 +0100"  >&lt;p&gt;Dan&amp;gt; Do you know which statement was causing this &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The test that fails is lang/altertable.sql. There first occurs&lt;br/&gt;
when re-executing a prepared statement that adds a constraint to a&lt;br/&gt;
table that has been dropped and re-created:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table xxx(c1 int, c2 int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; prepare p1 as &apos;alter table xxx add check(c2 = 1)&apos;;&lt;br/&gt;
ij&amp;gt; execute p1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; drop table xxx;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table xxx(c1 int);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; execute p1;&lt;br/&gt;
ERROR 42X04: Column &apos;C2&apos; is either not in any table in the FROM list or appears within a join specification and is outside the scope of the join specification or appears in a HAVING clause and is not in the GROUP BY list. If this is a CREATE or ALTER TABLE  statement then &apos;C2&apos; is not a column in the target table.&lt;br/&gt;
ij&amp;gt; alter table xxx add column c2 int;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; execute p1;&lt;br/&gt;
ERROR XSAI2: The conglomerate (1,568) requested does not exist.&lt;br/&gt;
&amp;#8211; Should have been: &quot;0 rows inserted/updated/deleted&quot;&lt;/p&gt;

&lt;p&gt;The second failure is similar (now dropping a constraint):&lt;br/&gt;
ij&amp;gt; &amp;#8211; verify that alter table works after drop/recreate of table&lt;br/&gt;
prepare p1 as &apos;alter table t0_1 drop constraint p2&apos;;&lt;br/&gt;
ij&amp;gt; execute p1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; drop table t0_1;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table t0_1 (c1 int, c2 int not null constraint p2 primary key);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; execute p1;&lt;br/&gt;
ERROR XSAI2: The conglomerate (992) requested does not exist.&lt;br/&gt;
&amp;#8211; Should have been: &quot;0 rows inserted/updated/deleted&quot;&lt;/p&gt;

&lt;p&gt;So I&apos;d say that your idea about immediate invalidation and forced&lt;br/&gt;
recompile looks correct.&lt;/p&gt;</comment>
                            <comment id="12485520" author="dyret" created="Fri, 30 Mar 2007 15:55:32 +0100"  >&lt;p&gt;AB&amp;gt; I&apos;m attaching them as multiprobe_notTested.patch.&lt;/p&gt;

&lt;p&gt;I&apos;ve now run both suites.All and derbyall with this patch applied&lt;br/&gt;
to a clean trunk. There were no failures (except for&lt;br/&gt;
SecurityPolicyReloadingTest)&lt;/p&gt;

&lt;p&gt;I also ran suites.All and derbyall with this patch in my&lt;br/&gt;
derby-827 sandbox. I saw no failures in suites.All (except for&lt;br/&gt;
SecurityPolicyReloadingTest). lang/inbetween.sql passes and there&lt;br/&gt;
are no new failures in derbyall. So this patch gets two thumbs up&lt;br/&gt;
from me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12485998" author="dyret" created="Mon, 2 Apr 2007 13:22:39 +0100"  >&lt;p&gt;Status report: I currently see 6 failures when&lt;br/&gt;
running derbyall:&lt;/p&gt;

&lt;p&gt;derbyall/derbyall.fail:lang/altertable.sql&lt;br/&gt;
Statement should have been invalidated and recompiled?&lt;/p&gt;

&lt;p&gt;derbyall/derbyall.fail:lang/declareGlobalTempTableJava.java&lt;br/&gt;
derbyall/derbyall.fail:lang/declareGlobalTempTableJavaJDBC30.java&lt;br/&gt;
Temporary table is still there after rollback to savepoint, which&lt;br/&gt;
it shouldn&apos;t be&lt;/p&gt;

&lt;p&gt;derbyall/derbyall.fail:lang/dynamicLikeOptimization.sql&lt;br/&gt;
Diff in printed query-plan, even after resetting counters in each open()&lt;/p&gt;

&lt;p&gt;derbyall/derbyall.fail:lang/grantRevokeDDL2.sql&lt;br/&gt;
Two diffs: &lt;br/&gt;
1)&lt;br/&gt;
ij(USER1)&amp;gt; &amp;#8211; should fail&lt;br/&gt;
delete from t1 where i = 7;&lt;br/&gt;
&amp;#8211; Should ALSO report &quot;ERROR: Failed with SQLSTATE 38000&quot; here, &lt;br/&gt;
&amp;#8211; but only reports&lt;br/&gt;
ERROR: Failed with SQLSTATE 38002&lt;/p&gt;

&lt;p&gt;2)&lt;br/&gt;
ij(USER2)&amp;gt; &amp;#8211; prepare statement, ok&lt;br/&gt;
prepare p1 as &apos;select * from user1.ttt2&apos;;&lt;br/&gt;
ij(USER2)&amp;gt; &amp;#8211; ok&lt;br/&gt;
execute p1;&lt;br/&gt;
I          &lt;br/&gt;
-----------&lt;br/&gt;
8          &lt;br/&gt;
1 row selected&lt;br/&gt;
ij(USER2)&amp;gt; set connection user1;&lt;br/&gt;
ij(USER1)&amp;gt; revoke select on ttt2 from user2;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij(USER1)&amp;gt; set connection user2;&lt;br/&gt;
ij(USER2)&amp;gt; &amp;#8211; expect error&lt;br/&gt;
execute p1;&lt;br/&gt;
I          &lt;br/&gt;
-----------&lt;br/&gt;
8          &lt;br/&gt;
1 row selected&lt;br/&gt;
&amp;#8211; This is incorrect. Should have failed &lt;br/&gt;
&amp;#8211; with &quot;ERROR: Failed with SQLSTATE 28508&quot;&lt;/p&gt;

&lt;p&gt;derbyall/derbyall.fail:lang/staleplans.sql&lt;br/&gt;
Diff in printed query-plan, even after resetting counters in each open()&lt;/p&gt;</comment>
                            <comment id="12486336" author="dyret" created="Tue, 3 Apr 2007 13:16:51 +0100"  >&lt;p&gt;WRT to the failures in derbyall/derbyall.fail:lang/grantRevokeDDL2.sql:&lt;br/&gt;
The first appears to be caused by a &lt;/p&gt;

&lt;p&gt;java.sql.SQLException: The external routine is not allowed to execute SQL statem&lt;br/&gt;
ents.&lt;/p&gt;

&lt;p&gt;which is NOT wrapped in a &lt;/p&gt;

&lt;p&gt;java.sql.SQLException: &apos;The external routine is not a&lt;br/&gt;
llowed to execute SQL statements.&apos; was thrown while evaluating an expression.&lt;/p&gt;

&lt;p&gt;but this happens for ordianary (not prepared) statements, so I&lt;br/&gt;
don&apos;t see how re-execution could be causing this.&lt;/p&gt;

&lt;p&gt;The second failure is easier to understand. Decompiling the&lt;br/&gt;
generated class which fails to properly check authorization&lt;br/&gt;
during the second execution we get:&lt;/p&gt;

&lt;p&gt;    public ResultSet execute()&lt;br/&gt;
		throws StandardException&lt;/p&gt;
    {
         throwIfClosed(&quot;execute&quot;);
         startExecution();
         BaseActivation.reinitializeQualifiers(e2);
         return ((resultSet == null) ? fillResultSet() : resultSet);
        // fillResultSet() will only be called once for a ps
    }


&lt;p&gt;    private ResultSet fillResultSet()&lt;br/&gt;
		throws StandardException&lt;/p&gt;
    {
         getLanguageConnectionContext().getAuthorizer().authorize(this , 1);
         // Problem - can&apos;t check authorization here, will not get called when
         // ps is re-executed

         return (getResultSetFactory().getScrollInsensitiveResultSet(getResultSetFactory().getIndexRowToBaseRowResultSet((long)960 , 5 , getResultSetFactory().getTableScanResultSet(this , (long)977 , 7 , getMethod(&quot;e0&quot;) , 2 , getMethod(&quot;e1&quot;) , 1 , null , -1 , true , e2 , &quot;T1&quot; , null , &quot;SQL070402062141340&quot; , true , false , -1 , -1 , 6 , false , 0 , true , 1.0 , 5.1195) , getMethod(&quot;e2&quot;) , 1 , &quot;T1&quot; , 1 , 2 , 3 , 4 , null , false , 1.0 , 5.1195) , this , 0 , 2 , getScrollable() , 1.0 , 5.1195));
    }</comment>
                            <comment id="12488627" author="knutanders" created="Fri, 13 Apr 2007 10:36:28 +0100"  >&lt;p&gt;A B, do you think it is OK to commit multiprobe_notTested.patch now that Dyre has verified that the regression tests pass?&lt;/p&gt;</comment>
                            <comment id="12488700" author="army" created="Fri, 13 Apr 2007 16:16:01 +0100"  >&lt;p&gt;&amp;gt; A B, do you think it is OK to commit multiprobe_notTested.patch now that Dyre&lt;br/&gt;
&amp;gt; has verified that the regression tests pass.&lt;/p&gt;

&lt;p&gt;Yes, definitely.  Sorry, I was thinking that Dyre would just take the patch and incorporate it into whatever it was he was doing.  I didn&apos;t realize it was waiting for a commit.&lt;/p&gt;

&lt;p&gt;Might be nice to add some explanatory comments to the multiprobe patch (esp. why we need &quot;origProbeValues&quot;), but  since Dyre ran the tests (thanks Dyre!) I think it&apos;s okay to commit.&lt;/p&gt;

&lt;p&gt;Are you (Knut Anders) volunteering to commit, or you asking me to?&lt;/p&gt;

&lt;p&gt;Apologies if this has been blocking anything...&lt;/p&gt;</comment>
                            <comment id="12488714" author="knutanders" created="Fri, 13 Apr 2007 17:59:00 +0100"  >&lt;p&gt;Thanks, Army! I don&apos;t think you have been blocking anything, I just noticed that there was a patch that could be applied independently and wondered if it was considered ready for commit. I have started suites.All/derbyall and can commit it tomorrow, but please feel free to commit it yourself.&lt;/p&gt;</comment>
                            <comment id="12488936" author="knutanders" created="Sun, 15 Apr 2007 14:33:57 +0100"  >&lt;p&gt;Committed multiprobe_notTested.patch with revision 528973.&lt;/p&gt;</comment>
                            <comment id="12489113" author="dyret" created="Mon, 16 Apr 2007 14:30:18 +0100"  >&lt;p&gt;I&apos;ve looked some more at the failure in lang/altertable.sql:&lt;/p&gt;

&lt;p&gt;Dan&amp;gt; I don&apos; t think that&apos;&apos;s a correct change, it&apos;s strange it&lt;br/&gt;
Dan&amp;gt; seems to be fixing something.  ConstantActions are constant and&lt;br/&gt;
Dan&amp;gt; created once at compile time, and then passed over to the&lt;br/&gt;
Dan&amp;gt; execution time.&lt;br/&gt;
Dan&amp;gt; Thus activation.getConstantAction() should return the same value.&lt;/p&gt;

&lt;p&gt;Dan&amp;gt; Do you know which statement was causing this, basically I&lt;br/&gt;
Dan&amp;gt; think the statement should have been invalidated once it was&lt;br/&gt;
Dan&amp;gt; executed, thus any future execution should be a recompile?&lt;/p&gt;

&lt;p&gt;The statement is &apos;alter table xxx add check(c2 = 1)&apos;. As an ALTER&lt;br/&gt;
TABLE statement it is invalidated immediately after it is&lt;br/&gt;
executed, and I have verified that this happens.&lt;/p&gt;

&lt;p&gt;The next execute triggers a recompile (also verified), and a new&lt;br/&gt;
ConstantAction based on the new (modified) DataDictionary is&lt;br/&gt;
created. See GenericStatement.prepMinion(line 473).&lt;br/&gt;
In this ConstantAction, table xxx is associated with the&lt;br/&gt;
correct Conglomerate number. This new ConstantAction object gets&lt;br/&gt;
stored in the GenericPreparedStatement object.&lt;/p&gt;

&lt;p&gt;A call to activation.getConstantAction() DOES return the same&lt;br/&gt;
object (according to System.identityHashCode) which was stored in&lt;br/&gt;
the GenericPreparedStatement during re-prepare.&lt;/p&gt;

&lt;p&gt;The ConstantAction reference inside MiscResultSet on the other&lt;br/&gt;
hand, still points to the old ConstantAction object:&lt;/p&gt;

&lt;p&gt;class org.apache.derby.impl.sql.execute.MiscResultSet@29537806.open() constantAction=class org.apache.derby.impl.sql.execute.AlterTableConstant&lt;br/&gt;
Action@28679195 actConstantAction=class org.apache.derby.impl.sql.execute.AlterT&lt;br/&gt;
ableConstantAction@8721445&lt;br/&gt;
class org.apache.derby.impl.sql.execute.AlterTableConstantAction@28679195.execut&lt;br/&gt;
eConstantAction() tableName=XXX tableId=5b17c1e6-0111-fa66-3772-00005462a030 tab&lt;br/&gt;
leConglomerateId=1568 td=SCHEMA:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
ERROR XSAI2: The conglomerate (1,568) requested does not exist&lt;/p&gt;

&lt;p&gt;AlterTableConstantAction@28679195 references 1568 while the new&lt;br/&gt;
AlterTableConstantAction@8721445 references 1584 (correct)&lt;/p&gt;

&lt;p&gt;So an existing ConstantAction is not valid after re-prepare, at least&lt;br/&gt;
not in the current implementation.&lt;/p&gt;</comment>
                            <comment id="12489153" author="bryanpendleton" created="Mon, 16 Apr 2007 17:02:01 +0100"  >&lt;p&gt;It sounds like both the prepared statement and the result set are&lt;br/&gt;
keeping a reference to the constant action, and, after re-prepare,&lt;br/&gt;
the result set is using its own (old) constant action pointer rather&lt;br/&gt;
than picking up the newly-re-prepared constant action from the prepared&lt;br/&gt;
statement.&lt;/p&gt;

&lt;p&gt;Perhaps the result set should not keep a reference to the constant&lt;br/&gt;
action, but should instead always pick up the constant action by&lt;br/&gt;
fetching it from the prepared statement. Then after the re-prepare the&lt;br/&gt;
result set would get the new constant action.&lt;/p&gt;

&lt;p&gt;I guess what I&apos;m suggesting is that perhaps there&apos;s no reason for&lt;br/&gt;
MiscResultSet to have a constantAction reference, since all it seems&lt;br/&gt;
to be doing is keeping a reference to an object which may become stale,&lt;br/&gt;
and instead it should just always fetch the constant action from the activation.&lt;/p&gt;
</comment>
                            <comment id="12489224" author="djd" created="Mon, 16 Apr 2007 21:30:19 +0100"  >&lt;p&gt;If the statement is being re-compiled how is it picking up an old MiscResultSet?&lt;/p&gt;

&lt;p&gt;Bryan&apos;s logic on not storing the constant action reference in the MiscResultSet seems good, but I don&apos;t see why the old MiscResultSet is even being used.&lt;/p&gt;</comment>
                            <comment id="12489339" author="dyret" created="Tue, 17 Apr 2007 09:49:34 +0100"  >&lt;p&gt;Thank you Bryan and Dan, for your comments. I like your&lt;br/&gt;
suggestion Bryan, but how is it different from what i suggested in my&lt;br/&gt;
comment on 27. March (02:02am)?&lt;/p&gt;

&lt;p&gt;Dan, the short (and stupid) answer is that the old MiscResultSet&lt;br/&gt;
gets returned (or is part of the ResultSet-tree returned) from&lt;br/&gt;
the call to Activation.execute(). You probably know better than&lt;br/&gt;
anyone what is supposed to happen when calling Activation.execute(), but&lt;br/&gt;
what I get from reading decompiled byte code (not from the failed&lt;br/&gt;
statement, but I think this part is identical for all&lt;br/&gt;
Activations?), is that the code will only create a new&lt;br/&gt;
ResultSet (tree) if its resultSet member variable is null. So&lt;br/&gt;
unless I&apos;m missing something (quite possible) there is no way for&lt;br/&gt;
the execution to know that the statement has been recompiled:&lt;/p&gt;

&lt;p&gt;public ResultSet execute()&lt;br/&gt;
                throws StandardException&lt;/p&gt;
    {
         throwIfClosed(&quot;execute&quot;);
         startExecution();
         BaseActivation.reinitializeQualifiers(e2);
         return ((resultSet == null) ? fillResultSet() : resultSet);
    }

&lt;p&gt;There is already an interface for clearing the resultSet&lt;br/&gt;
parameter in BaseActivation, so I guess the preferred semantic &lt;br/&gt;
could be achieved by simply adding a call to &lt;/p&gt;

&lt;p&gt;getActivation(lcc,false).clearResultSet() &lt;/p&gt;

&lt;p&gt;in GenericPreparedStatement.rePrepare() (inside the&lt;br/&gt;
if (!upToDate()) test), but I have not tried this.&lt;/p&gt;</comment>
                            <comment id="12489345" author="dyret" created="Tue, 17 Apr 2007 10:38:44 +0100"  >&lt;p&gt;Correction: Activation.clearResultSet() extists in trunk, but was removed in derby827_update920.txt&lt;/p&gt;</comment>
                            <comment id="12489417" author="djd" created="Tue, 17 Apr 2007 15:48:09 +0100"  >&lt;p&gt;My assumption is that if the statement is being recompiled then it should get a new activation instance and hence a new result set tree. So with a recompile there should be no relationship to the old activation or the old result set. &lt;/p&gt;</comment>
                            <comment id="12489433" author="bryanpendleton" created="Tue, 17 Apr 2007 16:25:48 +0100"  >&lt;p&gt;Hi Dyre. Indeed, my comment is in agreement with your 27-Mar comment.&lt;/p&gt;

&lt;p&gt;Unfortunately, I don&apos;t have any ideas to offer about why the recompiled statement is getting the old activation instance.&lt;/p&gt;</comment>
                            <comment id="12489544" author="dyret" created="Tue, 17 Apr 2007 22:18:04 +0100"  >&lt;p&gt;OK Bryan, thank you for taking the time to look at it. I really&lt;br/&gt;
appreciate it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I believe Dan&apos;s assumption is absolutely correct. A new&lt;br/&gt;
ActivationClass (with no ResultSet tree) is indeed created during&lt;br/&gt;
re-compile. The problem is, I think, that a new&lt;br/&gt;
GenericActivationHolder referencing the new generated class is&lt;br/&gt;
NOT created until the next call to&lt;br/&gt;
GenericPreparedStatement.getActivation(). Which does not happen,&lt;br/&gt;
so the execution is done with the old GenericActivationHolder.&lt;/p&gt;

&lt;p&gt;A simple fix for this would be to call getActivation() each time &lt;br/&gt;
(seems to work), but this will create a new Holder for each&lt;br/&gt;
execution.  &lt;/p&gt;

&lt;p&gt;One could put the call to getActivation() inside rePrepare (after&lt;br/&gt;
verifying that a rePrepare is required), but there you don&apos;t have&lt;br/&gt;
access to the activation variable (could return the new&lt;br/&gt;
ActivationHolder or store it in a member variable).&lt;/p&gt;

&lt;p&gt;One could also make getActivation() a bit more intelligent so&lt;br/&gt;
that it only returns a new Holder if the ActivationClass has&lt;br/&gt;
changed...&lt;/p&gt;</comment>
                            <comment id="12489560" author="knutanders" created="Tue, 17 Apr 2007 23:07:39 +0100"  >&lt;p&gt;What about letting PreparedStatement.rePrepare() return a boolean to tell whether the statement was recompiled? If rePrepare() returned a boolean, we could reset EmbedPreparedStatement.activation from EmbedStatement.executeStatement() on each recompile. It seems like most of the other callers of rePrepare() correctly call getActivation() after calling rePrepare().&lt;/p&gt;</comment>
                            <comment id="12489626" author="knutanders" created="Wed, 18 Apr 2007 08:30:12 +0100"  >&lt;p&gt;Thinking more about it, I don&apos;t think returning a boolean from rePrepare() is the right way to go. A single GenericPreparedStatement can be shared between many EmbedPreparedStatements, and my proposal would only get a new activation in the EmbedPreparedStatement that happened to trigger the recompile. Another approach would be to maintain a version field in GenericPreparedStatement so that we can check whether it has been recompiled since the last time we executed it.&lt;/p&gt;</comment>
                            <comment id="12489682" author="dyret" created="Wed, 18 Apr 2007 11:25:47 +0100"  >&lt;p&gt;Actually, calling getActivation() for every execute does NOT work. It fixes the stale ConstantAction problem, but altertable.sql shows a number of other errors... &lt;/p&gt;

&lt;p&gt;Knut&apos;s suggestion about verifying Activations (would that really be ActivationHolders?) against GenericPreparedStatements seems promising, I think.&lt;/p&gt;</comment>
                            <comment id="12489725" author="dyret" created="Wed, 18 Apr 2007 14:42:24 +0100"  >&lt;p&gt;The failures I saw happened because the prepared statement&lt;br/&gt;
parameters weren&apos;t copied to the new activation. I get the test&lt;br/&gt;
to pass by modifying EmbedPreparedStatement.executeStatement() as&lt;br/&gt;
follows:&lt;/p&gt;

&lt;p&gt;@@ -1649,7 +1657,22 @@&lt;br/&gt;
                checkExecStatus();&lt;br/&gt;
                checkIfInMiddleOfBatch();&lt;br/&gt;
                clearResultSets();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return super.executeStatement(a, executeQuery, executeUpdate);&lt;br/&gt;
+&lt;br/&gt;
+        ExecPreparedStatement ps = a.getPreparedStatement();&lt;br/&gt;
+        try 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            if (ps.getActivationClass() != null) {
+                activation = ps.getActivation(lcc, false);
+                activation.setParameters(a.getParameterValueSet(), 
+                                         ps.getParameterTypes());
+            }+        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (StandardException se) &lt;/p&gt;
{ 
+                throw EmbedResultSet.noStateChangeException(se); 
+        }
&lt;p&gt;+        catch (Exception e) &lt;/p&gt;
{
+            e.printStackTrace();
+        }
&lt;p&gt;+&lt;br/&gt;
+               return super.executeStatement(activation, executeQuery, executeUpdate);&lt;br/&gt;
        }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Note that this is just a proof of concept hack. A real solution&lt;br/&gt;
should:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;include a test to see if the activationClass has changed and&lt;br/&gt;
  only call getActivation() when necessary&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;would need to make similar changes to&lt;br/&gt;
  EmbedPreparedStatement.executeBatchElement(), or move the logic&lt;br/&gt;
  to EmbedStatement&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;not use &apos;false&apos; as the second argument to getActivation()&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;have cleaner exception handling&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;avoid testing if activationClass is null. This is a kludge to&lt;br/&gt;
  avoid calling rePrepare inside getActivation() which fails with&lt;br/&gt;
  an NPE&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12489751" author="knutanders" created="Wed, 18 Apr 2007 15:20:57 +0100"  >&lt;p&gt;I had a look at Dyre&apos;s snapshot of his sandbox (derby-827.snapshot.diff) and I think some of the changes could be committed independently. I applied the changes to the close methods of ProjectRestrictResultSet, LastIndexKeyResultSet and InsertResultSet on a clean sandbox, as these changes looked simple and harmless to me, and ran suites.All and derbyall with no failures. (I removed the check for source != null in ProjectRestrictResultSet.close() since its constructor asserts that source is not null.) Attached a new patch containing only these changes (d827-close-cleanup.diff) which I plan to commit unless anyone objects. &lt;/p&gt;</comment>
                            <comment id="12489778" author="dyret" created="Wed, 18 Apr 2007 16:09:11 +0100"  >&lt;p&gt;I just ran the other derbyall tests that failed (lang/grantRevokeDDL.sql, &lt;br/&gt;
lang/declareGlobalTempTableJava, lang/declareGlobalTempTableJavaJDBC30) and they all pass with my hack.&lt;/p&gt;</comment>
                            <comment id="12489867" author="dyret" created="Wed, 18 Apr 2007 21:04:52 +0100"  >&lt;p&gt;I&apos;m trying to think about how to create a proper solution out of my hack. This is my current understanding:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;any time rePrepare() gets called, any Activation that refers to that prepared statement could be &quot;stale&quot; (meaning that the ActivationHolder refers to an outdated generated class)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it would be possible to test for this staleness by adding an boolean isValid() method to the Activation interface. Its implementation would be something like (in BaseActivation):&lt;br/&gt;
 {&lt;br/&gt;
     GeneratedClass curGc = getPreparedStatement().getActivationClass();&lt;br/&gt;
     if (curGc == null || curGc == gc) 
{
          return true;
     }
&lt;p&gt;     return false;&lt;br/&gt;
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in all places where rePrepare may have been called, one needs to do&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;if (!activation.isValid()) &lt;/p&gt;
{
    activation = activation.getPreparedStatement().getActivation(lcc, ...);
}
&lt;p&gt;activation.xxx();&lt;/p&gt;

&lt;p&gt;I think this will work, but I would prefer a more automated solution. Maybe a solution where the same ActivationHolder could be used across rePrepares, and automatically detect and fix staleness.&lt;/p&gt;</comment>
                            <comment id="12489894" author="bryanpendleton" created="Wed, 18 Apr 2007 22:46:44 +0100"  >&lt;p&gt;&amp;gt; any Activation that refers to that prepared statement could be &quot;stale&quot;&lt;/p&gt;

&lt;p&gt;Is it possible to use the DependencyManager for this? Make the Activation(s)&lt;br/&gt;
dependent on the prepared statement? &lt;/p&gt;</comment>
                            <comment id="12489903" author="djd" created="Wed, 18 Apr 2007 23:46:59 +0100"  >&lt;p&gt;I thought that this was handled already by the activation/prepared statement mechanism, I&apos;ll try to find some time to look into what isn&apos;t happening that should.&lt;/p&gt;</comment>
                            <comment id="12489980" author="knutanders" created="Thu, 19 Apr 2007 10:37:11 +0100"  >&lt;p&gt;Committed d827-close-cleanup with revision 530343.&lt;/p&gt;</comment>
                            <comment id="12489983" author="knutanders" created="Thu, 19 Apr 2007 11:04:49 +0100"  >&lt;p&gt;I see that many of the result set classes check the isolation level in their constructors and store it in a field. Couldn&apos;t this cause problems if a statement is re-executed after changing the isolation level?&lt;/p&gt;</comment>
                            <comment id="12490012" author="dyret" created="Thu, 19 Apr 2007 13:11:27 +0100"  >&lt;p&gt;I&apos;m afraid I may have introduced some red herrings into the discussion:&lt;/p&gt;

&lt;p&gt;Herring 1: The reason why the test were running OK was because I&lt;br/&gt;
created a new ActvationHolder on each execution. I thought that a&lt;br/&gt;
new Holder would use the old byte code so that if the byte code&lt;br/&gt;
hadn&apos;t changed I would still reuse the result sets. But since the&lt;br/&gt;
ActivationHolder constructor creates a new Activation instance&lt;br/&gt;
from the GeneratedClass each time, I was essentially throwing&lt;br/&gt;
away the result sets each time. That&apos;s why all the tests were&lt;br/&gt;
passing.&lt;/p&gt;

&lt;p&gt;Herring 2: Even when doing a reprepare you may get the same&lt;br/&gt;
GeneratedClass object out of the query tree, so simply testing if&lt;br/&gt;
the gc in the ps and the gc in the ActivationHolder is the&lt;br/&gt;
same (as I did in my code example) will not be enough. In this&lt;br/&gt;
case I think you need to manually set BaseActivation.resultSet&lt;br/&gt;
to null to throw away the old result set tree.&lt;/p&gt;</comment>
                            <comment id="12490089" author="dyret" created="Thu, 19 Apr 2007 16:03:25 +0100"  >&lt;p&gt;Given that Dan is planning to look into this, I&apos;m not going to&lt;br/&gt;
push my solution much further. Just wanted to mention that by&lt;br/&gt;
adding the versioning proposed by Knut, and adding a rebind()&lt;br/&gt;
method to ActivationHolder which uses the version number to see&lt;br/&gt;
if it needs to load a new Activation from the&lt;br/&gt;
GeneratedClass (which may be the same as before) I got&lt;br/&gt;
altertable.sql to pass (and trace printouts show that it is&lt;br/&gt;
working as expected). But the other tests still fail, so there&lt;br/&gt;
are probably a more issues to look into.&lt;/p&gt;</comment>
                            <comment id="12490108" author="djd" created="Thu, 19 Apr 2007 17:55:04 +0100"  >&lt;p&gt;I think I understand now. GenericActivationHolder already handles the case when the activation generated class changes, but for constant action statements there is no generated activation class. The activation class implmentation is fixed (to avoid re-compiling the same basic class each time) then the check in GenericActivationHolder.execute is never triggered. Of course that works fine at the moment because the result set tree is always regenerated.&lt;/p&gt;

&lt;p&gt;Thus I now think that Dyre&apos;s original change is correct:&lt;/p&gt;

&lt;p&gt; activation.getConstantAction().executeConstantAction(activation); &lt;/p&gt;

&lt;p&gt;because now I understand why it is making the difference. Before I thought that a new activation would have been generated due to the recompile, but it won&apos;t because the activation class does not change and there&apos;s no need to because the activation class does not change.&lt;/p&gt;

&lt;p&gt;Sorry for any confusion, but (at least to my thinking) it&apos;s good to understand why a change fixes a problem.&lt;/p&gt;

&lt;p&gt;And of course this change (in MiscResultSet) can be made independently of the re-use, it works either way.&lt;/p&gt;</comment>
                            <comment id="12490248" author="dyret" created="Fri, 20 Apr 2007 08:31:12 +0100"  >&lt;p&gt;Dan&amp;gt; GenericActivationHolder already handles the case when the&lt;br/&gt;
Dan&amp;gt; activation generated class changes&lt;/p&gt;

&lt;p&gt;Duh! I don&apos;t understand how I missed that. I feel silly now. I&apos;ll&lt;br/&gt;
post my original suggestion as a patch when I&apos;ve run the tests.&lt;/p&gt;</comment>
                            <comment id="12490302" author="knutanders" created="Fri, 20 Apr 2007 10:54:53 +0100"  >&lt;p&gt;Dyre&apos;s snapshot patch contains a simple fix for something that clearly looks like a bug in TemporaryRowHolderImpl. Derbyall and suites.All ran cleanly with that single file patched. Committed the fix with revision 530723.&lt;/p&gt;</comment>
                            <comment id="12490383" author="dyret" created="Fri, 20 Apr 2007 16:19:08 +0100"  >&lt;p&gt;Attaching MiscResultSetConstantAction.diff. derbyall and suites.All pass.&lt;/p&gt;

&lt;p&gt;I believe I know the why lang/declareGlobalTempTableJava is failing. It turns out that a call to &apos;markTempTableAsModifiedInUnitOfWork&apos; gets compiled into the fillResultSet() method when accessing a (global?) temporary table. Since fillResultSet() now is only called on the first execution the temp table isn&apos;t marked as modified in later executions, and rollback doesn&apos;t clean it up as it should.&lt;/p&gt;</comment>
                            <comment id="12490820" author="knutanders" created="Mon, 23 Apr 2007 07:27:00 +0100"  >&lt;p&gt;Committed MiscResultSetConstantAction.diff with revision 531349.&lt;/p&gt;</comment>
                            <comment id="12490843" author="dyret" created="Mon, 23 Apr 2007 09:16:21 +0100"  >&lt;p&gt;The failure in lang/declareGlobalTempTableJava goes away if the&lt;br/&gt;
call to DMLModStatement.generateCodeForTemporaryTable() is&lt;br/&gt;
changed as follows:&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/sql/compile/InsertNode.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; java/engine/org/apache/derby/impl/sql/compile/InsertNode.java       (revisio&lt;br/&gt;
n 531019)&lt;br/&gt;
+++ java/engine/org/apache/derby/impl/sql/compile/InsertNode.java       (working&lt;br/&gt;
 copy)&lt;br/&gt;
@@ -815,7 +815,7 @@&lt;br/&gt;
                                                        throws StandardException&lt;br/&gt;
        {&lt;br/&gt;
                //If the DML is on the temporary table, generate the code to mar&lt;br/&gt;
k temporary table as modified in the current UOW&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;generateCodeForTemporaryTable(acb, mb);&lt;br/&gt;
+               generateCodeForTemporaryTable(acb, /&lt;b&gt;mb&lt;/b&gt;/acb.getExecuteMethod())&lt;br/&gt;
;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;                /* generate the parameters */&lt;br/&gt;
                generateParameterValueSet(acb);&lt;/p&gt;

&lt;p&gt;Note that the &apos;mb&apos; argument references the local variable&lt;br/&gt;
&apos;mbWorker&apos; from StatementNode.generate() which refers to the&lt;br/&gt;
fillResulSet() method, so currently&lt;br/&gt;
generateCodeForTemporaryTable() adds its code to that method.&lt;/p&gt;

&lt;p&gt;If this solution is acceptable, I can submit a patch (which can be&lt;br/&gt;
committed independently).&lt;/p&gt;</comment>
                            <comment id="12490945" author="knutanders" created="Mon, 23 Apr 2007 15:35:37 +0100"  >&lt;p&gt;Attaching a patch (test-isolation.diff) which modifies these test cases in ResultSetsFromPreparedStatementTests:&lt;br/&gt;
testScalarAggregateResultSet, testLastIndexKeyResultSet, testDistinctScanResultSet, testDistinctScalarAggregateResultSet, testDistinctGroupedAggregateResultSet, testGroupedAggregateResultSet, testNestedLoopResultSet, testHashTableResultSet, testNestedLoopLeftOuterJoinResultSet, testHashLeftOuterJoinResultSet&lt;/p&gt;

&lt;p&gt;They now try to re-execute the statements after dropping and recreating the tables and after changing the transaction isolation level. The test still passes on trunk, but all the modified test cases fail with a lock timeout when derby827_update920.txt is applied.&lt;/p&gt;</comment>
                            <comment id="12491170" author="knutanders" created="Tue, 24 Apr 2007 09:03:12 +0100"  >&lt;p&gt;Committed test-isolation.diff with revision 531820.&lt;/p&gt;</comment>
                            <comment id="12491427" author="dyret" created="Tue, 24 Apr 2007 21:01:30 +0100"  >&lt;p&gt;Since the last time I ran suites.All a bunch of tests have been ported from the old harness. One of them, lang/ScrollCursors1Test fails when reusing lang result sets. The error is caused by &apos;seenFirst&apos; not being initialized in openCore(). This is fairly easy to fix, but I&apos;m wondering if &apos;target&apos; (a CursorResultSet) needs some kind of resetting in either close() or openCore() as well? (I don&apos;t see any failures that can be tied to this, but just wanted to ask the question).&lt;/p&gt;</comment>
                            <comment id="12491930" author="dyret" created="Thu, 26 Apr 2007 10:30:56 +0100"  >&lt;p&gt;Attaching a patch (resetMembersScrollInsensitive.diff) which&lt;br/&gt;
fixes the failure in lang/ScrollCursors1Test, which can be&lt;br/&gt;
applied independently. derbyall and suites.All pass.&lt;/p&gt;</comment>
                            <comment id="12492217" author="knutanders" created="Fri, 27 Apr 2007 08:55:06 +0100"  >&lt;p&gt;Committed resetMembersScrollInsensitive.diff with revision 533003.&lt;/p&gt;</comment>
                            <comment id="12492330" author="dyret" created="Fri, 27 Apr 2007 17:04:45 +0100"  >&lt;p&gt;Attaching a patch (TempTableToExecute.diff) which implements my suggestion for how to &quot;touch&quot; temporary tables in every execution.&lt;/p&gt;</comment>
                            <comment id="12492331" author="dyret" created="Fri, 27 Apr 2007 17:05:44 +0100"  >&lt;p&gt;Forgot to mention that suites.All and derbyall pass with empTableToExecute.diff.&lt;/p&gt;</comment>
                            <comment id="12492450" author="knutanders" created="Sat, 28 Apr 2007 09:14:19 +0100"  >&lt;p&gt;TempTableToExecute.diff looks correct to me. execute() sounds like a more natural place for this code than fillResultSet().&lt;br/&gt;
Committed revision 533314.&lt;/p&gt;</comment>
                            <comment id="12492842" author="dyret" created="Tue, 1 May 2007 08:44:06 +0100"  >&lt;p&gt;Attaching a patch (RowChanger.diff). An ASSERT is triggered in&lt;br/&gt;
RowChanger.open() when open() is called multiple times without an&lt;br/&gt;
intervening close(). This happens in lang/refActions.sql when&lt;br/&gt;
re-using result sets. The patch makes two changes: &lt;/p&gt;

&lt;p&gt;1) Adds a call to RowChanger.close() in&lt;br/&gt;
   DeleteResultSet.cleanUp()&lt;/p&gt;

&lt;p&gt;2) In DeleteCascadeResultSet.open() it moves the call to&lt;br/&gt;
   cleanUp() (which in turn calls DeleteResultSet.cleanUp()) into&lt;br/&gt;
   the finally block so that it gets called even when an&lt;br/&gt;
   exception is thrown.&lt;/p&gt;

&lt;p&gt;suites.All and derbyall both run without errors. The patch can be&lt;br/&gt;
committed independently.&lt;/p&gt;</comment>
                            <comment id="12494146" author="knutanders" created="Mon, 7 May 2007 23:20:05 +0100"  >&lt;p&gt;Thanks Dyre. The patch looks good. Committed RowChanger.diff with revision 536007.&lt;/p&gt;</comment>
                            <comment id="12495049" author="knutanders" created="Fri, 11 May 2007 14:25:32 +0100"  >&lt;p&gt;I think the candidate row fix proposed in derby-827.extra.diff is correct, although I think it is better to place it in the base class where candidate is declared and instantiated. I also noticed that HashScanResultSet, TableScanResultSet, LastIndexKeyResultSet and DependentResultSet all use candidate rows the same way and probably all need the same fix. The first three of them share a common super class (ScanResultSet), and the last one looks like it should have been a sub-class of ScanResultSet. I have therefore created a patch (candidate.diff) which makes DependentResultSet extend ScanResultSet and pushes the creation/resetting of the candidate row into the base class.&lt;/p&gt;

&lt;p&gt;Also, Dyre mentioned that he would have preferred to use DataValueDescriptor.setToNull() instead of getNewNull(). To avoid the asserts that prevented him from doing it that way, I added a new recycle() method to the DataValueDescriptor interface. This method simply invokes restoreToNull() and returns itself if possible. If it can&apos;t set its value to null, it allocates a new object which it returns.&lt;/p&gt;

&lt;p&gt;suites.All ran cleanly with this patch. Derbyall has not finished yet. Will report back if it fails.&lt;/p&gt;</comment>
                            <comment id="12495063" author="knutanders" created="Fri, 11 May 2007 15:34:18 +0100"  >&lt;p&gt;Derbyall passed for candidate.diff. Unless there are objections, I will commit it in a day or so.&lt;/p&gt;</comment>
                            <comment id="12495120" author="knutanders" created="Fri, 11 May 2007 19:29:09 +0100"  >&lt;p&gt;I have also run run derbyall/suites.All with the combination of candidate.diff and derby827_update920.txt. Now there are no failures in suites.All, and two failures in derbyall (different statistics for dynamicLikeOptimization and staleplans).&lt;/p&gt;</comment>
                            <comment id="12495238" author="knutanders" created="Sat, 12 May 2007 09:11:47 +0100"  >&lt;p&gt;Committed candidate.diff with revision 537353.&lt;/p&gt;</comment>
                            <comment id="12498195" author="knutanders" created="Wed, 23 May 2007 12:18:58 +0100"  >&lt;p&gt;Derbyall and suites.All now run cleanly with derby827_update920.txt. Since all known issues with the patch have been fixed and there is a test for re-executing PreparedStatements (thanks, Dyre!), I think it is safe to commit it. If other issues show up because of the patch, I think they can be handled separately in other JIRAs. Committed to trunk with revision 540921. Thanks Dan for contributing the initial patch, and Dyre for all the work on preparing the surrounding code for this commit!&lt;/p&gt;</comment>
                            <comment id="12512245" author="myrna" created="Thu, 12 Jul 2007 21:21:04 +0100"  >&lt;p&gt;should this issue be marked fixed? Or is there more work?&lt;/p&gt;</comment>
                            <comment id="12519602" author="knutanders" created="Tue, 14 Aug 2007 07:45:22 +0100"  >&lt;p&gt;Marking the issue as resolved in 10.3.0.0 since it seems like all the patches went in before cutting the 10.3 branch. Assigning it to Dyre since he did most of the work to get the fix in (thanks also to Dan for the initial contribution).&lt;/p&gt;</comment>
                            <comment id="12521277" author="djd" created="Tue, 21 Aug 2007 00:24:23 +0100"  >&lt;p&gt;Looking at the code related to this issue I see that ResultSet.finish() is still called once per execution, instead of only when the activation is closed. Examples are:&lt;/p&gt;

&lt;p&gt;EmbedStatement.executeStatement  - line 1267 - resultsToWrap.finish()&lt;/p&gt;

&lt;p&gt;EmbedResultSet.close() - line 570 - theResults.finish()&lt;/p&gt;

&lt;p&gt;This means that the use of ResultSet.finish() does not match its javadoc. Should these calls be ResultSet.close() instead?&lt;/p&gt;</comment>
                            <comment id="12521468" author="knutanders" created="Tue, 21 Aug 2007 15:44:58 +0100"  >&lt;p&gt;I think you are right. It&apos;s a bit strange though that there doesn&apos;t seem to be any problems with reopening a finished ResultSet. I also noticed that BaseActivation.close() calls ResultSet.finish() and BasicNoPutResultSetImpl.finish() calls Activation.close(), so I think there still is some confusion as to when the different methods are to be called. Perhaps you could open a new JIRA for this?&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12386914">DERBY-3343</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12431919">DERBY-4330</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12424270">DERBY-4204</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12368116">DERBY-2594</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12377286">DERBY-3037</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12738395">DERBY-6724</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12383008">DERBY-3221</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12368116">DERBY-2594</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12350467">DERBY-1876</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12389455">DERBY-3459</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12355935" name="MiscResultSetConstantAction.diff" size="2293" author="dyret" created="Fri, 20 Apr 2007 16:19:08 +0100"/>
                            <attachment id="12356558" name="RowChanger.diff" size="1070" author="dyret" created="Tue, 1 May 2007 08:44:06 +0100"/>
                            <attachment id="12356415" name="TempTableToExecute.diff" size="2685" author="dyret" created="Fri, 27 Apr 2007 17:04:45 +0100"/>
                            <attachment id="12357104" name="candidate.diff" size="14377" author="knutanders" created="Fri, 11 May 2007 14:25:25 +0100"/>
                            <attachment id="12357105" name="candidate.stat" size="863" author="knutanders" created="Fri, 11 May 2007 14:25:27 +0100"/>
                            <attachment id="12354079" name="close_nofinish.txt" size="1248" author="dyret" created="Fri, 23 Mar 2007 14:28:46 +0000"/>
                            <attachment id="12355759" name="d827-close-cleanup.diff" size="1910" author="knutanders" created="Wed, 18 Apr 2007 15:20:57 +0100"/>
                            <attachment id="12353883" name="d827_execute_method_cleanup.txt" size="7339" author="djd" created="Wed, 21 Mar 2007 19:08:45 +0000"/>
                            <attachment id="12353853" name="derby-827.extra.diff" size="1230" author="dyret" created="Wed, 21 Mar 2007 15:20:32 +0000"/>
                            <attachment id="12354494" name="derby-827.snapshot.diff" size="28543" author="dyret" created="Thu, 29 Mar 2007 10:43:42 +0100"/>
                            <attachment id="12322145" name="derby827_draft_reuse_result_sets.txt" size="5179" author="djd" created="Fri, 20 Jan 2006 05:14:34 +0000"/>
                            <attachment id="12341326" name="derby827_update920.txt" size="7715" author="djd" created="Thu, 21 Sep 2006 22:00:42 +0100"/>
                            <attachment id="12354559" name="multiprobe_notTested.patch" size="2101" author="army" created="Fri, 30 Mar 2007 00:18:21 +0100"/>
                            <attachment id="12354078" name="noclose_finish.txt" size="849" author="dyret" created="Fri, 23 Mar 2007 14:28:46 +0000"/>
                            <attachment id="12354077" name="noclose_nofinish.txt" size="424" author="dyret" created="Fri, 23 Mar 2007 14:28:46 +0000"/>
                            <attachment id="12356304" name="resetMembersScrollInsensitive.diff" size="861" author="dyret" created="Thu, 26 Apr 2007 10:30:55 +0100"/>
                            <attachment id="12352091" name="rsfromps.v1.diff" size="66524" author="dyret" created="Tue, 27 Feb 2007 08:03:48 +0000"/>
                            <attachment id="12352092" name="rsfromps.v1.stat" size="382" author="dyret" created="Tue, 27 Feb 2007 08:03:54 +0000"/>
                            <attachment id="12351323" name="rsfromps_prelim.diff" size="52895" author="dyret" created="Fri, 16 Feb 2007 08:54:35 +0000"/>
                            <attachment id="12351391" name="rsfromps_prelim2.diff" size="62625" author="dyret" created="Fri, 16 Feb 2007 19:10:10 +0000"/>
                            <attachment id="12356055" name="test-isolation.diff" size="22577" author="knutanders" created="Mon, 23 Apr 2007 15:35:37 +0100"/>
                            <attachment id="12354493" name="test_inbetween.sql" size="2538" author="dyret" created="Thu, 29 Mar 2007 10:43:42 +0100"/>
                    </attachments>
                <subtasks>
                            <subtask id="12368179">DERBY-2597</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 16 Feb 2007 08:54:35 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29726</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0n8v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37584</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>