<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:29:49 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3926/DERBY-3926.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3926] Incorrect ORDER BY caused by index</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3926</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I think I found a bug in Derby that is triggered by an index on a large column: VARCHAR(1024). I know it  is generally not a good idea to have an index on such a large column.&lt;/p&gt;

&lt;p&gt;I have a table (table2) with a column &quot;value&quot;, my query orders on this column but the result is not sorted. It is sorted if I remove the index on that column.&lt;/p&gt;

&lt;p&gt;The output of the attached script is as follows (results should be ordered on the middle column):&lt;br/&gt;
ID                  |VALUE        |VALUE&lt;br/&gt;
----------------------------------------------&lt;br/&gt;
2147483653          |000002       |21857&lt;br/&gt;
2147483654          |000003       |21857&lt;br/&gt;
4294967297          |000001       |21857&lt;/p&gt;

&lt;p&gt;While I would expect:&lt;br/&gt;
ID                  |VALUE        |VALUE&lt;br/&gt;
----------------------------------------------&lt;br/&gt;
4294967297          |000001       |21857&lt;br/&gt;
2147483653          |000002       |21857&lt;br/&gt;
2147483654          |000003       |21857&lt;/p&gt;

&lt;p&gt;This is the definition:&lt;br/&gt;
CREATE TABLE table1 (id BIGINT NOT NULL, PRIMARY KEY(id));&lt;br/&gt;
CREATE INDEX key1 ON table1(id);&lt;br/&gt;
CREATE TABLE table2 (id BIGINT NOT NULL, name VARCHAR(40) NOT NULL, value VARCHAR(1024), PRIMARY KEY(id, name));&lt;br/&gt;
CREATE UNIQUE INDEX key2 ON table2(id, name);&lt;br/&gt;
CREATE INDEX key3 ON table2(value);&lt;/p&gt;

&lt;p&gt;This is the query:&lt;br/&gt;
SELECT table1.id, m0.value, m1.value&lt;br/&gt;
FROM table1, table2 m0, table2 m1&lt;br/&gt;
WHERE table1.id=m0.id&lt;br/&gt;
AND m0.name=&apos;PageSequenceId&apos;&lt;br/&gt;
AND table1.id=m1.id&lt;br/&gt;
AND m1.name=&apos;PostComponentId&apos;&lt;br/&gt;
AND m1.value=&apos;21857&apos;&lt;br/&gt;
ORDER BY m0.value;&lt;/p&gt;

&lt;p&gt;The bug can be reproduced by just executing the attached script with the ij-tool.&lt;br/&gt;
Note that the result of the query becomes correct when enough data is changed. This prevented me from creating a smaller example.&lt;/p&gt;

&lt;p&gt;See the attached file &quot;derby-reproduce.zip&quot; for sysinfo, derby.log and script.sql.&lt;/p&gt;

&lt;p&gt;Michael Segel pointed out:&lt;br/&gt;
&quot;It looks like its hitting the index ordering on id,name from table 2 and is ignoring the order by clause.&quot;&lt;/p&gt;</description>
                <environment>Checked into 10.3. This will still go to 10.2 and 10.1&lt;br/&gt;
</environment>
        <key id="12407399">DERBY-3926</key>
            <summary>Incorrect ORDER BY caused by index</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mamtas">Mamta A. Satoor</assignee>
                                    <reporter username="tjoris">Tars Joris</reporter>
                        <labels>
                    </labels>
                <created>Wed, 29 Oct 2008 08:56:57 +0000</created>
                <updated>Thu, 16 May 2013 07:53:30 +0100</updated>
                            <resolved>Wed, 12 Aug 2009 17:23:08 +0100</resolved>
                                    <version>10.1.3.3</version>
                    <version>10.2.2.1</version>
                    <version>10.3.3.1</version>
                    <version>10.4.2.0</version>
                                    <fixVersion>10.1.3.3</fixVersion>
                    <fixVersion>10.2.2.1</fixVersion>
                    <fixVersion>10.3.3.1</fixVersion>
                    <fixVersion>10.4.2.1</fixVersion>
                    <fixVersion>10.5.2.0</fixVersion>
                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12643442" author="tjoris" created="Wed, 29 Oct 2008 08:58:10 +0000"  >&lt;p&gt;derby.log&lt;br/&gt;
output.txt&lt;br/&gt;
script.sql&lt;br/&gt;
sysinfo.txt&lt;/p&gt;</comment>
                            <comment id="12658240" author="stan" created="Sat, 20 Dec 2008 01:03:32 +0000"  >&lt;p&gt;I verified the report then dropped and recreated the index key3.  The records ordered properly after that.  Go figure...??  With the newly created cardinality statistics it may be the correct index is selected this time but the original results are still wrong.&lt;/p&gt;

&lt;p&gt;ij&amp;gt; SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 WHERE tab&lt;br/&gt;
ER BY m0.value;&lt;br/&gt;
ID                  |VALUE&lt;br/&gt;
----------------------------------------------------------------------------------&lt;br/&gt;
------------------------------------------------------------------------------&lt;br/&gt;
2147483653          |000002&lt;br/&gt;
2147483654          |000003&lt;br/&gt;
4294967297          |000001&lt;br/&gt;
3 rows selected&lt;/p&gt;

&lt;p&gt;ij&amp;gt; drop index key3;&lt;br/&gt;
0 rows inserted/updated/deleted&lt;/p&gt;

&lt;p&gt;ij&amp;gt; SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 WHERE&lt;br/&gt;
table1.id=m0.id AND m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND&lt;br/&gt;
m1.name=&apos;PostComponentId&apos; AND m1.value=&apos;21857&apos; ORDER BY m0.value;&lt;br/&gt;
ID                  |VALUE&lt;br/&gt;
------------------------------------------------------------------------------------&lt;br/&gt;
------------------------------------------------------------------------------&lt;br/&gt;
4294967297          |000001&lt;br/&gt;
2147483653          |000002&lt;br/&gt;
2147483654          |000003&lt;br/&gt;
3 rows selected&lt;/p&gt;

&lt;p&gt;ij&amp;gt; CREATE INDEX key3 ON table2(value);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 WHERE&lt;br/&gt;
table1.id=m0.id AND m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND&lt;br/&gt;
m1.name=&apos;PostComponentId&apos; AND m1.value=&apos;21857&apos; ORDER BY m0.value;&lt;br/&gt;
ID                  |VALUE&lt;br/&gt;
------------------------------------------------------------------------------------&lt;br/&gt;
------------------------------------------------------------------------------&lt;br/&gt;
4294967297          |000001&lt;br/&gt;
2147483653          |000002&lt;br/&gt;
2147483654          |000003&lt;/p&gt;


&lt;p&gt;3 rows selected&lt;/p&gt;</comment>
                            <comment id="12683974" author="mamtas" created="Fri, 20 Mar 2009 18:21:26 +0000"  >&lt;p&gt;I ran the reporducible test case with couple different releases of Derby and noticed following&lt;br/&gt;
1)on trunk, if I quit out of the ij session which does the setup and runs the query with incorrect results, and then start a new session and run the query again it returns correct result. I didn&apos;t have to drop and recreate the index for it to work. The plan used in the 2 cases for the query are different&lt;br/&gt;
2)I found the same behavior in 10.2 codeline&lt;br/&gt;
3)With 10.1 codeline, I ran into npe when trying to run the setup script. Not sure what is going on there. I will enter a jira entry for the 10.1 behavior.&lt;/p&gt;</comment>
                            <comment id="12683990" author="mamtas" created="Fri, 20 Mar 2009 19:00:48 +0000"  >&lt;p&gt;The query plan when the incorrect results are returned is as follows&lt;br/&gt;
Statement Name:&lt;br/&gt;
        null&lt;br/&gt;
Statement Text:&lt;br/&gt;
        SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 W&lt;br/&gt;
HERE table1.id=m0.id AND&lt;br/&gt;
m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND m1.name=&apos;PostComponentId&apos; AND m&lt;br/&gt;
1.value=&apos;21857&apos; ORDER BY&lt;br/&gt;
m0.value&lt;br/&gt;
Parse Time: 0&lt;br/&gt;
Bind Time: 0&lt;br/&gt;
Optimize Time: 0&lt;br/&gt;
Generate Time: 0&lt;br/&gt;
Compile Time: 0&lt;br/&gt;
Execute Time: 0&lt;br/&gt;
Begin Compilation Timestamp : null&lt;br/&gt;
End Compilation Timestamp : null&lt;br/&gt;
Begin Execution Timestamp : null&lt;br/&gt;
End Execution Timestamp : null&lt;br/&gt;
Statement Execution Plan Text:&lt;br/&gt;
Project-Restrict ResultSet (10):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 3&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
        constructor time (milliseconds) = 0&lt;br/&gt;
        open time (milliseconds) = 0&lt;br/&gt;
        next time (milliseconds) = 0&lt;br/&gt;
        close time (milliseconds) = 0&lt;br/&gt;
        restriction time (milliseconds) = 0&lt;br/&gt;
        projection time (milliseconds) = 0&lt;br/&gt;
        optimizer estimated row count:            0.00&lt;br/&gt;
        optimizer estimated cost:            3.52&lt;/p&gt;

&lt;p&gt;Source result set:&lt;br/&gt;
        Nested Loop Join ResultSet:&lt;br/&gt;
        Number of opens = 1&lt;br/&gt;
        Rows seen from the left = 168&lt;br/&gt;
        Rows seen from the right = 3&lt;br/&gt;
        Rows filtered = 0&lt;br/&gt;
        Rows returned = 3&lt;br/&gt;
                constructor time (milliseconds) = 0&lt;br/&gt;
                open time (milliseconds) = 0&lt;br/&gt;
                next time (milliseconds) = 0&lt;br/&gt;
                close time (milliseconds) = 0&lt;br/&gt;
                optimizer estimated row count:            0.00&lt;br/&gt;
                optimizer estimated cost:            3.52&lt;/p&gt;

&lt;p&gt;        Left result set:&lt;br/&gt;
                Nested Loop Join ResultSet:&lt;br/&gt;
                Number of opens = 1&lt;br/&gt;
                Rows seen from the left = 3&lt;br/&gt;
                Rows seen from the right = 168&lt;br/&gt;
                Rows filtered = 0&lt;br/&gt;
                Rows returned = 168&lt;br/&gt;
                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        optimizer estimated row count:            0.00&lt;br/&gt;
                        optimizer estimated cost:            3.52&lt;/p&gt;

&lt;p&gt;                Left result set:&lt;br/&gt;
                        Project-Restrict ResultSet (5):&lt;br/&gt;
                        Number of opens = 1&lt;br/&gt;
                        Rows seen = 3&lt;br/&gt;
                        Rows filtered = 0&lt;br/&gt;
                        restriction = true&lt;br/&gt;
                        projection = true&lt;br/&gt;
                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                restriction time (milliseconds) = 0&lt;br/&gt;
                                projection time (milliseconds) = 0&lt;br/&gt;
                                optimizer estimated row count:            0.00&lt;br/&gt;
                                optimizer estimated cost:            3.52&lt;/p&gt;

&lt;p&gt;                        Source result set:&lt;br/&gt;
                                Index Row to Base Row ResultSet for TABLE2:&lt;br/&gt;
                                Number of opens = 1&lt;br/&gt;
                                Rows seen = 3&lt;br/&gt;
                                Columns accessed from heap = &lt;/p&gt;
{0, 1, 2}&lt;br/&gt;
                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        optimizer estimated row count:  0.00&lt;br/&gt;
                                        optimizer estimated cost:            3.52&lt;br/&gt;
                                        Index Scan ResultSet for TABLE2 using index KEY3 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                                        Number of opens = 1&lt;br/&gt;
                                        Rows seen = 3&lt;br/&gt;
                                        Rows filtered = 0&lt;br/&gt;
                                        Fetch Size = 1&lt;br/&gt;
                                                constructor time (milliseconds)= 0&lt;br/&gt;
                                                open time (milliseconds) = 0&lt;br/&gt;
                                                next time (milliseconds) = 0&lt;br/&gt;
                                                close time (milliseconds) = 0&lt;br/&gt;
                                                next time in milliseconds/row =0&lt;br/&gt;
                                        scan information:&lt;br/&gt;
                                                Bit set of columns fetched=All&lt;br/&gt;
                                                Number of columns fetched=2&lt;br/&gt;
                                                Number of deleted rows visited=0&lt;br/&gt;
&lt;br/&gt;
                                                Number of pages visited=2&lt;br/&gt;
                                                Number of rows qualified=3&lt;br/&gt;
                                                Number of rows visited=4&lt;br/&gt;
                                                Scan type=btree&lt;br/&gt;
                                                Tree height=-1&lt;br/&gt;
                                                start position:&lt;br/&gt;
        &amp;gt;= on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;br/&gt;
&lt;br/&gt;
                                                stop position:&lt;br/&gt;
        &amp;gt; on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;br/&gt;
&lt;br/&gt;
                                                qualifiers:None&lt;br/&gt;
                                                optimizer estimated row count:        0.00&lt;br/&gt;
                                                optimizer estimated cost:     3.52&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
                Right result set:&lt;br/&gt;
                        Project-Restrict ResultSet (8):&lt;br/&gt;
                        Number of opens = 3&lt;br/&gt;
                        Rows seen = 8688&lt;br/&gt;
                        Rows filtered = 8520&lt;br/&gt;
                        restriction = true&lt;br/&gt;
                        projection = true&lt;br/&gt;
                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                restriction time (milliseconds) = 0&lt;br/&gt;
                                projection time (milliseconds) = 0&lt;br/&gt;
                                optimizer estimated row count:            0.00&lt;br/&gt;
                                optimizer estimated cost:            0.00&lt;br/&gt;
&lt;br/&gt;
                        Source result set:&lt;br/&gt;
                                Index Row to Base Row ResultSet for TABLE2:&lt;br/&gt;
                                Number of opens = 3&lt;br/&gt;
                                Rows seen = 8688&lt;br/&gt;
                                Columns accessed from heap = {0, 1, 2}
&lt;p&gt;                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        optimizer estimated row count:  0.00&lt;br/&gt;
                                        optimizer estimated cost:            0.00&lt;/p&gt;

&lt;p&gt;                                        Index Scan ResultSet for TABLE2 using index KEY3 at read committed isolation level using share row locking chosen by the&lt;br/&gt;
 optimizer&lt;br/&gt;
                                        Number of opens = 3&lt;br/&gt;
                                        Rows seen = 8688&lt;br/&gt;
                                        Rows filtered = 0&lt;br/&gt;
                                        Fetch Size = 1&lt;br/&gt;
                                                constructor time (milliseconds)= 0&lt;br/&gt;
                                                open time (milliseconds) = 0&lt;br/&gt;
                                                next time (milliseconds) = 0&lt;br/&gt;
                                                close time (milliseconds) = 0&lt;br/&gt;
                                                next time in milliseconds/row =0&lt;/p&gt;

&lt;p&gt;                                        scan information:&lt;br/&gt;
                                                Bit set of columns fetched=&lt;/p&gt;
{1}
&lt;p&gt;                                                Number of columns fetched=1&lt;br/&gt;
                                                Number of deleted rows visited=0&lt;/p&gt;

&lt;p&gt;                                                Number of pages visited=12&lt;br/&gt;
                                                Number of rows qualified=8688&lt;br/&gt;
                                                Number of rows visited=8688&lt;br/&gt;
                                                Scan type=btree&lt;br/&gt;
                                                Tree height=2&lt;br/&gt;
                                                start position:        None&lt;br/&gt;
                                                stop position:        None&lt;br/&gt;
                                                qualifiers:None&lt;br/&gt;
                                                optimizer estimated row count:          0.00&lt;br/&gt;
                                                optimizer estimated cost:     0.00&lt;/p&gt;



&lt;p&gt;        Right result set:&lt;br/&gt;
                Table Scan ResultSet for TABLE1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
                Number of opens = 168&lt;br/&gt;
                Rows seen = 3&lt;br/&gt;
                Rows filtered = 0&lt;br/&gt;
                Fetch Size = 16&lt;br/&gt;
                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;                scan information:&lt;br/&gt;
                        Bit set of columns fetched=All&lt;br/&gt;
                        Number of columns fetched=1&lt;br/&gt;
                        Number of pages visited=1&lt;br/&gt;
                        Number of rows qualified=3&lt;br/&gt;
                        Number of rows visited=9408&lt;br/&gt;
                        Scan type=heap&lt;br/&gt;
                        start position:&lt;br/&gt;
null                    stop position:&lt;br/&gt;
null                    qualifiers:&lt;br/&gt;
Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
Operator: =&lt;br/&gt;
Ordered nulls: false&lt;br/&gt;
Unknown return value: false&lt;br/&gt;
Negate comparison result: false&lt;br/&gt;
Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
Operator: =&lt;br/&gt;
Ordered nulls: false&lt;br/&gt;
Unknown return value: false&lt;br/&gt;
Negate comparison result: false&lt;/p&gt;

&lt;p&gt;                        optimizer estimated row count:            0.00&lt;br/&gt;
                        optimizer estimated cost:            0.00&lt;/p&gt;</comment>
                            <comment id="12683992" author="mamtas" created="Fri, 20 Mar 2009 19:03:27 +0000"  >&lt;p&gt;The query plan when the correct results are returned is as follows&lt;br/&gt;
Statement Name:&lt;br/&gt;
        null&lt;br/&gt;
Statement Text:&lt;br/&gt;
        SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 W&lt;br/&gt;
HERE table1.id=m0.id AND&lt;br/&gt;
m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND m1.name=&apos;PostComponentId&apos; AND m&lt;br/&gt;
1.value=&apos;21857&apos; ORDER BY&lt;br/&gt;
m0.value&lt;br/&gt;
Parse Time: 0&lt;br/&gt;
Bind Time: 0&lt;br/&gt;
Optimize Time: 0&lt;br/&gt;
Generate Time: 0&lt;br/&gt;
Compile Time: 0&lt;br/&gt;
Execute Time: 0&lt;br/&gt;
Begin Compilation Timestamp : null&lt;br/&gt;
End Compilation Timestamp : null&lt;br/&gt;
Begin Execution Timestamp : null&lt;br/&gt;
End Execution Timestamp : null&lt;br/&gt;
Statement Execution Plan Text:&lt;br/&gt;
Sort ResultSet:&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows input = 3&lt;br/&gt;
Rows returned = 3&lt;br/&gt;
Eliminate duplicates = false&lt;br/&gt;
In sorted order = false&lt;br/&gt;
Sort information:&lt;br/&gt;
        Number of rows input=3&lt;br/&gt;
        Number of rows output=3&lt;br/&gt;
        Sort type=internal&lt;br/&gt;
        constructor time (milliseconds) = 0&lt;br/&gt;
        open time (milliseconds) = 0&lt;br/&gt;
        next time (milliseconds) = 0&lt;br/&gt;
        close time (milliseconds) = 0&lt;br/&gt;
        optimizer estimated row count:            0.20&lt;br/&gt;
        optimizer estimated cost:            8.26&lt;/p&gt;

&lt;p&gt;Source result set:&lt;br/&gt;
        Project-Restrict ResultSet (9):&lt;br/&gt;
        Number of opens = 1&lt;br/&gt;
        Rows seen = 3&lt;br/&gt;
        Rows filtered = 0&lt;br/&gt;
        restriction = false&lt;br/&gt;
        projection = true&lt;br/&gt;
                constructor time (milliseconds) = 0&lt;br/&gt;
                open time (milliseconds) = 0&lt;br/&gt;
                next time (milliseconds) = 0&lt;br/&gt;
                close time (milliseconds) = 0&lt;br/&gt;
                restriction time (milliseconds) = 0&lt;br/&gt;
                projection time (milliseconds) = 0&lt;br/&gt;
                optimizer estimated row count:            0.20&lt;br/&gt;
                optimizer estimated cost:            8.26&lt;/p&gt;

&lt;p&gt;        Source result set:&lt;br/&gt;
                Nested Loop Exists Join ResultSet:&lt;br/&gt;
                Number of opens = 1&lt;br/&gt;
                Rows seen from the left = 3&lt;br/&gt;
                Rows seen from the right = 3&lt;br/&gt;
                Rows filtered = 0&lt;br/&gt;
                Rows returned = 3&lt;br/&gt;
                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        optimizer estimated row count:            0.20&lt;br/&gt;
                        optimizer estimated cost:            8.26&lt;/p&gt;

&lt;p&gt;                Left result set:&lt;br/&gt;
                        Nested Loop Exists Join ResultSet:&lt;br/&gt;
                        Number of opens = 1&lt;br/&gt;
                        Rows seen from the left = 3&lt;br/&gt;
                        Rows seen from the right = 3&lt;br/&gt;
                        Rows filtered = 0&lt;br/&gt;
                        Rows returned = 3&lt;br/&gt;
                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                optimizer estimated row count:            0.20&lt;br/&gt;
                                optimizer estimated cost:            7.29&lt;/p&gt;

&lt;p&gt;                        Left result set:&lt;br/&gt;
                                Project-Restrict ResultSet (5):&lt;br/&gt;
                                Number of opens = 1&lt;br/&gt;
                                Rows seen = 3&lt;br/&gt;
                                Rows filtered = 0&lt;br/&gt;
                                restriction = true&lt;br/&gt;
                                projection = true&lt;br/&gt;
                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        restriction time (milliseconds) = 0&lt;br/&gt;
                                        projection time (milliseconds) = 0&lt;br/&gt;
                                        optimizer estimated row count:&lt;br/&gt;
  0.20&lt;br/&gt;
                                        optimizer estimated cost:            6.9&lt;br/&gt;
7&lt;/p&gt;

&lt;p&gt;                                Source result set:&lt;br/&gt;
                                        Index Row to Base Row ResultSet for TABL&lt;br/&gt;
E2:&lt;br/&gt;
                                        Number of opens = 1&lt;br/&gt;
                                        Rows seen = 3&lt;br/&gt;
                                        Columns accessed from heap = &lt;/p&gt;
{0, 1, 2}
&lt;p&gt;                                                constructor time (milliseconds)&lt;br/&gt;
= 0&lt;br/&gt;
                                                open time (milliseconds) = 0&lt;br/&gt;
                                                next time (milliseconds) = 0&lt;br/&gt;
                                                close time (milliseconds) = 0&lt;br/&gt;
                                                optimizer estimated row count:&lt;br/&gt;
          0.20&lt;br/&gt;
                                                optimizer estimated cost:&lt;br/&gt;
     6.97&lt;/p&gt;

&lt;p&gt;                                                Index Scan ResultSet for TABLE2using index KEY3 at read committed isolation level using instantaneous share row&lt;br/&gt;
 locking chosen by the optimizer&lt;br/&gt;
                                                Number of opens = 1&lt;br/&gt;
                                                Rows seen = 3&lt;br/&gt;
                                                Rows filtered = 0&lt;br/&gt;
                                                Fetch Size = 16&lt;br/&gt;
                                                        constructor time (millis&lt;br/&gt;
econds) = 0&lt;br/&gt;
                                                        open time (milliseconds)&lt;br/&gt;
 = 0&lt;br/&gt;
                                                        next time (milliseconds)&lt;br/&gt;
 = 0&lt;br/&gt;
                                                        close time (milliseconds&lt;br/&gt;
) = 0&lt;br/&gt;
                                                        next time in millisecond&lt;br/&gt;
s/row = 0&lt;/p&gt;

&lt;p&gt;                                                scan information:&lt;br/&gt;
                                                        Bit set of columns fetch&lt;br/&gt;
ed=All&lt;br/&gt;
                                                        Number of columns fetche&lt;br/&gt;
d=2&lt;br/&gt;
                                                        Number of deleted rows v&lt;br/&gt;
isited=0&lt;br/&gt;
                                                        Number of pages visited=&lt;br/&gt;
2&lt;br/&gt;
                                                        Number of rows qualified&lt;br/&gt;
=3&lt;br/&gt;
                                                        Number of rows visited=4&lt;/p&gt;

&lt;p&gt;                                                        Scan type=btree&lt;br/&gt;
                                                        Tree height=2&lt;br/&gt;
                                                        start position:&lt;br/&gt;
        &amp;gt;= on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;/p&gt;

&lt;p&gt;                                                        stop position:&lt;br/&gt;
        &amp;gt; on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;/p&gt;

&lt;p&gt;                                                        qualifiers:&lt;br/&gt;
None&lt;br/&gt;
                                                        optimizer estimated row&lt;br/&gt;
count:            0.20&lt;br/&gt;
                                                        optimizer estimated cost&lt;br/&gt;
:            6.97&lt;/p&gt;


&lt;p&gt;                        Right result set:&lt;br/&gt;
                                Index Scan ResultSet for TABLE1 using constraint SQL090320113016460 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                                Number of opens = 3&lt;br/&gt;
                                Rows seen = 3&lt;br/&gt;
                                Rows filtered = 0&lt;br/&gt;
                                Fetch Size = 1&lt;br/&gt;
                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;                                scan information:&lt;br/&gt;
                                        Bit set of columns fetched=&lt;/p&gt;
{0}
&lt;p&gt;                                        Number of columns fetched=1&lt;br/&gt;
                                        Number of deleted rows visited=0&lt;br/&gt;
                                        Number of pages visited=3&lt;br/&gt;
                                        Number of rows qualified=3&lt;br/&gt;
                                        Number of rows visited=3&lt;br/&gt;
                                        Scan type=btree&lt;br/&gt;
                                        Tree height=1&lt;br/&gt;
                                        start position:&lt;br/&gt;
        &amp;gt;= on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;br/&gt;
0&lt;br/&gt;
                                        stop position:&lt;br/&gt;
        &amp;gt; on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;br/&gt;
0&lt;br/&gt;
                                        qualifiers:&lt;br/&gt;
None&lt;br/&gt;
                                        optimizer estimated row count:&lt;br/&gt;
  0.20&lt;br/&gt;
                                        optimizer estimated cost:            0.31&lt;/p&gt;


&lt;p&gt;                Right result set:&lt;br/&gt;
                        Index Row to Base Row ResultSet for TABLE2:&lt;br/&gt;
                        Number of opens = 3&lt;br/&gt;
                        Rows seen = 3&lt;br/&gt;
                        Columns accessed from heap = &lt;/p&gt;
{2}
&lt;p&gt;                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                optimizer estimated row count:            0.20&lt;br/&gt;
                                optimizer estimated cost:            0.97&lt;/p&gt;

&lt;p&gt;                                Index Scan ResultSet for TABLE2 using constraint SQL090320113016670 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                                Number of opens = 3&lt;br/&gt;
                                Rows seen = 3&lt;br/&gt;
                                Rows filtered = 0&lt;br/&gt;
                                Fetch Size = 1&lt;br/&gt;
                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;                                scan information:&lt;br/&gt;
                                        Bit set of columns fetched=All&lt;br/&gt;
                                        Number of columns fetched=3&lt;br/&gt;
                                        Number of deleted rows visited=0&lt;br/&gt;
                                        Number of pages visited=6&lt;br/&gt;
                                        Number of rows qualified=3&lt;br/&gt;
                                        Number of rows visited=3&lt;br/&gt;
                                        Scan type=btree&lt;br/&gt;
                                        Tree height=2&lt;br/&gt;
                                        start position:&lt;br/&gt;
        &amp;gt;= on first 2 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:0 1&lt;br/&gt;
                                        stop position:&lt;br/&gt;
        &amp;gt; on first 2 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:0 1&lt;br/&gt;
                                        qualifiers:None&lt;br/&gt;
                                        optimizer estimated row count:  0.20&lt;br/&gt;
                                        optimizer estimated cost:            0.97&lt;/p&gt;</comment>
                            <comment id="12684012" author="mikem" created="Fri, 20 Mar 2009 19:55:52 +0000"  >&lt;p&gt;to me looks like the problem comes with plan that is trying to do sort avoidance.  The working plan has a sort node on the top.  &lt;/p&gt;

&lt;p&gt;But to me the &quot;bad&quot; plan looks like a valid sort avoidance plan.  Seems to have index scans on the left side, using key3 which is sorted on the value that the query in the end wants to be sorted on.  &lt;/p&gt;</comment>
                            <comment id="12684021" author="mikem" created="Fri, 20 Mar 2009 20:51:15 +0000"  >&lt;p&gt;could it be that the leftmost join is actually on the m1.value part of the query rather than the m0.value of the query.  maybe something got confused about the self join with 2 different &quot;range&quot; variables.  &lt;/p&gt;</comment>
                            <comment id="12685364" author="mamtas" created="Fri, 20 Mar 2009 21:17:53 +0000"  >&lt;p&gt;Once &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4105&quot; title=&quot;NPE when the attached reproducible script is run using ij.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4105&quot;&gt;&lt;del&gt;DERBY-4105&lt;/del&gt;&lt;/a&gt; is fixed, make sure that whatever fix is checked in for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3926&quot; title=&quot;Incorrect ORDER BY caused by index&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3926&quot;&gt;&lt;del&gt;DERBY-3926&lt;/del&gt;&lt;/a&gt; works in 10.1 release too.&lt;/p&gt;</comment>
                            <comment id="12685372" author="kmarsden" created="Fri, 20 Mar 2009 21:54:35 +0000"  >&lt;p&gt;I noticed that this issue also occurs on versions back to 10.1&lt;/p&gt;</comment>
                            <comment id="12688322" author="mamtas" created="Mon, 23 Mar 2009 16:49:48 +0000"  >&lt;p&gt;My apologies for false alarm on 10.1 codeline. I noticed that I had some local changes made on that client. Once i reverted them, the npe went away. I will mark the new jira entry  &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4015&quot; title=&quot;Regression in Statement.getGeneratedKeys()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4015&quot;&gt;DERBY-4015&lt;/a&gt; for npe as not a bug.&lt;/p&gt;</comment>
                            <comment id="12688804" author="mamtas" created="Tue, 24 Mar 2009 19:15:32 +0000"  >&lt;p&gt;I will spend little time on this jira. As Mike pointed out, it is a possibilit that in the wrong result case, may be we are getting confused with m0 and m1 which basically are involved in a self join. &lt;/p&gt;

&lt;p&gt;For a given query, if the optimizer chooses a query plan with an index key for say a where clause and it finds that the same key can be used to satisfy the order by, then in that case, optimizer will avoid doing the sorting required for order by because the rows are already in order based on the index key used to satisfy where clause.&lt;/p&gt;

&lt;p&gt;In this particular case, there is an index called key3 on table2.value which can be used to satisfy the m1.value=&apos;21857&apos;.  It is possible that may be there is some bug in optimizer which thinks that the index used for m1.value can be used to avoid the sorting required for m0.value. But the sort should not be avoided because the order by is on m0.value and not m1.value and hence index used for m1.value can&apos;t be used to avoid the sort on m0.value. I will debug this a little to see what is index key3 being used for ie m0 or m1. It is unclear from the query plan whether the index key3 is being used on m0 or m1.&lt;/p&gt;

&lt;p&gt;SELECT table1.id, m0.value, m1.value &lt;br/&gt;
FROM table1, table2 m0, table2 m1 &lt;br/&gt;
WHERE table1.id=m0.id &lt;br/&gt;
AND m0.name=&apos;PageSequenceId&apos; &lt;br/&gt;
AND table1.id=m1.id &lt;br/&gt;
AND m1.name=&apos;PostComponentId&apos; &lt;br/&gt;
AND m1.value=&apos;21857&apos; &lt;br/&gt;
ORDER BY m0.value; &lt;/p&gt;</comment>
                            <comment id="12689785" author="mamtas" created="Fri, 27 Mar 2009 02:39:21 +0000"  >&lt;p&gt;I debugged to see which table is picked as the leftmost table since it is unclear from the query plan what we mean when we say TABLE2 is the leftmost table. There is a self-join involved with TABLE2 and we use aliases m0 and m1 for them but in the query plan, we talk about them as just TABLE2 and not along  with their alias names. It appears that in both failing and passing case, m1 is the leftmost table in the query plan chosen for the queries. (I made one line change in my client to impl\sql\compile\IndexToBaseRowNode.java where rather than just sending the table name, I send both table name and alias name to the query plan collection logic. The code change is shown below&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;mb.push(source.getBaseTableName());&lt;br/&gt;
+               mb.push(source.getBaseTableName() + &quot; &quot; + source.getCorrelationName());&lt;br/&gt;
With the change above, I can see in the query plan for the failing and passing case that the leftmost resultset is for TABLE2 M1. I will go ahead and enter a jira entry to make query plan more readable by including the alias name along with the table name.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will next look at why we decide to skip the sorting in the failing case. That seems to be the only difference between the 2 query plans.&lt;/p&gt;</comment>
                            <comment id="12689790" author="bryanpendleton" created="Fri, 27 Mar 2009 02:50:02 +0000"  >&lt;p&gt;Including the alias name in the query plan output seems like a great idea. Thanks for tracking that down!&lt;/p&gt;</comment>
                            <comment id="12689969" author="bryanpendleton" created="Fri, 27 Mar 2009 17:12:18 +0000"  >&lt;p&gt;Hi Mamta thanks for all the hard work on this.&lt;/p&gt;

&lt;p&gt;I just wanted to comment that I think your theory that &quot;may be there is some bug in optimizer &lt;br/&gt;
which thinks that the index used for m1.value can be used to avoid the sorting required for m0.value&quot;&lt;br/&gt;
is a really good theory, and I think this is a good idea to explore in depth.&lt;/p&gt;</comment>
                            <comment id="12690020" author="mikem" created="Fri, 27 Mar 2009 19:44:28 +0000"  >&lt;p&gt;I also agree that including the alias name would be great.  Make sure to include a sample of what the query plan looks like after your change in the other jira.&lt;/p&gt;

&lt;p&gt;I also was guessing that the optimizer got confused by the two aliases on the same table.  It seems like you should find where in the optimizer we determine how the current query plan is sorted and we must compare that with how the query wants to be sorted to determine if the current plan is a valid &quot;sort avoidance&quot; plan.  My guess is that at this point we somehow pass in that the plan is sorted a table2.value but somewhere we are not recognizing that we need to &lt;br/&gt;
check for m0.value.  but just a guess.  It could also be a bug where we are passing in the wrong alias to the check.&lt;/p&gt;</comment>
                            <comment id="12694206" author="mamtas" created="Tue, 31 Mar 2009 19:40:02 +0100"  >&lt;p&gt;I spent some time in comparing the code path for the working case and non-working case in a debugger. What I found is in optimize phase, at one point, one of the join orders we try in non-working case is 2,0,1 and for the working case it is 2,0,-1. &lt;br/&gt;
0 stands for Table1 and 1 stands for Table2 m0, 2 stands for Table2 m1. -1 means that join position is not being used. I am not sure why we are picking different join orders. In addition to that, I see that for the 2,0,1 join order in non-working case, we indeed mark sort avoidance for Table2 m0, I definitely need to do more debugging to see why we think for this join order, we can avoid sorting for Table2 m0. I realize this is not much information but wanted to share what I have. &lt;/p&gt;</comment>
                            <comment id="12695057" author="mamtas" created="Thu, 2 Apr 2009 17:55:03 +0100"  >&lt;p&gt;Another interesting thing I noticed (in both working and non-working case) is we do recognize the optimize phase that sorting is required for m0 for the order by clause as shown belowHere, for the join order &lt;span class=&quot;error&quot;&gt;&amp;#91;2, 0, 1&amp;#93;&lt;/span&gt;, we identify that sorting is required for M0.&lt;br/&gt;
Thread &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; (Suspended)	&lt;br/&gt;
	OrderByList.sortRequired(RowOrdering, JBitSet) line: 549	&lt;br/&gt;
	Level2OptimizerImpl(OptimizerImpl).costBasedCostOptimizable(Optimizable, TableDescriptor, ConglomerateDescriptor, OptimizablePredicateList, CostEstimate) line: 2248	&lt;br/&gt;
	Level2OptimizerImpl(OptimizerImpl).costOptimizable(Optimizable, TableDescriptor, ConglomerateDescriptor, OptimizablePredicateList, CostEstimate) line: 1984	&lt;br/&gt;
	FromBaseTable.optimizeIt(Optimizer, OptimizablePredicateList, CostEstimate, RowOrdering) line: 521	&lt;br/&gt;
	ProjectRestrictNode.optimizeIt(Optimizer, OptimizablePredicateList, CostEstimate, RowOrdering) line: 316	&lt;br/&gt;
	Level2OptimizerImpl(OptimizerImpl).costPermutation() line: 1938	&lt;br/&gt;
	SelectNode.optimize(DataDictionary, PredicateList, double) line: 1767	&lt;br/&gt;
	CursorNode(DMLStatementNode).optimizeStatement() line: 305	&lt;br/&gt;
	CursorNode.optimizeStatement() line: 515	&lt;br/&gt;
	GenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 367	&lt;br/&gt;
	GenericStatement.prepare(LanguageConnectionContext, boolean) line: 88	&lt;br/&gt;
	GenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 802	&lt;br/&gt;
	EmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 606	&lt;br/&gt;
	ij.executeImmediate(String) line: 329	&lt;br/&gt;
	utilMain.doCatch(String) line: 505	&lt;br/&gt;
	utilMain.runScriptGuts() line: 347	&lt;br/&gt;
	utilMain.go(LocalizedInput[], LocalizedOutput) line: 245	&lt;br/&gt;
	Main.go(LocalizedInput, LocalizedOutput) line: 210	&lt;br/&gt;
	Main.mainCore(String[], Main) line: 177	&lt;br/&gt;
	Main.main(String[]) line: 73	&lt;br/&gt;
	Main.main(String[]) line: 73	&lt;br/&gt;
	ij.main(String[]) line: 59	&lt;br/&gt;
But it is obvious from the query plan for non-working that somehow we later decide to do sort avoidance for m0. I will look more to see where the optimizer changes it mind about the sort requirement for m0.&lt;/p&gt;</comment>
                            <comment id="12697757" author="mamtas" created="Fri, 10 Apr 2009 07:40:28 +0100"  >&lt;p&gt;For the incorrect case, the join order picked is 2,1,0 which m1, m0, table1 where as for the correct case, the join order picked is 2,0,1 which is m1,table1,m0. The other interesting thing in case of incorrect case is, for m0, for the plan used for m0, both the &quot;optimizer estimated row count&quot; and &quot;optimizer estimated cost&quot; are 0.00. Is it possible for the optimizer to be able to find a plan for a table such that the &quot;optimizer estimated row count&quot; and &quot;optimizer estimated cost&quot; can be 0? Maybe that is a valid situation, I don&apos;t know enough about the optimizer yet to answer that question but I though those statistics were worth bringing it up for discussion. &lt;/p&gt;
</comment>
                            <comment id="12697764" author="mamtas" created="Fri, 10 Apr 2009 08:53:09 +0100"  >&lt;p&gt;During query optimization phase, we need to know the estimated row count for the tables involved in the query. What I have found during debugging  of the correct case and incorrect case is that the estimated row count is not the same in the 2 cases. When we finish the database session in which the tables, indexes are created, as part of closing the session, we must update the estimated row count and that would explain why the count is different for the same table. Of course, this change in estimated row count must be factoring in what plan gets picked up by the optimizer. &lt;/p&gt;

&lt;p&gt;Next, I am planning on pursuing the broken case cost estimates during different join permutation because it seems like we are ending up with scenarios where the cost estimate shows the cost and row count to be 0 and hence we end up picking that plan because it is costing nothing to pickup that plan. Like I said in my earlier comment, I am not sure if it is ok to cost nothing for a plan and hence it ending up becoming the best plan and probably the best sort avoidance plan too.&lt;br/&gt;
costEstimate	&lt;br/&gt;
	cost	0.0	&lt;br/&gt;
	rowCount	0.0	&lt;/p&gt;</comment>
                            <comment id="12697932" author="mikem" created="Fri, 10 Apr 2009 20:07:45 +0100"  >&lt;p&gt;I don&apos;t think tracking down the difference in estimated row count is going to lead you to the solution to this problem.  For this issue it is key to figure out why the particular plan chosen in the bug case is wrong.  It may be that the cost of the plan is wrong, but that should not affect whether any chose plan gives the right result - the cost should never affect that.  &lt;/p&gt;

&lt;p&gt;So again I believe the key thing here is to track down why this plan that has m1 as the outermost table thinks that this plan does not have to add a sort at the top to get proper&lt;br/&gt;
ordering required by order by m0.  My guess is that the bad plan uses the same key for&lt;br/&gt;
m1 and m0 which are just ranges on the same table, but has incorrect logic to not see&lt;br/&gt;
that it needs m0 using index key as outer most rather than just index key.  &lt;/p&gt;

&lt;p&gt;Also don&apos;t get confused when the bug is fixed.  My guess is that once the bug is fixed that the currently chosen plan will get marked correctly as NOT a sort avoidance plan which then will require an additional sort node which will add to the cost.  This will probably make it such that the optimizer no longer picks this plan.   &lt;/p&gt;</comment>
                            <comment id="12698038" author="mamtas" created="Sat, 11 Apr 2009 02:21:29 +0100"  >&lt;p&gt;Yes, even if the cost calculation for a plan is wrong, Derby should not return wrong resutls and hence for this jira entry, at this point, it might not be worth it to pursue the lead if the cost calculation is wrong.&lt;/p&gt;

&lt;p&gt;I did find one consistently reproducible SQL which will cause the problem behavior whether we are in the same session where the tables/indexes were created or whether we start a fresh database session. So, once the database has been setup, one can open a new ij session and consistently repro the problem case with following optimizer overrides (this way, one does not have to setup the whole database in the same session as the origina problem SQL to repro the problem)&lt;br/&gt;
SELECT table1.id, m0.value, m1.value FROM  --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
table2  m1 &amp;#8211; DERBY-PROPERTIES index=key3&lt;br/&gt;
, table2 m0 &amp;#8211; DERBY-PROPERTIES index=key3&lt;br/&gt;
, table1 &lt;br/&gt;
WHERE table1.id=m0.id AND m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND m1.name=&apos;PostComponentId&apos; AND m1.value=&apos;21857&apos; ORDER BY m0.value;&lt;/p&gt;

&lt;p&gt;So, the important thing is have both m1 and m0 use the index KEY3 which is on the column value on which ordering is happening for table m0.&lt;/p&gt;

&lt;p&gt;Now that I have a simple repro case (ie I don&apos;t have to go through countless iteration of optimizer for all different join orders and different predicate pulling down in different join orders), I can focus on the problem join order. &lt;/p&gt;</comment>
                            <comment id="12698508" author="mamtas" created="Mon, 13 Apr 2009 20:25:06 +0100"  >&lt;p&gt;I have done more debugging on the simpler query with optimizer overrides as shown below&lt;br/&gt;
SELECT table1.id, m0.value, m1.value FROM  --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
table2  m1 &amp;#8211; DERBY-PROPERTIES index=key3&lt;br/&gt;
,  table2 m0 &amp;#8211; DERBY-PROPERTIES index=key3&lt;br/&gt;
, table1 &lt;br/&gt;
WHERE table1.id=m0.id AND m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND m1.name=&apos;PostComponentId&apos; AND m1.value=&apos;21857&apos; ORDER BY m0.value;&lt;/p&gt;

&lt;p&gt;For the query above, when the optimizer will start considering the join orders, it is going to assume table2 m1 is 0, table2 m0 is 1 and table1 is 3. So, when I say in my analysis below, that optimizer is working with say join order 0,1,-1, what I mean is optimizer is considering the join order &lt;br/&gt;
m1,m0,-1. -1 means we are not taking into consideration any table for that position at this point. With that in mind, let me share what is happening and what part of it I don&apos;t understand.&lt;/p&gt;

&lt;p&gt;For the query above, optimizer first considers 0,-1,-1 and in OptimizerImpl.costBasedCostOptimizable line 2248 which is shown as below&lt;br/&gt;
if (requiredRowOrdering.sortRequired(currentRowOrdering,assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)&lt;br/&gt;
The 2 params to the call above are set as follows&lt;br/&gt;
At this point, currentRowOrdering	RowOrderingImpl  (id=62)	&lt;br/&gt;
	alwaysOrderedOptimizables	Vector&amp;lt;E&amp;gt;  (id=92)	&lt;br/&gt;
		elementCount	0	&lt;br/&gt;
	columnsAlwaysOrdered	ColumnOrdering  (id=94)	&lt;br/&gt;
		columns	Vector&amp;lt;E&amp;gt;  (id=158)	&lt;br/&gt;
		myDirection	3	&lt;br/&gt;
		tables	Vector&amp;lt;E&amp;gt;  (id=159)	&lt;br/&gt;
	currentColumnOrdering	null	&lt;br/&gt;
	ordering	Vector&amp;lt;E&amp;gt;  (id=96)	&lt;br/&gt;
		elementCount	0	&lt;br/&gt;
	unorderedOptimizables	Vector&amp;lt;E&amp;gt;  (id=97)	&lt;br/&gt;
		elementCount	0	&lt;br/&gt;
(ColumnsAlwaysOrdered in currentRowOrdering is set to Direction: 3 Table 0, Column 3 Table 0, Column 2)&lt;br/&gt;
The 2nd param assignedTableMap just has &lt;/p&gt;
{0}
&lt;p&gt; because we are only considering 0 in the join order.&lt;/p&gt;

&lt;p&gt;We return for the call above with true and that qualifies us to consider sort avoidance for m1. One of my question is should m1 get quailified to have sort avoidance set to true when we are not really ordering on any column that comes from m1?&lt;/p&gt;

&lt;p&gt;Moving on, once we finish with 0,-1,-1 where we decided that sorting can be avoided for m1, we move to the join order 0,1,-1. Again, we come to the code mentioned above for 0,1,-1&lt;br/&gt;
if (requiredRowOrdering.sortRequired(currentRowOrdering,assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)&lt;br/&gt;
If the earlier decision for considering sort avoidance true for m1 was correct(for join order 0,-1,-1), we should definitely return sort avoidance false for join order 0,1,-1 because with m1 as the outermost table, we can&apos;t avoid sorting on m0. The 2 params at this point in code are as follows for the call above&lt;br/&gt;
The first param is currentRowOrdering	RowOrderingImpl  (id=62)	&lt;br/&gt;
	alwaysOrderedOptimizables	Vector&amp;lt;E&amp;gt;  (id=99)	&lt;br/&gt;
		elementCount	0	&lt;br/&gt;
	columnsAlwaysOrdered	ColumnOrdering  (id=156)	&lt;br/&gt;
		columns	Vector&amp;lt;E&amp;gt;  (id=245)	&lt;br/&gt;
		myDirection	3	&lt;br/&gt;
		tables	Vector&amp;lt;E&amp;gt;  (id=246)	&lt;br/&gt;
	currentColumnOrdering	ColumnOrdering  (id=157)	&lt;br/&gt;
		columns	Vector&amp;lt;E&amp;gt;  (id=252)	&lt;br/&gt;
		myDirection	1	&lt;br/&gt;
		tables	Vector&amp;lt;E&amp;gt;  (id=255)	&lt;br/&gt;
	ordering	Vector&amp;lt;E&amp;gt;  (id=103)	&lt;br/&gt;
		elementCount	1	&lt;br/&gt;
		elementData	Object&lt;span class=&quot;error&quot;&gt;&amp;#91;10&amp;#93;&lt;/span&gt;  (id=259)	&lt;br/&gt;
		modCount	3	&lt;br/&gt;
	unorderedOptimizables	Vector&amp;lt;E&amp;gt;  (id=104)	&lt;br/&gt;
		elementCount	0	&lt;br/&gt;
(ColumnsAlwaysOrdered in currentRowOrdering is set to Direction: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2)&lt;br/&gt;
(currentColumnOrdering in currentRowOrdering is set to Direction: 1 Table 1, Column 3)&lt;br/&gt;
(ordering in currentRowOrdering is set to &lt;span class=&quot;error&quot;&gt;&amp;#91;Direction: 1 Table 1, Column 3&amp;#93;&lt;/span&gt;)&lt;br/&gt;
The 2nd param assignedTableMap just has &lt;/p&gt;
{0,1}
&lt;p&gt; because we are only considering 0 and 1 in the join order.&lt;/p&gt;

&lt;p&gt;Going further deep in 0,1,-1 join order, the call above leads to following line in impl.sql.compile.OrderByList.sortRequired(RowOrdering, JBitSet) line: 535	&lt;br/&gt;
if ( ! rowOrdering.alwaysOrdered(cr.getTableNumber())) &lt;/p&gt;

&lt;p&gt;In this if block, we say that sorting is not required. In my mind, we should required sorting because the outermost table m1 is not going to be able to satisfy the ordering requirement for m0.value and hence we can&apos;t consider sort avoidance when m1 is outermost. But of course, code is deciding that sort avoidance is ok in this case. I will highly appreciate if someone can help me understand this piece of code which ends up making the decision for sorting required or not required. I think the code is mostly centered in org.apache.derby.impl.sql.compile.RowOrderingImple (protocol class org.apache.derby.iapi.sql.compile.RowOrdering). There is not much of javadoc at the class level which is making it hard me to grasp what this class is supposed to do and what are the different memebers in it. I am going to debug further on my own to try to understand it but any help from community will be appreciated.&lt;/p&gt;</comment>
                            <comment id="12699556" author="mamtas" created="Thu, 16 Apr 2009 07:59:35 +0100"  >&lt;p&gt;I talked to Army offline on this jira entry and following was his feedback on the issue.&lt;/p&gt;

&lt;p&gt;He tends to agree that the outermost table m1 should not avoid sorting when the ordering required is on a column that is from an optimizable that is not in the join order yet. The join order is 0,-1,-1 when m1 decides that we can choose a plan which will avoid sorting. The code that makes that decision is in OrderByList.sortRequired(...), lines 496 - 533 Apparently, this code has been there since Cloudscape 2.0 days. &lt;/p&gt;

&lt;p&gt;*************&lt;b&gt;Start of Army&apos;s analysis of the issue&lt;/b&gt;******************&lt;br/&gt;
The comment preceding the code segment mentioned above says:&lt;/p&gt;

&lt;p&gt;            /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Check whether the table referred to is in the table map (if any).&lt;/li&gt;
		&lt;li&gt;If it isn&apos;t, we may have an ordering that does not require&lt;/li&gt;
		&lt;li&gt;sorting for the tables in a partial join order.  Look for&lt;/li&gt;
		&lt;li&gt;columns beyond this column to see whether a referenced table&lt;/li&gt;
		&lt;li&gt;is found - if so, sorting is required (for example, in a&lt;/li&gt;
		&lt;li&gt;case like ORDER BY S.A, T.B, S.C, sorting is required).&lt;br/&gt;
            */&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The 2nd and 3rd line in comment confuses me.  The only time I can think of where we could assume &quot;sort avoidance&quot; was okay when a table number is missing would be if the ORDER BY expression did not refer to any tables, ex. if it was a constant:&lt;/p&gt;

&lt;p&gt;    ORDER BY &apos;some literal&apos;, m0.value&lt;/p&gt;

&lt;p&gt;But from what I can tell, we catch that during preprocessing and remove the constant, so the above code still wouldn&apos;t be useful. (Note: the above ORDER BY will actually cause the query to return the correct results because the presence of a non-column expression (esp. the literal) causes the optimizer to ALWAYS perform a sort--that&apos;s a workaround to the problem if the user really needs one...).&lt;/p&gt;

&lt;p&gt;If the code mentioned above was removed, then I think the optimizer would require sorting for the first optimizable (m1), and that would in turn mean that we have to sort for the entire join order--which should return the correct results.  Of course, the thought of just removing code that&apos;s been in there for years is a bit scary...It would be nice to understand what the intended use case was, but the comments are not clear about that at all.&lt;br/&gt;
*************&lt;b&gt;End of Army&apos;s analysis of the issue&lt;/b&gt;******************&lt;/p&gt;

&lt;p&gt;Based on the above feedback, I commented out the code from 496-533 lines in OrderByList and ran the junit tests and they all ran fine. The old harness had one test case failing (lang/wisconsin) and it failed because the query plans now include sorting when the original plans (without my code changes) did not include sorting.  It appears that wisconsin test does not check the results of the cursors which are getting prepared. It just opens few cursors in order to get their query plans and dumps the query plans without checking the results of those queries. So I am not sure if the results from those queries have changed because of the additional sorting which is being added into their query plans.&lt;/p&gt;

&lt;p&gt;Ofcourse, the problem query shown below works fine with the code commenting suggested by Army &lt;br/&gt;
SELECT table1.id, m0.value, m1.value FROM  --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
table2  m1 &amp;#8211; DERBY-PROPERTIES index=key3&lt;br/&gt;
,  table2 m0 &amp;#8211; DERBY-PROPERTIES index=key3&lt;br/&gt;
, table1 &lt;br/&gt;
WHERE table1.id=m0.id AND m0.name=&apos;PageSequenceId&apos; AND table1.id=m1.id AND m1.name=&apos;PostComponentId&apos; AND m1.value=&apos;21857&apos; ORDER BY m0.value;&lt;/p&gt;

&lt;p&gt;I would like to know what the community thinks of the code removal suggested by Army.&lt;/p&gt;</comment>
                            <comment id="12699721" author="bryanpendleton" created="Thu, 16 Apr 2009 15:42:44 +0100"  >&lt;p&gt;Thanks Army for taking the time to look at this, and for pointing us to a good theory!&lt;/p&gt;

&lt;p&gt;I like Army&apos;s suggestion. I wish I had a clearer grasp on the concept of a &apos;partial join order&apos;. I think that&lt;br/&gt;
this is an intermediate stage during optimization, where the optimizer has so far chosen an ordering&lt;br/&gt;
for some, but not yet all, of the tables. It looks like the code is trying to handle the problem of how&lt;br/&gt;
to make a sort avoidance check at this intermediate point in optimization.&lt;/p&gt;

&lt;p&gt;I think that all &lt;b&gt;chosen&lt;/b&gt; query plans eventually reach a &lt;b&gt;complete&lt;/b&gt; join order, but a query plan which&lt;br/&gt;
is &lt;b&gt;discarded&lt;/b&gt; due to being too expensive may never get beyond a &lt;b&gt;partial&lt;/b&gt; join order. Is that true?&lt;/p&gt;

&lt;p&gt;It seems to me that there may be two topics here:&lt;/p&gt;

&lt;p&gt;1) it would be valid to make such a check for the purposes of doing some preliminary costing of &lt;br/&gt;
the join order up to this point, but for such an algorithm, the code would have to then re-visit the &lt;br/&gt;
sort avoidance decision later in the optimization, once the partial join order had become a full join order.&lt;br/&gt;
That is, I wonder if the overall flow is something like:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;optimizer investigates a partial join order, decides to cost it, determines that (so far) a sort is not required.&lt;/li&gt;
	&lt;li&gt;optimizer later completes this join order, decides that it is acceptable, but does NOT re-analyze&lt;br/&gt;
   whether a sort is now required for the complete join order&lt;/li&gt;
	&lt;li&gt;optimizer then chooses the correct full join order, but incorrectly avoids the sort due to the decision&lt;br/&gt;
   it made when considering the partial join order.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2) The comment (&quot;ORDER BY S.A, T.B, S.C&quot;) raises the interesting question of the situation in&lt;br/&gt;
which each column, considered individually, is ordered properly, but because the ORDER BY&lt;br/&gt;
clause interleaves columns from different tables, a sort is still required. That is, if S had an index&lt;br/&gt;
on (A, C), and T had an index on B, we might look at ORDER BY S.A, T.B, S.C and think that no&lt;br/&gt;
sorting of the results was required, because the join from S -&amp;gt; T would emit the rows in the&lt;br/&gt;
correct order, but that is wrong; the interleaving of the columns means that the sort must still be performed.&lt;br/&gt;
And, presumably, there is the interesting situation where we need to cost out a query at a point&lt;br/&gt;
where we have determined a partial join order that contains a position for S, but not T, or vice versa.&lt;/p&gt;

&lt;p&gt;It would be interesting to know more about the Wisconsin test cases, about the queries involved, and&lt;br/&gt;
about the before- and after- query plan differences, with respect to sorting. Are &lt;b&gt;all&lt;/b&gt; the changes due&lt;br/&gt;
to situations where we formerly avoided a sort, but now we choose one? That&apos;s interesting, I think; we&lt;br/&gt;
want to be careful to avoid introducing un-necessary sorts because that could be a substantial&lt;br/&gt;
performance regression (of course, if the old query was returning the rows in the wrong order, but&lt;br/&gt;
the test didn&apos;t check, and the new query is now being performed correctly, that&apos;s important to know, too!)&lt;/p&gt;

&lt;p&gt;It would also be interesting to see if we can construct an example along the lines of the&lt;br/&gt;
ORDER BY S.A, T.B, S.C case, such that various other permutations (ORDER BY S.A, S.C, T.B or&lt;br/&gt;
ORDER BY T.B, S.A, S.C) did not require sorting, but ORDER BY S.A, T.B, S.C did, and see how&lt;br/&gt;
the query plans emitted for these various cases behaved.&lt;/p&gt;</comment>
                            <comment id="12699728" author="mamtas" created="Thu, 16 Apr 2009 16:19:10 +0100"  >&lt;p&gt;Bryan, I haven&apos;t read your comment completely but I noticed &quot; I wish I had a clearer grasp on the concept of a &apos;partial join order.  I think that this is an intermediate stage during optimization, where the optimizer has so far chosen an ordering for some, but not yet all, of the tables. It looks like the code is trying to handle the problem of how to make a sort avoidance check at this intermediate point in optimization.&quot; Your understanding of partial join order is correct. For our specific query case, the optimizer is eventually going to have a join order consisting of 3 tables once it determines the best join order. But to arrive to that join order, it goes through many iterations of possible join orders. It starts out by considering only one optimizable in the first position of the join order, eg, 0,-1,-1 and this will be considered partial join order.&lt;/p&gt;</comment>
                            <comment id="12699729" author="mamtas" created="Thu, 16 Apr 2009 16:20:42 +0100"  >&lt;p&gt;Bryan, I think you are right that there might be some partial join orders which will never reach complete join order stage because the partial join order is turning out to be too expensive.&lt;/p&gt;</comment>
                            <comment id="12699739" author="army" created="Thu, 16 Apr 2009 17:12:50 +0100"  >&lt;p&gt;For what it&apos;s worth, I agree with everything Bryan wrote in his April 16th comment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; I think that all &lt;b&gt;chosen&lt;/b&gt; query plans eventually reach a &lt;b&gt;complete&lt;/b&gt; join order, but a query&lt;br/&gt;
&amp;gt; plan which is &lt;b&gt;discarded&lt;/b&gt; due to being too expensive may never get beyond a &lt;b&gt;partial&lt;/b&gt;&lt;br/&gt;
&amp;gt; join order. Is that true? &lt;/p&gt;

&lt;p&gt;Yes, that&apos;s true.&lt;/p&gt;

&lt;p&gt;&amp;gt; The comment (&quot;ORDER BY S.A, T.B, S.C&quot;) raises the interesting question of the&lt;br/&gt;
&amp;gt; situation in which each column, considered individually, is ordered properly, but&lt;br/&gt;
&amp;gt; because the ORDER BY clause interleaves columns from different tables, a sort is&lt;br/&gt;
&amp;gt; still required.&lt;/p&gt;

&lt;p&gt;Yes, it does.  And as I re-think about this, perhaps the code was written for a situation like&lt;/p&gt;

&lt;p&gt;    &quot;ORDER BY S.A, T.B&quot;    &amp;#8211; Note that we do &lt;b&gt;NOT&lt;/b&gt; have &quot;S.C&quot;.&lt;/p&gt;

&lt;p&gt;In that case a partial join order with &quot;S&quot; would satisfy the first order by column, and the second order by colum, &quot;T.B&quot;, would have a table that is not in the join order.  Without the logic in question, I think the method would determine that a sort was required because table &quot;T&quot; wasn&apos;t found.  But the logic in question would see if there was anything &apos;after&apos; T.B, and since there isn&apos;t, it would say that the partial join order can avoid a sort &lt;b&gt;so far&lt;/b&gt;, with the assumption that if the next optimizable to be placed in the join order is &quot;T&quot;, we might be able to avoid the sort entirely.&lt;/p&gt;

&lt;p&gt;As soon as &quot;S.C&quot; gets added to the list, though, the logic sees that we have interleaving columns and therefore correctly requires a sort.&lt;/p&gt;

&lt;p&gt;So &lt;b&gt;if&lt;/b&gt; that&apos;s a correct statement of how the code is &lt;b&gt;supposed&lt;/b&gt; to work, then it is actually quite useful and it does make sense.  But there seems to be a glitch in the logic--namely, it should perhaps require that a) all of the tables for the LEADING SET of order by columns, up to the one whose table cannot be found, MUST exist within the join order, &lt;b&gt;and&lt;/b&gt; b) the leading set of order by columns canNOT be empty.  I think the code as written checks for &quot;a&quot;, but it does not check for &quot;b&quot;.&lt;/p&gt;

&lt;p&gt;So in the query for this issue, we have &quot;ORDER BY m0.value&quot;.  When we get a partial join order with &lt;/p&gt;
{ m1 }
&lt;p&gt; in it, we check the order by column &quot;m0.value&quot; and find that &quot;m0&quot; is not in the (partial) join order.  Today, due to the lack of condition &quot;b&quot;, we think we can avoid the sort.  But if condition &quot;b&quot; was in place, we would see that the &quot;leading set&quot; of order by columns--i.e. the number of order by columns before &quot;m0.value&quot;, is EMPTY, which means that &quot;so far&quot; nothing is sorted, and thus the sort would be required.&lt;/p&gt;

&lt;p&gt;I haven&apos;t actually tried that out, I&apos;m just writing as things occur to me, so this could be incomplete and/or entirely incorrect...&lt;/p&gt;</comment>
                            <comment id="12699744" author="army" created="Thu, 16 Apr 2009 17:16:00 +0100"  >&lt;p&gt;&amp;gt; if condition &quot;b&quot; was in place, we would see that the &quot;leading set&quot; of order by&lt;br/&gt;
&amp;gt; columns--i.e. the number of order by columns before &quot;m0.value&quot;, is EMPTY,&lt;br/&gt;
&amp;gt; which means that &quot;so far&quot; nothing is sorted, and thus the sort would be required.&lt;/p&gt;

&lt;p&gt;One easy way to check this theory would be to make the following change:&lt;/p&gt;

&lt;p&gt;@@ -503,7 +503,7 @@&lt;br/&gt;
                        */&lt;br/&gt;
                        if (tableMap != null)&lt;br/&gt;
                        {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if ( ! tableMap.get(cr.getTableNumber()))&lt;br/&gt;
+                               if ((position &amp;gt; 0) &amp;amp;&amp;amp; !tableMap.get(cr.getTableNumber()))&lt;br/&gt;
                                {&lt;br/&gt;
                                        /* Table not in partial join order */&lt;br/&gt;
                                        for (int remainingPosition = loc + 1;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;and see what happens...&lt;/p&gt;</comment>
                            <comment id="12699755" author="army" created="Thu, 16 Apr 2009 17:33:14 +0100"  >&lt;p&gt;&amp;gt; &lt;b&gt;and&lt;/b&gt; b) the leading set of order by columns canNOT be empty.&lt;/p&gt;

&lt;p&gt;Okay, check that, that&apos;s not a complete solution.&lt;/p&gt;

&lt;p&gt;Consider&lt;/p&gt;

&lt;p&gt;    ORDER BY S.A, T.B&lt;/p&gt;

&lt;p&gt;with a join order of &lt;/p&gt;
{ S, W, - }
&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;If we can avoid sorting for S.A and then we process &quot;T.B&quot; and say that we can avoid the sort there, as well, we&apos;ll get into trouble.  Once we get to join order &lt;/p&gt;
{ S, W, T }
&lt;p&gt; we might find that our access plan for T can avoid the sort for B...but due to the presence of &quot;W&quot; in the join order, I think the results would still end up out of order.  So the condition would have to be generalized more than what I posted earlier...I think...&lt;/p&gt;</comment>
                            <comment id="12699763" author="bryanpendleton" created="Thu, 16 Apr 2009 18:00:06 +0100"  >&lt;p&gt;&amp;gt; due to the presence of &quot;W&quot; in the join order, I think the results would still end up out of order.&lt;/p&gt;

&lt;p&gt;I&apos;m not seeing that, seems like the data from W is irrelevant to the final ordering, but I think it&apos;s &lt;br/&gt;
good to be cautious and verify all of this with some actual tables and some actual queries.&lt;/p&gt;

&lt;p&gt;Mamta, you might want to mark this issue as assigned to you...?&lt;/p&gt;</comment>
                            <comment id="12701587" author="mamtas" created="Wed, 22 Apr 2009 17:15:58 +0100"  >&lt;p&gt;I have worked on writing a junit test which is currently going to fail because we are returning the data in incorrect order. I thought it would be useful to have the test for people to quickly run the test if they wanted to. This junit test will not be part of any suite currently since the bug is not fixed yet. Putting it in the suite is going to make it fail everytime because the test is asserting that the data be returned in the correct order. I will check that test in soon. It was painful to convert the setup script provided for this jira into a junit test. The script is huge. I was able to use Army&apos;s test converter &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2151&quot; title=&quot;&amp;quot;Fixer-upper&amp;quot; utility to help convert ij canon-based tests to JUnit.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2151&quot;&gt;&lt;del&gt;DERBY-2151&lt;/del&gt;&lt;/a&gt;(it was extremely helpful because it atleast converted half of the script into junit test. My understanding is that the converter works on the older canon based master file. I think it takes sql delimited by ; from the canon file and assumes that next line is the output of that sql. So, the converter skipped every other sql from my setup script. I ended up hand putting every other line which was skipped by the converter. )&lt;/p&gt;</comment>
                            <comment id="12701593" author="mamtas" created="Wed, 22 Apr 2009 17:29:57 +0100"  >&lt;p&gt;I am working on the wisconsin test so I can print out the test results and see if the code changes suggested by Army affects the data output in anyways.&lt;/p&gt;</comment>
                            <comment id="12701729" author="kmarsden" created="Thu, 23 Apr 2009 00:09:18 +0100"  >&lt;p&gt;Hi Mamta, I noticed the grant to ASF checkbox was not marked with the attachment derby-reproduce.zip. Do you think it is ok to turn it into a test?  This may be fine since it is just SQL and not java code, but I wanted to just check and make sure.&lt;/p&gt;
</comment>
                            <comment id="12701802" author="mamtas" created="Thu, 23 Apr 2009 05:45:01 +0100"  >&lt;p&gt;Thanks for catching that, Kathey. I don&apos;t know the answer whether it is ok to create a SQL test out of an attachement which is not marked grant to ASF. Maybe someone else has a definitive answer.&lt;/p&gt;

&lt;p&gt;Tars Joris, do you think you can grant the derby-reproduce.zip to ASF?&lt;/p&gt;</comment>
                            <comment id="12701827" author="tjoris" created="Thu, 23 Apr 2009 08:28:36 +0100"  >&lt;p&gt;I will find out if the test code can be granted to ASF.&lt;/p&gt;</comment>
                            <comment id="12702085" author="mamtas" created="Thu, 23 Apr 2009 21:13:17 +0100"  >&lt;p&gt;wisconsin test was showing diffs after I commented out the code in OrderByList (code through 504-533). The diffs were for 7 queries and for those 7 queries, now the plan picked does a sorting (prior to my changes, the sorting was getting avoided). wisconsin test only does query plan dump, it does not check the actual data returned for those queries. For the 7 queries that changed, I added a check to dump the data returned from those queries. Rerunning wisconsin with and without my code changes atleast confirms that the data returned because of the additional sorting node has not been affected. All of these 7 queries involved multiple tables in the FROM list and they had ORDER BY clause. (I have included the 7 queries below for reference).&lt;/p&gt;

&lt;p&gt;I went through all the queries in wisconsin test and see that there are still quite a few queries (even the ones with more than one table in the FROM list and have ORDER BY) that do not have sorting node on top of their query plan because of the commenting of the code. One of such query example is&lt;br/&gt;
get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 and TENKTUP2.unique1 &amp;lt; 6000&lt;br/&gt;
	 order by TENKTUP1.unique1&apos;;&lt;/p&gt;


&lt;p&gt;BTW, the 7 queries that have changed their plans so that they now require sorting are as follows(Note that the comment for the query 2 &quot;says that sort avoidance with joins and order by on columns in different tables&quot;. Well, with other change in the code, we are not avoiding sort anymore)&lt;br/&gt;
1)&lt;br/&gt;
ij&amp;gt; &amp;#8211; one row from joining table&lt;br/&gt;
get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique2 = TENKTUP2.unique2&lt;br/&gt;
	 and TENKTUP2.unique1 = 0&lt;br/&gt;
	 order by TENKTUP1.unique1&apos;;&lt;/p&gt;

&lt;p&gt;2)&lt;br/&gt;
ij&amp;gt; &amp;#8211; Sort avoidance with joins and order by on columns in different tables&lt;br/&gt;
&amp;#8211;&lt;br/&gt;
-- order on joining columns&lt;br/&gt;
get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 order by TENKTUP1.unique1, TENKTUP2.unique1&apos;;&lt;/p&gt;

&lt;p&gt;3)&lt;br/&gt;
ij&amp;gt; get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 and TENKTUP1.unique2 = 0&lt;br/&gt;
	 and TENKTUP2.unique2 = 0&lt;br/&gt;
	 order by TENKTUP1.unique1, TENKTUP2.unique1&apos;;&lt;/p&gt;

&lt;p&gt;4)&lt;br/&gt;
ij&amp;gt; get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 and TENKTUP1.unique2 &amp;lt; 6000&lt;br/&gt;
	 and TENKTUP2.unique2 = 0&lt;br/&gt;
	 order by TENKTUP1.unique1, TENKTUP2.unique1&apos;;&lt;/p&gt;

&lt;p&gt;5)&lt;br/&gt;
ij&amp;gt; get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 and TENKTUP1.unique2 &amp;lt; 6000&lt;br/&gt;
	 and TENKTUP2.unique2 = 0&lt;br/&gt;
	 order by TENKTUP1.unique2, TENKTUP2.unique2&apos;;&lt;/p&gt;

&lt;p&gt;6)&lt;br/&gt;
ij&amp;gt; get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2, ONEKTUP&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 and ONEKTUP.unique1 = TENKTUP1.unique1&lt;br/&gt;
	 and TENKTUP1.unique2 = 0&lt;br/&gt;
	 and TENKTUP2.unique2 = 0&lt;br/&gt;
	 order by TENKTUP1.unique1, TENKTUP2.unique1&apos;;&lt;/p&gt;

&lt;p&gt;7)&lt;br/&gt;
ij&amp;gt; get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2, ONEKTUP&lt;br/&gt;
	 where TENKTUP1.unique2 = TENKTUP2.unique2&lt;br/&gt;
	 and ONEKTUP.unique2 = TENKTUP1.unique2&lt;br/&gt;
	 and TENKTUP1.unique2 = 0&lt;br/&gt;
	 and TENKTUP2.unique2 = 0&lt;br/&gt;
	 order by TENKTUP1.unique1, TENKTUP2.unique1&apos;;&lt;/p&gt;
</comment>
                            <comment id="12702107" author="army" created="Thu, 23 Apr 2009 22:03:01 +0100"  >&lt;p&gt;Thanks Mamta!&lt;/p&gt;

&lt;p&gt;Could you perhaps include the join order that was chosen for each of the above queries?  I&apos;m not looking for the full query plan, just something short like the &lt;/p&gt;
{ TENKTUP1, TENKTUP2 }
&lt;p&gt; notation.  You should be able to get the join order by reading the query plan top to bottom; the order in which you see the table names should reflect the join order chosen by the optimizer.&lt;/p&gt;

&lt;p&gt;Note that the order by clauses for queries #2 thru #7 all match the &quot;ORDER BY S.A, T.B&quot; shape that I mentioned in my first April 16th comment, so if the theory as to how that code is supposed to work was correct, that &lt;b&gt;might&lt;/b&gt; explain why these queries fail to avoid the sort when the relevant code is commented out...?  Of course, more tracing/debugging of the individual queries would be necessary to know for sure...&lt;/p&gt;</comment>
                            <comment id="12702137" author="mikem" created="Thu, 23 Apr 2009 23:12:35 +0100"  >&lt;p&gt;I took a close look at the original query plans for queries 1 through 3, and believe all of the original &lt;br/&gt;
query plans with no sort at the top are valid plans.  So think the current fix may not be valid as it is causing sort where they do not need to be.  I am new to this, so if my logic is wrong please point it&lt;br/&gt;
out.&lt;/p&gt;

&lt;p&gt;For query 1:&lt;br/&gt;
1)&lt;br/&gt;
ij&amp;gt; &amp;#8211; one row from joining table&lt;br/&gt;
get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique2 = TENKTUP2.unique2&lt;br/&gt;
	 and TENKTUP2.unique1 = 0&lt;br/&gt;
	 order by TENKTUP1.unique1&apos;;&lt;/p&gt;

&lt;p&gt;Because TENKTUP2.unique1 is a unique column and the query requires TENKTUP2.unique1 = 0,&lt;br/&gt;
only 1 or 0 rows qualifies from TENKTUP2.   Because TENKTUP2.unique2 and TENKTUP1.unique2 are &lt;br/&gt;
also both unique then TENKTUP1.unique2 = TENKTUP2.unique2 means only 1 or 0 rows qualify&lt;br/&gt;
qualify from TENKTUP1.  This means the query can only return 1 or 0 rows.  Because this is the&lt;br/&gt;
case there is no need to sort a 1 or 0 row result set.&lt;/p&gt;

&lt;p&gt;My question is, is it expected that the optimizer should recognize that a one row result set requires &lt;br/&gt;
no ordering?  &lt;/p&gt;

&lt;p&gt;It looks like queries 3 through 7 are all variations on one row result sets.&lt;/p&gt;

&lt;p&gt;Query 2 is different:&lt;br/&gt;
get cursor c as&lt;br/&gt;
	&apos;select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 order by TENKTUP1.unique1, TENKTUP2.unique1&apos;;&lt;/p&gt;

&lt;p&gt;In this case the interesting thing is that TENKTUP1.unique1 must be the same as &lt;br/&gt;
TENKTUP2.unique1.  So this means that any plan that is sorted on TENKTUP1.unique1 OR&lt;br/&gt;
TENKTUP2.unique1 fulfills the order by requirement to be sorted by TENKTUP1.unique1, TENKTUP2.unique1.&lt;/p&gt;

&lt;p&gt;So in the original queryplan it turns out the outermost index scan is:&lt;br/&gt;
TENKTUP1 using index TK1UNIQUE1  which because of the predicate is enough to avoid sorting.&lt;/p&gt;

&lt;p&gt;Again the question is whether the code is meant to catch this case or did it get lucky?&lt;/p&gt;

&lt;p&gt;Originally I have to admit I didn&apos;t understand how any multiple table order by could be a sort &lt;br/&gt;
avoidance plan since we have no indexes that cover multiple tables.  I believe the above show&lt;br/&gt;
some of the cases.&lt;/p&gt;

&lt;p&gt;Another case I have seen is an order by of A.key, B.key being satisfied by join on A.key, B.key when it is known A.key is a single value.  Or satisfied also by join on B.key, A.key where it is also known that&lt;br/&gt;
A is a single value like A.key = ?. &lt;/p&gt;


</comment>
                            <comment id="12702147" author="army" created="Thu, 23 Apr 2009 23:45:26 +0100"  >&lt;p&gt;I haven&apos;t looked at the details of your previous post, but regarding:&lt;/p&gt;

&lt;p&gt;&amp;gt; So think the current fix may not be valid as it is causing sort where they do not need to be.&lt;/p&gt;

&lt;p&gt;I agree.  That&apos;s what I was hoping to convey in my comment on April 16th when I wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;b&gt;if&lt;/b&gt; that&apos;s a correct statement of how the code is &lt;b&gt;supposed&lt;/b&gt; to work, then it is actually&lt;br/&gt;
&amp;gt; quite useful and it does make sense.&lt;/p&gt;

&lt;p&gt;I.e. we shouldn&apos;t remove it.  As for:&lt;/p&gt;

&lt;p&gt;&amp;gt; is it expected that the optimizer should recognize that a one row result set requires&lt;br/&gt;
&amp;gt; no ordering? &lt;/p&gt;

&lt;p&gt;I don&apos;t know the details of how it works, but there is definitely logic in the optimizer to try to recognize one row result sets and to make decisions based on that information.  The RowOrderingImpl.java class even includes a field called &quot;alwaysOrderedOptimizables&quot; for which the javadoc says:&lt;/p&gt;

&lt;p&gt;    /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;This vector contains table numbers for tables that are always ordered.&lt;/li&gt;
		&lt;li&gt;This happens for one-row tables.&lt;br/&gt;
    */&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Not sure how that plays into the above queries, but I thought I&apos;d mention it...&lt;/p&gt;

&lt;p&gt;&amp;gt; Another case I have seen is an order by of A.key, B.key being satisfied by join on&lt;br/&gt;
&amp;gt; A.key, B.key when it is known A.key is a single value&lt;/p&gt;

&lt;p&gt;Yes, I think that&apos;s what the &quot;columnsAlwaysOrdered&quot; field in RowOrderingImpl seems to be for.  Any columns which are compared to constants (and probably parameter markers as well?) are considered &quot;always ordered&quot; and hence should not require sorting in and of themselves.  Ex. In the query for this issue the columnsAlwaysOrdered field includes columns m0.name, m1.name, and m1.value because all of those columns are compared to literals in the WHERE clause.  It seems quite possible that the optimizer will apply these rules transitively to detect other &quot;always ordered&quot; columns as well...&lt;/p&gt;</comment>
                            <comment id="12703011" author="tjoris" created="Mon, 27 Apr 2009 08:22:46 +0100"  >&lt;p&gt;Test script that can be included in the Test-Suite.&lt;/p&gt;

&lt;p&gt;Some data was changed, but I verified that it still reproduced the bug.&lt;/p&gt;</comment>
                            <comment id="12703351" author="mamtas" created="Mon, 27 Apr 2009 21:36:34 +0100"  >&lt;p&gt;I have changed the test to use the test script submitted by Tars this morning. Thanks for the updated script, Tars Joris.&lt;/p&gt;</comment>
                            <comment id="12703844" author="mamtas" created="Tue, 28 Apr 2009 22:49:46 +0100"  >&lt;p&gt;I modified the last script provided by Tars to create a table identical to table2 and the new table is called table3. The original query for Tars test case which returns incorrect order of rows used a self join on table2 along with table1. To avoid any possibilities of problems associated with may be self join, I created this table3 which is identical to table2. But despite that, the query is still returning incorrect results. Here is how the new query (without the self join) looks like.&lt;br/&gt;
SELECT table1.id, table2.value, table3.value FROM table1, table2, table3 WHERE table1.id=table2.id AND &lt;/p&gt;

&lt;p&gt;table2.name=&apos;PageSequenceId&apos; AND table1.id=table3.id AND table3.name=&apos;PostComponentId&apos; AND &lt;/p&gt;

&lt;p&gt;table3.value=&apos;21857&apos; ORDER BY table2.value;&lt;/p&gt;

&lt;p&gt;The database can be setup to run the query above is enclosed as script3.sql to this jira entry.&lt;/p&gt;</comment>
                            <comment id="12704227" author="mamtas" created="Wed, 29 Apr 2009 19:12:09 +0100"  >&lt;p&gt;I am attaching a newer version of script3.sql The new script is called script3WithUserFriendlyIndexNames.sql The only changes made to script3.sql are to use user-friendly index names so that it is easier to understand the query which is using index names through optimizer overrides to demonstrate the buggy behavior. Hopefully it will be easier to read the query plan as well. The query to see the problem is as follows&lt;/p&gt;

&lt;p&gt;SELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED&lt;br/&gt;
table3 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table3&lt;br/&gt;
, table2 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table2&lt;br/&gt;
, table1&lt;br/&gt;
WHERE table1.id=table2.id AND table2.name=&apos;PageSequenceId&apos; &lt;br/&gt;
AND table1.id=table3.id &lt;br/&gt;
AND table3.name=&apos;PostComponentId&apos; &lt;br/&gt;
AND table3.value=&apos;21857&apos; ORDER BY table2.value;&lt;/p&gt;

&lt;p&gt;The query plan for the query above looks as follows&lt;br/&gt;
Statement Name:&lt;br/&gt;
        null&lt;br/&gt;
Statement Text:&lt;br/&gt;
        SELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED&lt;br/&gt;
table3 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table3&lt;br/&gt;
, table2 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table2&lt;br/&gt;
, table1&lt;br/&gt;
WHERE table1.id=table2.id AND table2.name=&apos;PageSequenceId&apos;&lt;br/&gt;
AND table1.id=table3.id&lt;br/&gt;
AND table3.name=&apos;PostComponentId&apos;&lt;br/&gt;
AND table3.value=&apos;21857&apos; ORDER BY table2.value&lt;br/&gt;
Parse Time: 0&lt;br/&gt;
Bind Time: 0&lt;br/&gt;
Optimize Time: 0&lt;br/&gt;
Generate Time: 0&lt;br/&gt;
Compile Time: 0&lt;br/&gt;
Execute Time: 0&lt;br/&gt;
Begin Compilation Timestamp : null&lt;br/&gt;
End Compilation Timestamp : null&lt;br/&gt;
Begin Execution Timestamp : null&lt;br/&gt;
End Execution Timestamp : null&lt;br/&gt;
Statement Execution Plan Text:&lt;br/&gt;
Project-Restrict ResultSet (10):&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows seen = 3&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
restriction = false&lt;br/&gt;
projection = true&lt;br/&gt;
        constructor time (milliseconds) = 0&lt;br/&gt;
        open time (milliseconds) = 0&lt;br/&gt;
        next time (milliseconds) = 0&lt;br/&gt;
        close time (milliseconds) = 0&lt;br/&gt;
        restriction time (milliseconds) = 0&lt;br/&gt;
        projection time (milliseconds) = 0&lt;br/&gt;
        optimizer estimated row count:            0.20&lt;br/&gt;
        optimizer estimated cost:         1185.66&lt;/p&gt;

&lt;p&gt;Source result set:&lt;br/&gt;
        User supplied optimizer overrides for join are &lt;/p&gt;
{ joinOrder=FIXED }&lt;br/&gt;
        Nested Loop Exists Join ResultSet:&lt;br/&gt;
        Number of opens = 1&lt;br/&gt;
        Rows seen from the left = 3&lt;br/&gt;
        Rows seen from the right = 3&lt;br/&gt;
        Rows filtered = 0&lt;br/&gt;
        Rows returned = 3&lt;br/&gt;
                constructor time (milliseconds) = 0&lt;br/&gt;
                open time (milliseconds) = 0&lt;br/&gt;
                next time (milliseconds) = 0&lt;br/&gt;
                close time (milliseconds) = 0&lt;br/&gt;
                optimizer estimated row count:            0.20&lt;br/&gt;
                optimizer estimated cost:         1185.66&lt;br/&gt;
&lt;br/&gt;
        Left result set:&lt;br/&gt;
                User supplied optimizer overrides for join are { joinOrder=FIXED }
&lt;p&gt;                Nested Loop Join ResultSet:&lt;br/&gt;
                Number of opens = 1&lt;br/&gt;
                Rows seen from the left = 3&lt;br/&gt;
                Rows seen from the right = 3&lt;br/&gt;
                Rows filtered = 0&lt;br/&gt;
                Rows returned = 3&lt;br/&gt;
                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        optimizer estimated row count:            0.20&lt;br/&gt;
                        optimizer estimated cost:         1185.35&lt;/p&gt;

&lt;p&gt;                Left result set:&lt;br/&gt;
                        Project-Restrict ResultSet (5):&lt;br/&gt;
                        Number of opens = 1&lt;br/&gt;
                        Rows seen = 3&lt;br/&gt;
                        Rows filtered = 0&lt;br/&gt;
                        restriction = true&lt;br/&gt;
                        projection = true&lt;br/&gt;
                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                restriction time (milliseconds) = 0&lt;br/&gt;
                                projection time (milliseconds) = 0&lt;br/&gt;
                                optimizer estimated row count:            0.20&lt;br/&gt;
                                optimizer estimated cost:            6.97&lt;/p&gt;

&lt;p&gt;                        Source result set:&lt;br/&gt;
                                Index Row to Base Row ResultSet for TABLE3:&lt;br/&gt;
                                Number of opens = 1&lt;br/&gt;
                                Rows seen = 3&lt;br/&gt;
                                Columns accessed from heap = &lt;/p&gt;
{0, 1, 2}&lt;br/&gt;
                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        optimizer estimated row count:  0.20&lt;br/&gt;
                                        optimizer estimated cost:            6.97&lt;br/&gt;
&lt;br/&gt;
                                        User supplied optimizer overrides on TABLE3 are { index=NONUNIQUEONVALUE_TABLE3 }&lt;br/&gt;
                                        Index Scan ResultSet for TABLE3 using index NONUNIQUEONVALUE_TABLE3 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                                        Number of opens = 1&lt;br/&gt;
                                        Rows seen = 3&lt;br/&gt;
                                        Rows filtered = 0&lt;br/&gt;
                                        Fetch Size = 1&lt;br/&gt;
                                                constructor time (milliseconds) = 0&lt;br/&gt;
                                                open time (milliseconds) = 0&lt;br/&gt;
                                                next time (milliseconds) = 0&lt;br/&gt;
                                                close time (milliseconds) = 0&lt;br/&gt;
                                                next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
                                        scan information:&lt;br/&gt;
                                                Bit set of columns fetched=All&lt;br/&gt;
                                                Number of columns fetched=2&lt;br/&gt;
                                                Number of deleted rows visited=0&lt;br/&gt;
&lt;br/&gt;
                                                Number of pages visited=2&lt;br/&gt;
                                                Number of rows qualified=3&lt;br/&gt;
                                                Number of rows visited=4&lt;br/&gt;
                                                Scan type=btree&lt;br/&gt;
                                                Tree height=-1&lt;br/&gt;
                                                start position:        &amp;gt;= on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;br/&gt;
&lt;br/&gt;
                                                stop position:        &amp;gt; on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:&lt;br/&gt;
&lt;br/&gt;
                                                qualifiers:None&lt;br/&gt;
                                                optimizer estimated row count:          0.20&lt;br/&gt;
                                                optimizer estimated cost:     6.97&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
                Right result set:&lt;br/&gt;
                        Project-Restrict ResultSet (8):&lt;br/&gt;
                        Number of opens = 3&lt;br/&gt;
                        Rows seen = 8688&lt;br/&gt;
                        Rows filtered = 8685&lt;br/&gt;
                        restriction = true&lt;br/&gt;
                        projection = true&lt;br/&gt;
                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                restriction time (milliseconds) = 0&lt;br/&gt;
                                projection time (milliseconds) = 0&lt;br/&gt;
                                optimizer estimated row count:            0.20&lt;br/&gt;
                                optimizer estimated cost:         1178.38&lt;br/&gt;
&lt;br/&gt;
                        Source result set:&lt;br/&gt;
                                Index Row to Base Row ResultSet for TABLE2:&lt;br/&gt;
                                Number of opens = 3&lt;br/&gt;
                                Rows seen = 8688&lt;br/&gt;
                                Columns accessed from heap = {0, 1, 2}
&lt;p&gt;                                        constructor time (milliseconds) = 0&lt;br/&gt;
                                        open time (milliseconds) = 0&lt;br/&gt;
                                        next time (milliseconds) = 0&lt;br/&gt;
                                        close time (milliseconds) = 0&lt;br/&gt;
                                        optimizer estimated row count:  0.20&lt;br/&gt;
                                        optimizer estimated cost:         1178.38&lt;/p&gt;

&lt;p&gt;                                        User supplied optimizer overrides on TABLE2 are &lt;/p&gt;
{ index=NONUNIQUEONVALUE_TABLE2 }
&lt;p&gt;                                        Index Scan ResultSet for TABLE2 using index NONUNIQUEONVALUE_TABLE2 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                                        Number of opens = 3&lt;br/&gt;
                                        Rows seen = 8688&lt;br/&gt;
                                        Rows filtered = 0&lt;br/&gt;
                                        Fetch Size = 1&lt;br/&gt;
                                                constructor time (milliseconds)= 0&lt;br/&gt;
                                                open time (milliseconds) = 0&lt;br/&gt;
                                                next time (milliseconds) = 0&lt;br/&gt;
                                                close time (milliseconds) = 0&lt;br/&gt;
                                                next time in milliseconds/row =0&lt;/p&gt;

&lt;p&gt;                                        scan information:&lt;br/&gt;
                                                Bit set of columns fetched=&lt;/p&gt;
{1}
&lt;p&gt;                                                Number of columns fetched=1&lt;br/&gt;
                                                Number of deleted rows visited=0&lt;/p&gt;

&lt;p&gt;                                                Number of pages visited=12&lt;br/&gt;
                                                Number of rows qualified=8688&lt;br/&gt;
                                                Number of rows visited=8688&lt;br/&gt;
                                                Scan type=btree&lt;br/&gt;
                                                Tree height=2&lt;br/&gt;
                                                start position:        None&lt;br/&gt;
                                                stop position:        None&lt;br/&gt;
                                                qualifiers:None&lt;br/&gt;
                                                optimizer estimated row count:          0.20&lt;br/&gt;
                                                optimizer estimated cost:  1178.38&lt;/p&gt;



&lt;p&gt;        Right result set:&lt;br/&gt;
                Index Scan ResultSet for TABLE1 using constraint SQL090429102526750 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                Number of opens = 3&lt;br/&gt;
                Rows seen = 3&lt;br/&gt;
                Rows filtered = 0&lt;br/&gt;
                Fetch Size = 1&lt;br/&gt;
                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;                scan information:&lt;br/&gt;
                        Bit set of columns fetched=&lt;/p&gt;
{0}
&lt;p&gt;                        Number of columns fetched=1&lt;br/&gt;
                        Number of deleted rows visited=0&lt;br/&gt;
                        Number of pages visited=3&lt;br/&gt;
                        Number of rows qualified=3&lt;br/&gt;
                        Number of rows visited=3&lt;br/&gt;
                        Scan type=btree&lt;br/&gt;
                        Tree height=1&lt;br/&gt;
                        start position:&lt;br/&gt;
        &amp;gt;= on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:0&lt;br/&gt;
                        stop position:&lt;br/&gt;
        &amp;gt; on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:0&lt;br/&gt;
                        qualifiers:&lt;br/&gt;
Column&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; Id: 0&lt;br/&gt;
Operator: =&lt;br/&gt;
Ordered nulls: false&lt;br/&gt;
Unknown return value: false&lt;br/&gt;
Negate comparison result: false&lt;/p&gt;

&lt;p&gt;                        optimizer estimated row count:            0.20&lt;br/&gt;
                        optimizer estimated cost:            0.31&lt;/p&gt;</comment>
                            <comment id="12705646" author="mamtas" created="Mon, 4 May 2009 17:55:38 +0100"  >&lt;p&gt;I went through the optimize phase through the debugger and it appears to me (I may be wrong and would appreciate others looking at my detail analysis of the optimize phase below) that the problem may be with the generate phase or the execute phase where we may be not using the non-unique index on table2 correctly to fetch the orders in row.&lt;/p&gt;

&lt;p&gt;The query in question is as below&lt;br/&gt;
SELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED&lt;br/&gt;
table3 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table3&lt;br/&gt;
, table2 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table2&lt;br/&gt;
, table1&lt;br/&gt;
WHERE table1.id=table2.id AND table2.name=&apos;PageSequenceId&apos; &lt;br/&gt;
AND table1.id=table3.id &lt;br/&gt;
AND table3.name=&apos;PostComponentId&apos; &lt;br/&gt;
AND table3.value=&apos;21857&apos; ORDER BY table2.value;&lt;/p&gt;

&lt;p&gt;For the query above, in addition to the predicates supplied by the user, optimizer internally generates another predicate, namely, table3.id=table2.id&lt;br/&gt;
So for the queyr, all the predicates are as follows&lt;br/&gt;
1)table1.id=table2.id &lt;br/&gt;
2)table1.id=table3.id &lt;br/&gt;
3)table3.id=table2.id&lt;br/&gt;
4)table2.name=&apos;PageSequenceId&apos; &lt;br/&gt;
5)table3.name=&apos;PostComponentId&apos; &lt;br/&gt;
6)table3.value=&apos;21857&apos; &lt;/p&gt;

&lt;p&gt;Of the predicates above, 4), 5) and 6) can be pushed down to the corresponding optimizables ie 4) will be associated with table2 and 5),6) will be associated with table3. This is because these predicates are constant comparison with columns. This leaves us with 3 predicates, namely 1), 2), 3)&lt;br/&gt;
which are multitable join predicates.&lt;/p&gt;

&lt;p&gt;Optimizer has a class called RowOrdering associated with it (OptimizerImpl.currentRowOrdering). &lt;br/&gt;
currentRowOrdering has following fields in it.&lt;br/&gt;
currentRowOrdering	RowOrderingImpl  &lt;br/&gt;
	alwaysOrderedOptimizables	Vector&amp;lt;E&amp;gt;&lt;br/&gt;
	columnsAlwaysOrdered	ColumnOrdering&lt;br/&gt;
	currentColumnOrdering	null	&lt;br/&gt;
	ordering	Vector&amp;lt;E&amp;gt;  &lt;br/&gt;
	unorderedOptimizables	Vector&amp;lt;E&amp;gt;  &lt;br/&gt;
All the predicates that are constant comparison will go into columnsAlwaysOrdered. These pushing of constant comparison predicates happen per optimizable basis when that particular optimizable is being consdiered in the possible join order combination.&lt;/p&gt;

&lt;p&gt;In our specific query, through optimizer overrides, we have instructed optimizer to only consider join order &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, table2, table1&amp;#93;&lt;/span&gt;. The optimizer starts with &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, -1, -1&amp;#93;&lt;/span&gt;. First thing it does is it goes through the join predicates (which are 1), 2) and 3) in the predicate list above). But since&lt;br/&gt;
all the referenced tables for any of the 3 predicates are not covered by the current join order of &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, -1, -1&amp;#93;&lt;/span&gt;, nothing gets done to those join predicates. Next, the optimizer will tell &lt;br/&gt;
currentRowOrdering to (this happens in FromBaseTable(FromTable).tellRowOrderingAboutConstantColumns(RowOrdering, OptimizablePredicateList) line: 1477) to add predicates 5) and 6) from above list into it&apos;s columnsAlwaysOrdered list. So, at the end of the&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;table3, -1, -1&amp;#93;&lt;/span&gt;, currentRowOrdering.columnsAlwaysOrdered will look as follows &lt;br/&gt;
Direction: 3 Table 0, Column 3 Table 0, Column 2&lt;br/&gt;
We are saying above that Table at position 0 (which is Table3 in our eg) has column 3(value) and column 2(name) which are always ordered because they are being compared with constants. So far, the logic for currentRowOrdering seems to be working fine. Next, we have asked the optimizer to use the index index=nonUniqueOnValue_Table3 on Table3. This index covers the predicate 6) since that predicate is on the same column on which the index is created but it does not cover the other columns from table3 that are being referenced in this query (which table3.id and table3.name). Because of this, we determine that the index being considered is not a covering index. The code to determine whether the sorting can be avoided for &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, -1, -1&amp;#93;&lt;/span&gt;, is in OrderByList.sortRequired(RowOrdering, JBitSet) method. Since order by is on table2.value, the order by column&apos;s table does not match with table3 and hecne we determine that sorting is not required based on what optimizer has seen so far. So it appears that we leave it to table2 when its turn comes in the join order to decide whether sorting should indeed be avoided or not.&lt;/p&gt;

&lt;p&gt;Next we consider the join order &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, table2, -1&amp;#93;&lt;/span&gt;. For table2, we have asked the optimizer to use index=nonUniqueOnValue_Table2. First thing that we do is go through the join predicates 1), 2) and 3). Predicate number 3) which is TABLE3.ID = TABLE2.ID can be pushed down to optimizable table2 because the current join order &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, table2, -1&amp;#93;&lt;/span&gt; includes the tables referenced by predicate 3). So, at this point, there are 2 predicates pushed down to table3, they are number 5) and 6). And for table2, there are 2 prdicates pushed down to it, they are number 3) and 4). Also, since predicate 4) is a constant comparison, it will get added to currentRowOrdering. At this point, currentRowOrdering.columnsAlwaysOrdered will look as folows&lt;br/&gt;
Direction: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2&lt;br/&gt;
We are saying above that Table at position 0 (which is Table3 in our eg) has column 3(value) and column 2(name) which are always ordered because they are being compared with constants. In addition, Table at position 1(which is Table2 in our join order) has column 2 which is always ordered because it is being compared with constant. Next, we have asked the optimizer to use the index nonUniqueOnValue_Table2 but it does not cover the constant comparison predicate 4) since that predicate is on column name and not value. Notice, this is a different code path we are following for table2 compared to table3 above. Because table3.value is not already an ordered column in currentRowOrdering because there is no&lt;br/&gt;
constant comparison predicate on it, we add it to the &quot;ordering &quot; vector in currentOrdering object. This is the first object that gets added to the currentRowOrdering.&quot;ordering&quot; vector in our eg. So, at this point, the currentRowOrdering has only 3 of it&apos;s fields propulated and they are as follows&lt;br/&gt;
columnsAlwaysOrdered	ColumnOrdering&lt;br/&gt;
	Direction: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2&lt;br/&gt;
currentColumnOrdering	ColumnOrdering &lt;br/&gt;
	Direction: 1 Table 1, Column 3&lt;br/&gt;
ordering	Vector&amp;lt;E&amp;gt;  &lt;br/&gt;
	&lt;span class=&quot;error&quot;&gt;&amp;#91;Direction: 1 Table 1, Column 3&amp;#93;&lt;/span&gt;&lt;br/&gt;
The index nonUniqueOnValue_Table2 does not cover any predicate on Table2 and it does not cover all the column from table2 that are being referenced in this query and hence it is not a covering index. Next, the code to determine whether sort can be avoided for join order &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, table2, -1&amp;#93;&lt;/span&gt;, we go through the code path in OrderByList.sortRequired(RowOrdering, JBitSet) method. We find that the order by column&apos;s table matches with table2 in join order. Because of this match, we need to look at currentRowOrdering to see if it will take care of the sorting and if so we can avoid the sort. To look into currentRowOrdering, we first call currentRowOrdering.alwaysOrdered(cr.getTableNumber()) (in this call, cr is the order by column). So, we are checking if table2 is always ordered in currentRowOrdering. Since table2 is not always ordered in this query, this check returns false. Next, we check if not the entire table, is the order by table.order by column combination always ordered in currentRowOrdering. In our query, that will be table2.value Since there is no constant comparison predicate on table2.value, it is not going to be in columnsAlwaysOrdered vector in currentRowOrdering.&lt;br/&gt;
For reference, currentRowOrdering looks as follws&lt;br/&gt;
columnsAlwaysOrdered	ColumnOrdering&lt;br/&gt;
	Direction: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2&lt;br/&gt;
currentColumnOrdering	ColumnOrdering &lt;br/&gt;
	Direction: 1 Table 1, Column 3&lt;br/&gt;
ordering	Vector&amp;lt;E&amp;gt;  &lt;br/&gt;
	&lt;span class=&quot;error&quot;&gt;&amp;#91;Direction: 1 Table 1, Column 3&amp;#93;&lt;/span&gt;&lt;br/&gt;
As we can see from currentRowOrdering object above, columnsAlwaysOrdered does not include Table 1, Column 3. So, we have not found table2 to be always ordered and we have not found table2.value to be always ordered either. The last place to check is the ordering vector in columnsAlwaysOrdered. This vector does include Table 1, Column 3 which is table2.value and hence we determine that sorting is not needed to table2. All this code of checking the columnsAlwaysOrdered happens in OrderByList.sortRequired(RowOrdering, JBitSet). Assuming that this code is working as intended, I think then the culprit might be when we generate the code. The only step in optimize left is to add table1 to the join order. So, at the end of the optimize phase, the join order will look as follows &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, table2, table1&amp;#93;&lt;/span&gt; and currentRowOrdering looks as follows&lt;br/&gt;
columnsAlwaysOrdered	ColumnOrdering&lt;br/&gt;
	Direction: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2&lt;br/&gt;
currentColumnOrdering	ColumnOrdering &lt;br/&gt;
	Direction: 1 Table 2, Column 1&lt;br/&gt;
ordering	Vector&amp;lt;E&amp;gt;  &lt;br/&gt;
	&lt;span class=&quot;error&quot;&gt;&amp;#91;Direction: 1 Table 1, Column 3, Direction: 1 Table 2, Column 1&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The only change to currentRowOrdering that is caused by adding of table1 in third join order position is that we are going to use primary key on table1 and hence we need to reflect that in currentRowOrdering by adding it to the ordering vector.&lt;/p&gt;</comment>
                            <comment id="12705719" author="mikem" created="Mon, 4 May 2009 21:01:48 +0100"  >&lt;p&gt;Let me know if I am understanding what is going on.&lt;br/&gt;
To me what looks like is happening is that the optimizer is looking&lt;br/&gt;
at each of the join nodes and says the following:&lt;br/&gt;
table3 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table3 :&lt;br/&gt;
    always ordered because we only get rows where table3.value = 21857&lt;br/&gt;
    but note that it is a non-unique key so multiple rows can come back.&lt;/p&gt;

&lt;p&gt;table2 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table2&lt;br/&gt;
    here it see&apos;s that an index scan on table2 will return keys in table2.valu&lt;br/&gt;
    order.&lt;/p&gt;

&lt;p&gt;Now it seems like the optimizer is saying that since table3 is always ordered&lt;br/&gt;
that it can then consider the result set to be solely ordered on&lt;br/&gt;
table2.value.  This would be a correct assumption if table3 returned a single&lt;br/&gt;
row, but not correct when it returns multiple rows.&lt;/p&gt;

&lt;p&gt;In the bug case it looks to me like table3 returns 3 rows where&lt;br/&gt;
table3.value = 21857.&lt;/p&gt;

&lt;p&gt;table3.id  | table3.value&lt;br/&gt;
----------------------------------------------&lt;br/&gt;
2147483653 |21857&lt;br/&gt;
2147483654 |21857&lt;br/&gt;
4294967297 |21857&lt;/p&gt;

&lt;p&gt;Now the next part of the join has been forced to use&lt;br/&gt;
table2.nonUniqueOnValue_Table2, which is not useful other than providing&lt;br/&gt;
sorted access, so it turns into a table scan. The key is that it turns&lt;br/&gt;
into 3 table scans, searching for table3.id=table2.id leading to:&lt;/p&gt;

&lt;p&gt;ID         |table2.VALUE |VALUE&lt;br/&gt;
----------------------------------------------&lt;br/&gt;
2147483653 |000002       |21857&lt;br/&gt;
2147483654 |000003       |21857&lt;br/&gt;
4294967297 |000001       |21857&lt;/p&gt;

&lt;p&gt;The code does THREE full scan using the index and thus the rows are not&lt;br/&gt;
ordered by table2.value.  So even though we are using a key that should give&lt;br/&gt;
us the correct sorted order on table2.value, we are traversing it more than&lt;br/&gt;
once so it does not matter.  If the probes had been done using a single&lt;br/&gt;
scan with something like where (id = 2147483653 or 2147483654 or 4294967297)&lt;br/&gt;
it would have been sorted correctly, but that is not how joins work.&lt;/p&gt;

&lt;p&gt;I believe the execution code is doing the right thing.   It seems to me that&lt;br/&gt;
the optimizer code is incorrectly using the &quot;always sorted information&quot;&lt;br/&gt;
incorrectly.&lt;/p&gt;</comment>
                            <comment id="12705726" author="mamtas" created="Mon, 4 May 2009 21:24:17 +0100"  >&lt;p&gt;Mike, thanks for your time on this jira. Yes, your understanding of my description is correct. I think the key here is that the outer table(table3) is returning more than one row and each one of those row is requiring us to look at the middle table (table2) which results into 3 scans on table2. So even though, table2.value has index on it, it is not helping in this case because of 3 different scans on table2. If it were just one scan on table2, then the index table2.value would have returned the rows to us in proper order. The 3 different scans would require a sorting on them to return the rows in sorted order.&lt;/p&gt;</comment>
                            <comment id="12706497" author="army" created="Wed, 6 May 2009 17:28:30 +0100"  >&lt;p&gt;Attaching another SQL file, d3926_repro.sql, which reproduces the problem (for me) with a simpler set of tables and data.&lt;/p&gt;

&lt;p&gt;This repro was motivated by the observation made by Mike and re-iterated by Mamta, namely:&lt;/p&gt;

&lt;p&gt;&amp;gt; the key here is that the outer table(table3) is returning more than one row and&lt;br/&gt;
&amp;gt; each one of those row is requiring us to look at the middle table (table2) which&lt;br/&gt;
&amp;gt; results into 3 scans on table2 &lt;/p&gt;

&lt;p&gt;Put differently, the outer table is the one which is &quot;driving&quot; the iteration because a) each row from the outer table leads to a scan on the middle table, and b) the optimizer determines that no sort is necessary.  Thus the order of the result is based solely on the order of the rows that are retrieved from the outer table.&lt;/p&gt;

&lt;p&gt;Some observations about what was necessary to get this particular repro to work:&lt;/p&gt;

&lt;p&gt;  1) The outer table (T1) has a non-unique index on column I1, and we force the optimizer to use that non-unique index.&lt;/p&gt;

&lt;p&gt;      Why? If the optimizer were to use a table scan for T1 then we would check to see if T1 was a &quot;oneRowResultSet&quot;, which it isn&apos;t (and can&apos;t be, since we need T1 to return multiple rows in order to satisfy observation 3 below).  Since it&apos;s not a one-row result set T1 would then get added to the list of &quot;unordered optimizables&quot; for the join order--and if that list has at least one optimizable in it, we would end up doing an explicit sort and thus the problem would not repro.  So the plan for T1 must use an index.&lt;/p&gt;

&lt;p&gt;  2) There is a predicate in the WHERE clause which compares the non-unique indexed column T1.I1 to a CONSTANT expression.&lt;/p&gt;

&lt;p&gt;      Why? If such a predicate did not exist then T1.I1 would be added as the first column in the &quot;rowOrdering&quot; for the join order.  Then when the optimizer adds the middle table (T2) to the join order, it would see that the index for T2 does &lt;b&gt;not&lt;/b&gt; satisfy the ordering requirement of T1.I1, which means we would end up doing an explicit sort for the whole plan.  So the problem would not repro.  By adding a predicate to compare T1.I1 with a constant, we effectively make T1.I1 &quot;always ordered&quot; and so we do not need to add it to the row ordering.&lt;/p&gt;

&lt;p&gt;  3) The outer table (T1) has multiple rows which have the same value for the indexed column T1.I1.&lt;/p&gt;

&lt;p&gt;      Why? The presence of multiple rows is important because that&apos;s what leads to multiple scans on the middle table (as pointed out by Mike and Mamta).  So we need to have a predicate which compares to a fixed constant value (observation 2), but we also need that predicate to return multiple rows.  Thus there must be multiple rows in T1 which have I1 column values that equal the constant value used in the predicate.  (This is why the index for T1 must be non-unique.)&lt;/p&gt;

&lt;p&gt;  4) The middle table (T2) has an index that is ordered the same way as the ORDER BY clause.  We force the optimizer to use that index for T2.&lt;/p&gt;

&lt;p&gt;      Why? If the optimizer is using an index that satisfies the ordering requirement for the query, it will try to avoid sorting the resultant rows.  Sort avoidance is key to reproducing the reported behavior--esp. the optimizer &lt;b&gt;thinks&lt;/b&gt; it can avoid the sort, and does so, but in truth it should &lt;b&gt;not&lt;/b&gt; have done so.&lt;/p&gt;

&lt;p&gt;  5) The index for T2 is not covering--and esp. it does &lt;b&gt;not&lt;/b&gt; include the column T2.I2 that is used for joining with the outer table.&lt;/p&gt;

&lt;p&gt;      Why? The fact that the index is non-covering means that we will have to go to the T2 table conglomerate to fetch the row that has the current join value--and access to the table conglomerate is &lt;em&gt;unordered&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;  6)  The column from T1 (outer table) that is joined with T2 (middle table) has varied values for each of the rows.&lt;/p&gt;

&lt;p&gt;      Why? The presence of different values in T1.J1 means that we will scan T2&apos;s table conglomerate multiple times for different T2.I2 values, and since the table conglomerate is unordered (observation 5), those multiple scans will return the rows in an order that does &lt;b&gt;not&lt;/b&gt; match the index order.&lt;/p&gt;

&lt;p&gt;  7) The rows that are inserted into T2 are inserted in an order that does NOT match the ORDER BY ordering.&lt;/p&gt;

&lt;p&gt;      Why? It appears that, when inserting rows into a table, the order of the rows in the base table conglomerate generally matches the insertion order.  I don&apos;t think there are any guarantees of that, but that&apos;s what I observed for this simple data.  So if we were to insert the rows in proper order, access to the base table conglomerate (observations 5 &amp;amp; 6) might in fact return the rows in the desired order by accident, which would hide the problem that we&apos;re trying to reproduce.&lt;/p&gt;

&lt;p&gt;With all of those observations in place, I was able to write the attached script to reproduce the problem for me.  The results I see when I run are:&lt;/p&gt;

&lt;p&gt;J1         |J2  |J3&lt;br/&gt;
---------------------------&lt;br/&gt;
0          |f   |five&lt;br/&gt;
1          |g   |six&lt;br/&gt;
2          |e   |four&lt;/p&gt;

&lt;p&gt;but the query specifies &quot;ORDER BY t2.j2&quot;, so the rows are in the wrong order.&lt;/p&gt;

&lt;p&gt;It would be great if others could try to run the script to make sure they see the same behavior (if not, then some or all of this comment may in fact be wrong or incomplete...).&lt;/p&gt;</comment>
                            <comment id="12706509" author="mamtas" created="Wed, 6 May 2009 17:48:39 +0100"  >&lt;p&gt;Army, I tried your much simpler repro and it reproduces the problem.&lt;/p&gt;</comment>
                            <comment id="12707021" author="mamtas" created="Thu, 7 May 2009 19:13:13 +0100"  >&lt;p&gt;It appears that we need to catch the case where an optimizable is not the outermost node and optimizer is considering using an index on that optimizable (the index is on the order by column) and there is no constant comparison predicate on that column. This pretty much makes the index of no use but say the optimizer has been forced to use that index through optimizer overrides (ie what we have done in our test queries in this jira). If the outer tables in the join order are all one-row resultset, then it is not an issues because we will be doing only one scan on the optimizable in question and all the rows returned for that optimizable will be sorted on the index being considered on optimizable. The problem case is when there are outer optimizable involved and the outer optimizables will qualify more than one row which will be returned for them and for each one of those rows, we will be doing a scan on the optimizable in question and hence the rows satisfied through multiple scans of the optimizable in question will not be in any sorted order. To fix this, I am planning on adding additional code in OptimizerImpl.costBasedCostOptimizable after the following existing if statement at line 2239&lt;br/&gt;
if (joinPosition == 0 ||  optimizableList.getOptimizable(proposedJoinOrder&lt;span class=&quot;error&quot;&gt;&amp;#91;joinPosition - 1&amp;#93;&lt;/span&gt;).considerSortAvoidancePath())&lt;br/&gt;
Following is the psudeo code of what I am planning on adding&lt;br/&gt;
if (joinPosition != 0) //if we are the outermost optimizable, we are good to go.&lt;br/&gt;
{&lt;br/&gt;
    if (optimizable.currentPlanUsingIndex() &amp;amp;&amp;amp; optimizable.indexOnOrderByColumn() &amp;amp;&amp;amp; optimizable.noConstantPredicateOnIndexColumn())&lt;br/&gt;
        Sorting can&apos;t be avoided on this optimizable&lt;br/&gt;
    else&lt;/p&gt;
    {
        Continue with the existing code which is 
        if (requiredRowOrdering.sortRequired(currentRowOrdering,assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)
        ................... 
    }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;I will try to implement this psedo code. Let me know if anyone has any comments if this does not look like a good possible solution.&lt;/p&gt;</comment>
                            <comment id="12707045" author="mikem" created="Thu, 7 May 2009 20:06:05 +0100"  >&lt;p&gt;I was expecting a fix like the following, maybe I don&apos;t understand the code path that you&lt;br/&gt;
are proposing.  The key point seems to be whether the other optimizables in the join order which have been marked&lt;br/&gt;
&quot;already sorted&quot; are single row result sets or not.&lt;/p&gt;

&lt;p&gt;I don&apos;t think the issue is whether a &quot;useful&quot; index is being used or not.  Even a useful index&lt;br/&gt;
in the middle of a join may result in multiple probes.&lt;/p&gt;

&lt;p&gt;So was expecting something like:&lt;/p&gt;

&lt;p&gt;if (not outer most join)&lt;br/&gt;
    if (all previous join nodes which have been marked already sorted are single row result sets)&lt;br/&gt;
        consider sort avoidance on the current join node&lt;/p&gt;
</comment>
                            <comment id="12707215" author="mamtas" created="Fri, 8 May 2009 03:47:19 +0100"  >&lt;p&gt;Sorry, I don&apos;t know how but I missed the crucial logic for checking one row resultset on previous optimizables. &lt;/p&gt;

&lt;p&gt;Here is my new pseudo code for handling the check to see if we are going to consider a new order by column and that column does not have a constant predicate on it. Before it can decide to do sort avoidance, It needs to make sure that previous optimizables do not return more than one row.&lt;/p&gt;

&lt;p&gt;if (joinPosition != 0) { &lt;br/&gt;
    if (optimizable.addingNewOrderByColumn() &amp;amp;&amp;amp; optimizable.doesNotHaveConstantPredOnOrderByColumn())&lt;br/&gt;
    &lt;/p&gt;
{
	if (previousOptimizablesAreAllSingleRow()) 
	        consider sort avoidanve (by running the current code)
    	else
                             Sorting can&apos;t be avoided on this optimizable 
    }
&lt;p&gt; else&lt;br/&gt;
	        consider sort avoidanve (by running the current code)&lt;br/&gt;
}&lt;/p&gt;</comment>
                            <comment id="12708117" author="mamtas" created="Mon, 11 May 2009 18:25:32 +0100"  >&lt;p&gt;I have attached a patch (not intended for checkin) DERBY3926_notforcheckin_patch1_051109_diff.txt based on the pseudocode that I posted last week. It fixes the problem query in question but when I run wisconsin test, I see that now we are adding sort nodes on top of few queries. I am trying to understand if it makes sense for us to have the additional sort node case by case. The first case I am looking at seems like should not get a sort node when the patch is choosing to add one. The query for that case is as follows&lt;br/&gt;
	select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 order by TENKTUP1.unique1;&lt;/p&gt;

&lt;p&gt;The query plan for the above query shows tektup1 to be the outermost query so I am not sure why we need the sort node on the top. I will look further into it. If anyone has time to look at the patch, I will greatly appreciate it. There are no comments(minimal) for the new code. I will work on adding some comments and repost the patch to make it easier to read but the code should correspond fairly straightforward to the psuedo code posted last week.&lt;/p&gt;

&lt;p&gt;The old query plan for the query above from wisconsin is as follows&lt;br/&gt;
ij&amp;gt; values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS();&lt;br/&gt;
1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
Statement Name: &lt;br/&gt;
	C&lt;br/&gt;
Statement Text: &lt;br/&gt;
	select * from TENKTUP1, TENKTUP2&lt;br/&gt;
	 where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
	 order by TENKTUP1.unique1&lt;br/&gt;
Parse Time: 0&lt;br/&gt;
Bind Time: 0&lt;br/&gt;
Optimize Time: 0&lt;br/&gt;
Generate Time: 0&lt;br/&gt;
Compile Time: 0&lt;br/&gt;
Execute Time: 0&lt;br/&gt;
Begin Compilation Timestamp : null&lt;br/&gt;
End Compilation Timestamp : null&lt;br/&gt;
Begin Execution Timestamp : null&lt;br/&gt;
End Execution Timestamp : null&lt;br/&gt;
Statement Execution Plan Text: &lt;br/&gt;
Nested Loop Exists Join ResultSet:&lt;br/&gt;
&amp;lt;filtered number of opens&amp;gt;&lt;br/&gt;
&amp;lt;filtered rows seen from the left&amp;gt;&lt;br/&gt;
&amp;lt;filtered rows seen from the right&amp;gt;&lt;br/&gt;
Rows filtered = 0&lt;br/&gt;
&amp;lt;filtered rows returned&amp;gt;&lt;br/&gt;
	constructor time (milliseconds) = 0&lt;br/&gt;
	open time (milliseconds) = 0&lt;br/&gt;
	next time (milliseconds) = 0&lt;br/&gt;
	close time (milliseconds) = 0&lt;br/&gt;
Left result set:&lt;br/&gt;
	Index Row to Base Row ResultSet for TENKTUP1:&lt;br/&gt;
	&amp;lt;filtered number of opens&amp;gt;&lt;br/&gt;
	&amp;lt;filtered rows seen&amp;gt;&lt;br/&gt;
	Columns accessed from heap = &lt;/p&gt;
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}
&lt;p&gt;		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		Index Scan ResultSet for TENKTUP1 using index TK1UNIQUE1 at serializable isolation level using share table locking chosen by the optimizer&lt;br/&gt;
		&amp;lt;filtered number of opens&amp;gt;&lt;br/&gt;
		&amp;lt;filtered rows seen&amp;gt;&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 1&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
		scan information: &lt;br/&gt;
			Bit set of columns fetched=&lt;/p&gt;
{1}
&lt;p&gt;			Number of columns fetched=1&lt;br/&gt;
			Number of deleted rows visited=0&lt;br/&gt;
			&amp;lt;filtered number of pages visited&amp;gt;&lt;br/&gt;
			&amp;lt;filtered number of rows qualified&amp;gt;&lt;br/&gt;
			&amp;lt;filtered number of rows visited&amp;gt;&lt;br/&gt;
			Scan type=btree&lt;br/&gt;
			Tree height=2&lt;br/&gt;
			start position: 	None&lt;br/&gt;
			stop position: 	None&lt;br/&gt;
			qualifiers:None&lt;br/&gt;
Right result set:&lt;br/&gt;
	Index Row to Base Row ResultSet for TENKTUP2:&lt;br/&gt;
	&amp;lt;filtered number of opens&amp;gt;&lt;br/&gt;
	&amp;lt;filtered rows seen&amp;gt;&lt;br/&gt;
	Columns accessed from heap = &lt;/p&gt;
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}&lt;br/&gt;
		constructor time (milliseconds) = 0&lt;br/&gt;
		open time (milliseconds) = 0&lt;br/&gt;
		next time (milliseconds) = 0&lt;br/&gt;
		close time (milliseconds) = 0&lt;br/&gt;
		Index Scan ResultSet for TENKTUP2 using index TK2UNIQUE1 at serializable isolation level using share row locking chosen by the optimizer&lt;br/&gt;
		&amp;lt;filtered number of opens&amp;gt;&lt;br/&gt;
		&amp;lt;filtered rows seen&amp;gt;&lt;br/&gt;
		Rows filtered = 0&lt;br/&gt;
		Fetch Size = 1&lt;br/&gt;
			constructor time (milliseconds) = 0&lt;br/&gt;
			open time (milliseconds) = 0&lt;br/&gt;
			next time (milliseconds) = 0&lt;br/&gt;
			close time (milliseconds) = 0&lt;br/&gt;
		scan information: &lt;br/&gt;
			Bit set of columns fetched=All&lt;br/&gt;
			Number of columns fetched=2&lt;br/&gt;
			Number of deleted rows visited=0&lt;br/&gt;
			&amp;lt;filtered number of pages visited&amp;gt;&lt;br/&gt;
			&amp;lt;filtered number of rows qualified&amp;gt;&lt;br/&gt;
			&amp;lt;filtered number of rows visited&amp;gt;&lt;br/&gt;
			Scan type=btree&lt;br/&gt;
			Tree height=2&lt;br/&gt;
			start position: &lt;br/&gt;
	&amp;gt;= on first 1 column(s).&lt;br/&gt;
	Ordered null semantics on the following columns: 0 &lt;br/&gt;
			stop position: &lt;br/&gt;
	&amp;gt; on first 1 column(s).&lt;br/&gt;
	Ordered null semantics on the following columns: 0 &lt;br/&gt;
			qualifiers:None&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The new query plan after my changes is as follows&lt;br/&gt;
ij&amp;gt; values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS();&lt;br/&gt;
1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
Statement Name:&lt;br/&gt;
        null&lt;br/&gt;
Statement Text:&lt;br/&gt;
        select * from TENKTUP1, TENKTUP2&lt;br/&gt;
         where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
         order by TENKTUP1.unique1&lt;br/&gt;
&lt;br/&gt;
Parse Time: 0&lt;br/&gt;
Bind Time: 0&lt;br/&gt;
Optimize Time: 0&lt;br/&gt;
Generate Time: 0&lt;br/&gt;
Compile Time: 0&lt;br/&gt;
Execute Time: 0&lt;br/&gt;
Begin Compilation Timestamp : null&lt;br/&gt;
End Compilation Timestamp : null&lt;br/&gt;
Begin Execution Timestamp : null&lt;br/&gt;
End Execution Timestamp : null&lt;br/&gt;
Statement Execution Plan Text:&lt;br/&gt;
Sort ResultSet:&lt;br/&gt;
Number of opens = 1&lt;br/&gt;
Rows input = 10000&lt;br/&gt;
Rows returned = 10000&lt;br/&gt;
Eliminate duplicates = false&lt;br/&gt;
In sorted order = false&lt;br/&gt;
Sort information:&lt;br/&gt;
        Number of merge runs=3&lt;br/&gt;
        Number of rows input=10000&lt;br/&gt;
        Number of rows output=10000&lt;br/&gt;
        Size of merge runs=&lt;span class=&quot;error&quot;&gt;&amp;#91;3215, 3215, 3215&amp;#93;&lt;/span&gt;&lt;br/&gt;
        Sort type=external&lt;br/&gt;
        constructor time (milliseconds) = 0&lt;br/&gt;
        open time (milliseconds) = 0&lt;br/&gt;
        next time (milliseconds) = 0&lt;br/&gt;
        close time (milliseconds) = 0&lt;br/&gt;
        optimizer estimated row count:        10005.00&lt;br/&gt;
        optimizer estimated cost:        73930.40&lt;br/&gt;
&lt;br/&gt;
Source result set:&lt;br/&gt;
        Nested Loop Exists Join ResultSet:&lt;br/&gt;
        Number of opens = 1&lt;br/&gt;
        Rows seen from the left = 10000&lt;br/&gt;
        Rows seen from the right = 10000&lt;br/&gt;
        Rows filtered = 0&lt;br/&gt;
        Rows returned = 10000&lt;br/&gt;
                constructor time (milliseconds) = 0&lt;br/&gt;
                open time (milliseconds) = 0&lt;br/&gt;
                next time (milliseconds) = 0&lt;br/&gt;
                close time (milliseconds) = 0&lt;br/&gt;
                optimizer estimated row count:        10005.00&lt;br/&gt;
                optimizer estimated cost:        73930.40&lt;br/&gt;
&lt;br/&gt;
        Left result set:&lt;br/&gt;
                Table Scan ResultSet for TENKTUP1 at read committed isolation level using instantaneous share row locking chosen by the optimizer&lt;br/&gt;
                Number of opens = 1&lt;br/&gt;
                Rows seen = 10000&lt;br/&gt;
                Rows filtered = 0&lt;br/&gt;
                Fetch Size = 16&lt;br/&gt;
                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        next time in milliseconds/row = 0&lt;br/&gt;
&lt;br/&gt;
                scan information:&lt;br/&gt;
                        Bit set of columns fetched=All&lt;br/&gt;
                        Number of columns fetched=16&lt;br/&gt;
                        Number of pages visited=771&lt;br/&gt;
                        Number of rows qualified=10000&lt;br/&gt;
                        Number of rows visited=10000&lt;br/&gt;
                        Scan type=heap&lt;br/&gt;
                        start position:null                    &lt;br/&gt;
                        stop position:null                    &lt;br/&gt;
                        qualifiers:None&lt;br/&gt;
                        optimizer estimated row count:        10005.00&lt;br/&gt;
                        optimizer estimated cost:        14870.88&lt;br/&gt;
&lt;br/&gt;
        Right result set:&lt;br/&gt;
                Index Row to Base Row ResultSet for TENKTUP2:&lt;br/&gt;
                Number of opens = 10000&lt;br/&gt;
                Rows seen = 10000&lt;br/&gt;
                Columns accessed from heap = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}
&lt;p&gt;                        constructor time (milliseconds) = 0&lt;br/&gt;
                        open time (milliseconds) = 0&lt;br/&gt;
                        next time (milliseconds) = 0&lt;br/&gt;
                        close time (milliseconds) = 0&lt;br/&gt;
                        optimizer estimated row count:        10005.00&lt;br/&gt;
                        optimizer estimated cost:        59059.52&lt;/p&gt;

&lt;p&gt;                        Index Scan ResultSet for TENKTUP2 using index TK2UNIQUE1 at read committed isolation level using share row locking chosen by the optimizer&lt;br/&gt;
                        Number of opens = 10000&lt;br/&gt;
                        Rows seen = 10000&lt;br/&gt;
                        Rows filtered = 0&lt;br/&gt;
                        Fetch Size = 1&lt;br/&gt;
                                constructor time (milliseconds) = 0&lt;br/&gt;
                                open time (milliseconds) = 0&lt;br/&gt;
                                next time (milliseconds) = 0&lt;br/&gt;
                                close time (milliseconds) = 0&lt;br/&gt;
                                next time in milliseconds/row = 0&lt;/p&gt;

&lt;p&gt;                        scan information:&lt;br/&gt;
                                Bit set of columns fetched=All&lt;br/&gt;
                                Number of columns fetched=2&lt;br/&gt;
                                Number of deleted rows visited=0&lt;br/&gt;
                                Number of pages visited=20000&lt;br/&gt;
                                Number of rows qualified=10000&lt;br/&gt;
                                Number of rows visited=10000&lt;br/&gt;
                                Scan type=btree&lt;br/&gt;
                                Tree height=2&lt;br/&gt;
                                start position:&lt;br/&gt;
        &amp;gt;= on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:0&lt;br/&gt;
                                stop position:&lt;br/&gt;
        &amp;gt; on first 1 column(s).&lt;br/&gt;
        Ordered null semantics on the following columns:0&lt;br/&gt;
                                qualifiers:None&lt;br/&gt;
                                optimizer estimated row count:        10005.00&lt;br/&gt;
                                optimizer estimated cost:        59059.52&lt;/p&gt;</comment>
                            <comment id="12708213" author="mamtas" created="Mon, 11 May 2009 21:51:40 +0100"  >&lt;p&gt;I am reattaching the earlier patch with little more comments(DERBY3926_notforcheckin_patch2_051109_diff.txt)  to help understand the code for someone who might be looking at the patch. My patch is adding sort node for the query from the wisconsin test as shown below is&lt;br/&gt;
connect &apos;jdbc:derby:wombat&apos;;&lt;br/&gt;
select * from tenktup1, tenktup2&lt;br/&gt;
where tenktup1.unique1 = tenktup2.unique1&lt;br/&gt;
order by tenktup1.unique1;&lt;br/&gt;
I think the reason for the sort node might be the code below that I have added in my patch&lt;br/&gt;
if (currentRowOrdering.orderingRequiredOnTable(optimizable.getTableNumber()))&lt;/p&gt;

&lt;p&gt;With the if statement above, I was trying to see if the current optimizable is covering some columns from the order by and if there are constant predicates on those column. I am trying to do this by just looking at currentRowOrdering object. I think the correct code should look at both requiredRowOrdering provided by the user and current row ordering info for the current join order as collected by the optimizer in the currentRowOrdering object. I will work on fixing the if statement code above to see if it gets rid of the sort node for the query above.&lt;/p&gt;</comment>
                            <comment id="12708468" author="mikem" created="Tue, 12 May 2009 16:39:13 +0100"  >&lt;p&gt;My take on the most recent queryplan that you posted is that it does need a sort node as the outermost node&lt;br/&gt;
is a tablescan, not an ordered index scan.  Having said that it seems likely that somehow your change incorrectly&lt;br/&gt;
eliminated a sort avoidance path, and then that plan was costed differently and not chosen.  To be sure you could&lt;br/&gt;
take the problem wisconsin query, force the old join order/index choice using hints and then see if your new code&lt;br/&gt;
chooses sort avoidance.&lt;/p&gt;

&lt;p&gt;It seems to me the code you want to change is the path in current code where it has just chosen to add a node&lt;br/&gt;
to the query ordering vector (not look at the ordering vector after the fact).  At the point the code is about to add&lt;br/&gt;
a node, then you want to do the checks you have in your patch.&lt;/p&gt;</comment>
                            <comment id="12709898" author="mamtas" created="Fri, 15 May 2009 17:36:31 +0100"  >&lt;p&gt;I have attached a patch (DERBY3926_patch3_051509_diff.txt)  that fixes the reproducible order by query case. The problem was that when considering inner optimizable nodes that required ordering(but the user query has no constant comparison predicate(s) on those columns), we did not check if the previous optimizables all returned single rows before deciding to avoid sorting. If the previous optimizables return more than one row, then that would require multiple scans into the inner optimizable and the rows satisfied by the multiple scans may or may not be ordered as per the user query requirement. &lt;/p&gt;

&lt;p&gt;The new logic has gone into impl\sql\compile\OptimizerImpl.java and the supporting code to determine if the current inner optimizable requires ordering on columns with no constant comparison predicates on them is in impl\sql\compile\OrderByList.java&lt;/p&gt;

&lt;p&gt;The logic has also been explained in detail in OptimizerImpl.java I will appreciate if someone can take a look at it. I have run junit tests and derbyall. There are two failures in derbyall. One of them is for T_RawStoreFactory which I think is existing known jira issue &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3993&quot; title=&quot;With IBM 1.6 T_RawStoreFactory fails with There should be 0 observers, but we still have 1 observers on Win 2K&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3993&quot;&gt;&lt;del&gt;DERBY-3993&lt;/del&gt;&lt;/a&gt;. The other failure is in wisconsin test. Only one sql is failing in wisconsin. That sql with some optimizer overrides looks as follows.&lt;br/&gt;
select * from   --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
TENKTUP1   &amp;#8211; DERBY-PROPERTIES index=TK1UNIQUE1&lt;br/&gt;
, TENKTUP2  &amp;#8211; DERBY-PROPERTIES index=TK2UNIQUE1&lt;br/&gt;
where TENKTUP1.unique1 = TENKTUP2.unique1&lt;br/&gt;
order by TENKTUP1.unique1, TENKTUP2.unique1;&lt;/p&gt;

&lt;p&gt;As the name of the columns suggest, there are unique indexes on the columns we are dealing with in the query above. With my changes in the patch, now we are requiring a sort on the top of the query plan. Prior to my changes, we were avoiding sort on this query. The reason we are requiring sort as per the new logic is - The outermost optimizable is TENKTUP1 and it is going to return more than one row. Next, we consider TENKTUP2 as the inner optimizable. We see that user has requested ordering on&lt;br/&gt;
TENKTUP2.unique1 and there is no constant predicate on TENKTUP2.unique1 AND the previous optimizable is not one row resultset and because of these conditions, we require that sorting is necessary. I think ideally, we should be able to avoid sort because even though the previous optimizable is returning more than one row, the current optimizable has equality check with the previous optimizable (on the ordered columns) and hence even though there will be multiple scans into current optimizable, the rows will&lt;br/&gt;
all be ordered because of the equality check. I haven&apos;t given this additional logic much thought. I will look more into it.&lt;/p&gt;</comment>
                            <comment id="12710809" author="army" created="Tue, 19 May 2009 18:43:31 +0100"  >&lt;p&gt;I took a look at the patch and the changes look reasonable to me. The latest version of the&lt;br/&gt;
patch seems a bit cleaner than the previous ones, which is nice.  And I like the detailed&lt;br/&gt;
comments in OptimizerImpl.java &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I did notice that in the latest patch there is an &quot;if&quot; condition which is commented out.  Was&lt;br/&gt;
that intentional, and if so, can it (and the corresponding {} brackets) be removed entirely,&lt;br/&gt;
instead of just being commented out?&lt;/p&gt;

&lt;p&gt;It might be useful if you could add a comment to indicate that the call to:&lt;/p&gt;

&lt;p&gt;  currentRowOrdering.alwaysOrdered(previousOptimizable.getTableNumber())&lt;/p&gt;

&lt;p&gt;will return true if the optimizable was found to be a &quot;oneRowResultSet&quot; during costing.&lt;br/&gt;
That might make it more clear that the code is actually in sync with the comments which&lt;br/&gt;
precede it (I had to do some investigation before I could come to that conclusion).&lt;/p&gt;

&lt;p&gt;Your explanation of the failure in the wisconsin test makes sense to me. Thanks so much&lt;br/&gt;
for your diligence with this particular issue!&lt;/p&gt;</comment>
                            <comment id="12711024" author="mamtas" created="Wed, 20 May 2009 07:17:48 +0100"  >&lt;p&gt;Army, thanks for looking at the patch. I need to remove the commented out if condition along with corresponding {} brackets. Also, I have added the comment for currentRowOrdering.alwaysOrdered(previousOptimizable.getTableNumber()) Let me know if I should reword it differently. &lt;/p&gt;

&lt;p&gt;I have attached a patch with these changes and some more order by tests. That is the only difference between this patch and the earlier patch.,&lt;/p&gt;

&lt;p&gt;On another note, I was planning on moving all this new code inside the existing method OrderByList.sortRequired which gets called by OptimizerImpl. This way, all the decision regarding sort avoidance would have been made in the appropriate named method sortRequired. But the new code added by me needs access to current join order position, previous optimizables, predicate lists etc which are not available to OrderByList.sortRequired method. Passing these additional parameters to the method will require changes to other part of the Derby code where we call this method. Based on that, I am thinking that I should leave my new code where it is right now. If anyone feels differently about the location of the new code, do let me know.&lt;/p&gt;

&lt;p&gt;The only issue with the suggested patch is that a query like following is now going to require a sort node on the top which we didn&apos;t require earlier. Other than this one case, all the other test cases&lt;br/&gt;
have worked fine with my patch. I am inclied on going ahead and committing the patch with this know one case. If I don&apos;t hear anything back on the patch, I will plan on comitting it towards the end of the week.&lt;br/&gt;
select * from --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
TENKTUP1 &amp;#8211; DERBY-PROPERTIES index=TK1UNIQUE1 &lt;br/&gt;
, TENKTUP2 &amp;#8211; DERBY-PROPERTIES index=TK2UNIQUE1 &lt;br/&gt;
where TENKTUP1.unique1 = TENKTUP2.unique1 &lt;br/&gt;
order by TENKTUP1.unique1, TENKTUP2.unique1; &lt;/p&gt;</comment>
                            <comment id="12711211" author="mikem" created="Wed, 20 May 2009 17:28:56 +0100"  >&lt;p&gt;Do you know how the current code determines that sort can be avoided in the one remaining &lt;br/&gt;
case?  Does it do something special with the equality condition?&lt;/p&gt;</comment>
                            <comment id="12711212" author="mikem" created="Wed, 20 May 2009 17:37:47 +0100"  >&lt;p&gt;If others who know this code are ok with your patch then I am ok.&lt;/p&gt;

&lt;p&gt;In looking at the current code I thought it would be cleaner if all the information that was &lt;br/&gt;
necessary to answer the question of whether the current join ordering met the current&lt;br/&gt;
order by requirement was actually already located in the current RowOrdering object.&lt;/p&gt;

&lt;p&gt;This would not require pushing the information down into the OrderBy.requiredOrdering()&lt;br/&gt;
interface.  Instead the information should already be in the RowOrdering object, so that&lt;br/&gt;
OrderBy.sortRequired(), would be implemented as it is currently using just information&lt;br/&gt;
from the RowOrdering interface.  The work here is that some more information may need&lt;br/&gt;
to be tracked in the RowOrdering to implement the additional logic you have come up with.&lt;/p&gt;</comment>
                            <comment id="12711239" author="army" created="Wed, 20 May 2009 18:17:54 +0100"  >&lt;p&gt;mike&amp;gt; I thought it would be cleaner if all the information that was necessary&lt;br/&gt;
mike&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; was actually already located in the current RowOrdering object. &lt;br/&gt;
mike&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; The work here is that some more information may need to be tracked&lt;br/&gt;
mike&amp;gt; in the RowOrdering.&lt;/p&gt;

&lt;p&gt;For what little it&apos;s worth, I agree, I think this is a nice idea that would in fact be a&lt;br/&gt;
bit cleaner.  I think the current patch is acceptable, as well, but if I had the luxury&lt;br/&gt;
of choosing, I&apos;d probably go with Mike&apos;s approach, if possible...&lt;/p&gt;</comment>
                            <comment id="12711252" author="mamtas" created="Wed, 20 May 2009 18:42:18 +0100"  >&lt;p&gt;Mike asked &quot;Do you know how the current code determines that sort can be avoided in the one remaining &lt;br/&gt;
case? Does it do something special with the equality condition? &quot; I do not know how the code knows about avoiding the sort in case of following query. I will spend some time understanding the code path.&lt;br/&gt;
select * from --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
TENKTUP1 &amp;#8211; DERBY-PROPERTIES index=TK1UNIQUE1 &lt;br/&gt;
, TENKTUP2 &amp;#8211; DERBY-PROPERTIES index=TK2UNIQUE1 &lt;br/&gt;
where TENKTUP1.unique1 = TENKTUP2.unique1 &lt;br/&gt;
order by TENKTUP1.unique1, TENKTUP2.unique1; &lt;/p&gt;</comment>
                            <comment id="12711301" author="bryanpendleton" created="Wed, 20 May 2009 20:25:33 +0100"  >&lt;p&gt;I&apos;ve been following this discussion, and learning a lot! Thanks much for the careful writeups and explanations.&lt;/p&gt;

&lt;p&gt;It seems to me that the problem with the current Wisconsin query has to do with the precise definition of &quot;one row result set&quot;.&lt;/p&gt;

&lt;p&gt;If we go back to Mike&apos;s original insight some time ago, he said:&lt;/p&gt;

&lt;p&gt;&amp;gt; the key here is that the outer table(table3) is returning more than one row and&lt;br/&gt;
&amp;gt; each one of those row is requiring us to look at the middle table (table2) which&lt;br/&gt;
&amp;gt; results into 3 scans on table2&lt;/p&gt;

&lt;p&gt;And that seems correct to me. But at some point I think we lost the &quot;AND&quot; part of Mike&apos;s statement&lt;br/&gt;
when it was translated into the bits-and-bytes of actual code.&lt;/p&gt;

&lt;p&gt;That is, in the Wisconsin query in question, the outer table (TENKTUP1) is returning&lt;br/&gt;
more than one row, &lt;b&gt;however&lt;/b&gt; each one of those rows only results in a single&lt;br/&gt;
open of the inner table (TENKTUP2), because the join key is unique.&lt;/p&gt;

&lt;p&gt;This comment from the patch seems to describe the essence of the issue:&lt;/p&gt;

&lt;p&gt;+	 * ... and hence we need to make sure &lt;br/&gt;
+	 * that the outer predicates in the join order are all&lt;br/&gt;
+	 * one row optimizables meaning that they can at the&lt;br/&gt;
+	 * most return only one row. If they return more than&lt;br/&gt;
+	 * one row, then it will require multiple scans of the&lt;br/&gt;
+	 * current optimizable and the rows returned from&lt;br/&gt;
+	 * those multiple scans may not be ordered correctly.&lt;/p&gt;

&lt;p&gt;The thing I think we need to do is to figure out some way to encode the following test:&lt;/p&gt;

&lt;p&gt;   Are the outer predicates in the join such that they will require at most one scan of the current optimizable?&lt;/p&gt;

&lt;p&gt;I think the reason the Wisconsin query has changed behavior (now includes an unnecessary&lt;br/&gt;
sort) is because the patch isn&apos;t quite expressing exactly this idea. Outer predicates which&lt;br/&gt;
are &lt;b&gt;not&lt;/b&gt; one row result sets should still be able to perform sort avoidance plans, &lt;b&gt;as long as&lt;/b&gt;&lt;br/&gt;
the join condition will perform only a single open of the inner optimizable.&lt;/p&gt;</comment>
                            <comment id="12711781" author="mamtas" created="Thu, 21 May 2009 21:15:57 +0100"  >&lt;p&gt;I went through the optimizer code for following query&lt;br/&gt;
connect &apos;jdbc:derby:wombat&apos;;&lt;br/&gt;
select * from --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
TENKTUP1 &amp;#8211; DERBY-PROPERTIES index=TK1UNIQUE1 &lt;br/&gt;
, TENKTUP2 &amp;#8211; DERBY-PROPERTIES index=TK2UNIQUE1 &lt;br/&gt;
where TENKTUP1.unique1 = TENKTUP2.unique1 &lt;br/&gt;
order by TENKTUP1.unique1, TENKTUP2.unique1; &lt;/p&gt;


&lt;p&gt;During the optimize phase, for an optimizable, everytime we are considering a new access path for it, we check if the conglomerate being considered for the optimizable is an index conglomerate. If yes, then we check if the current ordering for the given join order already has the index columns in it. That check is done by the following call in FromBaseTable.nextAccessPath: 478	&lt;br/&gt;
if ( ! rowOrdering.orderedOnColumn(isAscending&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; ? RowOrdering.ASCENDING : RowOrdering.DESCENDING,&lt;br/&gt;
	getTableNumber(), baseColumnPositions&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;))&lt;br/&gt;
The RowOrderingImpl.orderedOnColumn:119 first checks if the optimizable we are dealing with is marked as always ordered(I think this happens if the optimizable is a one-row table). If yes, then the we will return true from RowOrderingImpl.orderedOnColumn. If not, we check if there was a predicate on the index column which makes it always ordered(line 127). If not,then we check if the column is already being ordered by checking ordering vector at line 133. If not, we go ahead and add the index column to the ordering vector in currentRowOrdering object.&lt;/p&gt;

&lt;p&gt;Going to the query above when the optimizer is going through the join order &lt;span class=&quot;error&quot;&gt;&amp;#91;0, -1&amp;#93;&lt;/span&gt; which means it is considering TENKTUP1 at the outermost join order position and no optimizable has yet been considered in the next position yet. For TENKTUP1, we go through the above piece of code. The method RowOrderingImpl.orderedOnColumn is going to return false for the index column UNIQUE1(index TK1UNIQUE1 is on that column) because &lt;br/&gt;
a)TENKTUP1 is not always ordered meaning it is not one-row table&lt;br/&gt;
b)there is no constant predicate on TENKTUP1.UNIQUE1&lt;br/&gt;
c)there is no other ordering on TENKTUP1.UNIQUE1&lt;/p&gt;

&lt;p&gt;Since for our query, the index column UNIQUE1 is not already ordered yet in the currentRowOrdering object, we go ahead and add it to the ordering vector inside currentRowOrdering object (this is done in FromBaseTable.nextAccessPath at line: 484 with following 2 code lines.)&lt;br/&gt;
	rowOrdering.nextOrderPosition(isAscending&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; ? RowOrdering.ASCENDING : RowOrdering.DESCENDING);&lt;br/&gt;
	rowOrdering.addOrderedColumn(isAscending&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; ? RowOrdering.ASCENDING : RowOrdering.DESCENDING,&lt;br/&gt;
		getTableNumber(), baseColumnPositions&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;);&lt;br/&gt;
This adding of TENKTUP1.UNIQUE1 to ordering object will indicate that the rows are ordered on that column. So, at the end of considering access path for &lt;span class=&quot;error&quot;&gt;&amp;#91;0, -1&amp;#93;&lt;/span&gt; join order position, currentRowOrdering object will have TENKTUP1.UNIQUE1 in ordering vector and it will be marked as the current column ordering (this is done by having currentColumnOrdering = TENKTUP1.UNIQUE1). &lt;/p&gt;

&lt;p&gt;Next, we work on finding the cost of the given access path for &lt;span class=&quot;error&quot;&gt;&amp;#91;0, -1&amp;#93;&lt;/span&gt; join order. Once we find the cost, we check to see if it makes sense to avoid sort on it from what we know so far. This is done in OptimizerImpl.costBasedCostOptimizable through following piece of code&lt;br/&gt;
	if (considerSortAvoidance &amp;amp;&amp;amp; requiredRowOrdering.sortRequired(currentRowOrdering,&lt;br/&gt;
		assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)&lt;br/&gt;
What we are doing here is checking if the ordering requested by the user for the current table (that information is in requiredRowOrdering) is satisfied by row ordering provided by the join order being considered so far. The row ordering provided for the current join order is in currentRowOrdering. In our specific eg, since user has requested for ordering on TENKTUP1.UNIQUE1 and we are ordering on it because of the index that is being used, the above call to requiredRowOrdering.sortRequired is going to return sorting not required.&lt;/p&gt;

&lt;p&gt;Next, we put the next optimizable in the join order, meaning moving from &lt;span class=&quot;error&quot;&gt;&amp;#91;0,-1&amp;#93;&lt;/span&gt; join order to &lt;span class=&quot;error&quot;&gt;&amp;#91;0, 1&amp;#93;&lt;/span&gt;. At this point, optimizer is considering TENKTUP2 in the 2nd join order position. We have asked the optimizer to use index TK2UNIQUE1 for optimizable TENKTUP2. We go through the same code path as above for this optimizable. We will find that the index column TENKTUP2.unique1 needs to be added to ordering vector in currentRowOrdering because TENKTUP2 is not one-row table and there is no constant predicate on TENKTUP2.unique1 and hence the current index being considered on TENKTUP2 is going to provide ordering on TENKTUP2.unique1. Next, we see if sort can be aovided for TENKTUP2 by comparing required row ordering against current row ordering. User has required ordering on TENKTUP2.unique1 and current row ordering satisfies that ordering because of the index which is being considered for TENKTUP2.&lt;/p&gt;

&lt;p&gt;So, if my understanding of code is correct, the sorting is getting avoided NOT based on the fact that equality condition exists between the two optimizables ie TENKTUP1.unique1 = TENKTUP2.unique1 In other words, sorting avoidacne decision was not based on TENKTUP1.unique1 = TENKTUP2.unique1 It was because optimizer decides that the individual sorting required on the optimizables have been satisfied by indexes picked on them.&lt;/p&gt;

&lt;p&gt;Hope this helps understand the current behavior of the trunk code for the query in question.&lt;/p&gt;</comment>
                            <comment id="12712398" author="knutanders" created="Sat, 23 May 2009 11:29:43 +0100"  >&lt;p&gt;OrderByAndSortAvoidance.java has been causing warnings when building the javadocs in UTF-8 locale because it contains non-ASCII characters encoded with ISO-8859-1. The warnings look like this:&lt;/p&gt;

&lt;p&gt;  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; /code/derby/trunk1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByAndSortAvoidance.java:738: warning: unmappable character for encoding UTF8&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt;                 + &quot;documents.  Ils ont &#65533;t&#65533; faits pour quelque chose.&apos;)&quot;);&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt;                                        ^&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; /code/derby/trunk1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByAndSortAvoidance.java:738: warning: unmappable character for encoding UTF8&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt;                 + &quot;documents.  Ils ont &#65533;t&#65533; faits pour quelque chose.&apos;)&quot;);&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt;                                          ^&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; /code/derby/trunk1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByAndSortAvoidance.java:901: warning: unmappable character for encoding UTF8&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt;                             &quot;&apos;BatchTypeInstructions&apos;, &apos;Ne pas jeter ces documents.  Ils ont &#65533;t&#65533; faits pour quelque chose.&apos;)&quot;);&lt;br/&gt;
  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt;                                                                                             ^&lt;br/&gt;
.&lt;br/&gt;
.&lt;br/&gt;
.&lt;/p&gt;

&lt;p&gt;I fixed it in revision 777886 by replacing the occurrences of the problematic non-ASCII character (&#233;) with a Unicode escape sequence (\u00e).&lt;/p&gt;</comment>
                            <comment id="12712480" author="mamtas" created="Sun, 24 May 2009 01:11:25 +0100"  >&lt;p&gt;Thanks, Knut.&lt;/p&gt;</comment>
                            <comment id="12713641" author="mamtas" created="Wed, 27 May 2009 17:58:38 +0100"  >&lt;p&gt;I am attaching a new patch, namely DERBY3926_patch5_052709_stat.txt. This patch still does the same thing as the previous patch which is to make sure that if order by column does not belong to the outermost optimizable, then check if the order by column has a constant comparison predicate on it or it is coming from a single-row table. If either of the 2 conditions is true then we do not need to worry if the outer opitimizable to the optimizable for order by column are one-row resultsets or not. One thing to note is that I have the additional check to see if the order by column comes from a single row table. Earlier patch only checked if the order by column has constant comparison predicate on it. All this logic is now in RequiredRowOrdering:sortRequired(RowOrdering rowOrdering, JBitSet tableMap, OptimizableList optimizableList) throws StandardException;&lt;br/&gt;
This is more logical place for code to be in rather than putting in OptimizerImpl which is where the previous patch put the code changes.&lt;/p&gt;

&lt;p&gt;The one item remaining on this jira is one query from wisconsin that now requires a sorting node rather than avoiding the sort. Mike and Bryan are right about checking if the previous optimizables are multi-row optimizables then see if the multiple scan into order by column&apos;s optimizable are all going to return same single row resulset. If so, then there is no need to require sorting even though outer optimizables are multu-row resultsets.&lt;/p&gt;</comment>
                            <comment id="12714538" author="mikem" created="Fri, 29 May 2009 19:17:07 +0100"  >&lt;p&gt;I reviewed patch 5 and only comment I think requires change is that patch should enable the test you already added to always be run as part of the suite.&lt;/p&gt;

&lt;p&gt;nits:&lt;br/&gt;
I find the &quot;alwaysOrdered&quot;, isColumnAlwaysOrdered, terminology confusing.   Sometimes we need to be checking one row result set, and sometimes we seem it to mean a single value but may be multiple duplicate values.  It would be nice if the routine names reflected what we are counting on.&lt;/p&gt;

&lt;p&gt;The new routine you added  isColumnAlwaysOrdered() is doc&apos;d as:&lt;br/&gt;
+    * Return true if the column is always ordered. That will be true if the&lt;br/&gt;
+    * column has a constant comparison predicate on it.&lt;br/&gt;
But the comment in the call to it seems to say it is expecting something different:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The current order by column does not have any constant&lt;/li&gt;
	&lt;li&gt;comparison predicate on it nor does it belong to a&lt;/li&gt;
	&lt;li&gt;single row table which means that the rows will not&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;o some lines over 80&lt;/p&gt;

&lt;p&gt;o mostly uses brace on new line, but on the following uses brace on same line:&lt;br/&gt;
 if (moreThanOneTableInJoinOrder) {&lt;/p&gt;

</comment>
                            <comment id="12716172" author="mamtas" created="Thu, 4 Jun 2009 07:26:45 +0100"  >&lt;p&gt;I am attaching DERBY3926_patch5_060309_diff.txt Hopefully, this is the final patch for this jira entry. This patch takes care of the original problem query and one query from wisconsin which was getting an unnecessary sort node on it with the previous patch (DERBY3926_patch5_052709_stat.txt). &lt;/p&gt;

&lt;p&gt;Following are the files that were touched by the patch.&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\RowOrderingImpl.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\OrderByList.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\FromBaseTable.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\OptimizerImpl.java&lt;br/&gt;
M      java\engine\org\apache\derby\impl\sql\compile\PredicateList.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\sql\compile\RowOrdering.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\sql\compile\RequiredRowOrdering.java&lt;br/&gt;
M      java\engine\org\apache\derby\iapi\sql\compile\OptimizablePredicateList.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\lang\wisc_setup.sql&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\lang&amp;#95;Suite.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\tests\lang\OrderByAndSortAvoidance.java&lt;br/&gt;
M      java\testing\org\apache\derbyTesting\functionTests\master\wisconsin.out&lt;/p&gt;


&lt;p&gt;Following is the patch description.&lt;br/&gt;
The problem with the trunk codeline is that when optimizer goes through optimizables in a join order, it only looks at those optimizables individually to decide whether sorting can be avoided on them or not. That approach leaves out few queries which require sorting but do not get sorted. The decision for avoiding sorting should also include relationship between the optimizables in a given join order. Following query demonstrates the trunk problem&lt;br/&gt;
SELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
table3 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table3 &lt;br/&gt;
, table2 &amp;#8211; DERBY-PROPERTIES index=nonUniqueOnValue_Table2 &lt;br/&gt;
, table1 &lt;br/&gt;
WHERE table1.id=table2.id AND table2.name=&apos;PageSequenceId&apos; &lt;br/&gt;
AND table1.id=table3.id &lt;br/&gt;
AND table3.name=&apos;PostComponentId&apos; &lt;br/&gt;
AND table3.value=&apos;21857&apos; ORDER BY table2.value; &lt;/p&gt;

&lt;p&gt;In the query above, when optimizer is considering &lt;span class=&quot;error&quot;&gt;&amp;#91;table3, table2, -1&amp;#93;&lt;/span&gt; join order, it determines that sorting can be avoided on this join order because the order by column table2.value is already covered by the index nonUniqueOnValue_Table2. It does not see that the outermost optimizable table3 will qualify more than one row and hence it will be a multi-row resulset and for each one of those rows, we will be doing a scan into table2. In other words, there will be multiple scans into table2(and the rows returned by each one of those scans will be ordered on table2.value) but the collective rows from those multiple scans are not necessarily going to be ordered on table2.value. This patch is attempting to fix that problem.&lt;/p&gt;

&lt;p&gt;Currently, in trunk, a column is marked always ordered during a query processing when the optimizer finds that there is constant comparison predicate on the order by column. If the column does not have a constant predicate (as in our example above), we next see if we are using an index which will provide the required ordering on column (which is true in our case. The required ordering on table2.value is provided by the index nonUniqueOnValue_Table2). But as we can see in the query above, this index coverage is not enough to say that sorting is not needed. We need to add 2 more conditions before we can decide to avoid the sorting. One of those cases is 1)if the order by column does not belong to the outermost optimizable, then check if the order by column&apos;s optimizable is a one-row resultset. If yes, then it will be safe for the optimizer to avoid the sorting. The second case to consider is 2)if the order by column does not belong to the outermost optimizable, then check if the order by column&apos;s optimizable is multi-row resultset BUT all the outer optimizables are one-row resulsets. If either of these 2 additional conditions are satisfied then optimizer can choose to avoid the sorting. Otherwise&lt;br/&gt;
sorting should be added to the query plan. The example query above does not satisfy the 2 additional checks and hence sorting should be done as part of the query plan.&lt;/p&gt;

&lt;p&gt;The changes for the 1)check above has gone into OrderbyByList.sortRequired(RowOrdering, JBitSet, OptimizableList). The implementation of this change just required us to check the outer optimizables to be one row since the order by column&apos;s optimizable is not one row. If outer optimizables are all one-row, then we say that sorting can be avoided. Otherwise sorting is required.&lt;/p&gt;

&lt;p&gt;The changes for the 2)check above has gone into FromBaseTable.nextAccessPath(Optimizer optimizer, OptimizablePredicateList predList, RowOrdering rowOrdering) The implementation of this change requires us to see if the order by column is involved in equijoin with outer optimizable&apos;s indexed column. If yes, then we know that since outer optimizable is ordered, the rows qualified via the equijoin will also be ordered and hence sorting can be avoided. But if this is not true, then we can&apos;t rely on outer optimizables&apos; rows to be ordered on the order by column. To avoid sorting, we need to identify this case 2) as another case when the column can be marked as always ordered and that is when there is an equijoin predicate on the order by column with some other column&lt;br/&gt;
which is already known to be always ordered. Taking the query from wisconsin as an example will explain this behavior&lt;br/&gt;
select * from --DERBY-PROPERTIES joinOrder=FIXED &lt;br/&gt;
TENKTUP1 &amp;#8211; DERBY-PROPERTIES index=TK1UNIQUE1 &lt;br/&gt;
, TENKTUP2 &amp;#8211; DERBY-PROPERTIES index=TK2UNIQUE1 &lt;br/&gt;
where TENKTUP1.unique1 = TENKTUP2.unique1 &lt;br/&gt;
order by TENKTUP1.unique1, TENKTUP2.unique1; &lt;/p&gt;

&lt;p&gt;For the above query, as per the current trunk codeline, none of the order by columns are marked as always ordered because there is no constant comparison predicate on them. But, for the given join order, with TENKTUP1 as the outermost resultset and with the index TK1UNIQUE1, we know that the current row ordering at this point is going to ensure that rows from TENKTUP1 are ordered on UNIQUE1. Next, when we process TEKTUP2 in the 2nd join order position, we find that there is no constant predicate on TENKTUP2.unique1 and hence we conculde that the rows from TENKTUP2 are not going to be ordered and we decide to force a sort node on the top of the query. But in reality, even though the outer optimizable is not a single row resultset, it is ordered on TENKTUP1.unique1 and hence all those rows from outer optimizable are going to be ordered on TENKTUP1.unique1 and the inner optimizable has an equality join on &lt;/p&gt;

&lt;p&gt;TENKTUP1.unique1 using the order by column TENKTUP2.unique1 What that translates to is that even if there will be multiple scans into TENKTUP2, the rows qualified are going to be all ordered because of the equijoin between the outer and inner optimizables on the order by columns. So, with my latest patch, I have expanded the notion of always ordered columns to include both constant comparison predicates AND ordered column that has equijoin with an outer optimizable&apos;s ordered column. &lt;/p&gt;

&lt;p&gt;I think this patch is also improving the existing queries to include a better path than what it was picking up before. Following is an example of one such query from wisconsin.&lt;br/&gt;
select * from TENKTUP1, TENKTUP2 &lt;br/&gt;
where TENKTUP1.unique1 = TENKTUP2.unique1 &lt;br/&gt;
and TENKTUP2.unique1 &amp;lt; 100&lt;br/&gt;
order by TENKTUP1.unique1; &lt;br/&gt;
For this query, the trunk currently decides to use TENKTUP1 as the outermost optimizable using the TK1UNIQUE1 index and then those rows are filtered using TENKTUP2.unique1 &amp;lt; 100. Each of the 2 tables involved in the query have 10000 rows each. So we are going through 10000 qualified indexed rows from TENKTUP1 and then applying TENKTUP2.unique1 &amp;lt; 100 on them. With the attached patch, we use TENKTUP2 as the outermost optimizable with the index TK2UNIQUE1 and only gets the indexed rows which satisfy TENKTUP2.unique1 &amp;lt; 100 and then on them, we use the equlity join to fetch qualified rows from TENKTUP1. &lt;/p&gt;

&lt;p&gt;I hope the above explanation helps understand the patch. I would appreciate if someone can take the time to go through the patch and provide any feedback they may have. If I don&apos;t hear anything by early next week, I will go ahead and commit the patch.&lt;/p&gt;</comment>
                            <comment id="12716280" author="mamtas" created="Thu, 4 Jun 2009 14:53:57 +0100"  >&lt;p&gt;After doing a sync of the codeline and re-running the junit tests, I see failures in upgrade tests but I do not think they are related to my changes. &lt;/p&gt;</comment>
                            <comment id="12716735" author="mamtas" created="Fri, 5 Jun 2009 20:42:22 +0100"  >&lt;p&gt;To elaborate more on the upgrade test failures, I had the junit tests using the gui and that&apos;s when I saw upgrade test failures.&lt;br/&gt;
java -Xmx1024m -cp &apos;../../tools/java/junit.jar;../../classes&apos; junit.swingui.TestRunner -noloading org.apache.derbyTesting.functionTests.suites.All&lt;/p&gt;

&lt;p&gt;BTW, the platform for the test runs is Windows XP v2.10 and IBM 16 jdk.&lt;/p&gt;

&lt;p&gt;I ran the upgrade tests by themselves using the gui TestRunner and didn&apos;t see the failures. I am now running the entire junit test suit using text runner to see if the failures I saw earlier reproduce.&lt;br/&gt;
java -Xmx256M -XX:MaxPermSize=128M -cp &apos;../../tools/java/junit.jar;../../classes&apos; junit.textui.TestRunner org.apache.derbyTesting.functionTests.suites.All&lt;/p&gt;

&lt;p&gt;I will appreciate if someone has time to apply my patch and run the entire junit suite on their machine to see if the upgrade tests fail there. Thank you.&lt;/p&gt;</comment>
                            <comment id="12717095" author="mikem" created="Sun, 7 Jun 2009 21:25:44 +0100"  >&lt;p&gt;I ran full set of tests against ibm16 on a windows xp box with the latest patch and got no unexpected errors&lt;br/&gt;
(continue to get the replication test error seen in many nightly test runs).  I also by hand ran the upgrade tests&lt;br/&gt;
in the gui and did not get any errors with the patch also.&lt;/p&gt;

&lt;p&gt;Unless anyone else reviews and disagrees I think we should get this patch in and backported.  Any additional&lt;br/&gt;
improvements to the patch can be handled by subsequent work.&lt;/p&gt;</comment>
                            <comment id="12717311" author="mamtas" created="Mon, 8 Jun 2009 17:25:47 +0100"  >&lt;p&gt;Thanks, Mike, for ruuning the tests. I will plan on committing the patch tomorrow. &lt;/p&gt;

&lt;p&gt;One piece of possible improvement that can be made to the patch in future is to hide all the information about the column ordering in the RowOrdering object. Currently, we check if the current Optimizable is a one-row resultset or not and if not, then the check to make sure that all the previous optimizables should be one-row resultset happens in OrderByList.sortRequired(this check is done if we have found earlier that there is no equijoin between the current optimizable&apos;s order by column with columns already ordered from the previous optimizables. This check is made much earlier in the optimization phase and the result of that check is encapsulated in RowOrdering object and so no code restructuring is needed for this equijoin part of the logic. The possible code improvement is for part of the logic where the current optimizable is multi-row, there is no equijoin on this current optimizable&apos;s order by columns so say that ordering already exists and the previous optimizables are not all one-row resultset. It may be possible for this piece of logic to be encapsulated somehow in RowOrdering object). I am not sure if this encapsulation is feasible or not but just wanted to note it in the jira.&lt;/p&gt;

&lt;p&gt;This observation was also made by Mike and Army as comments to this jira entry,&lt;br/&gt;
********************************************************&lt;br/&gt;
A B added a comment - 20/May/09 10:17 AM &lt;br/&gt;
mike&amp;gt; I thought it would be cleaner if all the information that was necessary &lt;br/&gt;
mike&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; was actually already located in the current RowOrdering object. &lt;br/&gt;
mike&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; The work here is that some more information may need to be tracked &lt;br/&gt;
mike&amp;gt; in the RowOrdering. &lt;/p&gt;

&lt;p&gt;For what little it&apos;s worth, I agree, I think this is a nice idea that would in fact be a &lt;br/&gt;
bit cleaner. I think the current patch is acceptable, as well, but if I had the luxury &lt;br/&gt;
of choosing, I&apos;d probably go with Mike&apos;s approach, if possible... &lt;br/&gt;
********************************************&lt;/p&gt;</comment>
                            <comment id="12717318" author="mamtas" created="Mon, 8 Jun 2009 17:40:41 +0100"  >&lt;p&gt;BTW, i reran the reproducible test case for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4240&quot; title=&quot;An index cause SQL ORDER BY can&amp;#39;t return correct result&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4240&quot;&gt;&lt;del&gt;DERBY-4240&lt;/del&gt;&lt;/a&gt; with my patch and the test case returns correct result. Before committing the patch tomorrow, I will go ahead and add a test case for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4240&quot; title=&quot;An index cause SQL ORDER BY can&amp;#39;t return correct result&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4240&quot;&gt;&lt;del&gt;DERBY-4240&lt;/del&gt;&lt;/a&gt; in OrderByAndSortAvoidance.&lt;/p&gt;

&lt;p&gt;Also, I forgot to mention that I did take care of following comments from Mike on my earlier patch.&lt;br/&gt;
********************************&lt;br/&gt;
The new routine you added isColumnAlwaysOrdered() is doc&apos;d as: &lt;br/&gt;
+ * Return true if the column is always ordered. That will be true if the &lt;br/&gt;
+ * column has a constant comparison predicate on it. &lt;br/&gt;
But the comment in the call to it seems to say it is expecting something different: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The current order by column does not have any constant&lt;/li&gt;
	&lt;li&gt;comparison predicate on it nor does it belong to a&lt;/li&gt;
	&lt;li&gt;single row table which means that the rows will not&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;o some lines over 80 &lt;/p&gt;

&lt;p&gt;o mostly uses brace on new line, but on the following uses brace on same line: &lt;br/&gt;
 if (moreThanOneTableInJoinOrder) { &lt;br/&gt;
********************************&lt;/p&gt;</comment>
                            <comment id="12717880" author="mamtas" created="Wed, 10 Jun 2009 02:09:07 +0100"  >&lt;p&gt;Committed the patch into trunk with revision 783168. In next couple days, will start backporting it to earlier codelines.&lt;/p&gt;</comment>
                            <comment id="12718242" author="myrna" created="Wed, 10 Jun 2009 23:53:29 +0100"  >&lt;p&gt;Looks like this caused 1 javadoc warning:&lt;br/&gt;
C:\nightlies\main\src\opensource\java\engine\org\apache\derby\iapi\sql\compile\OptimizablePredicateList.java:136: warning - @return tag has no arguments.&lt;/p&gt;</comment>
                            <comment id="12718310" author="mamtas" created="Thu, 11 Jun 2009 06:56:35 +0100"  >&lt;p&gt;Thanks for catching that, Myrna. I have fixed it with revision 783641.&lt;/p&gt;</comment>
                            <comment id="12719596" author="mamtas" created="Mon, 15 Jun 2009 16:24:17 +0100"  >&lt;p&gt;Merged changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3926&quot; title=&quot;Incorrect ORDER BY caused by index&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3926&quot;&gt;&lt;del&gt;DERBY-3926&lt;/del&gt;&lt;/a&gt; into 10.5.1.2 codeline using revision 784809&lt;/p&gt;</comment>
                            <comment id="12719921" author="mamtas" created="Tue, 16 Jun 2009 05:32:43 +0100"  >&lt;p&gt;Merged changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3926&quot; title=&quot;Incorrect ORDER BY caused by index&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3926&quot;&gt;&lt;del&gt;DERBY-3926&lt;/del&gt;&lt;/a&gt; into 10.4.2.1 codeline using revision 785073. Had to hand copy some additional methods into RuntimeStatisticsParser.java because those methods didn&apos;t exist in 10.4.2.1 codeline.&lt;/p&gt;</comment>
                            <comment id="12721244" author="kmarsden" created="Thu, 18 Jun 2009 13:59:50 +0100"  >&lt;p&gt;Hi Mamta,&lt;/p&gt;

&lt;p&gt;I can go ahead and finish backporting this change to 10.3, 10.2, and 10.1.  I am backporting &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4268&quot; title=&quot;&amp;quot;SECURITY&amp;quot; is reserved as SQL keyword.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4268&quot;&gt;&lt;del&gt;DERBY-4268&lt;/del&gt;&lt;/a&gt; and running tests anyway and so can easily run tests for the two changes together.  The two changes don&apos;t have any common files, so I will check in separately,&lt;/p&gt;</comment>
                            <comment id="12721381" author="kmarsden" created="Thu, 18 Jun 2009 18:56:57 +0100"  >&lt;p&gt;Attached is a patch for my first attempt at merging this to 10.3.  This should not be committed.&lt;/p&gt;

&lt;p&gt;  The new test is failing seeing extra columns in the query:&lt;br/&gt;
  sql1 = &quot;select c.col1, b.col1, a.col1 from a, b, c where a.col1=1 &quot;+&lt;br/&gt;
        &quot;and b.col1 = 2 and c.col1=3 order by c.col1, b.col1, a.col1&quot;;&lt;/p&gt;

&lt;p&gt;Probably one of those phantom column bugs needs to be backported too.  I&apos;ll take a look and see.  &lt;br/&gt;
) testAdditionalOrderByCases(org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance)junit.framewo&lt;br/&gt;
sertionFailedError: Unexpected column count: expected:&amp;lt;3&amp;gt; but was:&amp;lt;5&amp;gt;&lt;br/&gt;
       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:750)&lt;br/&gt;
       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:700)&lt;br/&gt;
       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:658)&lt;br/&gt;
       at org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance.testAdditionalOrderByCases(Order&lt;br/&gt;
SortAvoidance.java:10102)&lt;br/&gt;
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:45)&lt;br/&gt;
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
       at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:89)&lt;br/&gt;
       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
       at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
       at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
) testAdditionalOrderByCases(org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance)junit.framewo&lt;br/&gt;
sertionFailedError: Unexpected column count: expected:&amp;lt;3&amp;gt; but was:&amp;lt;5&amp;gt;&lt;br/&gt;
       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:750)&lt;br/&gt;
       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:700)&lt;br/&gt;
       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:658)&lt;br/&gt;
       at org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance.testAdditionalOrderByCases(Order&lt;br/&gt;
SortAvoidance.java:10102)&lt;br/&gt;
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:45)&lt;br/&gt;
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)&lt;br/&gt;
       at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:89)&lt;br/&gt;
       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
       at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
       at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;br/&gt;
       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
       at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)&lt;br/&gt;
       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)&lt;br/&gt;
       at junit.extensions.TestSetup.run(TestSetup.java:23)&lt;br/&gt;
       at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)&lt;/p&gt;

&lt;p&gt;AILURES!!!&lt;br/&gt;
ests run: 10,  Failures: 2,  Errors: 0&lt;/p&gt;</comment>
                            <comment id="12721390" author="kmarsden" created="Thu, 18 Jun 2009 19:10:30 +0100"  >&lt;p&gt;The test case for this issue requires that &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3997&quot; title=&quot;ORDER BY causes column to be returned&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3997&quot;&gt;&lt;del&gt;DERBY-3997&lt;/del&gt;&lt;/a&gt; be backported as well.&lt;/p&gt;</comment>
                            <comment id="12723099" author="kmarsden" created="Tue, 23 Jun 2009 15:51:23 +0100"  >&lt;p&gt;Merging the change to 10.1, I see a diff in wisconsin. The main thing is that it is not using optimizer directives because they do not exist in 10.1 I think. I confirmed that the original repro works on the patched 10.1 and plan to update the wisconsin master, but would appreciate if someone could take a look and make sure the 10.1 output looks ok. Attached is the test output (wisconsin_10.1_result.zip)&lt;/p&gt;</comment>
                            <comment id="12723318" author="mamtas" created="Tue, 23 Jun 2009 22:43:52 +0100"  >&lt;p&gt;Kathey, I looked through the diff and like you said, it may have to do with no way of using optimizer overrides to have the optimizer use the specific join order. One other thing that can be done(though not necessary) is to run it on other codelines without optimizer overrides to see if we similar diff there.&lt;/p&gt;</comment>
                            <comment id="12723320" author="mamtas" created="Tue, 23 Jun 2009 22:45:11 +0100"  >&lt;p&gt;BTW, Kathey, thanks for taking care of backporting the changes for this jira entry while my hard drive died.&lt;/p&gt;</comment>
                            <comment id="12726926" author="kristwaa" created="Fri, 3 Jul 2009 12:57:22 +0100"  >&lt;p&gt;Triaged July 3, 2009: Assigned normal urgency, replaced 11.0 with 10.6 in Fix versions.&lt;/p&gt;</comment>
                            <comment id="12738087" author="kmarsden" created="Sun, 2 Aug 2009 16:14:39 +0100"  >&lt;p&gt;I neglected to resolve this issue after backporting it to 10.1. Resolving it now. Note: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4331&quot; title=&quot;Join returns results in wrong order&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4331&quot;&gt;&lt;del&gt;DERBY-4331&lt;/del&gt;&lt;/a&gt; has been identified as a regression from this change.&lt;/p&gt;
</comment>
                            <comment id="12738391" author="rhillegas" created="Mon, 3 Aug 2009 16:33:08 +0100"  >&lt;p&gt;I am re-opening this issue. Based on the discussion around &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4331&quot; title=&quot;Join returns results in wrong order&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4331&quot;&gt;&lt;del&gt;DERBY-4331&lt;/del&gt;&lt;/a&gt; it appears that this issue may have not been fixed. It seems that the ordering problem may simply have been moved from one family of queries to another.&lt;/p&gt;</comment>
                            <comment id="12742433" author="mikem" created="Wed, 12 Aug 2009 17:23:08 +0100"  >&lt;p&gt;regressions introduced by this fix have been resolved by checkins tracked under &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4311&quot; title=&quot;BaseJDBCTestCase.assertErrorCode() never fails&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4311&quot;&gt;&lt;del&gt;DERBY-4311&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12425987">DERBY-4240</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12431975">DERBY-4331</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12640488">DERBY-6148</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12417446">DERBY-4105</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12411288">DERBY-3997</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12407795" name="DERBY3926_notforcheckin_patch1_051109_diff.txt" size="8448" author="mamtas" created="Mon, 11 May 2009 18:25:32 +0100"/>
                            <attachment id="12407796" name="DERBY3926_notforcheckin_patch1_051109_stat.txt" size="747" author="mamtas" created="Mon, 11 May 2009 18:25:32 +0100"/>
                            <attachment id="12407816" name="DERBY3926_notforcheckin_patch2_051109_diff.txt" size="9683" author="mamtas" created="Mon, 11 May 2009 21:51:40 +0100"/>
                            <attachment id="12408262" name="DERBY3926_patch3_051509_diff.txt" size="7771" author="mamtas" created="Fri, 15 May 2009 17:36:31 +0100"/>
                            <attachment id="12408263" name="DERBY3926_patch3_051509_stat.txt" size="322" author="mamtas" created="Fri, 15 May 2009 17:36:31 +0100"/>
                            <attachment id="12408558" name="DERBY3926_patch4_051519_diff.txt" size="11917" author="mamtas" created="Wed, 20 May 2009 07:17:48 +0100"/>
                            <attachment id="12408559" name="DERBY3926_patch4_051519_stat.txt" size="322" author="mamtas" created="Wed, 20 May 2009 07:17:48 +0100"/>
                            <attachment id="12409186" name="DERBY3926_patch5_052709_diff.txt" size="15325" author="mamtas" created="Wed, 27 May 2009 17:58:38 +0100"/>
                            <attachment id="12409187" name="DERBY3926_patch5_052709_stat.txt" size="468" author="mamtas" created="Wed, 27 May 2009 17:58:38 +0100"/>
                            <attachment id="12409853" name="DERBY3926_patch6_060309_diff.txt" size="55543" author="mamtas" created="Thu, 4 Jun 2009 07:26:45 +0100"/>
                            <attachment id="12409854" name="DERBY3926_patch6_060309_stat.txt" size="945" author="mamtas" created="Thu, 4 Jun 2009 07:26:45 +0100"/>
                            <attachment id="12407375" name="d3926_repro.sql" size="617" author="army" created="Wed, 6 May 2009 17:28:30 +0100"/>
                            <attachment id="12411115" name="derby-3926_10.3_mergeattempt.txt" size="54023" author="kmarsden" created="Thu, 18 Jun 2009 18:56:57 +0100"/>
                            <attachment id="12392976" name="derby-reproduce.zip" size="14933" author="tjoris" created="Wed, 29 Oct 2008 08:58:10 +0000"/>
                            <attachment id="12406701" name="script3.sql" size="401625" author="mamtas" created="Tue, 28 Apr 2009 22:49:46 +0100"/>
                            <attachment id="12406808" name="script3WithUserFriendlyIndexNames.sql" size="401713" author="mamtas" created="Wed, 29 Apr 2009 19:12:09 +0100"/>
                            <attachment id="12406494" name="test-script.zip" size="13721" author="tjoris" created="Mon, 27 Apr 2009 08:22:46 +0100"/>
                            <attachment id="12411542" name="wisconsin_10.1_result.zip" size="152331" author="kmarsden" created="Tue, 23 Jun 2009 15:51:23 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>18.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 20 Dec 2008 01:03:32 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23922</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ptj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38001</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>