<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:40:33 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1326/DERBY-1326.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1326] Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1326</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;This issue was found when working on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1219&quot; title=&quot;jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1219&quot;&gt;&lt;del&gt;DERBY-1219&lt;/del&gt;&lt;/a&gt;. More details can be found in the comments at &lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1219&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1219&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12340130">DERBY-1326</key>
            <summary>Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="deepa">Deepa Remesh</reporter>
                        <labels>
                    </labels>
                <created>Tue, 16 May 2006 01:27:56 +0100</created>
                <updated>Mon, 25 Sep 2006 15:54:54 +0100</updated>
                            <resolved>Mon, 25 Sep 2006 10:14:24 +0100</resolved>
                                                    <fixVersion>10.2.1.6</fixVersion>
                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>Network Server</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12402448" author="deepa" created="Tue, 16 May 2006 06:48:09 +0100"  >&lt;p&gt;To repro this issue, run the test jdbcapi/checkDataSource.java with client framework. The test will hang intermittently. &lt;/p&gt;

&lt;p&gt;To avoid this hang, the code for system shutdown is currently not executed when running with client driver. This condition has to be removed when this issue is resolved.&lt;/p&gt;</comment>
                            <comment id="12412579" author="bryanpendleton" created="Sat, 20 May 2006 03:15:00 +0100"  >&lt;p&gt;I am interested in working on this problem. I have some thoughts and ideas which I will try to develop on the wiki and on the mailing list. As the discussion evolves, hopefully the proper solution will become clear.&lt;/p&gt;</comment>
                            <comment id="12412653" author="bryanpendleton" created="Sun, 21 May 2006 07:48:17 +0100"  >&lt;p&gt;I&apos;ve placed some background notes at &lt;a href=&quot;http://wiki.apache.org/db-derby/NetworkServerSessionManagement&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/NetworkServerSessionManagement&lt;/a&gt;. I&apos;d like to get some review and checking of this background material before moving on to the next step. Thanks!&lt;/p&gt;</comment>
                            <comment id="12412804" author="deepa" created="Tue, 23 May 2006 01:18:49 +0100"  >&lt;p&gt;Bryan, I took a quick look at excellent Wiki page you created about network server session management. I have one minor comment. In the sections for Session lifetime, it may be good to note that these are also ended when the network server restarts (when Derby system is shutdown) or shuts down. For DRDAConnThread lifetime, it would be good to mention about network server restart as this seems to be the cause of the bugs we are seeing.&lt;/p&gt;

&lt;p&gt;I am also attaching a smaller repro &apos;repro1326.java&apos; I had created to simulate the hang. With this repro too, the hang is intermittent. I have not been able to get a predictable hang so far. To run the repro, start network server on port 1527 and run &apos;java -Dframework=DerbyNetClient repro1326&apos;. &lt;/p&gt;</comment>
                            <comment id="12413203" author="bryanpendleton" created="Thu, 25 May 2006 10:14:05 +0100"  >&lt;p&gt;I&apos;ve been experimenting with the attached patch &quot;sessionMgmt1.diff&quot;. In my environment, it resolves the hang in checkDataSource, and it also passes Deepa&apos;s custom &quot;repro1326&quot; test, even after I modified that test to run the shutdown test case 200 times. So I&apos;m starting to feel it&apos;s pretty reliable as far as avoiding hangs.&lt;/p&gt;

&lt;p&gt;However, I&apos;m not completely happy with it. One issue is that I&apos;m still seeing situations in which a closed() DRDAConnThread is given a non-closed Session to run, which I think is incorrect behavior (non-closed sessions should only be assigned to non-closed threads).&lt;/p&gt;

&lt;p&gt;So I&apos;ve still got a ways to go on this problem. But since I&apos;ve had some significant progress, I wanted to post the work-in-progress changes in order to get feedback, and in order not to lose them.&lt;/p&gt;

&lt;p&gt;Comments and suggestions most welcome!&lt;/p&gt;</comment>
                            <comment id="12413319" author="deepa" created="Fri, 26 May 2006 07:51:50 +0100"  >&lt;p&gt;Bryan, I applied the patch and ran the repro. I do not get the hang but seeing this exception instead of the usual shutdown exception after a system shutdown:&lt;/p&gt;

&lt;p&gt;EXPECTED EXCEPTION: Insufficient data while reading from the network - expected a minimum of 6 bytes and received only -1 bytes.  The connection has been terminated.&lt;/p&gt;

&lt;p&gt;instead of&lt;/p&gt;

&lt;p&gt;EXPECTED EXCEPTION: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ015, SQLERRMC: Derby system shutdown.&lt;/p&gt;

&lt;p&gt;I am still looking at the changes but wanted to check if you get the same results with the patch ?&lt;/p&gt;</comment>
                            <comment id="12413488" author="bryanpendleton" created="Fri, 26 May 2006 23:46:06 +0100"  >&lt;p&gt;Hi Deepa, thanks very much for looking at the patch!&lt;/p&gt;

&lt;p&gt;The new message that you see is definitely  a result of this patch; I see it as well, &lt;br/&gt;
and should have mentioned it when I attached the patch. &lt;/p&gt;

&lt;p&gt;I believe that the new symptom is a result of the code I added to DRDAConnThread&apos;s&lt;br/&gt;
run() method, to try to handle the case when a thread returns from getNextSession() to&lt;br/&gt;
find itself in the interesting situation of having been given a Session to run, but also having&lt;br/&gt;
been closed():&lt;/p&gt;

&lt;p&gt;                if (closed())&lt;br/&gt;
+        {&lt;br/&gt;
+            // FIXME &amp;#8211; I think that if we return from&lt;br/&gt;
+            // getNextSession() with a non-null Session, but&lt;br/&gt;
+            // we ourselves have been closed(), this indicates&lt;br/&gt;
+            // a bug in the Network Server session management,&lt;br/&gt;
+            // as it shouldn&apos;t have assigned a valid session&lt;br/&gt;
+            // to a closed thread. Closing the session here&lt;br/&gt;
+            // is rude, but at least it prevents a hard hang. (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1326&quot; title=&quot;Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1326&quot;&gt;&lt;del&gt;DERBY-1326&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
+            try &lt;/p&gt;
{
+                if (session != null)
+                    session.close();
+            }
&lt;p&gt;catch (Exception e) &lt;/p&gt;
{ e.printStackTrace(); }
&lt;p&gt;                    break;&lt;br/&gt;
+        }&lt;/p&gt;

&lt;p&gt;It&apos;s clear that this code is wrong, as evidenced by the symptoms you see.&lt;/p&gt;

&lt;p&gt;Note also that in my code I didn&apos;t know what to do if I hit an exception; this is&lt;br/&gt;
very closely related to bug &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1020&quot; title=&quot;Network Server treats errors on cleanup of connections as an unexpected error after intentional shutdown of the database/server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1020&quot;&gt;DERBY-1020&lt;/a&gt; (thanks Kathey for pointing this out).&lt;/p&gt;

&lt;p&gt;The question I have is (and this is the main question left in this bug, I think):&lt;/p&gt;

&lt;p&gt;  what should the DRDAConnThread do in this situation?&lt;/p&gt;

&lt;p&gt;The possibilities I&apos;ve thought of include:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ignore that fact that we&apos;ve been closed; re-open ourselves and handle&lt;br/&gt;
   the Session we&apos;ve been given&lt;/li&gt;
	&lt;li&gt;give the Session back to the NetworkServerControlImpl and ask it to&lt;br/&gt;
   assign a different thread to this task&lt;/li&gt;
	&lt;li&gt;hard-close the Session, then exit the thread. This was the solution I tried,&lt;br/&gt;
   and as you can see it has some awkard side-effects.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Either of the first two seems like it might be a reasonable approach in the&lt;br/&gt;
case where the Network Server was restarted, not shut down, but they both&lt;br/&gt;
seem wrong in the case where the Network Server was shut down; in that&lt;br/&gt;
case it seems that the Session is doomed and we should just pack our&lt;br/&gt;
bags and leave quietly.&lt;/p&gt;

&lt;p&gt;Please let me know what you think about how best to handle this case.&lt;/p&gt;</comment>
                            <comment id="12413495" author="deepa" created="Sat, 27 May 2006 00:55:50 +0100"  >&lt;p&gt;Hi Bryan,&lt;/p&gt;

&lt;p&gt;I saw your question and suggestions in the previous comment while I was working on this new combined patch. So this comment may sound off-base but I am just posting my thoughts. &lt;/p&gt;

&lt;p&gt;I was experimenting a bit with your patch and I think it is not the code that you added in DRDAConnThread.run method which makes this new exception appear intstead of the old one. Reason I say this is I modified your patch trying to see how we can avoid the closed_thread_getting_valid_session scenario. In this patch, I removed the code you commented with //FIXME in DRDAConnThread.run. Even after that, I see the same exception instead of the usual shutdown exception. However, I have not figured out what is causing this new exception.&lt;/p&gt;

&lt;p&gt;In the attached trial patch &apos;sessionMgmt1_and_nosessionsforclosedthreads.diff&apos;, I combined your patches &apos;sessionMgmt1.diff&apos; and &apos;no-sessions-for-closed-threads.diff&apos;. To me, it looked like &apos;sessionMgmt1.diff&apos; solves all problems which we found except for closed_thread_getting_valid_session scenario. This scenario seems to be solved by your previous patch &apos;no-sessions-for-closed-threads.diff&apos;. The problem which we found previously with &apos;no-sessions-for-closed-threads.diff&apos; was that the &quot;createSession&quot; was thinking there are freeThreads (freeThreads !=0 ). But actually the threads it were thinking as available were already closed. For the combined patch to work, freeThreads must become 0 after a restart. This is to ensure that a new thread is created when a  new session comes in after a restart. I think the interrupt calls and the added synchronization assure that freeThreads will become 0 before we start accepting new sessions. Does this sound right?&lt;/p&gt;

&lt;p&gt;I have run the repro multiple times with this patch and did not see the hang.  If you think this patch makes sense, can you please try it on the machine where you can repro the hang easily to see if solves the hang? Thanks.&lt;/p&gt;

&lt;p&gt;I will think more about your question and suggestions in the previous comment as I am planning to look at &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-803&quot; title=&quot;derbynet/DerbyNetAutoStart.java test fails intermittently with org.apache.derby.iapi.services.context.ShutdownException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-803&quot;&gt;&lt;del&gt;DERBY-803&lt;/del&gt;&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1020&quot; title=&quot;Network Server treats errors on cleanup of connections as an unexpected error after intentional shutdown of the database/server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1020&quot;&gt;DERBY-1020&lt;/a&gt; later today.&lt;/p&gt;</comment>
                            <comment id="12414193" author="bryanpendleton" created="Thu, 1 Jun 2006 10:52:41 +0100"  >&lt;p&gt;I think that the cause of the new &quot;Insufficient data&quot; exception that is appearing with sessionMgmt1.diff&lt;br/&gt;
has to do with a specific part of the change to the NetworkServerControlImpl restart processing.&lt;/p&gt;

&lt;p&gt;I changed the restart processing so that, instead of just closing the Session objects on the RunQueue,&lt;br/&gt;
the restart code closes &lt;b&gt;all&lt;/b&gt; the Session objects in the sessionTable. In general, I think that this is&lt;br/&gt;
the right thing to do, as restart processing needs to close all the sessions, not just those that are&lt;br/&gt;
currently waiting for a free thread.&lt;/p&gt;

&lt;p&gt;However, the new code is too powerful, because it also closes the current Session, which is the&lt;br/&gt;
session which is performing the shutdown.&lt;/p&gt;

&lt;p&gt;Closing the current Session terminates it before it has a chance to format and return the Shutdown Exception&lt;br/&gt;
message back to the client. When the client doesn&apos;t get the expected Shutdown Exception, it reports&lt;br/&gt;
this as &quot;Insufficient data&quot;.&lt;/p&gt;

&lt;p&gt;If I tweak the patch so that the restart logic is changed back to just closing the Sessions on the RunQueue,&lt;br/&gt;
the nasty &quot;Insufficient data&quot; exception disappears, and the client gets a much more reasonable message:&lt;/p&gt;

&lt;p&gt;  ERROR XJ015: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ015, SQLERRMC: Derby system shutdown.&lt;/p&gt;

&lt;p&gt;So I think that the patch should be slightly modified, so that this critical loop in the restart processing&lt;br/&gt;
gets implemented as:&lt;/p&gt;

&lt;p&gt;  &quot;For each Session in the sessionTable, &lt;b&gt;except for the Session performing the shutdown&lt;/b&gt;, close it&quot;&lt;/p&gt;

&lt;p&gt;But I&apos;m not quite sure how to code that &quot;except&quot; clause.&lt;/p&gt;</comment>
                            <comment id="12414198" author="bryanpendleton" created="Thu, 1 Jun 2006 11:33:41 +0100"  >&lt;p&gt;Deepa, I was experimenting with your &quot;sessionMgmt1_and_nosessionsforclosedthreads.diff&quot; patch.&lt;/p&gt;

&lt;p&gt;I definitely cannot reproduce any hang with this diff; the only problem I can reproduce is the&lt;br/&gt;
&quot;Insufficient Data&quot; exception which I discussed in the previous comment above&lt;br/&gt;
(&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1326#action_12414193&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1326#action_12414193&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;However, I am concerned about a comment you made several weeks back, when we&lt;br/&gt;
were first discussing this problem in the context of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1219&quot; title=&quot;jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1219&quot;&gt;&lt;del&gt;DERBY-1219&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1219#action_12378954&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1219#action_12378954&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I think that your comment is still quite valid, and I am wondering how you think we should address it?&lt;/p&gt;</comment>
                            <comment id="12414236" author="deepa" created="Thu, 1 Jun 2006 21:57:04 +0100"  >&lt;p&gt;Bryan,&lt;br/&gt;
Combined with your code changes in &quot;sessionMgmt1.diff &apos;, I think my previous comment about &apos;no-sessions-for-closed-threads.diff&apos; does not hold good. This is the reason I think the combined patch is okay:&lt;br/&gt;
&quot;&lt;br/&gt;
The problem which we found previously with &apos;no-sessions-for-closed-threads.diff&apos; was that the &quot;createSession&quot; was thinking there are freeThreads (freeThreads !=0 ). But actually the threads it were thinking as available were already closed. For the combined patch to work, freeThreads must become 0 after a restart. This is to ensure that a new thread is created when a new session comes in after a restart. I think the interrupt calls and the added synchronization assure that freeThreads will become 0 before we start accepting new sessions.&lt;br/&gt;
&quot;&lt;/p&gt;

&lt;p&gt;To rephrase it,&lt;/p&gt;

&lt;p&gt;1) With only &apos;no-sessions-for-closed-threads.diff&apos;, we can get to the following scenario: When client starts a new session, the &quot;createSession&quot; logic in the server will check if freeThreads are available. Because of the restart, the freeThreads counter may be invalid (freeThreads !=0). This makes the &quot;createSession&quot; logic to think there are some free threads available. Hence, it will not create a new thread for the incoming session. Instead, the incoming session is put on the runQueue. However, all the existing threads were marked closed by the restart. And we do not give sessions to closed threads. So this session keeps waiting for a thread. When we start another session (e.g with ij), the hang goes away. When the connection from ij comes in, the newly created thread is able to work on the waiting session and resolve the hang. I think the patch does the right thing by not giving sessions to closed threads. However, it can sometimes cause the case of stranded sessions because of incorrect value of freeThreads counter in &quot;createSession&quot; logic.&lt;/p&gt;

&lt;p&gt;2) With the combined patch &quot;sessionMgmt1_and_nosessionsforclosedthreads.diff&quot;, I think we can assume freeThreads counter will have the correct value when a new session comes in after a restart. The interrupt calls and the added synchronization assure that freeThreads will become 0 before we start accepting new sessions. If this assumption is correct, then we will not have the case of stranded sessions mentioned in 1) above.&lt;/p&gt;</comment>
                            <comment id="12414497" author="bryanpendleton" created="Sat, 3 Jun 2006 02:54:27 +0100"  >&lt;p&gt;Hi Deepa, thank you for the excellent analysis. It is very helpful.&lt;/p&gt;

&lt;p&gt;The only part that troubles me is this:&lt;/p&gt;

&lt;p&gt;&amp;gt; The interrupt calls and the added synchronization assure that freeThreads will &lt;br/&gt;
&amp;gt; become 0 before we start accepting new sessions&lt;/p&gt;

&lt;p&gt;I am not yet able to see why that is necessarily true.&lt;/p&gt;

&lt;p&gt;I agree that we issue the interrupt() calls prior to completing the restart and prior&lt;br/&gt;
to accepting new sessions.&lt;/p&gt;

&lt;p&gt;However, the thread which is interrupted responds to this interrupt asynchronously.&lt;/p&gt;

&lt;p&gt;I believe that the only guarantee made by Java is that the thread which we are interrupting&lt;br/&gt;
will receive that interrupt some time in the future, but not necessarily immediately,&lt;br/&gt;
and not necessarily before we reach the end of the startNetworkServer() method&lt;br/&gt;
and declare the restart complete.&lt;/p&gt;

&lt;p&gt;In practice, given that the startNetworkServer() method is going to unload the &lt;br/&gt;
embedded engine, call System.gc(), and then reload the embedded engine,&lt;br/&gt;
that&apos;s probably enough work so that we have a very good chance that all the&lt;br/&gt;
old threads have received and responded to their interrupt() before we complete.&lt;/p&gt;

&lt;p&gt;But I don&apos;t think it&apos;s actually &lt;b&gt;guaranteed&lt;/b&gt; by the current changes in the combined patch.&lt;/p&gt;

&lt;p&gt;I may be being too picky here. What do you think?&lt;/p&gt;</comment>
                            <comment id="12414508" author="deepa" created="Sat, 3 Jun 2006 03:46:52 +0100"  >&lt;p&gt;Hi Bryan, I don&apos;t think you are being picky. After reading your explanation, I agree the combined patch still has some chance of causing a hang. As you explain, the following need not be always true: &quot;The interrupt calls and the added synchronization assure that freeThreads will become 0 before we start accepting new sessions &quot;. So the assumption that we will have the right value for freeThreads (=0) when a new session comes in after a restart does not hold good. &lt;/p&gt;

&lt;p&gt;Keeping the code to reset &quot;freeThreads = 0&quot; during restart seems to be an option. But that will cause the problem that you describe under &quot;freeThreads counter maintenance&quot; in &lt;a href=&quot;http://wiki.apache.org/db-derby/NetworkServerSessionManagement&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/db-derby/NetworkServerSessionManagement&lt;/a&gt;. The counter can become negative. &lt;/p&gt;

&lt;p&gt;If we plan to use this patch, we need to find out some way to ensure freeThreads counter is maintained correctly. &lt;/p&gt;








</comment>
                            <comment id="12414585" author="bryanpendleton" created="Sat, 3 Jun 2006 23:19:51 +0100"  >&lt;p&gt;I had an idea about how to address the &quot;failure to create a new thread&quot; aspect&lt;br/&gt;
of the hang, as follows:&lt;/p&gt;

&lt;p&gt;Suppose that, at the end of restart processing, we go ahead and create a new&lt;br/&gt;
DRDAConnThread instance, even though at this instance there may not be&lt;br/&gt;
any sessions for it to process yet. If not, it will just go into getNextSession and wait.&lt;/p&gt;

&lt;p&gt;With the current combined patch, during restart processing, we &quot;poison&quot; each&lt;br/&gt;
of the DRDAConnThread instances by closing and interrupting them, so that&lt;br/&gt;
we know that at some point those threads will die.&lt;/p&gt;

&lt;p&gt;The problem that we had was that if a new session came in while all those&lt;br/&gt;
poisoned threads were still in the process of dieing, then the create-new-session&lt;br/&gt;
logic might not realize that it needed to create a new thread because it might&lt;br/&gt;
mistakenly see a non-zero freeThreads count which was counting only poisoned&lt;br/&gt;
threads.&lt;/p&gt;

&lt;p&gt;But if we always create at least one new thread, then we know that the new&lt;br/&gt;
session will eventually get processed by that new thread.&lt;/p&gt;

&lt;p&gt;In order for this to be 100% solid I think we have to change runQueueAdd to do&lt;br/&gt;
a notifyAll(), but that&apos;s a slightly different topic, and I think I&apos;ll put that bit into&lt;br/&gt;
the Wiki page, because it should live beyond this bug.&lt;/p&gt;

&lt;p&gt;So, in conclusion, here is my latest idea:&lt;br/&gt;
1) At the end of restart processing, create a new thread even though we may not&lt;br/&gt;
have any new sessions for it to process yet.&lt;br/&gt;
2) change runQueueAdd to do a notifyAll(), not a notify().&lt;/p&gt;</comment>
                            <comment id="12414654" author="bryanpendleton" created="Mon, 5 Jun 2006 01:11:33 +0100"  >&lt;p&gt;This latest attachment, &apos;withNewThreadAndNoShutdownOfCurrentSession.diff&apos;,&lt;br/&gt;
contains the following changes relative to the previous patch proposal&lt;br/&gt;
(sessionMgmt1_and_nosessionsforclosedthreads.diff):&lt;/p&gt;

&lt;p&gt;1) runQueueAdd now calls runQueue.notifyAll() rather than runQueue.notify()&lt;br/&gt;
2) startNetworkServer now primes the thread pool by starting the first&lt;br/&gt;
DRDAConnThread right away, rather than waiting for the first Session to come&lt;br/&gt;
in. To make this work, I had to make a few small tweaks to DRDAConnThread&lt;br/&gt;
initialization so that it would defer its initialization until it had its first Session.&lt;br/&gt;
3) startNetworkServer now takes the calling Session as an argument. In the&lt;br/&gt;
initial server start case this is null, but if a restart is triggered by a shutdown&lt;br/&gt;
exception, the caller passes its Session in. startNetworkServer uses this to&lt;br/&gt;
avoid closing the Session which is triggering the restart, so it can stay open&lt;br/&gt;
long enough to return the shutdown exception back to the client.&lt;br/&gt;
4) The client-masters for checkDataSource and checkDataSource30 are&lt;br/&gt;
modified to add the shutdown exception. This modification of the master file&lt;br/&gt;
goes hand-in-hand with the modification of the test program to re-enable&lt;br/&gt;
the server shutdown/restart during the test.&lt;/p&gt;

&lt;p&gt;Please take a look at this latest proposal and let me know your comments.&lt;/p&gt;</comment>
                            <comment id="12414853" author="deepa" created="Tue, 6 Jun 2006 04:55:51 +0100"  >&lt;p&gt;I read through the changes in &apos;withNewThreadAndNoShutdownOfCurrentSession.diff&apos; patch and I think they address all the problems found in the previous comments. I could not apply the patch to my workspace. I think some intermediate check-ins changed the same file. &lt;/p&gt;
</comment>
                            <comment id="12414869" author="bryanpendleton" created="Tue, 6 Jun 2006 05:54:08 +0100"  >&lt;p&gt;Thanks for desk-checking the patch, Deepa! I updated my workspace and resolved the merge conflicts in DRDAConnThread, and am re-attaching the patch proposal as &apos;resolve_DRDAConnThread_conflict.diff&apos;. Hopefully you can now apply this patch to the head of the trunk.&lt;/p&gt;</comment>
                            <comment id="12414883" author="deepa" created="Tue, 6 Jun 2006 07:50:45 +0100"  >&lt;p&gt;I applied &apos;resolve_DRDConnThread_conflict.diff&apos; and ran the repro 50 times without any hang. This patch solves the hang mentioned in this issue. Also resolves the problems discovered while working on this issue.&lt;/p&gt;

&lt;p&gt;I have only minor comments:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Indentation seems to be out of place in NetworkServerControlImpl.java in the comment added to startNetworkServer method. Also in the changes in checkDataSource.java&lt;/li&gt;
	&lt;li&gt;It may be useful to have some more comment in startNetworkServer method as to why we interrupt the threads in addition to calling close on them.&lt;/li&gt;
&lt;/ul&gt;




</comment>
                            <comment id="12415066" author="deepa" created="Wed, 7 Jun 2006 06:59:10 +0100"  >&lt;p&gt;I am seeing a hang in the test derbynet/DerbyNetNewServer.java with &apos;resolve_DRDConnThread_conflict.diff&apos;&apos; patch. &lt;/p&gt;

&lt;p&gt;I was using the same workspace where I had applied this patch to try out some things for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-803&quot; title=&quot;derbynet/DerbyNetAutoStart.java test fails intermittently with org.apache.derby.iapi.services.context.ShutdownException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-803&quot;&gt;&lt;del&gt;DERBY-803&lt;/del&gt;&lt;/a&gt;. I started seeing a hang in derbynet/DerbyNetNewServer.java test. On looking at the .tmp file, I found that the test itself was running to the end. It looked like it was waiting for network server process to stop. I rechecked by reverting my changes, reapplying the patch and running a full build. I was still getting a hang in the test. It looks like there are additional changes in network server shutdown introduced by this patch. &lt;/p&gt;

&lt;p&gt;In an earlier mail, Bryan had mentioned that derbyall ran successfully with this patch. This could be because of &quot;timeout=60&quot; property specified in derbynetclientmats suite. To check this, I ran the test by specifying &quot;-Dtimeout=3&quot; on the command line. Then, the test process ran to the end within the timeout period and the test passed. It had this additional line on the console:&lt;br/&gt;
&quot;Server Process did not complete in time. Destroying...&quot;&lt;/p&gt;

&lt;p&gt;Bryan, if you still have the results from derbyall run with this patch, can you please check to see how long the test derbynet/DerbyNetNewServer.java took? If it took close to an hour to complete, it will confirm what I just observed. Otherwise, it may be a problem with my test environment.&lt;/p&gt;</comment>
                            <comment id="12415277" author="bryanpendleton" created="Thu, 8 Jun 2006 13:05:48 +0100"  >&lt;p&gt;Well this is very interesting! There is always something new to learn &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The test program intends to do the following:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;start up the Network Server&lt;/li&gt;
	&lt;li&gt;check that it started successfully&lt;/li&gt;
	&lt;li&gt;shut it down&lt;/li&gt;
	&lt;li&gt;start it up with a slightly different configuration&lt;/li&gt;
	&lt;li&gt;check that it started successfully&lt;/li&gt;
	&lt;li&gt;shut it down&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So we think we are starting it up twice and shutting it down twice&lt;/p&gt;

&lt;p&gt;When I investigated the hang that Deepa discovered, however, I learned that&lt;br/&gt;
in fact we are starting up the Network Server &lt;b&gt;four&lt;/b&gt; times, and shutting it down&lt;br/&gt;
twice. These extra Network Server instances didn&apos;t harm anything in the past,&lt;br/&gt;
because it was just a waste of memory to start up the extra instances.&lt;/p&gt;

&lt;p&gt;However, when I added the new thread creation code in the network server&lt;br/&gt;
startup, it meant that whenever the network server started, a DRDAConnThread&lt;br/&gt;
was also started. And if that network server wasn&apos;t shut down, then the&lt;br/&gt;
DRDAConnThread instance remained, and prevented the server from shutting&lt;br/&gt;
down, causing the hang.&lt;/p&gt;

&lt;p&gt;The reason that we are getting the extra NetworkServerControlImpl instances is very&lt;br/&gt;
simple: when you call NetworkServerControlImpl.start, it does the following:&lt;/p&gt;

&lt;p&gt;public void start(PrintWriter consoleWriter)&lt;br/&gt;
    throws Exception&lt;/p&gt;
{
    DRDAServerStarter starter = new DRDAServerStarter();
    starter.setStartInfo(hostAddress,portNumber,consoleWriter);
    startNetworkServer(null);
    starter.boot(false,null);
}

&lt;p&gt;That is, it directly starts this instance, then it spawns a background thread to&lt;br/&gt;
run the DRDAServerStarter code, which instantiates &lt;b&gt;another&lt;/b&gt; NetworkServerControlImpl&lt;/p&gt;

&lt;p&gt;My first idea was to remove the call to startNetworkServer() from this method, and just&lt;br/&gt;
let DRDAServerStarter start up the Network Server.&lt;/p&gt;

&lt;p&gt;Sure enough, this fixes the hang in DerbyNetNewServer.&lt;/p&gt;

&lt;p&gt;And, conceptually, it seems like a good change to make, because it doesn&apos;t seem&lt;br/&gt;
like we should be starting the Network Server twice.&lt;/p&gt;

&lt;p&gt;However, removing the call to startNetworkServer causes test failures in a bunch of&lt;br/&gt;
other Network Server tests, such as NSinSameJVM, dataSourcePermissions_net,&lt;br/&gt;
ownServerTests, and testSecMec.&lt;/p&gt;

&lt;p&gt;So, there&apos;s a bunch more investigation to do here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12415766" author="bryanpendleton" created="Mon, 12 Jun 2006 01:47:57 +0100"  >&lt;p&gt;Attached is &apos;unify_NSImpl_instances.diff&apos;, with these notes to explain. This&lt;br/&gt;
patch belongs with the rest of the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1326&quot; title=&quot;Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1326&quot;&gt;&lt;del&gt;DERBY-1326&lt;/del&gt;&lt;/a&gt; changes, but I&apos;ve extracted it&lt;br/&gt;
out into a standalone patch to make it easier to study and review.&lt;/p&gt;

&lt;p&gt;Recently, I&apos;ve been investigating that hang that Deepa uncovered which occurs&lt;br/&gt;
with the latest patch proposal for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1326&quot; title=&quot;Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1326&quot;&gt;&lt;del&gt;DERBY-1326&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12334997/withNewThreadAndNoShutdownOfCurrentSession.diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12334997/withNewThreadAndNoShutdownOfCurrentSession.diff&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Investigating that problem has taken me through some interesting analysis&lt;br/&gt;
of NetworkServer startup/shutdown issues, which I&apos;d like to describe here, to&lt;br/&gt;
see what sort of reaction I get from the team.&lt;/p&gt;

&lt;p&gt;There are several different ways to start up the Network Server, but after&lt;br/&gt;
some twists and turns there appear to be two essential techniques:&lt;br/&gt;
1) You can instantiate a NetworkServerControl object, and call the start()&lt;br/&gt;
   method on it.&lt;br/&gt;
2) You can define the derby.drda.startNetworkServer property to true, and then&lt;br/&gt;
   start the embedded engine.&lt;/p&gt;

&lt;p&gt;These two code paths proceed somewhat differently, but end up getting to the&lt;br/&gt;
same place:&lt;br/&gt;
1) NetworkServerControl.start() delegates to NetworkServerControlImpl.start(),&lt;br/&gt;
   which calls NetworkServerControlImpl.startNetworkServer(), then instantiates&lt;br/&gt;
   a DRDAServerStarter object and calls its boot() method.&lt;br/&gt;
2) Loading the embedded engine eventually calls JDBCBoot.boot(), which notices&lt;br/&gt;
   that derby.drda.startNetworkServer has been set, and calls&lt;br/&gt;
   Monitor.startSystemModule() to instantiate a DRDAServerStarter object and&lt;br/&gt;
   call its boot() method.&lt;/p&gt;

&lt;p&gt;The DRDAServerStarter.boot() method uses reflection to:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;dynamically load the Network Server code&lt;/li&gt;
	&lt;li&gt;create an instance of NetworkServerControlImpl&lt;/li&gt;
	&lt;li&gt;create a daemon server thread, which will then:&lt;/li&gt;
	&lt;li&gt;call NetworkServerControlImpl.blockingStart()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So whichever way that we start the Network Server, we end up constructing&lt;br/&gt;
a NetworkServerControlImpl instance and calling blockingStart() on that&lt;br/&gt;
instance from a background thread. This is good.&lt;/p&gt;

&lt;p&gt;However, there is an important and interesting difference between the two&lt;br/&gt;
startup methods:&lt;/p&gt;

&lt;p&gt;   DRDAServerStarter.boot() always creates its own instance of the&lt;br/&gt;
   NetworkServerControlImpl object and calls blockingStart() on that instance.&lt;br/&gt;
   So if you start the Network Server by instantiating a NetworkServerControl&lt;br/&gt;
   object in your own code, that NetworkServerControl instance creates a&lt;br/&gt;
   NetworkServerControlImpl instance, but then when it calls DRDAServerStarter,&lt;br/&gt;
   we end up creating a &lt;b&gt;second&lt;/b&gt; NetworkServerControlImpl instance to use as&lt;br/&gt;
   the master instance, and we never really use the NetworkServerControlImpl&lt;br/&gt;
   instance that was used by the NetworkServerControl object that you created.&lt;/p&gt;

&lt;p&gt;Worse, &lt;b&gt;both&lt;/b&gt; NetworkServerControlImpl instances are started up, in a certain&lt;br/&gt;
sense, because NetworkServerControlImpl.startNetworkServer() is called on&lt;br/&gt;
each instance:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;NetworkServerControlImpl.start() calls startNetworkServer() on itself before&lt;br/&gt;
   it instantiates the DRDAServerStarter object and calls boot()&lt;/li&gt;
	&lt;li&gt;NetworkServerControlImpl.blockingStart() calls startNetworkServer() on&lt;br/&gt;
   itself as its first action.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So if you start up the Network Server by calling NetworkServerControl.start(),&lt;br/&gt;
you end up actually creating &lt;b&gt;two&lt;/b&gt; Network Server instances, although one of&lt;br/&gt;
them doesn&apos;t really do very much. This is the source of the hang that I created&lt;br/&gt;
with the most recent patch proposal to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1326&quot; title=&quot;Network server may abandon sessions when Derby system is shutdown and this causes intermittent hangs in the client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1326&quot;&gt;&lt;del&gt;DERBY-1326&lt;/del&gt;&lt;/a&gt;: when I changed the&lt;br/&gt;
startNetworkServer() method to create a new thread, that code ends up being&lt;br/&gt;
called twice, but we don&apos;t shut down both of these instances, so we never&lt;br/&gt;
shut down the extra thread that I created, and that caused the process to&lt;br/&gt;
hang and not terminate.&lt;/p&gt;

&lt;p&gt;Clearly, one way out of this problem is to re-arrange the thread creation logic&lt;br/&gt;
so that the thread is only created when the &lt;b&gt;real&lt;/b&gt; NetworkServerControlImpl&lt;br/&gt;
instance is started.&lt;/p&gt;

&lt;p&gt;But I was curious about why there were two NetworkServerControlImpl instances,&lt;br/&gt;
since it seems quite clear to me that the NetworkServerControlImpl class is&lt;br/&gt;
designed to behave as a singleton object. I thought that if I had made this&lt;br/&gt;
assumption that there would only ever be a single instance in a Java app,&lt;br/&gt;
others might tend to make this same assumption in the future, and more bugs&lt;br/&gt;
like the one I accidentally introduced might get introduced in the future.&lt;/p&gt;

&lt;p&gt;So, for the last week or so, I&apos;ve been studying this code, trying to figure&lt;br/&gt;
out if we really need to have two NetworkServerControlImpl instances, or&lt;br/&gt;
whether it would be cleaner to just have a single instance.&lt;/p&gt;

&lt;p&gt;My conclusion is that, for the most part, we &lt;b&gt;don&apos;t&lt;/b&gt; need to have both&lt;br/&gt;
instances, and it &lt;b&gt;is&lt;/b&gt; cleaner to just have a single instance, but there&lt;br/&gt;
are a few messy details.&lt;/p&gt;

&lt;p&gt;The changes that I&apos;ve been experimenting with in this area are as follows:&lt;br/&gt;
1) Refactor the DRDAServerStarter code slightly so that the caller can&lt;br/&gt;
   optionally pass in the NetworkServerControlImpl instance to use. If the&lt;br/&gt;
   caller does not pass in an instance, DRDAServerStarter creates one via&lt;br/&gt;
   reflection, as it does now.&lt;br/&gt;
2) Simplify NetworkServerControlImpl.start() so that it no longer calls&lt;br/&gt;
   startNetworkServer() on itself, but instead simply calls DRDAServerStarter,&lt;br/&gt;
   passing the &quot;this&quot; pointer in as the instance to use for starting the server.&lt;br/&gt;
3) Modify the DRDAServerStarter boot code so that it loads the embedded&lt;br/&gt;
   engine. The current DRDAServerStarter code assumes that the embedded engine&lt;br/&gt;
   has already been started; I believe that this is the main reason for the&lt;br/&gt;
   current code&apos;s call to startNetworkServer() from NetworkServerControlImpl&apos;s&lt;br/&gt;
   start() method, as a side effect of startNetworkServer() is to load the&lt;br/&gt;
   embedded engine. It seems simple to have DRDAServerStarter load the&lt;br/&gt;
   embedded engine itself, but an alternative would be to load the embedded&lt;br/&gt;
   engine in NetworkServerControlImpl.start().&lt;/p&gt;

&lt;p&gt;With these changes in place, the Network Server startup and shutdown code&lt;br/&gt;
seems substantially cleaner to me, and the tests seem to run very well.&lt;br/&gt;
I&apos;m pleased with the results.&lt;/p&gt;

&lt;p&gt;However, there is one messy detail that remains to be resolved, and it&lt;br/&gt;
involves the Network Server shutdown processing. The shutdown() method for&lt;br/&gt;
the Network Server, in NetworkServerControlImpl.shutdown(), uses the following&lt;br/&gt;
algorithm:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;tell the server to shut down&lt;/li&gt;
	&lt;li&gt;loop for a while, ping&apos;ing the Network server, until we get an error&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Unfortunately, during this &quot;ping loop&quot;, the code wants to ensure that no&lt;br/&gt;
stray messages from the failed ping operation escape to the user, so the&lt;br/&gt;
code intentionally disables the Network Server console.&lt;/p&gt;

&lt;p&gt;When there were two NetworkServerControlImpl instances in play, intentionally&lt;br/&gt;
disabling the console of the one instance was a relatively safe thing to do.&lt;/p&gt;

&lt;p&gt;However, when there is only a single instance in the process, disabling the&lt;br/&gt;
console is a quite disruptive action, because it affects &lt;b&gt;all&lt;/b&gt; the messages&lt;br/&gt;
that the Network Server might want to print, including the &quot;normal shutdown&quot;&lt;br/&gt;
message that the Network Server prints at the conclusion of shutdown.&lt;/p&gt;

&lt;p&gt;Therefore, I&apos;m coming to believe that we shouldn&apos;t disable the console&lt;br/&gt;
during shutdown, but rather should implement a variant &quot;ping&quot; operation which&lt;br/&gt;
doesn&apos;t print any messages when it fails, but instead just throws an exception,&lt;br/&gt;
which the shutdown code could catch and handle. Unfortunately, this is not&lt;br/&gt;
a trivial one-line change, as the code which prints error messages to the&lt;br/&gt;
Network Server console is buried &lt;b&gt;deep&lt;/b&gt; in the Network Server command&lt;br/&gt;
processing code.&lt;/p&gt;

&lt;p&gt;Obviously, I&apos;ve still got more work to do here. But I&apos;m attaching the current&lt;br/&gt;
state of my changes anyway, since I think it&apos;s a useful intermediate stage&lt;br/&gt;
and would be interesting to reviewers.&lt;/p&gt;

&lt;p&gt;The other comment to be made is that this change is now becoming quite large,&lt;br/&gt;
and probably should be split into multiple smaller patches. I&apos;ll pursue that&lt;br/&gt;
strategy later, once I get to a point where I have code that seems solid.&lt;/p&gt;

&lt;p&gt;Thanks in advance for all comments, suggestions, and other feedback!&lt;/p&gt;
</comment>
                            <comment id="12415929" author="deepa" created="Tue, 13 Jun 2006 06:49:41 +0100"  >&lt;p&gt;Thanks again for posting a detailed description. I read through the description and patch &quot;unify_NSImpl_instances.diff &quot; quickly. &lt;/p&gt;

&lt;p&gt;I have few small comments/questions:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Currently, the patch does the following &quot;Modify the DRDAServerStarter boot code so that it loads the embedded engine. &quot; The description also mentions this: &quot;an alternative would be to load the embedded engine in NetworkServerControlImpl.start()&quot;. I like this alternative. I am thinking of the scenario where derby.drda.startNetowrkServer property is set and we boot embedded driver. In this scenario, if we load the embedded engine in the DRDAServerStarter boot code, it will appear that we are trying to boot the embedded driver twice. However, this will not do any harm as it will be a no-op. I think it would be better to avoid doing this as it causes confusion why we are loading the driver again when we trace the path from loading embedded engine.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;There is a slightly different code path when we start network server from the command line. In this case, we create an instance of NetworkServerControlImpl and then call executeWork which processes the &quot;start&quot; command by calling blockingStart(). There is no DRDAServerStarter involved here as we do not need to launch another thread. This is not very relevant for the current patch but just mentioning it in case we plan to re-organize the code.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It looks like the only purpose of calling DRDAServerStarter in NetworkServerControlImpl.start method is to launch a separate thread. The javadoc comment for NetworkServerControlImpl.start says:&lt;br/&gt;
	/**&lt;/li&gt;
	&lt;li&gt;Start a network server.  Launches a separate thread with&lt;/li&gt;
	&lt;li&gt;DRDAServerStarter.  Want to use Monitor.startModule,&lt;/li&gt;
	&lt;li&gt;so it can all get shutdown when cloudscape shuts down, but&lt;/li&gt;
	&lt;li&gt;can&apos;t get it working right now.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;From  current behaviour, we do not shutdown network server when we shutdown Derby. Does anyone know if there is any plan to do as indicated by the comment: &quot;Want to use Monitor.startModule, so it can all get shutdown when cloudscape shuts down, but can&apos;t get it working right now.&quot; ? &lt;/p&gt;</comment>
                            <comment id="12416494" author="johnemb" created="Fri, 16 Jun 2006 21:48:48 +0100"  >&lt;p&gt;&amp;gt; Deepa Remesh commented:&lt;br/&gt;
&amp;gt; -----------------------&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;snip&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; From  current behaviour, we do not shutdown network server when we shutdown Derby. Does anyone know if there is any plan to do as indicated by the comment: &quot;Want to use Monitor.startModule, so it can all get shutdown when cloudscape shuts down, but can&apos;t get it working right now.&quot; ? &lt;/p&gt;


&lt;p&gt;Speaking of current behaviour, here are some observations I have made recently:&lt;/p&gt;

&lt;p&gt;a) In the &quot;embedded server using properties&quot; scenario, the Network Server starts when the embedded driver is loaded and stops when it is &quot;unloaded&quot;, i.e. when the Derby system is shut down: DriverManager.getConnection(&quot;jdbc:derby:;shutdown=true&quot;);&lt;/p&gt;

&lt;p&gt;b) In the &quot;embedded server using NetworkServerControl API&quot; scenario, the Network server of course starts when NetworkServerControl.start() is called, and stops when shutdown() is called. However, if the Derby system is shut down (by loading the embedded driver and doing as shown above), clients can no longer connect (getting &quot;No suitable driver&quot;. Why?). The Network Server port seems to be listening on the same port still, though, according to netstat. Then, if I try to restart the server using the API (without calling shutdown() first), I get the message &quot;Could not listen on port 1527 on host 0.0.0.0.&quot;. This makes sense, since the port is already in use. However, after start() is called the second time, clients &lt;em&gt;are&lt;/em&gt; in fact able to connect. There seems to be something happening when start() is called, even if the port is busy, that is needed to make the server able to accept connections again.&lt;/p&gt;

&lt;p&gt;I have not done any code inspection in these cases, so I don&apos;t know if this is very helpful with regards to this Jira issue. I just reacted when I saw the above comment.&lt;/p&gt;</comment>
                            <comment id="12419031" author="bryanpendleton" created="Tue, 4 Jul 2006 07:35:02 +0100"  >&lt;p&gt;I want to thank all the reviewers for their helpful feedback! Those are very good suggestions.&lt;/p&gt;

&lt;p&gt;I am hoping to return to this bug and continue working on it, incorporating the various ideas.&lt;/p&gt;

&lt;p&gt;I was dismayed by how hard it seemed it was going to be to make a variation of the Network Server &quot;ping&quot; API which was silent.&lt;/p&gt;</comment>
                            <comment id="12432883" author="bryanpendleton" created="Wed, 6 Sep 2006 16:58:59 +0100"  >&lt;p&gt;I&apos;m not actively working on this. I hope to return to it in the future, but if somebody else has time in the meantime, please feel free to explore this issue.&lt;/p&gt;</comment>
                            <comment id="12434123" author="knutanders" created="Tue, 12 Sep 2006 12:27:45 +0100"  >&lt;p&gt;Attaching a repro (Restart.java) which always causes a hang in my environment. What it does is:&lt;/p&gt;

&lt;p&gt;  1) Open 20 connections to the server.&lt;br/&gt;
  2) Close all connections.&lt;br/&gt;
  3) Shut down the engine (will make the server restart).&lt;br/&gt;
  4) Open and close a connection 20 times (usually hangs on the second connection).&lt;/p&gt;

&lt;p&gt;After (3), the server has 20 threads sleeping in runQueue.wait(). All of these are closed, but when they start waking up in (4), they don&apos;t notice that they have been closed until they have picked up a session from the run queue. That session will be abandoned, and the client hangs.&lt;/p&gt;</comment>
                            <comment id="12434209" author="bryanpendleton" created="Tue, 12 Sep 2006 17:36:37 +0100"  >&lt;p&gt;Restart.java reliably reproduces the hang in my environment as well. Very nice.&lt;/p&gt;</comment>
                            <comment id="12434296" author="knutanders" created="Tue, 12 Sep 2006 23:19:46 +0100"  >&lt;p&gt;It is not clear to me why an engine shutdown should close down all DRDAConnThreads. I kind of understand why the sessions are closed (although that would happen implicitly anyway) since their embedded connections are closed as part of the engine shutdown. The DRDAConnThreads are however merely worker threads which don&apos;t have any dependencies on the engine instance that was active when they were created, so there is no reason why they can&apos;t be reused after the restart of the engine. Does anyone see problems with reusing the threads? In my opinion, it would be easier to ensure a consistent state after a restart if the threads were kept.&lt;/p&gt;</comment>
                            <comment id="12434299" author="bryanpendleton" created="Tue, 12 Sep 2006 23:35:00 +0100"  >&lt;p&gt;&amp;gt; Does anyone see problems with reusing the threads?&lt;/p&gt;

&lt;p&gt;Deepa and I discussed this a fair amount in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1219&quot; title=&quot;jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1219&quot;&gt;&lt;del&gt;DERBY-1219&lt;/del&gt;&lt;/a&gt;; you should&lt;br/&gt;
probably review that discussion to see if there&apos;s more you can learn from it.&lt;br/&gt;
In particular, the discussion regarding &quot;skipThreads.diff&quot; at:&lt;br/&gt;
&lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1219#action_12378300&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1219#action_12378300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If we didn&apos;t close down the threads, would we do anything to notify them of&lt;br/&gt;
the shutdown? Were you proposing to leave them alone entirely? Or were&lt;br/&gt;
you proposing to notify them of the shutdown, but not require the threads to exit?&lt;/p&gt;

&lt;p&gt;Are you sure a DRDAConnThread doesn&apos;t have dependencies on the engine&lt;br/&gt;
instance? The thread has a pointer to a session, and a session seems like&lt;br/&gt;
it could point to database objects (like Connection objects, e.g.)&lt;/p&gt;</comment>
                            <comment id="12434306" author="forsini" created="Tue, 12 Sep 2006 23:51:50 +0100"  >&lt;p&gt;Well, we do connect to the Derby engine instance from the network server layer so if the embedded Derby engine goes down, we would have to reinstantiate the database connections (logic is not there right now if am not mistaken), which means some state(s) have to be kept around and some logic has to be added. But then, how do you handle incoming request from the client(s), especially if it takes some time to recover the database(s)...What is there is a corruption and some database cannot be recovered? What if after a reboot of the engine some derby properties have affected the behavior and configuration of the recovered databases - For instance, some database properties are static, so they won&apos;t be taken into account until the next reboot, which can also mean that a client (user) would no longer be allowed to authenticate if the authentication provider was changed before the next reboot - This is true for Strong Password Substitute which only works with BUILT-IN or NONE authentication providers right now...Hence in this last case, a security mechanism negotiation needs to happen between the client and the network server...Another case if that if you enable authentication at the engine level but derby instance has not rebooted yet, you will then not be able to re-authenticate based on the cached database info per DRDA session - Simply because a password may not be cached at all since there was no authentication required beforehand and now there is because the static property got picked-up by the database in question at the next engine/database reboot...The connection with the database would not work and the client would probably get confused with some authentication exception where he/she was already authenticated before the Derby engine got shutdown...&lt;/p&gt;

&lt;p&gt;Were you actually implying some auto database reconnect of the current DRDA threads created in the network server once the Derby engine or/and databases are brought back up?&lt;/p&gt;</comment>
                            <comment id="12434398" author="knutanders" created="Wed, 13 Sep 2006 11:13:13 +0100"  >&lt;p&gt;Francois wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Were you actually implying some auto database reconnect of the&lt;br/&gt;
&amp;gt; current DRDA threads created in the network server once the Derby&lt;br/&gt;
&amp;gt; engine or/and databases are brought back up?&lt;/p&gt;

&lt;p&gt;Yes, when the server detects that one of the clients has shut down the&lt;br/&gt;
engine (it checks the SQLSTATE of exceptions before sending them to&lt;br/&gt;
the client), it (a) closes all sessions that are in the run queue&lt;br/&gt;
waiting for a thread, (b) poisons all DRDAConnThreads, and (c) reboots&lt;br/&gt;
the engine. Because the poisoned DRDAConnThreads are left around, they&lt;br/&gt;
will eventually pick up a session but abandon it.&lt;/p&gt;

&lt;p&gt;Bryan wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Deepa and I discussed this a fair amount in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1219&quot; title=&quot;jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1219&quot;&gt;&lt;del&gt;DERBY-1219&lt;/del&gt;&lt;/a&gt;; you should&lt;br/&gt;
&amp;gt; probably review that discussion to see if there&apos;s more you can learn&lt;br/&gt;
&amp;gt; from it.  In particular, the discussion regarding &quot;skipThreads.diff&quot;&lt;br/&gt;
&amp;gt; at: &lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-1219#action_12378300&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-1219#action_12378300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are many interesting patches attached to that issue (though I am&lt;br/&gt;
definitely not going for any solution which involves&lt;br/&gt;
Thread.interrupt()). skipThreads.diff seems to do exactly what I&lt;br/&gt;
proposed. From the comments, it seems like there were two objections:&lt;/p&gt;

&lt;p&gt;  1) It didn&apos;t fix all of the hangs.&lt;br/&gt;
  2) Removing the cleanup code didn&apos;t feel quite right, but if the&lt;br/&gt;
     threads could be reused after a restart, it should be okay.&lt;/p&gt;

&lt;p&gt;The hangs mentioned in (1) could be the same ones as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1817&quot; title=&quot;Race condition in network server&amp;#39;s thread pool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1817&quot;&gt;&lt;del&gt;DERBY-1817&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
fixed. I also believe that the threads can be reused after a restart.&lt;/p&gt;

&lt;p&gt;&amp;gt; If we didn&apos;t close down the threads, would we do anything to notify&lt;br/&gt;
&amp;gt; them of the shutdown? Were you proposing to leave them alone&lt;br/&gt;
&amp;gt; entirely? Or were you proposing to notify them of the shutdown, but&lt;br/&gt;
&amp;gt; not require the threads to exit?&lt;/p&gt;

&lt;p&gt;I don&apos;t think we need to notify them about the shutdown. If a thread&lt;br/&gt;
is waiting for runQueue notification in getNextSession(), it is not&lt;br/&gt;
bound to a session and hence doesn&apos;t need to know about the&lt;br/&gt;
shutdown. If a thread has a session bound to it, it would stay&lt;br/&gt;
sleeping (and unavailable for new sessions) until the client closes&lt;br/&gt;
the connection or disconnects. This is quite similar to the current&lt;br/&gt;
behaviour (the closed threads are not freed until there is some&lt;br/&gt;
activity on them).&lt;/p&gt;

&lt;p&gt;For the latter (threads with sessions), it would make sense to notify&lt;br/&gt;
them about the shutdown so they could drop their invalid sessions&lt;br/&gt;
earlier, but that would be an optimization and not a correctness&lt;br/&gt;
issue, I think.&lt;/p&gt;

&lt;p&gt;&amp;gt; Are you sure a DRDAConnThread doesn&apos;t have dependencies on the&lt;br/&gt;
&amp;gt; engine instance? The thread has a pointer to a session, and a&lt;br/&gt;
&amp;gt; session seems like it could point to database objects (like&lt;br/&gt;
&amp;gt; Connection objects, e.g.)&lt;/p&gt;

&lt;p&gt;All DRDAConnThread&apos;s dependencies on the engine go through the session&lt;br/&gt;
pointer. For free threads, the session pointer is null, hence there&lt;br/&gt;
are no dependencies. If it picks up a new session, it would depend on&lt;br/&gt;
the new session&apos;s engine, not the old one.&lt;/p&gt;

&lt;p&gt;For active DRDAConnThread instances, there are dependencies on the old&lt;br/&gt;
engine after the shutdown. However, this is also the case for the&lt;br/&gt;
current code (the thread is marked as closed, but the session is not&lt;br/&gt;
abandoned and the thread is not stopped until the client tries to&lt;br/&gt;
perform an operation on the connection).&lt;/p&gt;</comment>
                            <comment id="12434428" author="knutanders" created="Wed, 13 Sep 2006 13:39:29 +0100"  >&lt;p&gt;I&apos;m also exploring these options:&lt;br/&gt;
  1) Poisoning all active threads (those with session != null) and keeping the free threads.&lt;br/&gt;
  2) Poisoning all threads and make poisoned threads put sessions back in runQueue. This would also require moving the creation of new threads to runQueueAdd() in order to prevent the queue from growing bigger than the pool of free threads.&lt;/p&gt;</comment>
                            <comment id="12434481" author="bryanpendleton" created="Wed, 13 Sep 2006 16:53:22 +0100"  >&lt;p&gt;&amp;gt; For the latter (threads with sessions), it would make sense to notify&lt;br/&gt;
&amp;gt; them about the shutdown so they could drop their invalid sessions&lt;br/&gt;
&amp;gt; earlier, but that would be an optimization and not a correctness&lt;br/&gt;
&amp;gt; issue, I think. &lt;/p&gt;

&lt;p&gt;I think there could be a correctness issue here, actually.&lt;/p&gt;

&lt;p&gt;One of my worries had to do with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-51&quot; title=&quot;Need NetworkServerControl shutdown API method that does not shutdown derby embedded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-51&quot;&gt;DERBY-51&lt;/a&gt;, and whether there was&lt;br/&gt;
any implicit or explicit contract about how Network Server shutdown and&lt;br/&gt;
engine/database shutdown were linked.&lt;/p&gt;

&lt;p&gt;That is, it seems to me that a user might expect that if they shut down&lt;br/&gt;
the Network Server, that when that call returned to them, their application&lt;br/&gt;
could assume that the database was also shut down as of that point.&lt;/p&gt;

&lt;p&gt;NOTE: I&apos;m not saying that this is how things currently work; I&apos;m just saying&lt;br/&gt;
that it seems to me that users might make that assumption and we&lt;br/&gt;
haven&apos;t been explicit about it one way or another. But that&apos;s &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-51&quot; title=&quot;Need NetworkServerControl shutdown API method that does not shutdown derby embedded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-51&quot;&gt;DERBY-51&lt;/a&gt;,&lt;br/&gt;
properly, not this bug.&lt;/p&gt;

&lt;p&gt;Still, if we make a change for this bug that forces our hand w.r.t. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-51&quot; title=&quot;Need NetworkServerControl shutdown API method that does not shutdown derby embedded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-51&quot;&gt;DERBY-51&lt;/a&gt;,&lt;br/&gt;
we should make it clear that we&apos;re doing so intentionally so that we don&apos;t&lt;br/&gt;
later reverse that change and re-introduce this problem.&lt;/p&gt;</comment>
                            <comment id="12434547" author="deepa" created="Wed, 13 Sep 2006 22:26:12 +0100"  >&lt;p&gt;Thanks Knut for working on this.&lt;/p&gt;

&lt;p&gt;Some questions/thoughts:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I think it is okay to re-use free/idle threads without closing them. It may not be okay to re-use active threads without closing/poisoning them. If we do this, wouldn&apos;t we end up with threads getting invalid/closed sessions to work on?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Isn&apos;t this a possible scenario which can cause a hang in a client: When restart is in progress, a new client session comes in and gets added to runQueue. After the session is added, the restart code closes the new session or clears the runQueue. So the server just discards the new session and the client keeps waiting.&lt;/li&gt;
&lt;/ul&gt;



</comment>
                            <comment id="12434697" author="knutanders" created="Thu, 14 Sep 2006 15:39:40 +0100"  >&lt;p&gt;Attaching a patch (derby-1326-cleanup_exceptions.diff) with two small&lt;br/&gt;
cleanups in preparation for the real fix (for which the approach&lt;br/&gt;
hasn&apos;t been chosen yet). None of the two cleanups will fix the hang.&lt;/p&gt;

&lt;p&gt;Description of cleanup in DRDAConnThread.handleException(): When I was&lt;br/&gt;
stress testing one possible fix for the hang, I noticed a new type of&lt;br/&gt;
hang that I didn&apos;t understand. After a bit of investigation, I found&lt;br/&gt;
that the stress test triggered a NullPointerException while running&lt;br/&gt;
handleException(). handleException() is written so that all code paths&lt;br/&gt;
end with closeSession() and close(). However, if a runtime exception&lt;br/&gt;
is thrown, closeSession() and close() are skipped, and the&lt;br/&gt;
DRDAConnThread stops without closing the session (which leads to a&lt;br/&gt;
hang on the client). To fix this, I refactored handleException() so&lt;br/&gt;
that closeSession() and close() are called from a finally clause.&lt;/p&gt;

&lt;p&gt;Description of cleanup in NetworkServerControlImpl.startNetworkServer():&lt;br/&gt;
Currently, the restart code closes and removes all sessions in&lt;br/&gt;
runQueue, but it leaves them in sessionTable as long as the network&lt;br/&gt;
server runs. Fix: Remove them from sessionTable as well. Also, a&lt;br/&gt;
synchronized block was added around the runQueue loop in case&lt;br/&gt;
addSession() or getNextSession() modifies the size of runQueue while&lt;br/&gt;
the loop is running.&lt;/p&gt;

&lt;p&gt;I thought it would be better to get in these changes in advance to&lt;br/&gt;
make the real fix smaller and cleaner.&lt;/p&gt;

&lt;p&gt;Derbyall ran cleanly with these changes.&lt;/p&gt;</comment>
                            <comment id="12434718" author="knutanders" created="Thu, 14 Sep 2006 16:53:20 +0100"  >&lt;p&gt;Bryan, I&apos;m not sure I understand what impact this could have on&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-51&quot; title=&quot;Need NetworkServerControl shutdown API method that does not shutdown derby embedded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-51&quot;&gt;DERBY-51&lt;/a&gt;. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-51&quot; title=&quot;Need NetworkServerControl shutdown API method that does not shutdown derby embedded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-51&quot;&gt;DERBY-51&lt;/a&gt; is about server shutdown, whereas this issue is&lt;br/&gt;
about a client opening a connection which has the side effect of&lt;br/&gt;
shutting down the engine.&lt;/p&gt;

&lt;p&gt;&amp;gt; That is, it seems to me that a user might expect that if they shut&lt;br/&gt;
&amp;gt; down the Network Server, that when that call returned to them, their&lt;br/&gt;
&amp;gt; application could assume that the database was also shut down as of&lt;br/&gt;
&amp;gt; that point.&lt;/p&gt;

&lt;p&gt;If the network server is started from command line and the user&lt;br/&gt;
invokes NetworkServerControl.shutdown() this is exactly what happens&lt;br/&gt;
in Derby 10.2. In 10.1, and in 10.2 when the server is not started&lt;br/&gt;
from command line, the server does not shut down the engine/databases&lt;br/&gt;
on shutdown. However, getConnection(&quot;...;shutdown=true&quot;) does not shut&lt;br/&gt;
down the server, only the engine.&lt;/p&gt;

&lt;p&gt;I don&apos;t see that poisoning or not poisoning the threads should affect&lt;br/&gt;
that behaviour or &quot;force our hands&quot; in any way w.r.t. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-51&quot; title=&quot;Need NetworkServerControl shutdown API method that does not shutdown derby embedded&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-51&quot;&gt;DERBY-51&lt;/a&gt;. When&lt;br/&gt;
the &lt;b&gt;server&lt;/b&gt; at a later point is told to shut down, it is free to shut&lt;br/&gt;
down (or not to shut down) the &lt;b&gt;engine&lt;/b&gt; regardless of threads with old&lt;br/&gt;
sessions hanging around. Also, threads with old sessions can be&lt;br/&gt;
present on the server for a long time after an engine shutdown even in&lt;br/&gt;
the current code (there is no call to Thread.interrupt() after the&lt;br/&gt;
engine has been shut down).&lt;/p&gt;</comment>
                            <comment id="12434752" author="knutanders" created="Thu, 14 Sep 2006 18:56:51 +0100"  >&lt;p&gt;Deepa wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; * I think it is okay to re-use free/idle threads without closing&lt;br/&gt;
&amp;gt;   them. It may not be okay to re-use active threads without&lt;br/&gt;
&amp;gt;   closing/poisoning them. If we do this, wouldn&apos;t we end up with&lt;br/&gt;
&amp;gt;   threads getting invalid/closed sessions to work on?&lt;/p&gt;

&lt;p&gt;Yes, that is correct. This is also the case with the current code. The&lt;br/&gt;
active threads remain alive until the client sends a new&lt;br/&gt;
command. Since the embedded connection is closed, it gets a&lt;br/&gt;
connection-closed exception and closes the session, before it&lt;br/&gt;
discovers that the thread is closed as well, and exits. If we don&apos;t&lt;br/&gt;
close the threads, we get the same behaviour, except that the thread&lt;br/&gt;
is reused instead of closed down after the connection-closed&lt;br/&gt;
exception.&lt;/p&gt;

&lt;p&gt;&amp;gt; * Isn&apos;t this a possible scenario which can cause a hang in a client:&lt;br/&gt;
&amp;gt;   When restart is in progress, a new client session comes in and gets&lt;br/&gt;
&amp;gt;   added to runQueue. After the session is added, the restart code&lt;br/&gt;
&amp;gt;   closes the new session or clears the runQueue. So the server just&lt;br/&gt;
&amp;gt;   discards the new session and the client keeps waiting.&lt;/p&gt;

&lt;p&gt;This is a possible scenario, but it won&apos;t cause a hang. Since the&lt;br/&gt;
session and its socket streams have been closed, the client will get&lt;br/&gt;
an IOException on read() (seen as DRDAProtocolException, for instance:&lt;br/&gt;
insufficient data, read -1 bytes, expected 6).&lt;/p&gt;

&lt;p&gt;(But there is in fact a similar situation that can occur in the&lt;br/&gt;
current code, and that will cause a hang: If a new session is added to&lt;br/&gt;
runQueue after the restart code has closed all sessions in runQueue,&lt;br/&gt;
but before it has called runQueue.clear(), the new session will be&lt;br/&gt;
removed from runQueue without being closed, and the client will&lt;br/&gt;
hang. derby-1326-cleanup_exceptions.diff should fix that issue.)&lt;/p&gt;</comment>
                            <comment id="12434834" author="bryanpendleton" created="Thu, 14 Sep 2006 23:29:16 +0100"  >&lt;p&gt;Hi Knut Anders, thanks for the clarifications. I am comfortable with your explanation.&lt;/p&gt;</comment>
                            <comment id="12434851" author="deepa" created="Fri, 15 Sep 2006 00:55:15 +0100"  >&lt;p&gt;Thanks Knut for the answers. I still cannot wrap my head around old sessions hanging around in the server. I think this concerns the current code and not related to your patch. The cleanups you suggested sound good to me.&lt;/p&gt;
</comment>
                            <comment id="12434908" author="knutanders" created="Fri, 15 Sep 2006 09:14:32 +0100"  >&lt;p&gt;Committed derby-1326-cleanup_exceptions.diff with revision 446538.&lt;/p&gt;</comment>
                            <comment id="12434975" author="knutanders" created="Fri, 15 Sep 2006 14:40:42 +0100"  >&lt;p&gt;Attaching patch (derby-1326-skipThreads.diff) which modifies NetworkServerControlImpl the same way as Bryan&apos;s skipThreads.diff (attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1219&quot; title=&quot;jdbcapi/checkDataSource.java and jdbcapi/checkDataSource30.java hang intermittently with client&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1219&quot;&gt;&lt;del&gt;DERBY-1219&lt;/del&gt;&lt;/a&gt;). I cannot reproduce the hang with the patch. Derbyall ran cleanly on Solaris 10 x86, Sun JVM 1.5.0.&lt;/p&gt;</comment>
                            <comment id="12434985" author="knutanders" created="Fri, 15 Sep 2006 15:05:12 +0100"  >&lt;p&gt;Deepa wrote:&lt;br/&gt;
&amp;gt; I still cannot wrap my head around old sessions hanging around in the server.&lt;/p&gt;

&lt;p&gt;They hang around in the server because the DRDAConnThread could be blocked in a read() call. read() will block until the socket stream is closed (either by the client or the server) or the client sends data. Calling close() on the DRDAConnThread only sets a flag, so this won&apos;t interrupt read(). I think Bryan was very close to solving this when he went through sessionTable and closed each session (which will take down the socket stream and make read() return -1 immediately). See one of his earlier comments about this. I don&apos;t think that issue is directly related to the hang or abandoning of sessions, so it should probably be filed as a separate issue.&lt;/p&gt;</comment>
                            <comment id="12434998" author="deepa" created="Fri, 15 Sep 2006 15:42:55 +0100"  >&lt;p&gt;I&apos;ll file a separate issue for removing all the existing sessions after a restart. From Knut&apos;s comments, this is only an optimization issue.&lt;/p&gt;

&lt;p&gt;As derby-1326-skipThreads.diff resolves this hang, we can re-enable the shutdown in the test jdbcapi/checkDataSource.java. This was commented out as it caused the test to hang intermittently. It may be good to add the new repro &quot;Restart.java&quot; to the regression tests as it reliably reproduces this hang.&lt;/p&gt;</comment>
                            <comment id="12435462" author="knutanders" created="Mon, 18 Sep 2006 12:45:42 +0100"  >&lt;p&gt;Thanks for the suggestions, Deepa. I committed skipThreads with revision 447375. Will post a new patch with the suggested test changes.&lt;/p&gt;</comment>
                            <comment id="12435519" author="knutanders" created="Mon, 18 Sep 2006 17:35:07 +0100"  >&lt;p&gt;derby-1326-checkds.diff re-enables the shutdown in checkDataSource. Without the skipThreads patch, checkDataSource and checkDataSource30 hung intermittently. With the skipThreads patch, they didn&apos;t. Derbyall ran cleanly. Committed with revision 447462.&lt;/p&gt;</comment>
                            <comment id="12437487" author="knutanders" created="Mon, 25 Sep 2006 10:06:09 +0100"  >&lt;p&gt;Attaching a patch which makes derbynet/ShutDownDBWhenNSShutsDownTest.junit run the repro (Restart.java) as a JUnit test case.&lt;/p&gt;</comment>
                            <comment id="12437489" author="knutanders" created="Mon, 25 Sep 2006 10:14:24 +0100"  >&lt;p&gt;Committed derby-1326-restartTest.diff with revision 449616. Marking as fixed in 10.2.1.5 since the fix (but not all tests) made it into the release candidate.&lt;/p&gt;</comment>
                            <comment id="12437581" author="deepa" created="Mon, 25 Sep 2006 15:54:54 +0100"  >&lt;p&gt;Closing the issue as the fix is available in 10.2 and trunk. Thanks to Knut, Bryan (and others involved) in resolving this issue.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12349317">DERBY-1817</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12340643" name="Restart.java" size="1731" author="knutanders" created="Tue, 12 Sep 2006 12:27:45 +0100"/>
                            <attachment id="12341066" name="derby-1326-checkds.diff" size="2840" author="knutanders" created="Mon, 18 Sep 2006 17:35:07 +0100"/>
                            <attachment id="12340844" name="derby-1326-cleanup_exceptions.diff" size="3308" author="knutanders" created="Thu, 14 Sep 2006 15:39:40 +0100"/>
                            <attachment id="12341604" name="derby-1326-restartTest.diff" size="2187" author="knutanders" created="Mon, 25 Sep 2006 10:06:09 +0100"/>
                            <attachment id="12340921" name="derby-1326-skipThreads.diff" size="1003" author="knutanders" created="Fri, 15 Sep 2006 14:40:42 +0100"/>
                            <attachment id="12334415" name="repro1326.java" size="1176" author="deepa" created="Tue, 23 May 2006 01:18:49 +0100"/>
                            <attachment id="12335055" name="resolve_DRDConnThread_conflict.diff" size="12531" author="bryanpendleton" created="Tue, 6 Jun 2006 05:54:08 +0100"/>
                            <attachment id="12334540" name="sessionMgmt1.diff" size="7405" author="bryanpendleton" created="Thu, 25 May 2006 10:14:05 +0100"/>
                            <attachment id="12334630" name="sessionMgmt1_and_nosessionsforclosedthreads.diff" size="7719" author="deepa" created="Sat, 27 May 2006 00:55:50 +0100"/>
                            <attachment id="12335321" name="unify_NSImpl_instances.diff" size="4161" author="bryanpendleton" created="Mon, 12 Jun 2006 01:47:57 +0100"/>
                            <attachment id="12334997" name="withNewThreadAndNoShutdownOfCurrentSession.diff" size="12524" author="bryanpendleton" created="Mon, 5 Jun 2006 01:11:33 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 20 May 2006 02:15:00 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22439</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy14hr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40378</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>