<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:17:36 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3786/DERBY-3786.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3786] Assert failure in CacheEntry.unkeepForRemove when running stress.multi</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3786</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When running stress.multi on a machine with 32 hardware execution threads, I observed the following assert failure in two independent runs:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;2008-07-18 02:15:14.415 GMT Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;Thread-8,5,workers&amp;#93;&lt;/span&gt; (XID = 94699), (SESSIONID = 16923), (DATABASE = mydb), (DRDAID = null), Failed Statement is: insert into a values (1)&lt;br/&gt;
org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED&lt;br/&gt;
        at org.apache.derby.shared.common.sanity.SanityManager.ASSERT(SanityManager.java:98)&lt;br/&gt;
        at org.apache.derby.impl.services.cache.CacheEntry.unkeepForRemove(CacheEntry.java:217)&lt;br/&gt;
        at org.apache.derby.impl.services.cache.ConcurrentCache.remove(ConcurrentCache.java:446)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.removeStatement(GenericLanguageConnectionContext.java:898)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:516)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:794)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:606)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:555)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:329)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:508)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:350)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.mtTestCase.runMe(mtTestCase.java:246)&lt;br/&gt;
        at org.apache.derby.impl.tools.ij.mtTester.run(mtTester.java:91)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
Cleanup action completed&lt;/p&gt;
&lt;hr /&gt;


&lt;p&gt;In stress.log:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Tester8: insert2 Fri Jul 18 04:15:12 CEST 2008&lt;br/&gt;
Tester6: TERMINATING due to unexpected error:&lt;br/&gt;
FatalException: XJ001: Java exception: &apos;ASSERT FAILED: org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;br/&gt;
Tester1: SELECT2 Fri Jul 18 04:15:13 CEST 2008&lt;br/&gt;
Tester8: stopping on request after 820 iterations&lt;br/&gt;
Tester10: stopping on request after 859 iterations&lt;br/&gt;
Tester1: stopping on request after 847 iterations&lt;br/&gt;
Tester7: TERMINATING due to unexpected error:&lt;br/&gt;
FatalException: XJ001: Java exception: &apos;ASSERT FAILED: org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;br/&gt;
Tester9: stopping on request after 722 iterations&lt;br/&gt;
Tester3: stopping on request after 880 iterations&lt;br/&gt;
Tester5: stopping on request after 858 iterations&lt;br/&gt;
Tester4: stopping on request after 839 iterations&lt;br/&gt;
WARNING: testers didn&apos;t die willingly, so I&apos;m going to kill &apos;em.&lt;br/&gt;
        This may result in connection resources that aren&apos;t cleaned up&lt;br/&gt;
        (e.g. you may see problems in the final script run with deadlocks).&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;A few runs on a similar but slightly slower machine didn&apos;t experience the same failure, so the bug is likely timing dependent.&lt;br/&gt;
I&apos;ll perform some more runs and see how hard it is to reproduce.&lt;/p&gt;

&lt;p&gt;I haven&apos;t investigated what will happen in an insane build.&lt;/p&gt;</description>
                <environment>32 hardware execution threads</environment>
        <key id="12400637">DERBY-3786</key>
            <summary>Assert failure in CacheEntry.unkeepForRemove when running stress.multi</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="kristwaa">Kristian Waagan</reporter>
                        <labels>
                    </labels>
                <created>Mon, 21 Jul 2008 09:15:49 +0100</created>
                <updated>Mon, 4 May 2009 19:22:25 +0100</updated>
                            <resolved>Sat, 23 Aug 2008 08:48:16 +0100</resolved>
                                    <version>10.5.1.1</version>
                                    <fixVersion>10.4.2.0</fixVersion>
                    <fixVersion>10.5.1.1</fixVersion>
                                    <component>Services</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12615206" author="knutanders" created="Mon, 21 Jul 2008 11:38:15 +0100"  >&lt;p&gt;It looks like one thread calls ConcurrentCache.remove() while another thread is blocked inside the same method. According to the javadoc for CacheManager.remove(), callers of remove() must synchronize so that no two threads try to remove the same object concurrently:&lt;/p&gt;

&lt;p&gt;	/**&lt;br/&gt;
		Delete and remove an object from the cache. It is up to the user of the cache&lt;br/&gt;
		to provide synchronization of some form that ensures that only one caller&lt;br/&gt;
		executes remove() on a cached object.&lt;br/&gt;
		&amp;lt;BR&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12615591" author="knutanders" created="Tue, 22 Jul 2008 12:52:25 +0100"  >&lt;p&gt;Attaching code that reproduces the assert failure on my machine (dual core). It creates a table without committing in one transaction and starts 100 threads that prepare a query against that table in other transactions. The preparing of the query fails with a timeout exception, which leads to GenericLanguageConnectionContext.removeStatement() and CacheManager.remove() being called, and there seems to be a race condition between the threads that time out at approximately the same time.&lt;/p&gt;

&lt;p&gt;I also tried to run it on trunk in insane mode. Then the assert error didn&apos;t occur, of course, but more and more threads became idle, until all the threads were blocked.&lt;/p&gt;</comment>
                            <comment id="12615592" author="knutanders" created="Tue, 22 Jul 2008 12:56:40 +0100"  >&lt;p&gt;Tried the repro with JDK 1.4 to see if we get the same behaviour with the old cache manager (Clock) as with the new one (ConcurrentCache). I then got this assert failure:&lt;/p&gt;

&lt;p&gt;java.sql.SQLException: Java exception: &apos;ASSERT FAILED: org.apache.derby.shared.common.sanity.AssertFailure&apos;.&lt;br/&gt;
        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:87)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.Util.javaException(Util.java:244)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:403)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2192)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:146)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(EmbedPreparedStatement20.java:82)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(EmbedPreparedStatement30.java:63)&lt;br/&gt;
        at org.apache.derby.jdbc.Driver30.newEmbedPreparedStatement(Driver30.java:99)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(EmbedConnection.java:1533)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(EmbedConnection.java:1361)&lt;br/&gt;
        at d3786$1.run_(d3786.java:26)&lt;br/&gt;
        at d3786$1.run(d3786.java:15)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:534)&lt;br/&gt;
Caused by: org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED&lt;br/&gt;
        at org.apache.derby.shared.common.sanity.SanityManager.ASSERT(SanityManager.java:98)&lt;br/&gt;
        at org.apache.derby.impl.services.cache.CachedItem.unkeep(CachedItem.java:144)&lt;br/&gt;
        at org.apache.derby.impl.services.cache.Clock.remove(Clock.java:603)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.removeStatement(GenericLanguageConnectionContext.java:898)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:516)&lt;br/&gt;
        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)&lt;br/&gt;
        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:794)&lt;br/&gt;
        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(EmbedPreparedStatement.java:128)&lt;br/&gt;
        ... 8 more&lt;/p&gt;


&lt;p&gt;The failing assert is this one in CachedItem.unkeep():&lt;/p&gt;

&lt;p&gt;		if (SanityManager.DEBUG) &lt;/p&gt;
{
			SanityManager.ASSERT(keepCount &amp;gt;= 0);
		}</comment>
                            <comment id="12615596" author="knutanders" created="Tue, 22 Jul 2008 13:02:34 +0100"  >&lt;p&gt;Looking at the stack trace from JDK 1.4, I think this issue is the same as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1053&quot; title=&quot;stress.multi test on ibm142  in SANE builds fails with ASSERTION at org.apache.derby.impl.services.cache.CachedItem.unkeep(CachedItem.java:152)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1053&quot;&gt;&lt;del&gt;DERBY-1053&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12615643" author="knutanders" created="Tue, 22 Jul 2008 16:17:42 +0100"  >&lt;p&gt;The code that calls removeStatement() uses a synchronized flag and&lt;br/&gt;
wait()+notifyAll() to prevent multiple threads from recompiling the&lt;br/&gt;
same statement concurrently. The code synchronizes on the&lt;br/&gt;
GenericPreparedStatement instance that is being compiled. What&lt;br/&gt;
happens, is basically:&lt;/p&gt;

&lt;p&gt;  1. fetch the prepared statement from the statement cache, possibly&lt;br/&gt;
  creating a new one if it isn&apos;t in the cache&lt;/p&gt;

&lt;p&gt;  2. release the statement (which means others can removed it from the&lt;br/&gt;
  cache)&lt;/p&gt;

&lt;p&gt;  3. if someone else is recompiling the prepared statement, wait until&lt;br/&gt;
  they have finished&lt;/p&gt;

&lt;p&gt;  4. recompile the statement and block others until finished&lt;/p&gt;

&lt;p&gt;  5. if an error happens during recompile&lt;/p&gt;

&lt;p&gt;    a) check if it exists in the cache&lt;/p&gt;

&lt;p&gt;    b) if it is in the cache, remove it&lt;/p&gt;

&lt;p&gt;If two threads do this concurrently, they&apos;ll both get a reference to&lt;br/&gt;
the same prepared statement in the cache in step (1). Then one of the&lt;br/&gt;
threads is allowed to recompile the statement, whereas the other&lt;br/&gt;
thread is blocked in (3). In the repro, the thread that is recompiling&lt;br/&gt;
the statement fails with a lock timeout, so it removes the statement&lt;br/&gt;
from the cache. The other thread is allowed to continue, and also&lt;br/&gt;
fails while recompiling. The statement is no longer in the cache, so&lt;br/&gt;
it doesn&apos;t try to remove it, and everything is fine.&lt;/p&gt;

&lt;p&gt;Now, consider the possibility that a third thread tries to prepare the&lt;br/&gt;
same SQL text right after the first thread has removed the prepared&lt;br/&gt;
statement from the cache. This means that thread 3 doesn&apos;t find the&lt;br/&gt;
statement in the cache and therefore creates a new prepared&lt;br/&gt;
statement. Since this is another instance of GenericPreparedStatement&lt;br/&gt;
than the one thread 1 and thread 2 are working on, thread 3 won&apos;t&lt;br/&gt;
detect that others are recompiling the same statement.&lt;/p&gt;

&lt;p&gt;If the compilation succeeds, it is no problem that two different&lt;br/&gt;
GenericPreparedStatement instances are used for the same SQL&lt;br/&gt;
text. However, since also the third thread fails while compiling the&lt;br/&gt;
statement, and it is not synchronized with the second thread since&lt;br/&gt;
they don&apos;t have the same prepared statement, thread 2 and thread 3 may&lt;br/&gt;
end up calling removeStatement() concurrently. Although their prepared&lt;br/&gt;
statements are different, they&apos;ll have the same key in the statement&lt;br/&gt;
cache, so now thread 2 will find that the statement in fact is in the&lt;br/&gt;
cache and try to remove it. Thread 3 also finds it in the cache and&lt;br/&gt;
invokes CacheManager.remove() at the same time. This breaks the&lt;br/&gt;
contract of CacheManager.remove(), and bad things start happening&lt;br/&gt;
(assert failures and hangs).&lt;/p&gt;

&lt;p&gt;I think there are two ways to fix this:&lt;/p&gt;

&lt;p&gt;  1) In GenericLanguageConnectionContext.removeStatement(), only call&lt;br/&gt;
  remove() if the prepared statement in the cache is exactly the same&lt;br/&gt;
  as the prepared statement we tried to recompile. The patch&lt;br/&gt;
  remove.diff shows this approach. I haven&apos;t run the regression tests,&lt;br/&gt;
  but it seems to fix this problem (I don&apos;t see assert failures or&lt;br/&gt;
  hangs with the repro anymore).&lt;/p&gt;

&lt;p&gt;  2) It may also be possible to fix it by not releasing the statement&lt;br/&gt;
  in step (2). Then it&apos;s not possible to remove the statement from the&lt;br/&gt;
  cache until it has been recompiled, and all the threads that try to&lt;br/&gt;
  recompile it are guaranteed to work on the same&lt;br/&gt;
  GenericPreparedStatement instance. Some extra logic would be needed&lt;br/&gt;
  to prevent deadlocks, as the call to remove() would block until no&lt;br/&gt;
  one holds that statement, and every other thread that is waiting to&lt;br/&gt;
  recompile the same statement will be holding it.&lt;/p&gt;</comment>
                            <comment id="12615778" author="knutanders" created="Tue, 22 Jul 2008 21:30:04 +0100"  >&lt;p&gt;Derbyall and suites.All ran cleanly with remove.diff, so unless there are any objections to the approach, I&apos;ll create a new patch with some comments added that we can consider for commit.&lt;/p&gt;</comment>
                            <comment id="12624121" author="knutanders" created="Wed, 20 Aug 2008 21:17:40 +0100"  >&lt;p&gt;Here&apos;s a new version of the patch with comments added. Derbyall and suites.All still run cleanly.&lt;/p&gt;</comment>
                            <comment id="12624627" author="knutanders" created="Fri, 22 Aug 2008 09:58:15 +0100"  >&lt;p&gt;Committed revision 688027.&lt;/p&gt;

&lt;p&gt;Since this is also a problem in older versions, I&apos;m leaving the issue open until the fix has been back-ported to the 10.4 branch.&lt;/p&gt;</comment>
                            <comment id="12625030" author="knutanders" created="Sat, 23 Aug 2008 08:48:15 +0100"  >&lt;p&gt;Merged to 10.4 with revision 688275.&lt;/p&gt;</comment>
                            <comment id="12626000" author="kristwaa" created="Wed, 27 Aug 2008 09:27:25 +0100"  >&lt;p&gt;I ran stress.multi successfully 80 times on the same machine where I first saw this problem.  I also ran the repro (d3786) for a while withouth failures. Thanks for the fix, Knut Anders.&lt;/p&gt;

&lt;p&gt;I&apos;m closing this issue and the duplicate.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="12329452">DERBY-1053</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12386623" name="d3786.java" size="1624" author="knutanders" created="Tue, 22 Jul 2008 12:52:24 +0100"/>
                            <attachment id="12386631" name="remove.diff" size="1734" author="knutanders" created="Tue, 22 Jul 2008 16:17:42 +0100"/>
                            <attachment id="12388626" name="remove_v2.diff" size="3591" author="knutanders" created="Wed, 20 Aug 2008 21:17:40 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 21 Jul 2008 10:38:15 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23844</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0xnz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39272</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>