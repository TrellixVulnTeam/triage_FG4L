<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:52:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-6017/DERBY-6017.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-6017] IN lists with mixed types may return wrong results</title>
                <link>https://issues.apache.org/jira/browse/DERBY-6017</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Given this table:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; connect &apos;jdbc:derby:memory:db;create=true&apos;;&lt;br/&gt;
ij&amp;gt; create table t(x bigint);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t values 9223372036854775805, 9223372036854775806, 9223372036854775807;&lt;br/&gt;
3 rows inserted/updated/deleted&lt;/p&gt;

&lt;p&gt;A query that uses an IN list that contains all the three values actually stored in the table, returns all three rows as expected:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from t where x in (9223372036854775805, 9223372036854775806, 9223372036854775807);&lt;br/&gt;
X                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775805 &lt;br/&gt;
9223372036854775806 &lt;br/&gt;
9223372036854775807 &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;/p&gt;

&lt;p&gt;However, if we add a value whose type precedence is higher, like a DOUBLE value, and that value happens to be equal to the approximation of the other values in the IN list when they are cast from BIGINT to DOUBLE, only one row is returned:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from t where x in (9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18);&lt;br/&gt;
X                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775805 &lt;/p&gt;

&lt;p&gt;1 row selected&lt;/p&gt;

&lt;p&gt;I believe this query should return all three rows too.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12624466">DERBY-6017</key>
            <summary>IN lists with mixed types may return wrong results</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 18 Dec 2012 13:27:34 +0000</created>
                <updated>Wed, 7 Aug 2013 15:52:10 +0100</updated>
                            <resolved>Mon, 4 Mar 2013 13:47:14 +0000</resolved>
                                    <version>10.9.1.0</version>
                                    <fixVersion>10.8.3.3</fixVersion>
                    <fixVersion>10.9.2.2</fixVersion>
                    <fixVersion>10.10.1.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="13534914" author="knutanders" created="Tue, 18 Dec 2012 14:23:10 +0000"  >&lt;p&gt;I believe this happens because of optimizations that are performed if the IN list consists of constants only.&lt;/p&gt;

&lt;p&gt;Such IN lists are sorted at compile time so that binary search can be used to find if there&apos;s a match at run time. That&apos;s all good. However, the sorting and the binary search use different ordering. The sorting (in ValueNodeList.sortInAscendingOrder()) uses the ordering of the type with the highest precedence of the target and all the operands. The binary search (in DataType.in()) uses the ordering of the type with the highest precedence of each pair of values that it compares.&lt;/p&gt;

&lt;p&gt;In the query above, this means:&lt;/p&gt;

&lt;p&gt;The sorting happens using the type with the highest precedence of all the values. That is, DOUBLE. All the four values in the IN list have the same DOUBLE value, so the list is already sorted, regardless of how we order the actual values. But when binary search is performed at run time, BIGINT semantics are used for some of the comparisons (those that involve BIGINTs only) and DOUBLE comparison for others (those that involve a DOUBLE value). So the binary search does not see the list as one that contain values that are all equal.&lt;/p&gt;

&lt;p&gt;Additionally, during preprocessing, there is code to simplify the predicate if it&apos;s an IN list where all values are equal. This check also uses the dominant type, DOUBLE, and finds that the list indeed contains only one distinct value. It therefore eliminates the IN list and replaces it with a simple equality check using just one of the values in the IN list. That is, it rewrites the query from&lt;/p&gt;

&lt;p&gt;    select * from t where x in (9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18)&lt;/p&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;p&gt;    select * from t where x = 9223372036854775805&lt;/p&gt;

&lt;p&gt;Those two queries are equivalent if the equality operator uses DOUBLE semantics. Unfortunately, the information about what&apos;s the dominant type is lost when the IN list is eliminated, and the equality check is performed using BIGINT semantics instead. The result is that only a single row matches.&lt;/p&gt;

&lt;p&gt;So I think there are two things that need to be fixed:&lt;/p&gt;

&lt;p&gt;1) The sorting and the binary search must be made consistent.&lt;/p&gt;

&lt;p&gt;2) The duplicate elimination must preserve type information.&lt;/p&gt;</comment>
                            <comment id="13535049" author="bryanpendleton" created="Tue, 18 Dec 2012 17:02:03 +0000"  >&lt;p&gt;A very clear description, and a very clear analysis; thank you very much!&lt;/p&gt;

&lt;p&gt;The fact that floating point comparisons are approximate has always caught me up;&lt;br/&gt;
I wish that SQL had made it illegal to perform an exact comparison ( &quot;=&quot;, &quot;IN&quot;, etc.)&lt;br/&gt;
on a floating point type.&lt;/p&gt;

&lt;p&gt;Then we could have just declared this query illegal, and forced the user to think&lt;br/&gt;
more clearly about what computation they were trying to express.&lt;/p&gt;

&lt;p&gt;Is there any hope for such a resolution in the SQL standard?&lt;/p&gt;</comment>
                            <comment id="13535311" author="knutanders" created="Tue, 18 Dec 2012 20:58:21 +0000"  >&lt;p&gt;I think the query is allowed by the SQL standard. The first paragraph in SQL:2003, part 2, section 4.4.1 (Introduction to numbers) says: &quot;A number is either an exact numeric value or an approximate numeric value. Any two numbers are comparable.&quot; So no such luck.&lt;/p&gt;

&lt;p&gt;We probably need to study the standard more closely to find out what the exact semantics are, though. In particular this: Is it the sorting or the binary search that uses the right kind of comparison. If it&apos;s the sorting (which uses the same kind of comparison for all the values, based on the dominant type), I suspect the problem also affects IN lists that don&apos;t have constants. For example:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t3(b1 bigint, b2 bigint, d double);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t3 values (9223372036854775805, 9223372036854775806, 1);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t3 where b1 in (b2, d);&lt;br/&gt;
B1                  |B2                  |D                     &lt;br/&gt;
----------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;/p&gt;

&lt;p&gt;If it is correct that the dominant type should be used, I would have expected the above query to return one row, as there is a DOUBLE value in the IN list, and b1=b2 when they are converted to DOUBLE.&lt;/p&gt;

&lt;p&gt;Another puzzling result that doesn&apos;t involve constants, is this:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t4 (b bigint);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t4 values 9223372036854775806, 9223372036854775807;&lt;br/&gt;
2 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; create table t5 (d double);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t5 values 9.223372036854776E18;&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t4 where b in (select d from t5);&lt;br/&gt;
B                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775807 &lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select * from t4 where b in (select cast(d as double) from t5);&lt;br/&gt;
B                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775806 &lt;br/&gt;
9223372036854775807 &lt;/p&gt;

&lt;p&gt;2 rows selected&lt;/p&gt;

&lt;p&gt;Is it correct that the two queries should return different results? The only difference is that the first query accesses the D column with no cast, and the second one casts D to DOUBLE. But since D already is a DOUBLE column, I wouldn&apos;t expect the cast to make any difference.&lt;/p&gt;</comment>
                            <comment id="13535934" author="knutanders" created="Wed, 19 Dec 2012 13:12:19 +0000"  >&lt;p&gt;I&apos;ve tried to interpret what the standard says. Here are the relevant parts I&apos;ve found:&lt;/p&gt;

&lt;p&gt;&amp;gt; 8.4 &amp;lt;in predicate&amp;gt; - Syntax Rules&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; 2) Let IVL be an &amp;lt;in value list&amp;gt;.&lt;br/&gt;
&amp;gt; ( IVL )&lt;br/&gt;
&amp;gt; is equivalent to the &amp;lt;table value constructor&amp;gt;:&lt;br/&gt;
&amp;gt; ( VALUES IVL )&lt;/p&gt;

&lt;p&gt;So, according to this rule, the following two queries should be equivalent (which they are not currently):&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from t where x in (9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18);&lt;br/&gt;
X                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775805 &lt;/p&gt;

&lt;p&gt;1 row selected&lt;br/&gt;
ij&amp;gt; select * from t where x in (values 9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18);&lt;br/&gt;
X                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775805 &lt;br/&gt;
9223372036854775806 &lt;br/&gt;
9223372036854775807 &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;/p&gt;

&lt;p&gt;Furthermore, it says:&lt;/p&gt;

&lt;p&gt;&amp;gt; 8.4 &amp;lt;in predicate&amp;gt; - Syntax Rules&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; 5) The expression&lt;br/&gt;
&amp;gt; RVC IN IPV&lt;br/&gt;
&amp;gt; is equivalent to&lt;br/&gt;
&amp;gt; RVC = ANY IPV&lt;/p&gt;

&lt;p&gt;So to find the correct semantics for IN, we need to rewrite the query to ANY. That is,&lt;/p&gt;

&lt;p&gt;select * from t where x = any (values 9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18);&lt;/p&gt;

&lt;p&gt;and see what the standard says about that. (This particular ANY query returns three rows in Derby, which is the same as the IN (VALUES ...) query above.)&lt;/p&gt;

&lt;p&gt;This leads us to:&lt;/p&gt;

&lt;p&gt;&amp;gt; 8.8 &amp;lt;quantified comparison predicate&amp;gt; - Syntax Rules&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; 1) Let RV1 and RV2 be &amp;lt;row value predicand&amp;gt;s whose declared types are respectively that of the &amp;lt;row value&lt;br/&gt;
&amp;gt; predicand&amp;gt; and the row type of the &amp;lt;table subquery&amp;gt;. The Syntax Rules of Subclause 8.2, &#8220;&amp;lt;comparison&lt;br/&gt;
&amp;gt; predicate&amp;gt;&#8221;, are applied to:&lt;br/&gt;
&amp;gt; RV1 &amp;lt;comp op&amp;gt; RV2&lt;/p&gt;

&lt;p&gt;That is, for the comparisons, the value on the right hand side should have the row type of the sub-query.&lt;/p&gt;

&lt;p&gt;And the row type of our VALUES sub-query is DOUBLE (or at least some approximate numeric type) as 7.3 &amp;lt;table value constructor&amp;gt; says row type is determined by applying Subclause 9.3, &#8220;Data types of results of aggregations&#8221;, whose syntax rule 3d says:&lt;/p&gt;

&lt;p&gt;&amp;gt; If any data type in DTS is approximate numeric, then each data type in DTS shall be numeric and the&lt;br/&gt;
&amp;gt; result data type is approximate numeric with implementation-defined precision.&lt;/p&gt;

&lt;p&gt;Derby does produce the right type for the &amp;lt;table value constructor&amp;gt;:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; values 9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18;&lt;br/&gt;
1                     &lt;br/&gt;
----------------------&lt;br/&gt;
9.223372036854776E18  &lt;br/&gt;
9.223372036854776E18  &lt;br/&gt;
9.223372036854776E18  &lt;br/&gt;
9.223372036854776E18  &lt;/p&gt;

&lt;p&gt;4 rows selected&lt;/p&gt;

&lt;p&gt;The ANY query should therefore end up like:&lt;/p&gt;

&lt;p&gt;  select * from t where x = 9.223372036854776E18 or x = 9.223372036854776E18 or x = 9.223372036854776E18 or x = 9.223372036854776E18;&lt;/p&gt;

&lt;p&gt;Or even simpler, because the DOUBLE representation of all four values happens to be the same:&lt;/p&gt;

&lt;p&gt;  select * from t where x = 9.223372036854776E18;&lt;/p&gt;

&lt;p&gt;Now, 8.2 &amp;lt;comparison predicate&amp;gt; - General Rules, says this:&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) Numbers are compared with respect to their algebraic value.&lt;/p&gt;

&lt;p&gt;No more details than that, I&apos;m afraid. And no mentioning about converting the operands to the dominant type, so far as I can see.&lt;/p&gt;

&lt;p&gt;Derby currently returns these three rows for the query:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from t where x = 9.223372036854776E18;&lt;br/&gt;
X                   &lt;br/&gt;
--------------------&lt;br/&gt;
9223372036854775805 &lt;br/&gt;
9223372036854775806 &lt;br/&gt;
9223372036854775807 &lt;/p&gt;

&lt;p&gt;3 rows selected&lt;/p&gt;

&lt;p&gt;I&apos;m not completely convinced that all those three values have the same algebraic value as 9.223372036854776E18. But in any case I think changing how Derby performs numeric comparisons is outside the scope of this issue.&lt;/p&gt;

&lt;p&gt;So how&apos;s this for a plan? In this issue, let&apos;s assume Derby&apos;s equality comparison operator does the right thing. The goal for now should be to make an &amp;lt;in value list&amp;gt; behave the same way as the ANY query the SQL standard says it should be equivalent to. We should have tests that use the results from the equivalent ANY queries as canons, and those tests would also alert us if we later make changes to the comparison operator in a way that makes ANY and IN behave inconsistently.&lt;/p&gt;</comment>
                            <comment id="13536036" author="bryanpendleton" created="Wed, 19 Dec 2012 15:30:51 +0000"  >&lt;p&gt;Thank you Knut Anders for digging deep into the standard to explore these topics.&lt;/p&gt;

&lt;p&gt;I see no holes in your logic; it seems unavoidable that (a) these queries are intended to be&lt;br/&gt;
clearly-defined by the standard, and (b) Derby is doing it wrong. I can &lt;b&gt;wish&lt;/b&gt; that the&lt;br/&gt;
standard were written differently, but it ain&apos;t so... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I think your proposed approach is excellent.&lt;/p&gt;

&lt;p&gt;Hopefully the fact that we currently seem to behave correctly in the ANY queries and&lt;br/&gt;
in the table value constructor (VALUES ... ) give some clues about what&apos;s needed to&lt;br/&gt;
be included in the other queries to give them the right form.&lt;/p&gt;

&lt;p&gt;Am I right in conceptualizing this as &quot;we need to be implicitly casting the values to&lt;br/&gt;
the correct type in certain situations, and we&apos;re currently not doing so.&quot;?&lt;/p&gt;</comment>
                            <comment id="13536050" author="bryanpendleton" created="Wed, 19 Dec 2012 15:42:48 +0000"  >&lt;p&gt;A little bit of quick searching confirms my suspicion that most databases have this problem,&lt;br/&gt;
and that comparison of floating point values can lead to confusing results:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2567434/mysql-floating-point-comparison-issues&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://stackoverflow.com/questions/2567434/mysql-floating-point-comparison-issues&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://yongjun-jiao.blogspot.com/2011/11/floating-point-number-equality.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://yongjun-jiao.blogspot.com/2011/11/floating-point-number-equality.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kb.askmonty.org/en/numeric-operations/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://kb.askmonty.org/en/numeric-operations/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It might be worth, as a related issue or sub-task, considering ways to improve our&lt;br/&gt;
documentation in this area so that we guide users toward safer ways of comparing&lt;br/&gt;
floating point values, e.g., some form of:&lt;/p&gt;

&lt;p&gt;    WHERE ABS(float_column - other_value) &amp;lt; small_epsilon&lt;/p&gt;

&lt;p&gt;with an appropriate suggestion for what small_epsilon should be.&lt;/p&gt;</comment>
                            <comment id="13536117" author="knutanders" created="Wed, 19 Dec 2012 16:52:27 +0000"  >&lt;p&gt;Thanks, Bryan.&lt;/p&gt;

&lt;p&gt;&amp;gt; Am I right in conceptualizing this as &quot;we need to be implicitly casting the values to&lt;br/&gt;
&amp;gt; the correct type in certain situations, and we&apos;re currently not doing so.&quot;?&lt;/p&gt;

&lt;p&gt;For the values in the IN list, I think that&apos;s the right way to conceptualize it.&lt;/p&gt;

&lt;p&gt;For the simple comparison operations (for example a predicate such as 9223372036854775805 = 9.223372036854776E18) I&apos;m not so sure. But that&apos;s the part of the problem that I suggested we didn&apos;t focus on in this issue.&lt;/p&gt;

&lt;p&gt;I think it&apos;s a good idea to make our docs say that equality comparisons involving floating point values may have surprising results.&lt;/p&gt;</comment>
                            <comment id="13536889" author="knutanders" created="Thu, 20 Dec 2012 09:28:28 +0000"  >&lt;p&gt;I changed the title of the bug since the problem is not restricted to constants.&lt;/p&gt;

&lt;p&gt;Here&apos;s another example that we may add to our tests once the bug is fixed:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; create table t3(b1 bigint, b2 bigint, d double);&lt;br/&gt;
0 rows inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; insert into t3 values (9223372036854775805, 9223372036854775806, 1);&lt;br/&gt;
1 row inserted/updated/deleted&lt;br/&gt;
ij&amp;gt; select * from t3 where b1 in (b2, d);&lt;br/&gt;
B1                  |B2                  |D                     &lt;br/&gt;
----------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;0 rows selected&lt;br/&gt;
ij&amp;gt; select * from t3 where b1 in (values b2, d);&lt;br/&gt;
B1                  |B2                  |D                     &lt;br/&gt;
----------------------------------------------------------------&lt;br/&gt;
9223372036854775805 |9223372036854775806 |1.0                   &lt;/p&gt;

&lt;p&gt;1 row selected&lt;/p&gt;

&lt;p&gt;The two select queries return different results, although the standard says they should be equivalent.&lt;/p&gt;</comment>
                            <comment id="13537085" author="knutanders" created="Thu, 20 Dec 2012 15:37:00 +0000"  >&lt;p&gt;Attaching a patch (d6017-1a-duplicates.diff) for the problem we see when duplicates are eliminated from the IN list.&lt;/p&gt;

&lt;p&gt;The original code would detect that an IN list consisting of the values (9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776E18) only contained one distinct value after conversion to the dominant type. It would arbitrarily pick the first value and replace the IN predicate with leftOperand = &lt;br/&gt;
9223372036854775805.&lt;/p&gt;

&lt;p&gt;The patch changes this optimization so that it casts the right operand in the comparison to the dominant type if neither of the two operands already is of the dominant type.&lt;/p&gt;

&lt;p&gt;It also adds a test case to verify that the expected results are produced.&lt;/p&gt;

&lt;p&gt;All the regression tests ran cleanly with the patch.&lt;/p&gt;

&lt;p&gt;The patch doesn&apos;t address any of the other problems discussed in this issue.&lt;/p&gt;</comment>
                            <comment id="13537094" author="bryanpendleton" created="Thu, 20 Dec 2012 15:50:51 +0000"  >&lt;p&gt;+1 to the duplicates patch.&lt;/p&gt;

&lt;p&gt;I notice that you&apos;ve mostly been experimenting with values that become&lt;br/&gt;
approximate when converted from LONG to DOUBLE.&lt;/p&gt;

&lt;p&gt;Are there similar problems when mixing the 4-byte-floating-point REAL&lt;br/&gt;
with the 8-byte-floating-point DOUBLE?&lt;/p&gt;

&lt;p&gt;Or is it generally integer-to-floating-point where the most problems arise?&lt;/p&gt;</comment>
                            <comment id="13537406" author="knutanders" created="Thu, 20 Dec 2012 21:43:27 +0000"  >&lt;p&gt;Thanks for looking at the patch, Bryan.&lt;/p&gt;

&lt;p&gt;I&apos;ll look into the other data types and see if I find similar problems. If promoting a REAL to a DOUBLE could cause loss of precision (can it?), they might show the same problem. Promoting an INT to a REAL could lose precision too, but I think we always promote to DOUBLE when mixing INTs and REALs (per &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;). It&apos;s worth testing, though.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://db.apache.org/derby/docs/10.9/ref/rrefsqlj27767.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/docs/10.9/ref/rrefsqlj27767.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13537829" author="knutanders" created="Fri, 21 Dec 2012 12:52:38 +0000"  >&lt;p&gt;For the problem fixed by the 1a patch, I didn&apos;t find any problematic combinations except BIGINT/DOUBLE. As far as I can see REAL/DOUBLE doesn&apos;t have the problem because the conversion from REAL to DOUBLE never loses precision. And mixing INT and REAL is not a problem either, as the problem only affects IN lists that consists entirely of literals, and Derby&apos;s grammar doesn&apos;t have any way to express REAL literals (all approximate number literals get the type DOUBLE). You can of course cast a DOUBLE literal to a REAL, but then it&apos;s no longer a ConstantNode, and the problematic optimization is not applied.&lt;/p&gt;

&lt;p&gt;However, mixing REAL and INT seems to have similar problems as DOUBLE and BIGINT when using non-constant expressions in the IN list. Here&apos;s one example:&lt;/p&gt;

&lt;p&gt;ij&amp;gt; select * from tt where r1 in (i1, r2);&lt;br/&gt;
I1         |R1           |R2           &lt;br/&gt;
---------------------------------------&lt;br/&gt;
2147483645 |2.14748365E9 |2.14748365E9 &lt;br/&gt;
2147483645 |2.14748365E9 |0.0          &lt;/p&gt;

&lt;p&gt;2 rows selected&lt;br/&gt;
ij&amp;gt; select * from tt where r1 in (values i1, r2);&lt;br/&gt;
I1         |R1           |R2           &lt;br/&gt;
---------------------------------------&lt;br/&gt;
2147483645 |2.14748365E9 |2.14748365E9 &lt;/p&gt;

&lt;p&gt;1 row selected&lt;/p&gt;

&lt;p&gt;The two queries are supposed to be equivalent, but they return different results.&lt;/p&gt;

&lt;p&gt;I think the former query performs both of the comparisons (r1=i1, r1=r2) using REAL semantics, whereas the latter query uses DOUBLE semantics because the (values i1,r2) sub-query has DOUBLE as its row type. &lt;/p&gt;</comment>
                            <comment id="13537831" author="knutanders" created="Fri, 21 Dec 2012 12:53:36 +0000"  >&lt;p&gt;Committed the 1a patch to trunk, revision 1424889.&lt;/p&gt;</comment>
                            <comment id="13578355" author="knutanders" created="Thu, 14 Feb 2013 13:20:58 +0000"  >&lt;p&gt;Attaching d6017-2a-cast-if-needed.diff which solves the remaining IN&lt;br/&gt;
list problems discussed in this issue (except the second anomaly&lt;br/&gt;
mentioned in my 18/Dec/12 21:58 comment, as that&apos;s an IN subquery, not&lt;br/&gt;
an IN list).&lt;/p&gt;

&lt;p&gt;The 2a patch replaces the fix in the 1a patch with a more general one&lt;br/&gt;
that also addresses the problems with non-constants.&lt;/p&gt;

&lt;p&gt;The problems are caused by the comparison operations being performed&lt;br/&gt;
using the semantics of the dominant type of the two values being&lt;br/&gt;
compared. It should be performed using the dominant type of &lt;b&gt;all&lt;/b&gt; the&lt;br/&gt;
values in the IN predicate.&lt;/p&gt;

&lt;p&gt;To fix this, the patch makes InListOperatorNode.preprocess() cast the&lt;br/&gt;
left operand to the dominant type if some of the comparisons otherwise&lt;br/&gt;
would have been performed using a non-dominant type.&lt;/p&gt;

&lt;p&gt;The fix works because the left operand is part of every single&lt;br/&gt;
comparison operation, and as long as one of the values being compared&lt;br/&gt;
is of the dominant type, the comparison will be performed using the&lt;br/&gt;
semantics of that type.&lt;/p&gt;

&lt;p&gt;The cast is not added if the left operand is already of the dominant&lt;br/&gt;
type, in which case the cast would be redundant. Also, it is not added&lt;br/&gt;
if all the values in the right operand (the IN list) are of the&lt;br/&gt;
dominant type. In that case, too, every single comparison operation&lt;br/&gt;
would include one value of the dominant type, and the correct&lt;br/&gt;
semantics would be used.&lt;/p&gt;

&lt;p&gt;In all other cases, a cast is added to ensure that the comparisons are&lt;br/&gt;
performed using the right type.&lt;/p&gt;

&lt;p&gt;All the regression tests ran cleanly with the patch.&lt;/p&gt;

&lt;p&gt;Description of the changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;engine/org/apache/derby/impl/sql/compile/InListOperatorNode.java&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Made preprocess() cast the left operand to the dominant type if&lt;br/&gt;
  necessary.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed the cast added by the 1a patch for the case where all values&lt;br/&gt;
  in the IN list represented the same constant value, as that code was&lt;br/&gt;
  made redundant by the new fix.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;engine/org/apache/derby/iapi/types/DataType.java&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Improved comment about how types are handled when evaluating an IN&lt;br/&gt;
  predicate.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;engine/org/apache/derby/iapi/types/DataTypeDescriptor.java&lt;/li&gt;
	&lt;li&gt;engine/org/apache/derby/impl/sql/compile/ValueNodeList.java&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed unnecessary throws clauses. Did this so that I didn&apos;t have&lt;br/&gt;
  to add another unnecessary throws clause to a helper method I added&lt;br/&gt;
  to InListOperatorNode.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;testing/org/apache/derbyTesting/functionTests/tests/lang/InPredicateTest.java&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added test cases from previous comments on this issue. They work as&lt;br/&gt;
  expected with the patch.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13582028" author="knutanders" created="Wed, 20 Feb 2013 08:20:48 +0000"  >&lt;p&gt;Committed revision 1448025.&lt;/p&gt;

&lt;p&gt;I&apos;ve logged &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6080&quot; title=&quot;Cast to same type changes result with IN subquery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6080&quot;&gt;DERBY-6080&lt;/a&gt; for the IN subquery anomaly. Resolving this issue.&lt;/p&gt;</comment>
                            <comment id="13587605" author="knutanders" created="Tue, 26 Feb 2013 21:53:04 +0000"  >&lt;p&gt;The test for this issue is failing on weme. For example here: &lt;a href=&quot;http://people.apache.org/~myrnavl/derby_test_results/main/windows/testlog/weme6.2/1450000-suites.All_diff.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://people.apache.org/~myrnavl/derby_test_results/main/windows/testlog/weme6.2/1450000-suites.All_diff.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There was 1 failure:&lt;br/&gt;
1) testMixedTypes(org.apache.derbyTesting.functionTests.tests.lang.InPredicateTest)junit.framework.AssertionFailedError: Column value mismatch @ column &apos;R1&apos;, row 1:&lt;br/&gt;
    Expected: &amp;gt;2.14748365E9&amp;lt;&lt;br/&gt;
    Found:    &amp;gt;2.1474836E9&amp;lt;&lt;/p&gt;

&lt;p&gt;It looks like doubles are formatted differently on that platform. I&apos;ll see if I can make the test more robust against formatting differences.&lt;/p&gt;</comment>
                            <comment id="13588179" author="knutanders" created="Wed, 27 Feb 2013 09:46:44 +0000"  >&lt;p&gt;Attaching d6017-3a-weme-test-failure.diff which makes the test case use a different assert method that checks the actual numeric values returned by the result set, rather than just checking the string representation of the values. Hopefully, this is enough to get the test to pass on weme.&lt;/p&gt;

&lt;p&gt;Committed revision 1450695.&lt;/p&gt;

&lt;p&gt;I&apos;ll keep this bug open until there has been a clean run on weme in the nightly tests. I don&apos;t have a copy of weme to test it on myself.&lt;/p&gt;</comment>
                            <comment id="13589772" author="myrna" created="Thu, 28 Feb 2013 18:38:15 +0000"  >&lt;p&gt;Looks like the run for weme was clean last night, using a build of trunk sync-ed up to revision 1451076. Thanks for noticing this failure, and fixing it.&lt;/p&gt;</comment>
                            <comment id="13592208" author="knutanders" created="Mon, 4 Mar 2013 13:47:14 +0000"  >&lt;p&gt;Thanks, Myrna. Closing the issue again.&lt;/p&gt;</comment>
                            <comment id="13729484" author="kmarsden" created="Mon, 5 Aug 2013 13:54:47 +0100"  >&lt;p&gt;Assign to myself for backport&lt;/p&gt;</comment>
                            <comment id="13729650" author="jira-bot" created="Mon, 5 Aug 2013 18:05:14 +0100"  >&lt;p&gt;Commit 1510609 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kmarsden&quot; class=&quot;user-hover&quot; rel=&quot;kmarsden&quot;&gt;Kathey Marsden&lt;/a&gt; in branch &apos;code/branches/10.9&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1510609&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1510609&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6017&quot; title=&quot;IN lists with mixed types may return wrong results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6017&quot;&gt;&lt;del&gt;DERBY-6017&lt;/del&gt;&lt;/a&gt; IN lists with mixed types may return wrong results&lt;/p&gt;

&lt;p&gt;merge from trunk revisions 1424889, 1448025, 1450695&lt;br/&gt;
Contributed by Knut Anders Hatlen&lt;/p&gt;</comment>
                            <comment id="13731929" author="jira-bot" created="Wed, 7 Aug 2013 13:45:56 +0100"  >&lt;p&gt;Commit 1511288 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kmarsden&quot; class=&quot;user-hover&quot; rel=&quot;kmarsden&quot;&gt;Kathey Marsden&lt;/a&gt; in branch &apos;code/branches/10.8&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1511288&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1511288&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-6017&quot; title=&quot;IN lists with mixed types may return wrong results&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-6017&quot;&gt;&lt;del&gt;DERBY-6017&lt;/del&gt;&lt;/a&gt;  IN lists with mixed types may return wrong results&lt;/p&gt;

&lt;p&gt;merged from trunk 1424889, 1448025, 1450695&lt;br/&gt;
Contrubuted by Knut Anders Hatlen&lt;/p&gt;</comment>
                            <comment id="13731931" author="kmarsden" created="Wed, 7 Aug 2013 13:46:53 +0100"  >&lt;p&gt;Assign back to Knut after backport.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12360835">DERBY-2256</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12633152">DERBY-6080</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12656863">DERBY-6289</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12561904" name="d6017-1a-duplicates.diff" size="8485" author="knutanders" created="Thu, 20 Dec 2012 15:37:00 +0000"/>
                            <attachment id="12569339" name="d6017-2a-cast-if-needed.diff" size="11787" author="knutanders" created="Thu, 14 Feb 2013 13:20:58 +0000"/>
                            <attachment id="12571173" name="d6017-3a-weme-test-failure.diff" size="2034" author="knutanders" created="Wed, 27 Feb 2013 09:46:44 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10366"><![CDATA[Wrong query result]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 18 Dec 2012 17:02:03 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>300015</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10424"><![CDATA[Repro attached]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyzzwn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>243992</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>