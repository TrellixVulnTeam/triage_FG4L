<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:44:10 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-690/DERBY-690.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-690] Add scrollable, updatable, insensitive result sets</title>
                <link>https://issues.apache.org/jira/browse/DERBY-690</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;JDBC result sets are created with three properties: type, concurrency&lt;br/&gt;
and holdability. The type can be one of TYPE_FORWARD_ONLY,&lt;br/&gt;
TYPE_SCROLL_INSENSITIVE and TYPE_SCROLL_SENSITIVE. The concurrency can&lt;br/&gt;
be one of CONCUR_READ_ONLY and CONCUR_UPDATABLE. The holdability can&lt;br/&gt;
be one of HOLD_CURSORS_OVER_COMMIT and CLOSE_CURSORS_AT_COMMIT.&lt;/p&gt;

&lt;p&gt;JDBC allows the full cross product of these. SQL 2003 prohibits the&lt;br/&gt;
combination &lt;/p&gt;
{TYPE_SCROLL_INSENSITIVE, CONCUR_UPDATABLE}
&lt;p&gt;, but this&lt;br/&gt;
combination is supported by some vendors, notably Oracle.&lt;/p&gt;

&lt;p&gt;Currently, Derby supports JDBC result sets in a limited&lt;br/&gt;
way. Holdability is supported. Furthermore, the following is&lt;br/&gt;
supported: &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;forward-only, read-only&lt;/li&gt;
	&lt;li&gt;forward-only, updatable (update, delete, but not insert)&lt;br/&gt;
	     Also, in the network driver, support for some data types&lt;br/&gt;
	     conversions is missing.&lt;/li&gt;
	&lt;li&gt;scroll insensitive, read-only&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We (Fernanda and Andreas will cooperate with me on this) propose a&lt;br/&gt;
plan to add support for the combination:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;scroll insensitive, updatable&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;for both the embedded driver and the network client driver. &lt;br/&gt;
As a part of this we would also like to add the missing insert&lt;br/&gt;
operation to the &lt;/p&gt;
{forward-only, updatable}
&lt;p&gt; result sets (JIRA-100), and&lt;br/&gt;
remove the requirement for an explicit &quot;FOR UPDATE&quot; clause in the SQL&lt;br/&gt;
query to achieve updatability if CONCUR_UPDATABLE is specified&lt;br/&gt;
(JIRA-231).&lt;/p&gt;

&lt;p&gt;The full proposal text is uploaded as an attachment, including a proposed&lt;br/&gt;
functional specification.&lt;/p&gt;

&lt;p&gt;This JIRA will  be used to track sub-issues for this effort. The sub-issues will be linked back to this issue.&lt;/p&gt;


</description>
                <environment></environment>
        <key id="12325456">DERBY-690</key>
            <summary>Add scrollable, updatable, insensitive result sets</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dagw">Dag H. Wanvik</assignee>
                                    <reporter username="dagw">Dag H. Wanvik</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 Nov 2005 02:24:22 +0000</created>
                <updated>Thu, 2 May 2013 03:28:57 +0100</updated>
                            <resolved>Fri, 15 Sep 2006 16:25:34 +0100</resolved>
                                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                                                            <comments>
                            <comment id="12357048" author="dagw" created="Wed, 9 Nov 2005 02:28:54 +0000"  >&lt;p&gt;Proposal text uploaded.&lt;/p&gt;</comment>
                            <comment id="12366817" author="andreask" created="Sat, 18 Feb 2006 02:20:36 +0000"  >&lt;p&gt;Attaching a writeup for upcoming patch for SUR (files writeup-v1.html and SURChanges-v1.pdf)&lt;/p&gt;</comment>
                            <comment id="12367237" author="fernanda" created="Wed, 22 Feb 2006 03:08:33 +0000"  >&lt;p&gt;This is a first cut at a patch for SUR. It corresponds to the description uploaded earlier as&lt;br/&gt;
&lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12323122/writeup-v1.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12323122/writeup-v1.html&lt;/a&gt;. It passes derbyall,&lt;br/&gt;
and although the many tests written under &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-934&quot; title=&quot;create a set of JUnit tests for Scrollable Updatable Resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-934&quot;&gt;&lt;del&gt;DERBY-934&lt;/del&gt;&lt;/a&gt; have been enabled as part of this patch,&lt;br/&gt;
more tests will be written.&lt;/p&gt;

&lt;p&gt;There remains an issue around in-line compress, see the discussion in this mail thread:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/conflict-detection-strategies-t1120376.html#a2960144&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/conflict-detection-strategies-t1120376.html#a2960144&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12367458" author="djd" created="Thu, 23 Feb 2006 11:27:58 +0000"  >&lt;p&gt;Comments on writeup-v1.html.&lt;/p&gt;

&lt;p&gt;In the conflict section you treat read uncommitted and read-committed as the same, but read-uncommitted isolation level will not get any locks, at least that&apos;s what I thought. Should we even allow updateable result sets when the isolation level is read-uncommitted?&lt;/p&gt;

&lt;p&gt;The read uncommitted/read-committed talks about the row being deleted, but the row being deleted by the same transaction is not discussed in the serializable/repeatable read section.&lt;/p&gt;

&lt;p&gt;&quot; If the user renavigates to the row, the lock will be reset,&quot; - what does reset mean here, is it the lock will be obtained again?&lt;/p&gt;

&lt;p&gt;I didn&apos;t see any explaination how how the update or delete is performed using the RowLocation. The forward only ResultSet uses positioned SQL statements to perform the update, is that the case here? If not, how are you guaranteeing all the associated work is performed on an update or delete, such as firing triggers, enforcing constraints etc?&lt;/p&gt;

&lt;p&gt;&quot;NOTE: Own changes means changes made by the result set itself, while other changes means changes made by other transactions of other objects in the same transaction. &quot; _  I think you mean &apos;other transactions OR other objects in the same transaction&apos;&lt;/p&gt;

&lt;p&gt;&quot;In order to be able to view own changes, whenever the updateRow() method is called, the hashtable has to be updated with the new values for the updated columns&quot; - how is this being implemented, couldn&apos;t see any mention of it.&lt;/p&gt;
</comment>
                            <comment id="12367487" author="fernanda" created="Thu, 23 Feb 2006 18:40:51 +0000"  >&lt;p&gt;I hope this answers to some of your questions:&lt;/p&gt;

&lt;p&gt;Read-uncommited isolation level does aquire locks for updatable forward-only result sets, the same behavior has been kept on scrollable insensitve updatable result sets.&lt;/p&gt;

&lt;p&gt;If a transaction attempts to delete a row that have previously been deleted (either in the same trasaction, or by another transaction) a warning will be added to the result set (for an updateRow or deleteRow call) or to the statement (for positioned SQL statements).&lt;/p&gt;

&lt;p&gt;The update or delete is performed using positioned SQL statements as it has been done for forward only ResultSets. The RowLocation is used when navigating to position the scan controller at the correct row, and aquiring locks when necessary. Since the scan controller is positioned on the correct row, and the necessary locks are aquired, it is possible to perform a positioned SQL statement for both deletes and updates as it has been done for forward only result sets. &lt;/p&gt;

&lt;p&gt;Positioned SQL statements are being used so the associated work on update or delete should happen in the same way as for other positioned SQL statements. As mentioned when submitting the patch, more tests will be written for SUR, and checking that the associated work is performed on an update or delete, is part of the tests that are left to be written.&lt;/p&gt;

&lt;p&gt;Two methods have been added to NoPutResultSet, updateCachedRow(ExecRow row) and markCachedRowAsDeleted(), in order to view own changes. They are called from UpdateResultSet.open() and DeleteResultSet.open() respectively and  they propagate the changes done to the current row to ScrollInsensitiveResultSet, so that the hashtable can be updated.&lt;/p&gt;

&lt;p&gt;&quot;NOTE: Own changes means changes made by the result set itself, while other changes means changes made by other transactions of other objects in the same transaction. &quot; _ I think you mean &apos;other transactions OR other objects in the same transaction&apos;. That&apos;s correct, it is supposed to be &apos;other transactions OR other objects in the same transaction&apos;.&lt;/p&gt;</comment>
                            <comment id="12367531" author="djd" created="Fri, 24 Feb 2006 01:56:33 +0000"  >&lt;p&gt;Thanks for the answers, it would be good to update the writeup to reflect your answers.&lt;/p&gt;

&lt;p&gt;Fernanda wrote:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Two methods have been added to NoPutResultSet, updateCachedRow(ExecRow row) and markCachedRowAsDeleted(), in order to view own changes. They are called from UpdateResultSet.open() and DeleteResultSet.open() respectively and they propagate the changes done to the current row to ScrollInsensitiveResultSet, so that the hashtable can be updated.&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;So, to confirm, this means the updated row in the result set will reflect the state of the row in the database and not the values set by the updateRow() call? Good to state here exactly what the behaviour is expected to be. So if I update a column to value 10 using rs.updateRow(), but some processing in the SQL positioned update (say a fired trigger)  results in the column being stored as 20, then will the ResultSet have 20 or 10? Does the answer have any effect on the &quot;own vs others&quot; updates being visible?&lt;/p&gt;
</comment>
                            <comment id="12367654" author="dagw" created="Fri, 24 Feb 2006 22:40:48 +0000"  >&lt;p&gt;Dan wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; So, to confirm, this means the updated row in the result set will&lt;br/&gt;
&amp;gt; reflect the state of the row in the database and not the values set&lt;br/&gt;
&amp;gt; by the updateRow() call? Good to state here exactly what the&lt;br/&gt;
&amp;gt; behaviour is expected to be. So if I update a column to value 10&lt;br/&gt;
&amp;gt; using rs.updateRow(), but some processing in the SQL positioned&lt;br/&gt;
&amp;gt; update (say a fired trigger) results in the column being stored as&lt;br/&gt;
&amp;gt; 20, then will the ResultSet have 20 or 10? &lt;/p&gt;

&lt;p&gt;No, any further changes resulting from actions of the trigger will not be &lt;br/&gt;
reflected in the result set in the current implementation.&lt;/p&gt;

&lt;p&gt;&amp;gt; Does the answer have any effect on the &quot;own vs others&quot; updates being&lt;br/&gt;
&amp;gt; visible?&lt;/p&gt;

&lt;p&gt;Yes, I would say so. I tried to see if JDBC had anything to say on&lt;br/&gt;
whether a trigger action would constitute an &quot;own&quot; change, but could&lt;br/&gt;
not find anything. I think it is questionable to treat it is an &quot;own&quot;&lt;br/&gt;
change, since JDBC classifies even changes via a positioned update on&lt;br/&gt;
the result set&apos;s cursor as &quot;others&quot; (although we treat it as &quot;own&quot; in&lt;br/&gt;
our implementation as stated in the write-up). &lt;br/&gt;
That is, &quot;others&quot; are not limited to other transactions, but include&lt;br/&gt;
other changes made through other statement objects.&lt;/p&gt;

&lt;p&gt;Since a trigger executes a separate SQL statement one could argue that&lt;br/&gt;
this change happens via another statement object, and thus constitutes&lt;br/&gt;
an &quot;others&quot; change. But I don&apos;t think the answer is obvious. Since SQL&lt;br/&gt;
doesn&apos;t cater for updatable result sets for scrollable insensitive&lt;br/&gt;
cursors, there is no help to be gleaned from the standard. Will update&lt;br/&gt;
the write-up for now.&lt;/p&gt;</comment>
                            <comment id="12367668" author="djd" created="Sat, 25 Feb 2006 01:42:57 +0000"  >&lt;p&gt;&amp;gt; Dag H. Wanvik commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-690&quot; title=&quot;Add scrollable, updatable, insensitive result sets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-690&quot;&gt;&lt;del&gt;DERBY-690&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; -------------------------------------&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Dan wrote:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;So, to confirm, this means the updated row in the result set will&lt;br/&gt;
&amp;gt;&amp;gt;reflect the state of the row in the database and not the values set&lt;br/&gt;
&amp;gt;&amp;gt;by the updateRow() call? Good to state here exactly what the&lt;br/&gt;
&amp;gt;&amp;gt;behaviour is expected to be. So if I update a column to value 10&lt;br/&gt;
&amp;gt;&amp;gt;using rs.updateRow(), but some processing in the SQL positioned&lt;br/&gt;
&amp;gt;&amp;gt;update (say a fired trigger) results in the column being stored as&lt;br/&gt;
&amp;gt;&amp;gt;20, then will the ResultSet have 20 or 10? &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; No, any further changes resulting from actions of the trigger will not be &lt;br/&gt;
&amp;gt; reflected in the result set in the current implementation.&lt;/p&gt;

&lt;p&gt;My thought here is that the updated row in the ResultSet would then&lt;br/&gt;
reflect a state of the database that never occurred. This seems in&lt;br/&gt;
conflict with all isolation levels except read-uncommitted. I can&apos;t&lt;br/&gt;
think of another situation where an application using Derby can see a&lt;br/&gt;
row in that state (excluding read-uncommitted).&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;Dag&amp;#39;s useful own vs. others discussion snipped&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;If &quot;own&quot; means changes made through the ResultSet, then one could say&lt;br/&gt;
that side-effect changes are &quot;own&quot;, since they resulted from the&lt;br/&gt;
ResultSet&apos;s updateRow. Since an UPDATE statement and its side-effects&lt;br/&gt;
are atomic, then the updateRow must be atomic.&lt;/p&gt;</comment>
                            <comment id="12367672" author="djd" created="Sat, 25 Feb 2006 01:51:21 +0000"  >&lt;p&gt;Though currently it may not be possible in Derby to have side-effects on  an UPDATE statement. Currently triggers&lt;br/&gt;
are read-only on the firing table. I thought there might be some possibility of working around this restriction by&lt;br/&gt;
having a trigger on A that updates B which then fires a trigger to update A. But I think this will just recurse, hit the&lt;br/&gt;
trigger limit and throw an exception.&lt;/p&gt;

&lt;p&gt;At some point in the future it will be possible to have side-effects, users have requested before triggers that can modify&lt;br/&gt;
the NEW values, there is some outstanding issue for allowing procedures in trigger statements, which could open&lt;br/&gt;
up a lot of possibilities.&lt;/p&gt;

&lt;p&gt;Maybe there are other ways to get side-effects on an UPDATE?&lt;/p&gt;

&lt;p&gt;If no side-effects are possible then the proposed behaviour is ok, though the assumption should be clearly stated in the spec.&lt;/p&gt;</comment>
                            <comment id="12367693" author="dagw" created="Sat, 25 Feb 2006 03:43:27 +0000"  >&lt;p&gt;Thanks for your comments!&lt;/p&gt;

&lt;p&gt;Dan wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; My thought here is that the updated row in the ResultSet would then&lt;br/&gt;
&amp;gt; reflect a state of the database that never occurred. This seems in&lt;br/&gt;
&amp;gt; conflict with all isolation levels except read-uncommitted. I can&apos;t&lt;br/&gt;
&amp;gt; think of another situation where an application using Derby can see&lt;br/&gt;
&amp;gt; a row in that state (excluding read-uncommitted).&lt;/p&gt;

&lt;p&gt;Hmm, not quite sure what you mean here. Let me sum up my&lt;br/&gt;
understanding. Other (read-uncommitted) transactions would see all the&lt;br/&gt;
changes including the (trigger) side-effects. And so would the present&lt;br/&gt;
transaction when querying the data base via other statement objects&lt;br/&gt;
than the result set. The question, then, is what changes should be&lt;br/&gt;
reflected in the result set itself as a consequence of the updateRow&lt;br/&gt;
(or deleteRow) trigger action. Even if we did reflect the trigger&lt;br/&gt;
action&apos;s changes to rows which are part of the result set, that data&lt;br/&gt;
set is still not the same as the (uncommitted) view in the database &lt;br/&gt;
for two reasons:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;other changes made in the transaction (via other statement objects)&lt;br/&gt;
  are &quot;other&quot;s and not reflected in the result set. If they were, this&lt;br/&gt;
  would breach JDBC&apos;s stated semantics as far as I can understand.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Rows inserted via ResultSet#insertRow are not visible, either, in&lt;br/&gt;
  the present implementation. This is optional, though. JDBC provides&lt;br/&gt;
  metadata calls to allow for variation here.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In light of this, I think the data in the (insensitive) result set&lt;br/&gt;
should be viewed as a convenience, rather the &quot;truth&quot;; insensitive (by&lt;br/&gt;
design) result sets provide more isolation than the current isolation&lt;br/&gt;
level requires. But I agree this behavior is not obvious and should be&lt;br/&gt;
documented clearly.&lt;/p&gt;

&lt;p&gt;&amp;gt; Though currently it may not be possible in Derby to have&lt;br/&gt;
&amp;gt; side-effects on an UPDATE statement. Currently triggers are&lt;br/&gt;
&amp;gt; read-only on the firing table.&lt;/p&gt;

&lt;p&gt;That would alleviate a user&apos;s potential expectation problem. But is this&lt;br/&gt;
correct? I checked the reference manual for restrictions and could not&lt;br/&gt;
find this. I also tried it and it seemed to work, cf. sample trigger:&lt;/p&gt;

&lt;p&gt;st.execute(&quot;CREATE TABLE tmpResultSet (id int primary key, name varchar(50))&quot;);&lt;br/&gt;
st.execute(&quot;CREATE TRIGGER trig AFTER UPDATE OF id ON tmpResultSet&quot;+&lt;br/&gt;
        &quot; REFERENCING NEW AS UPDATEDROW &quot;+&lt;br/&gt;
        &quot; FOR EACH ROW MODE DB2SQL UPDATE tmpResultSet SET name=&apos;triggered&apos; &quot;+&lt;br/&gt;
        &quot; WHERE UPDATEDROW.id = 10&quot;);&lt;/p&gt;

&lt;p&gt;An updateRow of a row&apos;s &apos;id&apos; to 10 caused the trigger action here.&lt;br/&gt;
But maybe I am missing something here.&lt;/p&gt;

</comment>
                            <comment id="12367713" author="fernanda" created="Sat, 25 Feb 2006 06:29:05 +0000"  >&lt;p&gt;Here is a new version of the write-up and patch.&lt;/p&gt;</comment>
                            <comment id="12367771" author="djd" created="Sun, 26 Feb 2006 02:20:31 +0000"  >&lt;p&gt;Dag wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Dan wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; My thought here is that the updated row in the ResultSet would then&lt;br/&gt;
&amp;gt;&amp;gt; reflect a state of the database that never occurred. This seems in&lt;br/&gt;
&amp;gt;&amp;gt; conflict with all isolation levels except read-uncommitted. I can&apos;t&lt;br/&gt;
&amp;gt;&amp;gt; think of another situation where an application using Derby can see&lt;br/&gt;
&amp;gt;&amp;gt; a row in that state (excluding read-uncommitted).&lt;/p&gt;

&lt;p&gt;&amp;gt; Hmm, not quite sure what you mean here.&lt;br/&gt;
&amp;gt; Let me sum up my understanding&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;Dag&amp;#39;s correct understanding snipped&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I agree Dag with what you are saying, but in all the cases you describe every individual row&lt;br/&gt;
represents a state of the database at some point in time. The trouble I have with the SUR updated row is&lt;br/&gt;
 that it may not match a valid state of the database. No user at any time could have&lt;br/&gt;
issued a select from the database and seen those values. The row may also be self-inconsistent,&lt;br/&gt;
that is, column values that are inconsistent with each other.&lt;/p&gt;

&lt;p&gt;I think this becomes important when the database is enforcing business logic through triggers&lt;br/&gt;
(or any other mechanism that can modify columns on an UPDATE statement).&lt;/p&gt;

&lt;p&gt;If an old application updates a discount column in a row from 15% to 30% but new database side business logic has been&lt;br/&gt;
put in place to limit discounts to 25%, then anyone selecting that row from the database sees either 15% or 25%, never 30%.&lt;br/&gt;
However, with SUR the application has a scrollable ResultSet with a row that has discount 30%, since the result set is scrollable&lt;br/&gt;
this incorrect value of 30% can continue to be displayed to the end user of the application. This just seems wrong to me.&lt;/p&gt;

&lt;p&gt;An example for the row self-inconsistent state, is an update of a customer&apos;s address. If there is a calculated column&lt;br/&gt;
from the address, eg. zip code for the US, post code for the UK, sales-region for a sales application, then the updated&lt;br/&gt;
row in the SUR will have a mismatch. E.g. a Californian zip code for a New York address.&lt;/p&gt;

&lt;p&gt;Maybe as you say, we can just document this, and that applications should not rely on this behaviour.&lt;br/&gt;
To, me it seems like the row in the ResultSet should be either not updated or updated with&lt;br/&gt;
the full effect of the updateRow() operation (see &quot;own&quot; changes).&lt;/p&gt;

&lt;p&gt;This also seems closely tied to implementing the ResultSet.refreshRow() method, if we continue with the proposed&lt;br/&gt;
implementation and document it, then a natural work-around would be to tell the application to issue a refreshRow(),&lt;br/&gt;
but Derby doesn&apos;t support it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Of course if refreshRow was implemented, then we possibly wouldn&apos;t need to document&lt;br/&gt;
this as a refreshRow() could be called after an updateRow() to present the correct information.&lt;/p&gt;

&lt;p&gt;And on the triggers, I guess I remembered incorrectly, I thought I&apos;d seen code that disallowed modifying the triggered table.&lt;/p&gt;



</comment>
                            <comment id="12367925" author="andreask" created="Mon, 27 Feb 2006 18:51:43 +0000"  >&lt;p&gt;Dan wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; My thought here is that the updated row in the ResultSet would then&lt;br/&gt;
&amp;gt; reflect a state of the database that never occurred. This seems in&lt;br/&gt;
&amp;gt; conflict with all isolation levels except read-uncommitted. I can&apos;t&lt;br/&gt;
&amp;gt; think of another situation where an application using Derby can see&lt;br/&gt;
&amp;gt; a row in that state (excluding read-uncommitted). &lt;/p&gt;

&lt;p&gt;A transaction can always see its own uncommitted changes in the database, so it does not conflict with any isolation levels that the&lt;br/&gt;
ResultSet sees uncommitted data of its own transaction. &lt;br/&gt;
I think the current approach is quite clear: the ResultSet gets populated with the data that the current transaction can see. Later it is insensitive to changes made by other objects (in its own transaction and by other transactions), however it is sensitive to changes made by own objects.&lt;/p&gt;

&lt;p&gt;We may choose if the ResultSet should see its own changes or not. If we chose to let the ResultSet see its own changes, we need to determine if the ResultSet should consider triggers which fires because of updateRow() or deleteRow() as &quot;own&quot; changes or &quot;other&quot; changes. I think it is ok to consider these triggers as other objects.&lt;/p&gt;




</comment>
                            <comment id="12367929" author="fernanda" created="Mon, 27 Feb 2006 19:27:10 +0000"  >&lt;p&gt;Daniel wrote:&lt;br/&gt;
_______&lt;/p&gt;

&lt;p&gt;This also seems closely tied to implementing the ResultSet.refreshRow() method, if we continue with the proposed&lt;br/&gt;
implementation and document it, then a natural work-around would be to tell the application to issue a refreshRow(),&lt;br/&gt;
but Derby doesn&apos;t support it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Of course if refreshRow was implemented, then we possibly wouldn&apos;t need to document&lt;br/&gt;
this as a refreshRow() could be called after an updateRow() to present the correct information.&lt;br/&gt;
________&lt;/p&gt;

&lt;p&gt;I do not think implementing the ResultSet.refreshRow() method would help in this case. We are implementing result sets&lt;br/&gt;
of type TYPE_SCROLL_INSENSITIVE and according to the &quot;JBDC API Tutorial and Reference, Third Edition&quot; p.759, the &lt;br/&gt;
refreshRow() mothod does nothing for result sets of type TYPE_SCROLL_INSENSITIVE. Maybe you were thinking of the&lt;br/&gt;
refreshRow() semantics for sensitive result sets.&lt;/p&gt;

&lt;p&gt;I think we should decide whether the effects of a trigger (or other mechanism that can modify columns on an UPDATE &lt;br/&gt;
statement) constitute &quot;own&quot; or &quot;others&quot; changes, and whether we want the result sets of type TYPE_SCROLL_INSENSITIVE &lt;br/&gt;
to be sensitive to &quot;own&quot; updates and deletes or not.&lt;/p&gt;</comment>
                            <comment id="12367960" author="dagw" created="Mon, 27 Feb 2006 23:43:36 +0000"  >&lt;p&gt;I checked how the trigger situation is handled in Oracle, since they&lt;br/&gt;
do support Scrollable updatable insensitive result sets. In essence&lt;br/&gt;
they take that approach that:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;refreshRow will update the result set with the values of the&lt;br/&gt;
       underlying database, even for insensitive result sets.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;an updateRow will implicitly do a refreshRow after and thus&lt;br/&gt;
       capture any changes of a row to to a trigger action (plus any&lt;br/&gt;
       other changes made by &quot;others&quot; to that row).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is a well defined semantic and would solve Dan&apos;s concern about&lt;br/&gt;
row internal inconsistency, but is it is not JDBC compliant in my&lt;br/&gt;
view.  JDBC is quite clear on both points:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The refreshRow is stated to do nothing for insensitive result sets,&lt;br/&gt;
cf. Tutorial book, 3rd ed. p 759: &quot;..it does nothing for those that&lt;br/&gt;
are TYPE_SCROLL_INSENSITIVE&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;JDBC 3.0 spec: &quot;The result set is insensitive to changes made to the&lt;br/&gt;
underlying data source while it is open. It contains the rows that&lt;br/&gt;
satisfy the query at either the time the query is executed or as the&lt;br/&gt;
rows are retrieved.&quot;&lt;br/&gt;
Tutorial, 3rd ed, p. 718, &quot;If updates are visible, calling the&lt;br/&gt;
appropriate getter method after an updater method has been called will&lt;br/&gt;
return the new value&quot;. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The Oracle doc admits that result of triggers are &quot;others&quot; in the&lt;br/&gt;
sense of JDBC; I quote (Oracle9i JDBC Developer&apos;s Guide and Reference&lt;br/&gt;
Release 2). Note that they use the term &quot;external changes&quot; in the&lt;br/&gt;
sense of JDBC&apos;s &quot;other&apos;s&quot; changes:&lt;/p&gt;

&lt;p&gt;    &quot;Note: When you make an internal change that causes a trigger to&lt;br/&gt;
    execute, the trigger changes are effectively external&lt;br/&gt;
    changes. However, if the trigger affects data in the row you are&lt;br/&gt;
    updating, you will see those changes for any scrollable/updatable&lt;br/&gt;
    result set (also for insensitive! -Dag), because an implicit row&lt;br/&gt;
    refetch occurs after the update.&lt;/p&gt;

&lt;p&gt;They also make a point to distinguish between the insensitivity when&lt;br/&gt;
scrolling and visibility that is reinstated when doing updates:&lt;/p&gt;

&lt;p&gt;    &quot;Note: Explicit use of the refreshRow() method, described in&lt;br/&gt;
    &quot;Refetching Rows&quot;, is distinct from this discussion of&lt;br/&gt;
    visibility. For example, even though external updates are&lt;br/&gt;
    &quot;invisible&quot; to a scroll-insensitive result set, you can explicitly&lt;br/&gt;
    refetch rows in a scroll-insensitive/updatable result set and&lt;br/&gt;
    retrieve external changes that have been made. &quot;Visibility&quot; refers&lt;br/&gt;
    only to the fact that the scroll-insensitive/updatable result set&lt;br/&gt;
    would not see such changes automatically and implicitly.&lt;/p&gt;

&lt;p&gt;So, in my view, Oracle has tweaked the standard here to get semantics&lt;br/&gt;
similar to what Dan suggests. We may want to do this for SUR; but I&lt;br/&gt;
would like to  hear what more people think of this before we decide:&lt;/p&gt;

&lt;p&gt; Should we be strictly JDBC compliant or choose a more &quot;reasonable&quot; behavior?&lt;/p&gt;


</comment>
                            <comment id="12367965" author="djd" created="Tue, 28 Feb 2006 00:09:14 +0000"  >&lt;p&gt;Andreas wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; A transaction can always see its own uncommitted changes in the database, so it does not&lt;br/&gt;
&amp;gt; conflict with any isolation levels that the ResultSet sees uncommitted data of its own transaction. &lt;/p&gt;

&lt;p&gt;Agreed, but I see it that in this case the ResultSet does not hold an uncommitted row, it holds a row in a state that never existed on the database, due to server-side logic.  No other select can ever return the values seen in the SUR  for that row, I don&apos;t see this as the same as an uncommitted row in the database.&lt;/p&gt;

&lt;p&gt;Dag wrote: [&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;oracle behaviour snipped&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Thanks for investigating that Dag.&lt;/p&gt;

&lt;p&gt;&amp;gt; Should we be strictly JDBC compliant or choose a more &quot;reasonable&quot; behavior? &lt;/p&gt;

&lt;p&gt;I need to think a little more about why you think oracle&apos;s behaviour is not JDBC compliant&lt;br/&gt;
(excluding supporting refreshRow with an insensitive rs)&lt;/p&gt;



</comment>
                            <comment id="12367969" author="andreask" created="Tue, 28 Feb 2006 00:47:26 +0000"  >&lt;p&gt;Dan wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Agreed, but I see it that in this case the ResultSet does not hold an uncommitted row, it holds a row in a state that never existed on the database, due to server-side logic.  No other select can ever return the values seen in the SUR  for that row, I don&apos;t see this as the same as an uncommitted row in the database.&lt;/p&gt;

&lt;p&gt;True. This would also be the situation if:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The ResultSet selects a,b&lt;/li&gt;
	&lt;li&gt;Another statement updates column a on a row&lt;/li&gt;
	&lt;li&gt;The ResultSet updates column b on the same row&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After this, the ResultSet does not reflect the changes made by the other statement, (column a would be the same as it initially was) and it does not reflect a state for the row which ever existed on the database.  &lt;/p&gt;</comment>
                            <comment id="12367999" author="djd" created="Tue, 28 Feb 2006 03:20:03 +0000"  >&lt;p&gt;Andreas wrote:&lt;br/&gt;
&amp;#8212; quote&lt;/p&gt;

&lt;p&gt;True. This would also be the situation if:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The ResultSet selects a,b&lt;/li&gt;
	&lt;li&gt;Another statement updates column a on a row&lt;/li&gt;
	&lt;li&gt;The ResultSet updates column b on the same row&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After this, the ResultSet does not reflect the changes made by the other statement, (column a would be the same as it initially was) and it does not reflect a state for the row which ever existed on the database.&lt;/p&gt;

&lt;p&gt;--end quote&lt;/p&gt;

&lt;p&gt;Agreed, it&apos;s the same issue in my mind, and allowing such a row in a ResultSet would be wrong. I believe after an update the row in the ResultSet must reflect the state of the row in the database. Hence, like Oracle, Derby should perform the equivalent of a refreshRow.&lt;/p&gt;</comment>
                            <comment id="12368281" author="dagw" created="Wed, 1 Mar 2006 22:47:53 +0000"  >&lt;p&gt;(reposting a mail comment by &#216;ystein here. -Dag)&lt;/p&gt;

&lt;p&gt;Daniel John Debrunner (JIRA) wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Agreed, it&apos;s the same issue in my mind, and allowing such a row in a ResultSet would be wrong. I believe after an update the row in the ResultSet must reflect the state of the row in the database. Hence, like Oracle, Derby should perform the equivalent of a refreshRow.&lt;/p&gt;

&lt;p&gt;I think such an implementation kind of blurs the concept of&lt;br/&gt;
sensitivity.  You get a result set that is sensitive to some, but not&lt;br/&gt;
all, changes performed by other statements in the same transaction.&lt;br/&gt;
The available metadata for a result set, does not provide a way to&lt;br/&gt;
describe such behavior.  This whole discussion makes me think that the&lt;br/&gt;
only sensible way to implement an insensitive result set is to not&lt;br/&gt;
make own changes visible.  At least, that would give a clean&lt;br/&gt;
implementation with a behavior that is easy to understand.&lt;/p&gt;

&lt;p&gt;&amp;#8211;&lt;br/&gt;
&#216;ystein&lt;/p&gt;</comment>
                            <comment id="12368283" author="dagw" created="Wed, 1 Mar 2006 22:49:00 +0000"  >&lt;p&gt;(reposting a mail comment by Dan here. -Dag)&lt;/p&gt;

&lt;p&gt;&#216;ystein Gr&#248;vlen wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Daniel John Debrunner (JIRA) wrote:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; Agreed, it&apos;s the same issue in my mind, and allowing such a row in a&lt;br/&gt;
&amp;gt;&amp;gt; ResultSet would be wrong. I believe after an update the row in the&lt;br/&gt;
&amp;gt;&amp;gt; ResultSet must reflect the state of the row in the database. Hence,&lt;br/&gt;
&amp;gt;&amp;gt; like Oracle, Derby should perform the equivalent of a refreshRow.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I think such an implementation kind of blurs the concept of sensitivity.&lt;br/&gt;
&amp;gt;   You get a result set that is sensitive to some, but not all, changes&lt;br/&gt;
&amp;gt; performed by other statements in the same transaction.  The available&lt;br/&gt;
&amp;gt; metadata for a result set, does not provide a way to describe such&lt;br/&gt;
&amp;gt; behavior. &lt;/p&gt;

&lt;p&gt;Not sure I agree, I think insensitive result sets are like that anyway.&lt;br/&gt;
Taking this from the spec, that Dag quoted:&lt;/p&gt;

&lt;p&gt;&amp;gt; - JDBC 3.0 spec: &quot;The result set is insensitive to changes made to the&lt;br/&gt;
&amp;gt; underlying data source while it is open. It contains the rows that&lt;br/&gt;
&amp;gt; satisfy the query at either the time the query is executed or as the&lt;br/&gt;
&amp;gt; rows are retrieved.&quot; &lt;/p&gt;

&lt;p&gt;Since a row value can be from the time the query was executed or as the&lt;br/&gt;
rows are retrieved, I can have a ResultSet where some rows show the&lt;br/&gt;
effect of a statement, while other rows do not show the effect of the&lt;br/&gt;
same statement. Not sure an implicit refreshRow() after an updateRow()&lt;br/&gt;
makes the situation any different.&lt;/p&gt;

&lt;p&gt;&amp;gt; This whole discussion makes me think that the only sensible&lt;br/&gt;
&amp;gt; way to implement an insensitive result set is to not make own changes&lt;br/&gt;
&amp;gt; visible.  At least, that would give a clean implementation with a&lt;br/&gt;
&amp;gt; behavior that is easy to understand.&lt;/p&gt;

&lt;p&gt;That&apos;s one clean option.&lt;/p&gt;

&lt;p&gt;Dan.&lt;/p&gt;</comment>
                            <comment id="12368284" author="dagw" created="Wed, 1 Mar 2006 22:50:15 +0000"  >&lt;p&gt;(reposting a mail comment by Bernt. -Dag)&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Dag H. Wanvik (JIRA) wrote (2006-02-27 15:44:44):&lt;br/&gt;
&amp;gt;     [ &lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-690?page=comments#action_12367960&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-690?page=comments#action_12367960&lt;/a&gt; ] &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Dag H. Wanvik commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-690&quot; title=&quot;Add scrollable, updatable, insensitive result sets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-690&quot;&gt;&lt;del&gt;DERBY-690&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; -------------------------------------&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I checked how the trigger situation is handled in Oracle, since they&lt;br/&gt;
&amp;gt; do support Scrollable updatable insensitive result sets. In essence&lt;br/&gt;
&amp;gt; they take that approach that:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;      - refreshRow will update the result set with the values of the&lt;br/&gt;
&amp;gt;        underlying database, even for insensitive result sets.&lt;/p&gt;

&lt;p&gt;The API (1.4.2) spec of refreshRow states:&lt;/p&gt;

&lt;p&gt;   All values are refetched subject to the transaction isolation level&lt;br/&gt;
   and cursor sensitivity. &lt;/p&gt;

&lt;p&gt;Hence there is a difference in behaviour wrt sensitivity. This can&lt;br/&gt;
only imply that refreshRow is a null-operation for insensitive&lt;br/&gt;
resultsets. This is also in agreement with the tutorial as others had&lt;br/&gt;
pointed out(See refreshRow on page 759).&lt;/p&gt;

&lt;p&gt;We should also strive to make &quot;insensitivity&quot; as close to the SQL&lt;br/&gt;
defintion as possible (SQL 2003 p. 96):&lt;/p&gt;

&lt;p&gt;   A change to SQL-data is said to be independent of a cursor CR if&lt;br/&gt;
   and only if it is not made by an &amp;lt;update statement: positioned&amp;gt; or a&lt;br/&gt;
   &amp;lt;delete statement: positioned&amp;gt; that is positioned on CR.&lt;/p&gt;

&lt;p&gt;   A change to SQL-data is said to be significant to CR if and only if&lt;br/&gt;
   it is independent of CR, and, had it been committed before CR was&lt;br/&gt;
   opened, would have caused the table associated with the cursor to&lt;br/&gt;
   be different in any respect.&lt;/p&gt;

&lt;p&gt;   A change to SQL-data is said to be visible to CR if and only if it&lt;br/&gt;
   has an effect on CR by inserting a row in CR, deleting a row from&lt;br/&gt;
   CR, changing the value of a column of a row of CR, or reordering&lt;br/&gt;
   the rows of CR.&lt;/p&gt;

&lt;p&gt;   &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If the cursor is insensitive, then significant changes are not visible.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Bernt&lt;/p&gt;</comment>
                            <comment id="12368286" author="andreask" created="Wed, 1 Mar 2006 23:07:55 +0000"  >&lt;p&gt;I found the following in the JDBC 2.1 spec:&lt;br/&gt;
&quot;&lt;br/&gt;
5.8.3 A result set s own changes We have pointed out that the visibility of changes made by others generally depends on a result set s type. A final point that concerns the visibility of changes via an open result set is whether a result set can see its own changes (inserts, updates, and deletes). A JDBC technology application can determine if the changes made by a result set are vis-ible to the result set itself by calling the DatabaseMetaData methods: ownUpdate-sAreVisible, ownDeletesAreVisible, and ownInsertsAreVisible. These methods are needed since this capability can vary between DBMSs and JDBC drivers. One s own updates are visible if an updated column value can be retrieved by calling getXXX() following a call to updateXXX().&lt;br/&gt;
&quot;&lt;/p&gt;

&lt;p&gt;So the visibility of the ResultSets own changes does not have anything to do with the value in the database, it is the values you set when calling updateXXX().  (The values do not go down to the database until updateRow() is called).  &lt;/p&gt;

&lt;p&gt;Has this been changed in JDBC 3 and later ?&lt;/p&gt;</comment>
                            <comment id="12368299" author="dagw" created="Thu, 2 Mar 2006 00:25:29 +0000"  >&lt;p&gt;Dan&amp;gt; I need to think a little more about why you think oracle&apos;s&lt;br/&gt;
Dan&amp;gt; behaviour is not JDBC compliant (excluding supporting refreshRow&lt;br/&gt;
Dan&amp;gt; with an insensitive rs)&lt;/p&gt;

&lt;p&gt;Dan, did you reach any conclusion here? I would like to settle this&lt;br/&gt;
issue so we can move on with the review of the patch. I do understand&lt;br/&gt;
your concern about row internal consistency, but I admit I am torn,&lt;br/&gt;
since to get the effect of a trigger on the row being updated, we&lt;br/&gt;
would need to refresh the row and this is in violation of the JDBC&lt;br/&gt;
spec in two ways in my view:&lt;/p&gt;

&lt;p&gt;a) The definition of visibility of own changes in the specification:&lt;/p&gt;

&lt;p&gt;   &quot;One&apos;s own updates are visible if an updated column value can be&lt;br/&gt;
   retrieved by calling getXXX() following a call to updateXXX().&quot;&lt;br/&gt;
   [from the JDBC 2.0 spec, this explanation of own changes has been&lt;br/&gt;
   since been removed, though, but is still in the tutorial book,&lt;br/&gt;
   which purports to expound on JDBC 3.0]&lt;/p&gt;

&lt;p&gt;   Note, this quote does not mandate that updateRow() has been&lt;br/&gt;
   performed yet, so no side effects could be visible at this point;&lt;br/&gt;
   they did not happen yet. &lt;/p&gt;

&lt;p&gt;   That is not to say that the wording precludes that the updateRow&lt;br/&gt;
   could lead to further changes to the column(s), than those&lt;br/&gt;
   resulting from the direct updateXXX actions, but any such change&lt;br/&gt;
   would need to be a result of an &quot;own&quot; change for it to be legal for&lt;br/&gt;
   an insensitive result set. And I would still contend that any&lt;br/&gt;
   actions to the underlying data by the trigger represents an&lt;br/&gt;
   &quot;others&quot; change.&lt;/p&gt;

&lt;p&gt;b) A refresh would also make visible other changes to the row&lt;br/&gt;
   performed by others (that is other updates, not made by the trigger&lt;br/&gt;
   action). One could possibly filter out such changes, to get just&lt;br/&gt;
   the net effect of any trigger action, but it seems esoteric.  It&lt;br/&gt;
   could also be row internally inconsistent, as pointed out before in&lt;br/&gt;
   this thread. That is, to get row internal consistency, we need to&lt;br/&gt;
   make &quot;other&apos;s&quot; changes for the row visible (violation in my view).&lt;/p&gt;

&lt;p&gt;In summary, I think we should either&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;go for your suggestion, that is, do an implicit refresh after&lt;br/&gt;
     each updateRow (or positioned UPDATE), even if this breaks JDBC&lt;br/&gt;
     semantics a bit, &lt;b&gt;or&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;keep the current implementation (reflect only such changes as are&lt;br/&gt;
     made directly through the updateXXX methods. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I guess I am OK with either solution (just as long as we are clear on&lt;br/&gt;
if/how we break JDBC), but I would like to move on and would&lt;br/&gt;
appreciate your final conclusion &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I don&apos;t want to remove visibility up updates altogether, as &#216;ystein&lt;br/&gt;
proposed, as I think it makes for a less attractive/useful solution.&lt;/p&gt;

&lt;p&gt;If anybody else has a considered opinion on this, please raise your&lt;br/&gt;
voices now!&lt;/p&gt;</comment>
                            <comment id="12368311" author="djd" created="Thu, 2 Mar 2006 01:48:21 +0000"  >&lt;p&gt;I think one  difference is I don&apos;t see the argument for triggered actions being &quot;other changes&quot;&lt;br/&gt;
Triggered actions are atomic with a statement (in this case a SQL UPDATE).&lt;br/&gt;
Since ResultSet.updateRow() is logically a SQL UPDATE for Derby, and triggered actions are&lt;br/&gt;
atomic with the UPDATE, then triggered actions have to be considered &quot;own&quot; changes.&lt;br/&gt;
They resulted from the ResultSet.updateRow, and if the updateRow fails then the triggered actions are rolled back.&lt;/p&gt;

&lt;p&gt;That&apos;s from a SQL point of view, then from JDBC we have in JDBC 3.0 spec.&lt;br/&gt;
(section 14.2.4.2, for some reason this is no mention of &quot;other changes&quot; in the update section).&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
The method DatabaseMetaData.othersDeletesAreVisible(int type)&lt;br/&gt;
checks whether deletions made by others (another transaction or another&lt;br/&gt;
ResultSet object in the same transaction) are visible to ResultSet objects of the&lt;br/&gt;
specified type.&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
I assume a mistake was made here, changes can be made by Statements as well as ResultSet objects&lt;br/&gt;
in the same transaction. Even with that, triggered actions do &lt;b&gt;not&lt;/b&gt; fall into either category, they are&lt;br/&gt;
not made in another transaction and they are not made by other JDBC objects in the same transaction.&lt;br/&gt;
Thus, triggered actions are not &quot;other&quot; changes.&lt;/p&gt;

&lt;p&gt;The wording that Andreas found in the JDBC 2.1 spec is another issue, I think it just looks wrong, I think&lt;br/&gt;
own or other changes is a reflection of changes made at the database engine, not those just proposed in a ResultSet.&lt;br/&gt;
The fact that this text was removed in subsequent versions might support that.&lt;/p&gt;

&lt;p&gt;Dag said:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;b) A refresh would also make visible other changes to the row&lt;br/&gt;
   performed by others (that is other updates, not made by the trigger&lt;br/&gt;
   action). One could possibly filter out such changes, to get just&lt;br/&gt;
   the net effect of any trigger action, but it seems esoteric. It&lt;br/&gt;
   could also be row internally inconsistent, as pointed out before in&lt;br/&gt;
   this thread. That is, to get row internal consistency, we need to&lt;br/&gt;
   make &quot;other&apos;s&quot; changes for the row visible (violation in my view). &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;While a refreshRow() does make &quot;other&quot; changes visible, I see that as in-line with JDBC&apos;s&lt;br/&gt;
defintion of insensitive, which is not the same a SQL&apos;s &lt;span class=&quot;error&quot;&gt;&amp;#91;more on that in the other thread :-)&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Dag also said:&lt;br/&gt;
&amp;#8212; &lt;span class=&quot;error&quot;&gt;&amp;#91;as one option&amp;#93;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;go for your suggestion, that is, do an implicit refresh after&lt;br/&gt;
     each updateRow (or positioned UPDATE), even if this breaks JDBC&lt;br/&gt;
     semantics a bit, &lt;b&gt;or&lt;/b&gt;&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
So, I&apos;ve only ever said the implicit  refresh after an updateRow. Doing it&lt;br/&gt;
after a positioned UPDATE would be wrong as that is an &quot;other&quot; change,&lt;br/&gt;
it&apos;s executed by a different JDBC Statement object.&lt;/li&gt;
&lt;/ul&gt;




</comment>
                            <comment id="12368322" author="dagw" created="Thu, 2 Mar 2006 02:39:16 +0000"  >&lt;p&gt;Dan said:&lt;/p&gt;

&lt;p&gt;&amp;gt; I think one difference is I don&apos;t see the argument for triggered&lt;br/&gt;
&amp;gt; actions being &quot;other changes&quot; Triggered actions are atomic with a&lt;br/&gt;
&amp;gt; statement (in this case a SQL UPDATE).  Since ResultSet.updateRow()&lt;br/&gt;
&amp;gt; is logically a SQL UPDATE for Derby, and triggered actions are&lt;br/&gt;
&amp;gt; atomic with the UPDATE, then triggered actions have to be considered&lt;br/&gt;
&amp;gt; &quot;own&quot; changes.  They resulted from the ResultSet.updateRow, and if&lt;br/&gt;
&amp;gt; the updateRow fails then the triggered actions are rolled back.&lt;/p&gt;

&lt;p&gt;Yes, this is the crux of the matter &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Too bad the standard isn&apos;t more&lt;br/&gt;
explicit!&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; That&apos;s from a SQL point of view, then from JDBC we have in JDBC 3.0&lt;br/&gt;
&amp;gt; spec.  (section 14.2.4.2, for some reason this is no mention of&lt;br/&gt;
&amp;gt; &quot;other changes&quot; in the update section).  &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; The method DatabaseMetaData.othersDeletesAreVisible(int type) checks&lt;br/&gt;
&amp;gt;&amp;gt; whether deletions made by others (another transaction or another&lt;br/&gt;
&amp;gt;&amp;gt; ResultSet object in the same transaction) are visible to ResultSet&lt;br/&gt;
&amp;gt;&amp;gt; objects of the specified type.&lt;/p&gt;

&lt;p&gt;&amp;gt; I assume a mistake was made here, changes can be made by Statements&lt;br/&gt;
&amp;gt; as well as ResultSet objects in the same transaction. Even with&lt;/p&gt;

&lt;p&gt;Agreed, must be a mistake.&lt;/p&gt;

&lt;p&gt;&amp;gt; that, triggered actions do &lt;b&gt;not&lt;/b&gt; fall into either category, they are&lt;br/&gt;
&amp;gt; not made in another transaction and they are not made by other JDBC&lt;br/&gt;
&amp;gt; objects in the same transaction.  Thus, triggered actions are not&lt;br/&gt;
&amp;gt; &quot;other&quot; changes.&lt;/p&gt;

&lt;p&gt;Given the vagueness of the definition, it is hard to conclude. I&lt;br/&gt;
noticed that the Oracle doc explanation called it &quot;external change&quot;&lt;br/&gt;
(ie &quot;others&quot;). I agree that your interpretation makes sense from a&lt;br/&gt;
logical perspective, though (atomicity). Iff we assume the 2.1 wording&lt;br/&gt;
is wrong, I guess we have the latitude we need for accepting it as an&lt;br/&gt;
&quot;own&quot; change.&lt;/p&gt;

&lt;p&gt;&amp;gt; The wording that Andreas found in the JDBC 2.1 spec is another&lt;br/&gt;
&amp;gt; issue, I think it just looks wrong, I think own or other changes is&lt;br/&gt;
&amp;gt; a reflection of changes made at the database engine, not those just&lt;br/&gt;
&amp;gt; proposed in a ResultSet.  The fact that this text was removed in&lt;br/&gt;
&amp;gt; subsequent versions might support that.&lt;/p&gt;

&lt;p&gt;Yes, possibly.&lt;/p&gt;

&lt;p&gt;&amp;gt; While a refreshRow() does make &quot;other&quot; changes visible, I see that&lt;br/&gt;
&amp;gt; as in-line with JDBC&apos;s defintion of insensitive, which is not the&lt;br/&gt;
&amp;gt; same a SQL&apos;s &lt;span class=&quot;error&quot;&gt;&amp;#91;more on that in the other thread :-)&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;If we allow trigger&apos;s changes to be &quot;own&quot;, I guess we need to swallow&lt;br/&gt;
this one, too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I wish JDBC had something like ODBC&apos;s keyset driven&lt;br/&gt;
cursors sets, then we could happily refresh at each repositioning &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; Dag also said:&lt;br/&gt;
&amp;gt; &amp;#8212; &lt;span class=&quot;error&quot;&gt;&amp;#91;as one option&amp;#93;&lt;/span&gt;&lt;br/&gt;
&amp;gt;   - go for your suggestion, that is, do an implicit refresh after&lt;br/&gt;
&amp;gt;      each updateRow (or positioned UPDATE), even if this breaks JDBC&lt;br/&gt;
&amp;gt;      semantics a bit, &lt;b&gt;or&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; So, I&apos;ve only ever said the implicit  refresh after an updateRow. Doing it&lt;br/&gt;
&amp;gt; after a positioned UPDATE would be wrong as that is an &quot;other&quot; change,&lt;br/&gt;
&amp;gt; it&apos;s executed by a different JDBC Statement object.&lt;/p&gt;

&lt;p&gt;In our implementation, a positioned UPDATE (for the same result set)&lt;br/&gt;
is considered an &quot;own&quot; change, cf. the write-up. It would be hard to&lt;br/&gt;
differentiate since the implementation of updateRow piggybacks the&lt;br/&gt;
positioned update.&lt;/p&gt;

&lt;p&gt;If we are all OK with it, let&apos;s do the refresh solution.&lt;/p&gt;

</comment>
                            <comment id="12368384" author="fernanda" created="Thu, 2 Mar 2006 07:33:57 +0000"  >&lt;p&gt;Dag wrote:&lt;br/&gt;
&amp;gt; In our implementation, a positioned UPDATE (for the same result set) &lt;br/&gt;
&amp;gt; is considered an &quot;own&quot; change, cf. the write-up. It would be hard to &lt;br/&gt;
&amp;gt; differentiate since the implementation of updateRow piggybacks the &lt;br/&gt;
&amp;gt; positioned update&lt;/p&gt;

&lt;p&gt;If we decide to refresh the row instead of only seeing the results of&lt;br/&gt;
updateXXX methods, the reason why we chose to consider positioned&lt;br/&gt;
updates as &quot;own&quot; changes will no longer be there. Then we can only &lt;br/&gt;
refresh the row when an updateRow is executed, and stop considering&lt;br/&gt;
positioned updates as &quot;own&quot; changes.&lt;/p&gt;

&lt;p&gt;Dan wrote:&lt;br/&gt;
&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; Hence, like Oracle, Derby should perform the equivalent of a &lt;br/&gt;
&amp;gt; refreshRow. &lt;/p&gt;

&lt;p&gt;Do you mean that we should also, like Oracle, allow users to use the &lt;br/&gt;
refreshRow() method to get an updated row, or should it still be a &lt;br/&gt;
no-op when it is not being called from within the updateRow() method?&lt;/p&gt;</comment>
                            <comment id="12368542" author="andreask" created="Fri, 3 Mar 2006 02:14:27 +0000"  >&lt;p&gt;I wrote a testprogram. It verfies the JDBC 2.1 specification definition of own changes in Derby for FORWARD_ONLY, UPDATABLE.&lt;br/&gt;
        Statement s = testConn.createStatement&lt;br/&gt;
                (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);&lt;/p&gt;

&lt;p&gt;        ResultSet rs = s.executeQuery(&quot;select * from t1 for update&quot;);&lt;br/&gt;
        rs.next();&lt;br/&gt;
        rs.updateString(4, &quot;UPDATEDD!!&quot;);&lt;br/&gt;
        System.out.println(rs.getString(4));&lt;/p&gt;

&lt;p&gt;Output: UPDATEDD!!&lt;br/&gt;
So, the changes are visible when you call updateXXX(). updateRow() will do the actual update in the database. &lt;/p&gt;</comment>
                            <comment id="12368558" author="dagw" created="Fri, 3 Mar 2006 03:15:44 +0000"  >&lt;p&gt;Andreas said:&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;sample test program snipped&amp;#93;&lt;/span&gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Output: UPDATEDD!!&lt;br/&gt;
&amp;gt; So, the changes are visible when you call updateXXX(). updateRow()&lt;br/&gt;
&amp;gt; will do the actual update in the database.  &lt;/p&gt;

&lt;p&gt;Derby&apos;s DataBaseMetaData#ownUpdatesAreVisible(TYPE_FORWARD_ONLY)&lt;br/&gt;
presently returns false (both drivers)...&lt;/p&gt;

&lt;p&gt;Dag&lt;/p&gt;</comment>
                            <comment id="12369218" author="oysteing" created="Tue, 7 Mar 2006 20:39:33 +0000"  >&lt;p&gt;Some comments/questions to the write-up:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Updatability, 2nd paragraph:  I think you should explain why&lt;br/&gt;
  navigations to new rows and previously fetched rows needs to be&lt;br/&gt;
  handled differently.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Isolation level read-uncommitted/read-committed, 2nd paragraph:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;1st sentence: &quot;open&quot; instead of &quot;opened&quot;?&lt;/li&gt;
	&lt;li&gt;&quot;The result set may overwrite data in an updateRow() ... &quot;  I do&lt;br/&gt;
    not understand what you try to say here.  Do you mean that&lt;br/&gt;
    updateRow may overwrite data that has been changed after the row&lt;br/&gt;
    was read by the result set?  (In other words, you are talking&lt;br/&gt;
    about data in the database, not data in an updateRow.)&lt;/li&gt;
	&lt;li&gt;Last sentence: I would reformulate to say that only changed&lt;br/&gt;
    columns are written to the database on updateRow().&lt;/li&gt;
	&lt;li&gt;Is there really anything particular about result sets in this&lt;br/&gt;
    context?   Would not the same discussion be relevant for any&lt;br/&gt;
    multi-statement transaction?&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12369275" author="dagw" created="Wed, 8 Mar 2006 01:36:03 +0000"  >&lt;p&gt;I just uploaded v3 of the write-up to address &#216;ystein&apos;s comments.&lt;br/&gt;
See also answers inlined.&lt;/p&gt;

&lt;p&gt;&#216;ystein wrote:&lt;br/&gt;
&amp;gt; Some comments/questions to the write-up:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * Updatability, 2nd paragraph:  I think you should explain why&lt;br/&gt;
&amp;gt;   navigations to new rows and previously fetched rows needs to be&lt;br/&gt;
&amp;gt;   handled differently.&lt;/p&gt;

&lt;p&gt;This paragraph has been changed, see writeup-v3&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; * Isolation level read-uncommitted/read-committed, 2nd paragraph:&lt;br/&gt;
&amp;gt;   - 1st sentence: &quot;open&quot; instead of &quot;opened&quot;?&lt;/p&gt;

&lt;p&gt;yes&lt;/p&gt;

&lt;p&gt;&amp;gt;   - &quot;The result set may overwrite data in an updateRow() ... &quot;  I do&lt;br/&gt;
&amp;gt;     not understand what you try to say here.  Do you mean that&lt;br/&gt;
&amp;gt;     updateRow may overwrite data that has been changed after the row&lt;br/&gt;
&amp;gt;     was read by the result set?  (In other words, you are talking&lt;br/&gt;
&amp;gt;     about data in the database, not data in an updateRow.)&lt;br/&gt;
&amp;gt;   - Last sentence: I would reformulate to say that only changed&lt;br/&gt;
&amp;gt;     columns are written to the database on updateRow().&lt;/p&gt;

&lt;p&gt;This 2nd paragraph has been changed, see writeup-v3.&lt;/p&gt;

&lt;p&gt;&amp;gt;   - Is there really anything particular about result sets in this&lt;br/&gt;
&amp;gt;     context?   Would not the same discussion be relevant for any&lt;br/&gt;
&amp;gt;     multi-statement transaction?&lt;/p&gt;

&lt;p&gt;No, I agree. I added these paragraphs:&lt;/p&gt;

&lt;p&gt;    Note that these effects will also apply to rows changed by our own&lt;br/&gt;
    transaction if made via separate UPDATE statements, no matter what&lt;br/&gt;
    isolation level is active.&lt;/p&gt;

&lt;p&gt;    If such effects are an issue, the user could increase the&lt;br/&gt;
    isolation level (and/or make own transaction behave!) For Derby,&lt;br/&gt;
    at some point in the future we might want to add updatable&lt;br/&gt;
    sensitive result sets and/or add some syntax to allow extra&lt;br/&gt;
    locking for rows in updatable result set.&lt;/p&gt;

&lt;p&gt;Dag&lt;/p&gt;</comment>
                            <comment id="12369638" author="oysteing" created="Thu, 9 Mar 2006 21:16:29 +0000"  >&lt;p&gt;I have reviewed part of this patch. I have so far reviewed the &lt;br/&gt;
changes to ScrollInsensitiveResultSet and some related classes.&lt;br/&gt;
More will follow.  &lt;/p&gt;

&lt;p&gt;Some of my comments may be more of a request for a general&lt;br/&gt;
cleanup of the implementation, and not directly related to the&lt;br/&gt;
changes in this patch.  For such cases, I guess we should consider&lt;br/&gt;
whether to file a separate jira issue.&lt;/p&gt;

&lt;p&gt;1. ScrollInsensitiveResultSet:&lt;/p&gt;

&lt;p&gt;1.1 Imports a few classes that are not used (TargetResultSet, SQLBlob,&lt;br/&gt;
  SQLVarchar).&lt;/p&gt;

&lt;p&gt;1.2 Javadoc for classes:&lt;/p&gt;

&lt;p&gt;    a) Should say something about that the hash table may be stored on&lt;br/&gt;
       disk. &lt;br/&gt;
    b) I miss a description of the layout of the cached rows.&lt;/p&gt;

&lt;p&gt;1.3 getPreviousRow()&lt;/p&gt;

&lt;p&gt;    a) I do not understand why this code is added.&lt;br/&gt;
       positionInLastFetchedRow() is called if currentRow==null, but&lt;br/&gt;
       currentRow does not seem to be updated by&lt;br/&gt;
       positionInLastFetchedRow().  Also, it does not seem that the&lt;br/&gt;
       subsequent call to getRowFromHashTable() depend on any data&lt;br/&gt;
       that is set by positionInLastFetchedRow().&lt;/p&gt;

&lt;p&gt;1.4 getNextRowFromSource()&lt;/p&gt;

&lt;p&gt;    a) Comment: I am not able to understand what is going on here&lt;br/&gt;
       based on the comment:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;candidate&quot; is not mention anywhere else in this class,&lt;br/&gt;
              and needs to be defined.  &lt;/li&gt;
	&lt;li&gt;You mention TableScanResultSet, but I do not find any&lt;br/&gt;
              assumption in the code about that being the only&lt;br/&gt;
              possible type of the result set.  It is also unclear&lt;br/&gt;
              whether you are talking about target or source here.&lt;/li&gt;
	&lt;li&gt;Why does these ResultSets need to refer to the same row,&lt;br/&gt;
              and why does it help to set the current row to null?  &lt;/li&gt;
	&lt;li&gt;It is unclear to me what the relation is between the&lt;br/&gt;
              target result set and this result set.  Is this&lt;br/&gt;
              explained somewhere?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    b) Having to look up something by cursor name, indicates to me&lt;br/&gt;
       that you increasing the coupling between modules that by design&lt;br/&gt;
       was not intended to be coupled.  Also, this class already has a&lt;br/&gt;
       reference to an Activation.  Is this the same or some other&lt;br/&gt;
       Activation?&lt;/p&gt;

&lt;p&gt;1.5 addRowToHashTable()&lt;/p&gt;

&lt;p&gt;    a) Javadoc:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;key is no longer positionInSource, but currentPosition.&lt;/li&gt;
	&lt;li&gt;typo: &quot;this methods&quot;&lt;/li&gt;
	&lt;li&gt;You say that this method &quot;is used in order to store the&lt;br/&gt;
              new values of that row&quot;.  I think this is a bit&lt;br/&gt;
              misleading since this method only adds row to the hash&lt;br/&gt;
              table; it does not relate to updates.  Updates are&lt;br/&gt;
              achieved by the caller who deletes the old version&lt;br/&gt;
              before adding the new.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    b) I do not like the hard-coding of constants for field numbers&lt;br/&gt;
       and field counts.&lt;/p&gt;

&lt;p&gt;    c) Why are you recalculating extraColumns every time?  Will it not&lt;br/&gt;
       be the same value for the entire lifetime of the object?&lt;/p&gt;

&lt;p&gt;    d) Why is there some code in comments for the assignment to&lt;br/&gt;
       hashRowArray&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;? &lt;/p&gt;

&lt;p&gt;    e) I am not quite sure, but would it not be better if position was&lt;br/&gt;
       a parameter to the function?  That would make the dependency on&lt;br/&gt;
       the calling code more clear.&lt;/p&gt;

&lt;p&gt;1.6 getRowFromHashTable()&lt;/p&gt;

&lt;p&gt;    a) You are creating an object every time you do a lookup in the&lt;br/&gt;
       hash table.  Would it be an idea to have a single SQLInteger&lt;br/&gt;
       object that is reused for this purpose?&lt;/p&gt;

&lt;p&gt;    b) Disabled code in comments.  Any reason why it is not just&lt;br/&gt;
       removed?&lt;/p&gt;

&lt;p&gt;1.7 positionInLastFetchedRow()&lt;/p&gt;

&lt;p&gt;    a) No JavaDoc&lt;/p&gt;

&lt;p&gt;    b) Line exceeding 80 columns (not the only case.)&lt;/p&gt;

&lt;p&gt;    c) Assignment of currentPosition:  Could not this be done for all&lt;br/&gt;
       cases at the end (outside the if statement).&lt;/p&gt;

&lt;p&gt;1.8 updateCachedRow()&lt;/p&gt;

&lt;p&gt;    a) Are you sure that if a projection is needed that this will be&lt;br/&gt;
       done by the top node of the source tree?  Could not there be&lt;br/&gt;
       cases where a projection is needed even if source is of a&lt;br/&gt;
       different type?  (E.g., the source of source is a&lt;br/&gt;
       ProjectRestrictResultSet)&lt;/p&gt;

&lt;p&gt;    b) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;1.9 isDeleted()/isUpdated()&lt;/p&gt;

&lt;p&gt;    a) It does not seem to be necessary to cast the objects stored in&lt;br/&gt;
       the hash table to DataValueDescriptor[] in order to access its&lt;br/&gt;
       contents.  (Not doing so, could shorten some lines that are too&lt;br/&gt;
       long &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.10  setRowLocation()&lt;/p&gt;

&lt;p&gt;    a) I am not entirely happen with the name.  It sounds more like an&lt;br/&gt;
       attribute is being updated than that the underlying cursor is&lt;br/&gt;
       repositioned.&lt;/p&gt;

&lt;p&gt;    b) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;    c) Would not an assert be better than if-test in this case?  It&lt;br/&gt;
       seems to me that the code depends on the source being a&lt;br/&gt;
       CursorResultSet.&lt;/p&gt;

&lt;p&gt;2. UpdateResultSet/DeleteResultSet&lt;/p&gt;

&lt;p&gt;   a) Why is updateCachedRow()/markCachedRowAsDeleted() made general&lt;br/&gt;
      methods on NoPutResultSet?  That requires touching a lot of&lt;br/&gt;
      classes not concerned with scrollable cursors.  Would it not be&lt;br/&gt;
      possible to detect that the source is a&lt;br/&gt;
      ScrollInsensitiveResultSet, and do the necessary casting in this&lt;br/&gt;
      case.  If you insist on making these general methods, I would&lt;br/&gt;
      suggest calling them updateRow/markRowAsDeleted and let each&lt;br/&gt;
      ResultSet do whatever it needs to do when rows are&lt;br/&gt;
      updated/deleted.&lt;/p&gt;

&lt;p&gt;   b) Is there a reason why you place the calls in open() and not in&lt;br/&gt;
      collectAffectedRows()?&lt;/p&gt;

&lt;p&gt;   c) You make the assumption that only a single row is affected.&lt;br/&gt;
      This may be the case for scrollable cursors, but generally&lt;br/&gt;
      open() may update/delete many rows.  I think that needs to be&lt;br/&gt;
      explained in the code.&lt;/p&gt;

&lt;p&gt;3. ProjectRestrictResultSet&lt;/p&gt;

&lt;p&gt;3.1 setRowlocation()&lt;/p&gt;

&lt;p&gt;   a) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;   b) Assert instead of if-test?&lt;/p&gt;

&lt;p&gt;3.2 doBaseRowProjection()&lt;/p&gt;

&lt;p&gt;   a) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;   b) The test for (source!=null) is not necessary.&lt;/p&gt;

&lt;p&gt;4. NoPutResultSet/CursorResultSet&lt;/p&gt;

&lt;p&gt;   a) I have not really understood the relationship between&lt;br/&gt;
      CursorResultSet and NoPutResultSet.  Will there be classes that&lt;br/&gt;
      implement CursorResultSet but not NoPutResultSet, and vice&lt;br/&gt;
      versa?&lt;/p&gt;

&lt;p&gt;   b) Originally CursorResultSet has only get...() methods,&lt;br/&gt;
      getRowLocation() and getCurrentRow().  You have added&lt;br/&gt;
      setRowLocation(), but setCurrentRow() is part of NoPutResultSet.&lt;br/&gt;
      This is a bit assymetric.  If you had added setRowLocation to&lt;br/&gt;
      NoPutResultSet you would also have avoided a lot casting by&lt;br/&gt;
      callers.&lt;/p&gt;</comment>
                            <comment id="12369848" author="oysteing" created="Fri, 10 Mar 2006 19:54:35 +0000"  >&lt;p&gt;My review of the remaining changes to the SQL layer:&lt;/p&gt;

&lt;p&gt;5. TableScanResultSet&lt;/p&gt;

&lt;p&gt;5.1 General:&lt;/p&gt;

&lt;p&gt;    a) I do not understand why you need to prevent re-qualification.&lt;br/&gt;
       When will you need to read a row again?  I thought you were&lt;br/&gt;
       getting the row from the hash table on later accesses.&lt;/p&gt;

&lt;p&gt;    b) Both the write-up and the added comment only talks about&lt;br/&gt;
       qualification.  It does not mention anything about&lt;br/&gt;
       currentRowIsValid which does seem to address another issue.&lt;/p&gt;

&lt;p&gt;5.2 getRowLoaction()/getCurrentRow()&lt;/p&gt;

&lt;p&gt;    a) It seems like you have changed the behavior of these functions.&lt;br/&gt;
       Should not the JavaDoc be updated to reflect that?  (e.g., when&lt;br/&gt;
       null is returned seems to have changed) &lt;/p&gt;

&lt;p&gt;5.3 setRowLocation()&lt;/p&gt;

&lt;p&gt;    a) It seems like the comment relates to the testing on isKeyed.&lt;br/&gt;
       This relation could have been more obvious.  &lt;/p&gt;

&lt;p&gt;    b) Thinking about B-Tree scans: What if a query does not need to&lt;br/&gt;
       access the base table only; the index.  (That is, all selected&lt;br/&gt;
       columns are part of the index.)  How does the re-positioning&lt;br/&gt;
       work in this case?&lt;/p&gt;

&lt;p&gt;6. IndexRowToBaseRowResultSet&lt;/p&gt;

&lt;p&gt;6.1 positionFromRowLocation&lt;/p&gt;

&lt;p&gt;    a) Same question as for TableScanResultSet, when do you need to&lt;br/&gt;
       refetch the row from the heap?&lt;/p&gt;

&lt;p&gt;    b) I would like a comment that says what concept&lt;br/&gt;
       positionFromRowLocation represents.&lt;/p&gt;

&lt;p&gt;6.2 getCurrentRow()&lt;/p&gt;

&lt;p&gt;    a) The diff would have meen much smaller if you had structured&lt;br/&gt;
       this as follows:&lt;/p&gt;

&lt;p&gt;       if (positionFromRowLocation) &lt;/p&gt;
{
           &amp;lt;new code&amp;gt;
           return currentRow;
       }
&lt;p&gt;       &amp;lt;old code&amp;gt;&lt;/p&gt;

&lt;p&gt;    b) A comment on why your are testing on positionFromRowLocation&lt;br/&gt;
       would be nice.&lt;/p&gt;

&lt;p&gt;7. CurrentOfResultSet&lt;/p&gt;

&lt;p&gt;7.1 getNextRowCore()&lt;/p&gt;

&lt;p&gt;    a) I can not find that these changes is listed in the list of code&lt;br/&gt;
       changes in the writeup.&lt;/p&gt;

&lt;p&gt;    b) Is skipping the call to target.getCurrentRow() necessary or&lt;br/&gt;
       just an optimization?&lt;/p&gt;

&lt;p&gt;    c) I do not understand the comment for when to add the warning.&lt;br/&gt;
       Why was there not any need for a warning earlier?&lt;/p&gt;

&lt;p&gt;    d) Typo: coursor&lt;/p&gt;

&lt;p&gt;7.2 updateCachedRow()/markCachedRowAsDeleted()&lt;/p&gt;

&lt;p&gt;    a) Isn&apos;t the cursor already available as an object attribute?&lt;/p&gt;

&lt;p&gt;    b) Another instance of missing parameter name in Javadoc&lt;/p&gt;

&lt;p&gt;8. TemporaryRowHolderResultSet&lt;/p&gt;

&lt;p&gt;8.1 All new methods: I think the Javadoc should mention that these&lt;br/&gt;
    methods are no-ops.&lt;/p&gt;

&lt;p&gt;9. NoPutResultSetImpl&lt;/p&gt;

&lt;p&gt;9.1 Imports:  Why do you need to import CursorResultSet?&lt;/p&gt;

&lt;p&gt;9.2 setCurrentRow()&lt;/p&gt;

&lt;p&gt;    a) Why have you removed &apos;final&apos;?  I cannot find that you have&lt;br/&gt;
       added any method that overrides this method.&lt;/p&gt;

&lt;p&gt;    b) I guess it makes sense to set its currentRow here, but why was&lt;br/&gt;
       it not necessary before?&lt;/p&gt;

&lt;p&gt;9.3 updateCachedRow()/markCachedRowAsDeleted()&lt;/p&gt;

&lt;p&gt;    a) I think the Javadoc should mention that these methods are&lt;br/&gt;
       no-ops.&lt;/p&gt;

&lt;p&gt;9.4 setRowLocation()&lt;/p&gt;

&lt;p&gt;    a) Another instance of missing parameter name in Javadoc&lt;/p&gt;

&lt;p&gt;    b) Typo: Positiones&lt;/p&gt;

&lt;p&gt;    c) I do not understand the call to targetResultSet.&lt;br/&gt;
       targetResultSet is as far as I can tell always an&lt;br/&gt;
       InsertResultSet which, according to the javadoc, is used to&lt;br/&gt;
       insert rows from a source into a base table.  How is this&lt;br/&gt;
       relevant to what you are doing?&lt;/p&gt;

&lt;p&gt;10. NormalizeResultSet&lt;/p&gt;

&lt;p&gt;10.1 updateCachedRow()&lt;/p&gt;

&lt;p&gt;     a) Another instance of missing parameter name in Javadoc&lt;/p&gt;</comment>
                            <comment id="12370159" author="oysteing" created="Mon, 13 Mar 2006 19:21:37 +0000"  >&lt;p&gt;More review comments.  This time for the changes to the access layer:&lt;/p&gt;

&lt;p&gt;11. ScanController&lt;/p&gt;

&lt;p&gt;11.1 fetchWithoutQualify()&lt;/p&gt;

&lt;p&gt;     a) I think the Javadoc should be more verbose and at least list&lt;br/&gt;
        parameters and contain &quot;@see fetch&quot;.  I also think it would&lt;br/&gt;
        have been nice to be a bit more verbose on what not applying&lt;br/&gt;
        qualifiers mean.&lt;/p&gt;

&lt;p&gt;     b) I would have placed this new method below fetch&lt;/p&gt;

&lt;p&gt;11.2 positionAtRowLocation()&lt;/p&gt;

&lt;p&gt;     a) Why can not clients use the existing reopenScanByRowLocation&lt;br/&gt;
        instead?&lt;/p&gt;

&lt;p&gt;12. GenericScanController&lt;/p&gt;

&lt;p&gt;12.1 reopenScanByRecordHandleAndSetLocks()&lt;/p&gt;

&lt;p&gt;     a) If I have understood things correct, when a scan is initially&lt;br/&gt;
        opened, the first row is not locked.  Locking happen on the&lt;br/&gt;
        subsequent next().  Why could not a similar scheme be used&lt;br/&gt;
        here? That is, reopen positions just before the specified row&lt;br/&gt;
        and a subsequent call to next is performed to actually lock&lt;br/&gt;
        it.  Looking at fetchRows() and the methods it calls, there&lt;br/&gt;
        seems to already exist code to handle a repositioned scan.&lt;br/&gt;
        (The combination of SCAN_INIT and a set record posisiton).&lt;/p&gt;

&lt;p&gt;     b) I am still a bit uncomfortable with the method names in the&lt;br/&gt;
        following call path: &lt;br/&gt;
            setRowLocation() &lt;br/&gt;
                positionAtRowLocation()&lt;br/&gt;
                    reopenScanByRecordHandleAndSetLocks().  &lt;br/&gt;
        The lower levels makes more happen than the names of the high&lt;br/&gt;
        level methods indicates.&lt;/p&gt;

&lt;p&gt;13. Scan/SortBufferRowSource/SortScan&lt;/p&gt;

&lt;p&gt;13.1 Javadoc&lt;/p&gt;

&lt;p&gt;     a) Javadoc: I think you should at least put a sentence about what&lt;br/&gt;
        the methods does in addition to referring to the methods of&lt;br/&gt;
        ScanController.  At least for some of these classes, that&lt;br/&gt;
        seems to be the pattern that has previously been used.&lt;/p&gt;

&lt;p&gt;     b) I think the Javadoc should say that these methods will always&lt;br/&gt;
        throw exceptions.&lt;/p&gt;

&lt;p&gt;14. BTreeScan&lt;/p&gt;

&lt;p&gt;14.1 fetch()/fetchWithoutQualify()&lt;/p&gt;

&lt;p&gt;     a) I do not think it is good that both methods has the same&lt;br/&gt;
        Javadoc description.&lt;/p&gt;

&lt;p&gt;14.2 positionAtRowLocation ()&lt;/p&gt;

&lt;p&gt;     a) See comment 13.1&lt;/p&gt;


&lt;p&gt;15. HeapScan&lt;/p&gt;

&lt;p&gt;15.1 positionAtRowLocation()&lt;/p&gt;

&lt;p&gt;     a) See 13.1 a)&lt;/p&gt;

&lt;p&gt;16. DiskHashTable&lt;/p&gt;

&lt;p&gt;16.1 Constructor&lt;/p&gt;

&lt;p&gt;     a) It seems strange to me that you need special handling in order&lt;br/&gt;
        to be able to store RowLocation in the hash tables that is not&lt;br/&gt;
        necessary for any other types.  Is the problem the&lt;br/&gt;
        getNewNull() is broken for RowLocation?  Maybe that problem&lt;br/&gt;
        could be fixed in stead?&lt;/p&gt;
</comment>
                            <comment id="12370325" author="andreask" created="Tue, 14 Mar 2006 17:00:05 +0000"  >&lt;p&gt;&amp;gt; 11.2 positionAtRowLocation()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;      a) Why can not clients use the existing reopenScanByRowLocation&lt;br/&gt;
&amp;gt;         instead?&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;reopenScanByRowLocation(..) let the user reopen the scan and start scanning from the RowLocation specified. After a call to reopenScanByRowLocation(..) the rowLocation is not locked, the page is not latched, and the user need to call next() to get the next record. &lt;/p&gt;

&lt;p&gt;This will actually be the next record after the rowLocation specified in reopenScanByRowLocation().&lt;/p&gt;

&lt;p&gt;positionAtRowLocation(..) positions the scan, and locks the row. &lt;/p&gt;


&lt;p&gt;&amp;gt; 12. GenericScanController&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; 12.1 reopenScanByRecordHandleAndSetLocks()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;      a) If I have understood things correct, when a scan is initially&lt;br/&gt;
&amp;gt;         opened, the first row is not locked.  Locking happen on the&lt;br/&gt;
&amp;gt;         subsequent next().  Why could not a similar scheme be used&lt;br/&gt;
&amp;gt;         here? That is, reopen positions just before the specified row&lt;br/&gt;
&amp;gt;         and a subsequent call to next is performed to actually lock&lt;br/&gt;
&amp;gt;         it.  Looking at fetchRows() and the methods it calls, there&lt;br/&gt;
&amp;gt;         seems to already exist code to handle a repositioned scan.&lt;br/&gt;
&amp;gt;         (The combination of SCAN_INIT and a set record posisiton).&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;The combination of SCAN_INIT and a set record position will on the next() call move the rowlocation to the next row, not to the set record position.&lt;/p&gt;

&lt;p&gt;If you position to a rowlocation which points to a previous row, and call next you may risk:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;on the next() call you skip the row if it has been deleted and return another row&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;positionAtRowLocation() returns false if the row has been deleted.&lt;/p&gt;


&lt;p&gt;&amp;gt;      b) I am still a bit uncomfortable with the method names in the&lt;br/&gt;
&amp;gt;         following call path: &lt;br/&gt;
&amp;gt;             setRowLocation() &lt;br/&gt;
&amp;gt;                 positionAtRowLocation()&lt;br/&gt;
&amp;gt;                     reopenScanByRecordHandleAndSetLocks().  &lt;br/&gt;
&amp;gt;         The lower levels makes more happen than the names of the high&lt;br/&gt;
&amp;gt;         level methods indicates.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Remember these are methods in different modules, and we should try to keep the names of the methods within modules consistent with the module. &lt;/p&gt;

&lt;p&gt;I.e in SQL execution layer, methods for getting RowLocation is called getRowLocation(). &lt;/p&gt;

&lt;p&gt;The fact that positionAtRowLocation() also sets locks, is natural in the store. Also next() sets locks. You set locks in a scan without mentioning it in the method names.&lt;/p&gt;</comment>
                            <comment id="12370342" author="fernanda" created="Tue, 14 Mar 2006 21:04:54 +0000"  >&lt;p&gt;Here is a new version of the patch and write-up. I have chosen to call both the patch and the write-up v4 so that the numbering will match. I have answered to &#216;ysteins comments from 1 to 16.1.&lt;/p&gt;

&lt;p&gt;&amp;gt; 1. ScrollInsensitiveResultSet:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; 1.1 Imports a few classes that are not used (TargetResultSet, SQLBlob,&lt;br/&gt;
&amp;gt;   SQLVarchar).&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;OK Removed&lt;/p&gt;

&lt;p&gt;&amp;gt; 1.2 Javadoc for classes:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) Should say something about that the hash table may be stored on&lt;br/&gt;
&amp;gt;        disk. &lt;/p&gt;

&lt;p&gt;OK Added some text to javadoc &lt;/p&gt;

&lt;p&gt;&amp;gt;     b) I miss a description of the layout of the cached rows.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;OK Added some text to javadoc &lt;/p&gt;

&lt;p&gt;&amp;gt; 1.3 getPreviousRow()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) I do not understand why this code is added.&lt;br/&gt;
&amp;gt;        positionInLastFetchedRow() is called if currentRow==null, but&lt;br/&gt;
&amp;gt;        currentRow does not seem to be updated by&lt;br/&gt;
&amp;gt;        positionInLastFetchedRow().  Also, it does not seem that the&lt;br/&gt;
&amp;gt;        subsequent call to getRowFromHashTable() depend on any data&lt;br/&gt;
&amp;gt;        that is set by positionInLastFetchedRow().&lt;/p&gt;

&lt;p&gt;Not needed: Removed.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.4 getNextRowFromSource()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) Comment: I am not able to understand what is going on here&lt;br/&gt;
&amp;gt;        based on the comment:&lt;br/&gt;
&amp;gt;             - &quot;candidate&quot; is not mention anywhere else in this class,&lt;br/&gt;
&amp;gt;               and needs to be defined.  &lt;br/&gt;
&amp;gt;             - You mention TableScanResultSet, but I do not find any&lt;br/&gt;
&amp;gt;               assumption in the code about that being the only&lt;br/&gt;
&amp;gt;               possible type of the result set.  It is also unclear&lt;br/&gt;
&amp;gt;               whether you are talking about target or source here.&lt;br/&gt;
&amp;gt;             - Why does these ResultSets need to refer to the same row,&lt;br/&gt;
&amp;gt;               and why does it help to set the current row to null?  &lt;br/&gt;
&amp;gt;             - It is unclear to me what the relation is between the&lt;br/&gt;
&amp;gt;               target result set and this result set.  Is this&lt;br/&gt;
&amp;gt;               explained somewhere?&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;OK Re-written&lt;/p&gt;

&lt;p&gt;OK The target result set that we get using&lt;br/&gt;
target = lcc.lookupCursorActivation(getCursorName()).getTargetResultSet();&lt;br/&gt;
Is the result set that is closer to the scan. Usually a TableScanResultSet&lt;br/&gt;
or IndexRowToBaseRowResultSet.&lt;/p&gt;


&lt;p&gt;&amp;gt;     b) Having to look up something by cursor name, indicates to me&lt;br/&gt;
&amp;gt;        that you increasing the coupling between modules that by design&lt;br/&gt;
&amp;gt;        was not intended to be coupled.  Also, this class already has a&lt;br/&gt;
&amp;gt;        reference to an Activation.  Is this the same or some other&lt;br/&gt;
&amp;gt;        Activation?&lt;/p&gt;

&lt;p&gt;Using activation now to get the target result set.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.5 addRowToHashTable()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) Javadoc:&lt;br/&gt;
&amp;gt;             - key is no longer positionInSource, but currentPosition.         &lt;br/&gt;
&amp;gt;             - typo: &quot;this methods&quot;&lt;br/&gt;
&amp;gt;             - You say that this method &quot;is used in order to store the&lt;br/&gt;
&amp;gt;               new values of that row&quot;.  I think this is a bit&lt;br/&gt;
&amp;gt;               misleading since this method only adds row to the hash&lt;br/&gt;
&amp;gt;               table; it does not relate to updates.  Updates are&lt;br/&gt;
&amp;gt;               achieved by the caller who deletes the old version&lt;br/&gt;
&amp;gt;               before adding the new.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;OK Javadoc re-written&lt;/p&gt;

&lt;p&gt;&amp;gt;     b) I do not like the hard-coding of constants for field numbers&lt;br/&gt;
&amp;gt;        and field counts.&lt;/p&gt;

&lt;p&gt;Changed them into constants.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     c) Why are you recalculating extraColumns every time?  Will it not&lt;br/&gt;
&amp;gt;        be the same value for the entire lifetime of the object?&lt;/p&gt;

&lt;p&gt;OK Made extraColumns as private property in the class and set it in the &lt;br/&gt;
constructor&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     d) Why is there some code in comments for the assignment to&lt;br/&gt;
&amp;gt;        hashRowArray&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;? &lt;/p&gt;

&lt;p&gt;OK Removed!&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     e) I am not quite sure, but would it not be better if position was&lt;br/&gt;
&amp;gt;        a parameter to the function?  That would make the dependency on&lt;br/&gt;
&amp;gt;        the calling code more clear.&lt;/p&gt;

&lt;p&gt;OK, added the position as parameter to addRowToHashTable&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.6 getRowFromHashTable()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) You are creating an object every time you do a lookup in the&lt;br/&gt;
&amp;gt;        hash table.  Would it be an idea to have a single SQLInteger&lt;br/&gt;
&amp;gt;        object that is reused for this purpose?&lt;/p&gt;

&lt;p&gt;OK Created private variable positionInHashTable.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     b) Disabled code in comments.  Any reason why it is not just&lt;br/&gt;
&amp;gt;        removed?&lt;/p&gt;

&lt;p&gt;OK Removed&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.7 positionInLastFetchedRow()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) No JavaDoc&lt;/p&gt;

&lt;p&gt;OK Added javadoc.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     b) Line exceeding 80 columns (not the only case.)&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     c) Assignment of currentPosition:  Could not this be done for all&lt;br/&gt;
&amp;gt;        cases at the end (outside the if statement).&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.8 updateCachedRow()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) Are you sure that if a projection is needed that this will be&lt;br/&gt;
&amp;gt;        done by the top node of the source tree?  Could not there be&lt;br/&gt;
&amp;gt;        cases where a projection is needed even if source is of a&lt;br/&gt;
&amp;gt;        different type?  (E.g., the source of source is a&lt;br/&gt;
&amp;gt;        ProjectRestrictResultSet)&lt;/p&gt;

&lt;p&gt;The types of result sets you can get in updatable result sets seems to be&lt;br/&gt;
reduced, since there are restrictions to the type of query that can give&lt;br/&gt;
an updatable result set. I have not been able to find a case where &lt;br/&gt;
ProjectRestrict is not the top one. The other types that we have seen in &lt;br/&gt;
this context are TableScan and IndexRowToBaseRow which would logically&lt;br/&gt;
come under a ProjectRestrict.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     b) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;OK Found two places.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.9 isDeleted()/isUpdated()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) It does not seem to be necessary to cast the objects stored in&lt;br/&gt;
&amp;gt;        the hash table to DataValueDescriptor[] in order to access its&lt;br/&gt;
&amp;gt;        contents.  (Not doing so, could shorten some lines that are too&lt;br/&gt;
&amp;gt;        long  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 1.10  setRowLocation()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     a) I am not entirely happen with the name.  It sounds more like an&lt;br/&gt;
&amp;gt;        attribute is being updated than that the underlying cursor is&lt;br/&gt;
&amp;gt;        repositioned.&lt;/p&gt;

&lt;p&gt;OK. Renamed to positionScanAtRowLocation().&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     b) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     c) Would not an assert be better than if-test in this case?  It&lt;br/&gt;
&amp;gt;        seems to me that the code depends on the source being a&lt;br/&gt;
&amp;gt;        CursorResultSet.&lt;/p&gt;

&lt;p&gt;OK Not an issue longer, moved to NoPutResultSet.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 2. UpdateResultSet/DeleteResultSet&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    a) Why is updateCachedRow()/markCachedRowAsDeleted() made general&lt;br/&gt;
&amp;gt;       methods on NoPutResultSet?  That requires touching a lot of&lt;br/&gt;
&amp;gt;       classes not concerned with scrollable cursors.  Would it not be&lt;br/&gt;
&amp;gt;       possible to detect that the source is a&lt;br/&gt;
&amp;gt;       ScrollInsensitiveResultSet, and do the necessary casting in this&lt;br/&gt;
&amp;gt;       case.  If you insist on making these general methods, I would&lt;br/&gt;
&amp;gt;       suggest calling them updateRow/markRowAsDeleted and let each&lt;br/&gt;
&amp;gt;       ResultSet do whatever it needs to do when rows are&lt;br/&gt;
&amp;gt;       updated/deleted.&lt;/p&gt;

&lt;p&gt;ScrollInsensitiveResultSet is never the source, but the source of the&lt;br/&gt;
source ... of the source. I have renamed the two methods as you suggested.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;    b) Is there a reason why you place the calls in open() and not in&lt;br/&gt;
&amp;gt;       collectAffectedRows()?&lt;/p&gt;

&lt;p&gt;I have moved the calls to collectAffectedRows() and update/deleteDefferedRows().&lt;br/&gt;
I had called them in open so that I would only need to call them once for each&lt;br/&gt;
update, but if later other types of result sets need to use these methods it&lt;br/&gt;
is better that they are called after each updated row instead of only once. For&lt;br/&gt;
positioned updated, it would only be one affected row, so it would not be a&lt;br/&gt;
problem to call the methods from open().&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;    c) You make the assumption that only a single row is affected.&lt;br/&gt;
&amp;gt;       This may be the case for scrollable cursors, but generally&lt;br/&gt;
&amp;gt;       open() may update/delete many rows.  I think that needs to be&lt;br/&gt;
&amp;gt;       explained in the code.&lt;/p&gt;

&lt;p&gt;For SUR we are only interested in positioned updates which would result&lt;br/&gt;
in one row being updated, but I have moved the method calls so that they&lt;br/&gt;
can be used for other types of result sets later if necessary.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 3. ProjectRestrictResultSet&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; 3.1 setRowlocation()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    a) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;Changed to see NoPutResultSet.setRowLocation and added specific&lt;br/&gt;
comments to those implementations that needed it.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) Assert instead of if-test?&lt;/p&gt;

&lt;p&gt;Not needed anymore since it is a part of NoPutResultSet.&lt;/p&gt;

&lt;p&gt;&amp;gt; 3.2 doBaseRowProjection()&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    a) Javadoc: Parameter name is missing (not the only case).&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) The test for (source!=null) is not necessary.&lt;/p&gt;

&lt;p&gt;Agree. Changed.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; 4. NoPutResultSet/CursorResultSet&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;    a) I have not really understood the relationship between&lt;br/&gt;
&amp;gt;       CursorResultSet and NoPutResultSet.  Will there be classes that&lt;br/&gt;
&amp;gt;       implement CursorResultSet but not NoPutResultSet, and vice&lt;br/&gt;
&amp;gt;       versa?&lt;/p&gt;

&lt;p&gt;There are result sets that are NoPut but not Cursor, the opposite&lt;br/&gt;
does not happen.&lt;/p&gt;


&lt;p&gt;&amp;gt;    b) Originally CursorResultSet has only get...() methods,&lt;br/&gt;
&amp;gt;       getRowLocation() and getCurrentRow().  You have added&lt;br/&gt;
&amp;gt;       setRowLocation(), but setCurrentRow() is part of NoPutResultSet.&lt;br/&gt;
&amp;gt;       This is a bit assymetric.  If you had added setRowLocation to&lt;br/&gt;
&amp;gt;       NoPutResultSet you would also have avoided a lot casting by&lt;br/&gt;
&amp;gt;       callers.&lt;/p&gt;

&lt;p&gt;Moved to NoPutResultSet.&lt;/p&gt;

&lt;p&gt;&amp;gt;5. TableScanResultSet&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;5.1 General:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) I do not understand why you need to prevent re-qualification.&lt;br/&gt;
&amp;gt;       When will you need to read a row again?  I thought you were&lt;br/&gt;
&amp;gt;       getting the row from the hash table on later accesses.&lt;/p&gt;

&lt;p&gt;Right before an positioned update/delete is performed, CurrentOfResultSet &lt;br/&gt;
is used to get the current row. This will re-read the row, and re-qualify &lt;br/&gt;
before it is updated. That&apos;s the moment when we do not want to re-qualify, &lt;br/&gt;
since changes can have been done to the row that makes it no longer &lt;br/&gt;
qualify  and we don&apos;t want that to happen, since according to our chosen &lt;br/&gt;
semantics for insensitive result sets, rows will remain in the result, in &lt;br/&gt;
the same place, even if they no longer qualify according to the original&lt;br/&gt;
query.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) Both the write-up and the added comment only talks about&lt;br/&gt;
&amp;gt;       qualification.  It does not mention anything about&lt;br/&gt;
&amp;gt;       currentRowIsValid which does seem to address another issue.&lt;/p&gt;

&lt;p&gt;currentRowIsValid is set to the result of positioning at the rowLocation, &lt;br/&gt;
if positioning at rowLocation returs false, the row has been deleted &lt;br/&gt;
under our feet. Whenenver currentRowIsValid is false it means that the &lt;br/&gt;
row has been deleted.&lt;/p&gt;

&lt;p&gt;Write-up updated.&lt;/p&gt;

&lt;p&gt;&amp;gt;5.2 getRowLoaction()/getCurrentRow()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) It seems like you have changed the behavior of these functions.&lt;br/&gt;
&amp;gt;       Should not the JavaDoc be updated to reflect that?  (e.g., when&lt;br/&gt;
&amp;gt;       null is returned seems to have changed) &lt;/p&gt;

&lt;p&gt;OK The javadoc was not updated from before for getCurrentRow(). Updated &lt;br/&gt;
both javadocs.&lt;/p&gt;

&lt;p&gt;&amp;gt;5.3 setRowLocation()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) It seems like the comment relates to the testing on isKeyed.&lt;br/&gt;
&amp;gt;       This relation could have been more obvious.  &lt;/p&gt;

&lt;p&gt;OK. Changed the comment.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) Thinking about B-Tree scans: What if a query does not need to&lt;br/&gt;
&amp;gt;       access the base table only; the index.  (That is, all selected&lt;br/&gt;
&amp;gt;       columns are part of the index.)  How does the re-positioning&lt;br/&gt;
&amp;gt;       work in this case?&lt;/p&gt;

&lt;p&gt;The plan is to remove that optimization if the result set is of type&lt;br/&gt;
scrollable insensitive updatable. This seems to also be a problem for&lt;br/&gt;
forward-only result set, jira issue &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1087&quot; title=&quot;Updatable result sets behave different depending on the type of query used to generate the result set&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1087&quot;&gt;&lt;del&gt;DERBY-1087&lt;/del&gt;&lt;/a&gt; describes the problem.&lt;/p&gt;

&lt;p&gt;&amp;gt;6. IndexRowToBaseRowResultSet&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;6.1 positionFromRowLocation&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) Same question as for TableScanResultSet, when do you need to&lt;br/&gt;
&amp;gt;       refetch the row from the heap?&lt;/p&gt;

&lt;p&gt;Same answer as for 5.1&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) I would like a comment that says what concept&lt;br/&gt;
&amp;gt;       positionFromRowLocation represents.&lt;/p&gt;

&lt;p&gt;Ok, comment added.&lt;/p&gt;

&lt;p&gt;&amp;gt;6.2 getCurrentRow()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) The diff would have meen much smaller if you had structured&lt;br/&gt;
&amp;gt;       this as follows:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;       if (positionFromRowLocation) &lt;/p&gt;
{
&amp;gt;           &amp;lt;new code&amp;gt;
&amp;gt;           return currentRow;
&amp;gt;       }
&lt;p&gt;&amp;gt;       &amp;lt;old code&amp;gt;&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) A comment on why your are testing on positionFromRowLocation&lt;br/&gt;
&amp;gt;       would be nice.&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;7. CurrentOfResultSet&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;7.1 getNextRowCore()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) I can not find that these changes is listed in the list of code&lt;br/&gt;
&amp;gt;       changes in the writeup.&lt;/p&gt;

&lt;p&gt;write-up updated.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) Is skipping the call to target.getCurrentRow() necessary or&lt;br/&gt;
&amp;gt;       just an optimization?&lt;/p&gt;

&lt;p&gt;Not necessary, but if the rowLocation is NULL we know that the row&lt;br/&gt;
has been deleted.&lt;/p&gt;

&lt;p&gt;&amp;gt;    c) I do not understand the comment for when to add the warning.&lt;br/&gt;
&amp;gt;       Why was there not any need for a warning earlier?&lt;/p&gt;

&lt;p&gt;The cursor result set for a forward-only updatable result set will be sensitive to changes. The warning was not needed before because if the row had been deleted under our feet, the cursor result set would return NULL for cursorRow and an exception would be thrown. Now that the cursor result set is a ScrollInsensitiveResultSet, if a row is deleted under our feet, the ScrollInsensitiveResultSet will still return the cached row from the hash table (not NULL) while the target result set will return a currentRow that is NULL, this is the situation that causes the warning.&lt;/p&gt;

&lt;p&gt;&amp;gt;    d) Typo: coursor&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;7.2 updateCachedRow()/markCachedRowAsDeleted()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) Isn&apos;t the cursor already available as an object attribute?&lt;/p&gt;

&lt;p&gt;Yes, OK.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) Another instance of missing parameter name in Javadoc&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;8. TemporaryRowHolderResultSet&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;8.1 All new methods: I think the Javadoc should mention that these&lt;br/&gt;
&amp;gt;    methods are no-ops.&lt;/p&gt;

&lt;p&gt;Ok&lt;/p&gt;

&lt;p&gt;&amp;gt;9. NoPutResultSetImpl&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;9.1 Imports:  Why do you need to import CursorResultSet?&lt;/p&gt;

&lt;p&gt;OK. Removed&lt;/p&gt;

&lt;p&gt;&amp;gt;9.2 setCurrentRow()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) Why have you removed &apos;final&apos;?  I cannot find that you have&lt;br/&gt;
&amp;gt;       added any method that overrides this method.&lt;/p&gt;

&lt;p&gt;OK. Put final back.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) I guess it makes sense to set its currentRow here, but why was&lt;br/&gt;
&amp;gt;       it not necessary before?&lt;/p&gt;

&lt;p&gt;The change was done so that from now on we do not need to do this:&lt;br/&gt;
	currentRow = XXX;&lt;br/&gt;
	setCurrentRow(XXX);&lt;br/&gt;
you can just do:&lt;br/&gt;
	setCurrentRow(XXX);&lt;/p&gt;

&lt;p&gt;&amp;gt;9.3 updateCachedRow()/markCachedRowAsDeleted()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) I think the Javadoc should mention that these methods are&lt;br/&gt;
&amp;gt;       no-ops.&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;9.4 setRowLocation()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) Another instance of missing parameter name in Javadoc&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) Typo: Positiones&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;&amp;gt;    c) I do not understand the call to targetResultSet.&lt;br/&gt;
&amp;gt;       targetResultSet is as far as I can tell always an&lt;br/&gt;
&amp;gt;       InsertResultSet which, according to the javadoc, is used to&lt;br/&gt;
&amp;gt;       insert rows from a source into a base table.  How is this&lt;br/&gt;
&amp;gt;       relevant to what you are doing?&lt;/p&gt;

&lt;p&gt;Never reached, removed.&lt;/p&gt;

&lt;p&gt;&amp;gt;10. NormalizeResultSet&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;10.1 updateCachedRow()&lt;br/&gt;
&amp;gt;        &lt;br/&gt;
&amp;gt;     a) Another instance of missing parameter name in Javadoc&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;


&lt;p&gt;&amp;gt;11. ScanController&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;11.1 fetchWithoutQualify()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) I think the Javadoc should be more verbose and at least list&lt;br/&gt;
&amp;gt;        parameters and contain &quot;@see fetch&quot;.  I also think it would&lt;br/&gt;
&amp;gt;        have been nice to be a bit more verbose on what not applying&lt;br/&gt;
&amp;gt;        qualifiers mean.&lt;/p&gt;

&lt;p&gt;OK. Added more comments.&lt;/p&gt;

&lt;p&gt;&amp;gt;     b) I would have placed this new method below fetch&lt;/p&gt;

&lt;p&gt;OK. Moved&lt;/p&gt;

&lt;p&gt;&amp;gt;11.2 positionAtRowLocation()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) Why can not clients use the existing reopenScanByRowLocation&lt;br/&gt;
&amp;gt;        instead?&lt;/p&gt;

&lt;p&gt;Part of 1067 now, Andreas will comment on it.&lt;/p&gt;

&lt;p&gt;&amp;gt;12. GenericScanController&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;12.1 reopenScanByRecordHandleAndSetLocks()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) If I have understood things correct, when a scan is initially&lt;br/&gt;
&amp;gt;        opened, the first row is not locked.  Locking happen on the&lt;br/&gt;
&amp;gt;        subsequent next().  Why could not a similar scheme be used&lt;br/&gt;
&amp;gt;        here? That is, reopen positions just before the specified row&lt;br/&gt;
&amp;gt;        and a subsequent call to next is performed to actually lock&lt;br/&gt;
&amp;gt;        it.  Looking at fetchRows() and the methods it calls, there&lt;br/&gt;
&amp;gt;        seems to already exist code to handle a repositioned scan.&lt;br/&gt;
&amp;gt;        (The combination of SCAN_INIT and a set record posisiton).&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     b) I am still a bit uncomfortable with the method names in the&lt;br/&gt;
&amp;gt;        following call path: &lt;br/&gt;
&amp;gt;            setRowLocation() &lt;br/&gt;
&amp;gt;                positionAtRowLocation()&lt;br/&gt;
&amp;gt;                    reopenScanByRecordHandleAndSetLocks().  &lt;br/&gt;
&amp;gt;        The lower levels makes more happen than the names of the high&lt;br/&gt;
&amp;gt;        level methods indicates.&lt;/p&gt;

&lt;p&gt;Part of 1067 now, Andreas will comment on it.&lt;/p&gt;

&lt;p&gt;&amp;gt;13. Scan/SortBufferRowSource/SortScan&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;13.1 Javadoc&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) Javadoc: I think you should at least put a sentence about what&lt;br/&gt;
&amp;gt;        the methods does in addition to referring to the methods of&lt;br/&gt;
&amp;gt;        ScanController.  At least for some of these classes, that&lt;br/&gt;
&amp;gt;        seems to be the pattern that has previously been used.&lt;/p&gt;

&lt;p&gt;OK. Added a line about what it is supposed to do even though not implemented&lt;/p&gt;

&lt;p&gt;&amp;gt;     b) I think the Javadoc should say that these methods will always&lt;br/&gt;
&amp;gt;        throw exceptions.&lt;/p&gt;

&lt;p&gt;OK. Added a line that the method always throws exception&lt;/p&gt;

&lt;p&gt;&amp;gt;14. BTreeScan&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;14.1 fetch()/fetchWithoutQualify()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) I do not think it is good that both methods has the same&lt;br/&gt;
&amp;gt;        Javadoc description.&lt;/p&gt;

&lt;p&gt;OK. Specified on WithoutQualify that it does not apply qualifiers.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;14.2 positionAtRowLocation ()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) See comment 13.1&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;Part of 1067 now, Andreas will comment on it.&lt;/p&gt;

&lt;p&gt;&amp;gt;15. HeapScan&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;15.1 positionAtRowLocation()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) See 13.1 a)&lt;/p&gt;

&lt;p&gt;Part of 1067 now, Andreas will comment on it.&lt;/p&gt;

&lt;p&gt;&amp;gt;16. DiskHashTable&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;16.1 Constructor&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) It seems strange to me that you need special handling in order&lt;br/&gt;
&amp;gt;        to be able to store RowLocation in the hash tables that is not&lt;br/&gt;
&amp;gt;        necessary for any other types.  Is the problem the&lt;br/&gt;
&amp;gt;        getNewNull() is broken for RowLocation?  Maybe that problem&lt;br/&gt;
&amp;gt;        could be fixed in stead?&lt;/p&gt;

&lt;p&gt;OK. Fixed getNewNUll() for HeapRowLocation.&lt;/p&gt;</comment>
                            <comment id="12370358" author="fernanda" created="Tue, 14 Mar 2006 22:47:50 +0000"  >&lt;p&gt;I have found some more information to complement my answer to 1.4. I also decided to keep the way to get the targetResultSet in ScrollInsensitiveResultSet.java equal to how it is done in CurrentOfResultSet (1.4.b), so I am attaching a new patch. &lt;/p&gt;

&lt;p&gt;From ActivationClassBuilder.java line 350:&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Updatable cursors&lt;/li&gt;
	&lt;li&gt;need to add a field and its initialization&lt;/li&gt;
	&lt;li&gt;for use in BaseActivation to access the result set that&lt;/li&gt;
	&lt;li&gt;identifies target rows for a positioned update or delete.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;The code that is generated is:&lt;/li&gt;
	&lt;li&gt;&amp;lt;pre&amp;gt;&amp;lt;verbatim&amp;gt;&lt;/li&gt;
	&lt;li&gt;private CursorResultSet targetResultSet;&lt;br/&gt;
	 *&lt;/li&gt;
	&lt;li&gt;&amp;lt;/verbatim&amp;gt;&amp;lt;/pre&amp;gt;&lt;br/&gt;
	 *&lt;/li&gt;
	&lt;li&gt;The expression that is generated is:&lt;/li&gt;
	&lt;li&gt;&amp;lt;pre&amp;gt;&amp;lt;verbatim&amp;gt;&lt;/li&gt;
	&lt;li&gt;(ResultSet) (targetResultSet = (CursorResultSet) #expression#)&lt;/li&gt;
	&lt;li&gt;&amp;lt;/verbatim&amp;gt;&amp;lt;/pre&amp;gt;&lt;br/&gt;
	 *&lt;br/&gt;
	 */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And from line 309:&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Updatable cursors&lt;/li&gt;
	&lt;li&gt;need to add a getter method for use in BaseActivation to access&lt;/li&gt;
	&lt;li&gt;the result set that identifies target rows for a positioned&lt;/li&gt;
	&lt;li&gt;update or delete.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;The code that is generated is:&lt;/li&gt;
	&lt;li&gt;&amp;lt;pre&amp;gt;&amp;lt;verbatim&amp;gt;&lt;/li&gt;
	&lt;li&gt;public CursorResultSet getTargetResultSet() 
{
	 *	    return targetResultSet;
	 *  }
&lt;p&gt;	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public CursorResultSet getCursorResultSet() 
{
	 *		return cursorResultSet;
	 *  }&lt;/li&gt;
	&lt;li&gt;&amp;lt;/verbatim&amp;gt;&amp;lt;/pre&amp;gt;&lt;br/&gt;
	 *&lt;br/&gt;
	 */&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12370495" author="oysteing" created="Wed, 15 Mar 2006 19:20:03 +0000"  >&lt;p&gt;Thanks for addressing my comments.  I have only looked at code that is&lt;br/&gt;
related to earlier comments.  If other code has been added in the&lt;br/&gt;
later patches, please, point me to it. &lt;/p&gt;

&lt;p&gt;Basically, the changes looks good, but I still have a few questions&lt;br/&gt;
which is probably more about my understanding of this.&lt;/p&gt;

&lt;p&gt;Fernanda Pizzorno (JIRA) wrote:&lt;br/&gt;
&amp;gt;&amp;gt; 1. ScrollInsensitiveResultSet:&lt;br/&gt;
&amp;gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;I would like Javadoc for all the attributes you have added to the&lt;br/&gt;
class.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 1.4 getNextRowFromSource()&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     a) Comment: I am not able to understand what is going on here&lt;br/&gt;
&amp;gt;&amp;gt;        based on the comment:&lt;br/&gt;
&amp;gt;&amp;gt;             - &quot;candidate&quot; is not mention anywhere else in this class,&lt;br/&gt;
&amp;gt;&amp;gt;               and needs to be defined.  &lt;br/&gt;
&amp;gt;&amp;gt;             - You mention TableScanResultSet, but I do not find any&lt;br/&gt;
&amp;gt;&amp;gt;               assumption in the code about that being the only&lt;br/&gt;
&amp;gt;&amp;gt;               possible type of the result set.  It is also unclear&lt;br/&gt;
&amp;gt;&amp;gt;               whether you are talking about target or source here.&lt;br/&gt;
&amp;gt;&amp;gt;             - Why does these ResultSets need to refer to the same row,&lt;br/&gt;
&amp;gt;&amp;gt;               and why does it help to set the current row to null?  &lt;br/&gt;
&amp;gt;&amp;gt;             - It is unclear to me what the relation is between the&lt;br/&gt;
&amp;gt;&amp;gt;               target result set and this result set.  Is this&lt;br/&gt;
&amp;gt;&amp;gt;               explained somewhere?&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; OK Re-written&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt; OK The target result set that we get using&lt;br/&gt;
&amp;gt; target = lcc.lookupCursorActivation(getCursorName()).getTargetResultSet();&lt;br/&gt;
&amp;gt; Is the result set that is closer to the scan. Usually a TableScanResultSet&lt;br/&gt;
&amp;gt; or IndexRowToBaseRowResultSet.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;This confuses me.  I thought source was the result set closer to the&lt;br/&gt;
scan.  At least, it is where you get the rows from.  Or are you saying&lt;br/&gt;
that the target may be closer to the scan than the source?  Why is then&lt;br/&gt;
called target?  If I understand you correctly, getTargetResultSet does&lt;br/&gt;
not return a TargetResultSet.  This naming is very confusing.  (I know&lt;br/&gt;
it is not your fault.)&lt;/p&gt;

&lt;p&gt;If I understand the comments from ActivationClassBuilder correctly,&lt;br/&gt;
the target result is the result set used for position updates.  In&lt;br/&gt;
that case, I do not understand why you need to change the position of&lt;br/&gt;
the source result set when repositioning.  It seems to me that is only&lt;br/&gt;
used to populate the hash table.&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;     b) Having to look up something by cursor name, indicates to me&lt;br/&gt;
&amp;gt;&amp;gt;        that you increasing the coupling between modules that by design&lt;br/&gt;
&amp;gt;&amp;gt;        was not intended to be coupled.  Also, this class already has a&lt;br/&gt;
&amp;gt;&amp;gt;        reference to an Activation.  Is this the same or some other&lt;br/&gt;
&amp;gt;&amp;gt;        Activation?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Using activation now to get the target result set.&lt;/p&gt;

&lt;p&gt;I see you reverted this in the latest patch.  Why cannot the local&lt;br/&gt;
activation be used?  Is it not the same activation? &lt;/p&gt;


&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; 1.5 addRowToHashTable()&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     a) Javadoc:&lt;br/&gt;
&amp;gt;&amp;gt;             - key is no longer positionInSource, but currentPosition.         &lt;br/&gt;
&amp;gt;&amp;gt;             - typo: &quot;this methods&quot;&lt;br/&gt;
&amp;gt;&amp;gt;             - You say that this method &quot;is used in order to store the&lt;br/&gt;
&amp;gt;&amp;gt;               new values of that row&quot;.  I think this is a bit&lt;br/&gt;
&amp;gt;&amp;gt;               misleading since this method only adds row to the hash&lt;br/&gt;
&amp;gt;&amp;gt;               table; it does not relate to updates.  Updates are&lt;br/&gt;
&amp;gt;&amp;gt;               achieved by the caller who deletes the old version&lt;br/&gt;
&amp;gt;&amp;gt;               before adding the new.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; OK Javadoc re-written&lt;/p&gt;


&lt;p&gt;You have not adressed the last comment.&lt;/p&gt;


&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;     b) I do not like the hard-coding of constants for field numbers&lt;br/&gt;
&amp;gt;&amp;gt;        and field counts.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Changed them into constants.&lt;/p&gt;

&lt;p&gt;Good, but there are still some hard-coding in other methods.  &lt;/p&gt;

&lt;p&gt;I also think you can remove the comments on the assignments since&lt;br/&gt;
using constants the code becomes self-explanatory. &lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt; 1.7 positionInLastFetchedRow()&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     a) No JavaDoc&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; OK Added javadoc.&lt;/p&gt;

&lt;p&gt;Typos: Positiones, proviously, &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 1.8 updateCachedRow()&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     a) Are you sure that if a projection is needed that this will be&lt;br/&gt;
&amp;gt;&amp;gt;        done by the top node of the source tree?  Could not there be&lt;br/&gt;
&amp;gt;&amp;gt;        cases where a projection is needed even if source is of a&lt;br/&gt;
&amp;gt;&amp;gt;        different type?  (E.g., the source of source is a&lt;br/&gt;
&amp;gt;&amp;gt;        ProjectRestrictResultSet)&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The types of result sets you can get in updatable result sets seems to be&lt;br/&gt;
&amp;gt; reduced, since there are restrictions to the type of query that can give&lt;br/&gt;
&amp;gt; an updatable result set. I have not been able to find a case where &lt;br/&gt;
&amp;gt; ProjectRestrict is not the top one. The other types that we have seen in &lt;br/&gt;
&amp;gt; this context are TableScan and IndexRowToBaseRow which would logically&lt;br/&gt;
&amp;gt; come under a ProjectRestrict.&lt;/p&gt;

&lt;p&gt;This might well be the case.  Is there some way of verifying this?&lt;br/&gt;
And how easy will it be to detect the problem if new &quot;top nodes&quot; are&lt;br/&gt;
introduced?  And would it require a major rewrite to handle that?&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;     b) Javadoc: Parameter name is missing (not the only case).&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; OK Found two places.&lt;/p&gt;

&lt;p&gt;I have not verified that this is fixed everywhere for the latest&lt;br/&gt;
patch.  Could you please, generate javadoc and check warnings?&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 5. TableScanResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; 5.1 General:&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;    a) I do not understand why you need to prevent re-qualification.&lt;br/&gt;
&amp;gt;&amp;gt;       When will you need to read a row again?  I thought you were&lt;br/&gt;
&amp;gt;&amp;gt;       getting the row from the hash table on later accesses.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Right before an positioned update/delete is performed, CurrentOfResultSet &lt;br/&gt;
&amp;gt; is used to get the current row. This will re-read the row, and re-qualify &lt;br/&gt;
&amp;gt; before it is updated. That&apos;s the moment when we do not want to re-qualify, &lt;br/&gt;
&amp;gt; since changes can have been done to the row that makes it no longer &lt;br/&gt;
&amp;gt; qualify  and we don&apos;t want that to happen, since according to our chosen &lt;br/&gt;
&amp;gt; semantics for insensitive result sets, rows will remain in the result, in &lt;br/&gt;
&amp;gt; the same place, even if they no longer qualify according to the original&lt;br/&gt;
&amp;gt; query.&lt;/p&gt;

&lt;p&gt;I still does not see how this impact the insensitivity since I would&lt;br/&gt;
think the row will still be present in the hash table.  Will not the&lt;br/&gt;
update be performed if the row does not qualify?&lt;/p&gt;

&lt;p&gt;How does the CurrentOfResultSet refetch the current row?  Does it&lt;br/&gt;
involve the ScrollInsensitiveResultSet at all in order to get it?&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;    b) Both the write-up and the added comment only talks about&lt;br/&gt;
&amp;gt;&amp;gt;       qualification.  It does not mention anything about&lt;br/&gt;
&amp;gt;&amp;gt;       currentRowIsValid which does seem to address another issue.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; currentRowIsValid is set to the result of positioning at the rowLocation, &lt;br/&gt;
&amp;gt; if positioning at rowLocation returs false, the row has been deleted &lt;br/&gt;
&amp;gt; under our feet. Whenenver currentRowIsValid is false it means that the &lt;br/&gt;
&amp;gt; row has been deleted.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Write-up updated.&lt;/p&gt;

&lt;p&gt;Please, add a comment to the declaration of the attribute, too.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 5.3 positionScanAtRowLocation()  (was: setRowLocation)&lt;/p&gt;

&lt;p&gt;NEW: c) I do not understand the purpose of resumeRead.  The&lt;br/&gt;
description in JavaDoc (NoPutResultSet) is a bit confusing.  Is there&lt;br/&gt;
some way to make this a bit more general to other types of&lt;br/&gt;
NoPutResultSet?  &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 6. IndexRowToBaseRowResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; 6.1 positionFromRowLocation&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;    b) I would like a comment that says what concept&lt;br/&gt;
&amp;gt;&amp;gt;       positionFromRowLocation represents.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Ok, comment added.&lt;/p&gt;

&lt;p&gt;Typo: otherwite&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 7. CurrentOfResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; 7.1 getNextRowCore()&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;    b) Is skipping the call to target.getCurrentRow() necessary or&lt;br/&gt;
&amp;gt;&amp;gt;       just an optimization?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Not necessary, but if the rowLocation is NULL we know that the row&lt;br/&gt;
&amp;gt; has been deleted.&lt;/p&gt;

&lt;p&gt;But is it worth the extra complexity?&lt;/p&gt;

&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;    c) I do not understand the comment for when to add the warning.&lt;br/&gt;
&amp;gt;&amp;gt;       Why was there not any need for a warning earlier?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The cursor result set for a forward-only updatable result set will&lt;br/&gt;
&amp;gt; be sensitive to changes. The warning was not needed before because&lt;br/&gt;
&amp;gt; if the row had been deleted under our feet, the cursor result set&lt;br/&gt;
&amp;gt; would return NULL for cursorRow and an exception would be&lt;br/&gt;
&amp;gt; thrown. Now that the cursor result set is a&lt;br/&gt;
&amp;gt; ScrollInsensitiveResultSet, if a row is deleted under our feet, the&lt;br/&gt;
&amp;gt; ScrollInsensitiveResultSet will still return the cached row from the&lt;br/&gt;
&amp;gt; hash table (not NULL) while the target result set will return a&lt;br/&gt;
&amp;gt; currentRow that is NULL, this is the situation that causes the&lt;br/&gt;
&amp;gt; warning.&lt;/p&gt;

&lt;p&gt;I think my problem is that I have not quite understood what a target&lt;br/&gt;
result set is, and especially the reasoning behind its name.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 8. TemporaryRowHolderResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; 8.1 All new methods: I think the Javadoc should mention that these&lt;br/&gt;
&amp;gt;&amp;gt;    methods are no-ops.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Ok&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Not done for positionScanAtRowLocation.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 13. Scan/SortBufferRowSource/SortScan&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; 13.1 Javadoc&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;     a) Javadoc: I think you should at least put a sentence about what&lt;br/&gt;
&amp;gt;&amp;gt;        the methods does in addition to referring to the methods of&lt;br/&gt;
&amp;gt;&amp;gt;        ScanController.  At least for some of these classes, that&lt;br/&gt;
&amp;gt;&amp;gt;        seems to be the pattern that has previously been used.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; OK. Added a line about what it is supposed to do even though not implemented&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;Not addressed in Scan.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;     b) I think the Javadoc should say that these methods will always&lt;br/&gt;
&amp;gt;&amp;gt;        throw exceptions.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; OK. Added a line that the method always throws exception&lt;/p&gt;

&lt;p&gt;I would prefer that it also mentioned the SQLState for the exception.&lt;/p&gt;
</comment>
                            <comment id="12370799" author="oysteing" created="Fri, 17 Mar 2006 18:10:54 +0000"  >&lt;p&gt;Here are my review comments to the JDBC changes.  Generally, there are&lt;br/&gt;
also in this part of the code several Javdoc-@param without parameter&lt;br/&gt;
name.&lt;/p&gt;

&lt;p&gt;17. EmbedResultSet&lt;/p&gt;

&lt;p&gt;17.1 rowUpdated()/rowDeleted()&lt;/p&gt;

&lt;p&gt;     a) Why is checkIfClosed removed?&lt;/p&gt;

&lt;p&gt;17.2 addWarning()&lt;/p&gt;

&lt;p&gt;     a) I would like javadoc for this method&lt;/p&gt;


&lt;p&gt;18. EmbedDatabaseMetaData&lt;/p&gt;

&lt;p&gt;18.1 othersUpdatesAreVisible()&lt;/p&gt;

&lt;p&gt;     a) The added comment was placed a bit strange. Since it supposed&lt;br/&gt;
        to cover all three methods, either put it above the Javadoc&lt;br/&gt;
        for the first method, or duplicate withing Javadoc for all.&lt;/p&gt;


&lt;p&gt;19. EmbedConnection&lt;/p&gt;

&lt;p&gt;19.1 setResultSetConncurrency()&lt;/p&gt;

&lt;p&gt;     a) Is there any point in keeping this method around?  It just&lt;br/&gt;
        returns one of it input parameters.&lt;/p&gt;


&lt;p&gt;20. Added SqlState&lt;/p&gt;

&lt;p&gt;    a) Is it necessary to prefix the message with &quot;WARNING:&quot;?  I would&lt;br/&gt;
       think that would be possible to determined from the context.&lt;br/&gt;
       If kept, capitalize after colon.&lt;/p&gt;

&lt;p&gt;    b) According to the ODBC guide I have access to, this SqlState is&lt;br/&gt;
       for &quot;A positioned UPDATE or a positioned DELETE SQL statement&lt;br/&gt;
       was specified, and no row or more than one row was updated or&lt;br/&gt;
       deleted.&quot;  As far as I can tell, you will also use this warning&lt;br/&gt;
       when one reposition to a deleted row.  Is that according to the&lt;br/&gt;
       spec?&lt;/p&gt;

&lt;p&gt;    c) For the text of this message you have used the &quot;subcondition&quot;&lt;br/&gt;
       specified in the SQL spec.  Is that a requirement?  I thought&lt;br/&gt;
       the spec only put a requirement on the state and not the&lt;br/&gt;
       associated text.  I think something more descriptive, like what&lt;br/&gt;
       I found in the ODBC guide would be helpful to users.&lt;/p&gt;
</comment>
                            <comment id="12370893" author="fernanda" created="Sat, 18 Mar 2006 06:02:02 +0000"  >&lt;p&gt;Thank you for looking into the patch &#216;ystein. Here is a new patch a answer to &#216;ystein&apos;s comments.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;1. ScrollInsensitiveResultSet:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I would like Javadoc for all the attributes you have added to the&lt;br/&gt;
&amp;gt;class.&lt;/p&gt;

&lt;p&gt;OK. Added comment for all new attributes.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;1.4 getNextRowFromSource()&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    a) Comment: I am not able to understand what is going on here&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       based on the comment:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - &quot;candidate&quot; is not mention anywhere else in this class,&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              and needs to be defined.  &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - You mention TableScanResultSet, but I do not find any&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              assumption in the code about that being the only&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              possible type of the result set.  It is also unclear&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              whether you are talking about target or source here.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - Why does these ResultSets need to refer to the same row,&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              and why does it help to set the current row to null?  &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - It is unclear to me what the relation is between the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              target result set and this result set.  Is this&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              explained somewhere?&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK Re-written&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK The target result set that we get using&lt;br/&gt;
&amp;gt;&amp;gt;target = lcc.lookupCursorActivation(getCursorName()).getTargetResultSet();&lt;br/&gt;
&amp;gt;&amp;gt;Is the result set that is closer to the scan. Usually a TableScanResultSet&lt;br/&gt;
&amp;gt;&amp;gt;or IndexRowToBaseRowResultSet.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;This confuses me.  I thought source was the result set closer to the&lt;br/&gt;
&amp;gt;scan.  At least, it is where you get the rows from.  Or are you saying&lt;br/&gt;
&amp;gt;that the target may be closer to the scan than the source?  Why is then&lt;br/&gt;
&amp;gt;called target?  If I understand you correctly, getTargetResultSet does&lt;br/&gt;
&amp;gt;not return a TargetResultSet.  This naming is very confusing.  (I know&lt;br/&gt;
&amp;gt;it is not your fault.)&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;If I understand the comments from ActivationClassBuilder correctly,&lt;br/&gt;
&amp;gt;the target result is the result set used for position updates.  In&lt;br/&gt;
&amp;gt;that case, I do not understand why you need to change the position of&lt;br/&gt;
&amp;gt;the source result set when repositioning.  It seems to me that is only&lt;br/&gt;
&amp;gt;used to populate the hash table.&lt;/p&gt;

&lt;p&gt;We have a hierarchy of result sets of different types. When the top &lt;br/&gt;
result set needs to get a new row, it will get it from its source &lt;br/&gt;
(immediately under in the hierarchy), which will get it from its &lt;br/&gt;
source ... and so on, until the result set at the bottom of the &lt;br/&gt;
hierarchy fetches the row from the scan.&lt;/p&gt;

&lt;p&gt;The target result set is the one that is at the bottom of the &lt;br/&gt;
hierarchy, but if a result set accesses its source result set &lt;br/&gt;
which accesses its source ... and so on, it will end up indirectly&lt;br/&gt;
accessing the target result set.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;    b) Having to look up something by cursor name, indicates to me&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       that you increasing the coupling between modules that by design&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       was not intended to be coupled.  Also, this class already has a&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       reference to an Activation.  Is this the same or some other&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       Activation?&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Using activation now to get the target result set.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I see you reverted this in the latest patch.  Why cannot the local&lt;br/&gt;
&amp;gt;activation be used?  Is it not the same activation? &lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;Yes it is. I had forgotten to check for updatable, that&apos;s why I removed &lt;br/&gt;
it. Read-only result sets do not have a target.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;1.5 addRowToHashTable()&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    a) Javadoc:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - key is no longer positionInSource, but currentPosition.         &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - typo: &quot;this methods&quot;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;            - You say that this method &quot;is used in order to store the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              new values of that row&quot;.  I think this is a bit&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              misleading since this method only adds row to the hash&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              table; it does not relate to updates.  Updates are&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              achieved by the caller who deletes the old version&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;              before adding the new.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK Javadoc re-written&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;You have not adressed the last comment.&lt;br/&gt;
&amp;gt;&lt;/p&gt;

&lt;p&gt;OK, re-written once more.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    b) I do not like the hard-coding of constants for field numbers&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       and field counts.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Changed them into constants.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Good, but there are still some hard-coding in other methods.  &lt;/p&gt;

&lt;p&gt;OK. I believe I got all of them now.&lt;/p&gt;

&lt;p&gt;&amp;gt;I also think you can remove the comments on the assignments since&lt;br/&gt;
&amp;gt;using constants the code becomes self-explanatory. &lt;/p&gt;

&lt;p&gt;OK. Removed&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;1.7 positionInLastFetchedRow()&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    a) No JavaDoc&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK Added javadoc.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Typos: Positiones, proviously, &lt;/p&gt;

&lt;p&gt;OK. Corrected&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;1.8 updateCachedRow()&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    a) Are you sure that if a projection is needed that this will be&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       done by the top node of the source tree?  Could not there be&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       cases where a projection is needed even if source is of a&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       different type?  (E.g., the source of source is a&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       ProjectRestrictResultSet)&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;The types of result sets you can get in updatable result sets seems to be&lt;br/&gt;
&amp;gt;&amp;gt;reduced, since there are restrictions to the type of query that can give&lt;br/&gt;
&amp;gt;&amp;gt;an updatable result set. I have not been able to find a case where &lt;br/&gt;
&amp;gt;&amp;gt;ProjectRestrict is not the top one. The other types that we have seen in &lt;br/&gt;
&amp;gt;&amp;gt;this context are TableScan and IndexRowToBaseRow which would logically&lt;br/&gt;
&amp;gt;&amp;gt;come under a ProjectRestrict.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;This might well be the case.  Is there some way of verifying this?&lt;br/&gt;
&amp;gt;And how easy will it be to detect the problem if new &quot;top nodes&quot; are&lt;br/&gt;
&amp;gt;introduced?  And would it require a major rewrite to handle that?&lt;/p&gt;

&lt;p&gt;If we added the doBaseRowProjection as a public method in all NoPutResultSet, &lt;br/&gt;
and those that are not of type ProjectRestrictRS would return the results of &lt;br/&gt;
the execution of this method at their source result set, the ProjectRestrictRS &lt;br/&gt;
would no longer need to be the top one. I do not think that it is a major&lt;br/&gt;
rewrite.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;    b) Javadoc: Parameter name is missing (not the only case).&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK Found two places.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I have not verified that this is fixed everywhere for the latest&lt;br/&gt;
&amp;gt;patch.  Could you please, generate javadoc and check warnings?&lt;/p&gt;

&lt;p&gt;Done. Fixed all warnings concerning this patch.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;5. TableScanResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;5.1 General:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;   a) I do not understand why you need to prevent re-qualification.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      When will you need to read a row again?  I thought you were&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      getting the row from the hash table on later accesses.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Right before an positioned update/delete is performed, CurrentOfResultSet &lt;br/&gt;
&amp;gt;&amp;gt;is used to get the current row. This will re-read the row, and re-qualify &lt;br/&gt;
&amp;gt;&amp;gt;before it is updated. That&apos;s the moment when we do not want to re-qualify, &lt;br/&gt;
&amp;gt;&amp;gt;since changes can have been done to the row that makes it no longer &lt;br/&gt;
&amp;gt;&amp;gt;qualify  and we don&apos;t want that to happen, since according to our chosen &lt;br/&gt;
&amp;gt;&amp;gt;semantics for insensitive result sets, rows will remain in the result, in &lt;br/&gt;
&amp;gt;&amp;gt;the same place, even if they no longer qualify according to the original&lt;br/&gt;
&amp;gt;&amp;gt;query.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I still does not see how this impact the insensitivity since I would&lt;br/&gt;
&amp;gt;think the row will still be present in the hash table.  Will not the&lt;br/&gt;
&amp;gt;update be performed if the row does not qualify?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;How does the CurrentOfResultSet refetch the current row?  Does it&lt;br/&gt;
&amp;gt;involve the ScrollInsensitiveResultSet at all in order to get it?&lt;/p&gt;

&lt;p&gt;There are several levels of ResultSets in between Update/DeleteResultSet&lt;br/&gt;
and CurrentOfResultSet, but the row to be updated/deleted comes from a&lt;br/&gt;
call to CurrentOfResultSet.getNextRowCore().&lt;/p&gt;

&lt;p&gt;CurrentOfResultSet.getNextRowCore() will read a cursorRow and a currentRow.&lt;br/&gt;
The cursorRow comes from the CursorResultSet which in our case is a &lt;br/&gt;
ScrollInsensitiveResultSet, and currentRow comes from the TargetResultSet&lt;br/&gt;
which can be TableScan or IndexRowToBaseRow RS.&lt;/p&gt;

&lt;p&gt;CurrentOfResultSet uses to cursorRow to throw an exception if the cursor&lt;br/&gt;
is not on a row and the current row is the one returned to the result set&lt;br/&gt;
on top of CurrentOfResultSet.&lt;/p&gt;

&lt;p&gt;The hierarchy will usually be:&lt;/p&gt;

&lt;p&gt;1. Update/DeleteRS&lt;br/&gt;
2. DMLWriteRS&lt;br/&gt;
3. ProjectRestrictRS&lt;br/&gt;
4. CurrentOfRS&lt;/p&gt;

&lt;p&gt;The CurrentOfRS will return the currentRow from its targetRS. ProjectRestrictRS will &lt;br/&gt;
use the returned row returned by CurrentOfRS to build a new row with the information &lt;br/&gt;
that is necessary for Update/DeleteRS to update/delete the row. DMLWrite does not do &lt;br/&gt;
anything to the row, just returns it to Update/DeleteRS.&lt;/p&gt;

&lt;p&gt;If the row has been updated to values that not longer qualify, for example, if I &lt;br/&gt;
have a result set generated with the following statement: &quot;SELECT a, b FROM t1 &lt;br/&gt;
WHERE a &amp;lt; 5&quot;, and I run the following code:&lt;/p&gt;

&lt;p&gt;rs.next()&lt;br/&gt;
rs.updateInt(1, 10);&lt;br/&gt;
rs.updateRow();&lt;br/&gt;
rs.next();&lt;br/&gt;
rs.previous();&lt;br/&gt;
rs.updateInt(1, 15);&lt;br/&gt;
rs.updateRow();&lt;/p&gt;

&lt;p&gt;when we get to the second update row, the value of a in the database and result &lt;br/&gt;
set will be 10, so it will be &amp;gt; 5 and therefore not qualify. When UpdateResultSet &lt;br/&gt;
gets the row to be updated, the targetResultSet on the CurrentOfResultSet, will &lt;br/&gt;
return null as current row, because the current row has a &amp;gt; 10 and no longer &lt;br/&gt;
qualifies. That will make the CurrentOfResultSet return null as currentRow and &lt;br/&gt;
the row won&apos;t be updated, instead the application will get a &quot;Cursor operation &lt;br/&gt;
conflict&quot; warning.&lt;/p&gt;

&lt;p&gt;It is our design choice that once the row has been a part of the result set, &lt;br/&gt;
it will continue to be a part of it even though its values are changed so that &lt;br/&gt;
they no longer qualify. We chose not to have update holes in the result set, and &lt;br/&gt;
therefore, we need to keep this row in the result set even though a &amp;gt; 10. That&apos;s &lt;br/&gt;
why we want to result set to qualify only when getting a new row and not to &lt;br/&gt;
qualify again the getting the current row. &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;   b) Both the write-up and the added comment only talks about&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      qualification.  It does not mention anything about&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      currentRowIsValid which does seem to address another issue.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;currentRowIsValid is set to the result of positioning at the rowLocation, &lt;br/&gt;
&amp;gt;&amp;gt;if positioning at rowLocation returs false, the row has been deleted &lt;br/&gt;
&amp;gt;&amp;gt;under our feet. Whenenver currentRowIsValid is false it means that the &lt;br/&gt;
&amp;gt;&amp;gt;row has been deleted.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Write-up updated.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Please, add a comment to the declaration of the attribute, too.&lt;/p&gt;

&lt;p&gt;OK. Comment added&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;5.3 positionScanAtRowLocation()  (was: setRowLocation)&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;NEW: c) I do not understand the purpose of resumeRead.  The&lt;br/&gt;
&amp;gt;description in JavaDoc (NoPutResultSet) is a bit confusing.  Is there&lt;br/&gt;
&amp;gt;some way to make this a bit more general to other types of&lt;br/&gt;
&amp;gt;NoPutResultSet?  &lt;/p&gt;

&lt;p&gt;Removed. Moved the logic to TableScanResultSet instead.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;6. IndexRowToBaseRowResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;6.1 positionFromRowLocation&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;   b) I would like a comment that says what concept&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      positionFromRowLocation represents.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Ok, comment added.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Typo: otherwite&lt;/p&gt;

&lt;p&gt;Ok, corrected.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;7. CurrentOfResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;7.1 getNextRowCore()&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;   b) Is skipping the call to target.getCurrentRow() necessary or&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      just an optimization?&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Not necessary, but if the rowLocation is NULL we know that the row&lt;br/&gt;
&amp;gt;&amp;gt;has been deleted.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;But is it worth the extra complexity?&lt;/p&gt;

&lt;p&gt;Ok. Removed&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;   c) I do not understand the comment for when to add the warning.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;      Why was there not any need for a warning earlier?&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;The cursor result set for a forward-only updatable result set will&lt;br/&gt;
&amp;gt;&amp;gt;be sensitive to changes. The warning was not needed before because&lt;br/&gt;
&amp;gt;&amp;gt;if the row had been deleted under our feet, the cursor result set&lt;br/&gt;
&amp;gt;&amp;gt;would return NULL for cursorRow and an exception would be&lt;br/&gt;
&amp;gt;&amp;gt;thrown. Now that the cursor result set is a&lt;br/&gt;
&amp;gt;&amp;gt;ScrollInsensitiveResultSet, if a row is deleted under our feet, the&lt;br/&gt;
&amp;gt;&amp;gt;ScrollInsensitiveResultSet will still return the cached row from the&lt;br/&gt;
&amp;gt;&amp;gt;hash table (not NULL) while the target result set will return a&lt;br/&gt;
&amp;gt;&amp;gt;currentRow that is NULL, this is the situation that causes the&lt;br/&gt;
&amp;gt;&amp;gt;warning.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I think my problem is that I have not quite understood what a target&lt;br/&gt;
&amp;gt;result set is, and especially the reasoning behind its name.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;8. TemporaryRowHolderResultSet&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;8.1 All new methods: I think the Javadoc should mention that these&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;   methods are no-ops.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;Ok&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Not done for positionScanAtRowLocation.&lt;/p&gt;

&lt;p&gt;Done.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;13. Scan/SortBufferRowSource/SortScan&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;13.1 Javadoc&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    a) Javadoc: I think you should at least put a sentence about what&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       the methods does in addition to referring to the methods of&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       ScanController.  At least for some of these classes, that&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       seems to be the pattern that has previously been used.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK. Added a line about what it is supposed to do even though not implemented&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;Not addressed in Scan.&lt;/p&gt;

&lt;p&gt;Added javadoc to GenericScanController too.&lt;/p&gt;

&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;    b) I think the Javadoc should say that these methods will always&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;       throw exceptions.&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt;OK. Added a line that the method always throws exception&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;I would prefer that it also mentioned the SQLState for the exception.&lt;/p&gt;

&lt;p&gt;Ok&lt;/p&gt;

&lt;p&gt;&amp;gt;17. EmbedResultSet&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;17.1 rowUpdated()/rowDeleted()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) Why is checkIfClosed removed?&lt;/p&gt;

&lt;p&gt;Probably a merge problem since checkIfClosed() was commited after the first &lt;br/&gt;
patch was submitted.&lt;/p&gt;

&lt;p&gt;&amp;gt;17.2 addWarning()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) I would like javadoc for this method&lt;/p&gt;

&lt;p&gt;Added.&lt;/p&gt;

&lt;p&gt;&amp;gt;18. EmbedDatabaseMetaData&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;18.1 othersUpdatesAreVisible()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) The added comment was placed a bit strange. Since it supposed&lt;br/&gt;
&amp;gt;        to cover all three methods, either put it above the Javadoc&lt;br/&gt;
&amp;gt;        for the first method, or duplicate withing Javadoc for all.&lt;/p&gt;

&lt;p&gt;Agreed. Moved above the Javadoc for the first method.&lt;/p&gt;


&lt;p&gt;&amp;gt;19. EmbedConnection&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;19.1 setResultSetConncurrency()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;     a) Is there any point in keeping this method around?  It just&lt;br/&gt;
&amp;gt;        returns one of it input parameters.&lt;/p&gt;

&lt;p&gt;Removed.&lt;/p&gt;

&lt;p&gt;&amp;gt;20. Added SqlState&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    a) Is it necessary to prefix the message with &quot;WARNING:&quot;?  I would&lt;br/&gt;
&amp;gt;       think that would be possible to determined from the context.&lt;br/&gt;
&amp;gt;       If kept, capitalize after colon.&lt;/p&gt;

&lt;p&gt;Not really necessary.&lt;/p&gt;

&lt;p&gt;&amp;gt;    b) According to the ODBC guide I have access to, this SqlState is&lt;br/&gt;
&amp;gt;       for &quot;A positioned UPDATE or a positioned DELETE SQL statement&lt;br/&gt;
&amp;gt;       was specified, and no row or more than one row was updated or&lt;br/&gt;
&amp;gt;       deleted.&quot;  As far as I can tell, you will also use this warning&lt;br/&gt;
&amp;gt;       when one reposition to a deleted row.  Is that according to the&lt;br/&gt;
&amp;gt;       spec?&lt;/p&gt;

&lt;p&gt;The warning is added in CurrentOfResultSet. This result set is only used&lt;br/&gt;
for positioned update/delete operations. Therefore you will not get a &lt;br/&gt;
warning unless you attempt to delete/update a previously deleted row either&lt;br/&gt;
by a positioned update/delete or by calling ResultSet.updateRow() or&lt;br/&gt;
ResultSet.deleteRow() methods.&lt;/p&gt;

&lt;p&gt;&amp;gt;    c) For the text of this message you have used the &quot;subcondition&quot;&lt;br/&gt;
&amp;gt;       specified in the SQL spec.  Is that a requirement?  I thought&lt;br/&gt;
&amp;gt;       the spec only put a requirement on the state and not the&lt;br/&gt;
&amp;gt;       associated text.  I think something more descriptive, like what&lt;br/&gt;
&amp;gt;       I found in the ODBC guide would be helpful to users.&lt;/p&gt;

&lt;p&gt;Message changed to: &quot;An attempt to update or delete an already deleted row &lt;br/&gt;
was made: no row was updated or deleted.&quot;&lt;/p&gt;</comment>
                            <comment id="12371056" author="oysteing" created="Mon, 20 Mar 2006 18:15:37 +0000"  >&lt;p&gt;Thank you very much for the explanation on CurrentOfResultSet works &lt;br/&gt;
and interacts with other result sets.  It would have&lt;br/&gt;
been really nice to have had this (preferrably together with a figure),&lt;br/&gt;
when I started reviewing the patch.&lt;/p&gt;

&lt;p&gt;One tiny detail.  In the new message, I suggest the word after colon&lt;br/&gt;
be capiltalized:&lt;br/&gt;
&amp;gt; Message changed to: &quot;An attempt to update or delete an already deleted row &lt;br/&gt;
&amp;gt; was made: no row was updated or deleted.&quot;&lt;/p&gt;

&lt;p&gt;All my comments so far has been addressed.  I plan to do a quick&lt;br/&gt;
walk-through of the test changes.&lt;/p&gt;</comment>
                            <comment id="12371414" author="fernanda" created="Wed, 22 Mar 2006 20:02:39 +0000"  >&lt;p&gt;Thank you for reviewing the patch &#216;ystein. I am attaching a new patch that addresses &#216;ystein&apos;s last comment.&lt;/p&gt;

&lt;p&gt;&#216;ystein wrote:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
One tiny detail. In the new message, I suggest the word after colon&lt;br/&gt;
be capiltalized:&lt;br/&gt;
&amp;gt; Message changed to: &quot;An attempt to update or delete an already deleted row&lt;br/&gt;
&amp;gt; was made: no row was updated or deleted.&quot; &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I have changed the message from &quot;... no row was updated or deleted&quot; to &quot;... No row was updated or deleted&quot;.&lt;/p&gt;

&lt;p&gt;I have successfully run derbyall.&lt;/p&gt;</comment>
                            <comment id="12371551" author="andreask" created="Thu, 23 Mar 2006 20:39:53 +0000"  >&lt;p&gt;&amp;gt;Comment by &#216;ystein Gr&#248;vlen &lt;span class=&quot;error&quot;&gt;&amp;#91;20/Mar/06 10:15 AM&amp;#93;&lt;/span&gt;&lt;br/&gt;
&amp;gt;All my comments so far has been addressed. I plan to do a quick&lt;br/&gt;
&amp;gt;walk-through of the test changes. &lt;/p&gt;

&lt;p&gt;I have gone through the test changes, and they are ok. The tests for SUR have already been committed, and the changes in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-690&quot; title=&quot;Add scrollable, updatable, insensitive result sets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-690&quot;&gt;&lt;del&gt;DERBY-690&lt;/del&gt;&lt;/a&gt; is basically modifiying some out files and logic in existing tests to handle that scrollable cursors can be updatable in embedded mode.&lt;/p&gt;</comment>
                            <comment id="12371555" author="fernanda" created="Thu, 23 Mar 2006 20:58:27 +0000"  >&lt;p&gt;The patch has been reveiewed and all comments have been addressed. Can someone please commit this patch?&lt;/p&gt;

&lt;p&gt;Thank you in advance!&lt;/p&gt;</comment>
                            <comment id="12371556" author="fernanda" created="Thu, 23 Mar 2006 20:59:25 +0000"  >&lt;p&gt;The patch has been reveiewed and all comments have been addressed. Can someone please commit this patch?&lt;/p&gt;

&lt;p&gt;Thank you in advance!&lt;/p&gt;</comment>
                            <comment id="12371960" author="fernanda" created="Mon, 27 Mar 2006 21:21:55 +0100"  >&lt;p&gt;New patch in which we solved the merge conflicts.&lt;/p&gt;</comment>
                            <comment id="12372006" author="knutanders" created="Tue, 28 Mar 2006 03:18:12 +0100"  >&lt;p&gt;Committed revision 389202.&lt;/p&gt;</comment>
                            <comment id="12435005" author="rhillegas" created="Fri, 15 Sep 2006 16:25:25 +0100"  >&lt;p&gt;Toggling off the &quot;release note needed&quot; flag since I&apos;m already tracking this for the Release Notes and expect to cull a description from the 10.2 snapshot wiki.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12326898">DERBY-775</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="28909">DERBY-100</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12323243" name="DERBY-690-v1.diff" size="131786" author="fernanda" created="Wed, 22 Feb 2006 03:08:32 +0000"/>
                            <attachment id="12323244" name="DERBY-690-v1.stat" size="3507" author="fernanda" created="Wed, 22 Feb 2006 03:08:33 +0000"/>
                            <attachment id="12323391" name="DERBY-690-v2.diff" size="131950" author="fernanda" created="Sat, 25 Feb 2006 06:29:05 +0000"/>
                            <attachment id="12323392" name="DERBY-690-v2.stat" size="3507" author="fernanda" created="Sat, 25 Feb 2006 06:29:05 +0000"/>
                            <attachment id="12323123" name="SURChanges-v1.pdf" size="28287" author="andreask" created="Sat, 18 Feb 2006 02:20:36 +0000"/>
                            <attachment id="12324157" name="derby-690-v4.diff" size="130552" author="fernanda" created="Tue, 14 Mar 2006 21:04:54 +0000"/>
                            <attachment id="12324158" name="derby-690-v4.stat" size="3533" author="fernanda" created="Tue, 14 Mar 2006 21:04:54 +0000"/>
                            <attachment id="12324161" name="derby-690-v5.diff" size="130606" author="fernanda" created="Tue, 14 Mar 2006 22:47:49 +0000"/>
                            <attachment id="12324162" name="derby-690-v5.stat" size="3533" author="fernanda" created="Tue, 14 Mar 2006 22:47:50 +0000"/>
                            <attachment id="12324313" name="derby-690-v6.diff" size="128783" author="fernanda" created="Sat, 18 Mar 2006 06:02:02 +0000"/>
                            <attachment id="12324314" name="derby-690-v6.stat" size="3391" author="fernanda" created="Sat, 18 Mar 2006 06:02:02 +0000"/>
                            <attachment id="12324448" name="derby-690-v7.diff" size="128388" author="fernanda" created="Wed, 22 Mar 2006 20:02:38 +0000"/>
                            <attachment id="12324449" name="derby-690-v7.stat" size="3391" author="fernanda" created="Wed, 22 Mar 2006 20:02:39 +0000"/>
                            <attachment id="12324599" name="derby-690-v8.diff" size="128224" author="fernanda" created="Mon, 27 Mar 2006 21:21:49 +0100"/>
                            <attachment id="12324600" name="derby-690-v8.stat" size="3391" author="fernanda" created="Mon, 27 Mar 2006 21:21:55 +0100"/>
                            <attachment id="12320548" name="sur-proposal.txt" size="16679" author="dagw" created="Wed, 9 Nov 2005 02:28:54 +0000"/>
                            <attachment id="12323122" name="writeup-v1.html" size="18863" author="andreask" created="Sat, 18 Feb 2006 02:20:36 +0000"/>
                            <attachment id="12323393" name="writeup-v2.html" size="19921" author="fernanda" created="Sat, 25 Feb 2006 06:29:05 +0000"/>
                            <attachment id="12323873" name="writeup-v3.html" size="21335" author="dagw" created="Wed, 8 Mar 2006 01:36:02 +0000"/>
                            <attachment id="12324156" name="writeup-v4.html" size="22254" author="fernanda" created="Tue, 14 Mar 2006 21:04:54 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12328706">DERBY-934</subtask>
                            <subtask id="12329546">DERBY-1067</subtask>
                            <subtask id="12329604">DERBY-1070</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 18 Feb 2006 02:20:36 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29659</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0sjb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38441</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>