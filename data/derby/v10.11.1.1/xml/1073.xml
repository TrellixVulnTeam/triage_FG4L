<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:40:01 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1073/DERBY-1073.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1073] Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1073</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;I wanted to file this as subtask to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;, but since &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; is itself a subtask to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt;, I was not able to do so.  So I&apos;m creating this issue as a(nother) subtaks for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[ Based on derby-dev thread found here: &lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/16007&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/16007&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;If we have a query such as:&lt;/p&gt;

&lt;p&gt;select &amp;lt;...&amp;gt; from&lt;br/&gt;
   (select t1.i, t2.j from t1, t2 where &amp;lt;...&amp;gt;) X1,&lt;br/&gt;
    T3&lt;br/&gt;
where &amp;lt;...&amp;gt;&lt;/p&gt;

&lt;p&gt;then we would have one &quot;outer&quot; query and one &quot;subquery&quot;.  The outer query would be &quot;select &amp;lt;...&amp;gt; from X1, T3&quot;, the subquery would be &quot;select t1.i, t2.j from t1, t2&quot;.&lt;/p&gt;

&lt;p&gt;In this case the Derby optimizer will create two instances of OptimizerImpl: one for the outer query (call it OI_OQ) and one for the subquery (call it OI_SQ).  Each OptimizerImpl has its own timeout &quot;clock&quot; that it initializes at creation time--but never resets.  If timeout occurs, the OptimizerImpl will stop searching for &quot;the&quot; best plan and will just take the best plan found so far.&lt;/p&gt;

&lt;p&gt;That said, for every permutation of the outer query a call will be made to optimize the subquery.  To simplify things, let&apos;s assume there are only two permutations of the outer query: one with join order &lt;/p&gt;
{X1, T3} and another with join order {T3, X1}.&lt;br/&gt;
&lt;br/&gt;
Now let&apos;s say we&apos;re looking at the first permutation {X1, T3}
&lt;p&gt;.  OI_OQ will make a call to optimize the subquery represented by OI_SQ.  Let&apos;s further say that the subquery tries some permutation &lt;/p&gt;
{T1, T2} and then times out.  It then returns the plan information for {T1, T2}
&lt;p&gt; to the outer query.  The outer query, which has &lt;b&gt;not&lt;/b&gt; yet timed out, then decides to try its second permutation &lt;/p&gt;
{T3, X1}
&lt;p&gt;.  So it again makes a call to optimize the subquery.  In this case, the subquery-&lt;del&gt;which has already timed out&lt;/del&gt;-will &lt;b&gt;immediately&lt;/b&gt; return without trying to optimize anything.  The outer query will then make a decision about its second permutation based on the un-optimized subquery&apos;s plan results.&lt;/p&gt;

&lt;p&gt;This hasn&apos;t really been an issue to date because the &quot;best plan&quot; chosen by the subquery is typically independent of the outer query&apos;s current permutation--with the exception of &quot;outerCost&quot;, which is passed in from the outer query and is factored into the subquery&apos;s cost estimates.  Because of this relative independence, the plan chosen by the subquery would rarely (if ever?) change with different permutations of the outer query, so if the subquery timed out once there was no point in trying to re-optimize it again later.&lt;/p&gt;

&lt;p&gt;With &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;, though, Derby has acquired the ability to push predicates from outer queries down into subqueries--which means that the outer join order can have a very significant impact on the plan chosen by the subquery.  But because the timeout mechanism is never reset, we could end up skipping the second optimization phase of the subquery, which means we never get a chance to see how much the outer predicates can help, and thus we could end up skipping over some plans that have the potential to give us significant performance improvement.&lt;/p&gt;

&lt;p&gt;So resolution of this issue would involve resetting the timeout state for subqueries to allow the Derby optimizer to consider plans that rely on pushed predicates.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12329735">DERBY-1073</key>
            <summary>Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12325048">DERBY-649</parent>
                                    <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="army">A B</reporter>
                        <labels>
                    </labels>
                <created>Sat, 4 Mar 2006 00:43:34 +0000</created>
                <updated>Mon, 29 Jun 2009 15:36:20 +0100</updated>
                            <resolved>Fri, 26 May 2006 05:23:38 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.1.3.1</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12368731" author="army" created="Sat, 4 Mar 2006 01:09:24 +0000"  >&lt;p&gt;Attaching a patch, d1073_v1.patch, that adds logic to check to see if an OptimizerImpl has predicates that have been pushed from outer queries and, if so, resets the timeout state for that OptimizerImpl.  Otherwise, since the subquery&apos;s &quot;best plan&quot; won&apos;t change from the previous round, we leave the timeout state as it is.&lt;/p&gt;

&lt;p&gt;This approach allows the optimizer to consider plans that use pushed predicates, but at the same time it ensures that queries for which predicate pushdown is not an option will still timeout as they&apos;ve done in the past.&lt;/p&gt;

&lt;p&gt;Note that until &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; is fully committed, this change won&apos;t take effect (because we don&apos;t currently push any predicates during optimization).  Note also that there&apos;s not (to my knowledge) a good way to write a test for this because optimizer timeout is machine-dependent and thus a test that demonstrates the issue on one machine might not do so on another. &lt;/p&gt;

&lt;p&gt;I&apos;ve run derbylang on Windows 2000 with IBM 1.4.2 and saw no failures.  I actually tried running the full derbyall but my firewall blocked the server tests and thus the only tests which completed were the derbylang ones.  I&apos;ll try to run derbyall with these changes when possible.&lt;/p&gt;</comment>
                            <comment id="12368807" author="army" created="Sat, 4 Mar 2006 07:11:48 +0000"  >&lt;p&gt;Posting an updated patch based on the recent checkins for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt;.  This d1073_v2.patch does the exact same thing that d1073_v1.patch does; it&apos;s just been updated to apply cleanly with the latest trunk.&lt;/p&gt;</comment>
                            <comment id="12369234" author="bandaram" created="Tue, 7 Mar 2006 22:22:30 +0000"  >&lt;p&gt;Patch submitted to trunk.&lt;/p&gt;</comment>
                            <comment id="12370622" author="army" created="Thu, 16 Mar 2006 08:31:09 +0000"  >&lt;p&gt;As described in the derby-dev thread here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/16723&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/16723&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;the original patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1073&quot; title=&quot;Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1073&quot;&gt;&lt;del&gt;DERBY-1073&lt;/del&gt;&lt;/a&gt; was incomplete.  For details see the above thread.  In short, the &apos;default&apos; behavior for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1073&quot; title=&quot;Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1073&quot;&gt;&lt;del&gt;DERBY-1073&lt;/del&gt;&lt;/a&gt; (i.e. the case where there are no pushed predicates) combined with the changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; can result in significantly greater compilation time for some queries--as evidenced by the 4 to 7 time slow-down in the regression tests for nist/dml132.sql.&lt;/p&gt;

&lt;p&gt;The resolution to this problem is to take the changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1073&quot; title=&quot;Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1073&quot;&gt;&lt;del&gt;DERBY-1073&lt;/del&gt;&lt;/a&gt; one step further by recognizing when a subquery&apos;s optimizer has timed out and, for each round thereafter, allowing the optimizer to continue until it finds it&apos;s first complete (and valid) plan for that round.  Before d1073_timeoutFix_v1.patch the optimizer for a subquery would return immediately (i.e. without doing any optimization) for every round after the initial timeout, which led to incorrect (and exceedingly high) cost estimates.&lt;/p&gt;

&lt;p&gt;More simply put, the changes in d1073_timeoutFix_v1.patch delay subquery timeout until the optimizer for the subquery has found a legitimate cost to return.&lt;/p&gt;

&lt;p&gt;In order to have a legitimate cost, the optimizer must find at least one complete join order.  Instead of just using the first possible join order, the changes in d1073_timeoutFix_v1.patch try to guess at what the best join order will be by &quot;jumping&quot; to the join order that was most recently deemed &quot;best&quot; for the subquery prior to timeout.  It then stops optimizing (times out) and returns the cost of that join order.&lt;/p&gt;

&lt;p&gt;Note that with d1073_timeoutFix_v1.patch, the nist/dml132.sql test will still run more slowly than it did prior to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1073&quot; title=&quot;Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1073&quot;&gt;&lt;del&gt;DERBY-1073&lt;/del&gt;&lt;/a&gt;.  But a) the slow-down will be far less than the 4 to 7-time slow-down seen in the current trunk, and b) the slow-down is actually the result of more correct behavior.  The reason this slow-down is more correct is because it comes from the fact that optimizer timeout value is now correct (roughly 35ish seconds) whereas prior to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1073&quot; title=&quot;Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1073&quot;&gt;&lt;del&gt;DERBY-1073&lt;/del&gt;&lt;/a&gt; the timeout value, which was only 14-ish seconds, was incorrect because the subquery that timed out was returning an illegitimate cost estimate that in turn led to an incorrect timeout value.&lt;/p&gt;

&lt;p&gt;I ran derbyall with these changes against sane jars on Red Hat with IBM 1.4.2 and saw no new failures.&lt;/p&gt;

&lt;p&gt;I would appreciate any review comments, if anyone has the time...Thanks.&lt;/p&gt;</comment>
                            <comment id="12376834" author="army" created="Fri, 28 Apr 2006 06:58:02 +0100"  >&lt;p&gt;Timeout fix was committed with svn revision 393608.  Patch to port these changes to 10.1 is attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; and also posted here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/19330&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/19330&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12413309" author="army" created="Fri, 26 May 2006 05:23:38 +0100"  >&lt;p&gt;Timeout fix was checked into 10.1 with svn 397682, so I&apos;m marking this issue as resolved.  Thanks for the commits, Satheesh.&lt;/p&gt;</comment>
                            <comment id="12420384" author="army" created="Wed, 12 Jul 2006 02:02:49 +0100"  >&lt;p&gt;All changes committed to 10.1 and 10.2 codelines and no further issues reported, so closing.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12324243" name="d1073_timeoutFix_v1.patch" size="3136" author="army" created="Thu, 16 Mar 2006 08:31:09 +0000"/>
                            <attachment id="12323677" name="d1073_v1.patch" size="2038" author="army" created="Sat, 4 Mar 2006 01:09:24 +0000"/>
                            <attachment id="12323702" name="d1073_v2.patch" size="1978" author="army" created="Sat, 4 Mar 2006 07:11:48 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 7 Mar 2006 22:22:30 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29844</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0whz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39083</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>