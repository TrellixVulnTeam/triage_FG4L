<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:14:56 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-805/DERBY-805.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-805] Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-805</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt; implemented scalar (single table) predicate push down into UNIONs. While this improves performance for one set of queries, ability to push join-predicates further improves Derby performance by enabling use of indices where possible.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;create view V1 as select i, j from T1 union all select i,j from T2; &lt;br/&gt;
create view V2 as select a,b from T3 union all select a,b from T4; &lt;br/&gt;
insert into T1 values (1,1), (2,2), (3,3), (4,4), (5,5); &lt;/p&gt;

&lt;p&gt;For a query like&lt;/p&gt;

&lt;p&gt;select * from V1, V2 where V1.j = V2.b and V1.i =1;&lt;/p&gt;

&lt;p&gt;If the join order choosen is V1,V2, V1 can use index on V1.i (if present) following fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt;. But if there is a index on V2.b also, Derby currently can&apos;t use that index. By pushing join predicate, Derby would be able to use the index and improve performance. Some of the queries I have seen (not the one shown here...) could improve from 70-120 seconds to about one second.&lt;/p&gt;

&lt;p&gt;Note there is a good comment by Jeff Lichtman about join-predicate push down. I am copying parts of it here for completeness of this report: (Modified)&lt;/p&gt;

&lt;p&gt;If predicate push down is done during optimization, it would be possible to push joins into the union as long as it&apos;s in the right place in the join order.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;create view v as select * from t1 union all select * from t2;&lt;/p&gt;

&lt;p&gt;select * from v, t3 where v.c1 = t3.c2;&lt;/p&gt;

&lt;p&gt;In this select, if t3 is the outer table then the qualification could be pushed into the union and optimized there, but if t3 is the inner table the qualification can&apos;t be pushed into the union.&lt;/p&gt;

&lt;p&gt;If the pushing is done at preprocess time (i.e. before optimization) it is impossible to know whether a join qualification like this can be safely pushed.&lt;/p&gt;

&lt;p&gt;There&apos;s a comment in UnionNode.optimizeIt() saying:&lt;/p&gt;

&lt;p&gt;/* RESOLVE - don&apos;t try to push predicated through for now */&lt;/p&gt;

&lt;p&gt;This is where I&apos;d expect to see something for pushing predicates into the union during optimization.&lt;/p&gt;

&lt;p&gt;BTW, the business of pushing and pulling predicates during optimization can be hard to understand and debug, so maybe it&apos;s best to only handle the simple cases and do it during preprocessing.&lt;/p&gt;</description>
                <environment>generic</environment>
        <key id="12327441">DERBY-805</key>
            <summary>Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12325048">DERBY-649</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="bandaram">Satheesh Bandaram</reporter>
                        <labels>
                    </labels>
                <created>Tue, 10 Jan 2006 05:15:55 +0000</created>
                <updated>Thu, 17 Aug 2006 03:06:35 +0100</updated>
                            <resolved>Tue, 2 May 2006 07:35:18 +0100</resolved>
                                    <version>10.1.2.1</version>
                    <version>10.2.1.6</version>
                                    <fixVersion>10.1.3.1</fixVersion>
                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12366160" author="army" created="Mon, 13 Feb 2006 17:45:01 +0000"  >&lt;p&gt;Attaching a description of the changes I plan to submit for this issue.  This is a rather complicated enhancement so the description of the changes is pretty long.  In short, though, I outline a 6-step approach to pushing join predicates down into Unions:&lt;/p&gt;

&lt;p&gt;1 - Add the ability to take a predicate and scope it to a target result set so that it can be pushed to that result set.&lt;/p&gt;

&lt;p&gt;2 - Implement the &quot;pushOptPredicate()&quot; and &quot;optimizeIt()&quot; methods for UnionNodes.  The former method should take predicates that are passed into the UnionNode from outer queries, scope them (per step 1) for the left and right children of the UnionNode, and store them locally.  The latter method should then pass the scoped predicates down to both children so that they can use the predicates in their own optimize()/optimizeIt() calls.&lt;/p&gt;

&lt;p&gt;3 - Take scoped predicates (created in step 1) that are pushed into the children result sets of a UnionNode (per step 2) and allow the the children to push the scoped predicates even further down the tree, until we eventually get them to a base table.&lt;/p&gt;

&lt;p&gt;4 - Make sure predicates that are pushed down into subqueries of a UnionNode are correctly &quot;pulled&quot; back up (if they are unscoped) or discarded (if they are scoped) for every permutation seen during optimization.&lt;/p&gt;

&lt;p&gt;5 - Ensure that the best access path for a UnionNode that pushes predicates is correctly saved during optimization and correctly retrieved when it comes time to finalize the query&apos;s overall access path.&lt;/p&gt;

&lt;p&gt;6 - And finally, when optimization is complete, make sure all relevant predicates are pushed down the tree one last time and left there, in preparation for code generation.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;.html for all the gory details.&lt;/p&gt;

&lt;p&gt;I have made the changes described in this document locally and they all seem to work, with a couple of exceptions as noted at the end of the document.  I plan to break the changes down into separate patches where it&apos;s possible to do so, and will be posting those patches in the coming days.  In the meantime, if anyone has time to review this document and provide feedback/direction/suggestion, I would be grateful.  As I myself am still trying to learn all the subtleties of Derby optimization, the more feedback I get, the better...&lt;/p&gt;</comment>
                            <comment id="12366598" author="swazoo" created="Thu, 16 Feb 2006 17:11:53 +0000"  >&lt;p&gt;I have been reading Army&apos;s (A B&apos;&apos;s) document, and I have some questions.&lt;/p&gt;

&lt;p&gt;How could a predicate be pushable to only one side of a union? Can you provide an example of a predicate that can be pushed only to one side?&lt;/p&gt;

&lt;p&gt;Why are you only dealing with join predicates? It would also be useful to push simple search arguments (i.e. a column compared to a constant), and this case might  be more common than join predicates:&lt;/p&gt;

&lt;p&gt;create view v as select * from t1 union select * from t2&lt;/p&gt;

&lt;p&gt;select * from v where c = 1&lt;/p&gt;

&lt;p&gt;I would prefer to see any type of predicate pushed into a union - even those containing complex expressions. This might be hard to implement, though, as I don&apos;t know whether the cloning methods are implemented for the entire ValueNode hierarchy.&lt;/p&gt;</comment>
                            <comment id="12366729" author="army" created="Fri, 17 Feb 2006 10:05:01 +0000"  >&lt;p&gt;Pasting my reply to Jeff&apos;s question here (Jira was down this morning, so I just sent the reply to derby-dev):&lt;/p&gt;

&lt;p&gt;Jeff Lichtman (JIRA) wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt;     [ &lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-805?page=comments#action_12366598&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-805?page=comments#action_12366598&lt;/a&gt; ]&lt;br/&gt;
&amp;gt; Jeff Lichtman commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; -------------------------------------&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I have been reading Army&apos;s (A B&apos;&apos;s) document, and I have some questions.&lt;/p&gt;


&lt;p&gt;Thank you very much for taking the time to read it.  I really appreciate it.&lt;/p&gt;

&lt;p&gt;&amp;gt; How could a predicate be pushable to only one side of a union? Can you provide an example of a predicate that can be pushed only to one side?&lt;/p&gt;

&lt;p&gt;If we take something along the lines of:&lt;/p&gt;

&lt;p&gt;select ... from&lt;br/&gt;
  t2,&lt;br/&gt;
  (select * from t1 union values (1,2), (3,4), (5,6)) X1 (a,b)&lt;br/&gt;
where X1.a = t2.i;&lt;/p&gt;

&lt;p&gt;In this case the predicate X1.a = t2.i could be pushed to the left (&quot;select * from t1&quot;) and used when reading T1, but couldn&apos;t be pushed to the VALUES clause  because there&apos;s no underlying table.  If we pushed to the left but not to the right, then removed it from the UnionNode&apos;s predList-&lt;del&gt;which is the restrictionList of the ProjectRestrictNode above the UnionNode&lt;/del&gt;-the rows from the right would remain unqualified and thus we&apos;d return incorrect results (more rows that intended).&lt;/p&gt;

&lt;p&gt;&amp;gt; Why are you only dealing with join predicates? It would also be useful to push simple search arguments (i.e. a column compared to a constant), and this case might  be more common than join predicates:&lt;/p&gt;

&lt;p&gt;Actually, when I first made the changes described in the document, I pushed any predicate that was a binary relational operator with a column reference on at least one side and a query-invariant value (i.e. constant or parameter) on whichever side was not a column reference (if either).  This covered the case of a column compared to a constant.  All of my changes worked, so from a logical/coding perspective we could indeed do just that.  However, I then put in the join predicate limitation because it seemed to me (based on very brief inspection) that the case of a comparison with a constant was covered by Satheesh&apos;s fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt;, so I thought it might be extra unnecessary work to continually push/pull those predicates throughout the optimization process.  The following comments re: &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt; made me think I didn&apos;t need to worry about one-sided predicates:&lt;/p&gt;

&lt;p&gt;&amp;lt;Jeff Lichtman&amp;gt;&lt;br/&gt;
&amp;gt; BTW, the business of pushing and pulling predicates during optimization can be&lt;br/&gt;
&amp;gt; hard to understand and debug, so maybe it&apos;s best to only handle the simple&lt;br/&gt;
&amp;gt; cases and do it during preprocessing.&lt;/p&gt;

&lt;p&gt;&amp;lt;Satheesh&amp;gt;&lt;br/&gt;
The pushing is done before optimization... during preprocessing. [ ... ] You bring up a *great *point about pushing join predicates. I am not implementing this for UnionNode.&lt;/p&gt;

&lt;p&gt;And of the course, the &quot;summary&quot; of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; itself says &quot;Push join predicates into union and other set operations. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt; implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot;&lt;/p&gt;

&lt;p&gt;So given that, I figured the goal for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; was to focus on pushing join predicates--and that&apos;s what I&apos;ve done.  One final comment from OptimizerImpl further prompted me lean toward this limitation:&lt;/p&gt;

&lt;p&gt;    /*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;Pull the predicates at from the optimizable and put&lt;/li&gt;
		&lt;li&gt;them back in the predicate list.&lt;br/&gt;
    **&lt;/li&gt;
		&lt;li&gt;NOTE: This is a little inefficient because it pulls the&lt;/li&gt;
		&lt;li&gt;single-table predicates, which are guaranteed to always&lt;/li&gt;
		&lt;li&gt;be pushed to the same optimizable.  We could make this&lt;/li&gt;
		&lt;li&gt;leave the single-table predicates where they are.&lt;br/&gt;
    */&lt;br/&gt;
    pullMe.pullOptPredicates(predicateList);&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So it seemed like pushing more single-sided predicates would be adding to the &quot;inefficiency&quot; mentioned here, and since the predicates are (as I understand it) already handled in preprocessing for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-649&quot; title=&quot;Useful indexes not used in UNION ALL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-649&quot;&gt;&lt;del&gt;DERBY-649&lt;/del&gt;&lt;/a&gt;, I didn&apos;t think we&apos;d benefit from pushing them during optimization.  Perhaps I&apos;m missing something somewhere or drawing the wrong conclusion?&lt;/p&gt;

&lt;p&gt;&amp;gt; I would prefer to see any type of predicate pushed into a union - even those containing complex expressions. This might be hard to implement, though, as I don&apos;t know whether the cloning methods are implemented for the entire ValueNode hierarchy.&lt;/p&gt;

&lt;p&gt;Sounds like an &quot;itch&quot; to me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; While it might indeed be nice to push predicates containing complex expressions, that&apos;s another enhancement of its own.  I won&apos;t be doing that with my &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes.&lt;/p&gt;

&lt;p&gt;Thanks again-&lt;del&gt;I can&apos;t say that enough&lt;/del&gt;-for reading the document.  It&apos;s a huge one and I&apos;m grateful for your time and feedback.&lt;/p&gt;</comment>
                            <comment id="12366731" author="army" created="Fri, 17 Feb 2006 10:08:59 +0000"  >&lt;p&gt;Based on the 6 steps that I&apos;ve outlined in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;.html, I plan to post four separate patches for this issue, in the following order:&lt;/p&gt;

&lt;p&gt;&amp;#8211; Phase 1 &amp;#8211; The first patch will implement the changes as described in &quot;Step 5&quot; of the document, namely:&lt;/p&gt;

&lt;p&gt;	5 - Ensure that the best access path for a UnionNode that pushes&lt;br/&gt;
		predicates is correctly saved during optimization and correctly&lt;br/&gt;
		retrieved when it comes time to finalize the query&apos;s overall&lt;br/&gt;
		access path.&lt;/p&gt;

&lt;p&gt;The phase 1 patch shouldn&apos;t have any functional effect on the codeline; it&apos;s just an incremental step toward the complete fix.&lt;/p&gt;

&lt;p&gt;&amp;#8211; Phase 2 &amp;#8211; The second patch will add code for &quot;Step 1&quot;, which is:&lt;/p&gt;

&lt;p&gt;	1 - Add the ability to take a predicate and scope it to a target&lt;br/&gt;
		result set so that it can be pushed to that result set. &lt;/p&gt;

&lt;p&gt;The phase 2 patch will add code to the codeline that won&apos;t actually get executed until phase 3.  Thus, like the phase 1 patch, the phase 2 patch should have no functional effects on the codeline.&lt;/p&gt;

&lt;p&gt;&amp;#8211; Phase 3 &amp;#8211; The third patch will be the one that does the core of the predicate pushing/pulling.  This patch will cover Steps 2, 3, 4, and 6 of the steps outlined in the document.  Once this patch is committed, the changes for phase 1 and phase 2 will take effect--so phase 3 is also where I&apos;ll add tests to make sure predicates are being pushed correctly.  Note that after phase 3, any join predicates which are targeted for UNIONS will &lt;em&gt;always&lt;/em&gt; be pushed down into the union (assuming it&apos;s possible to do so).  This means that, as discussed in the document, there will be cases where Derby originally chose to do a Hash join using the predicate but will now (after phase 3) push the predicate and do a nested loop join.  This problem will then be addressed in phase 4.&lt;/p&gt;

&lt;p&gt;&amp;#8211; Phase 4 &amp;#8211; The phase 4 patch will address any unresolved issues from the first three phases, which right now means that it will include the necessary changes to allow the optimizer to make a cost-based decision about whether or not it should push the predicates, instead of always pushing them.&lt;/p&gt;

&lt;p&gt;The vast majority of the changes will go into the code as described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;.html, with potential variations due to review comments and/or improvements/alterations that I find to be necessary as I work.  So anyone who might have the opportunity to review any of the phase 1-4 patches will hopefully find it useful to read the respective parts of the document...&lt;/p&gt;</comment>
                            <comment id="12366736" author="swazoo" created="Fri, 17 Feb 2006 11:51:19 +0000"  >&lt;p&gt;Here is my reply to Army&apos;s reply (also previously posted to derby-dev):&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; How could a predicate be pushable to only one side of a union? Can you provide an example of a predicate that can be pushed only to one side?&lt;br/&gt;
&amp;gt; &amp;gt; &lt;br/&gt;
&amp;gt; If we take something along the lines of:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; select ... from&lt;br/&gt;
&amp;gt;   t2,&lt;br/&gt;
&amp;gt;   (select * from t1 union values (1,2), (3,4), (5,6)) X1 (a,b)&lt;br/&gt;
&amp;gt; where X1.a = t2.i;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; In this case the predicate X1.a = t2.i could be pushed to the left (&quot;select * from t1&quot;) and used when reading T1, but couldn&apos;t be pushed to the VALUES clause  because there&apos;s no underlying table.&lt;/p&gt;


&lt;p&gt;OK. One way to deal with this is to put a ProjectRestrictNode between the union node and the values clause as a place to park the predicate. To make things simple, you might want to always put ProjectRestrictNodes under both sides of the union during preprocessing (i.e. after binding but before optimization). In some cases the extra nodes won&apos;t be needed, but ProjectRestrictNodes (and the corresponding ProjectRestrictResultSets) are cheap. Also, you could eliminate unnecessary ProjectRestrictNodes at the end of optimization (possibly in modifyAccessPaths()).&lt;/p&gt;

&lt;p&gt;This approach would give better performance in some cases, and could simplify the code (since you wouldn&apos;t have to figure out when the predicates are pushable).&lt;/p&gt;</comment>
                            <comment id="12366748" author="army" created="Fri, 17 Feb 2006 14:08:52 +0000"  >&lt;p&gt;&amp;gt; OK. One way to deal with this is to put a ProjectRestrictNode between the union node and &lt;br/&gt;
&amp;gt; the values clause as a place to park the predicate. To make things simple, you might want &lt;br/&gt;
&amp;gt; to always put ProjectRestrictNodes under both sides of the union during preprocessing &lt;br/&gt;
&amp;gt; (i.e. after binding but before optimization). In some cases the extra nodes won&apos;t be needed, &lt;br/&gt;
&amp;gt; but ProjectRestrictNodes (and the corresponding ProjectRestrictResultSets) are cheap. &lt;br/&gt;
&amp;gt; Also, you could eliminate unnecessary ProjectRestrictNodes at the end of optimization &lt;br/&gt;
&amp;gt; (possibly in modifyAccessPaths()). &lt;/p&gt;

&lt;p&gt;Yes, that all sounds about right &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  But I wonder if that couldn&apos;t be done later as follow-up work?  Would you say that the changes I&apos;ve proposed-&lt;del&gt;namely, see if we can push the predicates to both sides and skip the push if not&lt;/del&gt;&lt;del&gt;are incorrect, or just that we could build on them to make them better?  If they&apos;re incorrect, then I&apos;ll have to look at this more.  But my feeling is that this is a(nother) way in which the pushing of join predicates could be made better once we have it working&lt;/del&gt;-i.e. something that would work well as a follow-up patch...?&lt;/p&gt;</comment>
                            <comment id="12366749" author="army" created="Fri, 17 Feb 2006 14:14:42 +0000"  >&lt;p&gt;Attaching d805_phase1_v1.patch, which is the patch for &quot;Phase 1&quot; as defined in my earlier comment.  The changes are mostly just what I described in the html document, except that I&apos;ve added logic to recurse down a UNION chain where necessary.&lt;/p&gt;

&lt;p&gt;I meant to run derbyall with these changes last night, but I messed up my environment, which means the test results were not meaningful.  I ran &quot;derbylang&quot; this evening and everything passed, so I&apos;m posting the patch.  I will run the full derbyall suite tonight and will post results tomorrow.&lt;/p&gt;</comment>
                            <comment id="12366756" author="swazoo" created="Fri, 17 Feb 2006 15:59:13 +0000"  >&lt;p&gt;&amp;gt; But I wonder if that couldn&apos;t be done later as follow-up work? Would you say that the changes I&apos;ve proposed-&lt;del&gt;namely, see if we can push the predicates to both sides and skip the push if not&lt;/del&gt;-are incorrect, or just that we could build on them to make them better?&lt;/p&gt;

&lt;p&gt;Your changes are not incorrect. I just wonder whether they wouldn&apos;t be both simpler and more complete if you didn&apos;t have to worry about whether predicates were pushed to both sides.&lt;/p&gt;

&lt;p&gt;I have the feeling you&apos;re anxious to finish this phase of the project. It&apos;s OK with me if you check in this change with the current algorithm. If you do this, please add comments to the code saying what could be changed to make it possible to apply a pushed predicate to one side only.&lt;/p&gt;</comment>
                            <comment id="12366829" author="army" created="Sat, 18 Feb 2006 03:55:11 +0000"  >&lt;p&gt;I ran derbyall last night (Windows 2000, Sun 1.4.2) with d805_phase1_v1.patch applied to my codeline and saw no new failures (only failure was xaSimplePositive.sql, which is not related to my changes).&lt;/p&gt;

&lt;p&gt;That said, I should point out that these phase 1 changes may need to be enhanced/updated at some point in the near future, depending on the results of the thread I started on derby-dev:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/14836&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/14836&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The link between that thread and d805_phase1_v1.patch is that the phase 1 patch expects &quot;trulyTheBestAccessPath&quot; for an Optimizable to be set correctly, but the issue described in the given thread may lead to situations where trulyTheBestAccessPath doesn&apos;t hold the value that it should.&lt;/p&gt;

&lt;p&gt;Note, though, the d805_phase1_v1.patch changes alone do not not affect the functionality of the codeline, so I think the patch can still be committed.  It&apos;s only when we get to Phase 3 that the issue described on derby-dev could start influencing the behavior of the codeline with my changes for predicate pushdown.&lt;/p&gt;</comment>
                            <comment id="12366831" author="army" created="Sat, 18 Feb 2006 04:00:30 +0000"  >&lt;p&gt; &amp;lt;Jeff&amp;gt;&lt;br/&gt;
&amp;gt; It&apos;s OK with me if you check in this change with the current algorithm. If you do this,&lt;br/&gt;
&amp;gt; please add comments to the code saying what could be changed to make it possible&lt;br/&gt;
&amp;gt; to apply a pushed predicate to one side only.&lt;/p&gt;

&lt;p&gt;Okay, will do. These comments will apply to the Phase 2 patch. Thanks for describing how the changes could work--that&apos;ll certain be a big help when it comes time to implement them.&lt;/p&gt;</comment>
                            <comment id="12366907" author="army" created="Sun, 19 Feb 2006 03:17:20 +0000"  >&lt;p&gt;Note to reviewers/committers: I plan to post a more robust version of the Phase 1 patch sometime soon, so it might be good to hold off on reviewing/committing d805_phase1_v1.patch until the new version can be posted and reviewed.  If it&apos;s agreed that the newer version is better (when I post it), then that version should be the one we commit.&lt;/p&gt;</comment>
                            <comment id="12366946" author="army" created="Sun, 19 Feb 2006 12:44:56 +0000"  >&lt;p&gt;Attaching a &quot;version 2&quot; of the Phase 1 patch, which does things in a more general and more robust way, based on discussed here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/14934&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/14934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The new patch is &quot;d805_phase1_v2.patch&quot;.  I&apos;m also attaching &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;_v2.html, which is a new version of the document that has been updated with details to explain the new approach for Phase 1 patch--see &quot;Step 5&quot; of section VI.  This new description matches what was said on derby-dev, with one minor change: the call to addOrLoadBestPlan() when placing an Optimizable was removed, as it turns out that it wasn&apos;t needed.  The new description also has a walk-through of what the new code does for a given example.&lt;/p&gt;

&lt;p&gt;Note that even though d805_phase1_v2.patch is a different approach, it is still the case none of the existing Derby functionality should be affected by this change.  The new code is exercised, but until we actually start pushing predicates, there should be no behavioral differences.&lt;/p&gt;

&lt;p&gt;I ran derbylang with this patch and IBM 1.4.2 with no failures.  I haven&apos;t had time to run derbyall yet, but hope to do so tonight (my poor machine is working around the clock lately, so night-time is the only time I can run the full suite).&lt;/p&gt;

&lt;p&gt;Thanks in advance for review comments.&lt;/p&gt;</comment>
                            <comment id="12366991" author="army" created="Mon, 20 Feb 2006 08:03:51 +0000"  >&lt;p&gt;I ran derbyall on Windows 2000 using IBM JDK 1.4.2 with d805_phase1_v2.patch applied and saw no new failures--only xaSimplePositive and jdbcapi.SURTest.junit failed, neither of which is caused by these changes.  So I&apos;m marking this as &quot;Patch available&quot; for review/commit.  Thanks.&lt;/p&gt;</comment>
                            <comment id="12367277" author="army" created="Wed, 22 Feb 2006 08:14:48 +0000"  >&lt;p&gt;While working with other changes for this issue, I came to realize that d805_phase1_v2 has one small problem.  That patch assumes that an OptimizerImpl will always find a &quot;best join order&quot; before it attempts to &quot;pull&quot; any Optimizables and re-position them for another join order.  But with the &quot;JUMPING&quot; functionality that the Optimizer does for queries with a large number of tables, it turns out that it is in fact possible to &quot;pull&quot; an Optimizable before finding a best join order.  So I need to update the Phase 1 patch to account for this.&lt;/p&gt;

&lt;p&gt;I already have the required fixes locally; I want to run derbylang to make sure nothing breaks, and then I will post another version of the patch.   In the meantime, I&apos;m unchecking the &quot;patch available&quot; box...&lt;/p&gt;</comment>
                            <comment id="12367414" author="army" created="Thu, 23 Feb 2006 06:03:51 +0000"  >&lt;p&gt;I&apos;ve finalized changes for d805_phase1_v3.patch but still need to run derbyall tonight to make sure there are no new diffs (I meant to do it last night but ended up tracing through code well into the night instead).&lt;/p&gt;

&lt;p&gt;In the meantime, I&apos;m posting the first version of the Phase 2 patch here: d805_phase2_v1.patch.  This patch handles the &quot;scoping&quot; logic for predicates as described in &quot;Step 1&quot; of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;_v3.html, which I&apos;m also posting here as there have been some updates since the first version.&lt;/p&gt;

&lt;p&gt;The Phase 2 patch (d805_phase2_v1.patch) is independent of the Phase 1 patch and therefore can be committed before or after Phase 1--the order in which the two are committed doesn&apos;t actually matter so long as both are committed before Phase 3.&lt;/p&gt;

&lt;p&gt;The Phase 2 patch does the following:&lt;/p&gt;

&lt;p&gt;  1. Adds the necessary logic/methods to scope a predicate&lt;br/&gt;
  2. Adds some utility methods and one new class (BaseTableNumbersVisitor)&lt;br/&gt;
	used for scoping predicates&lt;br/&gt;
  3. Adds some other simple utility methods in preparation for predicate&lt;br/&gt;
	pushdown with Phase 3.&lt;/p&gt;

&lt;p&gt;None of the new methods will ever get called until Phase 3 is committed, so d805_phase2_v1.patch should have no affect on the codeline--it&apos;s just part of incremental development.&lt;/p&gt;

&lt;p&gt;Thanks to anyone who has a chance to review and/or commit...&lt;/p&gt;</comment>
                            <comment id="12367457" author="army" created="Thu, 23 Feb 2006 11:23:58 +0000"  >&lt;p&gt;Attaching an updated patch d805_phase1_v3.patch to address the issue in my last comment.  The differences between d805_phase1_v3.patch and d805_phase1_v2.patch are summarized here:&lt;/p&gt;

&lt;p&gt;1) There was a slight off-by-one error in the optimizer JUMP logic that was causing it to pull Optimizables prematurely.  This error is what led me to realize that phase1_v2 was incomplete--however, the JUMP error &lt;em&gt;is&lt;/em&gt; still an error, so phas1_v3 fixes it (one-line change).&lt;/p&gt;

&lt;p&gt;2) phase1_v3 adds logic to only reload best plans when required, instead of doing it every single time we pull (which is what phase1_v2 did).  Since plan &quot;reload&quot; can be relatively expensive-&lt;del&gt;especially for deeply-nested subqueries&lt;/del&gt;-it&apos;s better to only do it when it&apos;s required.&lt;/p&gt;

&lt;p&gt;3) phase1_v3 adds logic to remember nested OptimizerImpl &quot;best join orders&quot; in addition to nested Optimizable &quot;best access paths&quot;.  The join orders have to saved with respect to outer queries, just like the access paths, but phase1_v2 did not do that.  phase1_v3 does.&lt;/p&gt;

&lt;p&gt;I ran derbyall on Red Hat Linux with IBM 1.4 and saw one diff in predicatesIntoViews that matches the diff from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-407&quot; title=&quot;predicatesIntoViews test failure on slow machine in Derby 10.1 branch version 201931&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-407&quot;&gt;&lt;del&gt;DERBY-407&lt;/del&gt;&lt;/a&gt;.  In that issue the diff was occuring with slower machines but not with faster machines.  With my phase1_v3.patch the diff occurs consistently regardless of the speed of my CPU, and I believe the diff is correct. So I&apos;ve included a master update for that test as part of d805_phase1_v3.patch.&lt;/p&gt;

&lt;p&gt;If anyone has time to review, I&apos;d be grateful...&lt;/p&gt;

&lt;p&gt;**NOTE to commiters: There are now two patches pending for this issue: d805_phase1_v3.patch and d805_phase2_v1.patch.  The patches are independent of each other and can be committed in either order.&lt;/p&gt;</comment>
                            <comment id="12367563" author="bandaram" created="Fri, 24 Feb 2006 03:58:30 +0000"  >&lt;p&gt;I am starting to review these patches, with the aim of submitting them to trunk. Let me know if any one has any comments on the patches so far.&lt;/p&gt;

&lt;p&gt;Thanks Army for all the good work!&lt;/p&gt;</comment>
                            <comment id="12368376" author="army" created="Thu, 2 Mar 2006 07:11:03 +0000"  >&lt;p&gt;Attaching a &quot;Phase 3&quot; patch, d805_phase3_v1.patch, to implement the changes described in steps 2, 3, 4 and 6 of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;_v3.html.  In short, this patch does the following:&lt;/p&gt;

&lt;p&gt;1. Implements the changes as described in the HTML document attached to this issue (steps 2, 3, 4 and 6).&lt;/p&gt;

&lt;p&gt;2. Adds a check in PredicateList.java to skip scoped predicates when trying to find a predicate to use for a hash join.  This check is needed because if the predicate was scoped and pushed down from an outer query, then one of the operands points to the outer query and the other (scoped) operand points down into a subquery, which means we can&apos;t do the hash join.  Without this check the optimizer might choose to do a hash scan using the predicate even though it won&apos;t actually be able to do the corresponding hash join.  That means we would lose the opportunity to use the predicate for an index scan, and thus we could miss out on a much better (index-based) plan.&lt;/p&gt;

&lt;p&gt;3. Makes a slight change to OptimizerImpl.addOrLoadBestPlanMappings to avoid doing extra work where possible.  More specifically, skips the logic to save/restore bestJoinOrder if there is only one Optimizable in the list, as there&apos;s only one possible join order in that case and so we don&apos;t need to keep track of which join order is best for each of the outer queries.&lt;/p&gt;

&lt;p&gt;4. Adds a new test, lang/predicatePushdown.sql, to the harness as part of the derbylang suite.  This test runs a bunch of queries that relate to the pushing of predicates down into unions.  Most of these test cases failed (either with compilation/execution errors or incorrect results) at one point or another while I worked on this issue, so I&apos;ve chosen to include them all as part of the new test.  The only way (that I know of) to tell if predicate pushdown is actually occuring is to print out the query plans, so the master file for this test is very large--almost 10,000 lines.  For that reason, combined with the fact that I think additional predicate pushdown tests will be needed as support for pushdown grows, I decided to create a new test instead of adding the test cases to an existing test.&lt;/p&gt;

&lt;p&gt;Once the Phase 1, Phase 2, and Phase 3 patches have been applied, along with the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt;, the basic predicate pushdown functionality will be in place.  That said, there are still two outstanding issues into which I&apos;m looking:&lt;/p&gt;

&lt;p&gt;A - As described in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;&lt;em&gt;v3.html, Phases 1 thru 3 will make it so that join predicates targeted for UNION nodes will always get pushed if it&apos;s possible to do so, which in turn means that the optimizer will no longer consider the cost of doing a hash join with the UNION (the hash join would require that the predicate _not&lt;/em&gt; be pushed into the UNION).  So I still need to investigate this to see how I can make the optimizer cost pushing predicates and using a nested loop join verses not pushing them and using a hash join.&lt;/p&gt;

&lt;p&gt;B - The changes I&apos;ve made for this issue-&lt;del&gt;esp. for Phase 1&lt;/del&gt;&lt;del&gt;add a good amount of code to the optimization code path.  This means that it&apos;s now possible for the optimizer to timeout &quot;sooner&quot; than it would have prior to these changse.  By &quot;sooner&quot; I mean that the optimizer might not have a chance to look at as many join orders as it used to (because it takes longer for it to cost each join order, esp. with deeply nested subqueries).  This means that there are situations where the optimizer pre&lt;/del&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; may have found one plan but post-&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; may never get to try that plan, and so it could end up choosing a worse plan than it used to. So I need to investigate the optimizer &quot;timeout&quot; mechanism to see how I can address this issue.&lt;/p&gt;

&lt;p&gt;As originally stated when I broke this enhancement down into phases, the issues that remain after Phase 3 will be addressed in Phase 4 (and whatever follow-up phases are required thereafter). In the meantime, the surest way to get the full effect of predicate pushdown is to disable optimizer timeout, which can be done with the property derby.optimizer.noTimeout=true.  Note that I set this property for the new predicatePushdown test, to ensure that the optimizer will choose the same plans across all machines.&lt;/p&gt;

&lt;p&gt;I ran derbyall on Red Hat Linux with IBM 1.4.2 and saw no new failures.  ** NOTE ** though that this patch, d805_phase3_v1.patch, has a dependency on d805_phase2_v1.patch and also on the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt;, attached to that issue and called d1007_v1.patch.  So both of those patches must be applied before d805_phase3_v1.patch can be applied.&lt;/p&gt;

&lt;p&gt;I know the patch looks long, but keep in mind that a good 9,000 lines of the diff is just for the new test.  I thought about posting the new test separately before the Phase 3 patch and then submitting an updated master file for Phase 3, but then the diff there would be even larger as most of the query plans would change.  So I&apos;ve just included the new test as part of the Phase 3 patch.&lt;/p&gt;

&lt;p&gt;So in short, the current patches for review-and-commit are as follow:&lt;/p&gt;

&lt;p&gt;1. d805_phase1_v3.patch (already committed)&lt;br/&gt;
2. d805_phase2_v1.patch&lt;br/&gt;
3. d1007_v1.patch (for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt;; dependent on #1)&lt;br/&gt;
4. d805_phase3_v1.patch (dependent on all of the previous patches).&lt;/p&gt;

&lt;p&gt;If anyone has the time to review/comment on any of these patches, I would most certainly appreciate it...&lt;/p&gt;</comment>
                            <comment id="12368612" author="army" created="Fri, 3 Mar 2006 06:33:59 +0000"  >&lt;p&gt;Attaching a one-line patch to fix a javadoc typo.  If any commiters out there can check this in quick, that&apos;d be great.&lt;/p&gt;</comment>
                            <comment id="12368827" author="army" created="Sat, 4 Mar 2006 11:18:59 +0000"  >&lt;p&gt;Small update to the lang/predicatePushdown.sql test to avoid truncation of query plans.  This should solve the diff reported in the TinderBox results here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.multinet.no/~solberg/public/Apache/TinderBox_Derby/Limited/testSummary-382964.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.multinet.no/~solberg/public/Apache/TinderBox_Derby/Limited/testSummary-382964.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;This is a small change to a test only-&lt;del&gt;no code changes&lt;/del&gt;-so if any commiter out there could commit, that&apos;d be great.&lt;/p&gt;</comment>
                            <comment id="12368839" author="fuzzylogic" created="Sat, 4 Mar 2006 15:49:49 +0000"  >&lt;p&gt;Committed predPushdown_testFix.patch with revision 383062.&lt;/p&gt;</comment>
                            <comment id="12373701" author="army" created="Sat, 8 Apr 2006 09:23:35 +0100"  >&lt;p&gt;Attaching two things to this issue:&lt;/p&gt;

&lt;p&gt;1 - &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt;_v4.html: an updated document that includes a description of my proposed changes for Phase 4.  See &quot;Section VII&quot;.&lt;/p&gt;

&lt;p&gt;2 - d805_phase4_v1.patch: a patch that implements the Phase 4 changes described in Section VII of the _v4.html document.&lt;/p&gt;

&lt;p&gt;The phase4_v1 patch also fixes a small error in BaseTableNumberVisitor.java and updates the lang/predicatePushdown.sql test to account for the new Phase 4 behavior.  As part of the changes for predicatePushdown.sql I have added a lot more data to the tables, which means the test queries take longer to run.  So where this test used to run in under a minute on my machine, it now takes over 4 minutes to complete.  That&apos;s expected given my changes, but I thought I should state that explicitly in case anyone notices.&lt;/p&gt;

&lt;p&gt;I ran derbyall on Linux Redhat using sane jars with IBM 1.4.2 and saw no new failures.  I also ran the updated lang/predicatePushdown.sql test against IBM wsdd5.6 and Sun 1.5 and the test passed without problems.&lt;/p&gt;

&lt;p&gt;If anyone has time to review and commit, that would be great. Note that while the patch is around 5500 lines, only about 600 lines of it are actual code changes; the rest is the result of the updated predicatePushdown.sql test and the corresponding output (a lot of query plans are printed in this test, so the output is quite large).&lt;/p&gt;</comment>
                            <comment id="12373933" author="army" created="Tue, 11 Apr 2006 06:24:44 +0100"  >&lt;p&gt;[ Attaching d805_phase4_v2.patch, which only has a 1-line diff from the v1 patch ]&lt;/p&gt;

&lt;p&gt;After stepping away from the code for the weekend and then re-reading the document for Phase 4, I noticed a small (one-line) error in the first version of my Phase 4 changes.&lt;/p&gt;

&lt;p&gt;In the document I correctly wrote the following regarding the need to revert access paths for subtrees when an Optimizable&apos;s current permutation is found to be &quot;not the best&quot;:&lt;/p&gt;

&lt;p&gt;&amp;lt;begin_quote&amp;gt;&lt;/p&gt;

&lt;p&gt;In order to fix this behavior, we have to add logic to save the &quot;best plans&quot; for an Optimizable&apos;s subtree before each new permutation, and then if the current permutation isn&apos;t the best one, we need to revert the entire subtree&apos;s plans back to what they were for the &quot;best&quot; permutation. &lt;/p&gt;

&lt;p&gt;&amp;lt;end_quote&amp;gt;&lt;/p&gt;

&lt;p&gt;But the code that I wrote didn&apos;t quite match this statement.  In the following diff:&lt;/p&gt;

&lt;p&gt;+        // If the final path that we considered for curOpt was &lt;em&gt;not&lt;/em&gt; the best&lt;br/&gt;
+        // path for this round, then we need to revert back to whatever the&lt;br/&gt;
+        // best plan for curOpt was this round.  Note that the cost estimate&lt;br/&gt;
+        // for bestAccessPath could be null here if the last path that we&lt;br/&gt;
+        // checked was the only one possible for this round.&lt;br/&gt;
+        if (!retval &amp;amp;&amp;amp;&lt;br/&gt;
+            (curOpt.getBestAccessPath().getCostEstimate() != null) &amp;amp;&amp;amp;&lt;br/&gt;
+            (curOpt.getCurrentAccessPath().getCostEstimate() != null))&lt;br/&gt;
+        {&lt;/p&gt;

&lt;p&gt;the check for &quot;!retval&quot; means that we will only revert the plans if we have exhausted all permutations for the current Optimizable.  But as I wrote in the document, we need to check (and potentially revert) the subtree&apos;s plans after &lt;em&gt;each&lt;/em&gt;  new permutation, not just after the final one.&lt;/p&gt;

&lt;p&gt;To show why this matters, assume we have some Optimizable with three possible permutations P1, P2, and P3, of which P1 is the &quot;best&quot;.  With the code as I wrote it in d805_phase4_v1.patch, we would end up doing the following:&lt;/p&gt;

&lt;p&gt;  &amp;#8211; Pick permutation P1.&lt;br/&gt;
  &amp;#8211; Since P1 is the first permutation, there is no previous &quot;best&quot; path&lt;br/&gt;
     so there&apos;s nothing to save.&lt;br/&gt;
  &amp;#8211; Optimize P1 and get the cost; say it&apos;s 25.&lt;br/&gt;
  &amp;#8211; Since P1 isn&apos;t our final permutation, we don&apos;t revert.  So the plans&lt;br/&gt;
     corresponding to P1 are still saved at the Optimizable and its subtree.&lt;br/&gt;
  &amp;#8211; Pick permutation P2.&lt;br/&gt;
  &amp;#8211; Before optimizing P2, save the best paths for the current Optimizable&apos;s&lt;br/&gt;
     subtree; this means we&apos;ll save off the paths corresponding to P1.&lt;br/&gt;
  &amp;#8211; Optimize P2 and get the cost; say it&apos;s 50.&lt;br/&gt;
  &amp;#8211; Since P2 isn&apos;t our final permutation, we &lt;b&gt;don&apos;t&lt;/b&gt; revert. So the plans&lt;br/&gt;
     corresponding to P2 are still saved at the Optimizable and its subtree.&lt;br/&gt;
  &amp;#8211; Pick permutation P3.&lt;br/&gt;
  &amp;#8211; Before optimizing P3, save the best paths for the current Optimizable&apos;s&lt;br/&gt;
     subtree; this means we&apos;ll save off the paths corresponding to &lt;b&gt;P2&lt;/b&gt;.&lt;br/&gt;
     (This is wrong.)&lt;br/&gt;
  &amp;#8211; Optimize P3 and get the cost; say it&apos;s 75.&lt;br/&gt;
  &amp;#8211; Since P3 is our final permutation, and since it is NOT the best permutation&lt;br/&gt;
     that we found, we&apos;ll now revert the paths of this Optimizable&apos;s subtree.&lt;br/&gt;
     That mean&apos;s we&apos;ll load the plans that we most recently saved and&lt;br/&gt;
     generate the query plan based on those.  But that will give us the&lt;br/&gt;
     plans for &lt;em&gt;P2&lt;/em&gt;, when what we wanted was the plans for &lt;em&gt;P1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So d805_phase4_v2.patch fixes this by removing the check for &quot;!retval&quot; in the above diff.  Then after we optimize P2 and get the cost, we&apos;ll see that it&apos;s not the best so we&apos;ll immediately revert the paths back to what they were for P1.  The P1 paths (instead of the P2 paths) will then get saved off before optimization of P3 starts, and thus when we do the &quot;revert&quot; after P3, we&apos;ll load the correct paths (P1).&lt;/p&gt;

&lt;p&gt;As it turns out this particular change doesn&apos;t change any of the other Phase 4 behavior.  The reason is that an Optimizable that is not a FromBaseTable only (currently) has two permutations-&lt;del&gt;nested loop join and hash join&lt;/del&gt;-and thus the above scenario can&apos;t currently happen. FromBaseTable&apos;s can have more than two permutations, but since they don&apos;t have subtrees beneath them this whole save/revert logic is not required.  Thus even though the v1 patch was technically incorrect, everything ran as expected.  For accuracy, though, I think this small error should be fixed, so that&apos;s what the second version of the phase 4 patch (d805_phase4_v2.patch) does.&lt;/p&gt;

&lt;p&gt;I&apos;ve also added a _v5.html document that is almost identical to _v4 except for two things: 1) the small change that I just described, and 2) I&apos;ve included a note with the info about index statistics that Andrew posted to derby-dev (thanks to Bryan for asking the question and to Andrew for providing the answer).&lt;/p&gt;

&lt;p&gt;Just to be safe I re-ran derbyall on Red Hat Linux with ibm142 sane jars and saw no failures.&lt;/p&gt;</comment>
                            <comment id="12374391" author="bandaram" created="Fri, 14 Apr 2006 02:25:07 +0100"  >&lt;p&gt;All four patches for each phase have been committed to trunk. Thanks Army.&lt;/p&gt;</comment>
                            <comment id="12376168" author="army" created="Tue, 25 Apr 2006 12:08:25 +0100"  >&lt;p&gt;Attaching a follow-up patch, d805_followup_v1.patch, that addresses some issues which remained after Phase 4 was committed. In particular:&lt;/p&gt;

&lt;p&gt;1) Added logic to skip predicate pushdown when either of the predicate&apos;s column references does not point to a base table.  This can happen if, for example, the column reference points to a literal or an aggregate expression.  Further work is required for such situations in order to correctly &quot;remap&quot; the column reference to its source (or at least, to figure out what exactly it means to remap a ColumnReference that doesn&apos;t point to a base table, and then to implement the appropriate changes)--so in the meantime, I&apos;ve just decided to skip pushing the predicate for now.&lt;/p&gt;

&lt;p&gt;2) Added logic to correctly set the column number of a &quot;scoped&quot; reference based on whether or not the reference points to a base table.  Existing comments in the relevant sections of code describe why we need to set the column numbers for references pointing to base tables, but the code itself didn&apos;t actually check for the base table condition--it set the column number for all scoped references, which wasn&apos;t always correct.&lt;/p&gt;

&lt;p&gt;3) In cases where a ColumnReference&apos;s source ResultColumn&apos;s expression is not another ColumnReference, made it so that the scope operation will return a clone of ColumnReference (instead of the ColumnReference itself) since that ColumnReference will be pushed to two result sets.&lt;/p&gt;

&lt;p&gt;4) Added corresponding test cases to the lang/predicatePushdown.sql test and updated the master file accordingly.&lt;/p&gt;

&lt;p&gt;I ran derbyall on Red Hat Linux with ibm142 and saw no new failures.&lt;/p&gt;

&lt;p&gt;If anyone has time to review, I&apos;d be grateful.  Thanks.&lt;/p&gt;</comment>
                            <comment id="12376646" author="mkutty" created="Thu, 27 Apr 2006 14:24:22 +0100"  >&lt;p&gt;Testing effect of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-805&quot; title=&quot;Push join predicates into union and other set operations. DERBY-649 implemented scalar (single table) predicate pushdown. Adding join predicate push down could improve performance significantly.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-805&quot;&gt;&lt;del&gt;DERBY-805&lt;/del&gt;&lt;/a&gt; changes &lt;/p&gt;

&lt;p&gt;various  complex queries were created and run against 10.1 and 10.2  versions and&lt;br/&gt;
the results and the test descriptions are being attached to this issue. &lt;/p&gt;

&lt;p&gt;The overall result after running these tests looks promising and 10.2 performs way better than 10.1. Still it will be good to have an improvement to the existing execution model to use multiple indexes for table scan. I have filed seperate jira entry for that.&lt;/p&gt;</comment>
                            <comment id="12376832" author="army" created="Fri, 28 Apr 2006 06:54:45 +0100"  >&lt;p&gt;Attaching patch to port all phases of this issue plus changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1007&quot; title=&quot;Optimizer can return incorrect &amp;quot;best cost&amp;quot; estimates with nested subqueries, which leads to generation of sub-optimal plans.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1007&quot;&gt;&lt;del&gt;DERBY-1007&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1073&quot; title=&quot;Reset optimizer timeout for subqueries on a per-round basis to allow consideration of plans that use pushed predicates.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1073&quot;&gt;&lt;del&gt;DERBY-1073&lt;/del&gt;&lt;/a&gt; to 10.1.  For more details (including why the three different issues are included a single patch), see here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.gmane.org/gmane.comp.apache.db.derby.devel/19330&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://article.gmane.org/gmane.comp.apache.db.derby.devel/19330&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Attaching here for ease of download and tracking.&lt;/p&gt;</comment>
                            <comment id="12376859" author="bandaram" created="Fri, 28 Apr 2006 10:42:53 +0100"  >&lt;p&gt;I have committed this patch to 10.1 branch. Thanks for pulling all relavent checkins.&lt;/p&gt;</comment>
                            <comment id="12377295" author="bandaram" created="Tue, 2 May 2006 07:35:18 +0100"  >&lt;p&gt;Fix has been merged into 10.2 (trunk), and 10.1 branches.&lt;/p&gt;</comment>
                            <comment id="12377296" author="bandaram" created="Tue, 2 May 2006 07:35:36 +0100"  >&lt;p&gt;Fix has been verified.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12333512">DERBY-1315</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12322934" name="DERBY-805.html" size="108648" author="army" created="Tue, 14 Feb 2006 03:52:30 +0000"/>
                            <attachment id="12323158" name="DERBY-805_v2.html" size="124116" author="army" created="Sun, 19 Feb 2006 12:44:56 +0000"/>
                            <attachment id="12323293" name="DERBY-805_v3.html" size="136586" author="army" created="Thu, 23 Feb 2006 06:03:51 +0000"/>
                            <attachment id="12325070" name="DERBY-805_v4.html" size="164319" author="army" created="Sat, 8 Apr 2006 09:23:35 +0100"/>
                            <attachment id="12325158" name="DERBY-805_v5.html" size="164727" author="army" created="Tue, 11 Apr 2006 06:24:43 +0100"/>
                            <attachment id="12325980" name="d805_1007_1073_portTo10_1.patch" size="571044" author="army" created="Fri, 28 Apr 2006 06:54:45 +0100"/>
                            <attachment id="12325981" name="d805_1007_1073_portTo10_1.stat" size="2855" author="army" created="Fri, 28 Apr 2006 06:54:45 +0100"/>
                            <attachment id="12325801" name="d805_followup_v1.patch" size="21778" author="army" created="Tue, 25 Apr 2006 12:08:25 +0100"/>
                            <attachment id="12323099" name="d805_phase1_v1.patch" size="11439" author="army" created="Fri, 17 Feb 2006 14:14:42 +0000"/>
                            <attachment id="12323100" name="d805_phase1_v1.stat" size="225" author="army" created="Fri, 17 Feb 2006 14:14:42 +0000"/>
                            <attachment id="12323156" name="d805_phase1_v2.patch" size="11467" author="army" created="Sun, 19 Feb 2006 12:44:55 +0000"/>
                            <attachment id="12323157" name="d805_phase1_v2.stat" size="523" author="army" created="Sun, 19 Feb 2006 12:44:56 +0000"/>
                            <attachment id="12323303" name="d805_phase1_v3.patch" size="21337" author="army" created="Thu, 23 Feb 2006 11:23:57 +0000"/>
                            <attachment id="12323304" name="d805_phase1_v3.stat" size="616" author="army" created="Thu, 23 Feb 2006 11:23:58 +0000"/>
                            <attachment id="12323291" name="d805_phase2_v1.patch" size="29182" author="army" created="Thu, 23 Feb 2006 06:03:51 +0000"/>
                            <attachment id="12323292" name="d805_phase2_v1.stat" size="304" author="army" created="Thu, 23 Feb 2006 06:03:51 +0000"/>
                            <attachment id="12323583" name="d805_phase3_v1.patch" size="419353" author="army" created="Thu, 2 Mar 2006 07:11:02 +0000"/>
                            <attachment id="12323584" name="d805_phase3_v1.stat" size="1041" author="army" created="Thu, 2 Mar 2006 07:11:03 +0000"/>
                            <attachment id="12325071" name="d805_phase4_v1.patch" size="198525" author="army" created="Sat, 8 Apr 2006 09:23:35 +0100"/>
                            <attachment id="12325072" name="d805_phase4_v1.stat" size="1001" author="army" created="Sat, 8 Apr 2006 09:23:35 +0100"/>
                            <attachment id="12325157" name="d805_phase4_v2.patch" size="198513" author="army" created="Tue, 11 Apr 2006 06:24:41 +0100"/>
                            <attachment id="12323644" name="phase2_javadocFix.patch" size="595" author="army" created="Fri, 3 Mar 2006 06:33:58 +0000"/>
                            <attachment id="12323709" name="predPushdown_testFix.patch" size="3088" author="army" created="Sat, 4 Mar 2006 11:18:59 +0000"/>
                            <attachment id="12325938" name="test_805.htm" size="23392" author="mkutty" created="Thu, 27 Apr 2006 14:27:44 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 13 Feb 2006 17:45:01 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29711</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy14vj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40440</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>