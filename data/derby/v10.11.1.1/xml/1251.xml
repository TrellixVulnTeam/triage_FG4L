<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:40:59 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1251/DERBY-1251.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1251] cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1251</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;If an application does the following:&lt;/p&gt;

&lt;p&gt;rs.updateInt(1, newValueCol1);&lt;br/&gt;
rs.updateRow();&lt;br/&gt;
rs.updateInt(2, newValueCol2);&lt;br/&gt;
rs.cancelRowUpdates();&lt;/p&gt;

&lt;p&gt;Then, when calling rs.getInt(1), it will return the old value. Instead it should return the new value.&lt;/p&gt;

&lt;p&gt;Workaround: after calling rs.updateRow(), the application could call rs.relative(0).&lt;/p&gt;

&lt;p&gt;This problem does not affect forward only resultsets, since after an updateRow() they get positoned before the next row, leaving it impossible to do anything with the current row.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12332650">DERBY-1251</key>
            <summary>cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="andreask">Andreas Korneliussen</assignee>
                                    <reporter username="andreask">Andreas Korneliussen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 25 Apr 2006 17:28:51 +0100</created>
                <updated>Tue, 23 May 2006 21:51:14 +0100</updated>
                            <resolved>Sun, 14 May 2006 15:55:41 +0100</resolved>
                                    <version>10.2.1.6</version>
                                    <fixVersion>10.2.1.6</fixVersion>
                                    <component>JDBC</component>
                    <component>Network Client</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12376218" author="andreask" created="Tue, 25 Apr 2006 17:32:50 +0100"  >&lt;p&gt;The bug was detected while adding the following testcase in SURTest:&lt;br/&gt;
    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Test that you can correctly run multiple updateXXX() + updateRow()&lt;/li&gt;
	&lt;li&gt;combined with cancelRowUpdates().&lt;br/&gt;
     */&lt;br/&gt;
    public void testMultiUpdateRow1() &lt;br/&gt;
        throws SQLException 
    {
        Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                          ResultSet.CONCUR_UPDATABLE);
        s.setCursorName(getNextCursorName());
        ResultSet rs = s.executeQuery(&quot;select * from t1&quot;);
        rs.absolute(5);
        final int oldCol2 = rs.getInt(2);
        final int newCol2 = -2222;
        final int oldCol3 = rs.getInt(3);
        final int newCol3 = -3333;
                
        rs.updateInt(2, newCol2);
        assertEquals(&quot;Expected the resultset to be updated after updateInt&quot;, 
                     newCol2, rs.getInt(2));
        rs.cancelRowUpdates();
        assertEquals(&quot;Expected updateXXX to have no effect after cancelRowUpdated&quot;, 
                     oldCol2, rs.getInt(2));
        rs.updateInt(2, newCol2);
        assertEquals(&quot;Expected the resultset to be updated after updateInt&quot;, 
                     newCol2, rs.getInt(2));
        assertTrue(&quot;Expected rs.rowUpdated() to be false before updateRow&quot;, 
                   !rs.rowUpdated());
        rs.updateRow();
        
        assertTrue(&quot;Expected rs.rowUpdated() to be true after updateRow&quot;, 
                   rs.rowUpdated());
==== FAILS HERE ======
        assertEquals(&quot;Expected the resultset detect the updates of previous &quot; + 
                     &quot;updateRow&quot;, newCol2, rs.getInt(2));
====================       
        rs.updateInt(3, newCol3);
        
        assertEquals(&quot;Expected the resultset to be updated after updateInt&quot;, 
                     newCol3, rs.getInt(3));
        assertEquals(&quot;Expected the resultset detect the updates of previous &quot; + 
                     &quot;updateRow&quot;, newCol2, rs.getInt(2));
        
        rs.cancelRowUpdates();
        
        assertEquals(&quot;Expected updateXXX to have no effect after &quot; +
                     &quot;cancelRowUpdated&quot;, oldCol3, rs.getInt(3));
        assertEquals(&quot;Expected the resultset detect the updates of previous &quot; +
                     &quot;updateRow after cancelRowUpdated&quot;, newCol2, rs.getInt(2));
        rs.updateInt(3, newCol3);
        rs.updateRow();
        assertEquals(&quot;Expected the resultset to be updated after updateInt&quot;, 
                     newCol3, rs.getInt(3));
        rs.cancelRowUpdates();
        
        assertEquals(&quot;Expected the resultset detect the updates of previous&quot; + 
                     &quot;updateRow after cancelRowUpdates&quot;, newCol2, rs.getInt(2));
        assertEquals(&quot;Expected the resultset detect the updates of previous&quot; + 
                     &quot;updateRow after cacnelRowUpdates&quot;, newCol2, rs.getInt(2));
        assertTrue(&quot;Expected rs.rowUpdated() to be true after &quot; + 
                   &quot;updateRow and cancelRowUpdates&quot;, rs.rowUpdated());
        
        rs.close();
    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The test fails with:&lt;br/&gt;
1) testMultiUpdateRow1(org.apache.derbyTesting.functionTests.tests.jdbcapi.SURTest)junit.framework.AssertionFailedError: Expected the resultset detect the updates of previous updateRow expected:&amp;lt;-2222&amp;gt; but was:&amp;lt;4&amp;gt;&lt;br/&gt;
        at org.apache.derbyTesting.functionTests.tests.jdbcapi.SURTest.testMultiUpdateRow1(SURTest.java:203)&lt;br/&gt;
...&lt;/p&gt;</comment>
                            <comment id="12376245" author="andreask" created="Tue, 25 Apr 2006 20:38:20 +0100"  >&lt;p&gt;Actually, the previous comment indicates another related bug: after updateRow(), rs.getXXX() returns the old value. &lt;/p&gt;

&lt;p&gt;In addition I found that in the network driver: after doing updateRow(), and you later do updateXXX() + cancelRowUpdates(), the cancelRowUpdates() does not have any effect, since updateRow() had been called once on the row.&lt;/p&gt;

&lt;p&gt;Due to this logic in org.apache.derby.client.am.ResultSet.cancelRowUpdates() :&lt;/p&gt;

&lt;p&gt;                / if updateRow() has already been called, then cancelRowUpdates should have&lt;br/&gt;
                // no effect.  updateRowCalled_ is reset to false as soon as the cursor moves to a new row.&lt;br/&gt;
                if (!updateRowCalled_) &lt;/p&gt;
{
                    resetUpdatedColumns();
                }
&lt;p&gt;updateRowCalled_ is set to true in updateRow().&lt;/p&gt;

&lt;p&gt;Seems most of this logic is relaxed on having the resultset becoming unpositioned after an updateRow().&lt;/p&gt;</comment>
                            <comment id="12376444" author="andreask" created="Wed, 26 Apr 2006 17:30:17 +0100"  >&lt;p&gt;Changes to address this bug:&lt;/p&gt;

&lt;p&gt;Embedded JDBC driver:&lt;/p&gt;

&lt;p&gt;EmbedResultSet.java: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;at the end of updateRow/deleteRow, the rowdata in the resultset is reloaded from the cursor&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Client JDBC driver:&lt;br/&gt;
ResultSet.java:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;removed the use of updateRowCalled_&lt;/li&gt;
	&lt;li&gt;at the end of updateRowX/deleteRowX, the rowdata is reloaded from the cursor&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Tests:&lt;br/&gt;
SURTest.java&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;3 testcases added, covering both this issue, and the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1249&quot; title=&quot;cursor operation conflict incorrectly handled in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1249&quot;&gt;&lt;del&gt;DERBY-1249&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Note: by reloading the rowdata from the cursor, this fix also fixes issue &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1249&quot; title=&quot;cursor operation conflict incorrectly handled in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1249&quot;&gt;&lt;del&gt;DERBY-1249&lt;/del&gt;&lt;/a&gt;, therefore these tests are part of this fix.&lt;/p&gt;</comment>
                            <comment id="12377466" author="andreask" created="Wed, 3 May 2006 04:20:25 +0100"  >&lt;p&gt;Withdrawing the patch &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;.diff.&lt;/p&gt;

&lt;p&gt;It turns out that the currentRow attribute in the EmbedResultSet may in certain combinations of scrolling refer directly to a row in the hashtable of a ScrollInsensitive ResultSet.  updateXXX() methods then get to write into the hashtable. When doing cancelRowUpdates(), EmbedResultSet copies over its internal reference to the columns, however the data in the hashtable may still have been modified by updateXXX. This patch simply reveals this problem more clearly, as this situation may occur every time one do cancelRowUpdates. I will work on a patch to completely remove this problem.&lt;/p&gt;
</comment>
                            <comment id="12378381" author="andreask" created="Mon, 8 May 2006 16:25:25 +0100"  >&lt;p&gt;Embedded:&lt;/p&gt;

&lt;p&gt;In this patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;v2.diff) I have addressed the problem in that&lt;br/&gt;
updateXXX(..) methods get to write directly into data which is owned&lt;br/&gt;
by theResultSet. The old behavior was that updateXXX() wrote directly&lt;br/&gt;
into currentRow(..), and a copy of the old data in current row was put&lt;br/&gt;
into copyOfDatabaseRow, to support cancelRowUpdates.&lt;/p&gt;

&lt;p&gt;The new logic is that the updateXXX(..) methods will write into a&lt;br/&gt;
new ExecRow attribute in EmbedResultSet, called updateRow, and it is&lt;br/&gt;
no longer necessary to copy data into copyofDatabaseRow.&lt;/p&gt;

&lt;p&gt;When doing updateRow() or insertRow(), the values are collected from&lt;br/&gt;
updateRow instead of currentRow. When doing cancelRowUpdates(), the&lt;br/&gt;
relevant flags are reset.&lt;/p&gt;

&lt;p&gt;These changes has allowed me to remove the following attributes from&lt;br/&gt;
EmbedResultSet:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;ExecRow insertRow&lt;/li&gt;
	&lt;li&gt;ExecRow currentRowBeforeInsert&lt;/li&gt;
	&lt;li&gt;DataValueDescriptor[] rowData&lt;/li&gt;
	&lt;li&gt;DataValueDescriptor[] copyOfDatabaseRow;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A new field has been added instead: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ExecRow updateRow&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All getXXX() methods use a method to look up a DataValueDescriptor for&lt;br/&gt;
the column. The getColumn() method will either return a&lt;br/&gt;
DataValueDescriptor from currentRow if the column has not been updated&lt;br/&gt;
with updateXXX(). Otherwise it will return the column from updateRow.&lt;br/&gt;
If on insertRow, the DataValueDescriptor is located from the&lt;br/&gt;
updateRow attribute.  &lt;/p&gt;

&lt;p&gt;The patch still (as in previous patch &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;.diff) reload data&lt;br/&gt;
from the cursor at the end of updateRow and deleteRow. This is done by&lt;br/&gt;
calling movePosition() equal to relative(0).  &lt;/p&gt;

&lt;p&gt;Client changes:&lt;br/&gt;
Similar as in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;.diff: reload the data of the row after&lt;br/&gt;
updateRow(). Note that reloading the data from the cursor, causes an&lt;br/&gt;
extra roundtrip to the server. So this part can be improved. In&lt;br/&gt;
deleteRow() I am using updateCount_ to check if the row was deleted by&lt;br/&gt;
the cursor. This is also used in updateRow(), to see if it is necessary to &lt;br/&gt;
reload data from the cursor.&lt;/p&gt;

&lt;p&gt;Testing:&lt;br/&gt;
SURTest: 4 testcases added.&lt;br/&gt;
The test passes, and I did not get any failures in derbyall.&lt;/p&gt;</comment>
                            <comment id="12378382" author="andreask" created="Mon, 8 May 2006 16:26:23 +0100"  >&lt;p&gt;A patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;v2.diff) is available for review.&lt;/p&gt;</comment>
                            <comment id="12378383" author="andreask" created="Mon, 8 May 2006 16:28:20 +0100"  >&lt;p&gt;Attaching report from derbyall, with patch &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;v2.diff&lt;/p&gt;</comment>
                            <comment id="12378628" author="fernanda" created="Tue, 9 May 2006 22:48:58 +0100"  >&lt;p&gt;Review:&lt;/p&gt;

&lt;p&gt;The patch looks good, here are some comments:&lt;/p&gt;

&lt;p&gt;Index: java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java&lt;br/&gt;
===================================================================&lt;br/&gt;
@@ -180,10 +181,17 @@&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
+	/* updateRow is used to keep the values which are updated with updateXXX() &lt;br/&gt;
+	 * calls. It is by both insertRow() and updateRow(). &lt;br/&gt;
                           ^ used&lt;br/&gt;
+	 * It is initialized to null if the resultset is not updatable. &lt;br/&gt;
+	 */&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
+	/* These are the columns which have been updated so far. &lt;br/&gt;
+	 * Used to build UPDATE...WHERE CURRENT OF sql and &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;could this be removed?&lt;br/&gt;
+	 * INSERT INTO .. statements.&lt;br/&gt;
+	 */&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -240,14 +248,26 @@&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
+		    columnGotUpdated = new boolean&lt;span class=&quot;error&quot;&gt;&amp;#91;columnCount&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+		    updateRow = factory.getValueRow(columnCount);&lt;br/&gt;
+			for (int i = 1; i &amp;lt;= columnGotUpdated.length; i++) &lt;/p&gt;
{
+		        updateRow.setColumn(i, resultDescription.getColumnDescriptor(i).
+		            getType().getNull());
+		    }
&lt;p&gt;+		    initializeUpdateRowModifiers();			&lt;br/&gt;
+		} else {&lt;br/&gt;
+			updateRow = null;&lt;/p&gt;

&lt;p&gt;Could you use columnCount instead of columnGotUpdated.length on the third line?&lt;br/&gt;
There is a mix of tab and spaces being used on these rows.&lt;/p&gt;

&lt;p&gt;@ -289,14 +309,18 @@&lt;br/&gt;
 	// onRow protects us from making requests of&lt;br/&gt;
 	// resultSet that would fail with NullPointerExceptions&lt;br/&gt;
 	// or milder problems due to not having a row.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
+	protected final void checkOnRow() throws SQLException	{&lt;br/&gt;
+		if (currentRow.getRowArray() == null) &lt;/p&gt;
{
 			throw newSQLException(SQLState.NO_CURRENT_ROW);
+		}
&lt;p&gt; &lt;br/&gt;
+	}&lt;/p&gt;

&lt;p&gt;This comments should be updated to reflect what is done in the method.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Initializes the updateRow and columnGotUpdated fields&lt;br/&gt;
+	 */&lt;br/&gt;
+	private void initializeUpdateRowModifiers() &lt;/p&gt;
{
+		currentRowHasBeenUpdated = false;
+		Arrays.fill(columnGotUpdated, false);
 	}

&lt;p&gt;This comment should also be updated, updateRow is not being initialized.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;@@ -3598,15 +3620,19 @@&lt;br/&gt;
                 }&lt;br/&gt;
                 rs.close();&lt;br/&gt;
                 rs.finish();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;//After a delete, the ResultSet will be positioned right before&lt;/li&gt;
	&lt;li&gt;//the next row.&lt;/li&gt;
	&lt;li&gt;rowData = null;&lt;/li&gt;
	&lt;li&gt;currentRow = null;&lt;br/&gt;
+                //For forward only resultsets, after a delete, &lt;br/&gt;
+                // the ResultSet will be positioned right before the next row.&lt;br/&gt;
+                if (getType() == TYPE_FORWARD_ONLY) 
{
+                    currentRow.setRowArray(null);
+                }
&lt;p&gt; else &lt;/p&gt;
{
+                    movePosition(RELATIVE, 0, &quot;relative&quot;);
+                }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;According to JDBC 3.0 specification section &quot;14.2.4.2 Deleting a Row&quot;, after a&lt;br/&gt;
deleteRow has been called, the cursor will be positioned before the next valid&lt;br/&gt;
row. Is there a reason to make this comment specific to forward only result &lt;br/&gt;
sets?&lt;/p&gt;


&lt;p&gt;Index: java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/SURTest.java&lt;br/&gt;
===================================================================&lt;/p&gt;

&lt;p&gt;@@ -242,6 +242,218 @@&lt;br/&gt;
         verifyTuple(rs);&lt;br/&gt;
         assertFailOnUpdate(rs);&lt;br/&gt;
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Test that you can correctly run multiple updateXXX() + updateRow() &lt;br/&gt;
+     * combined with cancelRowUpdates().&lt;br/&gt;
+     */&lt;br/&gt;
+    public void testMultiUpdateRow1() &lt;br/&gt;
+        throws SQLException &lt;br/&gt;
+    &lt;/p&gt;
{
[...]
+        assertEquals(&quot;Expected the resultset detect the updates of previous&quot; + 
+                     &quot;updateRow after cancelRowUpdates&quot;, newCol2, rs.getInt(2));
+        assertEquals(&quot;Expected the resultset detect the updates of previous&quot; + 
+                     &quot;updateRow after cancelRowUpdates&quot;, newCol2, rs.getInt(2));

I guess the intention was to check column 2 and 3 and not twice column 2.


+        assertTrue(&quot;Expected rs.rowUpdated() to be true after &quot; + 
+                   &quot;updateRow and cancelRowUpdates&quot;, rs.rowUpdated());
+        
+        rs.close();
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Test that you can correctly run multiple updateNull() + updateRow() &lt;br/&gt;
+     * combined with cancelRowUpdates().&lt;br/&gt;
+     */&lt;br/&gt;
+    public void testMultiUpdateRow2() &lt;br/&gt;
+        throws SQLException &lt;br/&gt;
+    &lt;/p&gt;
{
[...]


+        assertEquals(&quot;Expected the resultset detect the updates of previous&quot; + 
+                     &quot;updateRow after cancelRowUpdates&quot;, 0, rs.getInt(2));
+        assertEquals(&quot;Expected the resultset detect the updates of previous&quot; + 
+                     &quot;updateRow after cancelRowUpdates&quot;, 0, rs.getInt(2));

Same here.

+        assertTrue(&quot;Expected rs.rowUpdated() to be true after &quot; + 
+                   &quot;updateRow and cancelRowUpdates&quot;, rs.rowUpdated());
+        
+        rs.close();
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Test that you get cursor operation conflict warning if updating &lt;br/&gt;
+     * a row which has been deleted from the table.&lt;br/&gt;
+     */&lt;/p&gt;
</comment>
                            <comment id="12378856" author="andreask" created="Wed, 10 May 2006 16:58:24 +0100"  >&lt;p&gt;&amp;gt; - //After a delete, the ResultSet will be positioned right before&lt;br/&gt;
&amp;gt; - //the next row.&lt;br/&gt;
&amp;gt; - rowData = null;&lt;br/&gt;
&amp;gt; - currentRow = null;&lt;br/&gt;
&amp;gt; + //For forward only resultsets, after a delete,&lt;br/&gt;
&amp;gt; + // the ResultSet will be positioned right before the next row.&lt;br/&gt;
&amp;gt; + if (getType() == TYPE_FORWARD_ONLY) &lt;/p&gt;
{
&amp;gt; + currentRow.setRowArray(null);
&amp;gt; + }
&lt;p&gt; else &lt;/p&gt;
{
&amp;gt; + movePosition(RELATIVE, 0, &quot;relative&quot;);
&amp;gt; + }
&lt;p&gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; According to JDBC 3.0 specification section &quot;14.2.4.2 Deleting a Row&quot;, after a&lt;br/&gt;
&amp;gt; deleteRow has been called, the cursor will be positioned before the next valid&lt;br/&gt;
&amp;gt; row. Is there a reason to make this comment specific to forward only result&lt;br/&gt;
&amp;gt; sets? &lt;/p&gt;

&lt;p&gt;This is a good point. For FORWARD_ONLY resultsets, this means that the cursor is not on a row (i.e all getXXX(..) methods throws exception), and when calling next the cursor will be positioned on the next row.&lt;br/&gt;
For SCROLL INSENSITIVE cursors, I am a bit unsure if the current row (which has been deleted) is valid or not.  If it is valid, it is correct to be on the current row, since it is before the next valid row. If it is considered as invalid the cursor should be position somewhere inbetween the current row and the next row (i.e not on a row). &lt;br/&gt;
Then the behavior would be that: calling next() will give the next row, calling previous will give the previous row, and calling relative(0) will give the current invalid (deleted) row in scroll insensitive resultsets. &lt;/p&gt;

&lt;p&gt;However I choose to not deal with this in this patch. The call to movePosition(RELATIVE..) should not be part of the patch, it could be added in another patch, i.e  if we choose to consider the current row as a valid row after it has been deleted.&lt;/p&gt;</comment>
                            <comment id="12378858" author="andreask" created="Wed, 10 May 2006 17:01:28 +0100"  >&lt;p&gt;Attached is a patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;v3.diff) which addresses the review comments. The changes in deleteRow() behavior has been removed.&lt;/p&gt;</comment>
                            <comment id="12378902" author="fernanda" created="Wed, 10 May 2006 20:27:17 +0100"  >&lt;p&gt;All of my comments have been addressed. The patch &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1251&quot; title=&quot;cancelRowUpdates() affects rows updated with updateRow() in scrollable updatable resultsets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1251&quot;&gt;&lt;del&gt;DERBY-1251&lt;/del&gt;&lt;/a&gt;v3.diff looks good.&lt;/p&gt;</comment>
                            <comment id="12378922" author="knutanders" created="Wed, 10 May 2006 21:58:16 +0100"  >&lt;p&gt;I will run some tests and commit the patch.&lt;/p&gt;</comment>
                            <comment id="12402209" author="knutanders" created="Sun, 14 May 2006 15:55:41 +0100"  >&lt;p&gt;Committed revision 406279.&lt;/p&gt;</comment>
                            <comment id="12412934" author="andreask" created="Tue, 23 May 2006 21:51:14 +0100"  >&lt;p&gt;Thanks for committing this patch. Closing the report.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12325886" name="DERBY-1251.diff" size="13152" author="andreask" created="Wed, 26 Apr 2006 17:30:17 +0100"/>
                            <attachment id="12325887" name="DERBY-1251.stat" size="278" author="andreask" created="Wed, 26 Apr 2006 17:30:17 +0100"/>
                            <attachment id="12326375" name="DERBY-1251v2.diff" size="31453" author="andreask" created="Mon, 8 May 2006 16:25:25 +0100"/>
                            <attachment id="12326376" name="DERBY-1251v2.stat" size="278" author="andreask" created="Mon, 8 May 2006 16:25:25 +0100"/>
                            <attachment id="12326504" name="DERBY-1251v3.diff" size="30497" author="andreask" created="Wed, 10 May 2006 17:01:28 +0100"/>
                            <attachment id="12326377" name="derbyall_report.txt" size="4071" author="andreask" created="Mon, 8 May 2006 16:28:20 +0100"/>
                            <attachment id="12325888" name="derbyall_report.txt" size="14507" author="andreask" created="Wed, 26 Apr 2006 17:30:17 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 9 May 2006 21:48:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22396</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10102"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy16dz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>40685</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>