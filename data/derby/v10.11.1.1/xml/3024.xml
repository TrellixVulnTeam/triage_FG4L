<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:18:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3024/DERBY-3024.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3024] Validation of shared plans hurts scalability</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3024</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;To investigate whether there was anything in the SQL execution layer that prevented scaling on a multi-CPU machine, I wrote a multi-threaded test which continuously executed &quot;VALUES 1&quot; using a PreparedStatement. I ran the test on a machine with 8 CPUs and expected the throughput to be proportional to the number of concurrent clients up to 8 clients (the same as the number of CPUs). However, the throughput only had a small increase from 1 to 2 clients, and adding more clients did not increase the throughput. Looking at the test in a profiler, it seems like the threads are spending a lot of time waiting to enter synchronization blocks in GenericPreparedStatement.upToDate() and BaseActivation.checkStatementValidity() (both of which are synchronized on the a GenericPreparedStatement object).&lt;/p&gt;

&lt;p&gt;I then changed the test slightly, appending a comment with a unique thread id to the &quot;VALUES 1&quot; statement. That means the threads still did the same work, but each thread got its own plan (GenericPreparedStatement object) since the statement cache didn&apos;t regard the SQL text strings as identical. When I made that change, the test scaled more or less perfectly up to 8 concurrent threads.&lt;/p&gt;

&lt;p&gt;We should try to find a way to make the scalability the same regardless of whether or not the threads share the same plan.&lt;/p&gt;</description>
                <environment>Sun Java SE 6, Solaris 10, Sun Fire V880 (8 CPUs)</environment>
        <key id="12376700">DERBY-3024</key>
            <summary>Validation of shared plans hurts scalability</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="knutanders">Knut Anders Hatlen</reporter>
                        <labels>
                            <label>derby_triage10_10</label>
                    </labels>
                <created>Thu, 23 Aug 2007 11:24:31 +0100</created>
                <updated>Tue, 2 Oct 2012 09:45:01 +0100</updated>
                            <resolved>Tue, 2 Oct 2012 09:45:01 +0100</resolved>
                                    <version>10.4.1.3</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12522088" author="knutanders" created="Thu, 23 Aug 2007 11:26:57 +0100"  >&lt;p&gt;Attaching the test and a graph showing the difference in performance between shared plans and separate plans on a machine with 8 CPUs.&lt;/p&gt;</comment>
                            <comment id="12522204" author="mkhettry" created="Thu, 23 Aug 2007 18:49:31 +0100"  >&lt;p&gt;That is very interesting. A couple of thoughts on this.&lt;/p&gt;

&lt;p&gt;First, the point of sharing plans is to avoid doing potentially expensive compilation. By choosing a really simple query which is cheap both to compile and execute you are effectively measuring only the cost of sharing plans. If you had even a slightly more expensive query, I doubt you would see such a huge disparity between the two cases. &lt;/p&gt;

&lt;p&gt;That having been said, the lack of any speedup is troubling. I ran the same query to see how many times the routines you mentioned (GenericPreparedStatement#upToDate and BaseActivation#checkStatementValdity) are executed. The first one is called &lt;b&gt;five&lt;/b&gt; times per query and the second one &lt;b&gt;once&lt;/b&gt;. I haven&apos;t looked at the code too closely but it does seem excessive and could be a starting point to investigate contention.&lt;/p&gt;

&lt;p&gt;Also, there are two other routines GPS#finish and GPS#getActivation which synchronize on the GPS and are called once per statement so these routines add to the contention as well.&lt;/p&gt;
</comment>
                            <comment id="12522495" author="knutanders" created="Fri, 24 Aug 2007 13:50:00 +0100"  >&lt;p&gt;Thanks for investigating this, Manish!&lt;/p&gt;

&lt;p&gt;I agree that the test is not representative of a real-world application, but that wasn&apos;t my aim when I wrote it. I just wanted to see if there were any basic part of the SQL execution layer that would be a bottleneck on a multi-CPU machine. VALUES 1 seemed to be a good choice since it avoids accesses to the buffer manager, which is a known multi-CPU bottleneck. I think of it more like looking at a small part of Derby through a magnifying glass or a microscope. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;When I run the test, I only see three calls to GPS.upToDate(), one call to BA.checkStatementValidity(), and none to GPS.finish() and GPS.getActivation(). You didn&apos;t by any chance use a Statement instead of a PreparedStatement?&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I quite understand how the interaction with upToDate() works. If upToDate() returns true, we know (because of the synchronization) that at some point after we called upToDate() and before it returned, the compiled plan was up to date. However, the synchronization doesn&apos;t guarantee that the plan is up to date the moment after the method has returned, does it? How do we know the plan is still valid then? Is it because of the uncertainty we keep calling upToDate() multiple times during execution?&lt;/p&gt;</comment>
                            <comment id="12538150" author="djd" created="Sat, 27 Oct 2007 01:06:33 +0100"  >&lt;p&gt;GPS#getActivation &amp;amp; GPS#finish will not be called per execution (except when using a Statement).&lt;/p&gt;

&lt;p&gt;The upToDate() check interacts with the table locking of any DDL that lead to the invalidation.&lt;/p&gt;

&lt;p&gt;When a table T  is modified via DDL there is an exclusive lock held on T.&lt;br/&gt;
This lock is obtained and then plans dependent on that table are modified.&lt;/p&gt;

&lt;p&gt;Thus if a statement has obtained an intent lock on T and it is valid (upToDate()) then it can complete its execution knowing that no DDL can proceed and invalidate it since it holds an intent table lock that will block any DDL&apos;s exclusive lock.&lt;/p&gt;

&lt;p&gt;So ideally a plan will check that it&apos;s up to date once all of its table locks are obtained, in Derby this is not centralized. Some DBMS&apos;s as part of their compilation setup a list of table intent locks and obtain them at the start of execution. In Derby this is handled by calling checkStatementValdity() in &lt;b&gt;each&lt;/b&gt; open of a ResultSet (possibly regardless of it it obtains a table lock or not).&lt;/p&gt;

&lt;p&gt;Ideally this would be in one place, maybe after the open of the top level (language) ResultSet and thus executed once per-plan. I&apos;m not sure though if the top-level open is guaranteed to open all the tables that the plan requires.&lt;/p&gt;

&lt;p&gt;There&apos;s room for improvement here, not least by writing up &amp;amp; understanding all the interactions.&lt;/p&gt;


</comment>
                            <comment id="12760617" author="knutanders" created="Tue, 29 Sep 2009 15:22:46 +0100"  >&lt;p&gt;I ran the Values1 test on a Sun Fire T2000 with 32 virtual processors (running&lt;br/&gt;
Solaris 10 and Java version 1.6.0_15) and noticed that there was a simple&lt;br/&gt;
change in BaseActivation.checkStatementValidity() that improved the situation&lt;br/&gt;
somewhat. As mentioned in the previous comments, there&apos;s a synchronized block&lt;br/&gt;
in checkStatementValidity() where a lot of time is spent waiting:&lt;/p&gt;

&lt;p&gt;    synchronized (preStmt) &lt;/p&gt;
{
        if ((gc == preStmt.getActivationClass()) &amp;amp;&amp;amp; preStmt.upToDate())
            return;
    }

&lt;p&gt;If the (gc == preStmt.getActivationClass()) check is moved inside&lt;br/&gt;
preStmt.upToDate(), which is also synchronized on preStmt, we avoid a double&lt;br/&gt;
synchronization. This appears to take some of the pressure off the monitor and&lt;br/&gt;
allows the Values1 test to scale better. The preStmt monitor is still very hot,&lt;br/&gt;
though, so the performance still breaks down when too many threads are added,&lt;br/&gt;
but it is able to handle more threads than before before it breaks down.&lt;/p&gt;

&lt;p&gt;The attached patch and graph (patch-1a.diff and patch-1a.png) show the change&lt;br/&gt;
and its effect on the scalability. Whereas trunk maxes out on 5 threads and&lt;br/&gt;
305K tx/s, the patched version maxes out on 7 threads and 520K tx/s. After both&lt;br/&gt;
trunk and the patched version have collapsed because of too many threads, the&lt;br/&gt;
patched version seems to stabilize on a level 30% higher than trunk.&lt;/p&gt;

&lt;p&gt;For comparison, the graph also shows the results for trunk with separate plans&lt;br/&gt;
for each thread. Its throughput grows steadily for each thread added until the&lt;br/&gt;
number of threads reaches the number of virtual processors (32), which is still&lt;br/&gt;
far better than with shared plans, so it&apos;s clear that the patch is not a full&lt;br/&gt;
solution to this issue. It doesn&apos;t do anything with the underlying problem,&lt;br/&gt;
which is that upToDate() is called way too frequently during execution, but it&lt;br/&gt;
may be a good first step to remove the overhead of shared plans.&lt;/p&gt;

&lt;p&gt;One may perhaps expect the JVM to be able to eliminate double synchronization,&lt;br/&gt;
so that such a change should not be necessary. Anyhow, I think the change would&lt;br/&gt;
make sense even without any performance benefit, as it hides some of&lt;br/&gt;
GenericPreparedStatement&apos;s internal synchronization details from users of the&lt;br/&gt;
PreparedStatement interface.&lt;/p&gt;</comment>
                            <comment id="12765021" author="knutanders" created="Tue, 13 Oct 2009 11:01:03 +0100"  >&lt;p&gt;Committed patch-1a.diff to trunk with revision 824657.&lt;/p&gt;</comment>
                            <comment id="12801786" author="knutanders" created="Mon, 18 Jan 2010 14:00:24 +0000"  >&lt;p&gt;EmbedStatement.executeStatement() calls rePrepare() on the execution plan before trying to execute it. Later, in the same method, the plan is executed by calling GenericPreparedStatement.execute(). One of the first things GPS.execute() does, is to call rePrepare().&lt;/p&gt;

&lt;p&gt;Although calling rePrepare() on an already prepared and valid plan is basically a no-op, it does involve a check of statement validity and therefore contributes to the problem reported in this issue. It seems to me that the first call to rePrepare() is unnecessary, since the statement will be re-prepared if needed right before execution anyways.&lt;/p&gt;

&lt;p&gt;The attached patch (2a) removes the call to rePrepare() in EmbedStatement.executeStatement(). It also moves the retrieval of compile-time warnings until execute() has been called, since re-preparation will now happen in execute().&lt;/p&gt;

&lt;p&gt;All the regression tests ran cleanly with the patch. I also reran the Values test on a machine similar to the one used for testing patch 1a. The attached graph patch-2a.png shows the performance compared with trunk (which includes the 1a patch) and 10.5.3.0 (which contains none of the patches). There&apos;s still a long way to go before the scalability is similar to the one we get when the threads don&apos;t share the same execution plan, but the patch does seem to improve the situation somewhat.&lt;/p&gt;</comment>
                            <comment id="12803744" author="dagw" created="Fri, 22 Jan 2010 16:20:36 +0000"  >&lt;p&gt;The patch 2a looks safe to me, +1. Good catch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12803750" author="knutanders" created="Fri, 22 Jan 2010 16:30:12 +0000"  >&lt;p&gt;Thanks, Dag! Committed revision 902147.&lt;/p&gt;</comment>
                            <comment id="13467463" author="mamtas" created="Tue, 2 Oct 2012 05:02:49 +0100"  >&lt;p&gt;Hi Knut, can this jira be closed. It looks like there were 2 commits made for it,&lt;/p&gt;</comment>
                            <comment id="13467584" author="knutanders" created="Tue, 2 Oct 2012 09:45:01 +0100"  >&lt;p&gt;I think the problem described in this issue is not completely fixed yet. However, since some fixes have been committed, and it&apos;s not clear what more needs to be done, I&apos;m closing the issue. If someone later comes up with an idea on how to improve this code, that work could be tracked in a separate issue.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12364410" name="Values.java" size="2511" author="knutanders" created="Thu, 23 Aug 2007 11:26:57 +0100"/>
                            <attachment id="12420791" name="patch-1a.diff" size="3513" author="knutanders" created="Tue, 29 Sep 2009 15:22:46 +0100"/>
                            <attachment id="12420792" name="patch-1a.png" size="8270" author="knutanders" created="Tue, 29 Sep 2009 15:22:46 +0100"/>
                            <attachment id="12430632" name="patch-2a.diff" size="993" author="knutanders" created="Mon, 18 Jan 2010 14:00:24 +0000"/>
                            <attachment id="12430633" name="patch-2a.png" size="5079" author="knutanders" created="Mon, 18 Jan 2010 14:00:24 +0000"/>
                            <attachment id="12364409" name="values1.png" size="4611" author="knutanders" created="Thu, 23 Aug 2007 11:26:57 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 23 Aug 2007 17:49:31 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30700</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy08cf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>35170</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>