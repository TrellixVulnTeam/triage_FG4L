<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:52:03 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3980/DERBY-3980.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3980] Conflicting select then update with REPEATABLE_READ gives lock timeout instead of deadlock</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3980</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;The attached program TryTimeout.java should detect a deadlock but instead throws a lock timeout exception.  The program has two threads that attempt:&lt;/p&gt;


&lt;p&gt;	    threadConnection.setAutoCommit(false);&lt;br/&gt;
	    /* set isolation level to repeatable read */&lt;br/&gt;
	    threadConnection.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);&lt;/p&gt;

&lt;p&gt;	    ResultSet rs = stmt.executeQuery(&quot;select * from t where i = 456&quot;);&lt;br/&gt;
	    while (rs.next());&lt;br/&gt;
	    stmt.executeUpdate(&quot;update t set i = 456 where i = 456&quot;);&lt;br/&gt;
	    threadConnection.commit();&lt;/p&gt;


&lt;p&gt;This gives SQLState 40001 (deadlock) with DB2 but a lock timeout with Derby.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12410236">DERBY-3980</key>
            <summary>Conflicting select then update with REPEATABLE_READ gives lock timeout instead of deadlock</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="kmarsden">Kathey Marsden</reporter>
                        <labels>
                            <label>derby_triage10_5_2</label>
                    </labels>
                <created>Tue, 9 Dec 2008 01:00:11 +0000</created>
                <updated>Tue, 19 Apr 2011 13:38:40 +0100</updated>
                            <resolved>Mon, 14 Mar 2011 16:47:21 +0000</resolved>
                                    <version>10.1.3.1</version>
                    <version>10.2.2.0</version>
                    <version>10.3.3.0</version>
                    <version>10.4.2.0</version>
                    <version>10.5.1.1</version>
                                    <fixVersion>10.5.3.2</fixVersion>
                    <fixVersion>10.6.2.4</fixVersion>
                    <fixVersion>10.7.1.4</fixVersion>
                    <fixVersion>10.8.1.2</fixVersion>
                                    <component>Services</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12654881" author="kmarsden" created="Tue, 9 Dec 2008 18:33:19 +0000"  >&lt;p&gt;Attaching the 10.1 derby.log which shows two waiters instead of one.&lt;/p&gt;

&lt;p&gt;Also attaching the javacore from the trunk run as the threads are waiting to show where they are waiting.&lt;/p&gt;
</comment>
                            <comment id="12654884" author="mikem" created="Tue, 9 Dec 2008 18:38:12 +0000"  >&lt;p&gt;Looking at the error log there are a few wierd things:&lt;br/&gt;
1) I would expect to see 2 waiting locks.  &lt;br/&gt;
2) Given that it should be repeatable read, and there is no index I would expect the lock list to contain row locks for&lt;br/&gt;
     every row in the table.  Maybe it would useful to dump the lock table after the select using the lock vti just to see if&lt;br/&gt;
     it matches.  Maybe this will lead to whether the issue is the actual lock table, or just some issue with contruction the&lt;br/&gt;
     error message.  (1, 9) is likely the row in question.  The other rows are likely (1, 6), (1,7), and (1,8).  The id&apos;s before&lt;br/&gt;
     6 are reserved for special use so real rows start at 6 and increase.  &lt;br/&gt;
3) Just to be complete it would be good to verify that both threads are in a wait state in the lock, I would just dump the&lt;br/&gt;
     stacks using signal or cntrl key depending on jvm while it is stalled.  I looked at program and can&apos;t imagine anything else &lt;br/&gt;
     going on.&lt;br/&gt;
4) Anyone who wants to look at this one, the code is pretty isolated.  The interesting code is in &lt;br/&gt;
opensource/java/engine/org/apache/derby/impl/services/locks/LockSet.java&lt;/p&gt;

&lt;p&gt;5) some debugging steps I would take would include:&lt;br/&gt;
    o verify if a deadlock search is being made or not?&lt;br/&gt;
    o run in sane mode and turn on the SanityManager.DEBUG_ON(&quot;DeadlockTrace&quot;) flag.&lt;br/&gt;
    o If a deadlock search is being made, use the sanity code to dump out the lock table when the deadlock search is done and&lt;br/&gt;
       misses the deadlock.&lt;br/&gt;
    o see if the bug still happens if there is only 1 row in the table.&lt;/p&gt;

&lt;p&gt;ERROR 40XL2: A lock could not be obtained within the time requested.  The lockTable dump is: &lt;br/&gt;
2008-12-09 00:50:40.640 GMT&lt;br/&gt;
XID       |TYPE         |MODE|LOCKCOUNT|LOCKNAME                                                                        |STATE|TABLETYPE / LOCKOBJ                   |INDEXNAME / CONTAINER_ID / (MODE for LATCH only)  |TABLENAME / CONGLOM_ID                |&lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;The following row is the victim ***&lt;br/&gt;
186       |ROW          |U   |0        |(1,9)                                                                           |WAIT |T                                     |NULL                                              |T                                     |&lt;/li&gt;
			&lt;li&gt;The above row is the victim ***&lt;br/&gt;
184       |ROW          |S   |1        |(1,9)                                                                           |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
186       |ROW          |S   |1        |(1,9)                                                                           |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
184       |ROW          |U   |1        |(1,9)                                                                           |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
184       |TABLE        |IS  |1        |Tablelock                                                                       |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
186       |TABLE        |IS  |1        |Tablelock                                                                       |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
184       |TABLE        |IX  |2        |Tablelock                                                                       |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
186       |TABLE        |IX  |2        |Tablelock                                                                       |GRANT|T                                     |NULL                                              |T                                     |&lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12654886" author="mikem" created="Tue, 9 Dec 2008 18:42:23 +0000"  >&lt;p&gt;It may also be interesting to see if this is somehow related to U lock vs. X lock.  A similar test to one posted but changing the update to a delete would be interesting.  &lt;/p&gt;</comment>
                            <comment id="12655216" author="kmarsden" created="Wed, 10 Dec 2008 14:13:00 +0000"  >&lt;p&gt;I pursued some of Mike&apos;s debugging steps.&lt;br/&gt;
    o verify if a deadlock search is being made or not?&lt;br/&gt;
        The code enters Deadlock.look() so if that means it is doing a deadlock search then we are.&lt;br/&gt;
    o run in sane mode and turn on the SanityManager.DEBUG_ON(&quot;DeadlockTrace&quot;) flag.&lt;br/&gt;
       I set this but don&apos;t see any output difference.  In my calling program I just called    SanityManager.DEBUG_ON(&quot;DeadlockTrace&quot;).&lt;br/&gt;
       Am I doing something wrong?&lt;br/&gt;
    o If a deadlock search is being made, use the sanity code to dump out the lock table when the deadlock search is done and&lt;br/&gt;
       misses the deadlock.&lt;br/&gt;
      Haven&apos;t tried this yet.&lt;br/&gt;
    o see if the bug still happens if there is only 1 row in the table. &lt;br/&gt;
     It still happens with one row.&lt;br/&gt;
    o see if it still happens with a delete&lt;br/&gt;
     The same problem exists with delete.&lt;br/&gt;
   o verify two threads are waiting on lock with &amp;lt;ctrl&amp;gt; break.&lt;br/&gt;
      Here are the two traces with the program set to do a delete instead of update.&lt;br/&gt;
4XESTACKTRACE          at java/lang/Object.wait(Native Method)&lt;br/&gt;
4XESTACKTRACE          at java/lang/Object.wait(Object.java:231)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/daemon/BasicDaemon.rest(BasicDaemon.java:571)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/daemon/BasicDaemon.run(BasicDaemon.java:388)&lt;br/&gt;
4XESTACKTRACE          at java/lang/Thread.run(Thread.java:803)&lt;br/&gt;
3XMTHREADINFO      &quot;Thread-5&quot; (TID:0x4203EC00, sys_thread_t:0x42286868, state:CW, native ID:0x00001D94) prio=5&lt;br/&gt;
4XESTACKTRACE          at java/lang/Object.wait(Native Method)&lt;br/&gt;
4XESTACKTRACE          at java/lang/Object.wait(Object.java:231)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/ActiveLock.waitForGrant(ActiveLock.java:118)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/ConcurrentLockSet.lockObject(ConcurrentLockSet.java:463(Compiled Code))&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/AbstractPool.lockObject(AbstractPool.java:119)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/ConcurrentPool.lockObject(ConcurrentPool.java:28)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/raw/xact/RowLocking3.lockRecordForRead(RowLocking3.java:187)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/access/conglomerate/OpenConglomerate.lockPositionForRead(OpenConglomerate.java:436)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/access/conglomerate/GenericScanController.fetchRows(GenericScanController.java:683)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/access/heap/HeapScan.fetchNext(HeapScan.java:240)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/TableScanResultSet.getNextRowCore(TableScanResultSet.java:680)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:255)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/DMLWriteResultSet.getNextRowCore(DMLWriteResultSet.java:127)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/DeleteResultSet.setup(DeleteResultSet.java:252)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/DeleteResultSet.open(DeleteResultSet.java:136)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:416)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/GenericPreparedStatement.execute(GenericPreparedStatement.java:297)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/jdbc/EmbedStatement.executeStatement(EmbedStatement.java:1235)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/jdbc/EmbedStatement.execute(EmbedStatement.java:625)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/jdbc/EmbedStatement.executeUpdate(EmbedStatement.java:175)&lt;br/&gt;
4XESTACKTRACE          at TryTimeout.threadWorker(TryTimeout.java:125)&lt;br/&gt;
4XESTACKTRACE          at TryTimeout.access$000(TryTimeout.java:5)&lt;br/&gt;
4XESTACKTRACE          at TryTimeout$1.run(TryTimeout.java:69)&lt;br/&gt;
4XESTACKTRACE          at java/lang/Thread.run(Thread.java:803)&lt;br/&gt;
3XMTHREADINFO      &quot;Thread-6&quot; (TID:0x4203F000, sys_thread_t:0x42286ABC, state:CW, native ID:0x00001C5C) prio=5&lt;br/&gt;
4XESTACKTRACE          at java/lang/Object.wait(Native Method)&lt;br/&gt;
4XESTACKTRACE          at java/lang/Object.wait(Object.java:231)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/ActiveLock.waitForGrant(ActiveLock.java:118)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/ConcurrentLockSet.lockObject(ConcurrentLockSet.java:463(Compiled Code))&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/AbstractPool.lockObject(AbstractPool.java:119)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/services/locks/ConcurrentPool.lockObject(ConcurrentPool.java:28)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/raw/xact/RowLocking3.lockRecordForWrite(RowLocking3.java:248)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/access/conglomerate/OpenConglomerate.lockPositionForWrite(OpenConglomerate.java:541)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.delete(GenericConglomerateController.java:179)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/RowChangerImpl.deleteRow(RowChangerImpl.java:478)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/DeleteResultSet.collectAffectedRows(DeleteResultSet.java:405)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/execute/DeleteResultSet.open(DeleteResultSet.java:137)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/GenericPreparedStatement.executeStmt(GenericPreparedStatement.java:416)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/sql/GenericPreparedStatement.execute(GenericPreparedStatement.java:297)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/jdbc/EmbedStatement.executeStatement(EmbedStatement.java:1235)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/jdbc/EmbedStatement.execute(EmbedStatement.java:625)&lt;br/&gt;
4XESTACKTRACE          at org/apache/derby/impl/jdbc/EmbedStatement.executeUpdate(EmbedStatement.java:175)&lt;br/&gt;
4XESTACKTRACE          at TryTimeout.threadWorker(TryTimeout.java:125)&lt;br/&gt;
4XESTACKTRACE          at TryTimeout.access$000(TryTimeout.java:5)&lt;br/&gt;
4XESTACKTRACE          at TryTimeout$1.run(TryTimeout.java:69)&lt;br/&gt;
4XESTACKTRACE          at java/lang/Thread.run(Thread.java:803)&lt;/p&gt;

</comment>
                            <comment id="12655324" author="kmarsden" created="Wed, 10 Dec 2008 19:23:06 +0000"  >&lt;p&gt;I got the extra DeadlockTrace output  on by putting this in my derby.properties.&lt;br/&gt;
derby.debug.true=DeadlockTrace&lt;/p&gt;

</comment>
                            <comment id="12655393" author="kmarsden" created="Wed, 10 Dec 2008 22:37:47 +0000"  >&lt;p&gt;I am debugging this on 10.1 since at least there the Lock table showed two waiters on lock timeout.&lt;br/&gt;
I changed the test case a bit to have one of the threads sleep for 10 seconds after the select and also to have the program dump the lock table every ten seconds.  I found that after adding the sleep I usually get a deadlock instead of the timeout.&lt;br/&gt;
Expected exception:A lock could not be obtained due to a deadlock, cycle of locks and waiters is:&lt;br/&gt;
Lock : ROW, T, (1,7)&lt;br/&gt;
  Waiting XID : &lt;/p&gt;
{254, U}
&lt;p&gt; , DB2ADMIN, delete from t  where i = 456&lt;br/&gt;
  Granted XID : &lt;/p&gt;
{256, S}&lt;br/&gt;
Lock : ROW, T, (1,7)&lt;br/&gt;
  Waiting XID : {256, X} , DB2ADMIN, delete from t  where i = 456&lt;br/&gt;
  Granted XID : {256, S}
&lt;p&gt; , &lt;/p&gt;
{254, S}

&lt;p&gt;but still I sometimes get the lock timeout.  I also saw that at the time of deadlock checking, the lock tables for both the lock timeout run and the deadlock run show the same lock table which should deadlock.&lt;br/&gt;
xid     |username|trantype|type    |cnt|mode|tabname     |lockname  |state|status&lt;br/&gt;
---------------------------------------------------------------------------------&lt;br/&gt;
279     |UserTran|TABLE   |1  |IS  |T           |Tablelock |GRANT|ACTIVE&lt;br/&gt;
281     |UserTran|TABLE   |1  |IS  |T           |Tablelock |GRANT|ACTIVE&lt;br/&gt;
279     |UserTran|TABLE   |2  |IX  |T           |Tablelock |GRANT|ACTIVE&lt;br/&gt;
281     |UserTran|TABLE   |2  |IX  |T           |Tablelock |GRANT|ACTIVE&lt;br/&gt;
279     |UserTran|ROW     |1  |S   |T           |(1,7)     |GRANT|ACTIVE&lt;br/&gt;
281     |UserTran|ROW     |1  |S   |T           |(1,7)     |GRANT|ACTIVE&lt;br/&gt;
279     |UserTran|ROW     |0  |U   |T           |(1,7)     |WAIT|ACTIVE&lt;br/&gt;
281     |UserTran|ROW     |1  |U   |T           |(1,7)     |GRANT|ACTIVE&lt;br/&gt;
281     |UserTran|ROW     |0  |X   |T           |(1,7)     |WAIT|ACTIVE&lt;/p&gt;

&lt;p&gt;Mike mentioned to me that he thought it might be a problem with both threads doing the deadlock check at the same time, but  it seems like with the sleep that couldn&apos;t be the problem.  Let me know if you would like me to post the updated program.&lt;/p&gt;</comment>
                            <comment id="12655411" author="kmarsden" created="Wed, 10 Dec 2008 23:12:57 +0000"  >&lt;p&gt;Here is the updated program in case someone is interested, TryTimeout2.java . Changes from TryTimeout.java are&lt;br/&gt;
1) Second thread sleeps for 10 second after select.&lt;br/&gt;
2) Only has one row in the table.&lt;br/&gt;
3) Does delete instead of update.&lt;br/&gt;
4) Starts a thread that shows a lock table dump every 10 seconds.&lt;br/&gt;
5) This one fails sometimes with deadlock and sometimes with lock timeout.&lt;/p&gt;
</comment>
                            <comment id="12655583" author="knutanders" created="Thu, 11 Dec 2008 09:36:38 +0000"  >&lt;p&gt;Just a guess here, since I haven&apos;t checked the details. In the inner&lt;br/&gt;
for loop of Deadlock.look(), there&apos;s some code to prevent false&lt;br/&gt;
positives for self-deadlocks:&lt;/p&gt;

&lt;p&gt;    // We could be seeing a situation here like&lt;br/&gt;
    // Granted T1&lt;/p&gt;
{S}, T2{S}
&lt;p&gt;    // Waiting T1&lt;/p&gt;
{X}
&lt;p&gt; - deadlock checking on this&lt;br/&gt;
    //&lt;br/&gt;
    // In this case it&apos;s not a deadlock, although it&lt;br/&gt;
    // depends on the locking policy of the Lockable. E.g.&lt;br/&gt;
    .&lt;br/&gt;
    .&lt;br/&gt;
    .&lt;br/&gt;
    if (lock.canSkip) &lt;/p&gt;
{
        // not a deadlock ...
        chain.push(space); // set up as rollback() expects.

        rollback(chain);
        continue outer;
    }

&lt;p&gt;I&apos;m wondering if this perhaps is too broad. Both the transactions that&lt;br/&gt;
are waiting for the X lock already have a shared lock on the row, so&lt;br/&gt;
they&apos;ll both have lock.canSkip==true. We may be giving up finding a&lt;br/&gt;
deadlock along that path too early.&lt;/p&gt;</comment>
                            <comment id="12655720" author="kmarsden" created="Thu, 11 Dec 2008 18:06:59 +0000"  >&lt;p&gt;I did the runs with some additional  println&apos;s.  &lt;br/&gt;
1) Upon entering Deadlock.look, I print:&lt;br/&gt;
System.out.println(Thread.currentThread().getName() + &quot; Deadlock look&quot;);&lt;br/&gt;
        System.out.println(set.toDebugString());&lt;br/&gt;
2) Upon entering the block of code Knut mentioned I print  &lt;br/&gt;
   if (lock.canSkip) {&lt;br/&gt;
                System.out.println(&quot;rollback(chain). Not a deadlock&quot;);&lt;/p&gt;

&lt;p&gt;Here is the output of the run with deadlock TryTimeout2.out.10_1.deadlock and the run with timeout TryTimeout2.out.10_1.locktimeout.&lt;/p&gt;

&lt;p&gt;In both cases it first does a Deadlock.look for Thread0 which does not detect any deadlocks.&lt;/p&gt;

&lt;p&gt;On the Deadlock.look for Thread1  we see it pass through the &quot;Not a deadlock&quot; line for the deadlock case, not the lock timeout case, which is the reverse of what I would expect if that code were the problem.&lt;/p&gt;

&lt;p&gt;What I do notice is that always when we deadlock the lock&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; and lock&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;  of the Thread1 LockControl objects are in the reverse order from the timeout run.  Perhaps there is some problem in the logic when they are ordered in this way.&lt;/p&gt;

&lt;p&gt;A few general things I don&apos;t understand. Sorry for my newbieness.&lt;/p&gt;

&lt;p&gt;1) Why did we not detect the deadlock when Thread0 did Deadlock.look()?  The locks were the same at that point.&lt;/p&gt;

&lt;p&gt;2) Why in the timeout case do we do a second Deadlock.look on Thread0?&lt;/p&gt;

&lt;p&gt;3) Should the order of the LockControl objects matter?&lt;/p&gt;

&lt;p&gt;4) Could someone give me a high level description of the arguments to Deadlock.look()&lt;br/&gt;
static Object[] look(SinglePool factory, LockSet set, LockControl control, ActiveLock startingLock, byte deadlockWake) {&lt;br/&gt;
There is no javadoc.  I would be happy to add some if someone could post the information here.&lt;/p&gt;</comment>
                            <comment id="12655725" author="mikem" created="Thu, 11 Dec 2008 18:34:49 +0000"  >&lt;p&gt;I don&apos;t have answers, but more questions.  It looks like there are also timing bugs going on.  It might help if the program dumped more timing information along with print outs.&lt;/p&gt;

&lt;p&gt;For the timeout case, ignoring that it should be a deadlock, it seems like we should see a timeout after 60 seconds for Thread0 and then a timeout for Thread1 after 70 seconds, but it looks like they both timeout at the same time.&lt;/p&gt;</comment>
                            <comment id="12655746" author="mikem" created="Thu, 11 Dec 2008 19:16:50 +0000"  >&lt;p&gt;how about this as start for the javadoc:&lt;br/&gt;
    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Do a deadlock search.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;Walk through the graph of all locks and search for cycles among&lt;/li&gt;
	&lt;li&gt;the waiting lock requests which would indicate a deadlock.  A simple&lt;/li&gt;
	&lt;li&gt;deadlock cycle is where the granted locks of waiting compatibility&lt;/li&gt;
	&lt;li&gt;space A is blocking compatibility space B and space B holds locks causing&lt;/li&gt;
	&lt;li&gt;space A to wait.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;Would be nice to get a better high level description of deadlock&lt;/li&gt;
	&lt;li&gt;search.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;br/&gt;
     *&lt;/li&gt;
	&lt;li&gt;@return The identifier to be used to open the conglomerate later.&lt;br/&gt;
     *&lt;/li&gt;
	&lt;li&gt;@param factory       The locking system factory&lt;/li&gt;
	&lt;li&gt;@param set           The complete lock table. A lock table is a hash&lt;/li&gt;
	&lt;li&gt;table keyed by a Lockable and with a LockControl as&lt;/li&gt;
	&lt;li&gt;the data element.&lt;/li&gt;
	&lt;li&gt;@param control       A LockControl contains a reference to the item being&lt;/li&gt;
	&lt;li&gt;locked and doubly linked lists for the granted locks&lt;/li&gt;
	&lt;li&gt;and the waiting locks.  The passed in value is the&lt;/li&gt;
	&lt;li&gt;lock that the caller was waiting on when woken up&lt;/li&gt;
	&lt;li&gt;to do the deadlock check.&lt;/li&gt;
	&lt;li&gt;@param startingLock  represents the specific waiting lock request that&lt;/li&gt;
	&lt;li&gt;the caller has been waiting on, before just being&lt;/li&gt;
	&lt;li&gt;woken up to do this search.&lt;/li&gt;
	&lt;li&gt;@deadlockWake        Either Constants.WAITING_LOCK_IN_WAIT, or&lt;/li&gt;
	&lt;li&gt;Constants.WAITING_LOCK_DEADLOCK.  I am not sure&lt;/li&gt;
	&lt;li&gt;about this one.&lt;br/&gt;
     *&lt;/li&gt;
	&lt;li&gt;@exception  StandardException  Standard exception policy.&lt;br/&gt;
     **/&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12655765" author="mikem" created="Thu, 11 Dec 2008 20:21:41 +0000"  >&lt;p&gt;&amp;gt; 1) Why did we not detect the deadlock when Thread0 did Deadlock.look()? The locks were the same at that point.&lt;br/&gt;
To me this looks like another instance of the bug.  Either thread searching should find the deadlock once they have both gone &lt;br/&gt;
into waiting, which I believe is the case here.  I believe knut&apos;s comment on canSkip may be relevant.  I still don&apos;t understand the&lt;br/&gt;
code using skip.  &lt;/p&gt;

&lt;p&gt;&amp;gt; 3) Should the order of the LockControl objects matter? &lt;br/&gt;
If things are working right deadlock detection should find it no matter what, the order though might change which one is picked as victim.&lt;/p&gt;</comment>
                            <comment id="12655772" author="kmarsden" created="Thu, 11 Dec 2008 21:08:41 +0000"  >&lt;p&gt;Maybe the ordering was a red herring. Here is another run with timestamps and also with printing out index:&quot; + index +&quot; chain.size():&quot; + chain.size() + &quot; chain.indexOf(grants):&quot; + chain.indexOf(grants) before we evaluate whether to skip.&lt;/p&gt;

&lt;p&gt;Here the order of the LockSet  is the same for both runs.  &lt;/p&gt;

&lt;p&gt;The timestamp for the exceptions in the output is off because the exceptions are accumulated and then print, but the derby.log does show the two lock timeout exceptions with almost the  same timestamp so there does seem to be a bug there. &lt;br/&gt;
I will try to make a simpler test case and file a bug for that.&lt;/p&gt;

</comment>
                            <comment id="12655791" author="mikem" created="Thu, 11 Dec 2008 22:23:45 +0000"  >&lt;p&gt;I&apos;ve stared at the code below and am not clear what it is trying to do.  Main questions are&lt;br/&gt;
is it just trying to catch self waits?&lt;br/&gt;
and why is canSkip useful to call, what is the code counting on canSkip to tell it?&lt;/p&gt;

&lt;p&gt;The case in question, posed as the below comment is:&lt;br/&gt;
Granted T0(S), T1(S), T0(U)&lt;br/&gt;
Waiting T0(X)&lt;br/&gt;
Waiting T1(U)&lt;/p&gt;

&lt;p&gt;What is the expected value of canSkip for the 2 waiting locks.  Looking at the code I think both are going to have canSkip&lt;br/&gt;
set to true to indicate that it is ok to grant them in front of other waiting locks, because the space already holds a lock that&lt;br/&gt;
is blocking the waiting locks - but only if they are compatible with all other space granted locks.&lt;/p&gt;

&lt;p&gt;                if (index != -1) {&lt;/p&gt;

&lt;p&gt;                    // We could be seeing a situation here like&lt;br/&gt;
                    // Granted T1&lt;/p&gt;
{S}, T2{S}
&lt;p&gt;                    // Waiting T1&lt;/p&gt;
{X}
&lt;p&gt; - deadlock checking on this&lt;br/&gt;
                    //&lt;br/&gt;
                    // In this case it&apos;s not a deadlock, although it&lt;br/&gt;
                    // depends on the locking policy of the Lockable. E.g.&lt;br/&gt;
                    // Granted T1(latch)&lt;br/&gt;
                    // Waiting T1(latch)&lt;br/&gt;
                    //  is a deadlock.&lt;br/&gt;
                    //&lt;/p&gt;

&lt;p&gt;                    if ((index == (chain.size() - 1)) ||&lt;br/&gt;
                        ((index == (chain.size() - 2))&lt;br/&gt;
                        &amp;amp;&amp;amp; (index == (chain.indexOf(grants) - 1)))) {&lt;/p&gt;

&lt;p&gt;                        // potential self deadlock, but probably not!&lt;br/&gt;
                        ActiveLock lock = (ActiveLock) waiters.get(space);&lt;/p&gt;

&lt;p&gt;                        if (lock.canSkip) &lt;/p&gt;
{
                            // not a deadlock ...
                            chain.push(space); // set up as rollback() expects.

                            rollback(chain);
                            continue outer;
                        }
&lt;p&gt;                    }&lt;/p&gt;

&lt;p&gt;                    return Deadlock.handle(factory, chain, index, waiters, deadl&lt;/p&gt;</comment>
                            <comment id="12656088" author="kmarsden" created="Fri, 12 Dec 2008 18:13:20 +0000"  >&lt;p&gt;Attaching a trunk patch derby-3980_javadoc_and_test_diff.txt to update the javadoc as Mike suggested and to add a test for this issue which of course currently fails. The test should be ready to add into the suite once the issue is fixed.  Ran javadoc build and saw no warnings.  I&apos;ll check this in later this afternoon.&lt;/p&gt;

</comment>
                            <comment id="12656090" author="mikem" created="Fri, 12 Dec 2008 18:14:20 +0000"  >&lt;p&gt;i am wondering if the problem is that lock manager not beeing able to tell the difference for the purpose of deadlock detection&lt;br/&gt;
the case of a waitor on a waitor because of live lock, and a waitor on a waitor because both are blocked.  lockSkip may come into&lt;br/&gt;
it.   In this case I think lockSkip is getting set for both waitors, which properly means it is ok for them to skip waitors as they already&lt;br/&gt;
hold a lock blocking waitors, but they can&apos;t get granted now.   &lt;/p&gt;


&lt;p&gt;granted: T0(S), T1(S), T0(U)&lt;br/&gt;
waiting:  T1(U), T0(X)&lt;/p&gt;

&lt;p&gt;I think at least in the lastest repro which does 2 deadlock scans something is going wrong during 1st search which misses&lt;br/&gt;
the deadlock with respect to waiting on waitors case.  The problem comes when&lt;br/&gt;
we get to I think T0(X) which is marked waiting on a waitor.  For this we get to the &quot;waiting on a waitor&quot; part of the deadlock search and&lt;br/&gt;
it does not push anything on the stack.  Seems like it should push whatever granted locks are incompatible with it. It just changes &lt;br/&gt;
the current search compatibility space to be the waitor space, which may be fine if it is just waiting for waitors in front of it to get &lt;br/&gt;
granted and there is not current incompatible lock.  &lt;/p&gt;

&lt;p&gt;we need to make sure any fix does not start giving back false positives for livelock type waits.  The test suite really has almost no&lt;br/&gt;
testing for dealock/livelock cases, probably should add some as part of this fix.  The problem in the past has been depending on&lt;br/&gt;
timing it is sometimes hard to guarantee which waiting thread gets the deadlock in a system independent way.  &lt;/p&gt;</comment>
                            <comment id="12656157" author="kmarsden" created="Fri, 12 Dec 2008 20:39:36 +0000"  >&lt;p&gt;Thanks Mike for the tips and recommending tests.  I am studying the code but must admit I am still a bit baffled by it all.&lt;br/&gt;
I do think I can help by writing regression tests, so we can feel confident in the fix when we get one.   I&apos;ll write one for the simple deadlock case that I know works and  I&apos;d like to write a test for the live lock scenario.  Do I just need three  threads,  2 doing a repeated staggered select and another trying to get in and do an update?&lt;/p&gt;

&lt;p&gt;Are there any other tests that would be good?&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;</comment>
                            <comment id="12656700" author="kmarsden" created="Mon, 15 Dec 2008 19:11:04 +0000"  >&lt;p&gt;Attached is a test that test for live lock.  I would appreciate it if someone could review to make sure I am testing the right thing.  I have&lt;br/&gt;
SelectThread1 - starts right away.&lt;br/&gt;
for 10 tries &lt;/p&gt;
{
  - select * from t;
   -wait 3 seconds
   - commit
}

&lt;p&gt;SelectThread2 &lt;br/&gt;
Wait 1 second then the same as SelectThread1&amp;gt;&lt;/p&gt;

&lt;p&gt;UpdateThread&lt;br/&gt;
Wait 2 seconds&lt;br/&gt;
UPDATE T SET I = 456 where I = 456&lt;/p&gt;

&lt;p&gt;Deadlock timeout set to 5 seconds&lt;br/&gt;
Lock timeout set to 10 seconds.&lt;/p&gt;

&lt;p&gt;Makes sure the update goes through without exception.&lt;/p&gt;</comment>
                            <comment id="12657118" author="kmarsden" created="Tue, 16 Dec 2008 19:08:49 +0000"  >&lt;p&gt;I am attaching an old user case which should show a deadlock but gives lock timeouts.  I think it is just the same as &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3980&quot; title=&quot;Conflicting select then update with REPEATABLE_READ gives lock timeout instead of deadlock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3980&quot;&gt;&lt;del&gt;DERBY-3980&lt;/del&gt;&lt;/a&gt; except with inserts instead of deletes or updates, so I don&apos;t think it warrants another test.  Posting it here so it can be tried with the fix once there is one and perhaps someone else will see something worthwhile adding to the tests.&lt;/p&gt;

</comment>
                            <comment id="12657138" author="knutanders" created="Tue, 16 Dec 2008 19:57:41 +0000"  >&lt;p&gt;The test looks OK to me. It tests what its class javadoc says (that the two readers don&apos;t starve the writer). But wasn&apos;t the point actually to test that the deadlock detection doesn&apos;t incorrectly report it as a deadlock? I&apos;m not sure if deadlock detection will be performed in this case. If I understand the description of the test correctly, the update thread will be granted the exclusive lock after two seconds, but deadlock detection is not performed unless it needs to wait more than five seconds.&lt;/p&gt;

&lt;p&gt;Some minor nits:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;This code in selectWorker() doesn&apos;t do anything:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+            if (delay &amp;gt; 0)&lt;br/&gt;
+                ;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The while loop in selectWorker() checks the exit condition twice, here&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+            while (!isUpdateDone() &amp;amp;&amp;amp; tries &amp;lt;= 10) {&lt;/p&gt;

&lt;p&gt;and here&lt;/p&gt;

&lt;p&gt;+                if (tries == 10)&lt;br/&gt;
+                    fail(&quot;Update did not occur after 10 selects&quot;);&lt;/p&gt;

&lt;p&gt;The first check has no effect currently, and it should probably be removed so that one later doesn&apos;t disable the last check by accident if one decides to change to some other number of iterations and forgets to update one of the places.&lt;/p&gt;</comment>
                            <comment id="12657165" author="kmarsden" created="Tue, 16 Dec 2008 21:14:41 +0000"  >&lt;p&gt;Thanks Knut for looking at the patch.  I committed  revision 727147 for the changes you recommended.  The test for deadlock detection I checked in was Derby3980DeadlockTest.  That test currently fails with a lock timeout, so is not part of the suite.&lt;/p&gt;

&lt;p&gt;I added LiveLockTest because Mike suggested that we add a test for the live lock scenario as part of this issue, so we make sure we don&apos;t regress. Perhaps it would have been clearer to open a separate issue.  I hope I understood live lock correctly and that&apos;s what&apos;s being tested with LiveLockTest.  If not,  I&apos;ll try to make another shot at it when I get back from holiday in a few weeks time.  Hopefully  the mysteries of Deadlock.look() will be unlocked during that time and this issue can be resolved. If so the test Derby3980DeadlockTest should be enabled.&lt;/p&gt;

&lt;p&gt;Kathey&lt;/p&gt;


</comment>
                            <comment id="12657204" author="knutanders" created="Tue, 16 Dec 2008 22:44:47 +0000"  >&lt;p&gt;I understood Mike&apos;s comment as that we should make sure a livelock wasn&apos;t detected as a deadlock (false positive) after we make the changes, which means we would have to run deadlock detection on a possible livelock situation in order to test it. I have problems seeing how changes to the deadlock detection algorithm could cause a regression in a test that doesn&apos;t exercise that algorithm. But I agree that it&apos;s good to have this test too. Just shortening the deadlock timeout or increasing the time the select threads hold the locks would additionally make it test the deadlock detection algorithm, though.&lt;/p&gt;</comment>
                            <comment id="12657547" author="kmarsden" created="Wed, 17 Dec 2008 20:50:15 +0000"  >&lt;p&gt;Here is the updated patch where I confirmed we enter Deadlock.look(). I made the sleep 25 seconds and used the default deadlock and wait timeouts.  I tried just adjusting the deadlock timeout down to achieve the same result, but found we were never entering Deadlock.look(). There seems to be a problem  with the timeout values at least when set low.&lt;/p&gt;</comment>
                            <comment id="12658687" author="knutanders" created="Mon, 22 Dec 2008 22:11:18 +0000"  >&lt;p&gt;Do you see the problem with low timeout values if you change the nesting order of the CleanDatabaseTestSetup and the DatabasePropertyTestSetup? Many tests set the timeouts to even lower values (typically 2 seconds deadlock timeout and 4 seconds wait timeout).&lt;/p&gt;</comment>
                            <comment id="12658710" author="knutanders" created="Mon, 22 Dec 2008 23:09:02 +0000"  >&lt;p&gt;I think I see now why we have a problem with a lower deadlock timeout. Since the updater is supposed to be granted the lock after two seconds, we need to set the deadlock timeout to one second in order to trigger the deadlock detection. However, just before the updater has waited for one second, the first select thread releases its lock and wakes up all waiters. This early wakeup makes the updater check if it can obtain the lock, which it can&apos;t, but it won&apos;t do a deadlock check. It then goes back to sleep for another second, but before it wakes up to perform deadlock detection, it is granted the lock. (It looks like we allow five early wakeups before we reduce the time to wait for a deadlock. So for each early wakeup, the deadlock timeout is effectively increased. This is probably a good way to do it, since early wakeups indicate that it&apos;s probably not a deadlock yet.)&lt;/p&gt;

&lt;p&gt;Easy workaround: Set the deadlock timeout to 1 second, and make the select threads hold the locks for 4 seconds instead of 3 seconds. Then the update thread will wait for two seconds before it gets the early wakeup (because the first select thread releases the lock), and by that time it will already have performed deadlock detection.&lt;/p&gt;</comment>
                            <comment id="12662182" author="kmarsden" created="Fri, 9 Jan 2009 00:00:31 +0000"  >&lt;p&gt;Thanks Knut for figuring out how to set the sleep and deadlock timeout. I made the changes you suggested.  Although we are now going through deadlock detection, I am still not entirely sure I am  testing the scenario Mike was worried about.  If you or Mike have any suggestions on more test scenarios, please let me know and I will add them.   I think I will abandon staring at the deadlock detection code for a while.    I hope someone that understands this code better than I will fix this bug.&lt;/p&gt;</comment>
                            <comment id="12726961" author="knutanders" created="Fri, 3 Jul 2009 14:33:50 +0100"  >&lt;p&gt;Triaged for 10.5.2. Changed component to Services, since that&apos;s where the deadlock detection code is located.&lt;/p&gt;</comment>
                            <comment id="13006414" author="knutanders" created="Mon, 14 Mar 2011 14:04:31 +0000"  >&lt;p&gt;Attaching a patch for this issue. It&apos;s essentially the same patch as the 1b patch attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5073&quot; title=&quot;Derby deadlocks without recourse on simultaneous correlated subqueries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5073&quot;&gt;&lt;del&gt;DERBY-5073&lt;/del&gt;&lt;/a&gt;, only that the code has been re-indented to account for the extra nesting level added in that patch.&lt;/p&gt;

&lt;p&gt;The patch also adds a regression test with a test case both for this issue and for &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-5073&quot; title=&quot;Derby deadlocks without recourse on simultaneous correlated subqueries&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-5073&quot;&gt;&lt;del&gt;DERBY-5073&lt;/del&gt;&lt;/a&gt;. The test cases fail with a lock timeout without the fix and pass (get the expected deadlock exception) with the fix.&lt;/p&gt;

&lt;p&gt;I&apos;m running the regression test suites on the patch now and intend to commit it to trunk if the tests pass.&lt;/p&gt;</comment>
                            <comment id="13006419" author="bryanpendleton" created="Mon, 14 Mar 2011 14:15:14 +0000"  >&lt;p&gt;Wow! Now that&apos;s a test case! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Seriously, though, the new tests look excellent; they&apos;re commented very&lt;br/&gt;
well, and the code is clearly written. There&apos;s no easy way to write deadlock&lt;br/&gt;
test cases; your effort here should lead the way and make it easier for&lt;br/&gt;
people to write additional deadlock test cases in the future. Thanks very&lt;br/&gt;
much for taking the time to do so.&lt;/p&gt;

&lt;p&gt;It&apos;s too bad we can&apos;t set the deadlock timeout to less than a second. Nowadays,&lt;br/&gt;
that&apos;s an eternity on a modern computer.&lt;/p&gt;
</comment>
                            <comment id="13006505" author="knutanders" created="Mon, 14 Mar 2011 16:47:21 +0000"  >&lt;p&gt;Thanks, Bryan. I take that as a +1, then. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Committed revision 1081455.&lt;/p&gt;

&lt;p&gt;I agree with your comment about sub-second deadlock timeouts. Actually, one may even consider doing deadlock detection every time a lock cannot be granted immediately. I wouldn&apos;t think that it would be too expensive, though I&apos;ve never measured the cost of the deadlock detection, and if you have to wait for a lock, you&apos;ve lost performance-wise in any case, so one might just as well do the extra check. But that&apos;s another JIRA issue, I guess...&lt;/p&gt;</comment>
                            <comment id="13008698" author="kmarsden" created="Sat, 19 Mar 2011 00:25:55 +0000"  >&lt;p&gt;Closing this issue. Thank you Knut for the great fix and figuring out the tricky deadlock code.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12499864">DERBY-5073</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12501519">DERBY-5137</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12372507">DERBY-2877</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12396116" name="LiveLockTest_diff.txt" size="8232" author="kmarsden" created="Mon, 15 Dec 2008 19:11:04 +0000"/>
                            <attachment id="12396344" name="LiveLockTest_with_Deadlock_look_diff.txt" size="2461" author="kmarsden" created="Wed, 17 Dec 2008 20:50:15 +0000"/>
                            <attachment id="12396225" name="LockTimeoutWithInserts.java" size="8575" author="kmarsden" created="Tue, 16 Dec 2008 19:08:49 +0000"/>
                            <attachment id="12395613" name="TryTimeout.java" size="4459" author="kmarsden" created="Tue, 9 Dec 2008 01:03:44 +0000"/>
                            <attachment id="12395770" name="TryTimeout2.java" size="8906" author="kmarsden" created="Wed, 10 Dec 2008 23:12:57 +0000"/>
                            <attachment id="12395875" name="TryTimeout2.out.10_1.deadlock" size="6679" author="kmarsden" created="Thu, 11 Dec 2008 21:08:41 +0000"/>
                            <attachment id="12395856" name="TryTimeout2.out.10_1.deadlock" size="5529" author="kmarsden" created="Thu, 11 Dec 2008 18:06:59 +0000"/>
                            <attachment id="12395874" name="TryTimeout2.out.10_1.locktimeout" size="19238" author="kmarsden" created="Thu, 11 Dec 2008 21:08:41 +0000"/>
                            <attachment id="12395857" name="TryTimeout2.out.10_1.locktimeout" size="17823" author="kmarsden" created="Thu, 11 Dec 2008 18:06:59 +0000"/>
                            <attachment id="12473564" name="derby-3980-1a.diff" size="16942" author="knutanders" created="Mon, 14 Mar 2011 14:04:31 +0000"/>
                            <attachment id="12395956" name="derby-3980_javadoc_and_test_diff.txt" size="8582" author="kmarsden" created="Fri, 12 Dec 2008 18:13:20 +0000"/>
                            <attachment id="12395610" name="derby.log" size="18988" author="kmarsden" created="Tue, 9 Dec 2008 01:01:01 +0000"/>
                            <attachment id="12395665" name="derby.log.10_1" size="19340" author="kmarsden" created="Tue, 9 Dec 2008 18:33:19 +0000"/>
                            <attachment id="12395666" name="javacore.20081209.092827.9800.txt" size="181184" author="kmarsden" created="Tue, 9 Dec 2008 18:33:19 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>14.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 9 Dec 2008 18:38:12 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23957</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10422"><![CDATA[High Value Fix]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0gxj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>36561</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310050" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Urgency</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10052"><![CDATA[Normal]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>