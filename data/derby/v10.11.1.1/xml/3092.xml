<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:21:30 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-3092/DERBY-3092.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-3092] Use java.util.concurrent in TransactionTable to improve scalability</title>
                <link>https://issues.apache.org/jira/browse/DERBY-3092</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;Running scalability tests with the client and buffer manager from &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2911&quot; title=&quot;Implement a buffer manager using java.util.concurrent classes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2911&quot;&gt;&lt;del&gt;DERBY-2911&lt;/del&gt;&lt;/a&gt; shows that access to the TransactionTable.trans (a Hashtable) and XactFactory.tranId (a shared long) are the next major sources of contention. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12379282">DERBY-3092</key>
            <summary>Use java.util.concurrent in TransactionTable to improve scalability</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knutanders">Knut Anders Hatlen</assignee>
                                    <reporter username="dyret">Dyre Tjeldvoll</reporter>
                        <labels>
                    </labels>
                <created>Fri, 28 Sep 2007 13:58:01 +0100</created>
                <updated>Wed, 3 Sep 2014 09:31:31 +0100</updated>
                            <resolved>Mon, 26 Apr 2010 09:51:51 +0100</resolved>
                                    <version>10.3.1.4</version>
                                    <fixVersion>10.6.1.0</fixVersion>
                                    <component>Store</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12531010" author="dyret" created="Fri, 28 Sep 2007 14:24:30 +0100"  >&lt;p&gt;The test was performed on a SunFire T2000 with 8 cores and 4&lt;br/&gt;
hardware threads per core, using jvm version 1.6.0_02. The client&lt;br/&gt;
was run (in embedded mode) for 300 seconds with a 30 second&lt;br/&gt;
warmup, with 32 clients. The CPU utilization of the jvm process&lt;br/&gt;
was observed with top:&lt;/p&gt;

&lt;p&gt;10.3.1.4:                     &lt;br/&gt;
CPU utilization: 35.3% &lt;br/&gt;
Throughput: 37,512.6 TPS&lt;/p&gt;

&lt;p&gt;With new buffer manager:&lt;br/&gt;
CPU utilization: 82.8%&lt;br/&gt;
Throughput: 132,444 TPS&lt;/p&gt;

&lt;p&gt;With new buffer manager and java.util.concurrent in&lt;br/&gt;
TransactionTable and XactFfactory: &lt;br/&gt;
CPU utilization: 97.4%&lt;br/&gt;
Throughput: 159.720 TPS&lt;/p&gt;</comment>
                            <comment id="12531017" author="dyret" created="Fri, 28 Sep 2007 15:11:45 +0100"  >&lt;p&gt;Attaching a proof of concept patch a showing the changes. I cannot be committed in its present form, however, since it doesn&apos;t compile with java 1.4. Could perhaps be fixed with some reflection magic?&lt;/p&gt;</comment>
                            <comment id="12531063" author="bryanpendleton" created="Fri, 28 Sep 2007 16:56:54 +0100"  >&lt;p&gt;Could you describe the test you are running a little bit? Does &quot;TPS&quot; mean&lt;br/&gt;
Transactions Per Second? Are you really seeing 37 thousand transactions per second?&lt;/p&gt;</comment>
                            <comment id="12531441" author="dyret" created="Mon, 1 Oct 2007 10:05:23 +0100"  >&lt;p&gt;Hi Bryan,&lt;br/&gt;
yes, TPS=Transactions Per Second. The client used is the d2911perf.java client Knut attached to that issue:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12365001/d2911perf.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/secure/attachment/12365001/d2911perf.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Yes, those are the numbers I&apos;m seeing, but the client has been carefully constructed to avoid any &quot;data contention&quot;. That is,&lt;br/&gt;
each client (connection) selects a single record from its own table. So there is no contention for locks or latches. It is admittedly a pretty unrealistic load for a database, but the goal was to identify &quot;non-data-related&quot; contention in the engine. The idea being that if the engine doesn&apos;t scale with this type of load, it isn&apos;t much point in trying to address scalability issues for other types of load...&lt;/p&gt;</comment>
                            <comment id="12532830" author="mikebell90" created="Sat, 6 Oct 2007 06:51:21 +0100"  >&lt;p&gt;backport-java.util.concurrent COULD be used, and provides java.util.ConcurrentHashMap semantics and JDK 1.4 compatibility. &lt;/p&gt;

&lt;p&gt;Dunno if that&apos;s helpful.&lt;/p&gt;</comment>
                            <comment id="12532968" author="dyret" created="Sun, 7 Oct 2007 15:20:48 +0100"  >&lt;p&gt;That could be very helpful! I&apos;ll keep it in mind. &lt;/p&gt;

&lt;p&gt;Unfortunately, it turns out that simply replacing the old Hashtable with ConcurrentHashMap had some undesirable side-effects. They did not show up when running the simple d2911 client, but caused strange hangs with more complicated load. I do believe it is possible to work around that with better locking of the elements in the hash (as opposed to locking the entire hash), but I&apos;ve not had time to try that out yet...&lt;/p&gt;</comment>
                            <comment id="12785039" author="knutanders" created="Wed, 2 Dec 2009 22:49:49 +0000"  >&lt;p&gt;I reran Dyre&apos;s experiment on the same kind of machine, but with a newer JVM (early access release of JDK 7) and head of trunk. I used a slightly different test client that&apos;s available in derbyTesting.jar (java org.apache.derbyTesting.perf.clients.Runner -load sr_select_multi). It still looks like the patch improves the scalability for this kind of load.&lt;/p&gt;

&lt;p&gt;The xact-concept.diff patch actually consists of two independent changes:&lt;/p&gt;

&lt;p&gt;1) The tranId field in XactFactory is changed into an AtomicLong, and the synchronization that protects it is removed. This looks like a safe change (but some extra work is required to make it also work on pre-Java 5).&lt;/p&gt;

&lt;p&gt;2) The Hashtable in TransactionTable is changed into a ConcurrentHashTable. As Dyre noted, this change was not safe the way it appeared in the patch, and some more synchronization is needed (hopefully most of it can be added on the entry level to avoid locking the entire map). Making it work on pre-Java 5 platforms is required for this change too.&lt;/p&gt;

&lt;p&gt;When I ran the experiment, I tried to run with these two changes separately as well as combined. I was not able to detect any changes in the performance with change (1), whereas (2) seemed to give a good improvement. Based on that, I think it&apos;s best to focus on (2) first. Perhaps it would also make sense to split this JIRA issue into two separate issues.&lt;/p&gt;</comment>
                            <comment id="12785046" author="knutanders" created="Wed, 2 Dec 2009 23:03:31 +0000"  >&lt;p&gt;For the record, I&apos;m attaching a graph showing the results from my test run (xact-concept.png).&lt;/p&gt;

&lt;p&gt;I ran the test as&lt;/p&gt;

&lt;p&gt;  java org.apache.derbyTesting.perf.clients.Runner -load sr_select_multi -wt 20 -rt 40 -threads N&lt;/p&gt;

&lt;p&gt;The sr_select_multi client works on a set of 32 tables with a single row in them, with each client thread randomly picking tables to read from. (The large set of tables eliminates the data contention that would have been seen if all threads read from the same table. With a small number of tables, data contention would have been the dominating scalability bottleneck, and the issues in the transaction table would not be observable.)&lt;/p&gt;</comment>
                            <comment id="12790767" author="knutanders" created="Tue, 15 Dec 2009 15:01:48 +0000"  >&lt;p&gt;I&apos;ve filed a separate issue for the XactFactory part of this issue. See &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-4478&quot; title=&quot;Use AtomicLong for XactFactory.tranId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-4478&quot;&gt;&lt;del&gt;DERBY-4478&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12791533" author="knutanders" created="Wed, 16 Dec 2009 19:18:36 +0000"  >&lt;p&gt;I went through the TransactionTable class to get a picture of how the&lt;br/&gt;
synchronization is used there. It synchronizes on two different&lt;br/&gt;
objects: this (the TransactionTable) and trans (the Hashtable within&lt;br/&gt;
the TransactionTable). Many methods don&apos;t use any explicit&lt;br/&gt;
synchronization because they&apos;re guaranteed to be called only during&lt;br/&gt;
recovery, which is single-threaded.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The explicit and implicit synchronization on the Hashtable is&lt;br/&gt;
basically used to prevent removal of elements from the Hashtable&lt;br/&gt;
between calls to Enumeration.hasMoreElements() and&lt;br/&gt;
Enumeration.nextElement(). (In addition to the obvious task of&lt;br/&gt;
protecting the consistency of the Hashtable&apos;s internal data structures&lt;br/&gt;
when modifying it from multiple threads.)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think that ConcurrentHashMap&apos;s iterator gives the necessary&lt;br/&gt;
guarantees for most of these usages without any synchronization.&lt;/p&gt;

&lt;p&gt;One potential problem is the method getTableForXA() which returns the&lt;br/&gt;
internal Hashtable. The caller then synchronizes on the returned&lt;br/&gt;
Hashtable while looping through it. If we are to provide two different&lt;br/&gt;
implementations, one of which not based on Hashtable, we probably need&lt;br/&gt;
to rethink how this is done.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Synchronization on the TransactionTable is used to prevent&lt;br/&gt;
transaction table entries from state transitions between read&lt;br/&gt;
transactions and update transactions. This protection is needed when&lt;br/&gt;
writing the tx table during the checkpoint, since it scans the&lt;br/&gt;
transaction table twice, and the number of update transactions must be&lt;br/&gt;
equal both times. This synchronization probably needs to be preserved&lt;br/&gt;
in some way.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12791571" author="knutanders" created="Wed, 16 Dec 2009 20:38:28 +0000"  >&lt;p&gt;Dyre, do you happen to remember the nature of the tests that hung when you tested the patch?&lt;/p&gt;</comment>
                            <comment id="12799226" author="knutanders" created="Tue, 12 Jan 2010 15:09:51 +0000"  >&lt;p&gt;Dyre told me the test that hung was an appserver benchmark application, but he hadn&apos;t investigated whether the hang was caused by the patch or by something else. I&apos;ll see if I can get the application up and running myself and reproduce the hang.&lt;/p&gt;

&lt;p&gt;I don&apos;t see anything obvious that could cause a hang in the patch. As far as I&apos;ve understood how the synchronization in TransactionTable works, the changes suggested in xact-concept.diff look fine. (Except, of course, that we need to make it work on older Java versions too, and that some for loops are still unnecessarily synchronized on trans.)&lt;/p&gt;</comment>
                            <comment id="12802221" author="knutanders" created="Tue, 19 Jan 2010 12:18:11 +0000"  >&lt;p&gt;A good first step would be to change the declaration of TransactionTable.trans from Hashtable to Map, which is the common interface implemented by both Hashtable and ConcurrentHashMap. Such a change should be harmless, and it will make it easier to get TransactionTable to support different underlying Map implementations (which will be needed in order to work on platforms that don&apos;t support java.util.concurrent).&lt;/p&gt;

&lt;p&gt;The attached patch (derby-3092-1a-map.diff) makes the proposed change. Since the Map interface does not have an elements() method, all calls to that method are replaced with the equivalent iterator() method. Also, a couple of unused variables that I came across are removed by the patch.&lt;/p&gt;

&lt;p&gt;TransactionTable.trans is still a Hashtable. The patch only changes which interface we use to access the Hashtable.&lt;/p&gt;

&lt;p&gt;I&apos;m running regression tests now.&lt;/p&gt;</comment>
                            <comment id="12802317" author="knutanders" created="Tue, 19 Jan 2010 16:24:34 +0000"  >&lt;p&gt;The 1a patch made StressMultiTest fail consistently in sane builds because of ConcurrentModificationExceptions. The reason for this was that some debug code called from getTransactionTable() iterated through the transaction table without synchronizing on the Hashtable while doing that. What changed with the patch, was that an Iterator was used instead of an Enumeration. Hashtable&apos;s Iterators are fail-fast and raise CME as soon as they detect concurrent modification, whereas Hashtable&apos;s Enumerations are not fail-fast (see comment about this in Hashtable&apos;s class-level javadoc).&lt;/p&gt;

&lt;p&gt;Patch 1b moves the failing debug code into the synchronized block that starts right below it so that no concurrent modification of the Hashtable is possible while it&apos;s going through it. This code may have failed before too, but not as consistently as with the fail-fast Iterators, and probably with stack traces so similar to &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-3916&quot; title=&quot;StressMultiTest fails with protocol error due to java.util.NoSuchElementException in org.apache.derby.impl.store.raw.xact.TransactionTable.getTransactionInfo&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-3916&quot;&gt;&lt;del&gt;DERBY-3916&lt;/del&gt;&lt;/a&gt; that they were believed to be the same issue.&lt;/p&gt;

&lt;p&gt;suites.All ran cleanly with 1b. Running derbyall now.&lt;/p&gt;</comment>
                            <comment id="12802336" author="knutanders" created="Tue, 19 Jan 2010 17:05:42 +0000"  >&lt;p&gt;All the regression tests ran cleanly with patch 1b.&lt;/p&gt;</comment>
                            <comment id="12802744" author="knutanders" created="Wed, 20 Jan 2010 08:30:34 +0000"  >&lt;p&gt;Committed 1b with revision 901100.&lt;/p&gt;</comment>
                            <comment id="12802760" author="knutanders" created="Wed, 20 Jan 2010 09:13:57 +0000"  >&lt;p&gt;I was a little too aggressive in trimming down the code in the previous patch. In writeExternal() there used to be an &quot;if (count &amp;gt; 0)&quot; surrounding the second for loop, and it got removed by the 1b patch. This is just a tiny optimization that prevents a second scan of the transaction table if it only contains read-only transactions, so its removal should not cause any harm. But it was not supposed to be removed, so here&apos;s another patch (2a) that adds it back.&lt;/p&gt;</comment>
                            <comment id="12802809" author="knutanders" created="Wed, 20 Jan 2010 12:27:57 +0000"  >&lt;p&gt;Committed revision 901162.&lt;/p&gt;</comment>
                            <comment id="12802840" author="knutanders" created="Wed, 20 Jan 2010 14:10:29 +0000"  >&lt;p&gt;I think the next step is to encapsulate the Hashtable inside the TransactionTable class. Currently, this internal data structure is exposed through the method getTableForXA(). XactXAResourceManager uses this method to get a reference to the Hashtable, and synchronizes on the Hashtable while iterating over it. It will be easier to replace the Hashtable with a ConcurrentHashMap if no other classes depend on it being a Hashtable.&lt;/p&gt;

&lt;p&gt;In the attached patch (derby-3092-3a-xa-visitor.diff) I have removed the getTableForXA() method and instead introduced a visitor that can be used to go through the elements of the transaction table. The patch also makes XactXAResourceManager use the visitor instead of accessing the Hashtable directly.&lt;/p&gt;

&lt;p&gt;I believe that the proposed patch also fixes a bug in XactXAResourceManager.recover(). That method initializes an array with the same size as the transaction table outside the synchronized block. If a new entry is added to the tx table in the window between the call to Hashtable.size() and the start of the synchronized block, an ArrayIndexOutOfBoundsException may be raised while populating the array. With the patch, we no longer use Hashtable.size() to initialize an array, so this situation can&apos;t occur anymore.&lt;/p&gt;

&lt;p&gt;Running regression tests...&lt;/p&gt;</comment>
                            <comment id="12802886" author="knutanders" created="Wed, 20 Jan 2010 16:27:18 +0000"  >&lt;p&gt;Regression tests ran cleanly.&lt;/p&gt;</comment>
                            <comment id="12803231" author="knutanders" created="Thu, 21 Jan 2010 08:48:44 +0000"  >&lt;p&gt;Committed revision 901597.&lt;/p&gt;</comment>
                            <comment id="12803246" author="knutanders" created="Thu, 21 Jan 2010 10:11:24 +0000"  >&lt;p&gt;Now there are only a few places in the code that synchronize explicitly on trans. These are methods doing linear search of the transaction table, primarily during checkpoint and for diagnostics, as well when a global XA transaction is started.&lt;/p&gt;

&lt;p&gt;These are the methods doing linear search with explicit synchronization on trans:&lt;/p&gt;

&lt;p&gt;findTransactionContextByGlobalId&lt;br/&gt;
writeExternal&lt;br/&gt;
getFirstLogInstant&lt;br/&gt;
getTransactionInfo&lt;/p&gt;

&lt;p&gt;In addition you have hasActiveUpdateTransaction() whose comments indicate that synchronization on trans is needed, but it currently only synchronizes on &quot;this&quot;. And in sane builds, toString() is called from within the synchronized block in getTransactionInfo() and performs a linear search.&lt;/p&gt;

&lt;p&gt;If we change the above mentioned methods so that they use visitors instead of iterating through the transaction table themselves, we will have explicit synchronization on trans in just one method - visitEntries(). Having just a single method to override when adding ConcurrentHashMap sounds attractive, so I will attempt to make such a change.&lt;/p&gt;

&lt;p&gt;There are more methods that search the Hashtable linearly, but without synchronization because they are only called during boot/recovery, according to their comments. These methods are:&lt;/p&gt;

&lt;p&gt;hasRollbackFirstTransaction&lt;br/&gt;
hasPreparedXact&lt;br/&gt;
getMostRecentRollbackFirstTransaction&lt;br/&gt;
getMostRecentTransactionForRollback&lt;br/&gt;
getMostRecentPreparedRecoveredXact&lt;/p&gt;

&lt;p&gt;These methods do not need any changes when switching between Hashtable and ConcurrentHashMap, because they are only used when the engine is running single-threaded, and they do not depend on the synchronization properties of Hashtable.&lt;/p&gt;</comment>
                            <comment id="12803717" author="knutanders" created="Fri, 22 Jan 2010 15:04:31 +0000"  >&lt;p&gt;Attaching new patch derby-3092-4a-more-visitors.diff.&lt;/p&gt;

&lt;p&gt;This patch replaces the for loops that use explicit synchronization on trans, with visitors (in addition to the two methods hasActiveUpdateTransaction() and toString() that probably should have used synchronization in the first place). Now, visitEntries() is the only method that explicitly synchronizes on trans.&lt;/p&gt;

&lt;p&gt;I think most of the changes are pretty straightforward, and don&apos;t look too ugly... Some details that might be worth mentioning:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the return type of the visit() method was changed from void to boolean, so that the visitor has a way to stop the scan. This is useful if we&apos;re looking for the first entry to match a certain condition, and we don&apos;t want to continue scanning the transaction table once we&apos;ve found the entry of interest.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for brevity, the visitors don&apos;t check whether entries are null. Most of the for loops did, but since a Hashtable cannot contain null as key or value, those checks are unnecessary and misleading.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;hasActiveUpdateTransaction() and writeExternal() use the same visitor class to count the number of update transactions, with a parameter to tell whether it should stop as soon as it finds one update transaction (for hasActiveUT) or if it should count all update transactions (for writeExternal)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in writeExternal() an ASSERT was added to verify that the number of transactions written to the log is equal to the number of transactions we expected to write (otherwise, the log will most likely be corrupted)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All the regression tests passed with this patch.&lt;/p&gt;</comment>
                            <comment id="12805025" author="knutanders" created="Tue, 26 Jan 2010 13:23:58 +0000"  >&lt;p&gt;Committed 4a with revision 903200.&lt;/p&gt;

&lt;p&gt;Now, the next step is to make TransactionTable use a ConcurrentHashMap if supported by the platform. I think we can define a new interface with two methods&lt;/p&gt;

&lt;p&gt;  Map newMap() - which returns a Hashtable or a ConcurrentHashMap, depending on platform&lt;/p&gt;

&lt;p&gt;  void visitEntries(Map, EntryVisitor) - which performs thread-safe iteration over the Map&lt;/p&gt;

&lt;p&gt;and put some magic into modules.properties to load different implementations on the different platforms.&lt;/p&gt;</comment>
                            <comment id="12805078" author="dagw" created="Tue, 26 Jan 2010 16:30:45 +0000"  >&lt;p&gt;Sounds like a good approach.&lt;/p&gt;</comment>
                            <comment id="12806298" author="knutanders" created="Fri, 29 Jan 2010 10:49:54 +0000"  >&lt;p&gt;Attached is a new patch (derby-3092-5a-dynamic-loading.diff) that implements the dynamic loading of the correct Map implementation for the platform.&lt;/p&gt;

&lt;p&gt;Ideally, I would have just added a couple of helper methods in XactFactory and create a sub-class of XactFactory that overloaded the helper methods in order to use ConcurrentHashMap instead of Hashtable, and then give the parent XactFactory as an argument to TransactionTable&apos;s constructor. This could not be done because TransactionTable is externalizable and it must be possible to read it from a stream during recovery. When being read from a stream, it doesn&apos;t know anything about which XactFactory it belongs to.&lt;/p&gt;

&lt;p&gt;Instead, I made the first instance of XactFactory that&apos;s being created set a static field in XactFactory to point to a TransactionMapFactory object. TransactionMapFactory contains helper methods to create and iterate over a map, and there are two implementations (one for Hashtable and one for ConcurrentHashMap). Then TransactionTable&apos;s constructor can call a static accessor method in XactFactory to get hold of that object, and create a map of the type that gives the highest level of concurrency on that platform.&lt;/p&gt;

&lt;p&gt;I&apos;ve run all the regression tests on Java 1.4.2, Java 1.5.0 and Java 1.6.0 with no failures, and the d2911perf test shows improvements similar to those seen with Dyre&apos;s initial patch.&lt;/p&gt;

&lt;p&gt;I don&apos;t think the patch is ready for commit yet, but I&apos;m posting it here for reference. Now it is possible that multiple threads access fields in the same TransactionTableEntry object concurrently, which was not possible before when all iteration over the values would be protected by synchronization on trans. It might be that some entry-level synchronization will be needed, as Dyre suggested in an earlier comment. I&apos;ll do some more investigation on whether the mutable state of TransactionTableEntry is still protected, or if we have to add another level of synchronization. I&apos;m optimistic, though, that even if we have to add synchronization on the entry level, it should not affect the performance gain seen in the earlier patches very much, since those monitors will not be nearly as contended as the one on the Hashtable.&lt;/p&gt;</comment>
                            <comment id="12830073" author="knutanders" created="Fri, 5 Feb 2010 12:02:08 +0000"  >&lt;p&gt;As far as I can see, none of the code that currently synchronizes on the Hashtable modifies any shared state outside of the Hashtable itself, so the only purpose of this synchronization appears to be to make the Hashtable operations atomic. This is also ensured by ConcurrentHashMap, so I&apos;ve come to the conclusion that we don&apos;t need to add any new synchronization level when we remove &quot;synchronized (trans)&quot; around the for loops. Setting the Patch Available flag to record that I think the patch is ready for review.&lt;/p&gt;

&lt;p&gt;I will need to run more tests in order to fully convince myself that the changes are fine. Should we however commit the patch earlier in order to get as much testing as possible? If it&apos;s getting closer to the release date and we feel that we don&apos;t yet have the required level of confidence in the new code, it could easily be disabled by commenting out a couple of lines in modules.properties and we would fall back to the old, well-tested code on all platforms.&lt;/p&gt;</comment>
                            <comment id="12831910" author="knutanders" created="Wed, 10 Feb 2010 08:50:54 +0000"  >&lt;p&gt;If there are no objections, I will commit the 5a patch tomorrow. As mentioned in the previous comment, if it&apos;s getting closer to the release and we don&apos;t have enough confidence in the new code, it can be disabled by commenting out four lines in modules.properties.&lt;/p&gt;</comment>
                            <comment id="12831916" author="kristwaa" created="Wed, 10 Feb 2010 09:25:36 +0000"  >&lt;p&gt;I had a look at patch 5a, it looks solid. I also applied it and built Derby.&lt;br/&gt;
+1 to commit.&lt;/p&gt;</comment>
                            <comment id="12831970" author="knutanders" created="Wed, 10 Feb 2010 12:45:58 +0000"  >&lt;p&gt;Thanks for looking at the patch, Kristian!&lt;br/&gt;
Committed revision 908473.&lt;/p&gt;

&lt;p&gt;I&apos;ll leave the issue open until I&apos;ve had a chance to run the test where Dyre saw some unexplained behaviour with the concept patch.&lt;/p&gt;</comment>
                            <comment id="12860843" author="kristwaa" created="Mon, 26 Apr 2010 08:49:07 +0100"  >&lt;p&gt;I have been running the test where Dyre had some issues with the concept patch, but I have not observed any problems with the current patch committed to the code line (I ran with revision 935400, insane build).&lt;/p&gt;</comment>
                            <comment id="12860872" author="knutanders" created="Mon, 26 Apr 2010 09:51:51 +0100"  >&lt;p&gt;Thank you very much for running these tests, Kristian! No other problems related to this fix have been seen after the commit, as far as I&apos;m aware, so I&apos;m resolving the issue.&lt;/p&gt;</comment>
                            <comment id="14119586" author="knutanders" created="Wed, 3 Sep 2014 09:31:31 +0100"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;bulk update&amp;#93;&lt;/span&gt; Close all resolved issues that haven&apos;t been updated for more than one year.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12325504">DERBY-698</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12445915">DERBY-4517</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12373154">DERBY-2911</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12443394">DERBY-4478</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12445297">DERBY-4512</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12650317">DERBY-6242</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12430737" name="derby-3092-1a-map.diff" size="10943" author="knutanders" created="Tue, 19 Jan 2010 12:18:11 +0000"/>
                            <attachment id="12430753" name="derby-3092-1b-map.diff" size="11529" author="knutanders" created="Tue, 19 Jan 2010 16:24:34 +0000"/>
                            <attachment id="12430862" name="derby-3092-2a-count.diff" size="1021" author="knutanders" created="Wed, 20 Jan 2010 09:13:57 +0000"/>
                            <attachment id="12430886" name="derby-3092-3a-xa-visitor.diff" size="5451" author="knutanders" created="Wed, 20 Jan 2010 14:10:29 +0000"/>
                            <attachment id="12431115" name="derby-3092-4a-more-visitors.diff" size="16204" author="knutanders" created="Fri, 22 Jan 2010 15:04:31 +0000"/>
                            <attachment id="12431762" name="derby-3092-5a-dynamic-loading.diff" size="16647" author="knutanders" created="Fri, 29 Jan 2010 10:49:54 +0000"/>
                            <attachment id="12431761" name="derby-3092-5a-dynamic-loading.stat" size="529" author="knutanders" created="Fri, 29 Jan 2010 10:49:53 +0000"/>
                            <attachment id="12366745" name="xact-concept.diff" size="6698" author="dyret" created="Fri, 28 Sep 2007 15:11:45 +0100"/>
                            <attachment id="12426711" name="xact-concept.png" size="7474" author="knutanders" created="Wed, 2 Dec 2009 23:03:31 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310200" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Bug behavior facts</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10362"><![CDATA[Performance]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 28 Sep 2007 15:56:54 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30723</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0qrz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38156</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>