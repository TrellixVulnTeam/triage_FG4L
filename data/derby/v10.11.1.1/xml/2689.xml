<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:16:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2689/DERBY-2689.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2689] Deadlock with GenericPreparedStatement</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2689</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;We encountered two times a deadlock inside of derby. It seems that we can&apos;t workaround it. The involved two threads are attached, it looks like a classical deadlock:&lt;/p&gt;

&lt;p&gt;&quot;Thread-22&quot; daemon prio=6 tid=0x0cdaa400 nid=0x1c0 waiting for monitor entry &lt;span class=&quot;error&quot;&gt;&amp;#91;0x1317f000..0x1317fd4c&amp;#93;&lt;/span&gt;&lt;br/&gt;
   java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.finish(Unknown Source)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting to lock &amp;lt;0x052f4d70&amp;gt; (a org.apache.derby.impl.sql.GenericPreparedStatement)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BaseActivation.close(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.addActivation(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BaseActivation.initFromContext(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.LoadedGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.ReflectGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.getActivation(Unknown Source)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x05306f88&amp;gt; (a org.apache.derby.impl.sql.GenericPreparedStatement)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x047beb00&amp;gt; (a org.apache.derby.impl.jdbc.EmbedConnection40)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;custom methods&amp;#93;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&quot;ThreadPoolThread-SyncScheduler-3-1&quot; prio=2 tid=0x0e620400 nid=0xfec waiting for monitor entry &lt;span class=&quot;error&quot;&gt;&amp;#91;0x10a7e000..0x10a7fa14&amp;#93;&lt;/span&gt;&lt;br/&gt;
   java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.finish(Unknown Source)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;waiting to lock &amp;lt;0x05306f88&amp;gt; (a org.apache.derby.impl.sql.GenericPreparedStatement)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BaseActivation.close(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.addActivation(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.BaseActivation.initFromContext(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.LoadedGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.services.reflect.ReflectGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.getActivation(Unknown Source)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x052f4d70&amp;gt; (a org.apache.derby.impl.sql.GenericPreparedStatement)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
	at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;/li&gt;
	&lt;li&gt;locked &amp;lt;0x04225178&amp;gt; (a org.apache.derby.impl.jdbc.EmbedConnection40)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;br/&gt;
        &lt;span class=&quot;error&quot;&gt;&amp;#91;custom methods&amp;#93;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment>Windows</environment>
        <key id="12370141">DERBY-2689</key>
            <summary>Deadlock with GenericPreparedStatement</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mkhettry">Manish Khettry</assignee>
                                    <reporter username="mewert">Marc Ewert</reporter>
                        <labels>
                    </labels>
                <created>Thu, 24 May 2007 14:11:30 +0100</created>
                <updated>Fri, 21 Jan 2011 17:50:14 +0000</updated>
                            <resolved>Wed, 4 Jul 2007 12:08:20 +0100</resolved>
                                    <version>10.2.2.0</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>JDBC</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12500486" author="djd" created="Thu, 31 May 2007 21:56:24 +0100"  >&lt;p&gt;I assume the affects version was meant to be 10.2.2.0. Since it is unassigned then fixin should be unknown.&lt;/p&gt;</comment>
                            <comment id="12501707" author="jn" created="Tue, 5 Jun 2007 22:50:12 +0100"  >&lt;p&gt;We are experiencing deadlock at the same location.  This is with Derby 10.2.2.0.  The following output comes from jconsole (what a cool tool).  Two threads called Connection.getPreparedStatement(String) simultaneously, each from a different Connection instance.  I doubt the actual sql matters, but here were the strings:  &quot;select id from node where fk_parent_id = ? and name = ?&quot;, &quot;select id from band where fk_node_id = ? and name = ? and type = ?&quot;.&lt;/p&gt;

&lt;p&gt; Name: Thread-8&lt;br/&gt;
 State: BLOCKED on org.apache.derby.impl.sql.GenericPreparedStatement@18f5630 owned by: Thread-20&lt;br/&gt;
 Total blocked: 48  Total waited: 122&lt;/p&gt;

&lt;p&gt; Stack trace: &lt;br/&gt;
 org.apache.derby.impl.sql.GenericPreparedStatement.finish(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.sql.execute.BaseActivation.close(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.addActivation(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.sql.execute.BaseActivation.initFromContext(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.services.reflect.LoadedGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.services.reflect.ReflectGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.sql.GenericPreparedStatement.getActivation(Unknown Source)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;locked org.apache.derby.impl.sql.GenericPreparedStatement@16570ed&lt;br/&gt;
 org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
 org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
 org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;/li&gt;
	&lt;li&gt;locked org.apache.derby.impl.jdbc.EmbedConnection40@1b0d41&lt;br/&gt;
 org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;trace of custom code removed&amp;#93;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-----------------------------&lt;/p&gt;

&lt;p&gt;Name: Thread-20&lt;br/&gt;
State: BLOCKED on org.apache.derby.impl.sql.GenericPreparedStatement@16570ed owned by: Thread-8&lt;br/&gt;
Total blocked: 5  Total waited: 112&lt;/p&gt;

&lt;p&gt;Stack trace: &lt;br/&gt;
org.apache.derby.impl.sql.GenericPreparedStatement.finish(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.sql.execute.BaseActivation.close(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.addActivation(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.sql.execute.BaseActivation.initFromContext(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.services.reflect.LoadedGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.services.reflect.ReflectGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.sql.GenericPreparedStatement.getActivation(Unknown Source)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;locked org.apache.derby.impl.sql.GenericPreparedStatement@18f5630&lt;br/&gt;
org.apache.derby.impl.jdbc.EmbedPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.jdbc.EmbedPreparedStatement20.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.jdbc.EmbedPreparedStatement30.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.jdbc.EmbedPreparedStatement40.&amp;lt;init&amp;gt;(Unknown Source)&lt;br/&gt;
org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Unknown Source)&lt;br/&gt;
org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;/li&gt;
	&lt;li&gt;locked org.apache.derby.impl.jdbc.EmbedConnection40@2f599d&lt;br/&gt;
org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;trace of custom code removed&amp;#93;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12501734" author="bryanpendleton" created="Wed, 6 Jun 2007 00:02:02 +0100"  >&lt;p&gt;I see that the code in GenericLanguageConnectionContext.addActivation which calls BaseActivation.close was added as part of the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; changes. Studying &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; might lead to some insight about why there is a deadlock here and what conditions are triggering it.&lt;/p&gt;

&lt;p&gt;In particular, since the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; code is attempting to have Derby automatically clean up resources which have accumulated, I wonder if a workaround for this problem could be to change the application to be more aggressive about cleaning up resources. For example, check the application to ensure that ResultSets, Statements, and other JDBC resources are being tracked and closed when they are done?&lt;/p&gt;</comment>
                            <comment id="12501766" author="mkhettry" created="Wed, 6 Jun 2007 02:46:41 +0100"  >&lt;p&gt;The interesting thing in Jim&apos;s stack trace, if I am reading this right,  is that thread-20 seems to be calling finish on a prepared statement (GPS@16570ed) which thread-8 is initializing and vice versa. Why do we think this GenericPreparedStatements can be finished off before its seen the light of day?&lt;/p&gt;
</comment>
                            <comment id="12501770" author="jn" created="Wed, 6 Jun 2007 03:23:40 +0100"  >&lt;p&gt;The attached test case deadlocks pretty quickly for me.&lt;/p&gt;</comment>
                            <comment id="12501777" author="bryanpendleton" created="Wed, 6 Jun 2007 03:42:51 +0100"  >&lt;p&gt;Thanks Jim for the repro! &lt;/p&gt;

&lt;p&gt;The test program reproduces a deadlock for me with the current head of trunk.&lt;/p&gt;

&lt;p&gt;A note for others: the test program requires JDK 1.5.&lt;/p&gt;</comment>
                            <comment id="12501786" author="bryanpendleton" created="Wed, 6 Jun 2007 05:09:17 +0100"  >&lt;p&gt;Hi Manish, that is a great point.  I think that calling finish() on a PreparedStatement&lt;br/&gt;
doesn&apos;t mean that the entire statement is finished off, just that this particular&lt;br/&gt;
activation is finished off. The activations seem to maintain an &quot;inUseCount&quot;&lt;br/&gt;
reference count on the statement, and calling finish() for a particular activation&lt;br/&gt;
just decrements the reference count, and only reclaims the entire statement if&lt;br/&gt;
the inUseCount has gone to 0.&lt;/p&gt;

&lt;p&gt;In the case I looked at in the debugger, however, the inUseCount is nowhere close&lt;br/&gt;
to 0; it is in fact 60. So the statement is not finished, just this particular activation.&lt;/p&gt;

&lt;p&gt;It seems that closing an activation requires that we synchronize on the statement&lt;br/&gt;
in order to decrement the inUseCount, so this means that as part of initializing&lt;br/&gt;
a new activation for one statement, we may decide to close an activation for&lt;br/&gt;
some other statement, and since there is no inherent ordering to these reclaimable&lt;br/&gt;
activations, we have the situation that one thread which is trying to initialize an&lt;br/&gt;
activation for statement A is trying to close an activation for statement B, while another&lt;br/&gt;
thread which is trying to initialize an activation for statement B is trying to close&lt;br/&gt;
an activation for statement A.&lt;/p&gt;

&lt;p&gt;I agree with the assessment that this is a classical deadlock due to a lack of&lt;br/&gt;
lock ordering for the synchronization on the various statement objects.&lt;/p&gt;

&lt;p&gt;I can see several possibilities:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;don&apos;t try to reclaim activations from inside of addActivation (that is, revert that&lt;br/&gt;
   part of the &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; change). This would of course re-introduce that memory leak.&lt;/li&gt;
	&lt;li&gt;Move the code which reclaims activations to some other location, where it is&lt;br/&gt;
   safer to call, because we aren&apos;t calling it while holding any statements locked.&lt;/li&gt;
	&lt;li&gt;Change the code which reclaims activations so that it only closes those&lt;br/&gt;
   activations which are for the statement that we already have locked, and not&lt;br/&gt;
   for any other statements. This might render this code much less effective.&lt;/li&gt;
	&lt;li&gt;Introduce some sort of ordering of statement objects, and only reclaim&lt;br/&gt;
   activations for statements which have a higher ordering than ourselves. Since&lt;br/&gt;
   the statement locks would then be ordered, the code would not deadlock.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m sure there are a number of other ways to look at this, I just wanted to add my thoughts.&lt;/p&gt;</comment>
                            <comment id="12501963" author="knutanders" created="Wed, 6 Jun 2007 16:39:23 +0100"  >&lt;p&gt;I think there is a workaround for this issue. If the application always closes all of its result sets and statements before they are garbage collected, the offending code in GenericLanguageConnectionContext.addActivation() shouldn&apos;t be executed.&lt;/p&gt;</comment>
                            <comment id="12501967" author="knutanders" created="Wed, 6 Jun 2007 17:06:09 +0100"  >&lt;p&gt;I think all the possibilities mentioned by Bryan would work. I think (1) and (3) should be avoided, as they will reintroduce &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt;. (4) should also work, but it sounds like a complex and/or expensive solution to the problem.&lt;/p&gt;

&lt;p&gt;If we go for (3) I would suggest moving the check to the end of GenericPreparedStatement.getActivation() and only make the first part of that method synchronized. We could for instance add a closeUnusedActivations() method to the LanguageConnectionContext interface and call it from getActivation(). This would only lock one statement at a time and solve the deadlock problem.&lt;/p&gt;</comment>
                            <comment id="12501978" author="mikem" created="Wed, 6 Jun 2007 17:43:21 +0100"  >&lt;p&gt;upping the priority to critical.  This deadlock in many applications is equivalent or maybe even worse than a crash.  At least with crash locks and other held resources are released and user can try to log in again - here they are stuck.  While there may be a workaround by insuring all statements are closed, the reality is that many users programs have this problem and a deadlock in the field is going to be hard to diagnose and tie to an unclosed statement.  &lt;/p&gt;

&lt;p&gt;Also working applications may see a regression doing a soft upgrade from 10.0 or  10.1 to 10.2 and releases subsequent to 10.2.   The apps may not  be affected by the memory leak  fixed by &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; but  be noticably affected by java level synchonization deadlocks that never resollve themselves.&lt;/p&gt;</comment>
                            <comment id="12502920" author="mkhettry" created="Fri, 8 Jun 2007 21:26:41 +0100"  >&lt;p&gt;Since nobody has claimed this as yet and its critical, I can take a look. Hopefully I&apos;ll have an update early next week. &lt;/p&gt;</comment>
                            <comment id="12503705" author="mkhettry" created="Tue, 12 Jun 2007 03:28:36 +0100"  >&lt;p&gt;Thought I&apos;d update the bug with what I&apos;m trying right now--I think option 2 outlined in Brian&apos;s earlier comment is the cleanest in this case. I have moved the cleanup activation code to the constructor for EmbedConnection after the call to getActivation around line ~140 or so.&lt;/p&gt;

&lt;p&gt;			try {&lt;br/&gt;
			    preparedStatement = lcc.prepareInternalStatement&lt;br/&gt;
				(lcc.getDefaultSchema(), sql, resultSetConcurrency==JDBC20Translation.CONCUR_READ_ONLY, forMetaData);&lt;/p&gt;

&lt;p&gt;			    addWarning(preparedStatement.getCompileTimeWarnings());&lt;/p&gt;

&lt;p&gt;			    activation = preparedStatement.getActivation(lcc, resultSetType == JDBC20Translation.TYPE_SCROLL_INSENSITIVE);&lt;/p&gt;

&lt;p&gt;				// &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2689&quot; title=&quot;Deadlock with GenericPreparedStatement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2689&quot;&gt;&lt;del&gt;DERBY-2689&lt;/del&gt;&lt;/a&gt;. Close unused activations here when I&apos;m not inside a monitor.&lt;br/&gt;
				lcc.closeUnusedActivations();&lt;/p&gt;

&lt;p&gt;I&apos;ve been running the test case for both this bug and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt; to make sure that we have no deadlocks and no memory leaks.&lt;/p&gt;</comment>
                            <comment id="12507970" author="mkhettry" created="Mon, 25 Jun 2007 20:57:44 +0100"  >&lt;p&gt;I have moved the logic that closes unused activations. Earlier this was done when a activation was initialized and added to a lcc.&lt;/p&gt;

&lt;p&gt;at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.addActivation(Unknown Source)&lt;br/&gt;
at org.apache.derby.impl.sql.execute.BaseActivation.initFromContext(Unknown Source)&lt;br/&gt;
at org.apache.derby.impl.services.reflect.LoadedGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
at org.apache.derby.impl.services.reflect.ReflectGeneratedClass.newInstance(Unknown Source)&lt;br/&gt;
at org.apache.derby.impl.sql.GenericActivationHolder.&amp;lt;init&amp;gt;(Unknown Source) &lt;/p&gt;

&lt;p&gt;Now it is done by the caller (outside a synchronized block) whenever a statement is prepared or executed in GenericPreparedStatement:getActivation.&lt;/p&gt;

&lt;p&gt;For testing, I ran the reproduction attached with this bug. Without the bugfix it would deadlock within a few minutes. I let it run all morning and all the threads were making progress before I stopped the threads around noon. I also ran the reproduction with &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt;. Without the cleanup code being invoked, the test would run out of memory after about 230K iterations (with 20m heap size). With the bugfix I let it run to about 1m iterations before stopping the process. Also derbylang.&lt;/p&gt;

&lt;p&gt;The patch was made against trunk. &lt;/p&gt;</comment>
                            <comment id="12508180" author="knutanders" created="Tue, 26 Jun 2007 14:57:14 +0100"  >&lt;p&gt;Hi Manish,&lt;/p&gt;

&lt;p&gt;Thank you for working on this issue. I looked at the patch and I have a couple of questions/comments:&lt;/p&gt;

&lt;p&gt;1) Since GenericLanguageConnectionContext.acts now is an unsynchronized ArrayList and not a Vector, is it safe to access/modify it outside the synchronized block?&lt;/p&gt;

&lt;p&gt;2) I noticed that you moved &quot;unusedActs = false;&quot; below the loop. I believe that the assignment was placed above the loop deliberately (see Dan&apos;s comment 25/Aug/06 on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;3) There are some lines &amp;gt;80 characters.&lt;/p&gt;

&lt;p&gt;4) Most of the changes in GenericLanguageConnectionContext are pure whitespace changes (adding or removal of trailing blanks). Also, some extra garbage has ended up in the comments, like &quot;// size exceeds 20.SelectNod3&quot; and &quot;(...) true &lt;b&gt;if*z *all&lt;/b&gt; (...)&quot;&lt;/p&gt;

&lt;p&gt;5) &lt;b&gt;Tiny&lt;/b&gt; nit: In GenericPreparedStatement.getActivation(), ac is initialized to null. Since this initial value is not intended to be used, I think it is better to leave the variable uninitialized. The compiler will complain if one tries to use an uninitialized variable, so by setting it to null we actually remove some compile-time error checking.&lt;/p&gt;</comment>
                            <comment id="12508340" author="mkhettry" created="Tue, 26 Jun 2007 22:38:15 +0100"  >&lt;p&gt;Thanks for looking at the patch. &lt;/p&gt;

&lt;p&gt;As far as 2 goes-- if we set &quot;unusedActs&quot; to false at the beginning of the loop and while trying to close all activations, get an exception won&apos;t we end up with the case where unusedActs = false, yet there are unused activations which the loop did not get to?&lt;/p&gt;

&lt;p&gt;For 1, there seems to be no synchronization at all in this class. It is my understanding that a LangugageConnectionContext is scoped within a connection and only one thread may be using a lcc at a given time. Is that correct? The only case seems to be the finalize method of ResultSet which can end up marking &quot;unsedActs&quot;.&lt;/p&gt;

&lt;p&gt;On the same note, I&apos;m not sure I understand why we have to do the following:&lt;/p&gt;

&lt;p&gt;for (int i = acts.size() - 1; i &amp;gt;= 0; i--) {&lt;/p&gt;

&lt;p&gt;			// it maybe the case that a reset() ends up closing&lt;br/&gt;
			// one or more activation leaving our index beyond&lt;br/&gt;
			// the end of the array&lt;br/&gt;
			if (i &amp;gt;= acts.size())&lt;br/&gt;
				continue;&lt;/p&gt;

&lt;p&gt;Can the acts arraylist  bemodified by multiple threads? Also why don&apos;t all other routines employ this extra check? Look for example at lookupCursorActivation, checkIfAnyActivationHasHoldCursor, verifyAllHeldResultSetsAreClosed among others.&lt;/p&gt;

&lt;p&gt;Also, yes there seem to be some wierd characters which have crept up in the comments. I&apos;ll take them out of the next patch.&lt;/p&gt;
</comment>
                            <comment id="12508349" author="knutanders" created="Tue, 26 Jun 2007 23:11:51 +0100"  >&lt;p&gt;&amp;gt; For 1, there seems to be no synchronization at all in this class.&lt;/p&gt;

&lt;p&gt;Yes, you&apos;re absolutely right. For some reason I kept thinking that it was shared between threads, but lcc is not.&lt;/p&gt;

&lt;p&gt;&amp;gt; As far as 2 goes-- if we set &quot;unusedActs&quot; to false at the beginning of the loop and while trying to close all activations, get an exception won&apos;t we end up with the case where unusedActs = false, yet there are unused activations which the loop did not get to?&lt;/p&gt;

&lt;p&gt;I think you are right. We risk ending up with an incorrect value no matter where we put the assignment. Since it&apos;s really just a hint as to when it could be worthwhile to do the cleanup, I don&apos;t think it really matters. If we are leaking activations, the cleanup code will be triggered sooner or later, but there might be more than 20 activations (which is a low number anyway).&lt;/p&gt;

&lt;p&gt;&amp;gt; On the same note, I&apos;m not sure I understand why we have to do the following:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; for (int i = acts.size() - 1; i &amp;gt;= 0; i--) {&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; // it maybe the case that a reset() ends up closing&lt;br/&gt;
&amp;gt; // one or more activation leaving our index beyond&lt;br/&gt;
&amp;gt; // the end of the array&lt;br/&gt;
&amp;gt; if (i &amp;gt;= acts.size())&lt;br/&gt;
&amp;gt; continue;&lt;/p&gt;

&lt;p&gt;BaseActivation.close(), which is called further down in the method, calls lcc.removeActivation() which removes only one activation and should therefore not cause any problems. I assume that the reset() method mentioned in the comment is BaseActivation.reset(), but I can&apos;t see that it will close any activations, so I believe you are right on this too. Perhaps the comment refers to some old code?&lt;/p&gt;</comment>
                            <comment id="12508388" author="mkhettry" created="Wed, 27 Jun 2007 04:04:21 +0100"  >&lt;p&gt;re: walking the acts list, Dan in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-418&quot; title=&quot;outofmemory error when running large query in autocommit=false mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-418&quot;&gt;&lt;del&gt;DERBY-418&lt;/del&gt;&lt;/a&gt;, suggested that we recheck if the index is within bounds. &lt;a href=&quot;http://issues.apache.org/jira/browse/DERBY-418#action_12430512&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/DERBY-418#action_12430512&lt;/a&gt;. I can&apos;t seem to see why this would be necessary-- Dan, am I missing something? If this is the case, then all the routines that walk acts can be cleaned up, I think.&lt;/p&gt;</comment>
                            <comment id="12508469" author="knutanders" created="Wed, 27 Jun 2007 08:58:37 +0100"  >&lt;p&gt;If we decide to do the cleanup, I think it should be done in a separate patch (and perhaps a separate JIRA). Since the fix for this issue is likely to go into 10.3, it would be best if we kept the fix as small as possible to reduce the risk of introducing regressions.&lt;/p&gt;</comment>
                            <comment id="12508610" author="mkhettry" created="Wed, 27 Jun 2007 19:18:23 +0100"  >&lt;p&gt;agreed-- let me get another patch and then we can think about cleanup.&lt;/p&gt;</comment>
                            <comment id="12508615" author="djd" created="Wed, 27 Jun 2007 19:26:56 +0100"  >&lt;p&gt;&amp;gt;&amp;gt; On the same note, I&apos;m not sure I understand why we have to do the following:&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; for (int i = acts.size() - 1; i &amp;gt;= 0; i--) {&lt;br/&gt;
&amp;gt;&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; // it maybe the case that a reset() ends up closing&lt;br/&gt;
&amp;gt;&amp;gt; // one or more activation leaving our index beyond&lt;br/&gt;
&amp;gt;&amp;gt; // the end of the array&lt;br/&gt;
&amp;gt;&amp;gt; if (i &amp;gt;= acts.size())&lt;br/&gt;
&amp;gt;&amp;gt; continue;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; BaseActivation.close(), which is called further down in the method, calls lcc.removeActivation() which removes only one activation and should therefore not cause any problems.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure that is correct, that a close on an activation only closes one other activation. Activations can have a relationship to each other, the main case is  a positioned update/delete on a cursor. Closing the cursor may close the positioned statement. Maybe the code has changed such that isn&apos;t true, but I wanted to throw it out there as an example. The current code is safe for that situation, so if it is to be changed then that assumption (one close) must be well documented in the code.&lt;/p&gt;</comment>
                            <comment id="12509479" author="mkhettry" created="Mon, 2 Jul 2007 04:24:41 +0100"  >&lt;p&gt;Revised patch. I cleaned up some of the spurious characters in the comments, moved setting of unusedActs=false to the top of the loop and reduced some whitespace diffs.&lt;/p&gt;</comment>
                            <comment id="12509496" author="knutanders" created="Mon, 2 Jul 2007 07:45:32 +0100"  >&lt;p&gt;In addition to setting unusedActs=false on the top of the loop, the patch also sets it on the top of the method. Doesn&apos;t this make closeUnusedActivations() a no-op? (Since the body of the method is wrapped in an &quot;if (unusedActs &amp;amp;&amp;amp; ...)&quot;.)&lt;/p&gt;</comment>
                            <comment id="12509745" author="mkhettry" created="Tue, 3 Jul 2007 05:29:55 +0100"  >&lt;p&gt;fyi-- I attached another patch.&lt;/p&gt;
</comment>
                            <comment id="12509752" author="knutanders" created="Tue, 3 Jul 2007 06:57:05 +0100"  >&lt;p&gt;Thanks! Seems like you forgot to grant licence to the ASF. Could you please reattach it with grant licence checked.&lt;/p&gt;</comment>
                            <comment id="12509955" author="mkhettry" created="Tue, 3 Jul 2007 18:45:27 +0100"  >&lt;p&gt;another one with license granted. I&apos;ve already signed an ICLA-- do I still need to do this on a per-attachment basis?!&lt;/p&gt;</comment>
                            <comment id="12510102" author="knutanders" created="Wed, 4 Jul 2007 08:36:21 +0100"  >&lt;p&gt;Thanks! Committed revision 553101. I will also merge the changes into the 10.3 branch.&lt;/p&gt;</comment>
                            <comment id="12510144" author="knutanders" created="Wed, 4 Jul 2007 12:08:20 +0100"  >&lt;p&gt;Committed to 10.3 with revision 553171.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12311840">DERBY-418</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12359016" name="TestDerbyPreparedStatements.java" size="2536" author="jn" created="Wed, 6 Jun 2007 03:23:40 +0100"/>
                            <attachment id="12360514" name="deadlock.patch.txt" size="3502" author="mkhettry" created="Mon, 25 Jun 2007 20:57:44 +0100"/>
                            <attachment id="12360902" name="deadlock2.patch.txt" size="2997" author="mkhettry" created="Mon, 2 Jul 2007 04:24:41 +0100"/>
                            <attachment id="12361070" name="deadlock3.patch.txt" size="3087" author="mkhettry" created="Tue, 3 Jul 2007 18:45:27 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 31 May 2007 20:56:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23182</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0mcv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>37440</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>