<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:14:21 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-1816/DERBY-1816.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-1816] Client&apos;s ResultSet.getTime() on a SQL TIMESTAMP column loses the sub-second resolution and always has a milli-second value of zero.</title>
                <link>https://issues.apache.org/jira/browse/DERBY-1816</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;In embedded the java.sql.Time object returned from ResultSet.getTime() for a SQL TIMESTAMP object has its millisecond value for the time portion equal to that for the java.sql.Timestamp value.&lt;br/&gt;
In client the millisecond time value for such a value is always set to zero.&lt;/p&gt;

&lt;p&gt;Note a Derby SQL TIME value has by definition resolution of only a second so its millisecond  value is always zero,&lt;br/&gt;
but java.sql.Time  is not a direct mapping to the SQL Type, it&apos;s a JDBC type, so when converting from a SQL TIMESTAMP&lt;br/&gt;
it should retain the precision.&lt;/p&gt;

&lt;p&gt;The new test lang.TimeHandlingTest has this assert code that shows the problem, one of its calls will be commented out&lt;br/&gt;
with a comment with this bug number.&lt;/p&gt;

&lt;p&gt;    private void assertTimeEqual(Time tv, Timestamp tsv)&lt;/p&gt;
    {
        cal.clear();
        cal.setTime(tv);
                
        int hour = cal.get(Calendar.HOUR_OF_DAY);
        int min = cal.get(Calendar.MINUTE);
        int sec = cal.get(Calendar.SECOND);
        int ms = cal.get(Calendar.MILLISECOND);
                        
        // Check the time portion is set to the same as tv
        cal.clear();
        cal.setTime(tsv);
        assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));
        assertEquals(min, cal.get(Calendar.MINUTE));
        assertEquals(sec, cal.get(Calendar.SECOND));
        assertEquals(ms, cal.get(Calendar.MILLISECOND));      &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; FAILS HERE
    }</description>
                <environment></environment>
        <key id="12349305">DERBY-1816</key>
            <summary>Client&apos;s ResultSet.getTime() on a SQL TIMESTAMP column loses the sub-second resolution and always has a milli-second value of zero.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="army">A B</assignee>
                                    <reporter username="djd">Daniel John Debrunner</reporter>
                        <labels>
                    </labels>
                <created>Wed, 6 Sep 2006 14:31:08 +0100</created>
                <updated>Tue, 30 Jun 2009 17:12:53 +0100</updated>
                            <resolved>Wed, 20 Jun 2007 02:36:15 +0100</resolved>
                                    <version>10.1.1.0</version>
                    <version>10.1.2.1</version>
                    <version>10.1.3.1</version>
                    <version>10.2.1.6</version>
                    <version>10.3.1.4</version>
                                    <fixVersion>10.3.1.4</fixVersion>
                                    <component>JDBC</component>
                    <component>Network Client</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12432842" author="djd" created="Wed, 6 Sep 2006 14:32:52 +0100"  >&lt;p&gt;Another client time handling problem.&lt;/p&gt;</comment>
                            <comment id="12432843" author="djd" created="Wed, 6 Sep 2006 14:34:14 +0100"  >&lt;p&gt;Another issue with time handling in client.&lt;/p&gt;</comment>
                            <comment id="12493798" author="army" created="Fri, 4 May 2007 21:56:38 +0100"  >&lt;p&gt;While looking into this issue I noticed that there are several methods in client/am/DateTime.java which do the following two things:&lt;/p&gt;

&lt;p&gt;  1) Take a &quot;recyclable&quot; Time, Timestamp, or Date object with the apparent&lt;br/&gt;
     intent of avoiding repeated creation of corresponding java.sql.* objects.&lt;/p&gt;

&lt;p&gt;  2) Make use of &quot;setXXX&quot; methods that have been deprecated as of JDK 1.1.&lt;/p&gt;

&lt;p&gt;As an example, see client/am/DateTime.timeBytesToTime(...).&lt;/p&gt;

&lt;p&gt;That said, it looks like the &quot;recyclable&quot; objects are always null which makes the #1 code pretty meaningless (this is confirmed by the fact that the code coverage results show the relevant code is never executed).&lt;/p&gt;

&lt;p&gt;I believe I have a fix for this Jira (&lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-1816&quot; title=&quot;Client&amp;#39;s ResultSet.getTime() on a SQL TIMESTAMP column loses the sub-second resolution and always has a milli-second value of zero.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-1816&quot;&gt;&lt;del&gt;DERBY-1816&lt;/del&gt;&lt;/a&gt;), but before working more with it I&apos;m posting d1816_recycleCleanup_v1.patch, which is a pre-patch that does the following:&lt;/p&gt;

&lt;p&gt;  1) Replaces each of the recyclable Date, Time, and Timestamp arguments with&lt;br/&gt;
     a recyclable java.util.Calendar object.&lt;/p&gt;

&lt;p&gt;  2) Modifies the relevant code to call methods on the recyclable Calendar object&lt;br/&gt;
     instead of on Date, Time, and Timestamp objects.  The benefit to doing this&lt;br/&gt;
     is that we are now using non-deprecated methods. &lt;/p&gt;

&lt;p&gt;Note that even with this patch we are still creating a new instance of Time/Timestamp/Date for each method-&lt;del&gt;the cleanup patch does not change that.  Instead, the cleanup patch adds the instantiation of a new Calendar object (one per client/am/Cursor) and then (re&lt;/del&gt;)uses that object to replace the deprecated calls.  The goal here is not just to replace the deprecated calls, though; I think that having a Calendar object will help resolve this particular Jira (and maybe others), as well.&lt;/p&gt;

&lt;p&gt;That said, I was reading through the comments on &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-889&quot; title=&quot;with client getTimestamp on a TIME column will print the date  1900-01-01 instead of the current date&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-889&quot;&gt;&lt;del&gt;DERBY-889&lt;/del&gt;&lt;/a&gt; and one thing I&apos;m unsure about is how/if timezones need to be handled in this code.  When writing the cleanup patch I took a look at the embedded classes and, as far as I can tell, embedded creates a new instance of GregorianCalendar (no timezone info specified) and creates the appropriate date/time object from that (see for example the &quot;newTimestamp()&quot; method in iapi/types/SQLTimestamp, or the &quot;getTimeInMillis()&quot; second in iapi/types/SQLDate).  The changes in d1816_recycleCleanup_v1.patch are intended to mimic that behavior in client.&lt;/p&gt;

&lt;p&gt;But it&apos;s quite possible that I&apos;ve overlooked something, so I would appreciate any reviews/feedback that anyone might have on this &quot;cleanup&quot; patch.&lt;/p&gt;

&lt;p&gt;Note that d1816_recycleCleanup_v1.patch is not intended to change any functionality of the client.  The hope for this patch is to keep all behavior the same (even the behavior that is currently wrong) but to make it easier to fix the incorrect behavior with a subsequent patch.&lt;/p&gt;

&lt;p&gt;I ran suites.All and derbyall on SUSE Linux with ibm142 and there were no failures.&lt;/p&gt;</comment>
                            <comment id="12493804" author="djd" created="Fri, 4 May 2007 22:22:11 +0100"  >&lt;p&gt;The DATE/TIME/TIMESTAMP notes here might help:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://db.apache.org/derby/javadoc/publishedapi/jdbc3/org/apache/derby/jdbc/package-summary.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://db.apache.org/derby/javadoc/publishedapi/jdbc3/org/apache/derby/jdbc/package-summary.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12493807" author="army" created="Fri, 4 May 2007 22:44:00 +0100"  >&lt;p&gt;Thank you for the link, Dan, it&apos;s very helpful.&lt;/p&gt;

&lt;p&gt;Since all of the changes that I&apos;ve made in the clean_v1 patch happen for the getXXX() methods that do not take a Calendar argument, my reading is that  the values should be set &quot;according to the time zone of the java virtual machine&quot;.  My assumption is that this is what happens with the default &quot;new java.util.GregorianCalendar()&quot; constructor, in which case the changes are fine.&lt;/p&gt;

&lt;p&gt;Note that for getXXX() methods which &lt;b&gt;do&lt;/b&gt; take a Calendar object, the client code first calls the version of the method that takes no arguments (which is what the cleanup_v1 patch affects) and then normalizes the result based on the timezone of the received Calendar object.  So I think that part should be working correctly, as well.&lt;/p&gt;

&lt;p&gt;Please let me know if I&apos;ve misread something, though...&lt;/p&gt;

&lt;p&gt;Thanks again for the pointer.&lt;/p&gt;</comment>
                            <comment id="12493824" author="djd" created="Sat, 5 May 2007 00:19:26 +0100"  >&lt;p&gt;&amp;gt; Note that for getXXX() methods which &lt;b&gt;do&lt;/b&gt; take a Calendar object, the client code first calls the version of the method that takes no arguments (which is what the cleanup_v1 patch affects) and then normalizes the result based on the timezone of the received Calendar object.&lt;/p&gt;

&lt;p&gt;any idea why they don&apos;t just use the calendar passed in and just perform the conversion once? I think that&apos;s what embedded does.&lt;br/&gt;
Ie. the no calendar version calls the calendar version with a default calendar.&lt;/p&gt;</comment>
                            <comment id="12494101" author="army" created="Mon, 7 May 2007 19:19:49 +0100"  >&lt;p&gt;&amp;gt; any idea why they don&apos;t just use the calendar passed in and just perform the conversion once?&lt;br/&gt;
&amp;gt; I think that&apos;s what embedded does.&lt;/p&gt;

&lt;p&gt;I looked at the differences between embedded and client and while I&apos;m not sure what the answer to your question is (i.e. why client doesn&apos;t &quot;just use the calendar passed in&quot;) I did notice a difference in behavior that struck me as noteworthy.&lt;/p&gt;

&lt;p&gt;Namely, when a call to a getXXX() date/time method is made and a Calendar object is passed in, embedded will clobber (or at least wipe out) the received Calendar argument&apos;s value.  With the client, though, the argument is preserved (which is more what I would have expected).&lt;/p&gt;

&lt;p&gt;So while I can look into making the client mimic the embedded behavior, I&apos;m not sure that this particular piece of behavior (clobbering the Calendar argument&apos;s value) is correct.&lt;/p&gt;

&lt;p&gt;Ex: If &quot;rs&quot; is a ResultSet whose first column is the TIMESTAMP value &quot;2007-05-03 16:49:52.883&quot; then a call to the &quot;assertGetWithCal()&quot; method below will return something similar to the following:&lt;/p&gt;

&lt;p&gt;On embedded:&lt;/p&gt;

&lt;p&gt; targetBefore -=&amp;gt; 9 10, 2010 &amp;#8211; 10:10:10.205 (GMT-10:00)&lt;br/&gt;
 got cal     -=&amp;gt; 4 3, 2007 &amp;#8211; 19:49:52.883 (America/Los_Angeles)&lt;br/&gt;
 targetAfter -=&amp;gt; 4 3, 2007 &amp;#8211; 16:49:52.0 (GMT-10:00)&lt;/p&gt;

&lt;p&gt;With client:&lt;/p&gt;

&lt;p&gt; targetBefore -=&amp;gt; 9 10, 2010 &amp;#8211; 10:10:10.607 (GMT-10:00)&lt;br/&gt;
 got cal     -=&amp;gt; 4 3, 2007 &amp;#8211; 19:49:52.883 (America/Los_Angeles)&lt;br/&gt;
 targetAfter -=&amp;gt; 9 10, 2010 &amp;#8211; 10:10:10.607 (GMT-10:00)&lt;/p&gt;

&lt;p&gt;Notice how, with embedded, &quot;targetAfter&quot; has the same year, month, day, and time as the result of the &quot;getTimestamp(Calendar)&quot; call, and also that the millisecond value has been wiped out.  But with client, &quot;targetAfter&quot; matches &quot;targetBefore&quot;.  In both cases the correct timezone adjustment takes place.&lt;/p&gt;

&lt;p&gt;My guess is that the embedded behavior is incorrect, but I&apos;m not confident enough to say for sure.&lt;/p&gt;

&lt;p&gt;Any other opinions?&lt;/p&gt;</comment>
                            <comment id="12494102" author="army" created="Mon, 7 May 2007 19:21:44 +0100"  >&lt;p&gt;&quot;assertGetWithCal()&quot; as referenced in previous comment (forgot to paste):&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;    private void assertGetWithCal(ResultSet rs) throws Exception&lt;/p&gt;
    {
        Calendar targetCal = Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;GMT-10:00&quot;));
        targetCal.set(2010, Calendar.OCTOBER, 10, 10, 10, 10);

        System.out.println(&quot; targetBefore -=&amp;gt; &quot; + printCalendar(targetCal));

        Timestamp tsv = rs.getTimestamp(1, targetCal);
        Calendar getCal = Calendar.getInstance();
        getCal.setTime(tsv);

        // System.out.println(&quot; got ts  -=&amp;gt; &quot; + tsv + &quot; (&quot; + tsv.getTimezoneOffset() + &quot;)&quot;);
        System.out.println(&quot; got cal     -=&amp;gt; &quot; + printCalendar(getCal));
        System.out.println(&quot; targetAfter -=&amp;gt; &quot; + printCalendar(targetCal) + &quot;\n&quot;);
        return;
    }

&lt;p&gt;    private String printCalendar(Calendar cal)&lt;/p&gt;
    {
        StringBuffer sbuf = new StringBuffer();
        sbuf.append(cal.get(Calendar.MONTH) + &quot; &quot;);
        sbuf.append(cal.get(Calendar.DAY_OF_MONTH) + &quot;, &quot;);
        sbuf.append(cal.get(Calendar.YEAR) + &quot; -- &quot;);
        sbuf.append(cal.get(Calendar.HOUR_OF_DAY) + &quot;:&quot;);
        sbuf.append(cal.get(Calendar.MINUTE) + &quot;:&quot;);
        sbuf.append(cal.get(Calendar.SECOND) + &quot;.&quot;);
        sbuf.append(cal.get(Calendar.MILLISECOND));
        sbuf.append(&quot; (&quot; + cal.getTimeZone().getID() + &quot;)&quot;);
        return sbuf.toString();
    }</comment>
                            <comment id="12494122" author="djd" created="Mon, 7 May 2007 21:21:12 +0100"  >&lt;p&gt;The javadoc for the getTimestamp() with a calendar object state that the passed in Calendar is the one to use in creating the java.sql.Timestamp object.&lt;/p&gt;


&lt;p&gt;&quot;This method uses the given calendar to construct an appropriate millisecond value for the timestamp if the underlying database does not store timezone information.&quot;&lt;/p&gt;

&lt;p&gt;&quot;cal - the java.util.Calendar object to use in constructing the date&quot;&lt;/p&gt;

&lt;p&gt;So I think the embedded behaviour is within the spec. In fact one might be able to read the spec in such a way that it is expected the passed in Calendar&lt;br/&gt;
object is modified by the call and set to the value corresponding to the column, thus maybe client behaviour is incorrect?&lt;/p&gt;

</comment>
                            <comment id="12494140" author="army" created="Mon, 7 May 2007 22:55:31 +0100"  >&lt;p&gt;&amp;gt; So I think the embedded behaviour is within the spec. In fact one might be able to read the&lt;br/&gt;
&amp;gt; spec in such a way that it is expected the passed in Calendar object is modified by the call&lt;br/&gt;
&amp;gt; and set to the value corresponding to the column, thus maybe client behaviour is incorrect? &lt;/p&gt;

&lt;p&gt;Hmm.  So we are to read &quot;object to use in constructing the date&quot; as &quot;object in which to return the constructed date&quot;?&lt;/p&gt;

&lt;p&gt;Seems odd to a) return the timestamp value as a java.sql.Timestamp, &lt;b&gt;and&lt;/b&gt; b) return the timestamp via the received Calendar object.&lt;/p&gt;

&lt;p&gt;If that is in fact the correct behavior, then is there a bug in embedded because it truncates the milliseconds? I.e.:&lt;/p&gt;

&lt;p&gt;On embedded:&lt;/p&gt;

&lt;p&gt; targetBefore -=&amp;gt; 9 10, 2010 &amp;#8211; 10:10:10.205 (GMT-10:00)&lt;br/&gt;
 got cal -=&amp;gt; 4 3, 2007 &amp;#8211; 19:49:52.883 (America/Los_Angeles)&lt;br/&gt;
 targetAfter -=&amp;gt; 4 3, 2007 &amp;#8211; 16:49:52.0 (GMT-10:00) &lt;/p&gt;

&lt;p&gt;Note how the &quot;targetAfter&quot; object has no milliseconds.&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth, I ran the exact same program against a DB2 database and, as with Derby client, the Calendar object is &lt;b&gt;not&lt;/b&gt; modified.  I don&apos;t have any other RDMBs against which to try...&lt;/p&gt;

&lt;p&gt;In any event, I think this discussion goes beyond the scope of the &quot;recyclableCleanup_v1.patch&quot;, which is targeted for a very specific type of cleanup--and one that does not itself alter functionality.  Maybe changes to way in which client handles Calendar objects can be filed as a separate issue?&lt;/p&gt;</comment>
                            <comment id="12494170" author="djd" created="Tue, 8 May 2007 02:16:27 +0100"  >&lt;p&gt;AB&amp;gt; Seems odd to a) return the timestamp value as a java.sql.Timestamp, &lt;b&gt;and&lt;/b&gt; b) return the timestamp via the received Calendar object. &lt;/p&gt;

&lt;p&gt;What&apos;s the alternative semantics? Ie. given a Calendar object and the SQL representation of a TIMESTAMP, how does a JDBC driver&lt;br/&gt;
use the passed in Calendar object to create a valid JDBC java.sql.Timestamp without changing its value?&lt;/p&gt;</comment>
                            <comment id="12494182" author="djd" created="Tue, 8 May 2007 04:53:57 +0100"  >&lt;p&gt;Looking at the network client&apos;s implementation of getTimeStamp() with a Calendar I have to say it seems inefficient, confusing and wrong. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;This is looking at lines 1020-1031 in client.am.ResultSet.java (which isn&apos;t modified by the patch so it&apos;s existing code)&lt;/p&gt;

&lt;p&gt;Inefficient because it creates two new Calendar objects for every call,that will cause a heavy gc overload and cpu overhead.&lt;/p&gt;

&lt;p&gt;Confusing because it uses two Calendar objects (when one will do) and just does strange things:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The value from the column is set in the targetCalendar but then never used&lt;/li&gt;
	&lt;li&gt;The value from the column is set in the defaultCalendar but then never used&lt;/li&gt;
	&lt;li&gt;The timezeone offset is calculated using the two calendar objects, and then applied to the long millisecond value obtained from the&lt;br/&gt;
       java.sql.Timestamp value, but this is what Calendar objects do, so why is this being done explicitly?&lt;/li&gt;
	&lt;li&gt;no code comments&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Wrong because:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the passed in calendar is not used to perform the conversion from SQL TIMESTAMP value to java.sql.Timestamp. The passed in Calendar is only used to determine the timezone of the value to be returned (line 1021). However a Calendar object has more meaning than just a time zone, it has behaviour because a Calendar object is an abstract class and thus can have multiple different implementations. The client code is assuming that the Calendar object returned from the static methods Calendar.getInstance() match the Calendar object passed in, this may not be true. If the application passes in a Jewish Calendar implementation for example then most likely this client code will be using a GregorianCalendar to incorrectly perform calculations.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;looking beyond these lines of code, I think the complete conversion is incorrect, even if in this method the passed in Calendar was used. Before these lines of code the value is obtained using the getTimestamp() with no Calendar object, this uses a GregorianCalendar() to convert from the over-the-wire value to a java.sql Timestamp. Thus the conversion would be (if the user supplied Calendar object was used):&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   YYYY-MM-DD:hh:mm:ss.ffff  &amp;gt;&amp;gt; GregorianCalendar &amp;gt;&amp;gt;  long milli-seconds &amp;gt;&amp;gt; java.sql.Timestamp &amp;gt;&amp;gt; long milli-seconds &amp;gt;&amp;gt; user supplied Calendar object&lt;/p&gt;

&lt;p&gt;I&apos;m think that if the user supplied Calendar object was not an instance of GregorianCalendar then there&apos;s a significant chance the wrong result would be returned.&lt;br/&gt;
What is required is the same approach as embedded, which is to always perform&lt;br/&gt;
   YYYY-MM-DD:hh:mm:ss.ffff &amp;gt;&amp;gt; Calendar &amp;gt;&amp;gt;  long milli-seconds &amp;gt;&amp;gt; java.sql.Timestamp&lt;/p&gt;

&lt;p&gt;where the Calendar is either the user-supplied one or a builtin one, so that the calling order is the other way around, getTimestamp(int) should be calling getTimestamp(int, Calendar).&lt;/p&gt;
</comment>
                            <comment id="12494302" author="army" created="Tue, 8 May 2007 16:17:49 +0100"  >&lt;p&gt;Thank you for your extensive comments on this, Dan!&lt;/p&gt;

&lt;p&gt;&amp;gt; Looking at the network client&apos;s implementation of getTimeStamp() with a Calendar I have to &lt;br/&gt;
&amp;gt; say it seems inefficient, confusing &lt;/p&gt;

&lt;p&gt;I definitely agree with you here!&lt;/p&gt;

&lt;p&gt;&amp;gt; and wrong. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Well...okay.  Do you by chance know of a concrete repro to demonstrate what you have described above?&lt;/p&gt;

&lt;p&gt;&amp;gt; What is required is the same approach as embedded, which is to always perform&lt;br/&gt;
&amp;gt;   YYYY-MM-DD:hh:mm:ss.ffff &amp;gt;&amp;gt; Calendar &amp;gt;&amp;gt; long milli-seconds &amp;gt;&amp;gt; java.sql.Timestamp &lt;/p&gt;

&lt;p&gt;Sounds like a separate Jira, agreed?&lt;/p&gt;

&lt;p&gt;Is it okay to proceed with committing the recyclableCleanup_v1.patch (and subquent fix) for this issue as it is now?  I don&apos;t think my changes make the situation any worse, and they will make it easier to resolve this issue--and also &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-889&quot; title=&quot;with client getTimestamp on a TIME column will print the date  1900-01-01 instead of the current date&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-889&quot;&gt;&lt;del&gt;DERBY-889&lt;/del&gt;&lt;/a&gt;, I believe.&lt;/p&gt;

&lt;p&gt;Unless I hear objections pretty quickly, I&apos;ll plan to commit the cleanup_v1 patch later this morning.&lt;/p&gt;</comment>
                            <comment id="12494319" author="army" created="Tue, 8 May 2007 17:11:36 +0100"  >&lt;p&gt;&amp;gt; Unless I hear objections pretty quickly, I&apos;ll plan to commit the cleanup_v1 patch later this morning.&lt;/p&gt;

&lt;p&gt;Actually, I&apos;m not sure how much time I&apos;ll have over the next few days to work with this particular issue.  I may need to revisit my approach in light of Dan&apos;s comments.  So I&apos;ll hold off committing for now.&lt;/p&gt;</comment>
                            <comment id="12494830" author="army" created="Thu, 10 May 2007 21:45:45 +0100"  >&lt;p&gt;One solution that seems to solve this problem is to create a java.sql.Timestamp object from the SQL TIMESTAMP and then use the &quot;Time(long time)&quot; constructor to create a java.sql.Time object, where &quot;time&quot; is retrieved from the java.sql.Timestamp object.  For example (in client/am/DateTime.java):&lt;/p&gt;

&lt;p&gt;     java.sql.Time result = new java.sql.Time(timestampBytesToTimestamp(&lt;br/&gt;
         buffer, offset, (java.sql.Timestamp)null, encoding).getTime());&lt;/p&gt;

&lt;p&gt;That said, though, Java API indicates the following:&lt;/p&gt;

&lt;p&gt;  &quot;The date components should be set to the &quot;zero epoch&quot; value of January 1, 1970 and should not be accessed.&quot;&lt;/p&gt;

&lt;p&gt;So we would have to explicitly override the date fields for the resultant java.sql.Time object.  Doing so directly via the Time object would require use of deprecated methods (setYear(), setMonth(), setDay()).  The other (recommended) option is to use an intermediary Calendar object:&lt;/p&gt;

&lt;p&gt;     java.sql.Timestamp ts = timestampBytesToTimestamp(&lt;br/&gt;
         buffer, offset, (java.sql.Timestamp)null, encoding).getTime());&lt;/p&gt;

&lt;p&gt;     Calendar cal = &amp;lt;cleared Calendar object&amp;gt;;&lt;br/&gt;
     cal.setTimeInMillis(ts.getTime());&lt;/p&gt;

&lt;p&gt;     /* Java API indicates that the date components of a Time value must&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;be set to January 1, 1970.&lt;br/&gt;
      */&lt;br/&gt;
     cal.set(1970, Calendar.JANUARY, 1);&lt;br/&gt;
     return new java.sql.Time(cal.getTimeInMillis());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The latter approach (use of Calendar) seems cleaner, but requires either 1) repeated instantiation of a Calendar object, or 2) re-use of some passed in Calendar object, per d1816_recyclableCleanup_v1.patch.  The former approach (use of deprecated setXXX() methods) requires fewer changes but seems less wholesome.&lt;/p&gt;

&lt;p&gt;Any votes for/against one or the other?&lt;/p&gt;

&lt;p&gt;I prefer to use the Calendar approach to avoid deprecated methods, which is why I would like to commit the recyclableCleanup_v1.patch.  But I&apos;m open to alternate suggestions.&lt;/p&gt;

&lt;p&gt;Either approach requires the additional instantion of a java.sql.Timestamp object for each call to getTime().  Is that acceptable?  We could avoid that by isolating the timestamp parsing code into its own method and returning its fields via an array, but I&apos;m not sure if that&apos;s better or worse than creating an intermediate Timestamp object...&lt;/p&gt;</comment>
                            <comment id="12494832" author="djd" created="Thu, 10 May 2007 22:01:20 +0100"  >&lt;p&gt;The embedded driver works correctly without creating a Timestamp object, so it should be possible for the client to do the same.&lt;br/&gt;
(See SQLTimestamp.newTime(Calendar)&lt;/p&gt;</comment>
                            <comment id="12494841" author="army" created="Thu, 10 May 2007 22:19:00 +0100"  >&lt;p&gt;Right, but embedded is also working on an instance of SQLTimestamp, which already has a notion of &quot;time&quot; from which it can pull the right pieces.  So it&apos;s easier there.&lt;/p&gt;

&lt;p&gt;In client all we have a is a string.  We have to parse that string into &lt;b&gt;something&lt;/b&gt; that can be translated into hours, minutes, seconds, etc.&lt;/p&gt;

&lt;p&gt;&amp;gt; it should be possible for the client to do the same.&lt;/p&gt;

&lt;p&gt;Yes, it is possible, I didn&apos;t mean to suggest it wasn&apos;t.   We do that today.  But in order to fix this Jira we&apos;d have to explicitly parse the various pieces out of the string, just as we do with getTimestamp(). So we either duplicate the timestamp parsing code (ick), or we do something like:&lt;/p&gt;

&lt;p&gt;        int [] tsFields = new int &lt;span class=&quot;error&quot;&gt;&amp;#91;7&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        parseTimestampString(timestamp, tsFields);&lt;/p&gt;

&lt;p&gt;        cal.set(tsFields&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, tsFields&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, ...)&lt;/p&gt;

&lt;p&gt;Either way is possible, it&apos;s just that neither is particular pretty.  But if instantiating an extra Timestamp is so bad, it would of course be worth it.&lt;/p&gt;</comment>
                            <comment id="12494881" author="djd" created="Thu, 10 May 2007 23:41:36 +0100"  >&lt;p&gt;or just pass in a calendar object into the parse method, e.g. re-write timestampBytesToTimestamp() to pass in a calendar and then create the java.sql.Timestamp object outside when required.&lt;/p&gt;</comment>
                            <comment id="12497620" author="army" created="Mon, 21 May 2007 23:49:22 +0100"  >&lt;p&gt;Attaching d1816_recycleCleanup_v2.patch, which is pretty much the same as _v1 except that it has been sync&apos;d with the latest codeline (esp. &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-889&quot; title=&quot;with client getTimestamp on a TIME column will print the date  1900-01-01 instead of the current date&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-889&quot;&gt;&lt;del&gt;DERBY-889&lt;/del&gt;&lt;/a&gt; changes).  If I do not hear any objections, I plan to commit this cleanup patch before the end of the day Tuesday (05/22) PST...&lt;/p&gt;

&lt;p&gt;derbyall ran cleanly on SUSE Linux with ibm142; suites.All had 13 failures, but all of those show up in the tinderbox results, as well.&lt;/p&gt;

&lt;p&gt;Note that the _v2 patch does not resolve this Jira issue; it is simply &quot;pre-patch&quot; cleanup.&lt;/p&gt;</comment>
                            <comment id="12498001" author="army" created="Tue, 22 May 2007 21:40:44 +0100"  >&lt;p&gt;Committed d1816_recycleCleanup_v3.patch with svn # 540740:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=540740&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=540740&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The difference between v2 and v3 is that the latter sets the time-related fields to &quot;0&quot; when getting a timestamp value from a SQL date.  This more accurately matches the behavior as it was is in Derby prior to the changes for this issue:&lt;/p&gt;

&lt;p&gt;_v2:&lt;/p&gt;

&lt;p&gt;&amp;lt; +        cal.set(year, month, day);&lt;br/&gt;
&amp;lt; +        return new java.sql.Timestamp(cal.getTimeInMillis());&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;_v3:&lt;/p&gt;

&lt;p&gt;&amp;gt; +        cal.set(year, month, day, 0, 0, 0);&lt;br/&gt;
&amp;gt; +        java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());&lt;br/&gt;
&amp;gt; +        ts.setNanos(0);&lt;br/&gt;
&amp;gt; +        return ts;&lt;/p&gt;

&lt;p&gt;Other than that the two patches are the same.&lt;/p&gt;</comment>
                            <comment id="12498402" author="army" created="Wed, 23 May 2007 23:04:53 +0100"  >&lt;p&gt;Attaching d1816_v1.patch, which is a fix for this issue.  The patch does the following:&lt;/p&gt;

&lt;p&gt;  1. Separates the timestamp parse logic in client/am/DateTime.java into a new&lt;br/&gt;
     method called &quot;parseTimestampString()&quot;.  The new method takes a timestamp&lt;br/&gt;
     string and a Calendar object, and sets the fields of the Calendar based on&lt;br/&gt;
     the fields that are parsed from the timestamp string. (This is, I think,&lt;br/&gt;
     what Dan was suggesting in his most recent comment).  The method also&lt;br/&gt;
     returns the parsed microseconds value since that cannot be set on a&lt;br/&gt;
     Calendar object (the precision of a Calendar is milliseconds).&lt;/p&gt;

&lt;p&gt;  2. Modifies timestampBytesToTimestamp(...) to call the new method for&lt;br/&gt;
     parsing timestamps.&lt;/p&gt;

&lt;p&gt;  3. Changes the timestampBytesToTime(...) method so that it now parses the&lt;br/&gt;
     &lt;b&gt;full&lt;/b&gt; timestamp (via the new parseTimestampString() method) instead of&lt;br/&gt;
     just parsing the hours, minutes, and seconds.  Then a java.sql.Time&lt;br/&gt;
     object is created from the Calendar object into which the timestamp&lt;br/&gt;
     string was parsed.  This allows us to preserve the sub-second resolution&lt;br/&gt;
     that is parsed from the timestamp.&lt;/p&gt;

&lt;p&gt;  4. Re-enables the relevant test case in lang/TimeHandlingTest.java so that&lt;br/&gt;
     it now runs in client mode.&lt;/p&gt;

&lt;p&gt;I ran derbyall and suites.All on a SUSE Linux machine with an earlier  version of this patch and the only failure was in derbyall/derbynetmats/maxthreads, which failed with the following diff:&lt;/p&gt;

&lt;p&gt;  27 del&lt;br/&gt;
  &amp;lt; Max threads changed to 9000.&lt;br/&gt;
  27a27&lt;br/&gt;
  &amp;gt;  Reading from process streams timed out..&lt;/p&gt;

&lt;p&gt;I don&apos;t think that is related to my changes, though.&lt;/p&gt;

&lt;p&gt;If anyone has feedback on this fix/approach, that would be great.  I plan to re-run derbyall and suites.All as a sanity check to make sure the latest version (_v1 as attached here) still runs cleanly, but am open to suggestions in the meantime...&lt;/p&gt;</comment>
                            <comment id="12498415" author="bryanpendleton" created="Wed, 23 May 2007 23:38:21 +0100"  >&lt;p&gt;I reviewed the patch, and it looks good to me. The code change seems&lt;br/&gt;
nice and clean, thanks for adding the comments! I verified that the updated&lt;br/&gt;
test fails as expected without the code change, and works as expected&lt;br/&gt;
with the code change. Thanks for fixing this bug.&lt;/p&gt;</comment>
                            <comment id="12498688" author="army" created="Thu, 24 May 2007 16:49:17 +0100"  >&lt;p&gt;Thanks for the review, Bryan!  I re-ran suites.All and derbyall on SUSE Linux with ibm142 and everything ran cleanly with _v1 patch as attached to this issue.  So I committed with svn # 541333:&lt;/p&gt;

&lt;p&gt;  URL: &lt;a href=&quot;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=541333&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=rev&amp;amp;rev=541333&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I also filed &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2690&quot; title=&quot;Clean up client&amp;#39;s implementation of getTimestamp() with a Calendar argument.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2690&quot;&gt;DERBY-2690&lt;/a&gt; for tracking of Dan&apos;s comments/suggestion re: the current problems with the client&apos;s implementation of getTimestamp() with a Calendar object.&lt;/p&gt;

&lt;p&gt;Marking the issue as resolved for 10.3.&lt;/p&gt;</comment>
                            <comment id="12500478" author="army" created="Thu, 31 May 2007 21:25:07 +0100"  >&lt;p&gt;Attaching first attempt at a release note.&lt;/p&gt;</comment>
                            <comment id="12501992" author="army" created="Wed, 6 Jun 2007 18:07:27 +0100"  >&lt;p&gt;Fix is in trunk (10.3) and I haven&apos;t heard any objections to the release note, so closing.&lt;/p&gt;</comment>
                            <comment id="12505554" author="myrna" created="Sat, 16 Jun 2007 23:53:05 +0100"  >&lt;p&gt;scrubbed rn&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                                                <inwardlinks description="is part of">
                                        <issuelink>
            <issuekey id="12354628">DERBY-2034</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12328223">DERBY-889</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12368487">DERBY-2602</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12356807" name="d1816_recycleCleanup_v1.patch" size="18846" author="army" created="Fri, 4 May 2007 21:56:38 +0100"/>
                            <attachment id="12357810" name="d1816_recycleCleanup_v2.patch" size="19276" author="army" created="Mon, 21 May 2007 23:49:21 +0100"/>
                            <attachment id="12357811" name="d1816_recycleCleanup_v2.stat" size="120" author="army" created="Mon, 21 May 2007 23:49:22 +0100"/>
                            <attachment id="12357924" name="d1816_recycleCleanup_v3.patch" size="19348" author="army" created="Tue, 22 May 2007 21:40:44 +0100"/>
                            <attachment id="12358036" name="d1816_v1.patch" size="7572" author="army" created="Wed, 23 May 2007 23:04:52 +0100"/>
                            <attachment id="12359948" name="releaseNote.html" size="4117" author="myrna" created="Sat, 16 Jun 2007 23:53:05 +0100"/>
                            <attachment id="12358652" name="releaseNote.html" size="4206" author="army" created="Thu, 31 May 2007 21:25:07 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 4 May 2007 20:56:38 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22725</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310090" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Issue &amp; fix info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10101"><![CDATA[Release Note Needed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy0ufb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38747</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>