<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 03:53:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/DERBY-2926/DERBY-2926.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[DERBY-2926] Replication: Add a log buffer for log records that should be shipped to the slave</title>
                <link>https://issues.apache.org/jira/browse/DERBY-2926</link>
                <project id="10594" key="DERBY">Derby</project>
                    <description>&lt;p&gt;When a Derby instance has the master role for a database, log records are shipped to the slave to keep it up to date. A buffer is needed because the log records should not be shipped one at a time. Also, writing the log records to a buffer instead of sending them immediately removes the network communication from the critical path for the transaction.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12373593">DERBY-2926</key>
            <summary>Replication: Add a log buffer for log records that should be shipped to the slave</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12373499">DERBY-2922</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jorgenlo">J&#248;rgen L&#248;land</assignee>
                                    <reporter username="jorgenlo">J&#248;rgen L&#248;land</reporter>
                        <labels>
                    </labels>
                <created>Thu, 12 Jul 2007 09:13:11 +0100</created>
                <updated>Thu, 2 May 2013 03:29:08 +0100</updated>
                            <resolved>Thu, 23 Aug 2007 15:35:12 +0100</resolved>
                                    <version>10.4.1.3</version>
                                    <fixVersion>10.4.1.3</fixVersion>
                                    <component>Services</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12512012" author="jorgenlo" created="Thu, 12 Jul 2007 09:57:03 +0100"  >&lt;p&gt;Note the questions below...&lt;/p&gt;

&lt;p&gt;PLAN:&lt;br/&gt;
I am planing to write the buffer as a linked list of ReplicationLogRecord objects, each containing the same information that is passed to LogToFile.appendLogRecord:&lt;/p&gt;

&lt;p&gt;byte[] data&lt;br/&gt;
int offset&lt;br/&gt;
int length&lt;br/&gt;
byte[] optionaldata&lt;br/&gt;
int optionalDataOffset&lt;br/&gt;
int optionalDataLength&lt;/p&gt;

&lt;p&gt;This is the same information that is sent in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2872&quot; title=&quot;Add Replication functionality to Derby&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2872&quot;&gt;&lt;del&gt;DERBY-2872&lt;/del&gt;&lt;/a&gt; using RMI calls. Log records will be appended to the buffer somewhere in the LogFactory, while a log shipping service will remove log records from it. Adding and removing log records from the buffer is not part of this jira.&lt;/p&gt;

&lt;p&gt;QUESTIONS:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;It will be very easy to recycle the ReplicationLogRecord objects that make up the linked list. Once the log-information in an object has been shipped to the slave, the object could be put in a pool of recycled objects. This would significantly reduce the number of ReplicationLogRecord objects that must be created and garbage collected, but may increase the memory usage since the objects in the pool are not removed from memory. &lt;b&gt;Is recycling considered good or bad practice?&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Will it be ok to create a new directory for this, e.g. java/engine/org/apache/derby/impl/store/replication/buffer/ ? It is likely that more replication functionality will be added to store later, and /store/replication could then be used for all of this.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12512164" author="mikem" created="Thu, 12 Jul 2007 17:36:23 +0100"  >&lt;p&gt;Do you have a writeup on the architecture for replication you are implementing other&lt;br/&gt;
than what is in this JIRA and &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2922&quot; title=&quot;Replication: Add master replication mode &quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2922&quot;&gt;&lt;del&gt;DERBY-2922&lt;/del&gt;&lt;/a&gt;.  It is hard to comment without understanding&lt;br/&gt;
the architecture you envision.&lt;/p&gt;

&lt;p&gt;Have you considered rather than having a linked list of log records, using the existing functionality to scan the log records as the base for your list of log records to write?  Some&lt;br/&gt;
of this depends on what kind of replication guarantee you are trying to provide.  In other&lt;br/&gt;
systems I have seen this describes similar to levels of transaction durability, ie. levels&lt;br/&gt;
like (all basically are tradeoffs about how much you impact master side commit&lt;br/&gt;
response time against guaranteeing slave consistency):&lt;br/&gt;
o don&apos;t allow transaction to commit until log records are synced to remote system&lt;br/&gt;
o queue write of log records at commit to remote, wait for network reply but not disk sync&lt;br/&gt;
o queue write of log records at commit to remove, don&apos;t wait for network reply&lt;/p&gt;

&lt;p&gt;If you are looking for any sort of coordination between transaction commit and guaranteeing&lt;br/&gt;
records on the remote I think I would tie into the existing log writing code rather than add&lt;br/&gt;
a separate beast.  Basically just enhance the small piece of code that actually writes log&lt;br/&gt;
records to disk to also call a new routine that would also write log records somewhere&lt;br/&gt;
else.  This does mean impacting performance of master response time depending on&lt;br/&gt;
the overhead of the secondary write method.  Using multiple threads to do I/O locally and&lt;br/&gt;
remote at same time would probably help a lot.&lt;/p&gt;</comment>
                            <comment id="12512423" author="jorgenlo" created="Fri, 13 Jul 2007 11:35:51 +0100"  >&lt;p&gt;Hi Mike&lt;/p&gt;

&lt;p&gt;There is a better description of what we intend to create in &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2872&quot; title=&quot;Add Replication functionality to Derby&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2872&quot;&gt;&lt;del&gt;DERBY-2872&lt;/del&gt;&lt;/a&gt;. Jira does not allow multiple layers of subtasks, so I had to use the &quot;is part of&quot; link.&lt;/p&gt;

&lt;p&gt;Basically, the goal is to provide asynchronous replication, i.e. replication where log shipment to the slave is completely decoupled from transactions on the master. This is even looser synchronization than your third alternative, which I believe is also known as 1-safe replication.&lt;/p&gt;

&lt;p&gt;The asynchronous replication strategy may result in some lost transactions when the slave performs fail-over. The amount of lost transactions is, of course, closely related to how often log shipment is performed. As you mention, there is a trade off between how tight the master/slave synchronization is and the incurred performance degradation. Since log shipping in asynchronous replication is completely decoupled from the transactions, this strategy should have less performance impact than the alternatives.&lt;/p&gt;

&lt;p&gt;Although the plan is to add asynchronous replication now, replication with tighter synchronization should be kept in mind. If possible within reasonable increased work, the architecture should easily extend to 1-safe or 2-safe (your second alternative) replication later.&lt;/p&gt;

&lt;p&gt;When it comes to the core replication functionality, there are two things the replication master must know about: 1) log writes and 2) log flush. The log records must (sooner or later) be sent to the slave, hence 1). What to do with flush calls is up to the replication strategy. For the planned asynchronous replication, flush calls can be ignored. For 1-safe and 2-safe replication, flush calls require log shipment as you describe in alternatives 2 and 3.&lt;/p&gt;

&lt;p&gt;The current plan for using the log buffer is to append log records to it somewhere in LogToFile.appendLogRecord. This is the same method used to append log records to logOut (output stream to the log file; class type LogAccessFile). LogAccessFile is implemented with a number byte[] buffers (LogAccessFileBuffer), which are ordered in a linked list. LogToFile is the only entry point for log writes, and is therefore easily modifiable for our purpose. &lt;/p&gt;

&lt;p&gt;At the other end of the log buffer, a log shipping service will consume log records. The service should, as you suggest, run as a separate thread. I think DaemonFactory could be useful to create this thread, but that is just a guess. &lt;/p&gt;

&lt;p&gt;In the current code, the flush-methods in LogToFile are the only entry points for transactions to force a log flush (e.g. at commit). Hence, adding forced log shipment to achieve 1 or 2 safe replication later can be easily put in these methods. In the planned asynchronous strategy, log shipment may, e.g., be based on a timeout; flush calls can be ignored altogether.&lt;/p&gt;

&lt;p&gt;I hope this clarifies most of your concerns. Does this architecture fit into your idea of &quot;tie into the existing log writing code&quot; since log records are added to the buffer from the log factory? The single entry point for both log writes and flushes makes this a good place for modifications (for both asynchronous and the x-safe strategies) in my opinion, but there may be good reasons for doing otherwise.&lt;/p&gt;</comment>
                            <comment id="12512541" author="dagw" created="Fri, 13 Jul 2007 18:14:45 +0100"  >&lt;p&gt;&amp;gt; * It will be very easy to recycle the ReplicationLogRecord objects&lt;br/&gt;
&amp;gt;   that make up the linked list. Once the log-information in an object&lt;br/&gt;
&amp;gt;   has been shipped to the slave, the object could be put in a pool of&lt;br/&gt;
&amp;gt;   recycled objects. This would significantly reduce the number of&lt;br/&gt;
&amp;gt;   ReplicationLogRecord objects that must be created and garbage&lt;br/&gt;
&amp;gt;   collected, but may increase the memory usage since the objects in&lt;br/&gt;
&amp;gt;   the pool are not removed from memory. *Is recycling considered good&lt;br/&gt;
&amp;gt;   or bad practice?*&lt;/p&gt;

&lt;p&gt;At this years Java One, the Sun JVM garbage collector people talked a&lt;br/&gt;
lot about how cheap object creation and garbage collection is iff:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;objects are short-lived&lt;/li&gt;
	&lt;li&gt;objects are read-only (use final if possible!)&lt;/li&gt;
	&lt;li&gt;objects are short&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(see &lt;a href=&quot;http://developers.sun.com/learning/javaoneonline/2007/pdf/TS-2906.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://developers.sun.com/learning/javaoneonline/2007/pdf/TS-2906.pdf&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;So whether recycling will be good depends on the nature of the&lt;br/&gt;
objects. Perhaps a micro benchmark may be useful to determine&lt;br/&gt;
this. Another approach here would be to use a large circular byte buffer and&lt;br/&gt;
administer space in it yourself. &lt;/p&gt;

&lt;p&gt;How do you imagine flow control if the network gets slow?  Would you&lt;br/&gt;
block a transaction whose record would overflow the buffer?&lt;/p&gt;</comment>
                            <comment id="12512876" author="jorgenlo" created="Mon, 16 Jul 2007 08:01:04 +0100"  >&lt;p&gt;&amp;gt;Another approach here would be to use a large circular byte buffer and&lt;br/&gt;
&amp;gt;administer space in it yourself. &lt;/p&gt;

&lt;p&gt;Thank you for the link, Dag.&lt;/p&gt;

&lt;p&gt;The initial log buffer plan was to make a log buffer of linked&lt;br/&gt;
list LogElements, each containing exactly one Derby log record.&lt;br/&gt;
Simple to write, but will generate lots of small, short-lived&lt;br/&gt;
objects.&lt;/p&gt;

&lt;p&gt;Based on the comments from Mike and Dag, I see that we have an&lt;br/&gt;
alternative strategy in reusing code from LogAccessFile. Although&lt;br/&gt;
I am not sure if LogAccessFile can be used as a log buffer as it&lt;br/&gt;
is, we can reuse much of the code. Basically, this would mean&lt;br/&gt;
that the log buffer is written as a circular byte buffer. The&lt;br/&gt;
slave will have to unserialize the byte buffers to get the log&lt;br/&gt;
records, but that should be fairly easy.&lt;/p&gt;

&lt;p&gt;The byte buffer strategy requires far less objects since each&lt;br/&gt;
buffer can contain many log records. Furthermore, reusing&lt;br/&gt;
LogAccessFile means I don&apos;t have to add a separate &quot;beast&quot;,&lt;br/&gt;
although some modifications may be required. Finally, LogToFile&lt;br/&gt;
can still be the place where log records are added to the buffer.&lt;br/&gt;
This is nice because of the single point of entry considerations.&lt;/p&gt;

&lt;p&gt;The alternative strategy seems to be better than the original&lt;br/&gt;
one. I will give that a try.&lt;/p&gt;</comment>
                            <comment id="12512879" author="jorgenlo" created="Mon, 16 Jul 2007 08:19:10 +0100"  >&lt;p&gt;&amp;gt;How do you imagine flow control if the network gets slow? Would you&lt;br/&gt;
&amp;gt;block a transaction whose record would overflow the buffer? &lt;/p&gt;

&lt;p&gt;There are at least two simple alternatives for how to handle a full replication buffer:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Stop replication&lt;/li&gt;
	&lt;li&gt;Block transactions&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think the first alternative would be the better one since blocking transactions would mean no availability. This is the exact opposite of what we want to achieve with replication.&lt;/p&gt;

&lt;p&gt;The functional spec of &lt;a href=&quot;https://issues.apache.org/jira/browse/DERBY-2872&quot; title=&quot;Add Replication functionality to Derby&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DERBY-2872&quot;&gt;&lt;del&gt;DERBY-2872&lt;/del&gt;&lt;/a&gt; states that resuming replication after it has been stopped is a good candidate for extending the functionality. Once that issue has been addressed, we have a third alternative if the buffer gets full:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Stop replication for now, but store the log files so that replication can be resumed later.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12515231" author="jorgenlo" created="Wed, 25 Jul 2007 08:27:58 +0100"  >&lt;p&gt;Attachment: bytebuffer_v1.*&lt;/p&gt;

&lt;p&gt;The attachment contains a buffer implemented as &lt;/p&gt;

&lt;p&gt;LinkedList freeBuffers&lt;br/&gt;
LinkedList dirtyBuffers&lt;/p&gt;

&lt;p&gt;where each buffer is a byte[]. The buffer works similar to LogAccessFile, and reuses some code from that file. &lt;/p&gt;

&lt;p&gt;The patch includes an exception. The exception (LogBufferFullException) will only be used internally in the replication code. When caught by the log shipping code (to be written), the log shipper will have to decide what to do. Some examples: stop replication, stop replication but store log on disk for later restart, increase the buffer size, try to flush the buffer to see if that helps, and so on. The exception will never be thrown outside the replication code.&lt;/p&gt;

&lt;p&gt;I have two minor questions. &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I have not seen many internal exceptions in Derby. Is it ok for me to add one? I think the &quot;LogBufferFullException&quot; provides valuable information...&lt;/li&gt;
	&lt;li&gt;I have placed the patch in java/engine/org/apache/derby/impl/services/replication/buffer/. Future replication patches are intended to be added to the same path (- &quot;buffer/&quot;). Is that ok?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The buffer is not used anywhere in the Derby code yet. Later replication patches will start using it. I ran derbyall and suites.all. These failed with the same &lt;b&gt;number&lt;/b&gt; of fail/errors as reported by tinderbox. Unfortunately, the tinderbox report site is down for the moment. Since the code is not used for now, I expect it to not be the cause of the failures.&lt;/p&gt;</comment>
                            <comment id="12515247" author="jorgenlo" created="Wed, 25 Jul 2007 11:04:04 +0100"  >&lt;p&gt;Patch v1a replaces patch v1. It removes two methods that were used in testing, but is otherwise equal.&lt;/p&gt;</comment>
                            <comment id="12517625" author="rhillegas" created="Fri, 3 Aug 2007 21:16:52 +0100"  >&lt;p&gt;Small comment on this patch: The class name in the header boilerplate does not agree with the actual package and classname of the file.&lt;/p&gt;</comment>
                            <comment id="12517904" author="jorgenlo" created="Mon, 6 Aug 2007 13:09:48 +0100"  >&lt;p&gt;Patch v1-fixheader replaces v1a. The headers now match the actual package locations and class names&lt;/p&gt;</comment>
                            <comment id="12521092" author="knutanders" created="Mon, 20 Aug 2007 14:56:10 +0100"  >&lt;p&gt;Hi J&#248;rgen,&lt;/p&gt;

&lt;p&gt;I had a look at your patch (v1-fixheader). Please see my comments&lt;br/&gt;
below.&lt;/p&gt;

&lt;p&gt;1) I think it would be good if there were some class-level javadoc&lt;br/&gt;
comments explaining the purpose of each class. For instance, it is not&lt;br/&gt;
clear to me what a class named &quot;LogBufferReplication&quot; is meant to do&lt;br/&gt;
(I noticed that you mentioned a class called ReplicationLogBuffer in a&lt;br/&gt;
JIRA comment. If that&apos;s the same class, it sounds like a better name&lt;br/&gt;
to me.) Also, javadoc comments for the methods (at least the public&lt;br/&gt;
ones) would be good.&lt;/p&gt;

&lt;p&gt;2) I got this warning when I built the javadoc:&lt;/p&gt;

&lt;p&gt;  &lt;span class=&quot;error&quot;&gt;&amp;#91;javadoc&amp;#93;&lt;/span&gt; /export/home/kh160127/derby/trunk/java/engine/org/apache/derby/impl/services/replication/buffer/LogBufferReplication.java:103: warning - @param argument &quot;data_offset&quot; is not a parameter name.&lt;/p&gt;

&lt;p&gt;3) If the value of a field is not meant to change during the lifetime&lt;br/&gt;
of an object, I find it very useful to mark them as such by declaring&lt;br/&gt;
them final. Declaring them final serves both as documentation and as&lt;br/&gt;
an extra compile-time error check (and I have heard people saying it&lt;br/&gt;
helps the garbage collector as well). These fields could be final:&lt;/p&gt;

&lt;p&gt;LogBufferReplication&lt;br/&gt;
  dirtyBuffers&lt;br/&gt;
  freeBuffers&lt;br/&gt;
  defaultBufferSize&lt;/p&gt;

&lt;p&gt;LogBufferElement&lt;br/&gt;
  bufferdata&lt;br/&gt;
  bufferSize&lt;/p&gt;

&lt;p&gt;4) The fields LogBufferReplication.outBufferCapacity and&lt;br/&gt;
LogBufferElement.bufferSize are redundant since they are always equal&lt;br/&gt;
to outBufferData.length and bufferdata.length.&lt;/p&gt;

&lt;p&gt;5) Is the LogBufferElement class supposed to be accessed directly by&lt;br/&gt;
classes in other packages? If not, you could remove the public&lt;br/&gt;
modifier in the class definition.&lt;/p&gt;

&lt;p&gt;6) I think a better name for LogBufferElement.writeByte() would be&lt;br/&gt;
writeBytes(), since it writes an array, not a single byte.&lt;/p&gt;

&lt;p&gt;7) LogBufferElement.writeInt() and LogBufferElement.writeLong()&lt;br/&gt;
perform unnecessary casting and masking of intermediate results. I&lt;br/&gt;
think writeLong() could be simplified to:&lt;/p&gt;

&lt;p&gt;  bufferdata&lt;span class=&quot;error&quot;&gt;&amp;#91;p++&amp;#93;&lt;/span&gt; = (byte) (l &amp;gt;&amp;gt; 56);&lt;br/&gt;
  .&lt;br/&gt;
  .&lt;br/&gt;
  .&lt;br/&gt;
  bufferdata&lt;span class=&quot;error&quot;&gt;&amp;#91;p++&amp;#93;&lt;/span&gt; = (byte) (l &amp;gt;&amp;gt; 8);&lt;br/&gt;
  bufferdata&lt;span class=&quot;error&quot;&gt;&amp;#91;p++&amp;#93;&lt;/span&gt; = (byte) l;&lt;/p&gt;

&lt;p&gt;As a side note, if this code can use java.nio.ByteBuffer (it can&apos;t if&lt;br/&gt;
it&apos;s supposed to run under J2ME), I would recommend switching to it as&lt;br/&gt;
it has helper methods which do exactly the same. The number of Derby&lt;br/&gt;
classes with their own methods for big-endian encoding of integers is&lt;br/&gt;
high enough already... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8) LogBufferReplication.next() has an empty catch block. What about&lt;br/&gt;
adding SanityManager.THROWASSERT?&lt;/p&gt;

&lt;p&gt;9) I think I would have renamed setRecycle() and recycle() to&lt;br/&gt;
setRecyclable() and isRecyclable() (when I saw the call to recycle() I&lt;br/&gt;
first thought it was a command, not a getter method). Perhaps the&lt;br/&gt;
setRecycle() method even could be removed and instead we could pass&lt;br/&gt;
the value directly to the constructor?&lt;/p&gt;

&lt;p&gt;10) LogBufferReplication.validData() is declared to throw&lt;br/&gt;
NoSuchElementException, but it never throws anything.&lt;/p&gt;

&lt;p&gt;11) LogBufferReplication.getData() could be simplified by using&lt;br/&gt;
Arrays.copyOf().&lt;/p&gt;

&lt;p&gt;12) You asked whether it was OK with internal exceptions like&lt;br/&gt;
LogBufferFullException. I think is, but if the exception is supposed&lt;br/&gt;
to be caught by other modules (I don&apos;t know if that&apos;s how it will be&lt;br/&gt;
used) perhaps it should be located in one of the iapi packages instead&lt;br/&gt;
of impl?&lt;/p&gt;

&lt;p&gt;13) I noticed some use of synchronization in&lt;br/&gt;
LogBufferReplication. Could you add a short comment in the class&lt;br/&gt;
javadoc stating the synchronization requirements?&lt;/p&gt;

&lt;p&gt;14) In LogBufferReplication.next(), could we skip the shrinking of&lt;br/&gt;
outBufferData? Unless the buffer can become very large, I think we&lt;br/&gt;
could just skip it. That would simplify the code and also reduce the&lt;br/&gt;
need for reallocation if there&apos;s a non-default buffer size at a later&lt;br/&gt;
point in time.&lt;/p&gt;</comment>
                            <comment id="12521403" author="jorgenlo" created="Tue, 21 Aug 2007 12:51:16 +0100"  >&lt;p&gt;Attaching patch v2, replacing previous patches.&lt;/p&gt;

&lt;p&gt;Thanks for reviewing the patch, Knut. In v2 I have addressed most of your comments:&lt;/p&gt;

&lt;p&gt;Fixed: 1, 2, 3, 4, 5, 6, 7 (partially), 8, 9, 10, 13&lt;/p&gt;

&lt;p&gt;Comments:&lt;br/&gt;
--------&lt;br/&gt;
7: I cannot think of a situation where an application running j2me would want to run replication. However, I do not think it is a good idea to block this possibility at this point just to save 3 methods. I have therefore not removed these methods.&lt;/p&gt;

&lt;p&gt;11: You are right that Arrays.copyOf would be simpler. As far as I can see, however, these were introduced in Java 1.6 and can therefore not be used.&lt;/p&gt;

&lt;p&gt;12: I think the exception will only be seen by the master replication module. The exception can be moved to iapi later if this assumption does not hold.&lt;/p&gt;

&lt;p&gt;14: One log record could have the size of two whole pages (do and undo information for a whole page) + log record overhead. This could potentially be much larger than the default LogBufferElement size. I would therefore prefer to keep the code as it is.&lt;/p&gt;

&lt;p&gt;Also fixed:&lt;br/&gt;
----------&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Synchronization on two different objects in ReplicationLogBuffer so that the logger can append log records and the log consumer can read chunks of log at the same time.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ReplicationLogBuffer.switchDirtyBuffer is no longer synchronized since all uses of it is already synchronized. Also, the method is modified to move the currentDirtyBuffer to dirtyBuffers even if freeBuffers.size == 0&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Clearification of comments&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12521414" author="knutanders" created="Tue, 21 Aug 2007 13:54:38 +0100"  >&lt;p&gt;Thanks for the new patch J&#248;rgen. Your comments sound reasonable to me. Some new comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I assume the changes to index.html should be discarded.&lt;/li&gt;
	&lt;li&gt;ReplicationLogBuffer.validData() is synchronized on this. Did you mean outputLatch?&lt;/li&gt;
	&lt;li&gt;ReplicationLogBuffer.switchDirtyBuffer() mentions synchronized(this) in its javadoc. Should it say listLatch?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12521421" author="jorgenlo" created="Tue, 21 Aug 2007 14:15:10 +0100"  >&lt;p&gt;Attached patch v2b replaces v2. Knut&apos;s comments are addressed.&lt;/p&gt;</comment>
                            <comment id="12521423" author="knutanders" created="Tue, 21 Aug 2007 14:16:38 +0100"  >&lt;p&gt;One more question related to #14:&lt;/p&gt;

&lt;p&gt;It seems the code reallocates the buffer as long as its length is not equal to the default size, even if the new buffer will be of the exact same size as the old one (I was thinking this could happen if you for instance update a LOB, so that you get a large number of consecutive log records with identical size, but larger than default size). I think this simplified code would behave the same way and save buffer allocation in those cases:&lt;/p&gt;

&lt;p&gt;int requiredSize = Math.max(defaultBufferSize, current.size());&lt;br/&gt;
if (outBufferData.length != requiredSize) &lt;/p&gt;
{
    outBufferData = new byte[requiredSize];
}</comment>
                            <comment id="12521424" author="knutanders" created="Tue, 21 Aug 2007 14:18:28 +0100"  >&lt;p&gt;You&apos;re too quick! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12521426" author="knutanders" created="Tue, 21 Aug 2007 14:35:39 +0100"  >&lt;p&gt;Thanks for the new patch! Committed revision 568121.&lt;/p&gt;</comment>
                            <comment id="12522080" author="jorgenlo" created="Thu, 23 Aug 2007 10:36:13 +0100"  >&lt;p&gt;I agree - the change you suggest would both make the code easier to read and be more efficient. The attached patch, resizefix_1, addresses this issue.&lt;/p&gt;</comment>
                            <comment id="12522159" author="knutanders" created="Thu, 23 Aug 2007 15:35:12 +0100"  >&lt;p&gt;Thanks J&#248;rgen! Committed revision 569014.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12377554">DERBY-3051</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12364405" name="bytebuffer_resizefix_1.diff" size="2020" author="jorgenlo" created="Thu, 23 Aug 2007 10:36:13 +0100"/>
                            <attachment id="12364404" name="bytebuffer_resizefix_1.stat" size="95" author="jorgenlo" created="Thu, 23 Aug 2007 10:36:13 +0100"/>
                            <attachment id="12363238" name="bytebuffer_v1-fixheader.diff" size="17131" author="jorgenlo" created="Mon, 6 Aug 2007 13:09:48 +0100"/>
                            <attachment id="12363239" name="bytebuffer_v1-fixheader.stat" size="414" author="jorgenlo" created="Mon, 6 Aug 2007 13:09:48 +0100"/>
                            <attachment id="12362497" name="bytebuffer_v1.diff" size="16879" author="jorgenlo" created="Wed, 25 Jul 2007 08:27:58 +0100"/>
                            <attachment id="12362498" name="bytebuffer_v1.stat" size="352" author="jorgenlo" created="Wed, 25 Jul 2007 08:27:58 +0100"/>
                            <attachment id="12362504" name="bytebuffer_v1a.diff" size="16195" author="jorgenlo" created="Wed, 25 Jul 2007 11:04:03 +0100"/>
                            <attachment id="12362505" name="bytebuffer_v1a.stat" size="352" author="jorgenlo" created="Wed, 25 Jul 2007 11:04:04 +0100"/>
                            <attachment id="12364222" name="bytebuffer_v2.diff" size="31099" author="jorgenlo" created="Tue, 21 Aug 2007 12:51:16 +0100"/>
                            <attachment id="12364221" name="bytebuffer_v2.stat" size="414" author="jorgenlo" created="Tue, 21 Aug 2007 12:51:16 +0100"/>
                            <attachment id="12364230" name="bytebuffer_v2b.diff" size="23944" author="jorgenlo" created="Tue, 21 Aug 2007 14:15:10 +0100"/>
                            <attachment id="12364229" name="bytebuffer_v2b.stat" size="415" author="jorgenlo" created="Tue, 21 Aug 2007 14:15:10 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 12 Jul 2007 16:36:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30659</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy1153:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>39835</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                            </customfields>
    </item>
</channel>
</rss>