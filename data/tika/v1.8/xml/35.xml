<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 05:29:05 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/TIKA-35/TIKA-35.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[TIKA-35] Extract MsOffice properties</title>
                <link>https://issues.apache.org/jira/browse/TIKA-35</link>
                <project id="12310631" key="TIKA">Tika</project>
                    <description>&lt;p&gt;Hi,&lt;br/&gt;
I have developed a patch that allows MsOffice properties extraction. I wasn&apos;t able to extract the MsOffice properties and full text from a single inputstream, I always get this error : java.io.IOException Source code of java.io.IOException: Unable to read entire header; -1 bytes read;&lt;br/&gt;
expected 512 bytes. &lt;br/&gt;
I don&apos;t know how they make it work in Nutch (any ideas ?).&lt;br/&gt;
To get it work, I have added &quot;filePath&quot; variable in the parser class, and I populate it from ParseUtils class. After that I create an inputStream from filePath or Url and I use it to extract properties and I use the default inputstream to extract full text.&lt;br/&gt;
I didn&apos;t commit this modification; I would like to have your opinions before.&lt;br/&gt;
Regards.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12379209">TIKA-35</key>
            <summary>Extract MsOffice properties</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rbenjelloun">Rida Benjelloun</assignee>
                                    <reporter username="rbenjelloun">Rida Benjelloun</reporter>
                        <labels>
                    </labels>
                <created>Thu, 27 Sep 2007 18:12:40 +0100</created>
                <updated>Wed, 3 Oct 2007 21:30:09 +0100</updated>
                            <resolved>Mon, 1 Oct 2007 17:44:20 +0100</resolved>
                                    <version>0.1-incubating</version>
                                    <fixVersion>0.1-incubating</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12530822" author="kbennett" created="Thu, 27 Sep 2007 20:52:39 +0100"  >&lt;p&gt;Rida -&lt;/p&gt;

&lt;p&gt;The big question is: do we support the ability of parser implementations to make multiple passes over a stream?  If so, then we need to incorporate this cleanly into the architectural design.  Possible solutions are:&lt;/p&gt;

&lt;p&gt;1) Save the contents of the stream during the first pass.  Or, if the stream supports, use mark() and release().&lt;br/&gt;
2) Pass to the Parsers a URL instead of an InputStream so that we can create a stream multiple times.  This is simpler, but runs the risk of the resource changing between stream instantiations, though.&lt;/p&gt;

&lt;p&gt;IMO it would not be a good idea to put a resource identifier in the Parser class, even temporarily &amp;#8211; this is the reverse direction from our goal of making the parsers stateless.&lt;/p&gt;

&lt;p&gt;Instead, we could start discussing (or should I say continue to discuss?) how to support multiple passes cleanly in the architecture.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Keith&lt;/p&gt;

&lt;p&gt;P.S. For anyone having trouble applying Rida&apos;s patch, passing the &quot;-p5&quot; option to patch worked for me.&lt;/p&gt;</comment>
                            <comment id="12530823" author="rbenjelloun" created="Thu, 27 Sep 2007 21:05:42 +0100"  >&lt;p&gt;New patch, remove absolute directory name in the heaider.&lt;br/&gt;
Thanks keith.&lt;/p&gt;</comment>
                            <comment id="12530825" author="rbenjelloun" created="Thu, 27 Sep 2007 21:21:21 +0100"  >&lt;p&gt;Hi Keith,&lt;br/&gt;
I like the idea to save the content of the stream during the first pass. &lt;br/&gt;
Thanks&lt;/p&gt;</comment>
                            <comment id="12531453" author="jukkaz" created="Mon, 1 Oct 2007 10:44:42 +0100"  >&lt;p&gt;Re: multiple passes; I&apos;d rather achieve that with buffered streams and mark()/release(). This keeps the required coupling with the client to a minimum.&lt;/p&gt;</comment>
                            <comment id="12531559" author="rbenjelloun" created="Mon, 1 Oct 2007 17:43:56 +0100"  >&lt;p&gt;I have implement a method in Utils class that allows the copie of the inputstream in the memory.&lt;/p&gt;</comment>
                            <comment id="12531560" author="rbenjelloun" created="Mon, 1 Oct 2007 17:44:20 +0100"  >&lt;p&gt;SVN commit&lt;/p&gt;</comment>
                            <comment id="12531611" author="kbennett" created="Mon, 1 Oct 2007 21:02:22 +0100"  >&lt;p&gt;Rida, have you changed the code to copy an MS Word document&apos;s input stream into memory?  That would work well for 99% of input documents, but a really large one could bring down the JVM.&lt;/p&gt;</comment>
                            <comment id="12531668" author="kbennett" created="Tue, 2 Oct 2007 01:53:24 +0100"  >&lt;p&gt;Attached are a first pass at a rereadable stream class and a basic unit test that illustrates that it works (basically &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).&lt;/p&gt;

&lt;p&gt;This stream class wraps the document&apos;s input stream and saves its content when the passed stream is read.&lt;/p&gt;

&lt;p&gt;It supports a memory threshold; if the total size read is no more than this threshold, the data is stored in a byte [], and subsequent rereads of the stream are read from a ByteArrayInputStream.  If the total size exceeds the threshold, the data is stored in a File, and subsequent passes read a buffered FileInputStream.&lt;/p&gt;

&lt;p&gt;If you place these files in src/main/java/org/apache/tika/utils and src/test/java/org/apache/tika/utils, you should be able to compile them and run the test.&lt;/p&gt;

&lt;p&gt;Rereading the stream is accomplished by calling rewind().  Currently rewind() closes the input stream originally passed, but we may want to change that.&lt;/p&gt;
</comment>
                            <comment id="12531840" author="rbenjelloun" created="Tue, 2 Oct 2007 17:19:43 +0100"  >&lt;p&gt;Hi Keiht,&lt;br/&gt;
Thanks for this contribution. I will test it to extract office properties.  &lt;/p&gt;</comment>
                            <comment id="12531901" author="kbennett" created="Tue, 2 Oct 2007 21:23:27 +0100"  >&lt;p&gt;Rida -&lt;/p&gt;

&lt;p&gt;You&apos;re welcome.  This class is functional, but not 100% robust or complete.  In particular, if you call rewind() before reaching end of stream on the first pass, only those bytes already read will be saved to the buffer (memory or disk).  So if the first user of the stream may not read the whole stream, I&apos;d suggest forcing the initial pass to read the whole stream by doing something like:&lt;/p&gt;

&lt;p&gt;// Instantiate it with your stream and a memory thresold:&lt;br/&gt;
RereadableInputStream stream = new RereadableInputStream(aStream, 1024 * 1024);&lt;/p&gt;

&lt;p&gt;// Force reading entire stream to place it in storage for subsequent passes:&lt;br/&gt;
while (stream.read() != -1) &lt;/p&gt;
{
    // empty loop
}

&lt;p&gt;// Rewind the stream so that the next use of the stream will begin at the beginning of the stream,&lt;br/&gt;
// and read from the stored copy:&lt;br/&gt;
stream.rewind();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Keith&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12531981" author="rbenjelloun" created="Wed, 3 Oct 2007 02:47:58 +0100"  >&lt;p&gt;Keith - &lt;br/&gt;
I noted this problem, I will force reading entire stream before calling rewind() method. &lt;br/&gt;
Thanks for the suggestion&lt;/p&gt;</comment>
                            <comment id="12532000" author="chrismattmann" created="Wed, 3 Oct 2007 06:13:15 +0100"  >&lt;p&gt;Hi Folks:&lt;/p&gt;

&lt;p&gt;// Instantiate it with your stream and a memory thresold:&lt;br/&gt;
RereadableInputStream stream = new RereadableInputStream(aStream, 1024 * 1024);&lt;/p&gt;

&lt;p&gt;// Force reading entire stream to place it in storage for subsequent passes:&lt;br/&gt;
while (stream.read() != -1) &lt;/p&gt;
{
    // empty loop
}
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;Why not use the approach suggested by Keith above to wrap the rewind method with a check to see if the stream is at the end of stream? We could require RereadableInputStream to take an optional parameter, let&apos;s call it &quot;forceSeekOnRewind&quot;. By default, this would be set to false, but there could be a method that would set this to true, e.g., &quot;enableForceSeekOnRewind()&quot;. Then, in the rewind method, it would first do something like:&lt;/p&gt;

&lt;p&gt;if(forceSeekOnRewind){&lt;br/&gt;
  while(read() != -1)&lt;/p&gt;
{
   // empty loop
   }


&lt;p&gt;   doRewind(); /* does the actual rewind work */&lt;br/&gt;
}&lt;br/&gt;
else{&lt;br/&gt;
  if(EOF())&lt;/p&gt;
{
    /* at EOF, so go ahead and rewind */
  doRewind();
  }
&lt;p&gt;  /* else do nothing */&lt;br/&gt;
}&lt;/p&gt;


&lt;p&gt;Cheers, &lt;br/&gt;
 Chris&lt;/p&gt;

</comment>
                            <comment id="12532175" author="kbennett" created="Wed, 3 Oct 2007 18:45:11 +0100"  >&lt;p&gt;Rida -&lt;/p&gt;

&lt;p&gt;I saw your use of RereadableInputStream in MSExtractor.  The instance you are creating is passed to extractText() as an InputStream, not a RereadableInputStream, so the rereading functionality is never used.  Therefore, the original input stream could have been used instead.&lt;/p&gt;

&lt;p&gt;Can explain the original problem in detail?&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;
</comment>
                            <comment id="12532176" author="kbennett" created="Wed, 3 Oct 2007 18:51:21 +0100"  >&lt;p&gt;Chris -&lt;/p&gt;

&lt;p&gt;As per my previous comment, we may not need the RereadableInputStream after all.&lt;/p&gt;

&lt;p&gt;If we do keep it, though, I think for most use cases it would make sense for the default behavior to be:&lt;/p&gt;

&lt;p&gt;If rewind() is called on the first pass, read until end of stream to save the entire stream content.&lt;/p&gt;

&lt;p&gt;Perhaps there could be a way to override this, but I don&apos;t think we would ever want to use it.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;By the way, this class was really a proof of concept, and was not intended to be complete.  For example, we would probably want to set a maximum number of bytes read total (as opposed to in memory), to avoid consuming too much disk space.  I would also add javadoc. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Keith&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12532210" author="kbennett" created="Wed, 3 Oct 2007 20:28:10 +0100"  >&lt;p&gt;Rida -&lt;/p&gt;

&lt;p&gt;I was wrong when I said the original input stream could have been used.  I didn&apos;t see that the RereadableInputStream was being read twice.&lt;/p&gt;

&lt;p&gt;Sorry for the error.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Keith&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12532211" author="kbennett" created="Wed, 3 Oct 2007 20:33:18 +0100"  >&lt;p&gt;Rida -&lt;/p&gt;

&lt;p&gt;Please close the ReadableInputStream after you&apos;re finished using it.  That deletes the temporary file, if one was created.  Without this, the user&apos;s disk could be filled up while processing documents.&lt;/p&gt;

&lt;p&gt;Sorry, I should have included the close() call in the unit test I provided.  (Would you modify that too please?)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Keith&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12532241" author="rbenjelloun" created="Wed, 3 Oct 2007 21:30:09 +0100"  >&lt;p&gt;Keith - &lt;br/&gt;
This is done. &lt;br/&gt;
Thanks&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12366872" name="RereadableInputStream.java" size="2645" author="kbennett" created="Tue, 2 Oct 2007 01:53:24 +0100"/>
                            <attachment id="12366873" name="RereadableInputStreamTest.java" size="1507" author="kbennett" created="Tue, 2 Oct 2007 01:53:24 +0100"/>
                            <attachment id="12366691" name="tika35.patch" size="23316" author="rbenjelloun" created="Thu, 27 Sep 2007 21:05:42 +0100"/>
                            <attachment id="12366684" name="tika35.patch" size="24324" author="rbenjelloun" created="Thu, 27 Sep 2007 18:13:45 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 27 Sep 2007 19:52:39 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4827</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hxx69r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>17335</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>