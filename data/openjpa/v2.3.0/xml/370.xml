<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:31:04 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-370/OPENJPA-370.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-370] LoadFetchGroup annotation was not recognized during the fetch1</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-370</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Employee class has a LoadFetchGroup annotation defined on the Rating field, when getRating was called, the address should be returned also. However, openjpa did not handle the LoadFetchGroup correctly, therefore, address was not eargly fetched.&lt;br/&gt;
public class FGEmployee{&lt;br/&gt;
    @Id&lt;br/&gt;
    private int id;&lt;/p&gt;

&lt;p&gt;    @OneToOne(fetch=FetchType.LAZY) &lt;br/&gt;
    private FGAddress address;&lt;/p&gt;

&lt;p&gt;    @Basic(fetch=FetchType.LAZY)&lt;br/&gt;
    @LoadFetchGroup(&quot;AddressFetchGroup&quot;)&lt;br/&gt;
    private String rating;&lt;/p&gt;

&lt;p&gt;    @ManyToOne(fetch=FetchType.LAZY)&lt;br/&gt;
    private FGManager manager;&lt;/p&gt;

&lt;p&gt;..&lt;br/&gt;
}&lt;/p&gt;

</description>
                <environment></environment>
        <key id="12378299">OPENJPA-370</key>
            <summary>LoadFetchGroup annotation was not recognized during the fetch1</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="6">Invalid</resolution>
                                        <assignee username="tckan1">Teresa Kan</assignee>
                                    <reporter username="tckan1">Teresa Kan</reporter>
                        <labels>
                    </labels>
                <created>Fri, 14 Sep 2007 17:07:15 +0100</created>
                <updated>Tue, 9 Mar 2010 18:32:39 +0000</updated>
                            <resolved>Thu, 31 Jan 2008 00:23:46 +0000</resolved>
                                    <version>1.0.1</version>
                    <version>1.0.2</version>
                    <version>1.1.0</version>
                                    <fixVersion>1.0.2</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12527608" author="tckan1" created="Fri, 14 Sep 2007 20:18:09 +0100"  >&lt;p&gt;Attach the patch. See the following changes:&lt;br/&gt;
Index: openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java	(revision 574344)&lt;br/&gt;
+++ openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java	(working copy)&lt;br/&gt;
@@ -287,6 +287,9 @@&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    public void removeLoadFetchGroup()&lt;/p&gt;
{
+        
+    }
&lt;p&gt;     public Set getFields() {&lt;br/&gt;
         try {&lt;br/&gt;
             return _fetch.getFields();&lt;br/&gt;
Index: openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java	(revision 574344)&lt;br/&gt;
+++ openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java	(working copy)&lt;br/&gt;
@@ -192,7 +192,10 @@&lt;br/&gt;
     public FetchConfiguration clearFetchGroups();&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Resets the set of fetch groups to the list in the global configuration.&lt;br/&gt;
+     * Resets the set of fetch groups to the list in the global configuration. &lt;br/&gt;
+     * The global configuration will be the default plus any fetch groups &lt;br/&gt;
+     * that are added by the openjpa.FetchGroups property in the persistence.xml&lt;br/&gt;
+     * file.&lt;br/&gt;
      */&lt;br/&gt;
     public FetchConfiguration resetFetchGroups();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -197,6 +200,11 @@&lt;br/&gt;
     public FetchConfiguration resetFetchGroups();&lt;/p&gt;

&lt;p&gt;     /**&lt;br/&gt;
+     * Remove the loadFetchGroup if there is any loadFetchGroup.&lt;br/&gt;
+     */   &lt;br/&gt;
+    public void removeLoadFetchGroup();&lt;br/&gt;
+    &lt;br/&gt;
+    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns the set of fully-qualified field names that this component&lt;/li&gt;
	&lt;li&gt;will use when loading objects. Defaults to the empty set.  This set is&lt;/li&gt;
	&lt;li&gt;not thread safe.&lt;br/&gt;
Index: openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java&lt;br/&gt;
===================================================================
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java	(revision 575491)&lt;br/&gt;
+++ openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java	(working copy)&lt;br/&gt;
@@ -92,6 +92,7 @@&lt;br/&gt;
     private boolean _load = true;&lt;br/&gt;
     private int _availableRecursion;&lt;br/&gt;
     private int _availableDepth;&lt;br/&gt;
+    private String _lfg = null;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     public FetchConfigurationImpl() &lt;/p&gt;
{
         this(null);
@@ -287,7 +288,14 @@
                 getFetchGroupsList()));
         return this;
     }
&lt;p&gt;+      &lt;br/&gt;
+    public void removeLoadFetchGroup() &lt;/p&gt;
{
+        if (_lfg != null)
+            removeFetchGroup(_lfg);
+        _lfg = null;
+    }

&lt;p&gt;+&lt;br/&gt;
     public Set getFields() &lt;/p&gt;
{
         return (_state.fields == null) ? Collections.EMPTY_SET : _state.fields;
     }
&lt;p&gt;@@ -568,8 +576,16 @@&lt;br/&gt;
             return true;&lt;br/&gt;
         String[] fgs = fmd.getCustomFetchGroups();&lt;br/&gt;
         for (int i = 0; i &amp;lt; fgs.length; i++)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (hasFetchGroup(fgs&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;))&lt;br/&gt;
+            if (hasFetchGroup(fgs&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;)) {&lt;br/&gt;
+                String fg = fmd.getLoadFetchGroup();&lt;br/&gt;
+                if (fg != null) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+                    if (!hasFetchGroup(fg)) {
+                        addFetchGroup(fg);
+                        _lfg = fg;
+                    }+                }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;                 return true;&lt;br/&gt;
+            }&lt;br/&gt;
         return false; &lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -576,7 +592,7 @@&lt;br/&gt;
     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Return the available recursion depth via the given field for the&lt;/li&gt;
	&lt;li&gt;given type.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+     * &lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param traverse whether we&apos;re traversing the field&lt;br/&gt;
      */&lt;br/&gt;
     private int getAvailableRecursionDepth(FieldMetaData fm, Class type, &lt;br/&gt;
Index: openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java&lt;br/&gt;
===================================================================
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java	(revision 575494)&lt;br/&gt;
+++ openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java	(working copy)&lt;br/&gt;
@@ -358,6 +358,10 @@&lt;br/&gt;
         // is loaded, etc&lt;br/&gt;
         int lockLevel = calculateLockLevel(active, forWrite, fetch);&lt;br/&gt;
         boolean ret = loadFields(fields, fetch, lockLevel, sdata, forWrite);&lt;br/&gt;
+        // call back to FetchConfiguration to clean up any loadFetchGroup.&lt;br/&gt;
+        // The loadFetchGroup was set by the FetchConfigurationImpl.includes()&lt;br/&gt;
+        // during the process of the getUnloadedInternal method. &lt;br/&gt;
+        fetch.removeLoadFetchGroup();&lt;br/&gt;
         obtainLocks(active, forWrite, lockLevel, fetch, sdata);&lt;br/&gt;
         return ret;&lt;br/&gt;
     }&lt;br/&gt;
Index: openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java&lt;br/&gt;
===================================================================&lt;/li&gt;
			&lt;li&gt;openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java	(revision 574693)&lt;br/&gt;
+++ openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java	(working copy)&lt;br/&gt;
@@ -710,6 +710,8 @@&lt;br/&gt;
     /**&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;The fetch group that is to be loaded when this receiver is loaded, or&lt;/li&gt;
	&lt;li&gt;null if none set.&lt;br/&gt;
+     * The LoadFetchGroup does not relate to the FetchGroup annotation. Therefore&lt;br/&gt;
+     * resets a fetch group will not remove this LoadFetchGroup.&lt;br/&gt;
      */&lt;br/&gt;
     public void setLoadFetchGroup (String lfg) {&lt;br/&gt;
         if (&quot;&quot;.equals(lfg))&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12529153" author="tckan1" created="Thu, 20 Sep 2007 18:07:53 +0100"  >&lt;p&gt;I redo the fix for the LoadFetchGroup. The basic fix is based on the following principles:&lt;/p&gt;

&lt;p&gt;1)  when a field X which is part of the loadFetchGroup L but it  is not an eager fetch field,  field X can&apos;t determine whether it can be fetched or not because it is not sure that the owner of this loadFetchGroup will be loaded . Therefore, we have to wait until the owner of the loadFetchGroup is fetched.&lt;br/&gt;
2)  when a field Y has a FetchGroup associated with , then field Y is required to fetch. &lt;br/&gt;
   ==&amp;gt; Then we need  further to check whether this field Y has any loadFetchGroup. If field Y has a loadFetchGroup L; then we need to get the fields that associate with L. &lt;/p&gt;

&lt;p&gt;I have been looking into how to capture the info at parser phase. For example, if this is a LoadFetchGroup, then it should know all the fields that associated with this group. However, I found out that the fetch group is a String of name in the FieldMetaData. Unless we change the design to use the real FetchGroup object instead of the name, then we can capture the data at  parsing time.&lt;/p&gt;

&lt;p&gt;Anyway, I used the existing design and implementation to change the code. I have two patches:&lt;br/&gt;
1) Patch 1 : &lt;br/&gt;
It adds the LoadFetchGroup to the current active fetchgroup once it is found that the owner has defined this LoadFetchGroup, then StateManagerImpl will remove it later once all the fields are loaded. &lt;br/&gt;
2) Patch 2:&lt;br/&gt;
StateManagerImpl let the FetchConfiguration figure out what fields are needed to fetch for any fetch group. Instead of going to the FetchConfiguration.requiresFetch one field at a time, I introduced a new method FetchConfiguration.requiresFetch(set fetchgroup, FieldMetaData[] fmds) to return all the fields for the fetch groups.&lt;/p&gt;

&lt;p&gt;FetchConfiguration.requiresFetch() gets all the fields from the new includes(fetchgroup, fmds) method. This method loops thru each field and checks whether it associates with an active fetchgroup. If it is, then checks for a loadFetchGroup. If this field has the LoadFetchGroup, then get all the fields that associate with this LoadFetchGroup from getLoadFetchGroupFields().&lt;/p&gt;

&lt;p&gt;The getLoadFetchGroupFields() basically walk thru each field to check whether it is part of this LoadFetchGroup. Once all the fields are found, saved it in a cached Map for future use.&lt;/p&gt;

&lt;p&gt;Now we need to make decision about which patch should we use:&lt;br/&gt;
Patch 1 is simple and less expensive ; but it does not fit well into the architecture. Patch 2 is kind of fit well with the architecute but it is more expensive. Although I cached the loadFetchGroupFields info, we still need to go thru once to build this cache.&lt;br/&gt;
The best solution is to make use of the FetchGroup object. During the parse phase, capture the fields info in the FetchGroup. In addition to capture the fetch group info  in the Field, each FetchGroup also captures the fields info. In this case, once we find a fetch group, we can get all the loadFetchGroup and its assocated fields info.&lt;/p&gt;

&lt;p&gt;Since I&apos;m not totally familiar with the code, so it will take me a while to redo the FetchGroup objects in the parse phase. My suggestion is to commit either the patch1 or patch 2 in the version 1.0.x first. Then continue to work on the real implementation in 1.1.0.&lt;/p&gt;


</comment>
                            <comment id="12531014" author="kwsutter" created="Fri, 28 Sep 2007 14:57:55 +0100"  >&lt;p&gt;Teresa,&lt;br/&gt;
I&apos;m looking at your patch and the comments in this Issue.  The Patch 2 approach looks good to me.  I suggest we go ahead with this patch for both 1.0.x and 1.1.0.  If there are tweaks (desired or required) to the implementation, then we&apos;ll deal with them.  At least with this patch, we now have a working LoadFetchGroup annotation.&lt;/p&gt;

&lt;p&gt;Question concerning the tests.  They all seem to run just fine, but is the current package the proper location (org.apache.openjpa.persistence.query)?  I&apos;m thinking a separate fetchgroup package would be better.  And, we &apos;re bound to add more tests along the way.  If that&apos;s okay with you, I&apos;ll do the move, you don&apos;t have to supply another patch.  I will also add the required license header on the testcases.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12531601" author="kwsutter" created="Mon, 1 Oct 2007 20:12:48 +0100"  >&lt;p&gt;Resolved in 1.0.x Branch and 1.1.0 Trunk.&lt;/p&gt;</comment>
                            <comment id="12537025" author="pcl" created="Tue, 23 Oct 2007 15:42:25 +0100"  >&lt;p&gt;It looks like this patch might have a performance impact due to the additional time required to compute field inclusion. We should consider other implementation routes or potentially rolling this back on the 1.0.x branch prior to 1.0.1, depending on what we decide our release criteria should be.&lt;/p&gt;</comment>
                            <comment id="12538561" author="clr" created="Mon, 29 Oct 2007 19:03:33 +0000"  >&lt;p&gt;I&apos;m also concerned about the performance impact of the fix. &lt;/p&gt;

&lt;p&gt;The load fetch-group should not be a compute-intensive operation. It&apos;s meant to be a one-level operation, not a multi-level or recursive operation.&lt;/p&gt;

&lt;p&gt;The reason to use load fetch-group is to identify a fetch group to use when a field declared as a lazy loaded field (not declared in a currently active fetch-group at the time the instance it&apos;s a member of is fetched) is referenced. So it only applies when there is a requirement to load an unloaded field. &lt;/p&gt;

&lt;p&gt;&amp;gt; 1) when a field X which is part of the loadFetchGroup L but it is not an eager fetch field, field X can&apos;t determine whether it can be fetched or not because it is not sure that the owner of this loadFetchGroup will be loaded . Therefore, we have to wait until the owner of the loadFetchGroup is fetched. &lt;/p&gt;

&lt;p&gt;There is a difference between fetching a field and loading a field. Fetching a field is getting it from the datastore. Loading a field is fetching a field that is not currently loaded. For most operations (find, query, navigate) only the current fetch plan is needed to decide whether a field is fetched or not (a simple union of all fetch-groups in the fetch plan, disregarding the load fetch-group. The only time the load fetch-group is used is for field access operations where the instance is in memory but the field wasn&apos;t fetched before. This is due to one of two reasons: the instance is hollow and a field is accessed; the instance is not hollow and a field is accessed that wasnt&apos; part of the fetch plan when the instance was fetched.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) when a field Y has a FetchGroup associated with , then field Y is required to fetch. &lt;br/&gt;
&amp;gt;   ==&amp;gt; Then we need further to check whether this field Y has any loadFetchGroup. If field Y has a loadFetchGroup L; then we need to get the fields that associate with L. &lt;/p&gt;

&lt;p&gt;I&apos;m not really following this argument. The relevant part of the specification (JDO) is:&lt;/p&gt;

&lt;p&gt;&amp;lt;spec&amp;gt;&lt;br/&gt;
When the application dereferences an unloaded field, the JDO implementation uses the current fetch plan and the load-fetch-group of the field to create the fetch strategy for the field. The specific behavior depends on whether the unloaded field is a relation to another persistence-capable class.&lt;br/&gt;
for non-relation fields, the current fetch plan is applied to the field&apos;s owning instance, and the fields in the field&apos;s load-fetch-group, plus the field itself are added to the list of fields.&lt;br/&gt;
for relation fields, the fields in the owning instance are fetched as immediately above, and additionally the instances referred by the field are loaded using the current fetch plan plus the field&apos;s load-fetch-group.&lt;br/&gt;
&amp;lt;/spec&amp;gt;&lt;/p&gt;

&lt;p&gt;From the discussion, it sounds like patch 1 is more appropriate to implement the intent.&lt;/p&gt;</comment>
                            <comment id="12538646" author="kwsutter" created="Tue, 30 Oct 2007 01:56:02 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
Teresa is out for a week or so, so I will attempt to represent her interests on this issue...&lt;/p&gt;

&lt;p&gt;First thing is that there were several problems with the FetchGroup and FetchAttribute processing when Teresa started the investigation.  She worked with Pinaki on several of the problems:  &lt;a href=&quot;http://www.nabble.com/FetchGroup-and-FetchAttribute-question-tf4357034.html#a12416564&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/FetchGroup-and-FetchAttribute-question-tf4357034.html#a12416564&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One of the problems that was not resolved directly by Pinaki was related to the LoadFetchGroup processing.  In a nutshell, LoadFetchGroup just didn&apos;t work per the documentation (or maybe our interpretation of the documentation).&lt;/p&gt;

&lt;p&gt;In any case, she opened this Issue to resolve the problem with LoadFetchGroup.  Although it may not be the best performing, at least it is now functional.  So, from the standpoint of whether this fix should be part of 1.0.x or not, I would say that it&apos;s better to have a functional LoadFetchGroup or not at all.&lt;/p&gt;

&lt;p&gt;When I look back on this Issue, it discusses two patches, but as far as I can tell, there was only one patch ever attached to this issue.  There was the separate patch file for the testcase, but there was only a single runtime code patch.  From my discussions with Teresa, I believe the first patch idea was beyond her current understanding of the OpenJPA code base.  She could develop the patch #2 idea based on the current architecture &amp;#8211; although the performance may not be quite as good.&lt;/p&gt;

&lt;p&gt;Bottom line, I agree that we could probably improve the implementation of LoadFetchGroup to be better performing.  But, my take is that we should focus our efforts on this improvement in the 1.1.0 trunk instead of pulling the functional implementation from the 1.0.x branch.  Unless someone is volunteering to redo the fix for 1.0.x to be both functional and better performing, and a timely manner...  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12538649" author="pcl" created="Tue, 30 Oct 2007 02:52:18 +0000"  >&lt;p&gt;&amp;gt; But, my take is that we should focus our efforts on this improvement in the &lt;br/&gt;
&amp;gt; 1.1.0 trunk instead of pulling the functional implementation from the 1.0.x branch.&lt;/p&gt;

&lt;p&gt;I&apos;m not as concerned with the 1.0.x behavior as with the 1.1.0 behavior, since I&apos;m not in the process of releasing a product based on the 1.0.x branch.&lt;/p&gt;

&lt;p&gt;I do believe that the performance degradation is significant and important.&lt;/p&gt;

&lt;p&gt;&amp;gt; Unless someone is volunteering to redo the fix for 1.0.x to be both functional&lt;br/&gt;
&amp;gt; and better performing, and a timely manner... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;I&apos;m a bit concerned about the sentiment behind this statement. I think that performance regressions are big deals, and based on what I&apos;ve seen from the performance impact of this patch, I basically think that the patch does not work. Sure, it resolves the issue, but it causes regressions in other areas of the product. As I mentioned, I&apos;m ok letting things slide for 1.0.1, given that I understand that the goal of 1.0.1 is to get a product out. But I do not like it, and personally would prefer to see the behavior either fixed in a performant manner or backed out, especially in what we are claiming is a maintenance branch. And I definitely think that resolving this has to be a top priority.&lt;/p&gt;</comment>
                            <comment id="12538768" author="kwsutter" created="Tue, 30 Oct 2007 13:22:37 +0000"  >&lt;p&gt;&amp;gt;  I&apos;m a bit concerned about the sentiment behind this statement. I think that performance regressions are big deals, and based on what I&apos;ve seen from the performance impact of this patch, I basically think that the patch does not work. Sure, it resolves the issue, but it causes regressions in other areas of the product. As I mentioned, I&apos;m ok letting things slide for 1.0.1, given that I understand that the goal of 1.0.1 is to get a product out. But I do not like it, and personally would prefer to see the behavior either fixed in a performant manner or backed out, especially in what we are claiming is a maintenance branch. And I definitely think that resolving this has to be a top priority.&lt;/p&gt;

&lt;p&gt;Sorry, but I was reacting to your statements about potentially pulling this fix from the 1.0.1 release.  As you have pointed out, we&apos;re a little behind the eight ball since we&apos;re trying to close down the 1.0.1 release for an upcoming product release.  So, pulling the existing fix out of the 1.0.x branch would affect some of our product test efforts and cause some unnecessary churn (IMHO).&lt;/p&gt;

&lt;p&gt;From a JPA perspective, the use of LoadFetchGroup is an extension.  From our test efforts, it was shown not to work per our understanding of the documentation (and Pinaki&apos;s assistance).  So, the problems discovered were resolved and put into the maintenance release.  These were functional fixes.  We knew there might be some performance concerns, but not being experts in this area, we were not aware of how there might be &quot;regressions in other areas of the product&quot;.  I&apos;m assuming you are referring to the JDO extensions...&lt;/p&gt;

&lt;p&gt;So, where do we go from here?  As you can tell, I would prefer to leave the fixes in the 1.0.x branch.  We have re-opened the Issue.  And, when Teresa comes back, she can take another look at a fix that performs better.  If we can&apos;t wait, then somebody else will have to volunteer to take ownership on this Issue.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12538791" author="pcl" created="Tue, 30 Oct 2007 14:58:35 +0000"  >&lt;p&gt;Maybe I should be more clear about the impact. Our tests seem to indicate that this causes performance regressions across the board, not just when the feature is used. That is, the current implementation appears to slow down all relationship traversals and pk loads that do not come from cache.&lt;/p&gt;

&lt;p&gt;I haven&apos;t confirmed that 100%, but that&apos;s what the initial runs seem to show.&lt;/p&gt;</comment>
                            <comment id="12539137" author="pcl" created="Wed, 31 Oct 2007 18:02:14 +0000"  >&lt;p&gt;In our tests, we see a 20% performance regression due to this change. Our tests do not use the LoadFetchGroup feature. This is from a benchmark that queries an entity by a non-pk field and has eager relationship loading enabled for two other entities. The query-cache and the data-cache are large enough so that no DB calls occur during steady-state (and this has been verified by the profiles).&lt;/p&gt;</comment>
                            <comment id="12539165" author="kwsutter" created="Wed, 31 Oct 2007 19:36:50 +0000"  >&lt;p&gt;Thanks, Patrick, for the additional detail.  Now I understand your concern.  And, I take that your profiling has shown that the performance degradation is due to the changes introduced by this Issue?  Can you share any more details?  Thanks.&lt;/p&gt;

&lt;p&gt;So, we&apos;re in kind of a quandary...  Do we cut the 1.0.1 release with this change which makes LoadFetchGroups functional, or do we remove this change to get the performance back up?&lt;/p&gt;

&lt;p&gt;I&apos;m surprised that we haven&apos;t detected a performance problem since we introduced this change.  I will check on that as well.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12539205" author="ppoddar@apache.org" created="Wed, 31 Oct 2007 22:45:44 +0000"  >&lt;p&gt;&amp;gt; In a nutshell, LoadFetchGroup just didn&apos;t work per the documentation (or maybe our interpretation of the documentation). &lt;/p&gt;

&lt;p&gt;This statement &amp;#8211; the root of this change &amp;#8211; may require more validation. I have recently tried to verify LoadFetchGroup behavior with few tests and they are coming out positive. At this point, I will not contest the observation as my tests may not  cover many variations. Yet, even if the above statement is true, we should first investigate why the existing (i.e. before Teresa&apos;s patch) mechanics is not working.    &lt;/p&gt;

&lt;p&gt;The &apos;existing mechanics&apos; is more in the spirit of how Craig has explained and elaborated LoadFetchGroup. Essentially, LoadFetchGroup is &lt;b&gt;not&lt;/b&gt; taken into account when data is loaded from datastore. It is where the tight inner-loop evaluates for each field if it is to be &apos;fetched&apos; from the datastore. Given high frequency of this evaluation &amp;#8211; Patrick&apos;s concern on performance degradation is certainly valid. &lt;/p&gt;

&lt;p&gt;Before the instance is returned to the caller, the fields are checked again if they cause any other field be loaded because LoadFecthGroup. At that point, if field f has a LoadFetchGroup L and L is not part of the active fetch configuration then &lt;b&gt;temporarily&lt;/b&gt; add L to the active FetchConfiguration and go for another &apos;fetch&apos; (i.e. from the datastore).  &lt;/p&gt;

&lt;p&gt;See StateManagerImpl.java for details:&lt;/p&gt;

&lt;p&gt;    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Load the given field&apos;s fetch group; the field itself may already be&lt;/li&gt;
	&lt;li&gt;loaded if it is being set by the user.&lt;br/&gt;
     */&lt;br/&gt;
    protected void loadField(int field, int lockLevel, boolean forWrite,  boolean fgs) &lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12539221" author="clr" created="Wed, 31 Oct 2007 23:51:47 +0000"  >&lt;p&gt;&amp;gt; Before the instance is returned to the caller, the fields are checked again if they cause any other field be loaded because LoadFecthGroup. At that point, if field f has a LoadFetchGroup L and L is not part of the active fetch configuration then &lt;b&gt;temporarily&lt;/b&gt; add L to the active FetchConfiguration and go for another &apos;fetch&apos; (i.e. from the datastore). &lt;/p&gt;

&lt;p&gt;This sounds wrong. The effect of the load fetch group should be part of the fetch strategy, and no post-fetch analysis should be done. The only time the load fetch group is used is if a field f is accessed and it&apos;s not already fetched. &lt;/p&gt;

&lt;p&gt;The intent of the load fetch group is to augment the fetch plan under which the persistent instance was fetched. It&apos;s designed to provide an intelligent fetch strategy for the lower-usage cases where some use needs field f1 (not in any fetch group in the current fetch plan) and when using field f1 you want to also fetch fields f2, f3, and f4, that are also not part of the current fetch plan.&lt;/p&gt;</comment>
                            <comment id="12539268" author="kwsutter" created="Thu, 1 Nov 2007 02:08:00 +0000"  >&lt;p&gt;Due to the performance concern comments, I have backed out these changes in my own sandbox and am running our performance suites trying to validate the problem.  If the results indicate such a significant performance degradation, then I will gladly back out the changes until we figure out the proper solution.&lt;/p&gt;

&lt;p&gt;One thing that I immediately noticed is that the testcase that we committed with these changes no longer works.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/viewcvs.cgi//openjpa/branches/1.0.x/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/TestFetchGroup.java/?rev=580995&amp;amp;view=markup&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewcvs.cgi//openjpa/branches/1.0.x/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/TestFetchGroup.java/?rev=580995&amp;amp;view=markup&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, maybe the first step is to validate the testcase.  Could one of the interested parties that knows more about the intent of LoadFetchGroups (better than me) review this testcase?&lt;/p&gt;

&lt;p&gt;Thanks, &lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12539270" author="pcl" created="Thu, 1 Nov 2007 02:18:44 +0000"  >&lt;p&gt;&amp;gt; I take that your profiling has shown that the performance degradation&lt;br/&gt;
&amp;gt; is due to the changes introduced by this Issue? Can you share any more details?&lt;/p&gt;

&lt;p&gt;We&apos;ve seen a ~ 30% regression since an OpenJPA snapshot from a few months back. Rolling back this particular change cuts that to a 10% regression.&lt;/p&gt;</comment>
                            <comment id="12539276" author="clr" created="Thu, 1 Nov 2007 03:47:02 +0000"  >&lt;p&gt;I&apos;m looking at the test case TestFetchGroup.&lt;/p&gt;

&lt;p&gt;The test cases should check firstName and lastName in addition to the other fields.&lt;/p&gt;

&lt;p&gt;The difference between test001 and test002 isn&apos;t checked. In test001, lastName and firstName should be not null because they are in the default fetch group. In test002, they should be null because the reset fetch group has no fields.&lt;/p&gt;

&lt;p&gt;In test003, the only fields fetched should be the id and rating. In particular, address, firstName, and lastName should not be fetched. This test case seems to be central to the discussion here, and it appears to be checking the wrong result.&lt;/p&gt;

&lt;p&gt;The comments in the assertions don&apos;t match what&apos;s being checked. And the typos are very distracting.&lt;/p&gt;

&lt;p&gt;In test008 there are two EntityManagers used, and it doesn&apos;t appear that the usage of oem and oem1 are correct. What is the intent of having two em&apos;s?&lt;/p&gt;</comment>
                            <comment id="12539408" author="kwsutter" created="Thu, 1 Nov 2007 16:19:17 +0000"  >&lt;p&gt;Okay, my performance runs are not quite as drastic as the ones cited by Patrick, but they still are not great.  And, given the concerns about our interpretation of the LoadFetchGroups processing (via the testcase analysis), I will back out these changes from both the 1.0.x and 1.1.0 branches.  I will do this this afternoon.&lt;/p&gt;

&lt;p&gt;Thanks for the insights and the patience while we figure this out.  Teresa should be back in the saddle next week and we can figure out the proper solution and proper interpretation of LoadFetchGroups at that time (unless the collective &quot;we&quot; can do it before she gets back).&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12539435" author="ppoddar@apache.org" created="Thu, 1 Nov 2007 18:38:18 +0000"  >&lt;p&gt;Test case for LoadFetchGroup.&lt;br/&gt;
These test cases employ only basic fields (no relation). They all pass in my local environment.&lt;/p&gt;

&lt;p&gt;Craig, will you please review the cases to see that they are testing correct semantics of load-fetch-group? &lt;br/&gt;
If you think that the test cases are alright then I will add relation fields in the mix.&lt;/p&gt;</comment>
                            <comment id="12539615" author="kwsutter" created="Fri, 2 Nov 2007 15:31:56 +0000"  >&lt;p&gt;Moving the fix version for this Issue from 1.0.1 to 1.0.2.&lt;/p&gt;</comment>
                            <comment id="12539678" author="kwsutter" created="Fri, 2 Nov 2007 19:25:05 +0000"  >&lt;p&gt;The fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-403&quot; title=&quot;LoadFetchGroup patch (OPENJPA-370) introduces NPE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-403&quot;&gt;&lt;del&gt;OPENJPA-403&lt;/del&gt;&lt;/a&gt; was due to the code originally dropped for &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-370&quot; title=&quot;LoadFetchGroup annotation was not recognized during the fetch1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-370&quot;&gt;&lt;del&gt;OPENJPA-370&lt;/del&gt;&lt;/a&gt;.  If portions of the original code patch are ever used again for &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-370&quot; title=&quot;LoadFetchGroup annotation was not recognized during the fetch1&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-370&quot;&gt;&lt;del&gt;OPENJPA-370&lt;/del&gt;&lt;/a&gt;, then you should be aware of the quick patch required for &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-403&quot; title=&quot;LoadFetchGroup patch (OPENJPA-370) introduces NPE&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-403&quot;&gt;&lt;del&gt;OPENJPA-403&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12539762" author="clr" created="Sat, 3 Nov 2007 01:14:34 +0000"  >&lt;p&gt;The test case doesn&apos;t have an example of where load fetch group is used. The only tests are for regular fetch groups. Some specific comments:&lt;/p&gt;

&lt;p&gt;1. The test case should use spaces not tabs for delimiters.&lt;/p&gt;

&lt;p&gt;2. The tests should use commit not rollback to detach the instances.&lt;/p&gt;

&lt;p&gt;3. The tests testFieldsInFetchGroupAndLoadFetchGroupAreLoaded and testFieldsInFetchGroupAndLoadFetchGroupAreLoadedUsingFind&lt;/p&gt;

&lt;p&gt;don&apos;t test load fetch groups. I&apos;d suggest renaming them and changing their expected results as follows:&lt;/p&gt;

&lt;p&gt;	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Verifies that when a field with a LoadFetchGroup L is fetched, the fields&lt;/li&gt;
	&lt;li&gt;included in L are not fetched either.&lt;br/&gt;
	 *&lt;br/&gt;
	 */&lt;br/&gt;
	public void testFieldsInFetchGroupAndNotLoadFetchGroupAreLoaded() 
{
		OpenJPAEntityManager em = emf.createEntityManager();
		List&amp;lt;PObject&amp;gt; pcs = findByQuery(em, &quot;SELECT p FROM PObject p&quot;, &quot;f3&quot;);
		for (PObject pc:pcs) 
			assertLoaded(em, pc, &quot;f3&quot;);
	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;	public void testFieldsInFetchGroupAndNotLoadFetchGroupAreLoadedUsingFind() &lt;/p&gt;
{
		OpenJPAEntityManager em = emf.createEntityManager();
		PObject pc = findById(em, OID, &quot;f3&quot;);
		assertLoaded(em, pc, &quot;f3&quot;);
	}

&lt;p&gt;To test load fetch group you need to add internal methods that load field f3 after querying or finding it and then commit the transaction. Something like findByIdAndAccessField (OpenJPAEntityManager em, String field, Object oid, String... fetchGroups). After finding the object, it would access the named field and then commit. Similar functionality is needed for findByQueryAndAccessField.&lt;/p&gt;

&lt;p&gt;To do this, I would refactor isLoaded into isLoaded and loadField. The loadField can be used by the findByIdAndAccessField and findByQueryAndAccessField methods to access a field.&lt;/p&gt;
</comment>
                            <comment id="12539878" author="clr" created="Sat, 3 Nov 2007 05:42:46 +0000"  >&lt;p&gt;Hi Pinaki,&lt;/p&gt;

&lt;p&gt;Just saw this message. I&apos;ll take a look later today.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Craig&lt;/p&gt;



&lt;p&gt;Craig Russell&lt;br/&gt;
Architect, Sun Java Enterprise System &lt;a href=&quot;http://java.sun.com/products/jdo&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/products/jdo&lt;/a&gt;&lt;br/&gt;
408 276-5638 &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;mailto:Craig.Russell@sun.com&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;Craig.Russell@sun.com&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/mail_small.gif&quot; height=&quot;12&quot; width=&quot;13&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;
P.S. A good JDO? O, Gasp!&lt;/p&gt;
</comment>
                            <comment id="12540001" author="clr" created="Sat, 3 Nov 2007 21:20:34 +0000"  >&lt;p&gt;Joe Grassel commented:&lt;br/&gt;
&amp;gt; I&apos;m wondering what the intent of the LoadFetchGroup function was when it was designed.  The manual states:&lt;/p&gt;

&lt;p&gt;&amp;gt; &quot;A field can also declare a load fetch group.  When you access a lazy loaded field for the first time, OpenJPA makes a datastore trip to fetch that field&apos;s data.  Sometimes, however, you know that whenever you access a lazy field A, you&apos;re likely to access lazy fields B and C as well.  Therefore, it would be more efficient to fetch the data for A, B, and C in the same datastore trip.  By setting A&apos;s load fetch group to the name of a fetch group containing B and C, you can tell OpenJPA to load all of these fields together when A is first accessed.&quot;&lt;/p&gt;

&lt;p&gt;&amp;gt; I guess I have a question about the function I&apos;d like clarified:&lt;/p&gt;

&lt;p&gt;&amp;gt; What does it mean when B and C are co-fetched in the same datastore trip?  Is the data just loaded into the entitymanager&apos;s datacache and held there until a hit is made on it (when the application finally reads the entity persistable property for the first time, this would save an additional hit to the database) or is it genuinely considered eagerly fetched (entity persistable property field is populated when the entity object is constructed by the find/query operation?)&lt;/p&gt;

&lt;p&gt;It&apos;s useful to highlight when the load fetch group behavior is activated: when you access a lazy loaded field for the first time. This is not done during query or find, but only when the lazy loaded field is accessed (from the application) and it&apos;s not already loaded. &lt;/p&gt;

&lt;p&gt;To your other point, if fields B and C are in field A&apos;s load fetch group, then accessing field A makes is available in the detached instance, and fields B and C are also available in the detached instance as if they were accessed at the same time as field A was accessed.&lt;/p&gt;

&lt;p&gt;&amp;gt; This makes a big difference in what an application programmer should expect.  If the former, then LoadFetchGroup is just a datastore optimization that doesn&apos;t really make B and C eagerly loaded.  It just saves a datastore trip should they ever be loaded.  That means that if the entity becomes detached, B and C are not available because they were never accessed when the entity was managed by the persistence context.&lt;/p&gt;

&lt;p&gt;Yes, this does affect the fields that are detached. If fields B and C are loaded, then they are also loaded in the detached instance. But I&apos;d be careful calling this behavior eager loading. Eager loading is done for fields based on the fetch plan in effect for a find or query that first loads the instance into memory. The load fetch group isn&apos;t considered here. The load fetch group is only activated when you access a field that wasn&apos;t eagerly loaded.&lt;/p&gt;

&lt;p&gt;&amp;gt; The latter, and the function behavior I expected, if data is acquired from the datastore hit, then I&apos;d expect it to be available for reading from the entity object, even if the field was not access prior to becoming detached, since active fetch groups (or those referenced by a load fetch group) effectively nullify the LAZY loading setting on an affected persistable attribute.  Knowing what behavior to expect is especially important, especially in the situation where entities are acquired with a transaction-scoped persistence context when then find/query occurs outside of a transaction.  I&apos;d expect A to be loaded because it was referenced in an active fetch group, and B and C to be loaded (and referenceable in the entity) due to the load fetch group setting.&lt;/p&gt;

&lt;p&gt;No, here&apos;s the difference between active fetch groups and load fetch groups. If you want fields B and C to be loaded when the instance is first accessed via find or query, then you need to include B and C in one of the active fetch groups when you execute find or query. If you want fields B and C to be loaded only when some lazy loaded field is accessed, then put B and C into a fetch group and define that fetch group as the load fetch group of the lazy loaded fields that you want to trigger the fetch of fields B and C. &lt;/p&gt;

&lt;p&gt;A slightly different slant on this is that if field A is in some fetch group FG1, and use of field A requires fields B and C, then any fetch group that includes A (e.g. FG1) should also include B and C. There&apos;s no need for a load fetch group here. &lt;/p&gt;

&lt;p&gt;&amp;gt; Also, I noticed that some of the examples closed the entitymanager in order to test loadfetchgroup behavior &amp;#8211; what about when an entity is just detached from the persistence context, em.close() is one way to approach it, but that only works in JSE and JEE: Application Managed Persistence Contexts.  That&apos;s not going to work in Container Managed Persistence Contexts, and detachment is probably going to be frequently seen by Transaction Scoped persistence contexts, and situations where entities are serialized across the wire to distinct application components (say, to an application client, a web service, or via RMIIIOP to a remote application server&apos;s ejb/web container.)  I would expect that data to be available due to the fetchgroup/loadfetchgroup configuration.  &lt;/p&gt;

&lt;p&gt;The test cases use em.clear() or em.close() to detach the instances, but any operation that detaches instances, including serialization, should exhibit the behavior.&lt;/p&gt;

&lt;p&gt;&amp;gt; This includes both non-relational and relational lazy-loaded fields.&lt;/p&gt;

&lt;p&gt;I don&apos;t understand this comment. Are you referring to relationship fields?&lt;/p&gt;</comment>
                            <comment id="12540024" author="clr" created="Sat, 3 Nov 2007 23:31:38 +0000"  >&lt;p&gt;Joe Grassel commented:&lt;br/&gt;
&amp;gt; So, for B and C to be loaded, the lazy-loaded field that has the load fetch group annotation has to be accessed while the entity is still managed.  When A is faulted in, it faults B and C in automatically, even if they are never accessed while the entity is managed.&lt;/p&gt;

&lt;p&gt;True.&lt;/p&gt;

&lt;p&gt;&amp;gt; So given the entity FGEmployee (using this since the code is already available as an attachment, and keeps my message shorter), which (all, some, or none) of the following LoadFetchGroup scenarios are valid:&lt;/p&gt;

&lt;p&gt;&amp;gt; Scenario A:&lt;br/&gt;
&amp;gt; Starting environment:  No fetch groups other then &quot;default&quot; are active, persistence context is clear of any managed entities&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) Start a transaction&lt;br/&gt;
&amp;gt; 2) Find/Query FGEmployee&lt;br/&gt;
&amp;gt; 3) Read rating (this causes addressGroup to be faulted in, due to the @LoadFetchGroup on rating)&lt;br/&gt;
&amp;gt; 4) Commit the transaction&lt;br/&gt;
&amp;gt; 5) Clear the persistence context (not necessary for TS-CM PCs)&lt;br/&gt;
&amp;gt; 6) Read rating, since it was read while the entity was managed in step 3, its data should be available&lt;br/&gt;
&amp;gt; 7) Read addressGroup, although it was not read while the entity was managed, it was faulted in when addressGroup was accessed in step 3, because of the @LoadFetchGroup, so it should be available.  Other lazy loaded fields, like description, dept, manager, are not available at this point since they were never accessed while the entity was managed, and since default was the only active fetch group, they would have observed lazy loading behavior.&lt;/p&gt;

&lt;p&gt;True.&lt;/p&gt;

&lt;p&gt;&amp;gt; Scenario B:&lt;br/&gt;
&amp;gt; Starting environment: Active Fetch Groups: &quot;default&quot;, &quot;RatingFetchGroup&quot;.  Persistence context is clear of any managed entities&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) Start a transaction&lt;br/&gt;
&amp;gt; 2) Find/Query FGEmployee&lt;br/&gt;
&amp;gt; 3) Commit the Transaction&lt;br/&gt;
&amp;gt; 4) Clear the persistence context&lt;/p&gt;

&lt;p&gt;&amp;gt; (Note, the first four steps can be condensed to just 1 for a TS-CM PS if performed outside of a transaction)&lt;/p&gt;

&lt;p&gt;&amp;gt; 5) Read rating, since it was targeted by the RatingFetchGroup, it should be available even though it was never accessed while the entity was managed.  This has been tested and proven that this is the observed behavior for persistable attributes identified by fetch groups.&lt;/p&gt;

&lt;p&gt;True.&lt;/p&gt;

&lt;p&gt;&amp;gt; 6) Read addressGroup.  This is the rub.  Is it available?  ratings was loaded in because it was part of an active fetch plan.  I would expect that since rating was loaded, and since rating has declared that addressGroup should also be loaded via its @LoadFetchGroup annotation, then addressGroup should be available as well.&lt;/p&gt;

&lt;p&gt;No. Rating was not accessed when not loaded, so its load fetch group is not used. &lt;/p&gt;

&lt;p&gt;The behavior that you said you would expect does not need any additional concept. It can be accomplished just by defining your fetch groups. The reason we added load fetch groups was to handle the case where the application took a small probability path and accessed a field that is normally not needed. Because the field was now accessed, we need to go to the datastore. And without load fetch group, we would not be able to describe the fields needed by the small probability path, and would end up faulting several fields individually. With load fetch group, we can optimally fault in all the related fields.&lt;/p&gt;

&lt;p&gt;&amp;gt; Other lazy loaded fields, like description, dept, manager, are not available at this point since they were never accessed while the entity was managed, and were never a member of any of the active fetch groups, they would have observed lazy loading behavior.&lt;/p&gt;

&lt;p&gt;True.&lt;/p&gt;

&lt;p&gt;&amp;gt; The documentation as it is written makes it sound like both scenarios are valid &amp;#8211; any situation where rating&apos;s data is available, addressGroup&apos;s data is also supposed to be available, thanks to the @LoadFetchGroup.  Which scenarios are valid interpretations of the function?  Scenario A, Scenario B, both, or neither?&lt;/p&gt;

&lt;p&gt;A, not B. &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;Yes, this does affect the fields that are detached. If fields B and C are loaded, then they are also loaded in the detached instance. But I&apos;d be careful calling this behavior eager loading. Eager loading is done for fields based on the fetch plan in effect for a find or query that first loads the instance into memory. The load fetch group isn&apos;t considered here. The load fetch group is only activated when you access a field that wasn&apos;t eagerly loaded.&lt;/p&gt;

&lt;p&gt;&amp;gt;So, this means that Scenario A is the only scenario where @LoadFetchGroup will work?  Since rating, in Scenario B, would not be considered a lazy loaded field because it is a member of an active fetch plan?&lt;/p&gt;

&lt;p&gt;True. Rating, in scenario B, is not lazy loaded. It&apos;s eagerly loaded. &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; A slightly different slant on this is that if field A is in some fetch group FG1, and use of field A requires fields B and C, then any fetch group that includes A (e.g. FG1) should also include B and C. There&apos;s no need for a load fetch group here.&lt;/p&gt;

&lt;p&gt;&amp;gt; So, in the situation where we want both B and C to be loaded if A is loaded, we would either:&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) Do Scenario A&lt;br/&gt;
&amp;gt; 2) Have fetch groups that include A, B, and C active when the find/query is performed.&lt;/p&gt;

&lt;p&gt;True.&lt;/p&gt;

&lt;p&gt;&amp;gt; If that is the case, then I think the documentation really needs to be updated to make that crystal clear.  &lt;/p&gt;

&lt;p&gt;I agree some examples would be useful here. Volunteers?&lt;/p&gt;

&lt;p&gt;To update the description, we could change &quot;When you access a lazy loaded field for the first time&quot; to &quot;When you access a lazy loaded field by the application for the first time after being queried or found&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; Otherwise, it will be easy to assume (as I did) that @LoadFetchGroups will always be triggered if the persistable attribute annotated with it is loaded, be it approached in Scenario A or B.  By saying &quot;you can tell OpenJPA to load all of these fields together when A is first accessed.&quot; that sounds like B and C will always be loaded along with A, no matter what the loading circumstance (A loaded by a getter method while the entity is managed, or A loaded in by fetch group).&lt;/p&gt;

&lt;p&gt;So you understood &quot;When you access a lazy loaded field for the first time&quot; that &quot;access&quot; is a find or query? We meant to intend &quot;access&quot; to mean &quot;access by the application&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;This includes both non-relational and relational lazy-loaded fields.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;I don&apos;t understand this comment. Are you referring to relationship fields?&lt;/p&gt;

&lt;p&gt;&amp;gt;Yes, making sure that both attributes that make sense to be lazy loaded (Strings, blobs, etc.) and relationships (any, although the collection based relationships are lazy by default) are included under consideration here.&lt;/p&gt;

&lt;p&gt;Yes, the same rules apply to relationship fields. If they are lazy loaded, not part of any active fetch group, and then accessed by the application; when they are fetched from the datastore, the current fetch plan is augmented with the load fetch group of the relationship field and the fields that are in the augmented fetch plan are loaded from the datastore. This might load additional fields in the instance containing the lazy loaded relationship field, as well as loading the related object(s) according to the augmented fetch plan.&lt;/p&gt;</comment>
                            <comment id="12541124" author="tckan1" created="Thu, 8 Nov 2007 20:20:47 +0000"  >&lt;p&gt;I modified the TestFetchGroup testcase based on the current discussion and understanding of the fetch group and loadFetchGroup concept.. The testcases work with the current implementation now. However, I have one question about Craig&apos;s comment on the testcase 002, &lt;br/&gt;
Craig said,&lt;br/&gt;
&quot;The difference between test001 and test002 isn&apos;t checked. In test001, lastName and firstName should be not null because they are in the default fetch group. In test002, they should be null because the reset fetch group has no fields.&quot;&lt;br/&gt;
According to the documentation, resetFetchGroup will reset back to the global configuration which I interpreted it as the default fetch group plus the property defined in the persistence.xml file . That&apos;s how the current implementaiton work at this moment. Therefore, both firstName and lastName are still available (not null) even though resetFetchGroup has been called. &lt;br/&gt;
Please confirm the interpretation! If this is not true, then we have a bug in the openjpa for the resetFetchGroup.&lt;/p&gt;

&lt;p&gt;Thanks&lt;br/&gt;
Teresa&lt;/p&gt;

</comment>
                            <comment id="12541187" author="pcl" created="Fri, 9 Nov 2007 00:25:00 +0000"  >&lt;p&gt;I believe that resetFetchGroup should reset the current fetch groups, not the current state of the instances.&lt;/p&gt;</comment>
                            <comment id="12541198" author="clr" created="Fri, 9 Nov 2007 01:43:22 +0000"  >&lt;p&gt;&amp;gt; According to the documentation, resetFetchGroup will reset back to the global configuration which I interpreted it as the default fetch group plus the property defined in the persistence.xml file . That&apos;s how the current implementaiton work at this moment. Therefore, both firstName and lastName are still available (not null) even though resetFetchGroup has been called. &lt;br/&gt;
&amp;gt; Please confirm the interpretation! If this is not true, then we have a bug in the openjpa for the resetFetchGroup. &lt;/p&gt;

&lt;p&gt;You&apos;re right here. There is nothing in the JDO spec corresponding to resetFetchGroups, so my comments will need to be updated. I erroneously thought that resetFetchGroups referred to clearFetchGroups. Which we should add as a test case to make sure that clear does in fact remove all fetch groups. So in the test after resetFetchGroups, firstName and lastName should be available.&lt;/p&gt;

&lt;p&gt;I also noticed we have a conflict between the javadoc and the documentation. The javadoc refers to FetchConfiguration while the manual refers to FetchPlan. FetchPlan is an interface in JDO, whereas FetchConfiguration is an OpenJPA interface. So we&apos;re documenting FetchPlan in the manual but implementing FetchConfiguration.&lt;/p&gt;

&lt;p&gt;I&apos;ll raise a separate JIRA for this.&lt;/p&gt;
</comment>
                            <comment id="12541339" author="tckan1" created="Fri, 9 Nov 2007 15:02:34 +0000"  >&lt;p&gt;Craig,&lt;br/&gt;
Yes, the clearFetchGroup() performs as expected. All fields are cleared even the default fetch group. I added the test009 to include the clearFetchGroup() to the TestFetchGroup.patch.&lt;/p&gt;
</comment>
                            <comment id="12564239" author="pcl" created="Thu, 31 Jan 2008 00:23:46 +0000"  >&lt;p&gt;I believe that the upshot of this is that it works as designed. If there are remaining issues that I did not notice, please expand on them.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12380475">OPENJPA-403</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12368917" name="ASF.LICENSE.NOT.GRANTED--smime.p7s" size="2462" author="clr" created="Sat, 3 Nov 2007 05:42:46 +0000"/>
                            <attachment id="12366300" name="OPENJPA_370_2.patch" size="10082" author="tckan1" created="Thu, 20 Sep 2007 18:07:51 +0100"/>
                            <attachment id="12369233" name="TestFetchGroup.patch" size="29613" author="tckan1" created="Fri, 9 Nov 2007 15:02:34 +0000"/>
                            <attachment id="12365887" name="TestFetchGroup.zip" size="7943" author="tckan1" created="Fri, 14 Sep 2007 20:18:08 +0100"/>
                            <attachment id="12368835" name="TestJIRA370.zip" size="3149" author="ppoddar@apache.org" created="Thu, 1 Nov 2007 18:38:18 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 28 Sep 2007 13:57:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>42064</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hz7kov:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>288322</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>