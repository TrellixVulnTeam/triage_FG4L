<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:43:41 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-134/OPENJPA-134.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-134] Extra unneeded SQL joins for OneToMany relationship with fetch type EAGER</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-134</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Running JPAConfiguration default setting for EagerFetchMode (FetchModeValue.EAGER_PARALLEL), &lt;br/&gt;
the SQL generated is sub-optimal.&lt;br/&gt;
Consider the following entities:&lt;/p&gt;

&lt;p&gt;                                     lineitems( OneToMany ) &lt;br/&gt;
            Order  &amp;lt;===========================&amp;gt; OrderItem&lt;br/&gt;
                                    order ( ManyToOne )&lt;/p&gt;


&lt;p&gt;Case 1:  why not combining 2 SQL to 1 SQL ?&lt;br/&gt;
=================================================================================================&lt;br/&gt;
Order.lineitmes(EAGER):&lt;br/&gt;
OrderItem.order(LAZY):&lt;/p&gt;

&lt;p&gt;Executing query: select o from Order o&lt;br/&gt;
2173  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; executing prepstmnt 1299336562 &lt;br/&gt;
SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr FROM Order t0&lt;br/&gt;
2213  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;40 ms&amp;#93;&lt;/span&gt; spent&lt;br/&gt;
2223  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; executing prepstmnt 1406424020 &lt;br/&gt;
SELECT t0.oid, t1.lid, t1.version, t1.cost, t1.order_oid, t1.part_partno, t1.quantity FROM Order t0 INNER JOIN OrderItem t1 ON t0.oid = t1.order_oid ORDER BY t0.oid ASC&lt;/p&gt;


&lt;p&gt;Case 2: extra unneeded LEFT OUTER JOIN,  if eliminated, the selection aliase t2 should change to t1:&lt;br/&gt;
=============================================================================================&lt;br/&gt;
Order.lineitmes(EAGER):&lt;br/&gt;
OrderItem.order(LAZY):&lt;/p&gt;

&lt;p&gt;Executing query: select o from Order o left join fetch o.lineitems&lt;br/&gt;
2403  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1314410072&amp;gt; executing prepstmnt 1500797300 &lt;br/&gt;
SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr, t2.order_oid, t2.lid, t2.version, t2.cost, t2.part_partno, t2.quantity FROM Order t0 LEFT OUTER JOIN OrderItem t1 ON t0.oid = t1.order_oid LEFT OUTER JOIN OrderItem t2 ON t0.oid = t2.order_oid ORDER BY t2.order_oid ASC&lt;/p&gt;


&lt;p&gt;Case  3: why not generating 1 SQL ?&lt;br/&gt;
==================================================================================================&lt;br/&gt;
Order.lineitmes(EAGER):&lt;br/&gt;
OrderItem.order(EAGER):&lt;/p&gt;

&lt;p&gt;Executing query: select o from Order o&lt;br/&gt;
2343  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; executing prepstmnt 384833264 SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr FROM Order t0&lt;br/&gt;
2383  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;40 ms&amp;#93;&lt;/span&gt; spent&lt;br/&gt;
2393  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; executing prepstmnt 1722705582 &lt;br/&gt;
SELECT t0.oid, t1.lid, t1.version, t1.cost, t2.oid, t2.version, t2.amount, t2.customer_countryCode, t2.customer_id, t2.delivered, t2.shipaddr, t1.part_partno, t1.quantity FROM Order t0 INNER JOIN OrderItem t1 ON t0.oid = t1.order_oid LEFT OUTER JOIN Order t2 ON t1.order_oid = t2.oid ORDER BY t0.oid ASC&lt;br/&gt;
2393  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;0 ms&amp;#93;&lt;/span&gt; spent&lt;br/&gt;
3134  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; executing prepstmnt 950548648 &lt;br/&gt;
SELECT t0.lid, t0.version, t0.cost, t1.oid, t1.version, t1.amount, t1.customer_countryCode, t1.customer_id, t1.delivered, t1.shipaddr, t0.part_partno, t0.quantity FROM OrderItem t0 LEFT OUTER JOIN Order t1 ON t0.order_oid = t1.oid WHERE t0.order_oid = ? &lt;span class=&quot;error&quot;&gt;&amp;#91;params=(int) 88&amp;#93;&lt;/span&gt;&lt;br/&gt;
3134  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1318342292&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;0 ms&amp;#93;&lt;/span&gt; spent&lt;/p&gt;


&lt;p&gt;Case 4:  duplicate selections and redundant joins&lt;br/&gt;
==================================================================================================&lt;br/&gt;
Order.lineitmes(EAGER):&lt;br/&gt;
OrderItem.order(EAGER):&lt;/p&gt;

&lt;p&gt;Executing query: select o from Order o left join fetch o.lineitems&lt;br/&gt;
2273  demo  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 1307463150&amp;gt; executing prepstmnt 1565154634 &lt;br/&gt;
SELECT t0.oid, t0.version, t0.amount, t0.customer_countryCode, t0.customer_id, t0.delivered, t0.shipaddr, t2.order_oid, t2.lid, t2.version, t2.cost, t3.oid, t3.version, t3.amount, t3.customer_countryCode, t3.customer_id, t3.delivered, t3.shipaddr, t2.part_partno, t2.quantity FROM Order t0 LEFT OUTER JOIN OrderItem t1 ON t0.oid = t1.order_oid LEFT OUTER JOIN OrderItem t2 ON t0.oid = t2.order_oid LEFT OUTER JOIN Order t3 ON t2.order_oid = t3.oid ORDER BY t2.order_oid ASC&lt;/p&gt;</description>
                <environment></environment>
        <key id="12362266">OPENJPA-134</key>
            <summary>Extra unneeded SQL joins for OneToMany relationship with fetch type EAGER</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="faywang">Fay Wang</assignee>
                                    <reporter username="fancy">Catalina Wei</reporter>
                        <labels>
                    </labels>
                <created>Thu, 8 Feb 2007 01:47:21 +0000</created>
                <updated>Tue, 20 Nov 2012 08:43:07 +0000</updated>
                            <resolved>Wed, 11 Apr 2007 17:26:31 +0100</resolved>
                                                    <fixVersion>0.9.7</fixVersion>
                                    <component>sql</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="12476027" author="jstecher" created="Mon, 26 Feb 2007 22:43:42 +0000"  >&lt;p&gt;Just curious if there has been any movement on this JIRA.  This problem actually presents itself in the test bucket that IBM has been running trying to work through the performance issues of OpenJPA and puts the OpenJPA runtime behind the competitive implementations in the scenarios above.  I am interested in getting some feedback from those that understand the code a little more about this bug and getting a possible fix generated for it.  &lt;/p&gt;

&lt;p&gt;In my mind there is no reason that the the Orderlines-&amp;gt;Orders Eager,Eager relationship should ever issues a 2 join query.  It should be a single left outer join with the eager back pointer filled by the initial orderline query.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="12476029" author="pcl" created="Mon, 26 Feb 2007 22:54:46 +0000"  >&lt;p&gt;Could you attach a test case that demonstrates this problem?&lt;/p&gt;</comment>
                            <comment id="12476054" author="kwsutter" created="Tue, 27 Feb 2007 01:48:38 +0000"  >&lt;p&gt;The following conversation has also been recorded in the dev mailing list concerning this &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-134&quot; title=&quot;Extra unneeded SQL joins for OneToMany relationship with fetch type EAGER&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-134&quot;&gt;&lt;del&gt;OPENJPA-134&lt;/del&gt;&lt;/a&gt; Issue:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nabble.com/extraneous-joins-OPENJPA-134-tf3230933.html#a8977476&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/extraneous-joins-OPENJPA-134-tf3230933.html#a8977476&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12476232" author="jstecher" created="Tue, 27 Feb 2007 17:17:23 +0000"  >&lt;p&gt;I think the links to the mailing list post that Kevin has shows a good example of the code causing the problem.  In reality any one to many relationship with a back pointer generates two joins when only one is necessary to pull in all the information needed for the query.&lt;/p&gt;

&lt;p&gt;Dave&apos;s example in the mailing list should be something you can run pretty quick and see the problem.  Catalina&apos;s original JIRA entry contains a pretty good example of the SQL. &lt;/p&gt;</comment>
                            <comment id="12478917" author="dangalvin" created="Wed, 7 Mar 2007 21:45:55 +0000"  >&lt;p&gt;We find that this case also occurs on the getReference() call as well, I assume because associated fetch is eager? &lt;/p&gt;</comment>
                            <comment id="12485235" author="jstecher" created="Thu, 29 Mar 2007 17:10:29 +0100"  >&lt;p&gt;Any update on where we stand with getting this issue addressed?&lt;/p&gt;</comment>
                            <comment id="12488111" author="awhite" created="Wed, 11 Apr 2007 17:26:31 +0100"  >&lt;p&gt;Fixed the most egregious issue, which was the cyclic fetching of eager bidirectional relations.  Changed to cut off SELECTs when we&apos;re traversing the back-ptr to the owning side of a relation we&apos;ve already fetched.  I&apos;m not convinced all the other issues mentioned are bugs given the eager fetch settings used.  Please open new JIRAs for any individual issues that you believe remain.  Fixed in revision 527565.&lt;/p&gt;</comment>
                            <comment id="12488520" author="rob.wisniewski" created="Thu, 12 Apr 2007 23:15:58 +0100"  >&lt;p&gt;I did some performance testing and things look good here.  My &apos;one to many eager&apos; scenario, which would be affected the most by this looping query behavior, improved in performance by 6%, and verified by sql dumps.&lt;/p&gt;

&lt;p&gt;I did notice that my lazy scenarios are almost 50% slower now, but looking at the sql dumps it appears that we were fetching eagerly even in those scenarios and this (or another JIRA?) seems to have fixed that functional error.  Does that seem like something your changes would resolve?  Did you run into anything that would cause an eager fetch even when lazy was specified?&lt;/p&gt;</comment>
                            <comment id="12488521" author="rob.wisniewski" created="Thu, 12 Apr 2007 23:19:32 +0100"  >&lt;p&gt;To illustrate the &apos;eager despite lazy&apos; behavior...  here&apos;s the before and after sql:&lt;/p&gt;

&lt;p&gt;svn 04/03/2007:&lt;/p&gt;

&lt;p&gt;executed once:&lt;/p&gt;

&lt;p&gt;SELECT t0.HOLDINGID, t1.ACCOUNTID, t1.PROFILE_USERID, t1.BALANCE, t1.CREATIONDATE, t1.LASTLOGIN, t1.LOGINCOUNT, t1.LOGOUTCOUNT, t1.OPENBALANCE, t0.PURCHASEDATE, t0.PURCHASEPRICE, t0.QUANTI&lt;br/&gt;
TY, t2.SYMBOL, t2.CHANGE1, t2.COMPANYNAME, t2.HIGH, t2.LOW, t2.OPEN1, t2.PRICE, t2.VOLUME FROM HOLDINGEJB t0 LEFT OUTER JOIN ACCOUNTEJB t1 ON t0.ACCOUNT_ACCOUNTID = t1.ACCOUNTID LEFT OUTER JOIN QUOTEEJB t2 ON t0.QUOTE_SYMBOL =&lt;br/&gt;
 t2.SYMBOL WHERE t0.ACCOUNT_ACCOUNTID = ?&lt;/p&gt;

&lt;p&gt;executed once:&lt;/p&gt;

&lt;p&gt;SELECT t0.PROFILE_USERID, t0.BALANCE, t0.CREATIONDATE, t0.LASTLOGIN, t0.LOGINCOUNT, t0.LOGOUTCOUNT, t0.OPENBALANCE FROM ACCOUNTEJB t0 WHERE t0.ACCOUNTID = ? optimize for 1 row&lt;/p&gt;

&lt;p&gt;CORRECT svn 04/12/2007:&lt;/p&gt;

&lt;p&gt;executed once:&lt;/p&gt;

&lt;p&gt;SELECT t0.PROFILE_USERID, t0.BALANCE, t0.CREATIONDATE, t0.LASTLOGIN, t0.LOGINCOUNT, t0.LOGOUTCOUNT, t0.OPENBALANCE FROM ACCOUNTEJB t0 WHERE t0.ACCOUNTID = ?  FOR READ ONLY  optimize for 1&lt;br/&gt;
row&lt;/p&gt;

&lt;p&gt;executed 4 times:&lt;/p&gt;

&lt;p&gt;SELECT t1.ACCOUNTID, t1.PROFILE_USERID, t1.BALANCE, t1.CREATIONDATE, t1.LASTLOGIN, t1.LOGINCOUNT, t1.LOGOUTCOUNT, t1.OPENBALANCE FROM HOLDINGEJB t0 INNER JOIN ACCOUNTEJB t1 ON t0.ACCOUNT_A&lt;br/&gt;
CCOUNTID = t1.ACCOUNTID WHERE t0.HOLDINGID = ?  FOR READ ONLY  optimize for 1 row&lt;/p&gt;</comment>
                            <comment id="12615141" author="faywang" created="Mon, 21 Jul 2008 03:40:05 +0100"  >&lt;p&gt;I have tested the following scenario:&lt;/p&gt;

&lt;p&gt;@Entity&lt;br/&gt;
public class Customer &lt;/p&gt;
{
..
   @OneToMany(fetch=FetchType.EAGER, mappedBy=&quot;customer&quot;)
    private Collection&amp;lt;Order&amp;gt; orders = new ArrayList&amp;lt;Order&amp;gt;();
...
}

&lt;p&gt;@Entity&lt;br/&gt;
public class Order &lt;/p&gt;
{
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	 int oid;

	 double amount;
	 boolean delivered;
	 
	 @ManyToOne (fetch=FetchType.EAGER)
	 Customer customer;

...

}

&lt;p&gt;A JPQL :&lt;br/&gt;
   Select c from Customer c&lt;/p&gt;

&lt;p&gt;generates the following SQL:&lt;/p&gt;

&lt;p&gt;(1) SELECT t0.countryCode, t0.id, t0.version, t0.city, t0.state, t0.street, t0.zip &lt;br/&gt;
      FROM PdqCustomer t0 &lt;/p&gt;

&lt;p&gt;(2) SELECT t0.countryCode, t0.id, t1.oid, t1.version, t1.amount, t1.delivered &lt;br/&gt;
      FROM PdqCustomer t0 &lt;br/&gt;
      INNER JOIN PdqOrder t1 ON t0.countryCode = t1.CUSTOMER_COUNTRYCODE AND &lt;br/&gt;
                             t0.id = t1.CUSTOMER_ID ORDER BY t0.countryCode ASC, t0.id ASC &lt;/p&gt;

&lt;p&gt;(3) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip &lt;br/&gt;
      FROM PdqOrder t0 &lt;br/&gt;
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode &lt;br/&gt;
                             AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row&lt;/p&gt;

&lt;p&gt;(4) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip &lt;br/&gt;
      FROM PdqOrder t0 &lt;br/&gt;
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode &lt;br/&gt;
                              AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row&lt;/p&gt;

&lt;p&gt;(5) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip &lt;br/&gt;
      FROM PdqOrder t0 &lt;br/&gt;
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode &lt;br/&gt;
                             AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row&lt;/p&gt;

&lt;p&gt;(6) SELECT t1.countryCode, t1.id, t1.version, t1.city, t1.state, t1.street, t1.zip &lt;br/&gt;
      FROM PdqOrder t0 &lt;br/&gt;
      INNER JOIN PdqCustomer t1 ON t0.CUSTOMER_COUNTRYCODE = t1.countryCode &lt;br/&gt;
                              AND t0.CUSTOMER_ID = t1.id WHERE t0.oid = ?  optimize for 1 row&lt;/p&gt;

&lt;p&gt;Note that the last four sql are the same ((3) -(6)). This is because there are four orders for the customer and each loading of order will load its inverse relationship with customer.&lt;/p&gt;

&lt;p&gt;This case is most similar to the case (3) described by Catalina. The attached patch detects the inverse relationship and get rid of sql (3) to (6). &lt;/p&gt;



</comment>
                            <comment id="12618881" author="faywang" created="Thu, 31 Jul 2008 23:10:00 +0100"  >&lt;p&gt;Scenario (2) could no longer be reproduced with r680566:&lt;/p&gt;

&lt;p&gt;@Entity&lt;br/&gt;
public class Order &lt;/p&gt;
{
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	 int oid;
	
	 double amount;
	 boolean delivered;
	 
	@ManyToOne (fetch=FetchType.LAZY)
	 Customer customer;
	
	@OneToMany (fetch=FetchType.EAGER , mappedBy=&quot;order&quot;)
	 Collection&amp;lt;OrderItem&amp;gt; lineitems = new ArrayList&amp;lt;OrderItem&amp;gt;();
...
}

&lt;p&gt;@Entity&lt;/p&gt;

&lt;p&gt;public class OrderItem &lt;/p&gt;
{
	@Id 
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	int lid;
	
	int quantity;
	double cost;
	 
	@ManyToOne (fetch=FetchType.LAZY)
	Order order;
...
}

&lt;p&gt;JPQL:&lt;br/&gt;
--------&lt;br/&gt;
select o from Order o left join fetch o.lineitems&lt;/p&gt;

&lt;p&gt;Generated SQL:&lt;br/&gt;
----------------------&lt;br/&gt;
SELECT t0.oid, t0.version, t0.amount, t0.CUSTOMER_COUNTRYCODE, t0.CUSTOMER_ID, &lt;br/&gt;
t0.delivered, t1.ORDER_OID, t1.lid, t1.version, t1.cost, t1.PART_PARTNO, t1.quantity &lt;br/&gt;
FROM Order t0  LEFT OUTER JOIN OrderItem t1 ON t0.oid = t1.ORDER_OID ORDER BY t1.ORDER_OID ASC &lt;/p&gt;

&lt;p&gt;Note that the unneeded LEFT OUTER JOIN is gone .&lt;/p&gt;</comment>
                            <comment id="13500920" author="slowstrider" created="Tue, 20 Nov 2012 08:43:07 +0000"  >&lt;p&gt;Unfortunately for the above eager bidirectional Order and Customer example, when selecting from Order instead of Customer, OpenJPA still uses &quot;load field&quot; for Customer.orders for each Customer that was fetched. Another problem (very similar, both A and C are Order and B is Customer) happens when selecting A from A &lt;b&gt;..1 B 1..&lt;/b&gt; C. OpenJPA loads B&apos;s List&amp;lt;C&amp;gt; using a &quot;load field&quot; for each B. See &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-2296&quot; title=&quot;N+1 select problems when eager fetching OneToOne and ManyToOne fields&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-2296&quot;&gt;OPENJPA-2296&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12615441">OPENJPA-2296</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12386501" name="openjpa134_3.patch" size="7986" author="faywang" created="Mon, 21 Jul 2008 03:40:05 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 26 Feb 2007 22:43:42 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160469</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyeyjr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>121294</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>