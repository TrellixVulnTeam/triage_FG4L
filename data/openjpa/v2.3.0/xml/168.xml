<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:32:36 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-168/OPENJPA-168.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-168] sql optimize n rows query hint</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-168</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;There werre various comments from Patrick, Abe and Kevin Sutter about the code that I checked related to Optimize hint.  So I have gone back and relooked at this and wil be making some changes.  At Kevin&apos;s suggestion I will do this through a JIRA feature so that folks will have opportunity to comment on this before the code is actually done and checked in.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12364755">OPENJPA-168</key>
            <summary>sql optimize n rows query hint</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="wisneskid">David Wisneski</assignee>
                                    <reporter username="wisneskid">David Wisneski</reporter>
                        <labels>
                    </labels>
                <created>Mon, 12 Mar 2007 18:39:32 +0000</created>
                <updated>Tue, 9 Mar 2010 18:32:32 +0000</updated>
                            <resolved>Fri, 10 Aug 2007 01:27:17 +0100</resolved>
                                                    <fixVersion>1.0.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12480171" author="wisneskid" created="Mon, 12 Mar 2007 19:00:23 +0000"  >&lt;p&gt;By way of background,  several databases support a sql optimizer hint with respect to optimiziing the sql query for all rows or optimizing for quick retrieval of a few rows.   This is different from the FETCH LIMIT in sql which puts a hard limit on the number of rows returns.  The optimize hint  only affects optimiziation.   Not all database support this syntax and the syntax is different for each database.&lt;/p&gt;

&lt;p&gt;Derby does not support.&lt;br/&gt;
DB2 supports with syntax  OPTIMIZE FOR n ROW(S) which appears toward the end of the sql select statement.&lt;br/&gt;
Oracle supports with syntax /&lt;b&gt;+  FIRST ROWS(N) */   or /&lt;/b&gt;+ ALL ROWS */  which occurs after the select keyword.&lt;br/&gt;
SQLServer supports but the syntax is different from DB2, Oracle.&lt;/p&gt;

&lt;p&gt;Since the concept applies to multiple (but not all) databases and the syntax is vendor specific,  we propose a hint with the name &lt;/p&gt;

&lt;p&gt;openjpa.hints.SQLOptimizeRows&lt;/p&gt;

&lt;p&gt;which can be assigned a positive integer value.&lt;/p&gt;

&lt;p&gt;This value will be verified on the setHint call  and if it is not a java.lang.Integer and a positive value, an ArgumentException will be thrown.&lt;br/&gt;
For native queries,  the hint, if specified, will be ignored.&lt;br/&gt;
The hint value will be stored on the FetchConfiguration instance.&lt;/p&gt;

&lt;p&gt;For internally generated selects, such as from EntityManager.find or relationship navigation,  we also want to indicate if one row is the expected size of the result set.  Also in the case of Query.getSingleResult we want to indicate an expected size of one. &lt;br/&gt;
To do this we will have a instance variable n FetchConfiguration to track the fetch operation:  getResultList,  getSingleResult, find, etc.&lt;/p&gt;

&lt;p&gt;So FetchConfiguration will contain the user supplied hint value OR a indication of the operation that generated the select.&lt;/p&gt;

&lt;p&gt;We modify SelectImpl to add instance variables for expectedResultCount and boolean hasSingleValuesJoins.   When multi valued relationships are added to a select  through the EagerMap  the expectedResultCount will be appropriately modified to indicate it is not a single value select.  even if the original internal operation (i.e.  find ) would normally be a single row resut.   &lt;/p&gt;

&lt;p&gt;Finally the Dictionary class will have new method getOptimizeClause.  Database Dictionaries that support some form of OPTIMIZE FOR will have to override the two toSelect methods so that the expectedResultCout from selectImpl is emitted into the sql.&lt;/p&gt;</comment>
                            <comment id="12480177" author="awhite" created="Mon, 12 Mar 2007 19:42:25 +0000"  >&lt;p&gt;1. I think the hint name should be more like &quot;openjpa.hint.OptimizeResultCount&quot;.  It should be &quot;hint&quot; and not &quot;hints&quot; to match the existent &quot;openjpa.hint.OracleSelectHint&quot;.  And I see no reason to tie it to SQL.&lt;/p&gt;

&lt;p&gt;2. I don&apos;t think we need a FetchConfiguration instance variable.  For find() calls and loading hollow objects we always know we&apos;re only loading one instance because we use the StoreManager.load() call internally.  There are similar internal APIs used only when traversing a to-one relation.  So the JDBCStoreManager or relation field strategies can set the proper expected result count into the Select directly.  Much better than having to set a FetchConfiguration value and then make sure it disappears for subsequent selects.  The only problem is Query.getSingleResult, because right now we execute the query as a multi-result query and then extract the one result at the JPA layer.  We don&apos;t have to do it this way, though.  The underlying kernel Query already has a &quot;Unique&quot; property you can set to indicate a single result.  The property doesn&apos;t have quite the semantics we want, because it allows a query that returns 0 results whereas that&apos;s an error in JPA.  We can&apos;t just change the Unique semantics because of JDO, but we could certainly make it configurable on the Query instance whether a Unique query can legally return 0 results.  So if we start using the Unique property rather than extracting the single result at the JPA layer, we&apos;ll know when the user is using getSingleResult when we construct the Select, and we can again set the expected number of results directly into the Select.&lt;/p&gt;

&lt;p&gt;3. The SelectImpl already knows when it has to-many eager joins; no need for additional state.  See SelectImpl.hasEagerJoin(boolean toMany).&lt;/p&gt;

&lt;p&gt;4. &quot;getOptimizeClause&quot; seems too generic.  I&apos;m also not clear on what use it has in the base DBDictionary class if you state that individual dictionaries will still have to override toSelect themselves to insert the optimization SQL.&lt;/p&gt;</comment>
                            <comment id="12480839" author="ritika" created="Wed, 14 Mar 2007 17:01:52 +0000"  >&lt;p&gt;Abe is there a way from selectImpl to know if this is the top select or not.For example if EagerFetchMode set to parallel if we are trying to retrieve Department and department is eagerly fetching Emps.Then a single user query (select d from Department d) will produce multiple push down sqls.Now if the user set the hint to optimize on the top level query ie select d from Department d then it should appear only on the top level query and not the subsequent queries.But to do so we need the ability to be able to distinguish if this is the top select or not.Is there currently any mechanism to do this&lt;/p&gt;

&lt;p&gt;ritika&lt;/p&gt;</comment>
                            <comment id="12480920" author="awhite" created="Wed, 14 Mar 2007 20:46:48 +0000"  >&lt;p&gt;I don&apos;t recall any way to know whether a given Select it is a top-level Select or a parallel Select.  Note that if you take my advice and implement this as an ExpectedResultCount property of SelectExecutor (which can also replace the isSingleResult propertyof Union), then you don&apos;t need to know.  The query/storemanager/whatever that constructs the top-level select will set the expected count based on hints / knowledge, and the dictionary will use it as needed.  It won&apos;t get passed to parallel eager selects accidentally.&lt;/p&gt;</comment>
                            <comment id="12481235" author="ritika" created="Thu, 15 Mar 2007 17:29:31 +0000"  >&lt;p&gt;Abe I do not understand how the SelectImpl.hasEagerJoin method is implemented.I have EmpBean and DeptBean entities as follows&lt;/p&gt;

&lt;p&gt; public class DeptBean2 implements Serializable {&lt;/p&gt;

&lt;p&gt;	   @Id&lt;br/&gt;
	 private Integer no;&lt;br/&gt;
	   @Column(name=&quot;cdname&quot;,length=80)&lt;br/&gt;
     private String name;&lt;br/&gt;
     @OneToMany(fetch=FetchType.EAGER , mappedBy=&quot;dept&quot;)&lt;br/&gt;
     private List&amp;lt;EmpBean2&amp;gt; emps;&lt;br/&gt;
     @OneToOne&lt;br/&gt;
     private EmpBean2 mgr;&lt;/p&gt;

&lt;p&gt;public class EmpBean2 implements Serializable {&lt;/p&gt;

&lt;p&gt;        @Id&lt;br/&gt;
         Integer empid;&lt;/p&gt;

&lt;p&gt;        @Column(name=&quot;cesalary&quot;,columnDefinition=&quot;_double&quot;)&lt;br/&gt;
         Double salary;&lt;/p&gt;


&lt;p&gt;        @Column(name=&quot;cename&quot;,columnDefinition=&quot;_varchar&quot;)&lt;br/&gt;
	 String name;&lt;/p&gt;

&lt;p&gt;       @Column(name=&quot;cehireDate&quot;)&lt;br/&gt;
         Date hireDate;&lt;/p&gt;

&lt;p&gt;       @Column(name=&quot;ceismanager&quot; , columnDefinition=&quot;_boolean&quot;)&lt;br/&gt;
         Boolean isManager;&lt;/p&gt;

&lt;p&gt;       @Column(name=&quot;ceemp_ts&quot;)&lt;br/&gt;
         Timestamp emp_ts;&lt;/p&gt;

&lt;p&gt;        @ManyToOne()&lt;br/&gt;
        //@ForeignKey(name=&quot;deptno&quot;)&lt;br/&gt;
      	 DeptBean2 dept;&lt;/p&gt;


&lt;p&gt;Now I set the EagerFetchMode to parallel and run the following query&lt;/p&gt;

&lt;p&gt; OpenJPAQuery qryE = OpenJPAPersistence.cast(em.createQuery(&quot;select d from DeptBean2 d&quot;));&lt;br/&gt;
                               qryE.setHint(&quot;openjpa.hint.OptimizeResultCount&quot;, new Integer(1));&lt;br/&gt;
                              List rsE = qryE.getResultList();&lt;br/&gt;
These are the selects which are generated &lt;br/&gt;
42902  dwtest  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 685648094&amp;gt; executing prepstmnt 808464432 SELECT t0.no, t1.empid, t1.dept_no, t1.ceemp_ts, t1.cehireDate, t1.ceismanager, t1.cename, t1.cesalary, t0.cdname FROM deptab2 t0 LEFT OUTER JOIN emptab2 t1 ON t0.mgr_empid = t1.empid optimize for 1 row &lt;br/&gt;
42902  dwtest  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 685648094&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;0 ms&amp;#93;&lt;/span&gt; spent&lt;br/&gt;
65474  dwtest  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 685648094&amp;gt; executing prepstmnt 1509579258 SELECT t0.no, t1.empid, t2.no, t2.mgr_empid, t2.cdname, t1.ceemp_ts, t1.cehireDate, t1.ceismanager, t1.cename, t1.cesalary FROM deptab2 t0 INNER JOIN emptab2 t1 ON t0.no = t1.dept_no LEFT OUTER JOIN deptab2 t2 ON t1.dept_no = t2.no ORDER BY t0.no ASC&lt;br/&gt;
65474  dwtest  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 685648094&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;0 ms&amp;#93;&lt;/span&gt; spent&lt;br/&gt;
105963  dwtest  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 685648094&amp;gt; executing prepstmnt 1725589210 SELECT t0.empid, t1.no, t1.cdname, t0.ceemp_ts, t0.cehireDate, t0.ceismanager, t0.cename, t0.cesalary FROM emptab2 t0 LEFT OUTER JOIN deptab2 t1 ON t0.dept_no = t1.no WHERE t0.dept_no = ? &lt;span class=&quot;error&quot;&gt;&amp;#91;params=(int) 2&amp;#93;&lt;/span&gt;&lt;br/&gt;
106003  dwtest  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.jdbc.SQL - &amp;lt;t 1094730048, conn 685648094&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;40 ms&amp;#93;&lt;/span&gt; spent&lt;/p&gt;

&lt;p&gt;when I am executing the 1st select I see 3 eagerKeys in the eagerKey map in the debugger (dept,mgr,emps) but the selectImpl.hasEagerJoin(toMany) method returns false.So my question is that inspite of seeing emps in the eagerKey map how come this method returns false.The same holds true for the second select.So when is the hasEagerJoin method going to return true&lt;/p&gt;</comment>
                            <comment id="12481683" author="ritika" created="Fri, 16 Mar 2007 16:44:22 +0000"  >&lt;p&gt;here is a patch based on the discussions regarding this feature&lt;/p&gt;</comment>
                            <comment id="12482411" author="awhite" created="Tue, 20 Mar 2007 15:23:43 +0000"  >&lt;p&gt;&amp;gt; when I am executing the 1st select I see 3 eagerKeys in the eagerKey map in the debugger (dept,mgr,emps) but the selectImpl.hasEagerJoin(toMany) method returns false.So my question is that inspite of seeing emps in the eagerKey map how come this method returns false.&lt;/p&gt;

&lt;p&gt;Because emps is being selected via a parallel select, not a to-many join in the primary select.&lt;/p&gt;</comment>
                            <comment id="12482421" author="awhite" created="Tue, 20 Mar 2007 16:03:37 +0000"  >&lt;p&gt;Comments on the proposed patch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I don&apos;t like the whole scheme of setting the expected result count to -1 for anything &quot;artificial&quot;.  It&apos;s confusing and unnecessary.  Just set it to the number of expected &quot;primary&quot; results, and the DBDictionary can invoke sel.hasEagerJoin(true) to figure out if the expected count can be used.  Or just have the getter for the expected count always return 0 if there is an eager to-many join (or better yet, turn -1 into a value meaning &quot;unknown&quot; and have it return -1, which would then also be the default when no expected count is set).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I still think there should be a way to get rid of Union.is/setSingleResult by moving the expected result property to SelectExecutor &amp;#8211; which both Select and Union extend &amp;#8211; and taking advantage of the new expected result (&quot;1&quot; obviously indicates a single result).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If you&apos;re going to validate the value of the user-supplied hint in the JPA QueryImpl, you might as well transform it into a Number at that point before setting it into the FetchConfiguration.  Also, I&apos;d accept any Number, not just an Integer (technically we should accept any whole number, but that&apos;s a pain to implement).  Then in the JDBC layer, you can just cast the hint value directly to a Number and forgo validating it and checking for String values a second time.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DB2 really cares whether you use &quot;optimize for 1 row&quot; vs. &quot;optimize for 1 rows&quot;?  That&apos;s ugly.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;We should probably generalize the configuration of row optimization to the base DBDictionary with an override mechanism.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If you&apos;re going to invoke setUnique(true) on the underlying query from the JPA QueryImpl&apos;s getSingleResult, you need to do three things:&lt;br/&gt;
  1. Unset it in a finally clause, because the very next call might be to getResultList, and in general getSingleResult shouldn&apos;t have stateful side effects.&lt;br/&gt;
  2. Change the kernel&apos;s QueryImpl to throw an exception when unique is set but the query doesn&apos;t return any results.  Right now it allows 0 results and will return null, which is indistinguishable from a projection on a null field that returned 1 result.&lt;br/&gt;
  3. Get rid of the code immediately following in getSingleResult that extracts the value if a List is returned, because after setting the unique flag on the underlying query, it will never return a List.  &lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The hint key should be a constant in the kernel&apos;s Query interface or somewhere like that.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12482490" author="ritika" created="Tue, 20 Mar 2007 19:15:15 +0000"  >&lt;p&gt;Abe your comment :&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I don&apos;t like the whole scheme of setting the expected result count to -1 for anything &quot;artificial&quot;. It&apos;s confusing and unnecessary. Just set it to the number of expected &quot;primary&quot; results, and the DBDictionary can invoke sel.hasEagerJoin(true) to figure out if the expected count can be used. Or just have the getter for the expected count always return 0 if there is an eager to-many join (or better yet, turn -1 into a value meaning &quot;unknown&quot; and have it return -1, which would then also be the default when no expected count is set).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The reason for using -1 is that we want to differentiate between cases where the user added a hint to optimize for 1 row  versus where we internally generated the value (getSingleResult,singleRelationshiptraversal etc).If the user has specified the optimize for 1 row through hint than we do not want to check for eagerJoins(true).We basically do not want to do anychecking and just add the optimize for 1 row clause.&lt;br/&gt;
But if the expectedResultCount is computed internally to be a value of 1 then we want to check the eagerJoins(true) and want to make sure that we are in fact returning a single row.So the -1 differnetiates the internally generated 1 from the user&apos;s specified 1&lt;/p&gt;

&lt;p&gt;Your Comment&lt;/p&gt;

&lt;p&gt;We should probably generalize the configuration of row optimization to the base DBDictionary with an override mechanism. &lt;/p&gt;

&lt;p&gt;is contradicting with your earlier comment&lt;/p&gt;

&lt;p&gt;4. &quot;getOptimizeClause&quot; seems too generic. I&apos;m also not clear on what use it has in the base DBDictionary class if you state that individual dictionaries will still have to override toSelect themselves to insert the optimization SQL. &lt;/p&gt;

&lt;p&gt;The fact of the matter is that the optimize clause generation for various dictionaries is different in terms of syntax and where the clause appears in the select string.So I am not sure if u really want to generalize the configuration of row optimization to the base DBDictionary.Although that was our &lt;br/&gt;
original plan&lt;/p&gt;
</comment>
                            <comment id="12482904" author="awhite" created="Wed, 21 Mar 2007 20:26:59 +0000"  >&lt;p&gt;&amp;gt; The reason for using -1 is that we want to differentiate between cases where the user added a hint to optimize for 1 row versus where we internally generated the value (getSingleResult,singleRelationshiptraversal etc).&lt;/p&gt;

&lt;p&gt;That makes sense, though the use case seems vanishingly small (when would the user explicitly optimize for one row but also include a to-many eager join?).    &lt;/p&gt;

&lt;p&gt;How about instead of using -1 to indicate &quot;an artificial single result&quot;, we change the setExpectedResults API on Select (or SelectExecutor if we go that route) to take an additional &quot;boolean force&quot; parameter that is set to true when it&apos;s a user-specified count, and false when it&apos;s an artificial expectation.  Internally we can keep track of whether the expected count is forced with another bit flag among those already used in SelectImpl.  When the count is not forced, we ignore it in the presence of a to-many eager join.  This API seems more clear-cut to me, in addition to being more general (even if we don&apos;t necessarily need the additional generality at this point).  &lt;/p&gt;

&lt;p&gt;&amp;gt; The fact of the matter is that the optimize clause generation for various dictionaries is different in terms of syntax and where the clause appears in the select string.So I am not sure if u really want to generalize the configuration of row optimization to the base DBDictionary&lt;/p&gt;

&lt;p&gt;Fair enough &amp;#8211; I had forgotten that it was so different for different databases.  &lt;/p&gt;
</comment>
                            <comment id="12482926" author="ritika" created="Wed, 21 Mar 2007 21:43:01 +0000"  >&lt;p&gt;based on your latest comments here is another patch  &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-168&quot; title=&quot;sql optimize n rows query hint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-168&quot;&gt;&lt;del&gt;OPENJPA-168&lt;/del&gt;&lt;/a&gt;.patch2&lt;/p&gt;</comment>
                            <comment id="12483203" author="ritika" created="Thu, 22 Mar 2007 16:19:12 +0000"  >&lt;p&gt;In the singleResult method of the kernel QueryImpl when null was returned I threw an error using localizer property &quot;not-unique&quot;.But this error message does not correctly define the error so in the localizer.properties I added another property as follows&lt;/p&gt;

&lt;p&gt;not-unique: The query on candidate type &quot;&lt;/p&gt;
{0}&quot; with filter &quot;{1}&quot; was \&lt;br/&gt;
	configured to have a unique result, but more than one instance matched \&lt;br/&gt;
	the query.&lt;br/&gt;
is-null: The query on candidate type &quot;{0}
&lt;p&gt;&quot; with filter &quot;&lt;/p&gt;
{1}
&lt;p&gt;&quot; was \&lt;br/&gt;
	configured to have a unique result, but no instance matched \&lt;br/&gt;
	the query.&lt;/p&gt;

&lt;p&gt;so the is-null error would be thrown for the null conditions.So I will apply this on top of patch2&lt;/p&gt;
</comment>
                            <comment id="12484288" author="pcl" created="Tue, 27 Mar 2007 03:49:52 +0100"  >&lt;p&gt;&amp;gt; 2. I don&apos;t think we need a FetchConfiguration instance variable. &lt;/p&gt;

&lt;p&gt;My understanding is that you can often provide hints about how many results might be returned, as well as whether one or many results will be loaded. So it seems like we might want to expose some way for the user to specify for an arbitrary query (or relation load) that they expect n records to be returned.&lt;/p&gt;

&lt;p&gt;&amp;gt; 4. &quot;getOptimizeClause&quot; seems too generic.&lt;/p&gt;

&lt;p&gt;Agreed. The optimizations tend to get tucked into different parts of the SQL statement; this probably will end up needing to be significantly different for different db back-ends.&lt;/p&gt;</comment>
                            <comment id="12484474" author="awhite" created="Tue, 27 Mar 2007 15:35:16 +0100"  >&lt;p&gt;Something is wrong with my email system so instead of replying to the SVN commit message, I&apos;m posting my comments on the commit of this patch here.&lt;/p&gt;

&lt;p&gt;I didn&apos;t go through the entire commit, but what I saw looked really good.  There are, however, a few problems I&apos;d like to see fixed:&lt;/p&gt;

&lt;p&gt;1. The formatting is messed up (in that it is unlike all our other formatting) in many places.  Indentation is off, spaces are missing before opening braces or added before line-ending semicolons, etc.  Can you change the formatting to be consistent with the rest of the codebase?&lt;/p&gt;

&lt;p&gt;2.  The point of making the optimize hint string a static constant is not only to avoid typo errors when we use it internally, but also to make it available to users.  In this way it is exactly like the constants in org.apache.openjpa.kernel.QueryFlushModes, for example.  I&apos;d like to see the constant removed from AbstractStoreQuery.  Instead, I&apos;d like to see an org.apache.openjpa.kernel.QueryHints interface with a HINT_RESULT_COUNT defined, and I&apos;d like to see org.apache.openjpa.persistence.OpenJPAQuery implement this interface, just as it does for QueryFlushModes.  This will allow both our internal code &amp;#8211; through QueryHints &amp;#8211; and user code &amp;#8211; through OpenJPAQuery &amp;#8211; to use the constant.&lt;/p&gt;

&lt;p&gt;3. This is much more of a matter of personal opinion, but I think the added code is over-commented.  The new SelectExecutor.setExpectedResultCount method should be thoroughly documented, but IMO we don&apos;t need comments explaining what we&apos;re doing every time we invoke the method.  The code speaks for itself, and over-commenting always runs the danger of the comments falling out of synch with the code.&lt;/p&gt;</comment>
                            <comment id="12485307" author="ritika" created="Thu, 29 Mar 2007 20:14:20 +0100"  >&lt;p&gt;Abe,&lt;br/&gt;
        I hope you realize that the expectedResultCount on selectImpl is not reflecting the actual reseultCount of that SelectImpl but actually specifying the number of rows to be optimized for that selectImpl.So user might very well say optimize for 1 row where as the actual number of results returned by selectImpl is more than 1.To me the expectedResultCount is misleading and should be optimizeResultCount.&lt;/p&gt;</comment>
                            <comment id="12486820" author="pcl" created="Thu, 5 Apr 2007 01:42:18 +0100"  >&lt;p&gt;Has this new feature been documented?&lt;/p&gt;</comment>
                            <comment id="12518881" author="fancy" created="Fri, 10 Aug 2007 01:15:48 +0100"  >&lt;p&gt;Attached documentation patch for query hints&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12353525" name="OPENJPA-168.patch.txt" size="13121" author="ritika" created="Fri, 16 Mar 2007 16:44:21 +0000"/>
                            <attachment id="12353896" name="OPENJPA-168.patch2.txt" size="21503" author="ritika" created="Wed, 21 Mar 2007 21:43:16 +0000"/>
                            <attachment id="12363544" name="jpa_overview_query.xml.patch" size="8658" author="fancy" created="Fri, 10 Aug 2007 01:15:48 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 12 Mar 2007 19:42:25 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160500</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hysyvz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203000</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>