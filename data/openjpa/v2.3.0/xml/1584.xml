<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:36:25 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-1584/OPENJPA-1584.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-1584] PreparedQuery gives wrong result if query has subquery and parameters are used in both main select and subselect</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-1584</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;a back-to-back of the following JPQL query providing different set of parameter values, &lt;br/&gt;
the second execution gives wrong answer.&lt;/p&gt;

&lt;p&gt; &quot;select o from OrderJPA o where o.OrderId in (select max(o1.OrderId) from OrderJPA o1 where ((o1.CustomerId = :customerId) and (o1.DistrictId = :districtId) and (o1.WarehouseId = :warehouseId))) and (o.CustomerId = :customerId) and (o.DistrictId = :districtId) and (o.WarehouseId = :warehouseId)&quot;&lt;/p&gt;

&lt;p&gt;SQL trace shown the first time query execution, let say customerId=339, districtId=3, warehouseId=23, then query returns 1 row:&lt;/p&gt;

&lt;p&gt;the SQL trace looked fine:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;3/16/10 17:40:36:831 CDT&amp;#93;&lt;/span&gt; 00000045 OpenJPA       3   openjpa.jdbc.SQL: Trace: &amp;lt;t 241897067, conn 1981117973&amp;gt; executing prepstmnt 1547852866 SELECT t0.O_D_ID, t0.O_ID, t0.O_W_ID, t0.VERSION, t0.O_ALL_LOCAL, t0.O_CARRIER_ID, t0.O_C_ID, t0.O_ENTRY_D, t0.O_OL_CNT FROM ORDERS t0 WHERE (t0.O_ID IN (SELECT MAX(t1.O_ID) FROM ORDERS t1 WHERE (t1.O_C_ID = ? AND t1.O_D_ID = ? AND t1.O_W_ID = ?) ) AND t0.O_C_ID = ? AND t0.O_D_ID = ? AND t0.O_W_ID = ?)  optimize for 1 row &lt;span class=&quot;error&quot;&gt;&amp;#91;params=(short) 339, (short) 3, (short) 23, (short) 339, (short) 3, (short) 23&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;On the next execution of the same JPQL, the PreparedQueryImpl (which is cached before) gets reused.&lt;br/&gt;
In processing user provided parameters, for example, customerId=2967, districtId=5, warehouseId=22,&lt;br/&gt;
It is observed that the parameter values are incorrect: the last 3 values were incorrectly copied from the previously cached version.&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;3/16/10 17:45:42:411 CDT&amp;#93;&lt;/span&gt; 00000043 OpenJPA       3   openjpa.jdbc.SQL: Trace: &amp;lt;t 195496871, conn 1706649017&amp;gt; executing prepstmnt 1531796301 SELECT t0.O_D_ID, t0.O_ID, t0.O_W_ID, t0.VERSION, t0.O_ALL_LOCAL, t0.O_CARRIER_ID, t0.O_C_ID, t0.O_ENTRY_D, t0.O_OL_CNT FROM ORDERS t0 WHERE (t0.O_ID IN (SELECT MAX(t1.O_ID) FROM ORDERS t1 WHERE (t1.O_C_ID = ? AND t1.O_D_ID = ? AND t1.O_W_ID = ?) ) AND t0.O_C_ID = ? AND t0.O_D_ID = ? AND t0.O_W_ID = ?)  optimize for 1 row &lt;span class=&quot;error&quot;&gt;&amp;#91;params=(short) 2967, (short) 5, (short) 22, (short) 339, (short) 3, (short) 23&amp;#93;&lt;/span&gt;&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12459550">OPENJPA-1584</key>
            <summary>PreparedQuery gives wrong result if query has subquery and parameters are used in both main select and subselect</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="fancy">Catalina Wei</assignee>
                                    <reporter username="fancy">Catalina Wei</reporter>
                        <labels>
                    </labels>
                <created>Thu, 18 Mar 2010 17:57:12 +0000</created>
                <updated>Sat, 24 Jul 2010 17:23:37 +0100</updated>
                            <resolved>Sat, 24 Jul 2010 17:23:37 +0100</resolved>
                                    <version>2.0.0</version>
                                    <fixVersion>2.1.0</fixVersion>
                                    <component>performance</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12891214" author="dirichs" created="Thu, 22 Jul 2010 16:23:53 +0100"  >&lt;p&gt;A modification to SQLBuffer has been committed in revision 925036 which supposedly corrected this issue. However, the committed change also has problems. The problem arises during the construction of a prepared statement when sub-selects are added to the main statement. In particular, the indexes of user parameters have to be adapted to their new positions within the resulting statement (which consists of the main statement and the sub-select). File org.apache.openjpa.jdbc.sql.SQLBuffer contains the following lines, which were committed with revision 925036 (lines 170++):&lt;/p&gt;

&lt;p&gt;            // modify this buffer&apos;s user parameter index&lt;br/&gt;
            int otherSize = buf._userIndex.size()/2;&lt;br/&gt;
            for (int i = 0; i &amp;lt; _userIndex.size(); i+=2) &lt;/p&gt;
{
                int newIndex = ((Integer)_userIndex.get(i)).intValue() + otherSize;
                _userIndex.set(i, newIndex);
            }
&lt;p&gt;            // append the other buffer&apos;s user parameters to this one&lt;br/&gt;
            for (int i = 0; i &amp;lt; buf._userIndex.size(); i+=2) &lt;/p&gt;
{
                Object otherIndex = buf._userIndex.get(i);
                Object otherParam = buf._userIndex.get(i+1);
                _userIndex.add(otherIndex);
                _userIndex.add(otherParam);
            }
&lt;p&gt;            &lt;/p&gt;

&lt;p&gt;This code assumes that the sub-select user parameters, which are stored in buf._userIndex, always reside at positions in the combined statement before all the parameters of the main statement. If this is the case, the above code works (almost) correctly: All user parameters of the main statement get their indexes adapted, all sub-select user parameters are just copied without change. The code is only almost correct in this case, because the index offset calculation done with&lt;br/&gt;
int otherSize = buf._userIndex.size()/2;&lt;br/&gt;
is misguided - the offset should really be the number of all parameters (including non-user parameters) of the sub-select, not only the user parameters.&lt;/p&gt;

&lt;p&gt;The correct code is given below:&lt;/p&gt;

&lt;p&gt;            // modify this buffer&apos;s user parameter index for all parameters&lt;br/&gt;
            // at or behind paramIndex, which is the insertion position&lt;br/&gt;
            int otherSize = buf._params.size();&lt;br/&gt;
            for (int i = 0; i &amp;lt; _userIndex.size(); i+=2) &lt;/p&gt;
{
                int oldIndex = ((Integer)_userIndex.get(i)).intValue();
                if (oldIndex &amp;gt;= paramIndex)
                    _userIndex.set(i, oldIndex + otherSize);
            }
&lt;p&gt;            // append the other buffer&apos;s user parameters to this one, their&lt;br/&gt;
            // position adapted according to the insertion position&lt;br/&gt;
            for (int i = 0; i &amp;lt; buf._userIndex.size(); i+=2) &lt;/p&gt;
{
                int otherIndex = ((Integer) buf._userIndex.get(i)).intValue();
                Object otherParam = buf._userIndex.get(i+1);
                _userIndex.add(otherIndex + paramIndex);
                _userIndex.add(otherParam);
            }
&lt;p&gt;            &lt;/p&gt;

&lt;p&gt;Here, the insertion position at where the sub-select parameters get inserted into the main statement is propertly taken into account (paramIndex). User parameters of the main statement which reside before the insertion position remain unchanged, the position of all others gets offset by the number of parameters of the sub-select. The sub-select user parameters in turn are moved by an amount equal to the insertion position.&lt;/p&gt;

&lt;p&gt;A corresponding patch OpenJPA-2.0.0_OJ1584.patch containing the correct version of the code is attached. It would be better though to also add a new test method to TestPreparedQueryCache. If my help is welcome, I can create such a test case and supply it as well.&lt;/p&gt;</comment>
                            <comment id="12891251" author="drwoods" created="Thu, 22 Jul 2010 18:18:29 +0100"  >&lt;p&gt;Additional tests are always welcomed &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12891997" author="fancy" created="Sat, 24 Jul 2010 17:23:37 +0100"  >&lt;p&gt;Resolved in  &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-1719&quot; title=&quot;Prepared SQL cache ordering problem with subqueries. &quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-1719&quot;&gt;&lt;del&gt;OPENJPA-1719&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-1738&quot; title=&quot;Prepared SQL query does not handle collection-valued parameter of persistence-capable  objects&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-1738&quot;&gt;&lt;del&gt;OPENJPA-1738&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12450179" name="OpenJPA-2.0.0_OJ1584.patch" size="1904" author="dirichs" created="Thu, 22 Jul 2010 16:23:53 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 22 Jul 2010 15:23:53 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>161847</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt6f3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>204220</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>