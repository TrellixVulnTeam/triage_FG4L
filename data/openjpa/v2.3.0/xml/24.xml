<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:39:01 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-24/OPENJPA-24.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-24] Allow OpenJPA to be extensible</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-24</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;The current OpenJPA architecture is not extendable to other implementations.  For example, if somebody wanted to provide their own PersistenceProvider implementation, simply extending the org.apache.openjpa.PersistenceProviderImpl would not suffice due to the dependencies in the ConfigurationProviderImpl.  The discussion for this improvement was started on the dev mailing list.  Once it was determined that there was more to this request than a simple conditional or two, we decided to open a JIRA report.&lt;/p&gt;

&lt;p&gt;The complete history of this request can be found in the OpenJPA dev mailing list.  The first message was posted by me (Kevin Sutter) on August 14, titled &quot;Extending the OpenJPA Implementation&quot;.  I will attempt to paraphrase the current state of the problem...&lt;/p&gt;

&lt;p&gt;We have three main players in this issue.  The PersistenceProvider, the ConfigurationProvider, and the ProductDerivation (along with the various implementations of these interfaces).  Currently, the ConfigurationProvider is in the lib and is unaware of any specific persistence requirements.  The ProductDerivation is in the kernel and, unfortunately, is aware of persistence requirements, specifically the spec and store types.  Abe&apos;s postings have indicated that we need to make these two interfaces more aware of each other and work with each other.  We need to start with either making ConfigurationProvider more persistence-aware and move it into kernel, or make ProductDerivations less persistence-aware and move it into lib.  The latter approach is preferred.&lt;/p&gt;

&lt;p&gt;After we get this re-organization of the base framework complete, we still have a couple of other issues ot resolve:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Still need the ability to extend EMF&apos;s through a ProductDerivation.  This should be doable by adding a new PluginValue to indicate what class of EMF to load.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;There is still a question as to whether we will need to provide a custom PersistenceProviderImpl and ConfigurationProviderImpl pair.  I still think this will be necessary.   And, one of Abe&apos;s posts indicated that this might help with class loading issues when multiple versions of OpenJPA-based implementations are available in the same system.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I also posted these questions last Friday.  (Abe has responded with some answers, but I wanted to get this JIRA report created before trying to paraphrase his answers.)&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;You mention in several places about separating away the notion of specs and stores.  In a general sense, I understand what these are.  But, can you elaborate on how these types are used in the ConfigurationProvider and ProductDerivation interfaces?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I&apos;ve moved the ProductDerivation interface to the lib and added the &quot;load&quot; methods from the ConfigurationProvider (as described in your previous notes).  And, I&apos;ve started to clean up the implementations that depend on these interfaces.  But, concerning the implementation of the load methods...  Now that we need to return a ConfigurationProvider, would you expect that we just new up a ConfigurationProviderImpl and then just call across to the &quot;load&quot; methods on the implementation?  Since we want to keep the ProductDerivations stateless, I&apos;m not sure how else you were expecting to create a ConfigurationProvider to return on these &quot;load&quot; methods.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Now that ConfigurationProvider is bare, the ConfigurationTestConfigurationProvider doesn&apos;t have much function.  I&apos;ll need to take a look to see if this is even required any longer.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you shed a bit more light on the Configurations class?  It doesn&apos;t implement nor extend any interfaces or classes, but it seems to provide many of the same methods as ConfigurationProvider, but as statics.  And, it&apos;s dependent on having a Provider.  Can you explain the relationship of this class in the bigger picture and how you think it might be affected by thes changes?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That&apos;s enough for the initial JIRA report.  We will now track this problem here instead of the dev mailing list.  Thanks.&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</description>
                <environment></environment>
        <key id="12348334">OPENJPA-24</key>
            <summary>Allow OpenJPA to be extensible</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kwsutter">Kevin Sutter</assignee>
                                    <reporter username="kwsutter">Kevin Sutter</reporter>
                        <labels>
                    </labels>
                <created>Mon, 21 Aug 2006 14:27:35 +0100</created>
                <updated>Thu, 1 Mar 2007 02:20:03 +0000</updated>
                            <resolved>Thu, 1 Mar 2007 02:20:03 +0000</resolved>
                                                    <fixVersion>0.9.7</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12429441" author="kwsutter" created="Mon, 21 Aug 2006 16:57:48 +0100"  >&lt;p&gt;Abe&apos;s responses to my questions posted previously (from the dev mailing list)...&lt;/p&gt;

&lt;p&gt;&amp;gt;   - You mention in several places about separating away the notion of&lt;br/&gt;
&amp;gt; specs and stores.  In a general sense, I understand what these&lt;br/&gt;
&amp;gt; are.  But, can you elaborate on how these types are used in the&lt;br/&gt;
&amp;gt; ConfigurationProvider and ProductDerivation interfaces?&lt;/p&gt;

&lt;p&gt;What I meant was that the ProductDerivation interface has methods and&lt;br/&gt;
constants that imply knowledge of what a &quot;spec&quot; is and what a &quot;store&quot;&lt;br/&gt;
is: afterSepcificationSet(), TYPE_STORE, etc.  These methods and&lt;br/&gt;
constants become meaningless when the interface is moved from kernel&lt;br/&gt;
to lib, because lib is code that is completely ignorant of what&apos;s&lt;br/&gt;
built on top of it.  OpenJPA kernel understands that there might be&lt;br/&gt;
different spec facades built on it, and that there might be different&lt;br/&gt;
data stores plugged in, but lib code shouldn&apos;t be aware of those&lt;br/&gt;
concepts.&lt;/p&gt;

&lt;p&gt;Actually, I wouldn&apos;t mind moving the&lt;br/&gt;
OpenJPAConfiguration.setSpecification() method to the base&lt;br/&gt;
Configuration interface and giving lib the notion of a spec, because&lt;br/&gt;
that&apos;s a sufficiently general idea.  But lib certainly shouldn&apos;t know&lt;br/&gt;
anything about data stores &amp;#8211; that concept is very persistence-&lt;br/&gt;
specific.  So I believe that at the very least, the TYPE_STORE stuff&lt;br/&gt;
has to be moved out of ProductDerivation and into something in the&lt;br/&gt;
kernel if ProductDerivation itself moves into lib.  As I mentioned in&lt;br/&gt;
my original email, it might seem odd to maintain the strict&lt;br/&gt;
neutrality of lib code given that it&apos;s only used for OpenJPA, but we&lt;br/&gt;
do in fact build on that code with some non-persistence-aware Kodo&lt;br/&gt;
stuff, and as long as there is a separation of modules within&lt;br/&gt;
OpenJPA, I&apos;d like to maintain the meaning of lib-as-neutral vs.&lt;br/&gt;
kernel-as-persistence-aware.&lt;/p&gt;

&lt;p&gt;&amp;gt; Now that we need to return a ConfigurationProvider, would you&lt;br/&gt;
&amp;gt; expect that we just new up a ConfigurationProviderImpl and then&lt;br/&gt;
&amp;gt; just call  across to the &quot;load&quot; methods on the implementation?  Since we&lt;br/&gt;
&amp;gt; want to keep the ProductDerivations stateless, I&apos;m not sure how else you were&lt;br/&gt;
&amp;gt; expecting to create a ConfigurationProvider to return on these &quot;load&quot; methods.&lt;/p&gt;

&lt;p&gt;I would expect the ProductDerivation itself to do most of the load&lt;br/&gt;
work and to populate a new ConfigurationProvider with the parsed&lt;br/&gt;
state.  The ProductDerivation itself would remain stateless, but&lt;br/&gt;
would contain the load logic.  We can probably have just one&lt;br/&gt;
ConfigurationProviderImpl that will work for most derivations (i.e.&lt;br/&gt;
ConfigurationProviderImpl will probably not have to be JPA-specific&lt;br/&gt;
anymore, and can move into lib&apos;s conf package or somewhere where it&lt;br/&gt;
can be used by JDO, etc as well).  I bet a slight rework of&lt;br/&gt;
MapConfigurationProvider would do the trick.&lt;/p&gt;

&lt;p&gt;&amp;gt;   - Now that ConfigurationProvider is bare, the&lt;br/&gt;
&amp;gt; ConfigurationTestConfigurationProvider doesn&apos;t have much&lt;br/&gt;
&amp;gt; function.  I&apos;ll need to take a look to see if this is even required any longer.&lt;/p&gt;

&lt;p&gt;Yeah, I&apos;m sure tests will need updating.&lt;/p&gt;

&lt;p&gt;&amp;gt;   - Can you shed a bit more light on the Configurations class?  It&lt;br/&gt;
&amp;gt; doesn&apos;t implement nor extend any interfaces or classes, but it&lt;br/&gt;
&amp;gt; seems to provide many of the same methods as ConfigurationProvider, but as&lt;br/&gt;
&amp;gt; statics.  And, it&apos;s dependent on having a Provider.  Can you explain the&lt;br/&gt;
&amp;gt; relationship of this class in the bigger picture and how you think it might be&lt;br/&gt;
&amp;gt; affected by these changes?&lt;/p&gt;

&lt;p&gt;It&apos;s a utility class.  Aside from the low-level utils it provides,&lt;br/&gt;
it&apos;s mainly there so that its static configuration methods can be&lt;br/&gt;
invoked without worrying about what services the system is configured&lt;br/&gt;
with.  Configurations does the work of looking up the right&lt;br/&gt;
ConfigurationProvider using the services framework and applying it.&lt;br/&gt;
Otherwise, each component that used a ConfigurationProvider would&lt;br/&gt;
have to invoke the Services utilities itself to figure out which&lt;br/&gt;
ConfigurationProvider to use.&lt;/p&gt;

&lt;p&gt;When ProductDerivation takes over, Configurations will change to use&lt;br/&gt;
ProductDerivations instead, and will subsume the functionality of&lt;br/&gt;
kernel&apos;s conf.ProductDerivations utility class.&lt;/p&gt;</comment>
                            <comment id="12432209" author="kwsutter" created="Fri, 1 Sep 2006 20:18:52 +0100"  >&lt;p&gt;I&apos;m finally getting back to this exercise and I will have to admit that this is quite difficult not understanding the general architecture of thse ConfigurationProviders and ProductDerivations.  Instead of jumping right in and attempting to make Abe&apos;s suggested changes, I&apos;m trying to understand the current architecture.  Here&apos;s what I am finding...&lt;/p&gt;

&lt;p&gt;The application attempts to create an EMF via Persistence.createEntityManagerFactory().  This eventually gets us to the PersistenceProviderImpl.createEntityManagerFactory() methods, which creates the ConfigurationProviderImpl instance.  We then use this ConfigurationProviderImpl instance  to load the resources and create the PersistenceUnitInfo object.&lt;/p&gt;

&lt;p&gt;The last thing we do in createEntityManagerFactory is to create the appropriate BrokerFactory.  We do this by calling Bootstrap.newBrokerFactory passing in the ConfigurationProvider instance and associated Loader.&lt;/p&gt;

&lt;p&gt;Within this processing, I see where we are looping through the ProductDerivation services (sorted on Type).&lt;/p&gt;

&lt;p&gt;This, in turn, creates the new JDBCBrokerFactory instance, which creates the corresponding JDBCConfigurationImpl.  After initializing the properties in the constructor, we attempt to load the global settings by calling Configurations.loadGlobals static method (via the ConfigurationImpl.loadGlobals method).  This is where it gets confusing.  Within this method, we create new instances of the ConfigurationProviderImpl and we use these instances to load resources (again?).&lt;/p&gt;

&lt;p&gt;So, I am seeing where we loop through ConfigurationProviders, eventually creating and looping thorugh ProductDerivations, and then we create and process new instances of ConfigurationProviders.&lt;/p&gt;

&lt;p&gt;Granted, I&apos;ve only spent a couple of hours looking at this today, but I think I need some background on how these Services were working previously before attempting to correct it.  Maybe this was part of the reason why Abe wanted to get rid of the ConfigurationProvider service and drive everything through the ProductDerivations.  It&apos;s kind of confusing.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Keivn&lt;/p&gt;</comment>
                            <comment id="12432225" author="awhite" created="Fri, 1 Sep 2006 21:04:19 +0100"  >&lt;p&gt;Globals are configuration properties that are always loaded before any explicit configuration supplied by the user, both when using dev tools and at runtime.  Each configuration provider decides on whether and how it uses globals.  The JPA configuration provider does not use globals.  Kodo&apos;s JDO configuration provider looks for a &quot;kodo.properties&quot; resource in the classpath and loads anything in it.  A Kodo user could theoretically have a kodo.properties with JDO properties, but request an EntityManagerFactory through Persistence.  &lt;/p&gt;

&lt;p&gt;Thus the loading of globals is independent of the runtime ConfigurationProvider created by PersistenceProviderImpl or any other bootstrapping mechanism.  That is reflected in the behavior Kevin noted: when loading globals we loop through all the ConfigurationProviders in the system until we find one that loads successfully, regardless of how the user is bootstrapping his runtime.&lt;/p&gt;</comment>
                            <comment id="12432227" author="awhite" created="Fri, 1 Sep 2006 21:07:29 +0100"  >&lt;p&gt;Correction: the JPA configuration provider does use globals.  It looks for an openjpa.xml resource for global configuration.  Just as a Kodo user could have a kodo.properties but bootstrap his runtime through JPA, he could also use openjpa.xml but bootstrap his runtime through JDO.  Again, the loading of globals is independent of the runtime bootstrapping mechanism.&lt;/p&gt;</comment>
                            <comment id="12432240" author="logemann" created="Fri, 1 Sep 2006 21:57:55 +0100"  >&lt;p&gt;Just to get it right too. You can bootstrap OpenJPA by the means of PersistenceProviderImpl but still obtain a JDO persistenceManager. But the important question is, where to put things which were formerly in kodo.properties? Or is PersistenceProviderImpl able to load from kodo.properties?&lt;/p&gt;</comment>
                            <comment id="12432705" author="ppoddar@apache.org" created="Wed, 6 Sep 2006 02:04:03 +0100"  >&lt;p&gt;One use case for extension of OpenJPA implementations is backward compatibility of Kodo 4.1 with Kodo 4.0. In Kodo 4.0, we have published interfaces such as kodo.persistence.KodoEntityManagerFactory/KodoEntityManager. The applications compiled with Kodo 4.0 API to work with Kodo 4.1 runtime (based on OpenJPA), we would be supporting KodoEntityManagerFactory and other published interfaces.&lt;br/&gt;
The published Kodo 4.0 interfaces would be redefined to extend openjpa interfaces for Kodo 4.1. &lt;/p&gt;

&lt;p&gt;I&apos;m working on some related code for backwards-compatibility of Kodo, which turns out to be a similar problem to extensibility of OpenJPA. Let&apos;s compare notes, and see where we&apos;re overlapping and how we can help each other out.&lt;/p&gt;</comment>
                            <comment id="12433137" author="kwsutter" created="Thu, 7 Sep 2006 15:54:32 +0100"  >&lt;p&gt;Concerning the ProductDerivation types...&lt;/p&gt;

&lt;p&gt;Of the types defined in ProductDerivation, it looks like only TYPE_SPEC, TYPE_STORE, and TYPE_SPEC_STORE are being used.  (I don&apos;t find any references to TYPE_PRODUCT, TYPE_PRODUCT_STORE, or TYPE_FEATURE.  Must be for future extensions?)  I&apos;m assuming that any re-factoring of these types should continue to include these types that are not currently being utilized.&lt;/p&gt;

&lt;p&gt;One of Abe&apos;s earlier comments indicated that if we move ProductDerivation into lib, then we should remove the concept of SPEC and STORE from that interface since lib is persistence-neutral.  (Later on, Abe indicated that maybe we could leave the concept of SPEC since that is pretty general, but STORE is definitely specific to persistence.)  These removed concepts needed to be re-introduced into the kernel, possibly as a derived OpenJPAProductDerivation.&lt;/p&gt;

&lt;p&gt;This would imply that the getType() method and the associated constants for the TYPE_* values should be removed from the ProductDerivation interface.&lt;/p&gt;

&lt;p&gt;But, if we go that route, then we&apos;re screwed with our proposed looping through the list of ProductDerivations since it relies on the ProductDerivation.getType() method.&lt;/p&gt;

&lt;p&gt;So, it would seem that we still need the getType() method and associated TYPE_* constants at the ProductDerivation interface.  It seems that it would be okay for the interface to define the various types, and let the implementations deal with the SPEC and/or STORE implications.&lt;/p&gt;

&lt;p&gt;What am I missing?&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12433153" author="awhite" created="Thu, 7 Sep 2006 17:08:40 +0100"  >&lt;p&gt;The ProductDerivation interface can have a getType() and can order on that type without having to define all the type constants itself.  My usual strategy is to define the constants that make sense for the base type, leaving big &quot;holes&quot; so that subclasses can insert their own constants for proper ordering:&lt;/p&gt;

&lt;p&gt;public interface ProductDerivation &lt;/p&gt;
{
    public static final int BASETYPE1 = 10;
    public static final int BASETYPE2 = 20;
    ...
}

&lt;p&gt;It&apos;s somewhat delicate (I usually Javadoc the base constants with their values and the fact that they shouldn&apos;t be changed), but it&apos;s simple and IMO it&apos;s better than the base interface containing a bunch of meaningless (to it) constants.&lt;/p&gt;</comment>
                            <comment id="12435778" author="kwsutter" created="Tue, 19 Sep 2006 14:06:59 +0100"  >&lt;p&gt;It looks like Pinaki has dropped some code via revision r447664 that provides at least some of the infrastructure needed for this JIRA report.  I will need to compare his changes with the changes I was experimenting with to see if this report is now resolved or not.  Any additional changes will be logged via this JIRA report.&lt;/p&gt;</comment>
                            <comment id="12435915" author="ppoddar@apache.org" created="Tue, 19 Sep 2006 17:01:40 +0100"  >&lt;p&gt;I had made certain changes for extending OpenJPA with alternative implementaions via ProductDerivations mechanics. Let me present my understanding of this issue raised orginally by Kevin on this discussion thread. &lt;/p&gt;

&lt;p&gt;org.apache.openjpa.lib.conf.Configuration carries the properties that determines configurable behaviour e.g. which concrete PersistenceProvider to create or whether to synchronize the object schema with that of the database or whether to apply JPA or JDO style mapping primitives and so on. It is a rich and powerful construct with support for Plugin.  &lt;/p&gt;

&lt;p&gt;The purpose of OpenJPA configuration subsystem is to create one such Configuration instance that is essential for any particular instantiation of the generic kernel known as BrokerFactory. In fact, BrokerFactory and Configuration enjoy a 1:1 till-detah-do-us-apart sort of relationship.    &lt;/p&gt;

&lt;p&gt;ProductDerivation, ProductDerivations, ConfigurationProvider, Configurations are abstractions that participate in creating this Configuration instance. Let us see the roles played by each of them.&lt;/p&gt;

&lt;p&gt;ConfigurationProvider locates where the configuration information is and then reads it. The information can be in a META-INF/persistence.xml file inside a jar, a kodo.properties file available in classpath, a -Dxyz=myValue style Java system property, in a Map instance constructed programatically - the possibilities are not constrained by design. Because OpenJPA &amp;#8211; notwithstanding its name &amp;#8211; is by design capable of supporting multiple specifications that differs in configuration grammar &amp;#8211; multiple ConfigurationProvider classes are provided. Given the varied nature of how configuration information can be made available to the runtime, the basic interface org.apache.openjpa.lib.conf.ConfigurationProvider provides the discipline of reading configuration from &apos;global&apos; or &apos;default&apos; or named resources. Of course, each concrete implementation would interpret what &apos;global&apos; or &apos;default&apos; would mean. ConfigurationProvider after locating the information resource, reads its content and temporarilly stores in an internal name-value map. Eventually it pours this content into a Configuration instance via ConfigurationProvider.setInto(Configuration conf) method. &lt;/p&gt;

&lt;p&gt;ProductDerivation faciliates how Configuration will deal with this content &amp;#8211; which MetaDataFactory to set, which EntityManagerFactory (or PersistenceManagerFactory) to instantiate as a facade to the kernel according to active specification and so on. This tunning is accomplished by hooks during the life of a Configuration before being put to active duty i.e. before a Configuration instance is constructed, before the content carried by ConfigurationProvider is poured in Configuration and after a Configuration is set to represent a specification. For example, the spec-agnostic core configuration implementation ConfigurationImpl nor its derivation OpenJPAConfigurationImpl declares a plugin for which concrete EntityManagerFactory to construct as a facade. But PersistenceProductDerivation inserts org.apache.openjpa.persistence.EntityManagerFactoryImpl as the concrete implementation class for EMF in beforeConfigurationConstruct() hook and adds a EMF-plugin value via beforeConfigurationLoaded() hook i.e. before ConfigurationProvider pours its content into a Configuration. This allows the PersistenceProviderImpl to instantiate a org.apache.openjpa.persistence.EntityManagerFactoryImpl as a facade to BrokerFactory.  &lt;/p&gt;

&lt;p&gt;Given that OpenJPA supports an extensive set of configurable parameters it is logical to separate them into categories such as SPEC, PRODUCT, STORE etc &amp;#8211; and that lead to a host of ProductDerivation classes each tunning the configuration from its own perspective. org.apache.openjpa.lib.conf.ProductDerivations is the harness that locates each ProductDerivation available to the system, order them up sequentially to give a chance to modify Configuration/ConfigurationProvider. ProductDerivations finds ProductDerivation by looking up one or more &quot;org.apache.openjpa.lib.conf.ProductDerivation&quot; resources in the classpath and interpreting each line of this simple text-based resource as a class name for a particular org.apache.openjpa.lib.conf.ProductDerivation implementation. &lt;/p&gt;

&lt;p&gt;Configurations hold a bunch of static utility methods to instantiate plugin, pour system properties into Configuration and so on. I have not looked into this class due dilligence and it may even be a candidate for being refactored out completely later. &lt;/p&gt;


&lt;p&gt;Given this scheme, the most visible (and mechanical) change is to drive the loading of configuration data by the ConfigurationProvider via ProductDerivations. It used to be such that different ConfigurationProvider were activated by Configurations and different ProductDerivation were activated by ProductDerivations. Now ProductDerivations is the only driver of configuration subsystem. Each ProductDerivation can supply its own ConfigurationProvider to locate/parse/read configuration information and supplying a null imply that this ProductDerivation does not read resource at all. In fact, most of them don&apos;t. &lt;/p&gt;

&lt;p&gt;This ProductDerivation-as-driver-of-ConfigurationProvider notion is coded into AbstractProductDerivation.  &lt;/p&gt;

&lt;p&gt;The other change as outlined by Abe is to move ProductDerivations/ProductDerivation/Configuration to lib and factor out STORE specifc details in kerenl.OpenJPAProductDerivation. &lt;/p&gt;

&lt;p&gt;With all these machinery and refactoring &amp;#8211; now let us go back to the issue Kevin originally raised &amp;#8211; how does one extend OpenJPA?&lt;br/&gt;
The use case became real when we needed a backward compatibility support for Kodo 4.0. Kodo 4.0 was released few months ago in pre-OpenJPA era. Obviously, a mechanism is needed such that applications written on Kodo 4.0 but running on Kodo 4.1 based on OpenJPA must be able to use the old API of kodo.persistence.PersistenceProviderImpl instead of org.apache.... &lt;br/&gt;
In my next post, I will describe how that was done with ProductDerivation, I have to now attend to booth duty at BEAWorld. &lt;/p&gt;



</comment>
                            <comment id="12436086" author="mikedd" created="Wed, 20 Sep 2006 02:46:29 +0100"  >&lt;p&gt;It looks like creating an extension is fairly straight forward. With the changes Pinaki committed yesterday I was able to create a simple test extension. All I did was create three classes, a ProductDerivation, a PersistenceProvider, and a ConfigurationProvider. I extended PersistenceProductDerivation, PersistenceProviderImpl and ConfigurationImpl respectively, although I suppose one could write their own if they really wanted/needed to.  &lt;/p&gt;

&lt;p&gt;To get a fairly simple wrapper extension working all I had to do was override : ProductDerivation.newConfigurationProvider() , and&lt;br/&gt;
ConfigurationProvider.getPersistenceProviderName(). &lt;/p&gt;

&lt;p&gt;I didn&apos;t see any methods in PersistenceProviderImpl that I needed to change. &lt;/p&gt;

&lt;p&gt;The last thing I did was register the ProductDerivation and PersistenceProvider as services, and update persistence.xml (specifying the new PersistenceProvider for my persistent unit). &lt;/p&gt;

&lt;p&gt;After that the new PersistenceProvider, etc. were used and generated the configuration appropriately (as far as I can tell). Each ProductDerivation is called to load a ConfigurationProvider until the first non-null ConfigurationProvider is found. The ConfigProvider and PersistenceProvider need to match and so forth. &lt;/p&gt;

&lt;p&gt;Is there anything glaring that I missed? Admittedly all I did was a proof of concept. For a real world extension like Kodo 4.1 there will be other bits to change, changing the default properties in ConfigurationProvider.loadGlobals() for example. I&apos;m sure Pinaki will have a more information and a more robust example. &lt;/p&gt;

&lt;p&gt;One other thing I wasn&apos;t clear on is the type for the extension (TYPE_SPEC, TYPE_PRODUCT,etc). My first guess is that any extensions would use TYPE_PRODUCT (value 100), but I could see it being TYPE_PRODUCT_STORE as well. &lt;/p&gt;

&lt;p&gt;PersistenceProductDerivation is TYPE_SPEC (value 0) and the ProductDerivations are sorted in ascending order. If extensions are of TYPE_PRODUCT then the default Apache derivation will always be checked first.  If we assume that when an extension is present it will be used more often than the default we might want to have any extensions&apos; derivations called first. &lt;/p&gt;

&lt;p&gt;That&apos;s all I found. I didn&apos;t mean to steal Pinaki&apos;s thunder, just wanted to show that someone else has had some success. &lt;/p&gt;</comment>
                            <comment id="12436089" author="awhite" created="Wed, 20 Sep 2006 03:10:25 +0100"  >&lt;p&gt;I&apos;ve committed some additional work on this as I reviewed Pinaki&apos;s work.  You should now be able to extend OpenJPA by creating a ProductDerivation like so:&lt;/p&gt;

&lt;p&gt;public class MyProductDerivation &lt;br/&gt;
    extends AbstractProductDerivation {&lt;/p&gt;

&lt;p&gt;    public int getType() &lt;/p&gt;
{
        return TYPE_PRODUCT;
    }

&lt;p&gt;    public boolean beforeConfigurationLoad(Configuration conf) &lt;/p&gt;
{
        Value emf = conf.getValue(EntityManagerFactoryValue.KEY);
        if (emf == null)
            return false;
        emf.setDefault(MyEntityManagerFactoryClass.class.getName());
        emf.setClassName(MyEntityManagerFactoryClass.getName());
        return true;
    }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;With your custom EntityManagerFactory class (which must extend EntityManagerFactoryImpl), you can also override newEntityManagerImpl(Broker) to subclass the EntityManager, and using your EntityManager subclass I believe you can act as a factory for custom QueryImpl, etc extensions.  In addition to the PersistenceProvider.createEMF methods, the static toEntitymanagerFactory/toEntityManager methods in OpenJPAPersistence will also correctly return your custom subclasses.&lt;/p&gt;

&lt;p&gt;So you shouldn&apos;t need a custom ConfigurationProvider or a custom PersistenceProvider anymore.  I&apos;ll be doing some more review of this later to be sure it actually works, barring someone else testing it and telling me it does.&lt;/p&gt;</comment>
                            <comment id="12436323" author="mikedd" created="Wed, 20 Sep 2006 20:41:37 +0100"  >&lt;p&gt;Thanks Abe, I was able to load a custom EMF with your changes. I might have more questions when I get a chance to experiment a little more. &lt;/p&gt;</comment>
                            <comment id="12441142" author="kwsutter" created="Tue, 10 Oct 2006 14:54:35 +0100"  >&lt;p&gt;With Pinaki&apos;s and Abe&apos;s assistance, this JIRA report was resolved.  Thank you.&lt;/p&gt;</comment>
                            <comment id="12463342" author="kwsutter" created="Tue, 9 Jan 2007 16:58:53 +0000"  >&lt;p&gt;Housecleaning...&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 1 Sep 2006 20:04:19 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160362</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt0xr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203332</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>