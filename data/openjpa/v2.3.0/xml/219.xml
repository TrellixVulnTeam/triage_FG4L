<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:36:51 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-219/OPENJPA-219.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-219] Reflection: negative caching would be beneficial in redeployment scenarios</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-219</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;In a variety of situations, OpenJPA searches class hierarchies for fields. These searches invoke Class.getDeclaredField() in order to find non-public fields. This method throws an exception when it fails to find the specified field, and the exception creation is, as ever, slow.&lt;/p&gt;

&lt;p&gt;It would be useful to create a static (and thus per-classloader) Map&amp;lt;WeakReference&amp;lt;Class&amp;gt;,Collection&amp;lt;String&amp;gt;&amp;gt; of fields known not to be available in a given class.&lt;/p&gt;

&lt;p&gt;It may also be beneficial to maintain a cache of which fields &lt;b&gt;are&lt;/b&gt; present in a given class, but this issue is being filed as a result of a demonstrated performance hit during deployment due to the lack of a negative cache. If we obtain quantitative data indicating that a positive cache would be useful, we might want to implement such a thing at that time.&lt;/p&gt;

&lt;p&gt;Trace 3 (2115 occurances): &lt;span class=&quot;error&quot;&gt;&amp;#91;excepti&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;00090&amp;#93;&lt;/span&gt; java/lang/NoSuchFieldException: domainName&lt;br/&gt;
     at java/lang/Class.getDeclaredField(Ljava/lang/String;I)Ljava/lang/reflect/Field;(Unknown Source)&lt;br/&gt;
     at org/apache/openjpa/enhance/Reflection.findField(Ljava/lang/Class;Ljava/lang/String;Z)Ljava/lang/reflect/Field;(Reflection.java:101)&lt;br/&gt;
     at org/apache/openjpa/util/ApplicationIds.toPKValues(Ljava/lang/Object;Lorg/apache/openjpa/meta/ClassMetaData&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;[Ljava/lang/Object;&lt;br/&gt;
(ApplicationIds.java:89)&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12367409">OPENJPA-219</key>
            <summary>Reflection: negative caching would be beneficial in redeployment scenarios</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pcl">Patrick Linskey</assignee>
                                    <reporter username="pcl">Patrick Linskey</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 Apr 2007 21:31:32 +0100</created>
                <updated>Tue, 9 Mar 2010 18:32:34 +0000</updated>
                            <resolved>Wed, 25 Apr 2007 00:38:07 +0100</resolved>
                                    <version>0.9.0</version>
                    <version>0.9.6</version>
                    <version>0.9.7</version>
                                    <fixVersion>1.0.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12489536" author="pcl" created="Tue, 17 Apr 2007 21:37:45 +0100"  >&lt;p&gt;Note that we invoke Class.getDeclaredField() (and Class.getDeclaredMethod()) in a number of places. We should take care to replace all the uses of that method with our optimized version.&lt;/p&gt;</comment>
                            <comment id="12489556" author="pcl" created="Tue, 17 Apr 2007 22:56:53 +0100"  >&lt;p&gt;I think that this patch should fix the issue, but haven&apos;t tested it yet. I only replaced the getDeclaredField() cases that were iterating through superclasses.&lt;/p&gt;</comment>
                            <comment id="12489578" author="pcl" created="Wed, 18 Apr 2007 01:29:34 +0100"  >&lt;p&gt;New version of patch that uses iterated class instead of method argument.&lt;/p&gt;</comment>
                            <comment id="12491038" author="awhite" created="Mon, 23 Apr 2007 21:00:37 +0100"  >&lt;p&gt;If we&apos;re going to cache, I don&apos;t see why we wouldn&apos;t cache the declared fields/methods rather than the nonexistent ones.  It would be a simple matter of keeping a Class-&amp;gt;Set cache, where the Set is the names of the fields/methods returned by Class.getDeclaredFields/Methods().  Then we&apos;d have both a positive (set.contains&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) and negative (!set.contains&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) cache.&lt;/p&gt;

&lt;p&gt;I&apos;d also like to see some explicit control over whether requests to find a field/method cause cache additions.  It might be that we always want caching now, but it&apos;s such a general class that I can imagine na&#239;vely using the Reflection class&apos;s helper methods on one-off random field/method requests in the future without remembering the memory consequences.  If all use results in caching, that could be bad.  So I&apos;d like us to either add separate caching methods or a boolean parameter to the existing methods.  And either way, we need to revisit our current use of Reflection to decide which version to use in the current code.&lt;/p&gt;</comment>
                            <comment id="12491077" author="bretweinraub" created="Mon, 23 Apr 2007 22:49:26 +0100"  >&lt;p&gt;I developed a patch version that cached both &quot;success&quot; and &quot;failure&quot; cases - here are some of the performance numbers I generated:&lt;/p&gt;

&lt;p&gt;VM	Implementation	Benchmark Rate (ms)&lt;br/&gt;
Sun	1 - Original	333&lt;br/&gt;
Sun	2 - Cache v1	83&lt;br/&gt;
Sun	3 - Cache v2	40&lt;br/&gt;
JRockit	1 - Original	176&lt;br/&gt;
JRockit	2 - Cache v1	72&lt;br/&gt;
JRockit	3 - Cache v2	22&lt;/p&gt;

&lt;p&gt;Where &lt;/p&gt;

&lt;p&gt;Original : recent svn version&lt;br/&gt;
Cache V1: patch above plus a couple of minor tweaks&lt;br/&gt;
Cache V2: caches both success and failure calls thereby minimizing calls to Reflection API.&lt;/p&gt;

&lt;p&gt;Adding a boolean that says &quot;use cache&quot; or not would be simple.&lt;/p&gt;

&lt;p&gt;Anyway let me add that I/we feel that permanently caching Class objects would create memory leak problems in the case where a ClassLoader were to be thrown away.  Holding the class Object in a hash will keep the ClassLoader tree from being garbage collected ; we see this anti-pattern frequently, it is pathalogical, and can eventually lead to OOME for operations that recycle class loaders.  An example would be repeatedly deploying the same application to an application server, such as done during iterative development of WebApps/EnterpriseApps.  So I/we believe to be critical to create a mechanism whereby these Class object were not held in a static context.  If this code were associated with an object then when the object was GC-ed the Class references would be eliminated therey by allowing the class loader to be GC-ed.&lt;/p&gt;
</comment>
                            <comment id="12491078" author="bretweinraub" created="Mon, 23 Apr 2007 22:59:42 +0100"  >&lt;p&gt;I will add the &quot;Cache v2&quot; version here shortly.&lt;/p&gt;</comment>
                            <comment id="12491104" author="pcl" created="Tue, 24 Apr 2007 01:23:03 +0100"  >&lt;p&gt;I agree about the mem leak problem in the patch that I created; hence my comments in the original post about using weak references. There are a number of ways that you could solve this caching problem, such as making all / part of Reflection non-static and setting up per-Configuration caches, or using weak references in the cache, or even (and probably least attractively) creating undeploy APIs.&lt;/p&gt;

&lt;p&gt;Abe said: &lt;br/&gt;
&amp;gt; If we&apos;re going to cache, I don&apos;t see why we wouldn&apos;t cache the declared &lt;br/&gt;
&amp;gt; fields/methods rather than the nonexistent ones. It would be a simple&lt;br/&gt;
&amp;gt; matter of keeping a Class-&amp;gt;Set cache, where the Set is the names of &lt;br/&gt;
&amp;gt; the fields/methods returned by Class.getDeclaredFields/Methods(). &lt;br/&gt;
&amp;gt; Then we&apos;d have both a positive (set.contains&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) and negative &lt;br/&gt;
&amp;gt; (!set.contains&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) cache.&lt;/p&gt;

&lt;p&gt;As I mentioned in the original description, the bug here is that negative lookups are slow because of the exception creation. I see no reason to add extra caching if we don&apos;t know if we need it, although Bret&apos;s numbers potentially indicate that there is a benefit to positive caching. I have no problem with having a positive cache, but I think that we should only include it if it&apos;s going to help, since otherwise it&apos;ll just be one more thing contributing to memory consumption.&lt;/p&gt;</comment>
                            <comment id="12491310" author="awhite" created="Tue, 24 Apr 2007 15:54:57 +0100"  >&lt;p&gt;1. Yes, clearly we&apos;d use our org.apache.openjpa.lib.util.concurrent. ConcurrentReferenceHashMap with weak keys to hold the Classes.&lt;/p&gt;

&lt;p&gt;2. We have no evidence that a positive cache would consume any more memory than a negative cache in this case.  A positive cache&apos;s entry size for a given class is limited by the number of fields/methods in that class.  A negative cache&apos;s entry size is limited only by how many nonexistent field/method names we look for.  The negative cache will probably be smaller in this case except in deep inheritance hierarchies because I don&apos;t think we look for field or method names outside the inheritance hierarchy, but (a) I&apos;m not sure of that and (b) there&apos;s no guarantee that will always be the case.&lt;/p&gt;

&lt;p&gt;3. You know, another way to approach this would be not to cache at all, and just iterate over getDeclaredFields/Methods() looking for a match rather than using the singular getDeclaredField/Method() that throws an exception.  If that gives decent performance, we wouldn&apos;t have to worry about the memory consumption and complication of caching.  Bret, do you think you could try that out and see how it does?&lt;/p&gt;</comment>
                            <comment id="12491316" author="pcl" created="Tue, 24 Apr 2007 16:17:38 +0100"  >&lt;p&gt;&amp;gt; another way to approach this would be not to cache at all,&lt;br/&gt;
&amp;gt; and just iterate over getDeclaredFields/Methods() looking for a match&lt;/p&gt;

&lt;p&gt;Good point. That would certainly be a better approach. It looks like Class.getDeclaredFields() will be a bit slower, since more memory copying happens (the array is copied before being returned &amp;#8211; bummer that those APIs don&apos;t use collections), but that might not be noticeable in the benchmark.&lt;/p&gt;</comment>
                            <comment id="12491453" author="bretweinraub" created="Tue, 24 Apr 2007 22:06:48 +0100"  >&lt;p&gt;Includes a non-caching performance enhancement for Reflection.findField()&lt;/p&gt;

&lt;p&gt;Other implementations held on to references to class objects in static collections.   If the class loader which created this Class went away (like an application classloader during redeployment), this reference would prevent the ClassLoader object and associated Class objects from being garbage collected, which would have led to a memory leak.&lt;/p&gt;

&lt;p&gt;This version is about 3X faster than the original for JRockit, and about 5X faster for HotSpot.&lt;/p&gt;</comment>
                            <comment id="12491458" author="pcl" created="Tue, 24 Apr 2007 22:16:29 +0100"  >&lt;p&gt;How does this compare to the leaky-patch version?&lt;/p&gt;</comment>
                            <comment id="12491470" author="bretweinraub" created="Tue, 24 Apr 2007 23:07:26 +0100"  >&lt;p&gt;The no-leak version is &quot;cache v3&quot; although that&apos;s a misnomer ; there&apos;s no cache involved.&lt;/p&gt;

&lt;p&gt;VM - Version ms&lt;/p&gt;

&lt;p&gt;Sun - Original 333&lt;br/&gt;
Sun - Cache v1 83&lt;br/&gt;
Sun - Cache v2 40&lt;br/&gt;
Sun - Cache v3 73&lt;/p&gt;

&lt;p&gt;JRockit - Original 176&lt;br/&gt;
JRockit - Cache v1 72&lt;br/&gt;
JRockit - Cache v2 22&lt;br/&gt;
JRockit - Cache v3 52&lt;/p&gt;
</comment>
                            <comment id="12491472" author="bretweinraub" created="Tue, 24 Apr 2007 23:19:14 +0100"  >&lt;p&gt;My benchmark code.&lt;/p&gt;

&lt;p&gt;Easy to write a new implementation and get comparitive benchmark data.&lt;/p&gt;

&lt;p&gt;Measurements created in this issue were generated from this code.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12356183" name="OPENJPA-219-NoLeak.patch" size="2825" author="bretweinraub" created="Tue, 24 Apr 2007 22:06:48 +0100"/>
                            <attachment id="12355723" name="OPENJPA-219.patch" size="4295" author="pcl" created="Wed, 18 Apr 2007 01:29:33 +0100"/>
                            <attachment id="12356186" name="openJPABenchmark.tar.gz" size="29438" author="bretweinraub" created="Tue, 24 Apr 2007 23:19:13 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 23 Apr 2007 20:00:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160550</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hysw33:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>202546</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>