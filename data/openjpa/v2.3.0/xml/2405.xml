<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:34:50 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-2405/OPENJPA-2405.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-2405] EntityManager.merge does not work for entity that is managed by another EntityManager</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-2405</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;EntityManager.merge does not work for entity that is managed by another EntityManager. Instead of updating that entity OpenJPA tries to persist the entity a second time&lt;/p&gt;</description>
                <environment></environment>
        <key id="12654693">OPENJPA-2405</key>
            <summary>EntityManager.merge does not work for entity that is managed by another EntityManager</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="fyrewyld">Jody Grassel</assignee>
                                    <reporter username="arne">Arne Limburg</reporter>
                        <labels>
                    </labels>
                <created>Tue, 25 Jun 2013 10:38:19 +0100</created>
                <updated>Mon, 1 Jul 2013 19:59:08 +0100</updated>
                            <resolved>Mon, 1 Jul 2013 18:04:14 +0100</resolved>
                                    <version>2.2.3</version>
                                    <fixVersion>2.3.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                    <timeoriginalestimate seconds="7200">2h</timeoriginalestimate>
                            <timeestimate seconds="7200">2h</timeestimate>
                                        <comments>
                            <comment id="13692893" author="arne" created="Tue, 25 Jun 2013 10:40:06 +0100"  >&lt;p&gt;Added test that reproduces the problem&lt;/p&gt;</comment>
                            <comment id="13693020" author="allee8285" created="Tue, 25 Jun 2013 14:25:22 +0100"  >&lt;p&gt;Per Spec:&lt;br/&gt;
====================&lt;br/&gt;
3.2.7.1 Merging Detached Entity State&lt;br/&gt;
The merge operation allows for the propagation of state from detached entities onto persistent entities&lt;br/&gt;
managed by the entity manager.&lt;br/&gt;
The semantics of the merge operation applied to an entity X are as follows:&lt;br/&gt;
........&lt;br/&gt;
&#8226; If X is a managed entity, it is ignored by the merge operation, however, the merge operation is&lt;br/&gt;
cascaded to entities referenced by relationships from X if these relationships have been annotated&lt;br/&gt;
with the cascade element value cascade=MERGE or cascade=ALL annotation.&lt;br/&gt;
====================&lt;/p&gt;

&lt;p&gt;merge() is for &quot;detached&quot; entity only. If it is &quot;managed&quot;, it is IGNORED.....&lt;/p&gt;</comment>
                            <comment id="13693671" author="arne" created="Wed, 26 Jun 2013 07:01:39 +0100"  >&lt;p&gt;1. So you agree with me that it is a BUG that OpenJPA tries to INSERT the entity and throws an exception due to the duplicate key?&lt;/p&gt;

&lt;p&gt;2. Yes, I have read that chapter of the spec, too. And I come to the conclusion, that the only way to interpret it, is that managed entities of the SAME persistence context are meant.&lt;br/&gt;
Your way of reading the spec simply does not work. Think of the following situation:&lt;br/&gt;
 a. Entity A is loaded by EntityManager X. Entity A has a Cascade.ALL relation to Entity B.&lt;br/&gt;
 b. Entity B is newly created and assigned to A&lt;br/&gt;
 c. Entity A is merged to EntityManager Y.&lt;br/&gt;
Now Entity B would be managed by EntityManager Y due to the cascading behavior you cited. In addition Entity B would be managed by EntityManager X due to 3.2.4&lt;/p&gt;

&lt;p&gt;Spec 3.24&lt;br/&gt;
=====================&lt;br/&gt;
The semantics of the flush operation, applied to an entity X are as follows:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If X is a managed entity, it is synchronized to the database.&lt;/li&gt;
	&lt;li&gt;For all entities Y referenced by a relationship from X, if the relationship to Y has been annotated with the cascade element value cascade=PERSIST or cascade=ALL, the persist operation is applied to Y.&lt;br/&gt;
=====================&lt;br/&gt;
How do you think OpenJPA should behave in such situation? Should Entity B be managed by two persistence contexts?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Btw. Any other persistence provider returns a managed copy of Entity A in such situation, no matter if A is managed by another persistence context or detached. And this is the expected behavior, I guess.&lt;/p&gt;</comment>
                            <comment id="13694802" author="allee8285" created="Thu, 27 Jun 2013 16:37:16 +0100"  >&lt;p&gt;I am just pointing out that merge() is meant for merging DETACHED entity into a persistence context. If an entity is managed by the SAME persistence context, there is nothing to merge since the state of X is already maintained, hence the merge operation is ignored. However, the child relationship is still processed if proper cascade is specified.&lt;/p&gt;

&lt;p&gt;The spec also spelled out the following;&lt;br/&gt;
=================================&lt;br/&gt;
3.2.8 Managed Instances&lt;br/&gt;
It is the responsibility of the application to insure that an instance is managed in only a single persistence&lt;br/&gt;
context. The behavior is undefined if the same Java instance is made managed in more than one&lt;br/&gt;
persistence context.&lt;br/&gt;
=================================&lt;/p&gt;

&lt;p&gt;In the original test case,  A (managed by em, not detached) is merged to em2 and there is no managed A in em2. Since A is marked managed and not managed in em2, OpenJPA creates a new managed instance in em2 and eventually &quot;INSERT&quot; to the database. I am not saying this is the right or wrong behavior but this use case is undefined.&lt;/p&gt;

&lt;p&gt;If you wants to merge changed content in A to a different persistence context, you may have to do:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;em.find(A);&lt;/li&gt;
	&lt;li&gt;detach A from em2&lt;/li&gt;
	&lt;li&gt;make changes to A&lt;/li&gt;
	&lt;li&gt;em2.find(A);&lt;/li&gt;
	&lt;li&gt;em2.merge(A);&lt;/li&gt;
	&lt;li&gt;commit/flush em2&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13694882" author="arne" created="Thu, 27 Jun 2013 18:16:17 +0100"  >&lt;p&gt;Yes, I know how I could make it work in the test case.&lt;br/&gt;
Unfortunately this is not true for real life applications.&lt;br/&gt;
The problem occured in a web-app with concurrent requests.&lt;br/&gt;
I load the entity within one request and the EntityManager is closed after that request.&lt;br/&gt;
In the second request I merge that entity to have an attached instance again.&lt;br/&gt;
Unfortunately from time to time the second request comes in when the first is not completely finished and the first EntityManager is still open. Then the problem occures.&lt;/p&gt;

&lt;p&gt;So, until this behavior of OpenJPA is not fixed, I cannot have concurrent requests with JPA?&lt;/p&gt;

&lt;p&gt;Btw. I am willing to help fixing this issue.&lt;/p&gt;

&lt;p&gt;Is it common sense that the best behavior in the described case would be that OpenJPA simply copies the state of the entity?&lt;/p&gt;</comment>
                            <comment id="13695338" author="struberg" created="Fri, 28 Jun 2013 10:24:21 +0100"  >&lt;p&gt;Well, imo it&apos;s an OpenJPA bug in any case. If we simply ignore managed entities in em.merge() than we must not insert the children into the database twice neither.&lt;/p&gt;

&lt;p&gt;Regarding 3.2.8: In this paragraph &apos;instance&apos; clearly does not mean &apos;entity identity&apos; but &apos;java identity&apos; as indicated by the sentence: &quot;The behavior is undefined if the same Java instance is made managed in more than one persistence context.&quot;&lt;/p&gt;

&lt;p&gt;In any case I&apos;m not sure if &apos;fixing&apos; this would help you, Arne.&lt;/p&gt;

&lt;p&gt;I guess it&apos;s all about the entitymanager-per-request pattern and a premature redirect().&lt;br/&gt;
In this case it might happen that finishing the first request (the one with the redirect) takes longer to end than the new request to hit the server (in a parallel thread now).&lt;br/&gt;
In this case the flush() on the first request might change your records in the db and also update the @Version in those Entities. So even if you would get the entity merged into another EM in the 2nd request it would contain the old @Version and you will blow up at the end of the 2nd request with an OptimisticLockException. Doesn&apos;t sound good neither, right? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;There are now 2 ways to solve this issue in your application (even without changing OpenJPA)&lt;/p&gt;

&lt;p&gt;1.) Use a Servlet Filter to synchronize on your Session for those requests. Be careful as this might cause unnecessary locks ...&lt;/p&gt;

&lt;p&gt;2.) explicitly invoke em.flush() and em.close() before you do the redirect. And hope that your @Transactional Interceptor can deal with it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; For JSF apps we might be able to register a hook for the redirect in the FacesContext. Need to check...&lt;/p&gt;

&lt;p&gt;This might btw also work a bit different depending if you use synchronized or unsynchronized EM (see JTA-2.1 and em.joinTransaction()).&lt;/p&gt;

&lt;p&gt;Summary: multi-page &apos;wizard&apos; style pages without DTOs suck at this time. We need this new pattern we&apos;ve talked about last week where we use em.joinTransaction() to explicitly store the entity in the &apos;save&apos; action on the last page - without having the em.merge() operations automagically prematurely store all changes into the database on the intermediate pages. Still thinking about how this can be done best with OpenJPA&lt;/p&gt;</comment>
                            <comment id="13695643" author="fyrewyld" created="Fri, 28 Jun 2013 19:29:42 +0100"  >&lt;p&gt;Just reviewing this JIRA and wanted to post my own thoughts.  First, some clips from the JPA Specification that I think are relevant:&lt;/p&gt;

&lt;p&gt;3.2 Entity Instance&#8217;s Life Cycle&lt;br/&gt;
This section describes the EntityManager operations for managing an entity instance&#8217;s lifecycle. An entity instance can be characterized as being new, managed, detached, or removed.&lt;br/&gt;
&#65532;&#65532;&#65532;&#65532;&#8226; &#8226; &#8226; &#8226;&lt;br/&gt;
A new entity instance has no persistent identity, and is not yet associated with a persistence context.&lt;br/&gt;
A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.&lt;br/&gt;
A detached entity instance is an instance with a persistent identity that is not (or no longer) associated with a persistence context.&lt;br/&gt;
A removed entity instance is an instance with a persistent identity, associated with a persistence context, that will be removed from the database upon transaction commit.&lt;/p&gt;

&lt;p&gt;&amp;#8211; What I take from this is that an Entity Class that has been freshly created by its constructor (ie, not created by em.find() or a JPA query) and has never, ever been touched by an em.persist() or em.merge() operation is a &quot;new entity&quot;.  Such an object will not have any StateManager (DetachedStateManager or otherwise, it is simply null) associated with its internal state (internal state being the hidden variables added by enhancement.)&lt;/p&gt;

&lt;p&gt;&amp;#8211; A &quot;managed entity&quot; is an Entity Class instance that has a link to a live StateManager in its internal state &amp;#8211; and there&apos;s caveats to that.  A StateManager is associated to one and only one Persistence Context (ie, EntityManager instance) - to those and only those Persistence Contexts is the entity a &quot;managed entity&quot;.  A new entity becomes a managed entity when em.persist() or em.merge() is called on it.  (Managed entities are also provided by find/query operations (though it would return a detached entity if it&apos;s a CMTS entitymanager invocation outside of a transaction.))&lt;/p&gt;

&lt;p&gt;&amp;#8211; To any other Persistence Context, because it is not &quot;new&quot; (because it has a StateManager object associated with it) and has a non DetachedStateManager that is associated with another Persistence Context, it should be interpreted as a &quot;detached entity&quot; (even if the StateManager associated with the Entity Object instance&apos;s internal state is not a DetachedStateManager.)  So calling em.merge(entityWithSomeOtherPCsStateManager) should be treated as a detached entity, and return a new Entity Object instance.  Which could create &quot;interesting problems&quot; if the original entity doesn&apos;t have a committed row on the database yet (because the two different PCs will have two different db connections, and a merge operation will trigger a fetch operation from the database/cache.)  Remember the JPA spec requires Read-Committed to be the minimum isolation level.&lt;/p&gt;</comment>
                            <comment id="13695651" author="fyrewyld" created="Fri, 28 Jun 2013 19:39:51 +0100"  >&lt;p&gt;Further Thoughts, as I realize the statement &quot;A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.&quot; could be read differently than how I read it (using the 2.1 spec, which should not be different from previous spec iterations.)&lt;/p&gt;

&lt;p&gt;3.2.8 Managed Instances&lt;br/&gt;
It is the responsibility of the application to insure that an instance is managed in only a single persistence context. The behavior is undefined if the same Java instance is made managed in more than one persistence context.&lt;/p&gt;

&lt;p&gt;The contains() method can be used to determine whether an entity instance is managed in the current persistence context.&lt;/p&gt;

&lt;p&gt;&amp;#8211; What I take from here is that from the perspective of a Persistence Context, an entity is managed if and only if it is actively associated with it.  So an Entity Object instance with a StateManager associated with PCtx#1 is a &quot;managed entity&quot; only from the perspective of PCtx#1 (emPCTX1.contains(entity) returns true).  Any other PCtxs, such as PCtx#2 would see that it has a StateManager that is not associated with it so it is neither &quot;new&quot; nor &quot;managed&quot; (by PCtx#2) and should consider it to be unmanaged (detached, since it cannot be a &quot;new&quot; entity for reasons previously stated) - in this case emPCTX2(entity) returns false.&lt;/p&gt;</comment>
                            <comment id="13695657" author="struberg" created="Fri, 28 Jun 2013 19:44:13 +0100"  >&lt;p&gt;&amp;gt; Managed entities are also provided by find/query operations (though it would return a detached entity if it&apos;s a CMTS entitymanager invocation outside of a transaction.)&lt;/p&gt;

&lt;p&gt;Well, this is not quite what I do read from the JPA and JTA specs. The spec says that in such cases all query operations must succeed (thus also lacy loading shall work) but all write operations must get queued until the EntityManager joins a transaction.&lt;br/&gt;
And this mechanism is lacking in OpenJPA I fear. At least I&apos;m not aware that we can do this somehow.&lt;/p&gt;</comment>
                            <comment id="13695672" author="fyrewyld" created="Fri, 28 Jun 2013 19:54:22 +0100"  >&lt;p&gt;Outside of a tran, a CMTS EM find/query will work, the spec/javadoc just requires that the entities returned are detached.  Anyways, that really isn&apos;t relevant to this JIRA.&lt;/p&gt;

&lt;p&gt;And I focused a bit too much on the first part and gave just a partial answer.&lt;/p&gt;

&lt;p&gt;As I interpret it, write operations are queued, and it&apos;s up to the persistence provider to decide when to flush them to the database (with em.flush() and tran commit being the &quot;push everything to the database and do it Now&quot; tools.)  However, because of the Read Committed isolation policy, a new Entity that has been persisted and made managed by EM#1, even if flushed () (but not tran committed yet) will not be detectable to any other EM because EM#(not 1) doesn&apos;t share the same JDBC connection.  So EM#1 could conceivably automatically sync every mutation as it comes in from the application to the database, but it&apos;s invisible until that critical tran.commit() takes place.&lt;/p&gt;</comment>
                            <comment id="13695690" author="struberg" created="Fri, 28 Jun 2013 20:15:22 +0100"  >&lt;p&gt;Jody, I&apos;m not sure if the Entity of such a unsynchronized CMTS EM would be &apos;detached&apos;. At least according to what I talked with Mike Keith (assuming that I didn&apos;t misunderstand him) lazy loading and graph traversal would work for such entitites.&lt;/p&gt;

&lt;p&gt;I agree with your 2nd part. Having the same db row managed in 2 different EMs will either not see each other properly or if they do (update case) most likely cause an OptimisticLockingException in one of them - at least if both write!&lt;/p&gt;</comment>
                            <comment id="13695705" author="fyrewyld" created="Fri, 28 Jun 2013 20:28:28 +0100"  >&lt;p&gt;Looking at the attached test, my opinion is that the following should happen:&lt;/p&gt;

&lt;p&gt;1) The call to populate(), before the test begins, creates a new em, adds a row to the database, commits, and destroys the em.&lt;br/&gt;
2) Enter testMergeManagedParent()&lt;br/&gt;
3) Parent parent = em.find(Parent.class, pk); - returns an instance of Parent (id=K1) with an address of, say, @0000001.&lt;br/&gt;
4) Parent mergedParent = em2.merge(parent); - sees parent is not &quot;new&quot; (because it has a StateManager), and that its associated StateManager belongs to em and not em2, should view parent as a detached entity - so it should perform a fetch from the database, create a new object, say, @0000002, and bring in any fields which have been mutated in @0000001 (which in this case, are none), and return @0000002 to the caller which is saved in the mergedParent field.&lt;/p&gt;

&lt;p&gt;It&apos;s a little different scenario than what I was initially led to believe (I thought the scenario would have been the em from step #3 was creating a new entity object instance, here, the row already exists on the db before the test logic runs.)&lt;/p&gt;

&lt;p&gt;Does anyone disagree with this?&lt;/p&gt;</comment>
                            <comment id="13695758" author="fyrewyld" created="Fri, 28 Jun 2013 21:31:52 +0100"  >&lt;p&gt;I propose the attached fix for this issue, which allows the reporter&apos;s sample test to pass.&lt;/p&gt;

&lt;p&gt;Basically the idea is simple: check if the object to be merged (toAttach) has a StateManager associated with it.  If it does and that StateManager is a StateManagerImpl (which DetachedStateManager is not a descendent of) then grab its broker reference.&lt;/p&gt;

&lt;p&gt;If this broker reference is different than the broker being used to perform the merge() operation, then set isManagedByAnotherPCtx=true.&lt;/p&gt;

&lt;p&gt;Then modify isNew to the following logic:&lt;/p&gt;

&lt;p&gt;boolean isNew = !broker.isDetached(pc) &amp;amp;&amp;amp; !isManagedByAnotherPCtx;&lt;/p&gt;

&lt;p&gt;Basically, if toAttach is not detached and it is not managed by another persistence context, then it is to be considered a new object.  If toAttach is not detached (because pc.isDetached() is not broker context aware) but if it is managed by some other broker,t hen it should NOT be considered a new object.&lt;/p&gt;

&lt;p&gt;(Disclaimer: have not run the full junit suite yet, will do so after posting this.)&lt;/p&gt;</comment>
                            <comment id="13695767" author="fyrewyld" created="Fri, 28 Jun 2013 21:39:27 +0100"  >&lt;p&gt;I would also like to take the time to make the reminder that the 2.2.x is managed by IBM, any changes to this branch will need to go through the PMR process.  Otherwise, if the general consensus decides that this is an appropriate fix it will have to go into trunk.&lt;/p&gt;</comment>
                            <comment id="13696961" author="jira-bot" created="Mon, 1 Jul 2013 17:58:12 +0100"  >&lt;p&gt;Commit 1498565 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fyrewyld&quot; class=&quot;user-hover&quot; rel=&quot;fyrewyld&quot;&gt;Jody Grassel&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1498565&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1498565&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-2405&quot; title=&quot;EntityManager.merge does not work for entity that is managed by another EntityManager&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-2405&quot;&gt;&lt;del&gt;OPENJPA-2405&lt;/del&gt;&lt;/a&gt;: EntityManager.merge does not work for entity that is managed by another EntityManager&lt;/p&gt;</comment>
                            <comment id="13696964" author="fyrewyld" created="Mon, 1 Jul 2013 17:58:53 +0100"  >&lt;p&gt;Fix has been checked into trunk.&lt;/p&gt;</comment>
                            <comment id="13697068" author="arne" created="Mon, 1 Jul 2013 19:59:08 +0100"  >&lt;p&gt;Thanks for fixing this, Jody. Your suggested (and implemented) behavior matches my expectation &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12589574" name="OPENJPA-2405.patch" size="2530" author="arne" created="Tue, 25 Jun 2013 10:40:06 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 25 Jun 2013 13:25:22 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>334970</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hzfmhj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>335294</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>