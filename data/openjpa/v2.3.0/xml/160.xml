<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:32:38 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-160/OPENJPA-160.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-160] Reuse BrokerImpl objects</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-160</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description></description>
                <environment></environment>
        <key id="12363424">OPENJPA-160</key>
            <summary>Reuse BrokerImpl objects</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12361497">OPENJPA-115</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pcl">Patrick Linskey</assignee>
                                    <reporter username="mikedd">Michael Dick</reporter>
                        <labels>
                    </labels>
                <created>Thu, 22 Feb 2007 17:47:32 +0000</created>
                <updated>Tue, 17 Apr 2007 19:38:46 +0100</updated>
                            <resolved>Wed, 28 Feb 2007 19:22:57 +0000</resolved>
                                                    <fixVersion>0.9.7</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12475102" author="mikedd" created="Thu, 22 Feb 2007 17:48:15 +0000"  >&lt;p&gt;Another performance issue we&apos;ve run into is the overhead of creating a new BrokerImpl object when the application calls createEntityManager. The JPA spec clearly states that the provider needs to return a new EntityManager instance, and we&apos;re not trying to circumvent that requirement. However it seems plausible that we could reuse the underlying BrokerImpl object, once all the persistence data has been cleared (ie after BrokerImpl.free has been called). Implementing a fairly simple object reuse pool resulted in a significant performance improvement in our testing. I don&apos;t see this as being a violation of the intent of the spec, but I&apos;d rather get a sense of consensus before I/we go any further. &lt;/p&gt;

&lt;p&gt;Questions : &lt;/p&gt;

&lt;p&gt;1. Is there a reason why we can&apos;t reuse the BrokerImpl objects? &lt;/p&gt;

&lt;p&gt;2. Assuming we can reuse the objects, where should we put the reuse pool? The original implementation created a static map in AbstractBrokerFactory. I&apos;m not sure that&apos;s the best place for it though. BrokerImpl isn&apos;t a final class it&apos;s possible that different configurations could use different broker implementations (through the broker plugin). Maybe we need a new plugin which indicates that class to use as a Broker pool? &lt;/p&gt;

&lt;p&gt;3. Should we pool the broker instances by default? I think we&apos;ll want this to be configurable, but I&apos;m not sure it needs to be on by default. &lt;/p&gt;

&lt;p&gt;Justification : &lt;br/&gt;
We&apos;ve been running tests with the Sun Application Server and adding in a BrokerImpl reuse pool brings the performance on par with Hibernate. &lt;/p&gt;</comment>
                            <comment id="12475108" author="pcl" created="Thu, 22 Feb 2007 18:05:20 +0000"  >&lt;p&gt;&amp;gt; 1. Is there a reason why we can&apos;t reuse the BrokerImpl objects?&lt;/p&gt;

&lt;p&gt;Architecturally, none that I can think of. But we should take care to ensure that BrokerImpl.free() really does enough work to close up resources appropriately. Also, I&apos;d love to take a look at some profiling data to see if we can just optimize creation of brokers instead of adding the complexity of a pool.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2. Assuming we can reuse the objects, where should we put the reuse pool? The &lt;br/&gt;
&amp;gt; original implementation created a static map in AbstractBrokerFactory. I&apos;m not sure &lt;br/&gt;
&amp;gt; that&apos;s the best place for it though. BrokerImpl isn&apos;t a final class it&apos;s possible that &lt;br/&gt;
&amp;gt; different configurations could use different broker implementations (through the &lt;br/&gt;
&amp;gt; broker plugin). Maybe we need a new plugin which indicates that class to use as &lt;br/&gt;
&amp;gt; a Broker pool?&lt;/p&gt;

&lt;p&gt;The two options that I see are a Configuration option and a non-static field in AbstractBrokerFactory. I think that I prefer making it an OpenJPAConfiguration option, so that it&apos;s more easily configurable. Configuration would look like so:&lt;/p&gt;

&lt;p&gt;&amp;lt;property name=&quot;openjpa.BrokerPool&quot; value=&quot;Size=50&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;If BrokerImpl.free() purges the data passed in to the newBroker() call, then we should be able to just use a set. In this scenario, the newBroker() code would then grab something from the set, populate the obtained broker with the data passed into the newBroker() call, and return it. &lt;/p&gt;

&lt;p&gt;If BrokerImpl.free() leaves the broker in a state where the data passed into newBroker() is relevant, then we should create a key (probably a private inner class) that includes that data in it, and maintain a map of sets, keyed off of that data. &lt;/p&gt;

&lt;p&gt;All things equal, I&apos;d prefer if we could use a Set (the first case).&lt;/p&gt;

&lt;p&gt;&amp;gt; 3. Should we pool the broker instances by default? I think we&apos;ll want this to be &lt;br/&gt;
&amp;gt; configurable, but I&apos;m not sure it needs to be on by default.&lt;/p&gt;

&lt;p&gt;We should use the pooling logic, but allow the user to control the pool size. If this is a performance benefit, then we should choose some reasonable initial pool size. I have no idea what &apos;reasonable&apos; is.&lt;/p&gt;</comment>
                            <comment id="12475167" author="pcl" created="Thu, 22 Feb 2007 21:27:20 +0000"  >&lt;p&gt;Note that AbstractBrokerFactory already has a data structure for holding weak refs to open brokers. We&apos;d presumably want to incorporate that data structure into whatever we did for pooling.&lt;/p&gt;</comment>
                            <comment id="12475238" author="clr" created="Fri, 23 Feb 2007 01:32:57 +0000"  >&lt;p&gt;I think it&apos;s great that profiling EntityManager creation resulted in this analysis. &lt;/p&gt;

&lt;p&gt;I&apos;d like to know why Broker creation is so expensive. Most of the static information should be kept in the Broker factory so configuring and looking up stuff should be &quot;free&quot;. The only thing that is needed for a new Broker should be the various identity maps and such that bind the EM to the persistence context. These artifacts should be just as cheap to create as to clear.&lt;/p&gt;

&lt;p&gt;Until we understand why it&apos;s so expensive to create Brokers, I&apos;d like to stay away from pools. From my experience, trying to dynamically manage pools is extremely difficult, and making the user responsible for tuning the pools is a disaster waiting to happen.&lt;/p&gt;</comment>
                            <comment id="12475363" author="awhite" created="Fri, 23 Feb 2007 15:38:16 +0000"  >&lt;p&gt;+1 to Craig&apos;s comments.  &lt;/p&gt;</comment>
                            <comment id="12475455" author="mikedd" created="Fri, 23 Feb 2007 20:06:19 +0000"  >&lt;p&gt;We ran some more performance tests with the latest OpenJPA code and the issue appears to be with creating an instance of the BrokerImpl (when Configurations calls Class.newInstance). &lt;/p&gt;

&lt;p&gt;I was surprised that creating a new instance turned out to take so much time and  I don&apos;t know what we&apos;d could (or would want to) tinker with to try to make it faster to create. I&apos;m not thrilled about adding the complexity of a reuse pool so I&apos;m open to suggestions. &lt;/p&gt;

&lt;p&gt;The pool that we used before was a two level pool thread.toString+user+pass -&amp;gt; collection of brokers. Adding a non static field to AbstractBrokerFactory sounds feasible too (unless there&apos;s an alternative to pooling).&lt;/p&gt;

&lt;p&gt;Still looking into whether we need a key in BrokerImpl - I&apos;ll follow up on that as well. &lt;/p&gt;</comment>
                            <comment id="12475465" author="pcl" created="Fri, 23 Feb 2007 20:14:28 +0000"  >&lt;p&gt;Do you have any stack traces or anything that you can share to help debug the issue?&lt;/p&gt;</comment>
                            <comment id="12475507" author="clr" created="Fri, 23 Feb 2007 21:38:42 +0000"  >&lt;p&gt;&amp;gt;We ran some more performance tests with the latest OpenJPA code and the issue appears to be with creating an instance of the BrokerImpl (when Configurations calls Class.newInstance). &lt;/p&gt;

&lt;p&gt;I&apos;m surprised that the time is being taken in the constructor.  The BrokerImpl is actually initialized for real during the initialize method, not the constructor, and that&apos;s where I&apos;d expect to find the initialization cost.&lt;/p&gt;

&lt;p&gt;There is no constructor implemented for BrokerImpl, so the only initialization done during the compiler-generated constructor is the initialization of the fields. Most of the fields are initialized to null, which takes no time (the initial memory allocated is cleared via a system clear memory call). The only things I see in the field initialization during newInstance are:&lt;br/&gt;
    private final JCAHelper _jca = new JCAHelper();&lt;br/&gt;
This is a stateless instance for which the constructor should be &quot;free&quot;.&lt;/p&gt;

&lt;p&gt;    private ClassLoader _loader = Thread.currentThread().&lt;br/&gt;
        getContextClassLoader();&lt;br/&gt;
Ah, perhaps this is the culprit?&lt;/p&gt;</comment>
                            <comment id="12475510" author="mikedd" created="Fri, 23 Feb 2007 21:49:03 +0000"  >&lt;p&gt;I have a screenshot from the performance tool. I don&apos;t have access to the performance test environment right now but I&apos;ll see what else I can share on Monday. &lt;/p&gt;</comment>
                            <comment id="12475511" author="clr" created="Fri, 23 Feb 2007 21:55:07 +0000"  >&lt;p&gt;Great screen shot, but when I click on the frypan next to newInstance, nothing happens. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Could you go a few levels down into newInstance and see what the heck is taking so long? My money is on getContextClassLoader or registerFinalizer.&lt;/p&gt;</comment>
                            <comment id="12476019" author="mikedd" created="Mon, 26 Feb 2007 22:15:59 +0000"  >&lt;p&gt;Here&apos;s a jpg with the call to Class.newInstance() expanded. The data is from a different execution though so the numbers are a little different but they show the same problem. &lt;/p&gt;

&lt;p&gt;It looks like the time is spent in reflection accessing the constructor. I don&apos;t know what data to gather next though.&lt;/p&gt;</comment>
                            <comment id="12476026" author="pcl" created="Mon, 26 Feb 2007 22:40:57 +0000"  >&lt;p&gt;So maybe one alternate would be to just make BrokerImpl cloneable, and put an optimization into BrokerValue (or maybe even ObjectValue!) that can hang onto a template instance for later construction. Or, we could bytecode-generate a class that does a &apos;new BrokerImpl()&apos;, again as an across-the-board optimization in ObjectValue. That would let us get away from any pooling complexity.&lt;/p&gt;</comment>
                            <comment id="12476032" author="jstecher" created="Mon, 26 Feb 2007 23:07:38 +0000"  >&lt;p&gt;From the testing that we have done fooling with different prototyped versions and making different fields in BrokerImpl static to avoid recreation I am pretty (almost 100%) sure the cost we are looking at here is just that of creating this class in general being expensive.  I would love to have someone else profile the code with different tools than I have at my disposal and see if they find a different culprit.&lt;/p&gt;

&lt;p&gt;WRT pooling I think a reasonable solution would not be to create a massive pool of objects but just one per thread-id to optimize for the general case.  I am assuming that one Broker per thread is common.  I am with everyone else in that I would love to keep configuration to a minimum overall.  I am not a big fan of exposing pool settings to a user as if we decide to change it later on you might have to support the setting beyond when you really want too. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Any thoughts on why this would not work or can someone enlighten me on what the general use case is?&lt;/p&gt;

&lt;p&gt;Patrick - I would be worried about the Clone being almost as heavy weight as what we are doing now but need to implement and test it.  &lt;/p&gt;</comment>
                            <comment id="12476038" author="pcl" created="Mon, 26 Feb 2007 23:19:16 +0000"  >&lt;p&gt;Also, I noticed that your traces show AbstractBrokerFactory.lock() and unlock() in them. I don&apos;t think that newBroker() invokes these methods anymore; it might be worthwhile to re-run the tests with the latest code drop.&lt;/p&gt;</comment>
                            <comment id="12476039" author="pcl" created="Mon, 26 Feb 2007 23:24:03 +0000"  >&lt;p&gt;The profiling data seems to point to reflection as the culprit; the init() call is very very fast.&lt;/p&gt;

&lt;p&gt;Could someone with access to the benchmark try out just calling &apos;new BrokerImpl() from JDBCConfigurationImpl or something? That should tell us a lot about where the cost is coming from.&lt;/p&gt;

&lt;p&gt;WRT per-thread pooling &amp;#8211; it sounds like you&apos;re proposing that we would actually share brokers between multiple EMs in the same thread. I think that that would have a lot of undesired consequences, would certainly violate a bunch of the intent of the JPA spec, and would probably fail in the CTS. In OpenJPA, each logical EM definitely needs to have access to a unique Broker. Pooling could help us reduce the cost of obtaining such a Broker, but sharing would be a pretty significant semantic change.&lt;/p&gt;</comment>
                            <comment id="12476077" author="pcl" created="Tue, 27 Feb 2007 06:36:25 +0000"  >&lt;p&gt;This patch should eliminate any reflection overhead for the BrokerImpl call. While implementing it, I noticed a couple of other plugins that are instantiated via reflection during BrokerImpl instantiation, so I used the new optimization for them as well.&lt;/p&gt;

&lt;p&gt;Please run this against the benchmarks that demonstrated the problem and report back as to whether or not this resolves the issue.&lt;/p&gt;</comment>
                            <comment id="12476219" author="clr" created="Tue, 27 Feb 2007 16:46:52 +0000"  >&lt;p&gt;Sweet. The ObjectValue.InstanceFactory is the technique I was going to propose. My only question is whether this pattern exists anywhere else or only in ObjectValue. That might argue for making InstanceFactory a more general interface instead of being a member of ObjectValue.&lt;/p&gt;</comment>
                            <comment id="12476225" author="clr" created="Tue, 27 Feb 2007 17:03:06 +0000"  >&lt;p&gt;As you&apos;ve coded it, each instance of ObjectValue gets its own Map. Does a given instance need more than one factory? It could just be stored as a member instead of a Map.&lt;/p&gt;

&lt;p&gt;On the other hand, if the Map is static, it should probably be a Concurrent Map and account for garbage collecting undeployed classes.&lt;/p&gt;</comment>
                            <comment id="12476228" author="jstecher" created="Tue, 27 Feb 2007 17:07:58 +0000"  >&lt;p&gt;Patrick - I&apos;ll pull your patch and we&apos;ll test it out here today on the benchmark.  I agree with Craig that it seems like its the reflection thats kicking us in the butt the most so we will see here.&lt;/p&gt;

&lt;p&gt;WTR the per-thread pooling I was thinking of something a little more intelligent with the key being the thread-id and the EM id thus making it only usable in a single EM and on a single thread.  If you had multiple EM&apos;s you would have multiple BrokerImpl&apos;s and thus not share amongst the EM&apos;s.  In any regard I&apos;m just throwing it out here to get kicked around and hardened.  If your current patch works it won&apos;t be necessary. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;</comment>
                            <comment id="12476234" author="pcl" created="Tue, 27 Feb 2007 17:22:36 +0000"  >&lt;p&gt;&amp;gt; Patrick - I&apos;ll pull your patch and we&apos;ll test it out here today on the benchmark.&lt;/p&gt;

&lt;p&gt;Cool &amp;#8211; I&apos;m looking forward to seeing the results.&lt;/p&gt;

&lt;p&gt;&amp;gt; My only question is whether this pattern exists anywhere else or only in &lt;br/&gt;
&amp;gt; ObjectValue. That might argue for making InstanceFactory a more general &lt;br/&gt;
&amp;gt; interface instead of being a member of ObjectValue.&lt;/p&gt;

&lt;p&gt;I thought about that, and decided to just keep it in ObjectValue until we discover the need for it elsewhere.&lt;/p&gt;

&lt;p&gt;&amp;gt; As you&apos;ve coded it, each instance of ObjectValue gets its own Map. Does a &lt;br/&gt;
&amp;gt; given instance need more than one factory? It could just be stored as a &lt;br/&gt;
&amp;gt; member instead of a Map.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; On the other hand, if the Map is static, it should probably be a Concurrent Map &lt;br/&gt;
&amp;gt; and account for garbage collecting undeployed classes.&lt;/p&gt;

&lt;p&gt;I put a Map in place to get around any ClassLoader issues. In the common case, it shouldn&apos;t be an issue, since all the built-in OpenJPA classes will presumably  be in the same classloader as the ObjectValue class. But the existing code handled more complex ClassLoader situations, so I figured I&apos;d preserve that feature.&lt;/p&gt;

&lt;p&gt;The set-up happens during BrokerFactory initialization, so there is no real need to make it static. Making it static might speed things up between multiple BrokerFactories, but I like having different BrokerFactories be independent.&lt;/p&gt;</comment>
                            <comment id="12476295" author="clr" created="Tue, 27 Feb 2007 18:26:36 +0000"  >&lt;p&gt;&amp;gt;I put a Map in place to get around any ClassLoader issues. In the common case, it shouldn&apos;t be an issue, since all the built-in OpenJPA classes will presumably be in the same classloader as the ObjectValue class. But the existing code handled more complex ClassLoader situations, so I figured I&apos;d preserve that feature. &lt;/p&gt;

&lt;p&gt;Once you have a Class for the type, there are no classloader issues any more. The code only looks at the classloader of the type. So I don&apos;t see the need for generalization.  &lt;/p&gt;</comment>
                            <comment id="12476316" author="pcl" created="Tue, 27 Feb 2007 19:18:55 +0000"  >&lt;p&gt;Craig identified a problem with the patch; after talking with him on the phone, I&apos;ve updated it to address his concern. Thanks, Craig!&lt;/p&gt;</comment>
                            <comment id="12476320" author="jstecher" created="Tue, 27 Feb 2007 19:27:06 +0000"  >&lt;p&gt;Patrick - Tested the patch and it has the same performance as the original implementation.  Basically the cost is still in the BrokerImpl newinstance call which is setting up the class.  I have attached a profile showing the runtime with your patch in it.  If you look closely all we really did was move the cost of the BrokerImpl create into the inner class that you created.  The profile shows that the &amp;lt;init&amp;gt; method is costing next to nothing compared to the actual setup of the class and class variables.  From the best of my knowledge the &amp;lt;init&amp;gt; method in the profile is the constructor while the rest of the time is class setup overhead.  So given this I&apos;d say we still dont have a fix that addresses the issue yet.&lt;/p&gt;

&lt;p&gt;John&lt;/p&gt;
</comment>
                            <comment id="12476321" author="clr" created="Tue, 27 Feb 2007 19:27:14 +0000"  >&lt;p&gt;For the record, the new patch changes a couple of things. The factory method now does not take an argument, but what is registered is the full class name of the implementing class along with the factory for the class. This allows, for example, multiple factories to be registered for the same instance of ObjectValue, one of which is selected at configuration time. &lt;/p&gt;</comment>
                            <comment id="12476323" author="jstecher" created="Tue, 27 Feb 2007 19:28:26 +0000"  >&lt;p&gt;Profile with ObjectValue factory.&lt;/p&gt;</comment>
                            <comment id="12476324" author="jstecher" created="Tue, 27 Feb 2007 19:29:09 +0000"  >&lt;p&gt;Our profile is with the first patch.&lt;/p&gt;</comment>
                            <comment id="12476333" author="jstecher" created="Tue, 27 Feb 2007 19:34:44 +0000"  >&lt;p&gt;Tested the second patch but basically the same thing WRT performance.&lt;/p&gt;</comment>
                            <comment id="12476335" author="pcl" created="Tue, 27 Feb 2007 19:36:33 +0000"  >&lt;p&gt;Hmm. I don&apos;t get it. The only thing in newInstance() is &apos;new BrokerImpl()&apos;. It&apos;s my understanding that all of the BrokerImpl construction should be reported in the BrokerImpl.&amp;lt;init&amp;gt; method call. I have a hard time believing that memory allocation (the only other thing that should be involved in a &apos;new BrokerImpl()&apos; call) is taking up 9.1% of the time.&lt;/p&gt;

&lt;p&gt;What profiler are you using? Did you run the test without the profiler also, to see if it&apos;s inspection overhead?&lt;/p&gt;

&lt;p&gt;Am I wrong in thinking that the construction time, including inlined field assignments, will be in BrokerImpl.&amp;lt;init&amp;gt;?&lt;/p&gt;</comment>
                            <comment id="12476343" author="pcl" created="Tue, 27 Feb 2007 19:51:44 +0000"  >&lt;p&gt;Assuming that field initializations aren&apos;t being counted in &amp;lt;init&amp;gt;, the only thing that could be taking time is the Thread.currentThread().getContextClassLoader() call. Can you run a test with _loader set to null to see if that&apos;s the culprit?&lt;/p&gt;

&lt;p&gt;Based on quick examination, it looks like if it&apos;s set to null, the code should still work, but it&apos;s possible that having a null loader returned by BrokerImpl.getClassLoader() could cause problems.&lt;/p&gt;</comment>
                            <comment id="12476351" author="jstecher" created="Tue, 27 Feb 2007 19:59:17 +0000"  >&lt;p&gt;All performance throughput numbers are run without the profiler on a 2-way Linux/Intel machine.  1410 tps at 99% CPU without the patch, 1413 tps at 99% CPU with both patches.  Those numbers are average throughput over a 3 minute run with another 3 minute run as a warmup.  &lt;/p&gt;

&lt;p&gt;Flipping the profiler on only after gathering those numbers is what shows the above graphs.  &lt;/p&gt;

&lt;p&gt;Using Jprofiler as well as IBM internal tools.&lt;/p&gt;

&lt;p&gt;I am in agreement with you that I am a little taken aback by the overhead of the newinstance call but I can tell you that the &amp;lt;init&amp;gt; you see in the profile is the constructor and only the constructor my knowledge of the profiling tools, everything else under newinstance is the class being setup by the VM and the class members being initialized.&lt;/p&gt;

&lt;p&gt;Pooling the objects and thus eliminating the object creation completely leads to a tps rate of 1506 using the same methodology talked about above. &lt;/p&gt;</comment>
                            <comment id="12476353" author="clr" created="Tue, 27 Feb 2007 20:03:06 +0000"  >&lt;p&gt;The real cost according to the trace is in the dynamically created class, not in BrokerImpl&amp;lt;init&amp;gt;.&lt;/p&gt;

&lt;p&gt;I don&apos;t get it either, except to think that the implementation of the dynamically created class uses reflection itself, which is slow.&lt;/p&gt;

&lt;p&gt;To see if this is the case, we&apos;ll need to create a real compiler-generated factory, like this:&lt;/p&gt;

&lt;p&gt;openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java&lt;br/&gt;
...&lt;br/&gt;
        brokerPlugin.registerInstanceFactory(BrokerImpl.class.getName(), &lt;br/&gt;
            new BrokerInstanceFactory();&lt;br/&gt;
...&lt;br/&gt;
       public class BrokerInstanceFactory implements ObjectValue.InstanceFactory {&lt;br/&gt;
                public Object newInstance() &lt;/p&gt;
{
                    return new BrokerImpl();
                }
&lt;p&gt; &lt;br/&gt;
...&lt;/p&gt;</comment>
                            <comment id="12476359" author="awhite" created="Tue, 27 Feb 2007 20:16:19 +0000"  >&lt;p&gt;FYI, at the bytecode level all field initializations take place in &amp;lt;init&amp;gt;.  A profiler would have to jump through a lot of hoops to &lt;b&gt;exclude&lt;/b&gt; field initializations from &amp;lt;init&amp;gt; overhead.  This may have no bearing on the issue depending on where the bottleneck is actually occurring, but I thought I&apos;d point it out.  &lt;/p&gt;</comment>
                            <comment id="12476382" author="pcl" created="Tue, 27 Feb 2007 20:57:14 +0000"  >&lt;p&gt;New version to resolve conflict with Kevin Sutter&apos;s change.&lt;/p&gt;</comment>
                            <comment id="12476390" author="jstecher" created="Tue, 27 Feb 2007 21:09:19 +0000"  >&lt;p&gt;Craig - I will try to get it coded up this afternoon.  Got side tracked on other issues here. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  If you can provide me the code I would be grateful.  If not hopefully we (Me and another IBMer are working on this) can get it coded up later this afternoon.&lt;/p&gt;

&lt;p&gt;Abe - The last time I looked at bytecode in depth (it&apos;s been a while) the field declarations and method declarations were separate in both where they were located in the class file and when they were executed.  I thought static and field identifiers were executed first in alphabetical order and then the init method was called.  Then I remember there being a &amp;lt;clinit&amp;gt; and &amp;lt;init&amp;gt; method as well but cant recall what they do off the top of my head.&lt;/p&gt;</comment>
                            <comment id="12476391" author="jstecher" created="Tue, 27 Feb 2007 21:10:12 +0000"  >&lt;p&gt;Patrick what is in the new version?  Not sure what Sutter&apos;s conflict is.&lt;/p&gt;</comment>
                            <comment id="12476393" author="pcl" created="Tue, 27 Feb 2007 21:14:23 +0000"  >&lt;p&gt;&amp;gt; Patrick what is in the new version? Not sure what Sutter&apos;s conflict is.&lt;/p&gt;

&lt;p&gt;It&apos;s basically the same. Kevin submitted something that sets the system classloader differently; it so happens that that change is in a line that I indented into an if block in my patch.&lt;/p&gt;</comment>
                            <comment id="12476396" author="awhite" created="Tue, 27 Feb 2007 21:19:48 +0000"  >&lt;p&gt;&amp;gt; The last time I looked at bytecode in depth (it&apos;s been a while) the field declarations and method declarations were separate in both where they were located in the class file and when they were executed.&lt;/p&gt;

&lt;p&gt;The names and types of your fields are defined in their own area of the class file.  But code used to initialize instance field values inline is dumped into your constructor bytecode (&amp;lt;init&amp;gt;) before any constructor code you write.  And code used to initialize static field values inline is dumped into your static initializer bytecode (&amp;lt;clinit&amp;gt;) before any static block code you write.&lt;/p&gt;</comment>
                            <comment id="12476414" author="rob.wisniewski" created="Tue, 27 Feb 2007 22:15:54 +0000"  >&lt;p&gt;I went ahead and made the change that Craig suggested but as you can see it really just changed the label.  I don&apos;t think the compiler or runtime are doing anything fishy with loading or identifying the class.&lt;/p&gt;</comment>
                            <comment id="12476423" author="pcl" created="Tue, 27 Feb 2007 22:26:26 +0000"  >&lt;p&gt;Did you guys get a chance to try setting the ClassLoader field to null to see if that&apos;s the culprit somehow? I&apos;d be surprised, but then again, I&apos;m surprised that the contents of the InstanceFactory method could possibly be accounting for 9% of anything.&lt;/p&gt;</comment>
                            <comment id="12476425" author="clr" created="Tue, 27 Feb 2007 22:27:56 +0000"  >&lt;p&gt;This patch uses a regular class instead of an anonymous inner class to create the BrokerImplFactory. It is supposed to include everything in Patrick&apos;s patch.&lt;/p&gt;</comment>
                            <comment id="12476431" author="rob.wisniewski" created="Tue, 27 Feb 2007 22:40:34 +0000"  >&lt;p&gt;Craig &amp;#8211; I coded up pretty much exactly what you have and it didn&apos;t have an impact.  You can see the screenshot as profile_explicitclass.&lt;/p&gt;

&lt;p&gt;Patrick &amp;#8211; Mike and I tried that yesterday to no avail.  It doesn&apos;t seem to be that.  All of the other instance variables are null except for the JCAHelper object _jca, and creating that class is extremely simple as well. (in fact the constructor isn&apos;t even explicit)&lt;/p&gt;</comment>
                            <comment id="12476433" author="clr" created="Tue, 27 Feb 2007 22:47:18 +0000"  >&lt;p&gt;Rob &amp;#8211; thanks, our coding passed in the mail.&lt;/p&gt;

&lt;p&gt;All &amp;#8211; WTF?&lt;/p&gt;</comment>
                            <comment id="12476438" author="jstecher" created="Tue, 27 Feb 2007 23:06:36 +0000"  >&lt;p&gt;So here is a thought.  Basically this benchmark is performing 5 interactions with the database doing a simple FBPK in this scenario.  Thus the tps numbers above really need to be multiplied by 5 to get the total number of times we pass into the JPA code base.  So that really means that we are doing 7000 invocations per second spread across 50 runtime threads in the appserver.  This could lead to a heck of a lot of contention on any single sync point which is what we saw in the earlier improvements we worked on with Kevin and company.  &lt;/p&gt;

&lt;p&gt;Now someone can correct me if I am wrong here but isnt the JVM specification clear that when initializing a class the class object must be synchronized on.  Thus possibly making this the single most contended point in the codebase now that we have removed all the other sync points in the earlier performance work?  &lt;/p&gt;

&lt;p&gt;We are doing CPU sampling based profiling to cut overhead to a minimum so that would show something like this as a hotspot I would think as the actually sync point is in C code and happens under the newintsance method.&lt;/p&gt;

&lt;p&gt;Anyway just throwing that out there for a reason this could be happening.  I am still baffled.  Need to think about a test case to prove this as well.&lt;/p&gt;</comment>
                            <comment id="12476470" author="clr" created="Wed, 28 Feb 2007 00:43:07 +0000"  >&lt;p&gt;A few questions and a comment.&lt;/p&gt;

&lt;p&gt;1. Is the profiling capturing CPU time or wait time?&lt;/p&gt;

&lt;p&gt;2. Is the VM synchronizing on the constructor, possibly because of the finalize() method that needs to register with a collection? The VM might just synchronize before construction to avoid synchronizing later.&lt;/p&gt;

&lt;p&gt;3. Do we really need the finalizer?&lt;/p&gt;

&lt;p&gt;4. What about Patrick&apos;s suggestion to use clone() instead of constructing a new instance?&lt;/p&gt;</comment>
                            <comment id="12476471" author="pcl" created="Wed, 28 Feb 2007 00:43:48 +0000"  >&lt;p&gt;So the only thing that I think is left to try to control is the field declarations in BrokerImpl. I&apos;m going to put together a patch that moves all fields in BrokerImpl into an inner class, sets the inner class instance variable to null in the constructor phase, and then instantiates the inner class (and therefore the extra memory of the variables) during initialize(), which is called after construction.&lt;/p&gt;</comment>
                            <comment id="12476472" author="pcl" created="Wed, 28 Feb 2007 00:48:17 +0000"  >&lt;p&gt;We can easily get rid of the finalizer for the purposes of exploration &amp;#8211; it&apos;s just there to help out developers who don&apos;t call close() on their own.&lt;/p&gt;</comment>
                            <comment id="12476502" author="jstecher" created="Wed, 28 Feb 2007 03:57:24 +0000"  >&lt;p&gt;Craig 1) We are using the CPU sampling feature of the profiler to not slow the runtime down to much.  Its basically sampling the processor every n microseconds and seeing whats active on the processor when the sample occurs.  I have found this shows a pretty good representation of wall clock time for the runtime.  2) and 3) I think Patrick has answered and I look forward to testing the patch.  4) I am open to trying clone as it would show a non-synchronized mechanism for setting up the new object versus the possibly synchronzied newInstance call.  Looking at the code we should be able to make clone work in this case.  I know from performance testing I did a long time back in the J2EE 1.2 days that clone was something like 4x faster than actually calling newInstance but it was a nightmare to get the clone to actually work in most cases and setup the object correctly.&lt;/p&gt;

&lt;p&gt;I look forward to the new patch Patrick.  &lt;/p&gt;</comment>
                            <comment id="12476520" author="pcl" created="Wed, 28 Feb 2007 05:07:10 +0000"  >&lt;p&gt;In our situation, cloning might not be a nightmare, as almost all initialization already happens in initialize().&lt;/p&gt;

&lt;p&gt;Patches coming later this evening.&lt;/p&gt;</comment>
                            <comment id="12476556" author="pcl" created="Wed, 28 Feb 2007 09:14:39 +0000"  >&lt;p&gt;This patch will clone BrokerImpls from a template instance held in the new BrokerValue class. All initialization has been moved into the initialize() call.&lt;/p&gt;</comment>
                            <comment id="12476614" author="rob.wisniewski" created="Wed, 28 Feb 2007 15:35:12 +0000"  >&lt;p&gt;Guys... sorry to keep bearing bad news, but we seem to just be shifting this stuff around constantly.. Now the clone() call takes up the time as you can see in profile_clonepatch.&lt;/p&gt;

&lt;p&gt;John suggested that I take out the finalizer as was suggested early and give it a shot.  I like that idea and I&apos;ll update after I try it.&lt;/p&gt;</comment>
                            <comment id="12476626" author="rob.wisniewski" created="Wed, 28 Feb 2007 15:56:30 +0000"  >&lt;p&gt;Okay..  looks like the finalizer was the problem.  I took it out and we&apos;re right up where the pooling prototype puts us with respect to performance.  So the question is are we willing to take away the developer&apos;s safety net and get rid of the finalizer?  Our calculations are showing about 8% improvement for this fix alone in our particular scenario.  I like those numbers.  Is there a way we can make this work?&lt;/p&gt;</comment>
                            <comment id="12476627" author="rob.wisniewski" created="Wed, 28 Feb 2007 15:58:32 +0000"  >&lt;p&gt;Also, to be clear, the cloning seems to give us a little boost too so I&apos;d love to integrate that as well.  I tried both ways.   Clone w/ finalizer removed is 1522 req/sec and NewInstance w/ finalizer removed is 1504.  Considering the clone change is fairly inoccuous I say let&apos;s go with that.&lt;/p&gt;</comment>
                            <comment id="12476629" author="pcl" created="Wed, 28 Feb 2007 16:17:24 +0000"  >&lt;p&gt;K... IMO, we should get rid of the finalizer in the default config, and create a new FinalizingBrokerImpl that has a finalizer, that can optionally be used by developers. I think that we should make that the default, and then let appserver providers (who are the most likely to definitely control resources correctly) turn the finalization off.&lt;/p&gt;</comment>
                            <comment id="12476647" author="pcl" created="Wed, 28 Feb 2007 17:19:00 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;moved BrokerImpl.finalize() to new FinalizingBrokerImpl subtype&lt;/li&gt;
	&lt;li&gt;retained clone() logic&lt;/li&gt;
	&lt;li&gt;made FinalizingBrokerImpl the default&lt;/li&gt;
	&lt;li&gt;added alias for BrokerImpl called &apos;non-finalizing&apos;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Frameworks that guarantee that EM.close() will be invoked should set the openjpa.BrokerImpl property to &apos;non-finalizing&apos;.&lt;/p&gt;</comment>
                            <comment id="12476680" author="rob.wisniewski" created="Wed, 28 Feb 2007 19:09:47 +0000"  >&lt;p&gt;Patrick..  good work.   The new patch performs as expected.  I test with and without the new config property and everything seems to perform as expected.&lt;/p&gt;

&lt;p&gt;Everyone agree with integrating this?&lt;/p&gt;</comment>
                            <comment id="12476683" author="pcl" created="Wed, 28 Feb 2007 19:22:57 +0000"  >&lt;p&gt;Hopefully, we can put this to rest now.&lt;/p&gt;</comment>
                            <comment id="12476731" author="clr" created="Wed, 28 Feb 2007 21:56:14 +0000"  >&lt;p&gt;&amp;gt;K... IMO, we should get rid of the finalizer in the default config, and create a new FinalizingBrokerImpl that has a finalizer, that can optionally be used by developers. I think that we should make that the default, and then let appserver providers (who are the most likely to definitely control resources correctly) turn the finalization off.&lt;/p&gt;

&lt;p&gt;Two comments, one procedural.&lt;/p&gt;

&lt;p&gt;1. I really think we&apos;re going just a bit too fast here. I wasn&apos;t able to comment on the discussion because I&apos;ve been in meetings all morning, and it&apos;s really tough to find the issue resolved, a patch committed, and I never had a chance. I also notice that just minutes after the commit, Abe had a comment that resulted in another change. For issues that attract this kind of attention, I think a little more time is probably needed to reach closure.&lt;/p&gt;

&lt;p&gt;2. I&apos;d like to reopen the discussion of which BrokerImpl should be the default. In general, I like performance options to be the default. It makes the &quot;out of the box&quot; experience better because users don&apos;t need to find, much less read, the relevant part of the documentation. Well-behaved applications don&apos;t need the finalizer. Small applications running in short-lived vms don&apos;t need it. &lt;/p&gt;

&lt;p&gt;So it seems the finalizer is only really needed in long-lived vms (application servers, web servers) that have poorly designed applications. Why is this the default? Applications that don&apos;t close their ems should be slapped about the upper body. Seems that the finalize method should do some strenuous logging (WARNING or SEVERE) to point out to the developer that they need to change their ways. &lt;/p&gt;

&lt;p&gt;Bottom line, I guess I&apos;d prefer that the finalizer version be documented in the troubleshooting section of the doc.&lt;/p&gt;
</comment>
                            <comment id="12476736" author="pcl" created="Wed, 28 Feb 2007 22:06:41 +0000"  >&lt;p&gt;&amp;gt; 1. I really think we&apos;re going just a bit too fast here. I wasn&apos;t able to comment &lt;br/&gt;
&amp;gt; on the discussion because I&apos;ve been in meetings all morning, and it&apos;s really &lt;br/&gt;
&amp;gt; tough to find the issue resolved, a patch committed, and I never had a chance. &lt;br/&gt;
&amp;gt; I also notice that just minutes after the commit, Abe had a comment that &lt;br/&gt;
&amp;gt; resulted in another change. For issues that attract this kind of attention, I &lt;br/&gt;
&amp;gt; think a little more time is probably needed to reach closure. &lt;/p&gt;

&lt;p&gt;IIRC, we&apos;re operating in a commit-then-review mode in OpenJPA. This issue has been very experimental by nature up earlier today, so I was providing patches to find something that worked. Once we got there, I committed, Abe reviewed, we changed it. Seems pretty much exactly like how we&apos;ve handled other issues, except that we did a bunch of code-collaboration along the way.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2. I&apos;d like to reopen the discussion of which BrokerImpl should be the default. &lt;br/&gt;
&amp;gt; In general, I like performance options to be the default. It makes the &quot;out of &lt;br/&gt;
&amp;gt; the box&quot; experience better because users don&apos;t need to find, much less read, &lt;br/&gt;
&amp;gt; the relevant part of the documentation. Well-behaved applications don&apos;t need &lt;br/&gt;
&amp;gt; the finalizer. Small applications running in short-lived vms don&apos;t need it.&lt;/p&gt;

&lt;p&gt;Personally, I prefer more forgiving defaults when possible, so that people don&apos;t get bitten when they&apos;re just playing around with things. Also, if we decide to change our defaults, I think that we should include openjpa.DataCache, openjpa.QueryCache, and possibly other things listed in the optimization guide in such a change.&lt;/p&gt;

&lt;p&gt;Any other opinions?&lt;/p&gt;</comment>
                            <comment id="12476744" author="kwsutter" created="Wed, 28 Feb 2007 22:40:07 +0000"  >&lt;p&gt;&amp;gt; IIRC, we&apos;re operating in a commit-then-review mode in OpenJPA. This issue has been very experimental by nature up earlier today, so I was providing patches to find something that worked. Once we got there, I committed, Abe reviewed, we changed it. Seems pretty much exactly like how we&apos;ve handled other issues, except that we did a bunch of code-collaboration along the way. &lt;/p&gt;

&lt;p&gt;I can see both sides of the argument.  If you look at the history on this Issue, there has been lots of discussion, several alternative proposals, several patches considered and tested, and an eventual fix that is acceptable to most everybody.  Maybe waiting one day after posting the &quot;final&quot; patch would have been a good compromise before committing the code.  Not that we have to do this with every JIRA Issue, but ones like this that attract so much attention and discussion may be good candidates.  The extra day would have allowed Abe to get his comments recognized and Craig would have been able to voice his &quot;default action&quot; concern.  And, anybody that couldn&apos;t wait for the commit to happen could always apply the patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; Personally, I prefer more forgiving defaults when possible, so that people don&apos;t get bitten when they&apos;re just playing around with things. Also, if we decide to change our defaults, I think that we should include openjpa.DataCache, openjpa.QueryCache, and possibly other things listed in the optimization guide in such a change. &lt;/p&gt;

&lt;p&gt;Here again, I can see both sides (in a wishy-washy mood).  Safe defaults are good to protect the naive users.  But, having good performance out of the box is a benefit &amp;#8211; not only for the customer, but also for all of us so that we don&apos;t have to explain why we&apos;re &quot;protecting&quot; the customer from him/herself.  Patrick has a good point.  He basically is following suit with the existing OpenJPA behavior in regards to existing optimizing configuration parameters.  Maybe we should open a JIRA issue to track this concern.  We could discuss all of these optimization parameters and which should be defaulted to which values.&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12476749" author="pcl" created="Wed, 28 Feb 2007 22:54:17 +0000"  >&lt;p&gt;&amp;gt; The extra day would have allowed Abe to get his comments recognized &lt;br/&gt;
&amp;gt; and Craig would have been able to voice his &quot;default action&quot; concern.&lt;/p&gt;

&lt;p&gt;I guess I fail to see the problem. Craig has voiced his &quot;default action&quot; concern, and Abe did get his comments recognized. IMO, the real issue here is whether we want to do review-then-commit or commit-then-review. Unless there is some known way to say &quot;this issue needs to be review-then-commit&quot;, this problem will just keep on repeating itself. &lt;/p&gt;

&lt;p&gt;Personally, I like to get changes off of my local machine and into svn as soon as I can, as I&apos;ve found that letting changes linger is problematic.&lt;/p&gt;

&lt;p&gt;Remember that (modulo svn&apos;s issues with David&apos;s checkin) we have history here. Just checking something in doesn&apos;t mean that it&apos;s necessarily done.&lt;/p&gt;

&lt;p&gt;&amp;gt; But, having good performance out of the box is a benefit &amp;#8211; not only for the &lt;br/&gt;
&amp;gt; customer, but also for all of us so that we don&apos;t have to explain why we&apos;re &lt;br/&gt;
&amp;gt; &quot;protecting&quot; the customer from him/herself.&lt;/p&gt;

&lt;p&gt;It&apos;s worth noting that in this situation, it&apos;s not a performance issue per se, but rather a scalability issue, since it only crops up under heavily-concurrent usage patterns. I&apos;d expect that anyone doing that type of coding and not using an appserver would be reading through the optimization guide in detail.&lt;/p&gt;

&lt;p&gt;Which brings up an interesting possibility: we could set the value differently if the entry point is from PersistenceProvider.createContainerEntityManagerFactory(), since an appserver really really should be managing resources correctly.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12352154" name="newprofile.jpg" size="72522" author="jstecher" created="Tue, 27 Feb 2007 19:28:26 +0000"/>
                            <attachment id="12352207" name="openjpa-160-clone-patch.txt" size="5551" author="pcl" created="Wed, 28 Feb 2007 09:14:39 +0000"/>
                            <attachment id="12352242" name="openjpa-160-finalization-and-cloning-patch.txt" size="7005" author="pcl" created="Wed, 28 Feb 2007 17:19:00 +0000"/>
                            <attachment id="12352180" name="openjpa-160-patch.txt" size="7757" author="clr" created="Tue, 27 Feb 2007 22:27:56 +0000"/>
                            <attachment id="12352170" name="openjpa-160-patch.txt" size="7536" author="pcl" created="Tue, 27 Feb 2007 20:57:14 +0000"/>
                            <attachment id="12352153" name="openjpa-160-patch.txt" size="7446" author="pcl" created="Tue, 27 Feb 2007 19:18:54 +0000"/>
                            <attachment id="12352085" name="openjpa-160-patch.txt" size="7419" author="pcl" created="Tue, 27 Feb 2007 06:36:25 +0000"/>
                            <attachment id="12351919" name="perf2.jpg" size="79786" author="mikedd" created="Fri, 23 Feb 2007 21:49:03 +0000"/>
                            <attachment id="12352068" name="perf3.jpg" size="80520" author="mikedd" created="Mon, 26 Feb 2007 22:15:58 +0000"/>
                            <attachment id="12352231" name="profile_clonepatch.jpg" size="132722" author="rob.wisniewski" created="Wed, 28 Feb 2007 15:35:12 +0000"/>
                            <attachment id="12352177" name="profile_explicitclass.jpg" size="119723" author="rob.wisniewski" created="Tue, 27 Feb 2007 22:15:54 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 22 Feb 2007 18:05:20 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160492</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt0wn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203327</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>