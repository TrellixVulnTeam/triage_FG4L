<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:32:03 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-1787/OPENJPA-1787.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-1787] Bean validation fails merging a new entity</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-1787</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;The bean validation is not working correctly&lt;/p&gt;

&lt;p&gt;If you try to merge a new entity.&lt;/p&gt;

&lt;p&gt;        EntityManager em = entityManagerFactory.createEntityManager();&lt;br/&gt;
        Person person = new Person();&lt;br/&gt;
        person.setName(&quot;Oliver&quot;);                               // Employee.name is annotated @NotNull &lt;br/&gt;
        person = em.merge(person);                            &lt;/p&gt;

&lt;p&gt;you get a ConstraintValidationException, although name is set. &lt;/p&gt;
</description>
                <environment></environment>
        <key id="12473823">OPENJPA-1787</key>
            <summary>Bean validation fails merging a new entity</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="techhusky">Jeremy Bauer</assignee>
                                    <reporter username="oringel">Oliver Ringel</reporter>
                        <labels>
                    </labels>
                <created>Fri, 10 Sep 2010 17:23:51 +0100</created>
                <updated>Mon, 15 Oct 2012 19:24:45 +0100</updated>
                            <resolved>Wed, 16 Mar 2011 18:52:14 +0000</resolved>
                                    <version>2.0.1</version>
                    <version>2.1.0</version>
                    <version>2.2.0</version>
                                    <fixVersion>2.1.1</fixVersion>
                    <fixVersion>2.2.0</fixVersion>
                                    <component>jpa</component>
                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12908077" author="oringel" created="Fri, 10 Sep 2010 17:28:05 +0100"  >&lt;p&gt;Here is a testcase.&lt;/p&gt;</comment>
                            <comment id="12908769" author="drwoods" created="Mon, 13 Sep 2010 13:56:05 +0100"  >&lt;p&gt;Can you provide more details about your application and environment?  You marked affects 2.0.1 and 2.1.0, so which jars are you using?  The openjpa-2.x.x.jar does not include the BVAL API or implementation.  If you grab the latest openjpa-all-2.1.0-SNAPSHOT.jar then that includes the Apache Geronimo Validation API and Apache Bean Validation implementation.&lt;/p&gt;</comment>
                            <comment id="12908772" author="drwoods" created="Mon, 13 Sep 2010 14:04:56 +0100"  >&lt;p&gt;So after looking at your example, I&apos;m not sure why you opened a JIRA....&lt;br/&gt;
You&apos;re using Hibernate Validator 4.0.2.GA, which we support.&lt;br/&gt;
The Employee.name is marked with @NotNull.&lt;br/&gt;
But in your code snippet above, you are setting the Name, so what is the behavior you&apos;re expecting?  @NotNull should only throw an exception if you didn&apos;t call setName() before trying to merge/persist the entity.....&lt;/p&gt;</comment>
                            <comment id="12908778" author="oringel" created="Mon, 13 Sep 2010 14:32:19 +0100"  >&lt;p&gt;OK, I think I described the issue not clear enough.&lt;/p&gt;

&lt;p&gt;As you said right, @NotNull should only throw an exception, if name is not set. &lt;br/&gt;
The problem is, that I get an exception (javax.validation.ConstraintViolationException), &lt;br/&gt;
although I called setName().&lt;/p&gt;

&lt;p&gt;Using persist instead of merge is working as expected. I added added test method to &lt;br/&gt;
demonstrate this.&lt;/p&gt;



</comment>
                            <comment id="12909000" author="drwoods" created="Mon, 13 Sep 2010 22:11:55 +0100"  >&lt;p&gt;Can you attach your stack trace?  I just ran into a scenario where an entity not using Validation is causing the Apache Bean Validation provider to throw an exception due to entity.hashCode() throwing a NPE....&lt;/p&gt;</comment>
                            <comment id="12909143" author="oringel" created="Tue, 14 Sep 2010 09:15:36 +0100"  >&lt;p&gt;Here is my test output.&lt;/p&gt;</comment>
                            <comment id="13001526" author="oringel" created="Wed, 2 Mar 2011 18:30:56 +0000"  >&lt;p&gt;A new simple testcase without dependencies to spring, etc.&lt;/p&gt;</comment>
                            <comment id="13001564" author="oringel" created="Wed, 2 Mar 2011 19:22:11 +0000"  >&lt;p&gt;I finally found the place in the source code where the data gets lost.&lt;/p&gt;

&lt;p&gt;If you merge a new entity the BrokerImpl first tries to attach the entity via the AttachManager.&lt;br/&gt;
The AttachManager uses an AttachStrategy to persist the new entity. &lt;/p&gt;

&lt;p&gt;Here ist the code snippet from the org.apache.openjpa.kernel.AttachStrategy class with my comments&lt;/p&gt;

&lt;p&gt;    protected StateManagerImpl persist(AttachManager manager,&lt;br/&gt;
        PersistenceCapable pc, ClassMetaData meta, Object appId, &lt;br/&gt;
        boolean explicit) {&lt;br/&gt;
        PersistenceCapable newInstance;&lt;/p&gt;

&lt;p&gt;        if (!manager.getCopyNew())&lt;br/&gt;
            newInstance = pc;                                                                       &amp;lt;--- calling this would fix the issue &lt;br/&gt;
        else if (appId == null) &lt;/p&gt;
{
            newInstance = pc.pcNewInstance(null, false);                                &amp;lt;--- but this is called, pc.pcNewInstance returns an new instance, person.name is set to null
	}
&lt;p&gt;        else&lt;br/&gt;
            newInstance = pc.pcNewInstance(null, appId, false);&lt;/p&gt;

&lt;p&gt;        return (StateManagerImpl) manager.getBroker().persist                       &amp;lt;-- this calls finally BrokerImpl.persistInternal(...) and fails because person.name is null  &lt;br/&gt;
            (newInstance, appId, explicit, manager.getBehavior());&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;For my testcases this issue could be fixed by replacing the first if statement with &quot;if (manager.getCopyNew())&quot;.&lt;br/&gt;
I&apos;m absolutely not sure, if it is really that easy. I guess not.&lt;/p&gt;

&lt;p&gt;Maybe another good place to fix the problem is EntityManagerImpl.merge() which also sets the AttachManager&apos;s copyNew flag.&lt;/p&gt;

&lt;p&gt;Please could someone with more insight into openjpa verify this solution.&lt;br/&gt;
Thanks.&lt;/p&gt;</comment>
                            <comment id="13004237" author="mikedd" created="Tue, 8 Mar 2011 21:41:01 +0000"  >&lt;p&gt;The main problem with your proposed solution is that it would change the way merge works. EntityManager.merge creates a new copy of the entity and it&apos;s the copy of the entity that becomes part of the persistence context - not the entity you passed in. Your change would eliminate the copy.&lt;/p&gt;

&lt;p&gt;I think the real issue here is that the data hasn&apos;t been copied into the new instance before validation occurs. I&apos;m not familiar with this code path, and I haven&apos;t had a chance to try your testcase yet, but I&apos;d start by looking at the code where we copy the fields into a new instance. &lt;/p&gt;</comment>
                            <comment id="13005059" author="oringel" created="Thu, 10 Mar 2011 13:43:48 +0000"  >&lt;p&gt;Hi Michael,&lt;br/&gt;
thank you for your answer. I thought that it would not be so easy to solve this issue. Unfortunately.&lt;/p&gt;

&lt;p&gt;I agree with you that the main problem here is that a copy action is missing and I guess AttachStrategy.persist is the right place to add some kind of copy functionality.&lt;/p&gt;

&lt;p&gt;I started looking into the source code of the enhanced class from the test. PersistenceCapable declares a public method to copy fields (pcCopyFields(...)).&lt;br/&gt;
Unfortunately you can&apos;t use in AttachStrategy.persist, because the entity to persist has no statemanager at this point (an exception InvalidStateException will be the result).&lt;/p&gt;

&lt;p&gt;My suggestion is to modify the class enhancement and remove the StateManager check in pcCopyFields (I don&apos;t see the need for this check). &lt;br/&gt;
Afterwards you can use pcCopyFields in AttachStrategy.persist by adding something like &lt;/p&gt;

&lt;p&gt;   ...&lt;br/&gt;
        if (manager.getCopyNew()) &lt;/p&gt;
{
            int[] fields = new int[meta.getFields().length];
            for (int i = 0; i &amp;lt; fields.length; i++)
                fields[i] = i;
            newInstance.pcCopyFields(pc, fields);
        }
&lt;p&gt;   ...&lt;/p&gt;

&lt;p&gt;This solution works for my testcase.&lt;/p&gt;

&lt;p&gt;As an alternative you can modify (or add an additional) newInstance to copy the data.&lt;/p&gt;

&lt;p&gt;I have no real experience with OpenJPA. Perhaps there is a much better solution.&lt;/p&gt;</comment>
                            <comment id="13005093" author="curtisr7" created="Thu, 10 Mar 2011 15:00:15 +0000"  >&lt;p&gt;Can you post a stack trace of the problem?&lt;/p&gt;</comment>
                            <comment id="13005193" author="oringel" created="Thu, 10 Mar 2011 17:36:21 +0000"  >&lt;p&gt;Hi Rick,&lt;/p&gt;

&lt;p&gt;this is the stack trace from my testcase.&lt;/p&gt;

&lt;p&gt;2004  OpenJpaTestcase  TRACE  &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; openjpa.Runtime - An exception occurred while ending the transaction.  This exception will be re-thrown.&lt;br/&gt;
&amp;lt;openjpa-2.2.0-SNAPSHOT-r422266:1078811 fatal store error&amp;gt; org.apache.openjpa.util.StoreException: The transaction cannot be committed, because it was already marked for rollback only.  The transaction will be rolled back instead. The cause of the rollback-only status is reported in the embedded stack.&lt;br/&gt;
	at org.apache.openjpa.kernel.LocalManagedRuntime.commit(LocalManagedRuntime.java:89)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.commit(BrokerImpl.java:1497)&lt;br/&gt;
	at org.apache.openjpa.kernel.DelegatingBroker.commit(DelegatingBroker.java:933)&lt;br/&gt;
	at org.apache.openjpa.persistence.EntityManagerImpl.commit(EntityManagerImpl.java:565)&lt;br/&gt;
	at testcase.openjpa.OpenJpaTest.testValidation(OpenJpaTest.java:24)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)&lt;br/&gt;
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)&lt;br/&gt;
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)&lt;br/&gt;
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)&lt;br/&gt;
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)&lt;br/&gt;
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)&lt;br/&gt;
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)&lt;br/&gt;
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)&lt;br/&gt;
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)&lt;br/&gt;
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)&lt;br/&gt;
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)&lt;br/&gt;
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)&lt;br/&gt;
	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59)&lt;br/&gt;
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:115)&lt;br/&gt;
	at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:102)&lt;br/&gt;
	at org.apache.maven.surefire.Surefire.run(Surefire.java:180)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
	at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:350)&lt;br/&gt;
	at org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1021)&lt;br/&gt;
Caused by: javax.validation.ConstraintViolationException: A validation constraint failure occurred for class &quot;testcase.openjpa.Person&quot;.&lt;br/&gt;
	at org.apache.openjpa.persistence.validation.ValidatorImpl.validate(ValidatorImpl.java:282)&lt;br/&gt;
	at org.apache.openjpa.validation.ValidatingLifecycleEventManager.fireEvent(ValidatingLifecycleEventManager.java:122)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.fireLifecycleEvent(BrokerImpl.java:790)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.persistInternal(BrokerImpl.java:2606)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.persist(BrokerImpl.java:2544)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.persist(AttachStrategy.java:95)&lt;br/&gt;
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:102)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:251)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:104)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3433)&lt;br/&gt;
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1214)&lt;br/&gt;
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:873)&lt;br/&gt;
	at testcase.openjpa.OpenJpaTest.testValidation(OpenJpaTest.java:22)&lt;br/&gt;
	... 26 more&lt;/p&gt;</comment>
                            <comment id="13005251" author="techhusky" created="Thu, 10 Mar 2011 19:06:49 +0000"  >&lt;p&gt;I tracked down the source of the problem.  When merging a new entity, OpenJPA persists a new &quot;empty&quot; entity, sets (or retrieves) an ID for the new entity, and then merges in the object passed in.  The problem is that the during the persist of the empty entity, a PRE_PERSIST lifecycle event gets fired, causing validation to occur.  I&apos;ve found that not only is validation occurring prematurely, but OpenJPA violates the JPA specification for the PrePersist callback as well.  &lt;/p&gt;

&lt;p&gt;&amp;lt;jpa 1.0 &amp;amp; 2.0 spec - section 3.5.2&amp;gt;&lt;br/&gt;
For entities to which the merge operation has been applied and causes the creation of newly managed instances, the PrePersist callback methods will be invoked for the managed instance after the entity state has been copied to it.&lt;br/&gt;
&amp;lt;jpa 1.0 &amp;amp; 2.0 spec - section 3.5.2/&amp;gt;&lt;/p&gt;

&lt;p&gt;By adding this simple callback to the Person class, it showed that a PrePersist callback occurred before the entity was fully populated. &lt;br/&gt;
class Person {&lt;br/&gt;
...&lt;/p&gt;

&lt;p&gt;    @PrePersist&lt;br/&gt;
    public void prePersist() &lt;/p&gt;
{
        System.out.println(&quot;PrePersist getName()=&quot; + this.getName());
    }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Result:  PrePersist getName()=null&lt;/p&gt;

&lt;p&gt;I think the solution will be to disable this callback for the case where a new entity is created specifically for the purposes of a merge.  Working on a fix...&lt;/p&gt;</comment>
                            <comment id="13005475" author="techhusky" created="Fri, 11 Mar 2011 03:53:59 +0000"  >&lt;p&gt;Attaching patch for 2.1.x release that prevents the persist path from firing a premature pre-persist event on new entities produced in a merge operation.  I am seeing some jUnit failures that test order/look schema related rather than related to this change.  I am looking into those failures and producing additional test cases.&lt;/p&gt;</comment>
                            <comment id="13005733" author="techhusky" created="Fri, 11 Mar 2011 17:29:28 +0000"  >&lt;p&gt;Attached jUnits for inclusion in the bean validation integration module.&lt;/p&gt;</comment>
                            <comment id="13005817" author="techhusky" created="Fri, 11 Mar 2011 20:33:43 +0000"  >&lt;p&gt;Committed code and jUnit patches to trunk.  I was able to get clean local and server based builds today.  I&apos;m not sure what was up yesterday.&lt;/p&gt;</comment>
                            <comment id="13006993" author="oringel" created="Tue, 15 Mar 2011 16:24:06 +0000"  >&lt;p&gt;Perfect. You fixed the issue. Both my test case as well as my real project are working now. Thank you very much.&lt;/p&gt;

&lt;p&gt;BTW. I found something probably wrong in the ValidatingLifecycleEventManager&lt;/p&gt;

&lt;p&gt;...&lt;br/&gt;
    @Override&lt;br/&gt;
    public boolean hasUpdateListeners(Object source, ClassMetaData meta) {&lt;br/&gt;
        if (_validator == null) &lt;/p&gt;
{            
            return super.hasUpdateListeners(source, meta);
        }
&lt;p&gt;        return _validator.validating(source, LifecycleEvent.BEFORE_PERSIST) ||    &amp;lt;--- LifecycleEvent.BEFORE_UPDATE&lt;br/&gt;
            super.hasUpdateListeners(source, meta);&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;    @Override&lt;br/&gt;
    public boolean hasPersistListeners(Object source, ClassMetaData meta) {&lt;br/&gt;
        if (_validator == null) &lt;/p&gt;
{            
            return super.hasPersistListeners(source, meta);
        }
&lt;p&gt;        return _validator.validating(source, LifecycleEvent.BEFORE_UPDATE) ||    &amp;lt;--- LifecycleEvent.BEFORE_PERSIST&lt;br/&gt;
            super.hasPersistListeners(source, meta);        &lt;br/&gt;
    }&lt;br/&gt;
...&lt;/p&gt;

&lt;p&gt;Although it has no effect for my testcase, it looks not correct. Maybe you verify this.&lt;/p&gt;
</comment>
                            <comment id="13007006" author="techhusky" created="Tue, 15 Mar 2011 16:46:09 +0000"  >&lt;p&gt;Great!  I&apos;m glad it fixed the problem.  I just checked the code into the 2.1.x stream as well.&lt;/p&gt;

&lt;p&gt;Yes, the has*Listeners methods in the VLEM do look suspect.  Thanks for reporting it.  I&apos;ll do some verification and will open a new JIRA if it turns out to be a bug.  I&apos;m about 99% certain it is...  Both pre-persist and pre-update validation are enabled by default.  So, the bug will not surface unless non-default validation groups are specified.  Looks like we are missing a test variation or three.&lt;/p&gt;</comment>
                            <comment id="13007316" author="techhusky" created="Wed, 16 Mar 2011 02:17:18 +0000"  >&lt;p&gt;It looks like the hasPersistListeners and hasUpdateListeners methods in the VLEM are implemented simply for the sake of consistency and, as far as I can tell, are not actually called within OpenJPA.  Event type checking is all within the fireEvent method itself and testing shows it to work as expected.  The hasDeleteListeners method (which is implemented correctly) does get called by JDBCStoreQuery for specific in-memory operations.  For the sake of consistency, and in the event that an external plugin may be calling these methods (they are public), I&apos;ll check in the simple code fix and some additional test cases that further verify validation is working as expected, based on the event type and specified validation group (or lack thereof).  This JIRA will be used to make these changes.&lt;/p&gt;</comment>
                            <comment id="13007624" author="techhusky" created="Wed, 16 Mar 2011 18:52:14 +0000"  >&lt;p&gt;Committed has*Listeners fix + additional testcases to trunk under rev 1082259.  I don&apos;t think this additional change necessarily needs to be backported since it doesn&apos;t appear to cause any real problem, but it certainly could be.&lt;/p&gt;</comment>
                            <comment id="13198944" author="allee8285" created="Thu, 2 Feb 2012 16:54:10 +0000"  >&lt;p&gt;Close issue in preparation for 2.2.0 release.&lt;/p&gt;</comment>
                            <comment id="13249471" author="rogerkeays" created="Sun, 8 Apr 2012 05:25:52 +0100"  >&lt;p&gt;Did this bug fix make it into 2.2.0?&lt;/p&gt;

&lt;p&gt;I have exactly the same problem using @Basic(optional=false)&lt;/p&gt;</comment>
                            <comment id="13249473" author="rogerkeays" created="Sun, 8 Apr 2012 05:38:23 +0100"  >&lt;p&gt;Or more accurately, when the merge cascades more than one relationship. i.e. the non-null field is&lt;/p&gt;

&lt;p&gt;Invoice.Customer.Contact.name&lt;/p&gt;

&lt;p&gt;and I call&lt;/p&gt;

&lt;p&gt;merge(invoice)&lt;/p&gt;

&lt;p&gt;The Customer validates okay, but validation annotations on the Contact all fail because the fields are null.&lt;/p&gt;</comment>
                            <comment id="13250050" author="kwsutter" created="Mon, 9 Apr 2012 19:43:29 +0100"  >&lt;p&gt;According to Albert&apos;s comment on 02/02/2012 and the svn commit messages, this problem was resolved in the 2.2.0 release.  Are you still experiencing a similar problem with 2.2.0?  Or, were you just asking?&lt;/p&gt;</comment>
                            <comment id="13451219" author="rogerkeays" created="Sat, 8 Sep 2012 02:52:58 +0100"  >&lt;p&gt;I have this problem in 2.2.0&lt;/p&gt;

&lt;p&gt;    &amp;lt;dependency&amp;gt;&lt;br/&gt;
      &amp;lt;groupId&amp;gt;org.apache.openjpa&amp;lt;/groupId&amp;gt;&lt;br/&gt;
      &amp;lt;artifactId&amp;gt;openjpa&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
      &amp;lt;version&amp;gt;2.2.0&amp;lt;/version&amp;gt;&lt;br/&gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;br/&gt;
    &amp;lt;/dependency&amp;gt;&lt;/p&gt;</comment>
                            <comment id="13451264" author="rogerkeays" created="Sat, 8 Sep 2012 07:26:36 +0100"  >&lt;p&gt;I&apos;ve hit this bug again with cascade merging. Validations on the nested object fail because the fields are all null. Maybe the fireEvents flag isn&apos;t properly handled when cascading?&lt;/p&gt;</comment>
                            <comment id="13476328" author="rogerkeays" created="Mon, 15 Oct 2012 19:24:45 +0100"  >&lt;p&gt;I&apos;ve opened &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-2279&quot; title=&quot;Merge Validation Fails With Chained Constructor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-2279&quot;&gt;OPENJPA-2279&lt;/a&gt; and attached a failing unit test for the problem I described.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12473363" name="OPENJPA-1787_2.1.x.patch" size="3036" author="techhusky" created="Fri, 11 Mar 2011 03:53:59 +0000"/>
                            <attachment id="12473408" name="OPENJPA-1787_jUnits_2.1.x.patch" size="9822" author="techhusky" created="Fri, 11 Mar 2011 17:29:28 +0000"/>
                            <attachment id="12454528" name="com.example.TestEmployeeDAO.txt" size="4822" author="oringel" created="Tue, 14 Sep 2010 09:15:35 +0100"/>
                            <attachment id="12454309" name="openjpa-1787.tar" size="7416" author="oringel" created="Fri, 10 Sep 2010 17:28:05 +0100"/>
                            <attachment id="12472438" name="testcase-openjpa-1787.tar" size="3449" author="oringel" created="Wed, 2 Mar 2011 18:30:56 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 13 Sep 2010 12:56:05 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>162029</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hy3uhr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>56264</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>