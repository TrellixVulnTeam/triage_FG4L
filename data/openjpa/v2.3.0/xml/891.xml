<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:41:04 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-891/OPENJPA-891.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-891] JPA2 LockTypeMode Support</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-891</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description></description>
                <environment></environment>
        <key id="12413904">OPENJPA-891</key>
            <summary>JPA2 LockTypeMode Support</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12413399">OPENJPA-875</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="allee8285">Albert Lee</assignee>
                                    <reporter username="allee8285">Albert Lee</reporter>
                        <labels>
                    </labels>
                <created>Tue, 3 Feb 2009 16:23:37 +0000</created>
                <updated>Mon, 12 Oct 2009 21:03:45 +0100</updated>
                            <resolved>Wed, 11 Mar 2009 15:42:08 +0000</resolved>
                                    <version>2.0.0-M2</version>
                                    <fixVersion>2.0.0-M2</fixVersion>
                                    <component>jpa</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12670005" author="allee8285" created="Tue, 3 Feb 2009 16:28:45 +0000"  >&lt;p&gt;This sub-task is used to implement the initial support of new optimistic locks types: Optimistic and Optimistic_Force_Increment, per JPA 2 spec.&lt;/p&gt;

&lt;p&gt;The new pessimistic lock types will be addressed in (part 2 ) future iteration. This requires the spec settles on the names being used, the final semantics of the these lock types and the availability of the javax.persistence.* API from Geronimo project.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;
</comment>
                            <comment id="12672732" author="allee8285" created="Wed, 11 Feb 2009 19:16:26 +0000"  >&lt;p&gt;Still investigating and coding for the desired functions. No code will be committed under &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-808&quot; title=&quot;OpenJPA 2.0 iteration 3 primary task&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-808&quot;&gt;&lt;del&gt;OPENJPA-808&lt;/del&gt;&lt;/a&gt; and move this sub-task to &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-875&quot; title=&quot;OpenJPA 2.0 iteration 4 primary task&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-875&quot;&gt;&lt;del&gt;OPENJPA-875&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12675510" author="allee8285" created="Fri, 20 Feb 2009 23:28:55 +0000"  >&lt;p&gt;The JIRA implements the new JPA2 LockModeType features.&lt;/p&gt;

&lt;p&gt;The following is a summary of the design points and considerations in the OpenJPA implementation:&lt;/p&gt;

&lt;p&gt;Support the following new LockModeType and property map combination for find, lock and refresh methods in the EntityManager interface:&lt;br/&gt;
Optimistic (Same as Read)&lt;br/&gt;
Optimistic_Force_Increment (Same as Write)&lt;br/&gt;
Pessimistic_Read&lt;br/&gt;
Pessimistic_Write&lt;br/&gt;
Pessimistic_Force_Increment&lt;/p&gt;

&lt;p&gt;Since OpenJPA already support both optimistic and pessimistic lock managers, the basic design goal is to &quot;reuse&quot; as much as possible to ensure stability, compatibility and semantics of existing lock managers behaviors as well as the new JPA 2 support..&lt;/p&gt;

&lt;p&gt;A new JPA2LockManager is introduced to support the new lock mode semantics. &quot;jpa2&quot; is the alias name for the openjpa.LockManager properties. This will be the default for OpenJPA 2.0.0.&lt;/p&gt;

&lt;p&gt;There are 3 aspects in supporting the new features:&lt;br/&gt;
The front end - EntityManagerImpl:&lt;br/&gt;
The EntityManagerImpl needs to implement the new interface methods.&lt;br/&gt;
Since the em method&apos;s LockMode and properties Map arguments are transient and only apply during the method call, the front end code needs to save, apply the setting for the current method call and restore the previous values when the method exit.&lt;br/&gt;
Translate the relevant property values and apply to the fetch configuration for use downstream. Only the following properties will be processed&lt;br/&gt;
javax.persistence.lock.timeout&lt;br/&gt;
openjpa.LockTimeout&lt;br/&gt;
openjpa.ReadLockMode&lt;br/&gt;
openjpa.WriteLockMode&lt;/p&gt;

&lt;p&gt;public &amp;lt;T&amp;gt; T find(Class&amp;lt;T&amp;gt; cls, Object oid, LockModeType mode,&lt;br/&gt;
        Map&amp;lt;String, Object&amp;gt; properties) {&lt;br/&gt;
        assertNotCloseInvoked();&lt;br/&gt;
        if (mode != LockModeType.NONE)&lt;br/&gt;
            _broker.assertActiveTransaction();&lt;/p&gt;

&lt;p&gt;        boolean fcPushed = pushLockProperties(mode, properties);&lt;br/&gt;
        try &lt;/p&gt;
{
            oid = _broker.newObjectId(cls, oid);
            return (T) _broker.find(oid, true, this);
        }
&lt;p&gt; finally &lt;/p&gt;
{
            popLockProperties(fcPushed);
        }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;The back end - Lock Manager&lt;br/&gt;
The role of the JPA2LockManager is to route the requested LockMode to the lock manager and set the version check options to be processed by the delegated lock manager:&lt;/p&gt;

&lt;p&gt;    protected void lockInternal(OpenJPAStateManager sm, int level, int timeout, Object sdata) {&lt;br/&gt;
        if (level &amp;gt;= LOCK_PESSIMISTIC_FORCE_INCREMENT) &lt;/p&gt;
{
            setVersionCheckOnReadLock(true);
            setVersionUpdateOnWriteLock(true);
            super.lockInternal(sm, level, timeout, sdata);
        }
&lt;p&gt; else if (level &amp;gt;= LOCK_PESSIMISTIC_READ) &lt;/p&gt;
{
            setVersionCheckOnReadLock(true);
            setVersionUpdateOnWriteLock(false);
            super.lockInternal(sm, level, timeout, sdata);
        }
&lt;p&gt; else if (level &amp;gt;= LOCK_READ) &lt;/p&gt;
{
            setVersionCheckOnReadLock(true);
            setVersionUpdateOnWriteLock(true);
            optimisticLockInternal(sm, level, timeout, sdata);
        }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;Exception handling&lt;br/&gt;
New LockTimeoutException and PessimisticLockException require differentiation its statement-level and transaction-level rollback semantics respectively. Application may recover and re-try when the former exception is received.&lt;br/&gt;
Since detecting these conditions is very database specific. the DBDictionary.narrow() method will delegate to the associated Dictionary subclass to examine the SQLException (SQLState, SQLCode and message text etc.) thrown by the database and to compute if the exception is a recoverable exception. The existing sqlstate mapping to StoreException&apos;s subtype remains unchanged (except a few corrections). The StoreException is used to encapsulate the recoverable attribute of the SQLException and will be processed during exception translation.. The only subtype that is affected is StoreException.LOCK type.&lt;/p&gt;

&lt;p&gt;OpenJPAException narrow(String msg, SQLException ex) {&lt;br/&gt;
        Boolean recoverable = null;&lt;br/&gt;
        int errorType = StoreException.GENERAL;&lt;br/&gt;
        for (Integer type : sqlStateCodes.keySet()) {&lt;br/&gt;
            Set&amp;lt;String&amp;gt; errorStates = sqlStateCodes.get(type);&lt;br/&gt;
            if (errorStates != null) {&lt;br/&gt;
                recoverable = matchErrorState(type, errorStates, ex);&lt;br/&gt;
                if (recoverable != null) &lt;/p&gt;
{
                    errorType = type;
                    break;
                }
&lt;p&gt;            }&lt;br/&gt;
        }&lt;br/&gt;
        StoreException storeEx;&lt;br/&gt;
        switch (errorType) {&lt;br/&gt;
        case StoreException.LOCK:&lt;br/&gt;
            storeEx = new LockException(msg);&lt;br/&gt;
            break;&lt;br/&gt;
E.g.&lt;br/&gt;
DB2:&lt;br/&gt;
    @Override&lt;br/&gt;
    protected Boolean matchErrorState(int subtype, Set&amp;lt;String&amp;gt; errorStates,&lt;br/&gt;
        SQLException ex) {&lt;br/&gt;
        Boolean recoverable = null;&lt;br/&gt;
        if (errorStates.contains(errorState)) {&lt;br/&gt;
            recoverable = Boolean.FALSE;&lt;br/&gt;
            if (subtype == StoreException.LOCK &amp;amp;&amp;amp; errorState.equals(&quot;57033&quot;)&lt;br/&gt;
                &amp;amp;&amp;amp; ex.getMessage().indexOf(&quot;80&quot;) != -1) &lt;/p&gt;
{
                recoverable = Boolean.TRUE;
            }&lt;br/&gt;
        }&lt;br/&gt;
        return recoverable;&lt;br/&gt;
    }&lt;br/&gt;
Derby:&lt;br/&gt;
    @Override&lt;br/&gt;
    protected Boolean matchErrorState(int subtype, Set&amp;lt;String&amp;gt; errorStates,&lt;br/&gt;
        SQLException ex) {&lt;br/&gt;
        Boolean recoverable = null;&lt;br/&gt;
        String errorState = ex.getSQLState();&lt;br/&gt;
        int errorCode = ex.getErrorCode();&lt;br/&gt;
        if (errorStates.contains(errorState)) {&lt;br/&gt;
            recoverable = Boolean.FALSE;&lt;br/&gt;
            if (subtype == StoreException.LOCK &amp;amp;&amp;amp; errorCode &amp;lt; 30000) {
                recoverable = Boolean.TRUE;
            }
&lt;p&gt;        }&lt;br/&gt;
        return recoverable;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;The LockException will be translated to the proper em method exception as in :&lt;/p&gt;

&lt;p&gt;private static Throwable translateStoreException(OpenJPAException ke) &lt;/p&gt;
{
        .......
        }
&lt;p&gt; else if (ke.getSubtype() == StoreException.LOCK || cause instanceof LockException) {&lt;br/&gt;
                LockException lockEx = (LockException)(ke instanceof LockException ? ke : cause);&lt;br/&gt;
                if( lockEx != null &amp;amp;&amp;amp; lockEx.isPessimistic()) {&lt;br/&gt;
                    if( lockEx.isRecoverable()) &lt;/p&gt;
{
                        e = new org.apache.openjpa.persistence
                            .LockTimeoutException(ke.getMessage(), getNestedThrowables(ke), getFailedObject(ke), ke.isFatal());
                    }
&lt;p&gt; else &lt;/p&gt;
{
                        e = new org.apache.openjpa.persistence
                            .PessimisticLockException(ke.getMessage(), getNestedThrowables(ke), getFailedObject(ke), ke.isFatal());
                    }
&lt;p&gt;                } else &lt;/p&gt;
{
                    e = new org.apache.openjpa.persistence
                        .OptimisticLockException(ke.getMessage(), getNestedThrowables(ke), getFailedObject(ke), ke.isFatal());
                }
&lt;p&gt;        } else if (ke.getSubtype() == StoreException.OBJECT_EXISTS&lt;/p&gt;

&lt;p&gt;The LockTimeoutException and QueryTimeoutException will be exempted from being marked RolledbackOnly in PersistenceExceptions&lt;/p&gt;

&lt;p&gt;    public static RuntimeExceptionTranslator getRollbackTranslator(&lt;br/&gt;
        final OpenJPAEntityManager em) {&lt;br/&gt;
        return new RuntimeExceptionTranslator() {&lt;br/&gt;
            private boolean throwing = false;&lt;br/&gt;
            public RuntimeException translate(RuntimeException re) {&lt;br/&gt;
                RuntimeException ex = toPersistenceException(re);&lt;br/&gt;
                if (!(ex instanceof NonUniqueResultException)&lt;br/&gt;
                    &amp;amp;&amp;amp; !(ex instanceof NoResultException)&lt;br/&gt;
                    &amp;amp;&amp;amp; !(ex instanceof LockTimeoutException)&lt;br/&gt;
                    &amp;amp;&amp;amp; !(ex instanceof QueryTimeoutException)&lt;br/&gt;
                    &amp;amp;&amp;amp; !throwing) {&lt;br/&gt;
                    try {&lt;br/&gt;
                        throwing = true;&lt;/p&gt;

&lt;p&gt;openjpa.ReadLockLevel and WriteLockLevel are enhanced in parallel to the new lock modes. (i.e.&lt;br/&gt;
5.53.  openjpa.ReadLockLevel &lt;br/&gt;
Property name: openjpa.ReadLockLevel &lt;br/&gt;
Resource adaptor config-property: ReadLockLevel &lt;br/&gt;
Default: read &lt;br/&gt;
Possible values: none, read, write, optimistic, optimistic-force-increment, pessimistic-read, pessimistic-write, pessimistic-force-increment, numeric values for lock-manager specific lock levels &lt;br/&gt;
Description: The default level at which to lock objects retrieved during a non-optimistic transaction. Note that for the default JDBC lock manager, read and write lock levels are equivalent. &lt;/p&gt;

&lt;p&gt;For the em methods that take both LockModeType and a property Map, we may run into situation where &quot;openjpa.ReadLockMode/WriteLockMode&quot; are specified and create a conflict with the LockModeType argument. Resolution:  the LockModeType argument takes a higher precedent than the *LockLevel values specified in the Map argument.&lt;/p&gt;

&lt;p&gt;If application specifies &quot;version&quot; or &quot;pessimistic&quot; as the openjpa.LockManager, the old behavior is honored.&lt;br/&gt;
However if new lock mode is requested using the new EntityManager Interface, the following behavior will be implemented:&lt;br/&gt;
&quot;version&quot; lock manager&lt;br/&gt;
All &quot;Pessimistic_*&quot; mode will be down grade to &quot;Optimistic_Force_Increment&quot; (Write) and a warning message is logged.&lt;br/&gt;
&quot;pessimistic&quot; lock manager&lt;br/&gt;
All lock type uses the same existing pessimistic semantics.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12677670" author="milosz" created="Sat, 28 Feb 2009 10:17:25 +0000"  >&lt;p&gt;Albert, maybe the newly added DBDictionary.supportIsolationForUpdate() could be named supportsIsolationForUpdate (with &quot;s&quot;) to be more aligned with other supports* methods.&lt;/p&gt;</comment>
                            <comment id="12677768" author="allee8285" created="Sun, 1 Mar 2009 03:30:08 +0000"  >&lt;p&gt;Milosz, Thank for the comment. Method name changed.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12679427" author="ppoddar@apache.org" created="Thu, 5 Mar 2009 23:41:48 +0000"  >&lt;p&gt;Few minor suggestions/comments:&lt;/p&gt;

&lt;p&gt;1. A new method isRecoverable() method is added in one of the OpenJPA Exception class. There is an existing isFatal() method which had similar semantics. Could that have sufficed instead of the new method? If not, then what is the semantic difference and it may be documented for the newly added method. &lt;/p&gt;

&lt;p&gt;2. Naming (in classes, in configuration) that uses &apos;jpa2&apos; does somehow looks awkward. It will perhaps make less sense in 2012 when newer JPA version is available and no significant change has happened in an area to warranty a &lt;b&gt;JPA6&lt;/b&gt;.java. As a rule of thumb, perhaps a naming scheme that is explanatory of its function rather than its compliance to a spec version is a more long-lasting approach. &lt;/p&gt;

&lt;p&gt;3. SQLExceptions&lt;br/&gt;
   Newly added method used OpenJPAConfiguration but appears in method signature&lt;/p&gt;

&lt;p&gt;4. LockException&lt;br/&gt;
   Should have constructor with new lockLevel argument as in the case of existing state variables.&lt;/p&gt;
</comment>
                            <comment id="12679991" author="allee8285" created="Sun, 8 Mar 2009 16:23:21 +0000"  >&lt;p&gt;More testing reveals there exist 2 problems in the current implementations:&lt;/p&gt;

&lt;p&gt;1) e.lock() does not honor the following contract&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;@throws IllegalArgumentException if the instance is not an entity or is a detached entity, E.g.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;      e = em.lock(null,LockModeType.XXX);&lt;br/&gt;
      e = em.lock(&quot;xxxx&quot;,LockModeType.XXX);&lt;/p&gt;

&lt;p&gt;2) e.refresh does not honor the WRITE lock contract.&lt;/p&gt;

&lt;p&gt;3.4.3 Lock Modes&lt;br/&gt;
&quot;If transaction T1 calls lock(entity, LockModeType.WRITE) on a versioned object, the entity manager must avoid the phenomena P1 and P2 (as with  LockModeType.READ) and must also force an update (increment) to the entity&apos;s version column. A forced version update may be performed immediately, or may be deferred until a flush or commit.&quot; E.g.&lt;/p&gt;

&lt;p&gt;     e = em.find(Entity.class, 1);&lt;br/&gt;
     em.refresh(e, LockModeType.WRITE)&lt;br/&gt;
     em.getTransaction.commit();&lt;/p&gt;

&lt;p&gt;does not update the version field on commit. but the lock did force the version to be updated.&lt;br/&gt;
     e = em.find(Entity.class, 1);&lt;br/&gt;
     em.lock(e, LockModeType.WRITE)&lt;br/&gt;
     em.getTransaction.commit();&lt;/p&gt;

&lt;p&gt;More corrective patch and test cases will be posted later.&lt;br/&gt;
Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12679994" author="allee8285" created="Sun, 8 Mar 2009 17:41:00 +0000"  >&lt;p&gt;Pinaki,&lt;/p&gt;

&lt;p&gt;Thanks for the comments.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; 1 &amp;amp; 4&lt;br/&gt;
Fixed.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;2. Naming (in classes, in configuration) that uses &apos;jpa2&apos; does somehow looks awkward. It will perhaps make less sense in 2012 when newer JPA version is available and no significant change has happened in an area to warranty a &lt;b&gt;JPA6&lt;/b&gt;.java. As a rule of thumb, perhaps a naming scheme that is explanatory of its function rather than its compliance to a spec version is a more long-lasting approach.&lt;/p&gt;

&lt;p&gt;Agree. What would be a good choice? I am thinking the following:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;mixed&lt;/li&gt;
	&lt;li&gt;miximistic (mix of both optimistic and pessimistic)&lt;/li&gt;
	&lt;li&gt;combomistic (comination of both)&lt;/li&gt;
	&lt;li&gt;jpa&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt;&amp;gt; 3. SQLExceptions&lt;br/&gt;
   Newly added method used OpenJPAConfiguration but appears in method signature&lt;/p&gt;

&lt;p&gt;Not sure what this is referring to. There is a methods that needs the OpenJPAConfiguration to access the lock manager. The other is a convenient method with StateManager as agrument that calls the first method to do the same thing.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12680234" author="drwoods" created="Mon, 9 Mar 2009 19:06:23 +0000"  >&lt;p&gt;Albert, it looks like you have implemented this using setQueryTimeout(), which is a client side JDBC timeout function, while lock timeouts are implemented in the DB server.  See -&lt;br/&gt;
&lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/db2luw/v8/index.jsp?topic=/com.ibm.db2.udb.doc/admin/r0011874.htm&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://publib.boulder.ibm.com/infocenter/db2luw/v8/index.jsp?topic=/com.ibm.db2.udb.doc/admin/r0011874.htm&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa213032(SQL.80).aspx&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://msdn.microsoft.com/en-us/library/aa213032(SQL.80).aspx&lt;/a&gt;&lt;br/&gt;
Also, the following discussion gives a good overview of the two and why apps should use both to handle unreliable network conditions -&lt;br/&gt;
&lt;a href=&quot;http://social.msdn.microsoft.com/Forums/en-US/sqldataaccess/thread/95755534-bbef-4c2c-afa4-b80ca2a2c333/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://social.msdn.microsoft.com/Forums/en-US/sqldataaccess/thread/95755534-bbef-4c2c-afa4-b80ca2a2c333/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12680247" author="ppoddar@apache.org" created="Mon, 9 Mar 2009 19:54:31 +0000"  >&lt;p&gt;&amp;gt; 3. SQLExceptions&lt;br/&gt;
&amp;gt;&amp;gt;Not sure what this is referring to.&lt;/p&gt;

&lt;p&gt;Just a minor comment. In the following code LockManager lm is never used. &lt;/p&gt;

&lt;p&gt;public static OpenJPAException getStoreSQLException(&lt;br/&gt;
        OpenJPAConfiguration config, SQLException se, DBDictionary dict,&lt;br/&gt;
        int level) {&lt;br/&gt;
        OpenJPAException storeEx = SQLExceptions.getStore(se, dict);&lt;br/&gt;
        String lm = config.getLockManager();&lt;br/&gt;
        if (storeEx.getSubtype() == StoreException.LOCK) &lt;/p&gt;
{
            LockException lockEx = (LockException) storeEx;
            lockEx.setLockLevel(level);
        }
&lt;p&gt;        return storeEx;&lt;br/&gt;
    }&lt;/p&gt;</comment>
                            <comment id="12680318" author="ppoddar@apache.org" created="Mon, 9 Mar 2009 22:58:27 +0000"  >&lt;p&gt;I have started looking into the changes in EntityManagerImpl.java related to this issue. Here are few comments:(the first one is critical becuase it is architectural)&lt;/p&gt;


&lt;p&gt;1. I see JDBCConfiguration appearing in EntityManagerImpl. This is not a welcome sign. Considerable effort has gone in throughout this codebase to maintain architectural layerering so that EntityManager/Facade does not know the nature of the Store. In fact, I thought  maven build prohibits package import via dependencies to enforce such layering restriction.&lt;br/&gt;
   Anyway, the short point is: if EntityManagerImpl has to refer to JDBCConfiguration then something else is amiss. It also violates one of the basic architectural principles.&lt;/p&gt;

&lt;p&gt;2. Going by the code further, I think many of the new processing added to EntityManagerImpl actually belongs somewhere else. Most probabaly in appropriate FetchConfiguration implementation.&lt;/p&gt;

&lt;p&gt;3. The setFetchConfigProperty() calls in a loop&lt;br/&gt;
       configuration.getPropertyKeys()&lt;br/&gt;
    Please note that given this is a costly operation and in the returned value is not going to change across the loop, it makes sense to compute it once before entering the loop. &lt;/p&gt;

&lt;p&gt;4. I also completely missed the point that why one will require to instantiate IntValue in such a place. The purpose there looked like to populate an instance of FetchConfiguration from the user supplied map and then push that onto the stack. Why will one require conf.IntValue to do that is not clear to me at all.&lt;/p&gt;

&lt;p&gt;5. FetchConfiguration seemed to be pushed in a loop.That will amount to multiple clones in the stack &amp;#8211; that is &lt;b&gt;not&lt;/b&gt; what is wanted &amp;#8211; the user properties should poulate one single instance of FetchConfiguration and that should be pished into the stack. What will happen by this code (perhaps, reading always can be faulty) is user property will land up in different fetch config instances. &lt;/p&gt;
</comment>
                            <comment id="12680493" author="allee8285" created="Tue, 10 Mar 2009 14:51:16 +0000"  >&lt;p&gt;Donald,&lt;/p&gt;

&lt;p&gt;Per our separated conversation, current OpenJPA implementation uses statement level setQueryTimeout for lock timeout and query timeout, which is stored in the fetch configuration. &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-958&quot; title=&quot;Support lock mode on Named Query&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-958&quot;&gt;&lt;del&gt;OPENJPA-958&lt;/del&gt;&lt;/a&gt;,959: timeout on query&quot; is addressing the separation of both property hint definitions. A new JIRA can be used to document your suggested functions.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12680522" author="allee8285" created="Tue, 10 Mar 2009 16:20:33 +0000"  >&lt;p&gt;Pinaki,&lt;/p&gt;

&lt;p&gt;Thanks for your time reviewing the code and your architectural insight into the code base.&lt;/p&gt;

&lt;p&gt;There are 2 functions in the implementation:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;setting the correct (jpa2) lock level in the fetch configuration so that the datastore can issue the correct SQL&lt;/li&gt;
	&lt;li&gt;process the related input properties and set up the appropriate fetch configuration values.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;1) The original thought was the new pessimistic lock mode type is only related to jpa spec, therefore it is not push down to say fetch configuration in the kernel layer, which does not know anything about the the new lock levels, to handle the processing. I am trying to encapsulate this in the persistence layer. The attribute to implement and differentiate PESSIMISTIC_READ/WRITE is based on the isolation level being set in the fetch configuration, hence the code is getting the dictionary to see if it is supported by the db and then set the isolation in the JDBCFetchConfiguration. Both objects are in the jdbc-jdbc layer.  We can skip the db checking (and avoid touching the JDBCConfiguration object) but still have to find a way to set the JDBCFetchConfiguration isolation level somehow. If we can find a solution to this problem, then we can avoid the dependency of openjpa-jdbc from openjpa-persistence.  One thought is to defer the hint/property process further down the path and by setting the isolation property, we can de-couple the dependency.&lt;/p&gt;

&lt;p&gt;2) If we process the JPA behavior in the FetchConfiguration, that also means the kernel is aware of the JPA personality&apos;s behavior. Is that what we want.&lt;/p&gt;

&lt;p&gt;3) Point taken. I will move the (expensive) getPropertyKeys() call out of the loop and request it once.&lt;/p&gt;

&lt;p&gt;4) The intent of using IntValue to process the property value is to keep the exact same behavior as if it is being process by the configuration plugin framework. Since the property map takes Object as value, so it can take many valid types. &lt;/p&gt;

&lt;p&gt;5) The current implementation will only do at most 1 push and 0 if no fetch configuration is changed. That is the fcPushed is for.  I was debating either a) always do 1 push and set the value in the fetch configuration (cleaner in code path, no if(!fsPush) conditional processing )  or b) push only if needed (current implementation.)&lt;/p&gt;

&lt;p&gt;Comments/suggestions are welcome.&lt;br/&gt;
Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12680571" author="allee8285" created="Tue, 10 Mar 2009 18:26:48 +0000"  >&lt;p&gt;Iteration summary:&lt;/p&gt;

&lt;p&gt;Support new JPA LockModeType in find, lock and refresh methods in the EntityManager interface. A new &quot;mixed&quot; lock manager is introduced implementing the new mixed optimistic and pessimistic entity locking semantics.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12680891" author="allee8285" created="Wed, 11 Mar 2009 15:42:08 +0000"  >&lt;p&gt;This issues is functionally complete. Outstanding issues raised by Pinaki will be addressed in future JIRA.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 28 Feb 2009 10:17:25 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>161191</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hysx9j:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>202737</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>