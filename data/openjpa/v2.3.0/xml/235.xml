<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:34:27 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-235/OPENJPA-235.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-235] SQL reordering to avoid non-nullable foreign key constraint violations</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-235</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;OpenJPA does not do any SQL statement re-ordering in order to resolve foreign key constraints. Instead, objects are always inserted in the order in which the user persists the instances.  When you persist in an order that would violate foreign key constraints, OpenJPA attempts to insert null and then update the foreign key value in a separate statement. If you use non-nullable constraints, though, you must persist your objects in the correct order.&lt;/p&gt;

&lt;p&gt;This improvement re-orders SQL statements as follows:&lt;/p&gt;

&lt;p&gt;1. First, all insert statements execute. Inserts which have foreign keys with non-nullable constraints execute AFTER the foreign keys which they depend on have been inserted since no deferred update is possible.&lt;/p&gt;

&lt;p&gt;2. Next, all update statements execute. No reordering is necessary.&lt;/p&gt;

&lt;p&gt;3.  Finally, all delete statements execute. Like inserts, deletes execute in an order which does not violate non-nullable foreign key constraints.&lt;/p&gt;

&lt;p&gt;If a circular foreign key reference is found during the re-ordering process then re-ordering halts and the remaining unordered statements are left as is. There is nothing that can be done about the circular reference (other than fixing the schema) and the resulting SQL statements will not succeed.&lt;/p&gt;

&lt;p&gt;The net effect is that users do not need to worry about the persistence order of their objects regardless of non-nullable foreign key constraints. The only class modified was org.apache.openjpa.jdbc.kernel.OperationOrderUpdateManager. I have included a patch which includes my modifications to OperationOrderUpdateManager and test cases. The test cases I have provided fail on the current trunk but pass with my modifications. I have also verified that I did not break anything by using maven to run all test cases with my modifications in place.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12368684">OPENJPA-235</key>
            <summary>SQL reordering to avoid non-nullable foreign key constraint violations</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pcl">Patrick Linskey</assignee>
                                    <reporter username="rgarret">Reece Garrett</reporter>
                        <labels>
                    </labels>
                <created>Fri, 4 May 2007 19:24:08 +0100</created>
                <updated>Tue, 9 Mar 2010 18:32:34 +0000</updated>
                            <resolved>Thu, 31 Jul 2008 16:38:45 +0100</resolved>
                                                    <fixVersion>1.1.1</fixVersion>
                    <fixVersion>1.2.0</fixVersion>
                    <fixVersion>1.3.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="12493762" author="rgarret" created="Fri, 4 May 2007 19:25:42 +0100"  >&lt;p&gt;Patch includes code changes and test cases.&lt;/p&gt;</comment>
                            <comment id="12493766" author="rgarret" created="Fri, 4 May 2007 19:29:19 +0100"  >&lt;p&gt;This bug illustrates the effects of not re-ordering sql when dealing with non-nullable foreign key constraints. The patch provided with this improvement fixes these issues.&lt;/p&gt;</comment>
                            <comment id="12497082" author="mprudhom" created="Sat, 19 May 2007 00:22:04 +0100"  >&lt;p&gt;I need to revert the patch for OperationOrderUpdateManager, since it is causing 19 TCK failures (one of the test failures can be reproduced with: mvn integration-test -Dtest=false -Ptck-profile -Djpatck.pkg.dir=com/sun/ts/tests/ejb30/persistence/annotations/orderby ).&lt;/p&gt;</comment>
                            <comment id="12497632" author="pcl" created="Tue, 22 May 2007 00:34:09 +0100"  >&lt;p&gt;Any idea about the nature of the failure? Was the patch reordering things incorrectly?&lt;/p&gt;

&lt;p&gt;Ideally, we should fix this in a way that passes the TCK; did it seem like a significant enough problem that it&apos;s worthwhile to create a separate non-default UpdateManager for use by the TCK (or for use to access the feature)?&lt;/p&gt;</comment>
                            <comment id="12497641" author="mprudhom" created="Tue, 22 May 2007 01:05:59 +0100"  >&lt;p&gt;I didn&apos;t look to closely at the failures. I just saw that the TCK hadn&apos;t been passing since May 4th, so I figured it would be best to restore its passing status, and the patch author could work to determine why the failures were occurring. I do recall that the errors I saw had to do with foreign key constraint violations, which was a little surprising (since the patch was designed to avoid precisely that).&lt;/p&gt;

&lt;p&gt;The errors are pretty easily reproducable with the command I mention above, provided you have access to the TCK.&lt;/p&gt;</comment>
                            <comment id="12497650" author="gergul" created="Tue, 22 May 2007 01:32:55 +0100"  >&lt;p&gt;FWIW, I&apos;ve tested the patch with the hope that it&apos;d also fix &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-231&quot; title=&quot;Incorrect handling of cascading bidirectional collections during merge/attach&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-231&quot;&gt;&lt;del&gt;OPENJPA-231&lt;/del&gt;&lt;/a&gt;, however it broke a good number of my local tests which persist fresh objects (with multiple generations of cascading collections), I couldn&apos;t get to the stage where I can test merge behaviour at all --had to rollback locally.&lt;/p&gt;</comment>
                            <comment id="12497991" author="rgarret" created="Tue, 22 May 2007 21:26:41 +0100"  >&lt;p&gt;I have been doing further work on this patch over the past week to deal with several edge cases I did not initially think of (which may have caused the failures) and to deal with unique constraint violations. I will reproduce and fix the tests Marc referred to.&lt;/p&gt;

&lt;p&gt;Gokhan, I am interested in the test cases that this broke so if you have time please email me.&lt;/p&gt;

&lt;p&gt;I apologize for any inconvenience this has caused but I was not aware of additional test cases that I needed to run. This functionality is sorely needed for anyone using a database which does not support deferred constraints so I will continue to work on it.&lt;/p&gt;

&lt;p&gt;Also, I just posted a message on the mailing list, &quot;SQL ordering and unique constraints&quot;, and would appreciate any suggestions on how to proceed. &lt;/p&gt;
</comment>
                            <comment id="12498842" author="rgarret" created="Thu, 24 May 2007 22:12:08 +0100"  >&lt;p&gt;I am just about done revising my patch but I do not have access to the TCK and can not sign the NDA  because I work for a government agency which will not allow it. All the test cases I can run (mvn test) pass but that&apos;s not saying much because they passed the first time. As I said, I have caught a few cases that I did not think of the first time and am hopeful that they were the source of the TCK failures but can not be sure.  Also, the algorithm is now iterative instead of recursive,  does almost no collection copying, and orders rows based purely on dependencies instead of lumping all inserts first followed by updates and then deletes. I decided not to include support for ordering unique keys until I get foreign key ordering resolved (although I&apos;m fairly certain my idea for unique keys will work well.&lt;/p&gt;

&lt;p&gt;I&apos;m at a loss as to how to proceed from here. I&apos;ll have a new patch ready soon but since I can not run the TCK tests myself I don&apos;t feel comfortable resubmitting it and potentially taking up more of your development time tracking down bugs I&apos;ve introduced. What should I do with my new patch? &lt;/p&gt;</comment>
                            <comment id="12498880" author="m_fuchs" created="Fri, 25 May 2007 00:26:04 +0100"  >&lt;p&gt;Hi Reece,&lt;/p&gt;

&lt;p&gt;This test case produces a foreign key violation when applying your previous patch.&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12499200" author="pcl" created="Fri, 25 May 2007 19:46:36 +0100"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Attach the patch to the JIRA and one of those of us with TCK access will run it against the TCK.&lt;/p&gt;</comment>
                            <comment id="12499262" author="rgarret" created="Sat, 26 May 2007 01:22:09 +0100"  >&lt;p&gt;Markus,&lt;/p&gt;

&lt;p&gt;Thank you for your test case. It runs just fine with my new code. I will post a new patch on Tuesday. Everyone have a great weekend!&lt;/p&gt;</comment>
                            <comment id="12499266" author="m_fuchs" created="Sat, 26 May 2007 01:53:24 +0100"  >&lt;p&gt;Hi Reece,&lt;/p&gt;

&lt;p&gt;Thanks for trying my test case. I&apos;ve been playing around with commit dependencies, and this is, what I found:&lt;/p&gt;

&lt;p&gt;1) One reason, why your previous patch didn&apos;t work is, as you already found out, that the rows returned by RowManagerImpl.getInserts returns are not in user order. This might be unexpected and should either be documented or changed (I haven&apos;t found any usages of RowManagerImpl.getInserts in the current code, so it might be possible to change that). An alternative would be to add a new method RowManagerImpl.getOrderedInserts.&lt;/p&gt;

&lt;p&gt;2) Another situation, that generally doesn&apos;t work (both w/ your patch and w/o), is when relationships are nullified before the objects are deleted. Please see my new test openjpa-235-test1. OpenJPA doesn&apos;t execute updates for deleted objects. There will be a fk constraint violation if the updates are skipped and the objects aren&apos;t modified according to the constraint dependencies inside the user transaction. I couldn&apos;t find how to get &quot;old&quot; relationship value before the update, which would be needed for the dependency calculation.&lt;/p&gt;

&lt;p&gt;3) It seems, that join table entries are removed from the non-owning side. IMHO, relationship updates should only be done from the owning side.&lt;/p&gt;</comment>
                            <comment id="12500232" author="rgarret" created="Wed, 30 May 2007 21:41:26 +0100"  >&lt;p&gt;I&apos;ve posted my updated patch (sqlReorder2.patch). It is considerably different from the first patch. Statements are ordered based on dependency to other statements.  The logic is as follows:&lt;/p&gt;

&lt;p&gt;INSERTS: an insert statement depends on other insert statements involving rows with a non-nullable foreign key to it. If the foreign key is nullable and it is necessary to avoid a constraint violation then  the foreign key columns are initially inserted as null and later updated after the foreign key has been inserted. &lt;/p&gt;

&lt;p&gt;UPDATES: an update statement depends on insert statements involving rows with a non-nullable foreign key to it. If the foreign key is nullable and it is necessary to avoid a constraint violation then the foreign key columns are initially updated to null and later updated again after the foreign key has been inserted. &lt;/p&gt;

&lt;p&gt;DELETES: A delete statement depends on other delete statements involving rows with a non-nullable foreign key to it. If the foreign key is nullable and it is necessary to avoid a constraint violation then an update is generated to null the offending foreign key before this delete executes. A  delete statement may be generated because another delete or update dereferenced it&apos;s state. If this is the case then said delete depends on the update or delete that caused the dereferenced state.  &lt;/p&gt;

&lt;p&gt;To calculate dependencies for dereferenced states it is necessary to store those states in the state that dereferenced them. This involved adding a collection (set) to each state, methods to add and remove states to the collection, and a method to retrieve the states from the collection. Of the three methods mentioned only the method that retrieves the dereferenced states was added to the OpenJPAStateManager interface. I had to add the method to the interface because OperationOrderUpdateManager (where I calculate dependencies)  programs to that interface, however, SingleFieldManager, where the calls to dereference and un-dereference states initiate) does not. SingleFieldManager programs to StateManagerImpl which is an implementation of OpenJPAStatManager. Of course that did not prevent me from adding the add and remove methods to the OpenJPAStateManager interface but there was no reason to. &lt;/p&gt;

&lt;p&gt;Adding the one method to the OpenJPAStateManager interface forced me to change all implementing classes including DetatchedStateManager, DetachedValueStateManager, ObjectIdStateManager,  NullEmbeddedStateManager (an inner class of EmbededFieldStrategy), and of course StateManagerImpl. StateManagerImpl is the only implementation that actually uses the method so the rest of classes throw either an UnsupportedOperationException or an InternalException. &lt;/p&gt;

&lt;p&gt;I should also mention that I consider updating a persistence capable field to null to be dereferencing it and added the state for that persistence capable object to the collection of dereferenced states.&lt;/p&gt;

&lt;p&gt;I have provided a simple test case to exercise my code and have verified that all other OpenJPA test cases pass (with the exception of the TCK tests which I do not have access to). Without being able to run the TCK tests I cannot guarantee that I have addressed the issues that caused the previous failures, but I have caught several cases that I did not catch the first time so I am confident.&lt;/p&gt;

&lt;p&gt;Markus,&lt;/p&gt;

&lt;p&gt;Again, thank you for the test cases. They all pass and I have addressed all of  your issues you mentioned in your last post except for your comment about deletes from join tables. Join tables are secondary tables and are handled up front  by OpenJPA so I don&apos;t mess with any of that.&lt;/p&gt;</comment>
                            <comment id="12500291" author="gergul" created="Thu, 31 May 2007 07:00:25 +0100"  >&lt;p&gt;Reece,&lt;/p&gt;

&lt;p&gt;I&apos;m sorry it took so long, somehow I managed to mess up maven plugin repo, wasn&apos;t able to run tests at all for the last week. Testcases attached, they&apos;re ready to be used as part of standard openjpa tests. TestMultigenOneToManyMerge.updateDetached should succeed with the patch I attached. TestMultigenOneToManyMerge.updateAttached works with auto-generated tables against Derby, fails against mysql/innodb with foreign keys defined between tables, that&apos;s the case I&apos;m hoping your patch would solve.&lt;/p&gt;

&lt;p&gt;Let me know if you have trouble setting up/running the tests. &lt;/p&gt;

&lt;p&gt;Gokhan.&lt;/p&gt;</comment>
                            <comment id="12500460" author="rgarret" created="Thu, 31 May 2007 20:29:06 +0100"  >&lt;p&gt;Gokhan,&lt;/p&gt;

&lt;p&gt;Thank you for the test cases. The first test case ( testMergeAttached ) passes but the other case ( testMergeDetached ) fails before it even gets to my code. I see what you&apos;re trying to do and my patch should handle it. I&apos;m sorry I don&apos;t have time to tell you why the error occurs but I suspect it is a problem with your annotations. Here is the error testMergeDetached generates:&lt;/p&gt;

&lt;p&gt;&amp;lt;0.0.0 nonfatal user error&amp;gt; org.apache.openjpa.persistence.ArgumentException: Encountered new object &quot;org.apache.openjpa.persistence.merge.model.EntityB@1450f1f&quot; in persistent field &quot;org.apache.openjpa.persistence.merge.model.EntityC.parent&quot; of managed object &quot;org.apache.openjpa.persistence.merge.model.EntityC@1a722ef&quot; during attach.  However, this field does not allow cascade attach.  You cannot attach a reference to a new object without cascading.&lt;br/&gt;
FailedObject: org.apache.openjpa.persistence.merge.model.EntityB@1450f1f&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.getReference(AttachStrategy.java:276)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:193)&lt;br/&gt;
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:134)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:239)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.attachCollection(AttachStrategy.java:330)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.replaceCollection(AttachStrategy.java:298)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.attachField(AttachStrategy.java:220)&lt;br/&gt;
	at org.apache.openjpa.kernel.VersionAttachStrategy.attach(VersionAttachStrategy.java:134)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:239)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachStrategy.attachCollection(AttachStrategy.java:330)&lt;br/&gt;
	at org.apache.openjpa.kernel.DetachedStateManager.attach(DetachedStateManager.java:250)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:239)&lt;br/&gt;
	at org.apache.openjpa.kernel.AttachManager.attach(AttachManager.java:100)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.attach(BrokerImpl.java:3176)&lt;br/&gt;
	at org.apache.openjpa.kernel.DelegatingBroker.attach(DelegatingBroker.java:1147)&lt;br/&gt;
	at org.apache.openjpa.persistence.EntityManagerImpl.merge(EntityManagerImpl.java:665)&lt;br/&gt;
	at org.piercecountywa.personnel.openjpa.TestMultigenOneToManyMerge.testMergeDetached(TestMultigenOneToManyMerge.java:108)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Unknown Source)&lt;br/&gt;
	at junit.framework.TestCase.runTest(TestCase.java:164)&lt;br/&gt;
	at junit.framework.TestCase.runBare(TestCase.java:130)&lt;br/&gt;
	at junit.framework.TestResult$1.protect(TestResult.java:110)&lt;br/&gt;
	at junit.framework.TestResult.runProtected(TestResult.java:128)&lt;br/&gt;
	at junit.framework.TestResult.run(TestResult.java:113)&lt;br/&gt;
	at junit.framework.TestCase.run(TestCase.java:120)&lt;br/&gt;
	at junit.framework.TestSuite.runTest(TestSuite.java:228)&lt;br/&gt;
	at junit.framework.TestSuite.run(TestSuite.java:223)&lt;br/&gt;
	at org.junit.internal.runners.OldTestClassRunner.run(OldTestClassRunner.java:35)&lt;br/&gt;
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:38)&lt;br/&gt;
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)&lt;br/&gt;
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)&lt;br/&gt;
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)&lt;br/&gt;
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)&lt;br/&gt;
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)&lt;/p&gt;

&lt;p&gt;Again, the good news is the first test case runs great and what you&apos;re trying to do in the second test should work great too. If you can figure out what the issue is on that second test please post it.&lt;/p&gt;</comment>
                            <comment id="12500481" author="gergul" created="Thu, 31 May 2007 21:38:11 +0100"  >&lt;p&gt;Reece --thanks for trying them out, good news indeed on the attached-merge front. The issue with detached testcase is as follows: merge A cascades to B, which in turn cascades to C, since the relations between A -&amp;gt; B and B -&amp;gt; C are annotated with Cascade.ALL on OneToMany sides. But as there&apos;s no cascade annotation on ManyToOne side (owner side of bidirectional relation), when AttachManager tries to attach those fields (such as C.parent), it encounters a new object (an instance of EntityB), and complains as such. In all fairness, that&apos;s correct &amp;#8211; B is a new object and there&apos;s no Cascade.MERGE from C.parent to B. The missing piece of information is, that B object has already been attached (evidently since manager._attached map contains it) as part of that &quot;merge session&quot; so to speak --that&apos;s the object via which AttachManager got to object C in the first place, and B will be persisted as part of the same transaction. So there&apos;s no grounds to reject it. That&apos;s what the patch I attached along with the testcase does. If you could go ahead and apply it, you should no longer see that error.&lt;/p&gt;</comment>
                            <comment id="12500542" author="m_fuchs" created="Fri, 1 Jun 2007 01:38:49 +0100"  >&lt;p&gt;Hi Reece,&lt;/p&gt;

&lt;p&gt;I ran the JPA TCK with your changes, and all tests passed!&lt;br/&gt;
Congratulations.&lt;/p&gt;

&lt;p&gt;But I&apos;d need some more time to really understand your changes. One&lt;br/&gt;
question upfront: What does &quot;dereference&quot; mean? Does it mean changing&lt;br/&gt;
the reference to a persistence capable object?&lt;/p&gt;

&lt;p&gt;Hi Reece &amp;amp; Gokhan:&lt;/p&gt;

&lt;p&gt;Are non-nullable foreign keys the only reason for constraint&lt;br/&gt;
dependencies? One update can be dependent on another update in case of&lt;br/&gt;
a OneToOne relationship, as OneToOne relationships are usually&lt;br/&gt;
enforced by unique keys in the database. Please also consider the&lt;br/&gt;
following situation:&lt;/p&gt;

&lt;p&gt;a -&amp;gt; b;&lt;br/&gt;
c -&amp;gt; d;&lt;/p&gt;

&lt;p&gt;tx.begin();&lt;br/&gt;
c -&amp;gt; b;&lt;br/&gt;
a -&amp;gt; null;&lt;br/&gt;
tx.commit();&lt;/p&gt;

&lt;p&gt;B/c of the unique key, the foreign key in the row corresponding to &quot;a&quot;&lt;br/&gt;
has to be nullified, &lt;b&gt;before&lt;/b&gt; the foreign key in row &quot;c&quot; can be&lt;br/&gt;
updated. Does this dependency also need to be addressed?&lt;/p&gt;

&lt;p&gt;Is above dependency different from the dependencies imposed by&lt;br/&gt;
non-nullable foreign keys? I.e. can non-nullable foreign keys cause&lt;br/&gt;
dependencies, that can&apos;t be addressed by the user order of operations?&lt;br/&gt;
Are non-nullable foreign keys different in this regard?&lt;/p&gt;

&lt;p&gt;Thanks and sorry for my late reply!&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12500765" author="gergul" created="Fri, 1 Jun 2007 18:14:42 +0100"  >&lt;p&gt;Marcus,&lt;/p&gt;

&lt;p&gt;I&apos;m not familiar with the specifics of Reece&apos;s patch (yet), but to answer your question from a theoretical point of view: As your example demonstrates, not-nullable FKs are not the only reason for such dependencies. The real issue with ordering statements is not about nullable/not-nullable constraints, but rather with whether the target database supports deferred constraints or not (constraints enforced at transaction commit time, as opposed constraints enforced after each statement). If the target database supports deferred constraints, we&apos;d have no need to reorder statements --assuming that resulting set of rows (or lack of them) at transaction commit do not violate any constraints. Otherwise the transaction will fail anyway, irrespective of if/how you order the statements. &lt;/p&gt;

&lt;p&gt;On a related note, since you have access to TCK tests, is there any chance you can apply the patch I posted to see if it breaks anything? If we could take that detached testcase out of the picture I&apos;ll go ahead mark &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-231&quot; title=&quot;Incorrect handling of cascading bidirectional collections during merge/attach&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-231&quot;&gt;&lt;del&gt;OPENJPA-231&lt;/del&gt;&lt;/a&gt; resolved, since the issue with attached testcase is the same with this one. &lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Gokhan.&lt;/p&gt;
</comment>
                            <comment id="12500768" author="rgarret" created="Fri, 1 Jun 2007 18:20:29 +0100"  >&lt;p&gt;Markus, &lt;/p&gt;

&lt;p&gt;That is great news! Thanks for running those test and getting back to me. &lt;/p&gt;

&lt;p&gt;Dereferenced means that a persistence capable object was either nulled or replaced. I need to capture this information because the dereference may cause a delete. If that is the case, then by the time the code gets to OperationOrderUpdateManager there is no way to calculated the dependency between the delete and the update which caused it without knowing who dereferenced who. &lt;/p&gt;

&lt;p&gt;As a concrete example: A has a non-nullable reference to B and no one else refers to B. You replace B with B2 thus dereferencing B. B is now orphaned and will be deleted. You get three rows generated:&lt;/p&gt;

&lt;p&gt;Row 1: insert B2&lt;/p&gt;

&lt;p&gt;Row 2: update A to point to B2&lt;/p&gt;

&lt;p&gt;Row 3: delete B&lt;/p&gt;

&lt;p&gt;So, row 2 depends on row 1 and row 3 depends on row 2. But, without knowing that the state manager for row 2 was responsible for dereferencing the state manager for row 3 (thus causing the delete) there is no way to know that row 3 depends on row 2. Without having that dependency row 3 could be run before row 2 and would violate the foreign key constraint.&lt;/p&gt;

&lt;p&gt;As for your second question, no, non-nullable foreign keys are not the only reason for constraint&lt;br/&gt;
dependencies. Unique key constraints also cause dependencies. With unique keys an insert can depend on an update or delete and an update can depend on another update or delete. I mentioned earlier that I have a plan for dealing with this but decided that it would be best complete my patch for foreign keys first and then tackle uniques. I have a post on the mailing list where I get into a bit more detail. The post was placed on May 22nd and is titled &quot;SQL ordering and unique constraints&quot;. &lt;/p&gt;

&lt;p&gt;Hope that all made sense. If you have any more questions please ask away.&lt;/p&gt;

&lt;p&gt;Gokhan,&lt;/p&gt;

&lt;p&gt;I&apos;m sorry but I have not had a chance to apply your patch and try my code with it yet. I&apos;ll try my best to get to it but assuming your patch corrects the problem I was running into I see no reason why it won&apos;t work. I&apos;m being lazy by not looking but have you posted your issue as a bug and posted the patch for these guys to test? &lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12501352" author="m_fuchs" created="Mon, 4 Jun 2007 21:35:19 +0100"  >&lt;p&gt;Gokhan, &lt;/p&gt;

&lt;p&gt;I applied your patch and ran the TCK successfully again. Your testcase TestMultigenOneToManyMerge passes, too.&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12501368" author="gergul" created="Mon, 4 Jun 2007 21:58:22 +0100"  >&lt;p&gt;Markus, &lt;/p&gt;

&lt;p&gt;Good news, thanks for your time and effort. What&apos;s the process to get the patch and testcases reviewed/committed? &lt;/p&gt;

&lt;p&gt;Reece --yep, it&apos;s been there for a while (&lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-231&quot; title=&quot;Incorrect handling of cascading bidirectional collections during merge/attach&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-231&quot;&gt;&lt;del&gt;OPENJPA-231&lt;/del&gt;&lt;/a&gt;), didn&apos;t get as much attention as this one though.   &lt;/p&gt;
</comment>
                            <comment id="12501996" author="rgarret" created="Wed, 6 Jun 2007 18:11:47 +0100"  >&lt;p&gt;Is there any update on the status of my patch? I don&apos;t want to start work on a new patch to deal with unique key constraints until this patch gets committed. I&apos;m sure you&apos;ve all been busy what with OpenJPA being promoted to a top level project.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12502036" author="pcl" created="Wed, 6 Jun 2007 19:54:25 +0100"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I just checked in a change (r544918) that does re-ordering according to a graph traversal. It looks like your solution has better handling of nulled relations than the code that I checked in, so we might want to look at how to integrate the two approaches a bit more. I haven&apos;t tried your tests against these changes, though. Ideally, it&apos;d be good to get your test cases into a patch form that we can just check into the codebase directly.&lt;/p&gt;</comment>
                            <comment id="12502155" author="m_fuchs" created="Thu, 7 Jun 2007 01:12:24 +0100"  >&lt;p&gt;Hi Patrick,&lt;/p&gt;

&lt;p&gt;from comments in ConstraintUpdateManager (line 101,102) I got the impression, that you assume that inserts can not be dependent on updates. The attached testcase displays a situation (involving an unique key) where an insert is actually dependent on an update.&lt;/p&gt;

&lt;p&gt;Best regards,&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12502535" author="rgarret" created="Thu, 7 Jun 2007 22:31:44 +0100"  >&lt;p&gt;Hello Patrick,&lt;/p&gt;

&lt;p&gt;Your patch works great for foreign keys but I wrote my patch in anticipation of adding uniqueness constraint dependencies. Markus is correct, when you consider uniqueness constraints an insert can depend on an update or a delete and an update can depend on another update or a delete.&lt;/p&gt;

&lt;p&gt;Say you have an insert which depends on a delete because of a uniqueness constraint. The delete should get ordered first. However, the delete was originally generated because there is an update either nulling or replacing  a foreign key reference to it . If the delete runs before the update a foreign key violation will occur because the row being deleted has not been dereferenced by the update yet. Upon seeing that the delete precedes the update which it depends on the code must update the offending foreign key to null before the delete executes (this assumes the foreign key is nullable, if not then you&apos;re out of luck).&lt;/p&gt;

&lt;p&gt;The code you committed does not know about the dependency between the delete and the update and thus can not handle the above situation. In fact, without having my list of dereferenced states for each state manager I do not see how the dependency can be calculated. &lt;/p&gt;

&lt;p&gt;Other than that, the code looks great. My test cases pass and I will attach them as a patch (&quot;sqlReorderTests.patch&quot;). &lt;/p&gt;

&lt;p&gt;Any input you have on the uniqueness constraint issue would be much appreciated because that&apos;s the last piece to this puzzle. Secretly I&apos;m hoping you guys will tackle this one because it doesn&apos;t look too hard and will give you guys (another) advantage over the competition. I know I can do it but it will require going a bit deeper into the code than I feel totally comfortable with. For all updates and deletes I&apos;d have to store the original values (as they stood at the beginning of the transaction) for columns involved in uniqueness constraints. Then, when calculating dependencies for inserts and updates where uniqueness constraints are involved I&apos;d check all updates and deletes going to the same table and see if they need to be run first to prevent a unique key violation. Like I said, it shouldn&apos;t be rocket science as all the data needed to do this is pulled from the database; just not stored for later access. Updates have some of these original values stored for rollback but deletes don&apos;t store any of the original values except the primary key and version. &lt;/p&gt;

&lt;p&gt;Basically, if there was a method &quot;RowImpl.getOriginal(Column col)&quot; that works just like the existing method &quot;RowImpl.getSet(Column col)&quot;  but returns the original value for the specified column then it would be smooth sailing from there.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12502554" author="pcl" created="Thu, 7 Jun 2007 23:01:09 +0100"  >&lt;p&gt;&amp;gt; Basically, if there was a method &quot;RowImpl.getOriginal(Column col)&quot; that&lt;br/&gt;
&amp;gt; works just like the existing method &quot;RowImpl.getSet(Column col)&quot; but&lt;br/&gt;
&amp;gt; returns the original value for the specified column then it would be smooth&lt;br/&gt;
&amp;gt; sailing from there. &lt;/p&gt;

&lt;p&gt;Would it be sufficient to just always run the deletes first, then the updates, and finally the inserts, when there are unique constraints involved? Assuming that we optimize away any SQL operations for insert-then-delete-before-flush, it would seem that that algorithm would be guaranteed to work when no constraint violations were generated in the business code, which I think is all that we can really strive for in the case of unique constraints.&lt;/p&gt;</comment>
                            <comment id="12502561" author="clr" created="Thu, 7 Jun 2007 23:49:11 +0100"  >&lt;p&gt;&amp;gt; Would it be sufficient to just always run the deletes first, then the updates, and finally the inserts, when there are unique constraints involved? Assuming that we optimize away any SQL operations for insert-then-delete-before-flush, it would seem that that algorithm would be guaranteed to work when no constraint violations were generated in the business code, which I think is all that we can really strive for in the case of unique constraints.&lt;/p&gt;

&lt;p&gt;This algorithm isn&apos;t quite enough. Consider deleting an instance that has a reference from an instance that is being updated to nullify that reference. Then you want to do the update to nullify the reference before you do the delete.&lt;/p&gt;

&lt;p&gt;I think the general issue is that due to uniqueness and referential integrity constraints you need to create a dependency graph and then order the operations to preserve the dependencies. But you also want to preserve the order the user made the changes to avoid deadlocks due to locking dependencies. And you also want to reorder operations to take advantage of statement batching.&lt;/p&gt;</comment>
                            <comment id="12502575" author="pcl" created="Fri, 8 Jun 2007 00:28:02 +0100"  >&lt;p&gt;&amp;gt; This algorithm isn&apos;t quite enough. Consider deleting an instance that has&lt;br/&gt;
&amp;gt; a reference from an instance that is being updated to nullify that&lt;br/&gt;
&amp;gt; reference. Then you want to do the update to nullify the reference before&lt;br/&gt;
&amp;gt; you do the delete.&lt;/p&gt;

&lt;p&gt;That should be already caught in the graph traversal that&apos;s in place, since presumably such a constraint would be a foreign key constraint, not a unique constraint. Am I missing something?&lt;/p&gt;</comment>
                            <comment id="12502601" author="rgarret" created="Fri, 8 Jun 2007 02:34:27 +0100"  >&lt;p&gt;&amp;gt; Would it be sufficient to just always run the deletes first, then the updates, and finally the inserts, when there are unique constraints involved? &lt;br/&gt;
&amp;gt; Assuming that we optimize away any SQL operations for insert-then-delete-before-flush, it would seem that that algorithm would be guaranteed to &amp;gt; work when no constraint violations were generated in the business code, which I think is all that we can really strive for in the case of unique &lt;br/&gt;
&amp;gt; constraints.&lt;/p&gt;

&lt;p&gt;That won&apos;t work because updates can have inner dependencies due to uniqueness constraints. For instance, you have a table with a unique column and two rows. The first row has value &apos;1&apos;  in the unique column and the second row has value &apos;2&apos; in the unique column. You want to update the unique column in the first row to value &apos;2&apos; and the unique column in the second row to value &apos;3&apos;. The second row must be updated first but the only way to know that is to have access to the original values of both rows. I see no way to properly deal with unique keys without snapshots of the original rows.&lt;/p&gt;

&lt;p&gt;Like I said, OpenJPA already pulls the origin values and if I could access them with a method like RowImpl.getOriginal(Column col) then I could modify my patch to deal with both unique and foreign key constraints in no time flat. The original values could be put in an array on the row the same way set values for updates are put in the _vals array.&lt;/p&gt;

&lt;p&gt;Also, although blindly putting deletes before inserts and updates works for uniqueness constraints, it does not work for foreign key constraints because it is possible for either an update or another delete to depend on that delete. Putting the delete first only works if all inbound foreign key dependencies are nulled first. But, there are two problems with that.&lt;/p&gt;

&lt;p&gt;1) The patch you committed does not know about dependencies between updates and the deletes they have caused by breaking relationships to other objects. You need to know that if you&apos;re planning on arbitrarily ordering deletes first for uniqueness constraints, otherwise, you won&apos;t know that an update needs to be generated to null a foreign key which relies on the row your about to delete. That&apos;s why I store dereferenced states in my patch. By the time your code executes that information is lost in space.&lt;/p&gt;

&lt;p&gt;2) By ordering a delete first for tables with uniqueness constraints without checking to see if an insert or update actually depends on it  (only way is to check the original values) you could be generating unnecessary updates to null foreign keys.&lt;/p&gt;

&lt;p&gt;In a nutshell, if we want to do unique and foreign key constraints properly we need original values on both updates and deletes and be able to access those values using the columns they map to, just like is done for RowImpl.getSet(Column col). And we need to be able to calculate dependencies between deletes and updates in cases where the delete was caused by the update.&lt;/p&gt;

&lt;p&gt;-Reece &lt;/p&gt;</comment>
                            <comment id="12503698" author="m_fuchs" created="Tue, 12 Jun 2007 02:03:52 +0100"  >&lt;p&gt;Hi all,&lt;/p&gt;

&lt;p&gt;I propose the following steps to extend dependency management based on&lt;br/&gt;
the current implementation in ConstraintUpdateManager:&lt;/p&gt;

&lt;p&gt;The current dependency calculation is based on a Depth First Search&lt;br/&gt;
(DFS) algorithm on the dependency graph defined by foreign key&lt;br/&gt;
constraints for inserts and deletes. Unique key constraints are&lt;br/&gt;
currently not handled.&lt;/p&gt;

&lt;p&gt;1) Circles are identified by &quot;BACK&quot; edges found by the DFS and are&lt;br/&gt;
  broken right there by nullifying the foreign key corresponding to&lt;br/&gt;
  the &quot;BACK&quot; edge. This doesn&apos;t work, if this foreign key is not&lt;br/&gt;
  nullable. Instead, I propose to identify the edges that contribute&lt;br/&gt;
  to the circle in the NodeInfo corresponding to each graph node. If&lt;br/&gt;
  we have the info about about the edges on the circle, we can walk&lt;br/&gt;
  the circle and break it at the first &lt;b&gt;nullable&lt;/b&gt; foreign key&lt;br/&gt;
  found. Note, that there can&apos;t be a circle consisting of only&lt;br/&gt;
  non-nullable foreign keys!&lt;/p&gt;

&lt;p&gt;2) In a second phase, incorporate dependencies based on unique keys&lt;br/&gt;
  into the graph construction. That means that instead of possibly&lt;br/&gt;
  getting two independent graphs, one for inserts and one for&lt;br/&gt;
  deletes, we&apos;d always have just one graph including inserts,&lt;br/&gt;
  updates, and deletes. The flush algorithm described in 1) would&lt;br/&gt;
  stay the same, just the dependency graph would have additional&lt;br/&gt;
  edges.&lt;/p&gt;

&lt;p&gt;3) Independent rows (rows that weren&apos;t included in the dependency&lt;br/&gt;
  graph) are currently flushed in random order. This might cause&lt;br/&gt;
  deadlocks in the database. As an additional feature, we might want&lt;br/&gt;
  to flush these rows in the order they were modified in the&lt;br/&gt;
  transaction.&lt;/p&gt;

&lt;p&gt;Does this make sense? What do you think? Did I miss anything?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;
</comment>
                            <comment id="12503994" author="rgarret" created="Tue, 12 Jun 2007 21:35:25 +0100"  >&lt;p&gt;Markus,&lt;/p&gt;

&lt;p&gt;That looks like an excellent solution. It doesn&apos;t look like you&apos;ve missed anything.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12504326" author="rgarret" created="Wed, 13 Jun 2007 17:57:17 +0100"  >&lt;p&gt;Hello all,&lt;/p&gt;

&lt;p&gt;I would like to know if anyone has plans or is in the process of implementing Markus&apos;s solution?  Obviously, based on the interest this has generated, it is an important addition to OpenJPA. However, for the moment I can not devote anymore development hours to working on a new patch. Right now we are dealing with unique keys by...not using them. This will work in the short term but we&apos;ll have to find a way to handle them soon. Perhaps at that point I&apos;ll get more hours to work on a patch but  I&apos;m a bit apprehensive because as I mentioned earlier, it will require going a bit deeper in to the code to store original values to calculate unique key dependencies. It is also difficult working on this without access to the TCK tests.&lt;/p&gt;

&lt;p&gt;As Markus suggests, the solution is basically the current implementation in ConstraintUpdateManager with provisions for capturing dereferenced rows to calculate update-delete dependencies (my second patch does this), circular reference handling (my second patch does minimal handling but Markus&apos;s solution is better), deadlock prevention, and of course unique key dependencies.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12504478" author="m_fuchs" created="Thu, 14 Jun 2007 00:54:32 +0100"  >&lt;p&gt;Hi Reece,&lt;/p&gt;

&lt;p&gt;I started implementing my proposal. As the 3 steps are pretty much independent, I&apos;ll be posting patches and new test cases for every phase here. I&apos;m looking forward to using some of the code you already provided. Thanks for getting this started.&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12505311" author="rgarret" created="Fri, 15 Jun 2007 18:07:21 +0100"  >&lt;p&gt;Markus,&lt;/p&gt;

&lt;p&gt;Excellent, we&apos;re in good hands then. Please let me know if you have any questions about my code or in general.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12506579" author="kwsutter" created="Wed, 20 Jun 2007 16:51:15 +0100"  >&lt;p&gt;Can someone summarize the current state of this JIRA report?  From the comments and the commits, it sounds like Patrick has committed at least a partial solution, but there are still some holes based on the original JIRA report.  I have not seen another patch posted after Patrick&apos;s commits on June 06 and 07, except for testcase patches.&lt;/p&gt;

&lt;p&gt;So, what are we waiting on?  Do we have additional code patches or commits required to finish up this report?  It sounds like Markus is working on an implementation, but is to resolve this Issue or a new proposal?  What about the testcases?  Patrick integrated some changes for the testcases, but are they complete?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12506602" author="kevan" created="Wed, 20 Jun 2007 18:00:52 +0100"  >&lt;p&gt;Geronimo testing has started running into duplicate key and foreign key constraint exceptions. I&apos;ve tracked the problem down to revision 544918. &lt;/p&gt;

&lt;p&gt;I haven&apos;t, however, fully diagnosed the problem... Are you not seeing any problems in your testing?&lt;/p&gt;

&lt;p&gt;BTW, Geronimo has a policy which allows interested Apache committers from other projects to gain guest access to our tck infrastructure. This has worked really well with Axis and CXF projects. Would be great to have OpenJPA participation, also. If anyone&apos;s interested contact me or our dev list...&lt;/p&gt;</comment>
                            <comment id="12506606" author="pcl" created="Wed, 20 Jun 2007 18:22:56 +0100"  >&lt;p&gt;That&apos;s surprising, since OpenJPA passes the JPA TCK with the change. Do you have any more details about which test is failing?&lt;/p&gt;

&lt;p&gt;Also, note that you can always manually specify the old operation-order update manager (via the openjpa.jdbc.UpdateManager property), which will give you the old behavior.&lt;/p&gt;</comment>
                            <comment id="12506611" author="rgarret" created="Wed, 20 Jun 2007 18:44:11 +0100"  >&lt;p&gt;Kevin,&lt;/p&gt;

&lt;p&gt;The patch which Patrick submitted is not a complete solution, however, it seems to work quite well for foreign key constraints. I&apos;m not certain what you mean by &quot;complete&quot;, but the test cases I submitted exercise the code in such a way that a foreign key constraint violation should occur if ordering is not done properly. Markus is in the  process of implementing the changes he outlined a few posts back so we&apos;re waiting for him to contribute his code. &lt;/p&gt;

&lt;p&gt;Kevan,&lt;/p&gt;

&lt;p&gt;Revision 544918 is not my code and to be honest I haven&apos;t had a chance to look at it in depth. I did write the test cases that were committed and they all pass; perhaps there are scenarios I failed to address. Without knowing the specifics of the exceptions it&apos;s hard to say what the problem could be. Please let us know when you determine the exact cause. &lt;/p&gt;

&lt;p&gt;I am definitely interested in gaining access to your tck infrastructure. As I said earlier, I work for a government organization so signing the NDA presents certain legal issues.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;
</comment>
                            <comment id="12506619" author="m_fuchs" created="Wed, 20 Jun 2007 19:26:11 +0100"  >&lt;p&gt;Hi Kevin &amp;amp; Kevan,&lt;/p&gt;

&lt;p&gt;The current implementation in ConstraintUpdateManager handles foreign key constraints correctly and resolves circular dependencies. AFAIK, the only pieces missing are:&lt;/p&gt;

&lt;p&gt;1) OpenJPA might try to nullify a non-nullable foreign key in case of circular dependencies&lt;br/&gt;
2) Dependencies based on unique keys and not handled right now &lt;/p&gt;

&lt;p&gt;I&apos;m working on add these features as described in my earlier post.&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12506624" author="kevan" created="Wed, 20 Jun 2007 19:41:26 +0100"  >&lt;p&gt;Reece, afraid access to the tck would still require signing the NDA.&lt;/p&gt;

&lt;p&gt;Patrick, afraid I can&apos;t really discuss details of the test failures. They wouldn&apos;t be in a &quot;JPA&quot; test suite. This is why it would be great if we could share some of this information more openly. Best (only?) way that I know of is by getting access to our TCK.&lt;/p&gt;

&lt;p&gt;I&apos;ll see if I (or someon else) can generate enough info on the problem...&lt;/p&gt;</comment>
                            <comment id="12506627" author="rgarret" created="Wed, 20 Jun 2007 19:46:27 +0100"  >&lt;p&gt;It&apos;s times like these when open source doesn&apos;t seem so.....open.&lt;/p&gt;</comment>
                            <comment id="12506635" author="mprudhom" created="Wed, 20 Jun 2007 19:58:45 +0100"  >&lt;p&gt;Kevan-&lt;/p&gt;

&lt;p&gt;If you set the &quot;openjpa.jdbc.UpdateManager&quot; to be &quot;operation-order&quot;, do you still see the failures? That will at least help identify if this is a problem that always happened, or if it is new and is due to the FK ordering support.&lt;/p&gt;</comment>
                            <comment id="12506649" author="kevan" created="Wed, 20 Jun 2007 20:53:34 +0100"  >&lt;p&gt;Patrick and Marc,&lt;br/&gt;
Setting -Dopenjpa.jdbc.UpdateManager=operation-order does avoid the problem. Let me know if there&apos;s additional data that can be gathered...&lt;/p&gt;

&lt;p&gt;Reece,&lt;br/&gt;
Understood. The NDA is required because of Sun restrictions (you would be getting access to Sun restricted materials). I certainly wish we didn&apos;t have to go through these shenanigans...&lt;/p&gt;</comment>
                            <comment id="12506655" author="gergul" created="Wed, 20 Jun 2007 21:08:08 +0100"  >&lt;p&gt;Patrick,&lt;/p&gt;

&lt;p&gt;ConstraintUpdateManager breaks the testcase I previously submitted (attachment #2) while persisting initial entities with FK violation (against mysql, passes against derby) --before it actually gets around to test merge behaviour. That phase at least works fine with OperationOrderUpdateManager. &lt;/p&gt;</comment>
                            <comment id="12506964" author="rgarret" created="Thu, 21 Jun 2007 18:25:32 +0100"  >&lt;p&gt;Kevan,&lt;/p&gt;

&lt;p&gt;Concerning the exceptions you&apos;re getting, one of my colleagues suggested (and I agree) that  OpenJPA may not know about some foreign keys due to missing foreign key annotations. There are several cases where OpenJPA defines logical foreign keys but not actual foreign keys unless explicitly instructed to do so by the @ForeignKey or @ElementForeignKey annotations. I was not able to detect logical foreign keys when calculating dependencies between rows. I solved this problem by explicitly declaring the foreign keys I was missiong. Logical foreign keys worked well before the patch because the code did not need to detect the foreign keys for ordering.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12507017" author="gergul" created="Thu, 21 Jun 2007 21:20:11 +0100"  >&lt;p&gt;Fixed wrong/missing headers in testcases.&lt;/p&gt;</comment>
                            <comment id="12508289" author="m_fuchs" created="Tue, 26 Jun 2007 20:10:42 +0100"  >&lt;p&gt;Hi Kevan,&lt;/p&gt;

&lt;p&gt;Is it possible that the tests failing with ConstraintUpdateManager update/null-out relationships before the instance is deleted? With the current implementation dependencies wouldn&apos;t be detected. Depending on the operation order, these situations  work with OperationOrderUpdateManager.&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12511580" author="m_fuchs" created="Tue, 10 Jul 2007 22:45:35 +0100"  >&lt;p&gt;This patch guarantees that circular dependencies are always broken at nullable foreign keys. Its successfully tested by new tests and running the JPA TCK. The changes are:&lt;/p&gt;

&lt;p&gt;ConstraintUpdateManager.java:&lt;br/&gt;
=============================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;analyzeForeignKeys, analyzeAgainstInserts:&lt;br/&gt;
the direction of edges in the dependency graph has been reversed. &lt;br/&gt;
A node has edges to other nodes it depends on&lt;/li&gt;
	&lt;li&gt;flushGraph:&lt;br/&gt;
Handles circular constraints&lt;/li&gt;
	&lt;li&gt;if deleted row A has a ciricular fk to deleted row B,&lt;br/&gt;
  then use an update statement to null A&apos;s fk to B before flushing, &lt;br/&gt;
  and then flush&lt;/li&gt;
	&lt;li&gt;if inserted row A has a circular fk to updated/inserted row B,&lt;br/&gt;
  then null the fk in the B row object, then flush,&lt;br/&gt;
  and after flushing, use an update to set the fk back to A&lt;br/&gt;
Depending on where circular dependencies are broken, the  &lt;br/&gt;
topological order of the graph nodes has to be re-calculated;&lt;br/&gt;
The Lists deleteUpdates and insertUpdates are always initialized, &lt;br/&gt;
since they are passed to resolceCycles &lt;/li&gt;
	&lt;li&gt;addDeleteUpdate, addInsertUpdate:&lt;br/&gt;
refactored the code nulifying foreign keys into separate methods&lt;/li&gt;
	&lt;li&gt;findBreakableLink:&lt;br/&gt;
finds a nullable foreign key by walking the dependency cycle.&lt;/li&gt;
	&lt;li&gt;recalculateDFA:&lt;br/&gt;
Re-calculates the DepthFirstSearch analysis of the graph &lt;br/&gt;
after some of the edges have been removed. Assertions ensure&lt;br/&gt;
that the graph is cycle free.&lt;/li&gt;
	&lt;li&gt;resolveCycles:&lt;br/&gt;
Resolves cycles by identifying a nullable foreign key, and &lt;br/&gt;
then calling either addDeleteUpdate or addInsertUpdate depending &lt;br/&gt;
on the operation causing the dependency&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ForeignKey.java:&lt;br/&gt;
================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;hasNotNullColumns:&lt;br/&gt;
checks for non-nullable local columns&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;kernel/localizer.properties:&lt;br/&gt;
============================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added messages used in ConstraintUpdateManager.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;DepthFirstAnalysis.java:&lt;br/&gt;
========================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added localizer for messages&lt;/li&gt;
	&lt;li&gt;visit:&lt;br/&gt;
a) takes a list of graph edges traversed while walking the graph in DFS; &lt;br/&gt;
list is initially empty; &lt;br/&gt;
always contains the edges walked to reach currently visited node&lt;br/&gt;
b) the cycle is calculated for back- and forward edges;&lt;br/&gt;
The cycle always exists for back edges part: of path + back edge;&lt;br/&gt;
The cycle might exist for forward edges: Reasons for forward edges&lt;br/&gt;
i) The graph is disconnected or ii) Threre&apos;s a cycle. &lt;/li&gt;
	&lt;li&gt;buildCycle:&lt;br/&gt;
Constructs the cycle for back edges: part of DFS path + back edge&lt;/li&gt;
	&lt;li&gt;cycleForBackEdge:&lt;br/&gt;
calculates the cycle for a back edge&lt;/li&gt;
	&lt;li&gt;cycleForForwardEdge:&lt;br/&gt;
Once a forward edge is found, the graph is walked to find a path from&lt;br/&gt;
the end of the forward edge back to it&apos;s beginning node&lt;/li&gt;
	&lt;li&gt;findNodeInPath:&lt;br/&gt;
Finds the position of the edge starting from a node in a continuous &lt;br/&gt;
list of edges.&lt;/li&gt;
	&lt;li&gt;NodeInfoComparator.compare&lt;br/&gt;
Since the edge direction is reversed, node are sorted by finished order&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Edge.java:&lt;br/&gt;
==========&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;List cycle holds the cycle for back- and forward edges&lt;/li&gt;
	&lt;li&gt;cycle field is re-set in clearTraversal&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;util/localizer.properties:&lt;br/&gt;
==========================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added messages used in DepthFirstAnalysis.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;TestDepthFirstAnalysis.java:&lt;br/&gt;
============================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;refactored test data set up&lt;/li&gt;
	&lt;li&gt;adjusted testNodeSorting for reversed edge direction&lt;/li&gt;
	&lt;li&gt;added new graph resembling the commit dependencies in&lt;br/&gt;
TestNoForeignKeyViolation#testComplexCycle to test cycle detection&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;EntityB.java, EntityC.java:&lt;br/&gt;
===========================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;reintroduced &quot;non optional&quot; property removed in last commit&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;EntityD.java:&lt;br/&gt;
=============&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added two optional relationships to EntityA and EntityB. Both&lt;br/&gt;
relationships may cause a circular dependency&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;EntityE.java:&lt;br/&gt;
=============&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added class, has a nullable relationship to EntityB. This&lt;br/&gt;
relationship doesn&apos;t cause a circular dependency&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;TestNoForeignKeyViolation.java:&lt;br/&gt;
===============================&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;refactored test data set up&lt;/li&gt;
	&lt;li&gt;testSimpleCycle&lt;br/&gt;
Dependency graph has exactly one cycle. &lt;br/&gt;
The nodes on the cycle don&apos;t have any edges which are not on the cycle&lt;/li&gt;
	&lt;li&gt;testComplexCycle&lt;br/&gt;
Like above. One node on the cycle has an edge which is not on the cycle&lt;/li&gt;
	&lt;li&gt;testComplexTwoCycles&lt;br/&gt;
Dependency graph has two cycles. Otherwise like above.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12512735" author="clr" created="Sat, 14 Jul 2007 21:18:53 +0100"  >&lt;p&gt;I&apos;m not competent to evaluate the entire patch, but here are a few comments on openjpa-235-break-nullable.patch:&lt;/p&gt;

&lt;p&gt;First, the patch is nicely commented, follows the code conventions, and is very readable.&lt;/p&gt;

&lt;p&gt;1. Assert is used to detect fatal internal errors not user errors. For production code, assertions are turned off. It&apos;s not clear that recalculateDFA should use the assert keyword. If this code is executed after trying to break cycles, but due to the schema the cycle cannot be broken, then this is not an invariant and assert should not be used. On the other hand, if this code is only executed after successfully removing an edge and the assertion should never fail, then it&apos;s ok.&lt;/p&gt;

&lt;p&gt;2. Similarly, resolveCycles should not use assert, since it&apos;s a user condition not an invariant.&lt;/p&gt;

&lt;p&gt;3. It&apos;s hard to tell if cycleForBackEdge should use assert.&lt;/p&gt;

&lt;p&gt;4. The new messages in localizer.properties are pretty terse. Are these user messages or internal diagnostics? If user messages, they could be expanded. For example, instead of&lt;br/&gt;
+no-nullable-fk: No nullable foreign key found to resolve circular commit dependency.&lt;br/&gt;
perhaps something that tells the user&lt;br/&gt;
+no-nullable-fk: No nullable foreign key found to resolve circular flush dependency. During flush processing, changes to instances, new instances, and deleted instances must be processed in a specific sequence to avoid foreign key constraint violations. The changes required in this transaction cannot be reordered because none of the foreign key constraints is nullable (optional). &lt;/p&gt;</comment>
                            <comment id="12513124" author="m_fuchs" created="Tue, 17 Jul 2007 02:06:03 +0100"  >&lt;p&gt;Thanks Craig for the review! To your comments:&lt;/p&gt;

&lt;p&gt;1. The graph passed to recalculateDFA should never have cycles. The assertion is testing an invariant. I abstracted the check for no cycles into a new method hasNoCycles in DepthFirstAnalysis. I re-named recalculateDFA to recalculateDepthFirstAnalysis.&lt;/p&gt;

&lt;p&gt;2. resolveCycles now throws a UserException, if no nullable foreign key can be found.&lt;/p&gt;

&lt;p&gt;3. The assertions in cycleForBackEdge are testing invariants and are therefor left in place. I moved the localization messages into a new localizer.properties file at the correct location.&lt;/p&gt;

&lt;p&gt;4. I took over the improved message for no-nullable-fk, which is now thown as a UserException, see above. I also improved the assertion messages.&lt;/p&gt;

&lt;p&gt;Question: Shall the assertion messages be localized at all?&lt;/p&gt;</comment>
                            <comment id="12513139" author="clr" created="Tue, 17 Jul 2007 04:24:47 +0100"  >&lt;p&gt;Hi Markus,&lt;/p&gt;

&lt;p&gt;The assertion changes look good. &lt;/p&gt;

&lt;p&gt;It&apos;s probably best to localize the assertion messages just due to our international developer team. It&apos;s not strictly required but nice to have.&lt;/p&gt;</comment>
                            <comment id="12513396" author="clr" created="Wed, 18 Jul 2007 00:58:44 +0100"  >&lt;p&gt;I tested this patch by running the mvn install command and no errors were reported. &lt;br/&gt;
Markus ran the TCK and no errors were reported.&lt;/p&gt;

&lt;p&gt;svn commit -m &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-235&quot; title=&quot;SQL reordering to avoid non-nullable foreign key constraint violations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-235&quot;&gt;&lt;del&gt;OPENJPA-235&lt;/del&gt;&lt;/a&gt; break-nullable-patch contributed by Markus Fuchs&quot;&lt;br/&gt;
Sending        openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java&lt;br/&gt;
Sending        openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java&lt;br/&gt;
Sending        openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties&lt;br/&gt;
Sending        openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java&lt;br/&gt;
Sending        openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java&lt;br/&gt;
Adding         openjpa-lib/src/main/resources/org/apache/openjpa/lib/graph&lt;br/&gt;
Adding         openjpa-lib/src/main/resources/org/apache/openjpa/lib/graph/localizer.properties&lt;br/&gt;
Sending        openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java&lt;br/&gt;
Sending        openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java&lt;br/&gt;
Sending        openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java&lt;br/&gt;
Sending        openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java&lt;br/&gt;
Adding         openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityE.java&lt;br/&gt;
Sending        openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java&lt;br/&gt;
Transmitting file data ............&lt;br/&gt;
Committed revision 557089.&lt;/p&gt;</comment>
                            <comment id="12516114" author="rgarret" created="Sat, 28 Jul 2007 00:26:46 +0100"  >&lt;p&gt;Markus,&lt;/p&gt;

&lt;p&gt;Your work on circular dependencies looks great, thanks for taking the time to do that! I was wondering if you are working on, or planning to working on, dependencies based on unique key constraints?&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12517657" author="m_fuchs" created="Sat, 4 Aug 2007 00:21:21 +0100"  >&lt;p&gt;Reece,&lt;/p&gt;

&lt;p&gt;I was quite busy this week, but I will start on addressing unique constraint dependencies next week. Sorry for the late reply!&lt;/p&gt;

&lt;p&gt;&amp;#8211; markus.&lt;/p&gt;</comment>
                            <comment id="12517670" author="rgarret" created="Sat, 4 Aug 2007 01:16:38 +0100"  >&lt;p&gt;Markus,&lt;/p&gt;

&lt;p&gt;That&apos;s great news. No worries about late replies; I know exactly what you mean about being busy. I&apos;m just grateful to have you working on this. The project I&apos;m on has a growing number of uniques in the database schema and I cringe at the thought of having to write app-level business rules to deal with them. I wish all DBMS would support deferred constraints!&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12523052" author="rgarret" created="Mon, 27 Aug 2007 18:05:02 +0100"  >&lt;p&gt;Hey Markus,&lt;/p&gt;

&lt;p&gt;Have you had time to make any progress on this? I know you guys have been busy.&lt;/p&gt;

&lt;p&gt;-Reece&lt;/p&gt;</comment>
                            <comment id="12575537" author="rogerkeays" created="Thu, 6 Mar 2008 02:15:20 +0000"  >&lt;p&gt;As discussed on openjpa-users, the ConstraintUpdateManager breaks recursive delete operations where ON DELETE CASCADE foreign key actions are used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nabble.com/ON-DELETE-CASCADE-causes-OptimisticLockingException-td14308483.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/ON-DELETE-CASCADE-causes-OptimisticLockingException-td14308483.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The old OperationOrderUpdateManager doesn&apos;t have this problem.&lt;/p&gt;</comment>
                            <comment id="12602346" author="faywang" created="Wed, 4 Jun 2008 17:48:31 +0100"  >&lt;p&gt;I did some investigation about the OptimisticLock exception where ConstraintUpdateManager is used when entity A is deleted: &lt;/p&gt;

&lt;p&gt;@Entity A &lt;/p&gt;
{
  @OneToMany(cascade=CascadeType.ALL, mappedBy=&quot;a&quot;)
  List b;
}

&lt;p&gt;@Entity B &lt;/p&gt;
{
  @ForeignKey(deleteAction=ForeignKeyAction.CASCADE)
  @ManyToOne(cascade=CascadeType.MERGE)
  A a;
}

&lt;p&gt;It is found that if the foreign key delete action is set to &quot;on delete restrict&quot;, the deletion of A is fine without OptimisticLock exception. It turns out that&lt;br/&gt;
ConstraintUpdateManager only re-order the deletions of  entities for foreign key on delete restrict such that the child rows (entity B) are deleted first before the parent rows (entity A) are deleted. This re-ordering should also be applied to foreign key on delete cascade. &lt;br/&gt;
With foreign key on delete cascade, if the parent row is deleted first, the child rows will be deleted automatically by the database, resulting in&lt;br/&gt;
OptimiticLock exception (b/c the child rows (entity B)  are no longer there when openjpa tries to delete them.) &lt;/p&gt;

&lt;p&gt;The attached patch adds support for foreign key on delete cascade so that the ConstraintUpdateManager will re-order the deletions of entities to prevent  OptimiticLock exception.&lt;/p&gt;</comment>
                            <comment id="12602467" author="faywang" created="Wed, 4 Jun 2008 22:44:46 +0100"  >&lt;p&gt;This patch fixed a typo in the comments and also includes a test case.&lt;/p&gt;</comment>
                            <comment id="12603079" author="bogdan.stroe" created="Fri, 6 Jun 2008 16:38:56 +0100"  >&lt;p&gt;Actually it doesn&apos;t matter if the foreign key is nullable or not. I have the same problem even on a nullable foreign key: it gets an id for the second entity from the sequence and then it tries to insert that id as a foreign key before inserting in the other (parent) table. So you get a &quot;parent key not found&quot; error.&lt;/p&gt;</comment>
                            <comment id="12603082" author="faywang" created="Fri, 6 Jun 2008 16:45:27 +0100"  >&lt;p&gt;Bogdan, the problem you described appears to be an insert problem. Do you have a test case it? &lt;/p&gt;</comment>
                            <comment id="12609492" author="rogerkeays" created="Tue, 1 Jul 2008 09:40:11 +0100"  >&lt;p&gt;Hi Fay, unfortunately your patch doesn&apos;t seem to work for me. However, as you discovered it seems that using RESTRICT in the annotations &lt;b&gt;does&lt;/b&gt; work around the problem. This appears to work even if the actual database constraints are set to CASCADE.&lt;/p&gt;</comment>
                            <comment id="12609625" author="faywang" created="Tue, 1 Jul 2008 16:47:43 +0100"  >&lt;p&gt;Hi Roger, my patch includes a test case to test deletion for foreign key on delete cascade. This test case will not work without the patch. Since yours still does not work, can you provide me your test case or let me know the difference between your test case and mine for further investigation? Thanks!&lt;/p&gt;</comment>
                            <comment id="12610463" author="rogerkeays" created="Fri, 4 Jul 2008 07:38:26 +0100"  >&lt;p&gt;Hi Fay, Your patch does actually work for me. I just needed to clean and rebuild. Thanks for that, I was tearing my hair out. Will we see the patch applied for 1.1.1?&lt;/p&gt;</comment>
                            <comment id="12614343" author="bogdan.stroe" created="Thu, 17 Jul 2008 15:06:31 +0100"  >&lt;p&gt;Fay, I downloaded one of the existing test cases and I will prepare a similar one for my problem.&lt;/p&gt;</comment>
                            <comment id="12618425" author="mikedd" created="Wed, 30 Jul 2008 17:34:43 +0100"  >&lt;p&gt;Is there more work to be done here, or can we consider the issue resolved? &lt;/p&gt;</comment>
                            <comment id="12618726" author="mikedd" created="Thu, 31 Jul 2008 16:38:45 +0100"  >&lt;p&gt;I believe this issue is resolved. If there are other cases which need addressing please open a separate JIRA or a subtask. &lt;/p&gt;</comment>
                            <comment id="12740745" author="dezzio" created="Fri, 7 Aug 2009 22:19:43 +0100"  >&lt;p&gt;Merged fix to 1.1.x branch at 802195 from trunk.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12371165">OPENJPA-253</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12365447">OPENJPA-177</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12358589" name="merge-detached.patch" size="781" author="gergul" created="Thu, 31 May 2007 07:00:25 +0100"/>
                            <attachment id="12360321" name="merge-testcases.patch" size="18402" author="gergul" created="Thu, 21 Jun 2007 21:20:11 +0100"/>
                            <attachment id="12361938" name="openjpa-235-break-nullable-070716.patch" size="43694" author="m_fuchs" created="Tue, 17 Jul 2007 02:06:03 +0100"/>
                            <attachment id="12361530" name="openjpa-235-break-nullable.patch" size="41005" author="m_fuchs" created="Tue, 10 Jul 2007 22:45:35 +0100"/>
                            <attachment id="12383416" name="openjpa-235-delete-cascade.patch" size="9172" author="faywang" created="Wed, 4 Jun 2008 22:44:46 +0100"/>
                            <attachment id="12358172" name="openjpa-235-test.jar" size="8185" author="m_fuchs" created="Fri, 25 May 2007 00:26:04 +0100"/>
                            <attachment id="12358293" name="openjpa-235-test1.jar" size="8142" author="m_fuchs" created="Sat, 26 May 2007 01:53:24 +0100"/>
                            <attachment id="12359131" name="openjpa-235-test2.zip" size="6316" author="m_fuchs" created="Thu, 7 Jun 2007 01:12:24 +0100"/>
                            <attachment id="12383397" name="openjpa.patch" size="2437" author="faywang" created="Wed, 4 Jun 2008 17:49:30 +0100"/>
                            <attachment id="12383396" name="openjpa.patch" size="2437" author="faywang" created="Wed, 4 Jun 2008 17:48:31 +0100"/>
                            <attachment id="12358573" name="sqlReorder2.patch" size="33255" author="rgarret" created="Wed, 30 May 2007 21:41:26 +0100"/>
                            <attachment id="12359216" name="sqlReorderTests.patch" size="11745" author="rgarret" created="Thu, 7 Jun 2007 22:32:36 +0100"/>
                            <attachment id="12356797" name="sqlreorder.patch" size="21952" author="rgarret" created="Fri, 4 May 2007 19:25:41 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>13.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 18 May 2007 23:22:04 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160566</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hysw67:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>202560</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>