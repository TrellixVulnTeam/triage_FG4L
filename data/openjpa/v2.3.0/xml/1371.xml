<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:30:54 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-1371/OPENJPA-1371.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-1371] Insert is called instead of Update when merge() with derived Identity</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-1371</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Insert is called instead of Update when merge() with derived Identity:&lt;/p&gt;</description>
                <environment></environment>
        <key id="12439580">OPENJPA-1371</key>
            <summary>Insert is called instead of Update when merge() with derived Identity</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="faywang">Fay Wang</reporter>
                        <labels>
                    </labels>
                <created>Fri, 30 Oct 2009 22:51:47 +0000</created>
                <updated>Thu, 22 Apr 2010 21:33:00 +0100</updated>
                            <resolved>Wed, 24 Mar 2010 17:47:55 +0000</resolved>
                                    <version>2.0.0-M3</version>
                                    <fixVersion>2.0.0-M3</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12772179" author="faywang" created="Fri, 30 Oct 2009 23:36:57 +0000"  >&lt;p&gt;The following test scenario is provided by Constantine Kulak &amp;lt;code@mail.by&amp;gt;:&lt;/p&gt;

&lt;p&gt;There are three entities where PrognosisEntry has derived identity:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;Source for Prognosis.java:&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; @Entity(name = &quot;Prognosis&quot;)&lt;br/&gt;
 @Table(name = &quot;PROGNOSIS&quot;)&lt;br/&gt;
 @IdClass(Prognosis.PrognosisId.class)&lt;br/&gt;
 @Inheritance(strategy = InheritanceType.JOINED)&lt;br/&gt;
 public class Prognosis {&lt;/p&gt;

&lt;p&gt;     protected List&amp;lt;PrognosisEntry&amp;gt; entries;&lt;br/&gt;
    protected String station;&lt;br/&gt;
    protected String type;&lt;/p&gt;

&lt;p&gt;    @OneToMany(targetEntity = PrognosisEntry.class, cascade = &lt;/p&gt;
{CascadeType.MERGE}
&lt;p&gt;, mappedBy=&quot;prognosis&quot;, fetch=FetchType.EAGER)&lt;br/&gt;
    public List&amp;lt;PrognosisEntry&amp;gt; getEntries() {&lt;br/&gt;
        if (entries == null) &lt;/p&gt;
{
            entries = new ArrayList&amp;lt;PrognosisEntry&amp;gt;();
        }
&lt;p&gt;        return this.entries;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;    public void setEntries(List&amp;lt;PrognosisEntry&amp;gt; entries) &lt;/p&gt;
{
        this.entries = entries;
    }

&lt;p&gt;    @Id&lt;br/&gt;
    @Column(name = &quot;STATION&quot;)&lt;br/&gt;
    public String getStation() &lt;/p&gt;
{
        return station;
    }

&lt;p&gt;    public void setStation(String value) &lt;/p&gt;
{
        this.station = value;
    }

&lt;p&gt;    @Id&lt;br/&gt;
    @Column(name = &quot;TYPE_&quot;)&lt;br/&gt;
    public String getType() &lt;/p&gt;
{
        return type;
    }

&lt;p&gt;    public void setType(String value) &lt;/p&gt;
{
        this.type = value;
    }

&lt;p&gt;    public boolean equals(Object object) &lt;/p&gt;
{ ... }&lt;br/&gt;
    public int hashCode() { ... }

&lt;p&gt;    public static class PrognosisId {&lt;br/&gt;
        protected String station;&lt;br/&gt;
        protected String type;&lt;/p&gt;

&lt;p&gt;        public String getStation() &lt;/p&gt;
{
            return station;
        }

&lt;p&gt;        public void setStation(String value) &lt;/p&gt;
{
            this.station = value;
        }

&lt;p&gt;        public String getType() &lt;/p&gt;
{
            return type;
        }

&lt;p&gt;        public void setType(String value) &lt;/p&gt;
{
            this.type = value;
        }

&lt;p&gt;          public boolean equals(Object object) &lt;/p&gt;
{ ... }&lt;br/&gt;
        public int hashCode() { ... }
&lt;p&gt;    }&lt;br/&gt;
 }&lt;/p&gt;


&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;Source for PrognosisEntry.java:&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; @Entity(name = &quot;PrognosisEntry&quot;)&lt;br/&gt;
 @Table(name = &quot;PROGNOSISENTRY&quot;)&lt;br/&gt;
 @Inheritance(strategy = InheritanceType.JOINED)&lt;br/&gt;
 @IdClass(PrognosisEntry.PrognosisEntryId.class)&lt;br/&gt;
 public class PrognosisEntry {&lt;/p&gt;

&lt;p&gt;    protected String timestamp;&lt;br/&gt;
    protected String localState;&lt;br/&gt;
    protected Prognosis prognosis;&lt;/p&gt;

&lt;p&gt;    protected Stock stock;&lt;/p&gt;

&lt;p&gt;    @Id&lt;br/&gt;
    @ManyToOne(targetEntity = Stock.class, cascade = &lt;/p&gt;
{ CascadeType.MERGE }, fetch = FetchType.EAGER)&lt;br/&gt;
    public Stock getStock() {
        return stock;
    }&lt;br/&gt;
&lt;br/&gt;
    public void setStock(Stock stock) {
        this.stock = stock;
    }&lt;br/&gt;
&lt;br/&gt;
    @Id&lt;br/&gt;
    @ManyToOne(targetEntity = Prognosis.class, cascade = { CascadeType.MERGE }
&lt;p&gt;, fetch = FetchType.EAGER)&lt;br/&gt;
    public Prognosis getPrognosis() &lt;/p&gt;
{
        return prognosis;
    }

&lt;p&gt;    public void setPrognosis(Prognosis prognosis) &lt;/p&gt;
{
        this.prognosis = prognosis;
    }

&lt;p&gt;    @Column(name = &quot;TIMESTAMP_&quot;, length = 255)&lt;br/&gt;
    public String getTimestamp() &lt;/p&gt;
{
        return timestamp;
    }

&lt;p&gt;    public void setTimestamp(String value) &lt;/p&gt;
{
        this.timestamp = value;
    }

&lt;p&gt;    @Basic&lt;br/&gt;
    @Column(name = &quot;LOCALSTATE&quot;, length = 255)&lt;br/&gt;
    public String getLocalState() &lt;/p&gt;
{
        return localState;
    }

&lt;p&gt;    public void setLocalState(String value) &lt;/p&gt;
{
        this.localState = value;
    }

&lt;p&gt;    public boolean equals(Object object) &lt;/p&gt;
{ ... }&lt;br/&gt;
    public int hashCode() { ... }

&lt;p&gt;    public static class PrognosisEntryId {&lt;/p&gt;

&lt;p&gt;        protected Prognosis.PrognosisId prognosis;&lt;br/&gt;
        protected String stock;&lt;/p&gt;

&lt;p&gt;        public String getStock() &lt;/p&gt;
{
            return stock;
        }

&lt;p&gt;        public void setStock(String stock) &lt;/p&gt;
{
            this.stock = stock;
        }

&lt;p&gt;        public Prognosis.PrognosisId getPrognosis() &lt;/p&gt;
{
            return prognosis;
        }

&lt;p&gt;        public void setPrognosis(Prognosis.PrognosisId prognosis) &lt;/p&gt;
{
            this.prognosis = prognosis;
        }

&lt;p&gt;        public boolean equals(Object object) &lt;/p&gt;
{ ... }&lt;br/&gt;
        public int hashCode() { ... }
&lt;p&gt;    }&lt;br/&gt;
 }&lt;/p&gt;


&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;
		&lt;ul&gt;
			&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;
				&lt;ul&gt;
					&lt;li&gt;Source for Stock.java:&lt;/li&gt;
				&lt;/ul&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; @Entity(name = &quot;Stock&quot;)&lt;br/&gt;
 @Table(name = &quot;STOCK&quot;)&lt;br/&gt;
 @Inheritance(strategy = InheritanceType.JOINED)&lt;br/&gt;
 public class Stock {&lt;br/&gt;
    protected String index;&lt;br/&gt;
    protected String length;&lt;/p&gt;

&lt;p&gt;    @Id&lt;br/&gt;
    @Column(name = &quot;INDEX_&quot;)&lt;br/&gt;
    public String getIndex() &lt;/p&gt;
{
        return index;
    }

&lt;p&gt;    public void setIndex(String value) &lt;/p&gt;
{
        this.index = value;
    }
&lt;p&gt;      @Basic&lt;br/&gt;
    @Column(name = &quot;LENGTH_&quot;, length = 255)&lt;br/&gt;
    public String getLength() &lt;/p&gt;
{
        return length;
    }

&lt;p&gt;    public void setLength(String value) &lt;/p&gt;
{
        this.length = value;
    }

&lt;p&gt;    public boolean equals(Object object) &lt;/p&gt;
{ ... }&lt;br/&gt;
    public int hashCode() { ... }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;The test scenario: &lt;br/&gt;
(1) create a Prognosis entity with a list of PrognosisEntry.&lt;br/&gt;
(2) call em.merge(newEntity) and commit&lt;br/&gt;
(3) call em.clear()&lt;br/&gt;
(4) call em.merge(newEntity)&lt;/p&gt;

&lt;p&gt;Step (4) generate insert statement to insert PrognosisEntry again, resulting in unique constraint violation from the database.&lt;/p&gt;

&lt;p&gt;It appears that the ApplicationIds.create(pc, meta) where pc is PrognosisEntry, the oid does not have complete id values.&lt;/p&gt;








</comment>
                            <comment id="12772296" author="faywang" created="Sun, 1 Nov 2009 00:43:56 +0000"  >&lt;p&gt;During merge, openjpa needs to retrieve id from the entity to decide whether this is a new entity or a detached one. If it thinks it is a new entity, an INSERT will be perform. Otherwise, an Update statement will be executed. &lt;br/&gt;
If  (1) an entity has the compound primary key using IdClass, and &lt;br/&gt;
    (2) some field in the IdClass is a derived identity from a OneToOne/ManyToOne field,&lt;br/&gt;
    (3) that value in that field has not yet become managed (i.e., does not have the StateManagerImpl yet),&lt;br/&gt;
this field in the IdClass will not be populated, as the primary key of the OneToOne/ManyToOne field usually can not be fetched back without an associated StateManagerImpl, unless it has a single-value primary key. &lt;/p&gt;

&lt;p&gt;Currently openjpa returns the null value for this field in the IdClass regardlessly in the above situation.  The patch provides a relief when this derived identity-relation field has a single value primary key. It should fix the problem reported by Constantine. However, the limitation for nested/multi-level compound primary (e.g. Stock entity has compound primary key using IdClass, and some value in the idClass is a derived-identity relation field, ...) during merge remains.   &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>161640</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt2db:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203564</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>