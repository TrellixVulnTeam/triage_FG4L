<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:36:21 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-407/OPENJPA-407.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-407] Cache SQL (or closer precursors to SQL) more aggressively</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-407</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;When data is not available in the data cache, OpenJPA dynamically creates SQL to look up the requested data. OpenJPA should more aggressively cache this SQL to accelerate pathways from a cache miss to the database.&lt;/p&gt;

&lt;p&gt;The generated SQL takes a number of factors into account, including the requested records, transaction status, currently-loaded data, and the current fetch configuration. Any caching would need to account for these factors as well.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12380622">OPENJPA-407</key>
            <summary>Cache SQL (or closer precursors to SQL) more aggressively</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="faywang">Fay Wang</assignee>
                                    <reporter username="pcl">Patrick Linskey</reporter>
                        <labels>
                    </labels>
                <created>Wed, 17 Oct 2007 18:49:51 +0100</created>
                <updated>Tue, 7 Feb 2012 19:18:52 +0000</updated>
                            <resolved>Tue, 15 Jul 2008 20:36:15 +0100</resolved>
                                    <version>0.9.0</version>
                    <version>0.9.6</version>
                    <version>0.9.7</version>
                    <version>1.0.0</version>
                    <version>1.0.1</version>
                    <version>1.0.2</version>
                    <version>1.0.3</version>
                    <version>1.0.4</version>
                    <version>1.1.0</version>
                    <version>1.1.1</version>
                                    <fixVersion>1.2.0</fixVersion>
                                    <component>jdbc</component>
                    <component>kernel</component>
                    <component>query</component>
                    <component>sql</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12535677" author="pcl" created="Wed, 17 Oct 2007 20:02:12 +0100"  >&lt;p&gt;This patch seems like it addresses some of the right areas to make improvements on this issue, at least for lookups by id (find() and lazy-loads). It builds a cache of Select instances keyed off of relevant data, and uses this cache in JDBCStoreManager to avoid recreating Select records.&lt;/p&gt;

&lt;p&gt;However, initial testing seems to indicate that there&apos;s actually a performance loss. Additionally, all the OpenJPA tests are passing, but a small number of the TCK tests fail with this change.&lt;/p&gt;</comment>
                            <comment id="12535680" author="pcl" created="Wed, 17 Oct 2007 20:07:30 +0100"  >&lt;p&gt;The attached patch reuses Select instances across all active Brokers from a given BrokerFactory. We need to do more careful analysis to make sure that Select instances are thread-safe once they&apos;ve been created. Adding synchronization to the Select implementations will probably not help, since this would likely add a scalability bottleneck.&lt;/p&gt;</comment>
                            <comment id="12535697" author="kwsutter" created="Wed, 17 Oct 2007 20:49:51 +0100"  >&lt;p&gt;Took a quick look at your patch.  Much more involved than my initial experimentation.  I was actually looking at it from a Query viewpoint and I was thinking of caching the generated sql along with the query compilation cache.  That is, if a specific jpql query was cached after it was parsed and compiled, then couldn&apos;t we tag along the cached generated sql.  As my previous notes on the dev mailing list indicated, we would still have to take into account the variable aspects of the query (parameters, hints, result size, etc).  So, maybe going this route would have hit just as many parts.  But, your patch was much more extensive than I was hoping for.  Guess this shows how tight the sql generation and the &quot;query processing&quot; really is.&lt;/p&gt;

&lt;p&gt;Figuring out where to base the cache was also a question for me.  Like you have found out, if you do it at too high of a level then we&apos;ll hit synchronization issues.  If I put it at too low of a level, then it turned out to be useless.  I was actually thinking of scoping the cache to an EntityManager (broker) instance.  Maybe not as useful as across all active brokers, but we would still gain a sizeable benefit (hopefully).&lt;/p&gt;

&lt;p&gt;Those are my initial thoughts.  To be honest, I haven&apos;t completely grasped your proposed changes, so I don&apos;t have any specific comments on your changes yet...&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12535750" author="pcl" created="Wed, 17 Oct 2007 22:19:46 +0100"  >&lt;p&gt;The Select interface and its implementations are responsible for both assembling and executing SELECT statements (and, for legacy reasons, some other statement types). So, it seemed as though reusing the Select instances was the right level of abstraction.&lt;/p&gt;

&lt;p&gt;My change actually isn&apos;t all that involved; it&apos;s mostly just a refactoring, and not much new code. The refactoring was necessary because a bunch of things involved in SQL generation examined a StateManager directly, and so to properly build a key for the Select, I needed to include all those bits of information. I could have actually left most of the classes alone and just made the key account for those bits of information, but I decided that that approach would be error-prone, both up-front (what if I missed some state manager interrogation?) and moving forward (what if the downstream methods started grabbing more data from the state manager?).&lt;/p&gt;

&lt;p&gt;Additionally, my change does not currently actually cache the SQLBuffers generated within the SelectImpls. It is possible that this is why there is no performance gain. The performance loss in our tests might be attributable to the extra overhead of always computing all the data needed for the SelectKey even if it&apos;s not needed in the end.&lt;/p&gt;

&lt;p&gt;Also, note that my changes right now only are used when loading a single instance, not when executing a Query. I expect that the techniques and implementation could be broadened to JPQL cases as well, but I didn&apos;t really look at that use case, since the problem description seemed to be identifying relation traversals and finds as the problems.&lt;/p&gt;

&lt;p&gt;&amp;gt; I was actually thinking of scoping the cache to an EntityManager (broker) &lt;br/&gt;
&amp;gt; instance. Maybe not as useful as across all active brokers, but we would &lt;br/&gt;
&amp;gt; still gain a sizeable benefit (hopefully).&lt;/p&gt;

&lt;p&gt;I think that the deciding factor for this will be whether or not there is any Broker-specific state that must be involved in the caches.&lt;/p&gt;</comment>
                            <comment id="12535763" author="pcl" created="Wed, 17 Oct 2007 23:11:08 +0100"  >&lt;p&gt;I just prototyped caching SQLBuffers inside SelectImpl.execute(), and am now seeing relatively significant speedups. It&apos;s probably still worth looking into why things slowed down without that extra level of caching (there might be some more gains to be had there), but I&apos;ll explore that direction a bit more later this week.&lt;/p&gt;</comment>
                            <comment id="12535765" author="pcl" created="Wed, 17 Oct 2007 23:14:58 +0100"  >&lt;p&gt;In case you&apos;re interested, my numbers are based on running the full OpenJPA test suite on the same hardware, with and without the changes. Without them (clean trunk build), the JDBC tests take around 7.5 minutes, and I just got a run in 5.5 minutes with the attached patch + my SQLBuffer prototype.&lt;/p&gt;

&lt;p&gt;This is a significant speedup, especially considering that our tests generally probably don&apos;t reuse statements as much as the average database application, since we generate a lot of different SQL and don&apos;t generally do the same thing too many times.&lt;/p&gt;</comment>
                            <comment id="12535767" author="kwsutter" created="Wed, 17 Oct 2007 23:23:26 +0100"  >&lt;p&gt;Wow!  That does sound significant.  So, what were the SQLBuffer enhancements?  And, would those changes be sufficient?  Or, are they dependent on the other changes in your original patch?&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12535776" author="pcl" created="Wed, 17 Oct 2007 23:53:37 +0100"  >&lt;p&gt;The change was trivial: I changed the &apos;sql&apos; local variable in SelectImpl.execute() to be a member variable, and added a null check to control whether or not to go to the DBDictionary to create a new one.&lt;/p&gt;

&lt;p&gt;This depends on the original patch; the original patch lets us cache SelectImpls. Without that patch, the SQLBuffer would always be uninitialized anyways.&lt;/p&gt;

&lt;p&gt;I don&apos;t think that the lack of thread-safety in my prototype is an issue, since in the worst case, we just end up over-creating SQLBuffers. However, I am concerned about the fact that I&apos;m ignoring the forUpdate and fetch parameters that are passed to execute(). I think that it might be ok to ignore fetch, since I think it&apos;s the same as the one that was used to create the SelectImpl, and is just being passed through for use by the DBDictionary. But I need to look at that more closely, and also do the same analysis for the forUpdate statement.&lt;/p&gt;

&lt;p&gt;But first I want to reproduce the numbers that I was seeing, to make sure that this is a worthwhile avenue.&lt;/p&gt;</comment>
                            <comment id="12535777" author="pcl" created="Thu, 18 Oct 2007 00:03:43 +0100"  >&lt;p&gt;I&apos;m having a hard time reproducing both the 7.5 and the 5.5 numbers; I&apos;m seeing numbers around 9 minutes for both clean trunk and my patch + prototype. The new stuff seems to be running a small amount faster, but not as much as I saw before. Odd.&lt;/p&gt;

&lt;p&gt;It is probably worthwhile to create a microbenchmark that exercises these pathways and try it out with that directly, instead of trying to infer something from our existing test execution speed.&lt;/p&gt;</comment>
                            <comment id="12535782" author="ppoddar@apache.org" created="Thu, 18 Oct 2007 00:23:38 +0100"  >&lt;p&gt;&amp;gt; I think that it might be ok to ignore fetch, since I think it&apos;s the same as the one that was used to create the SelectImpl&lt;br/&gt;
Did not see the patch but a point comment is FetchConfiguration in constructing a Select starts from a &apos;root&apos; instance and then spawns other FetchConfiguration instances as it traverses the fetch graph. But the spawned as well as the root instance shares the same &apos;state&apos; (ConfigurationState). They only differ by &apos;dynamic&apos; state that tracks the current location in fetch graph traversal. Effectively the shared root instances would be identify a fetch configuration if one is considering to use it as a part of a lookup key.      &lt;/p&gt;</comment>
                            <comment id="12564210" author="kwsutter" created="Wed, 30 Jan 2008 23:00:32 +0000"  >&lt;p&gt;Instead of trying to resolve the whole sql caching problem, how about if we just start with caching the SQL for the findBy operation?  Each Entity type has a unique SelectImpl and SQLBuffer associated with processing a find(class, id) operation, right?  So, why not cache these results so that they can be re-used the next time the find operation is invoked?&lt;/p&gt;

&lt;p&gt;Looking back at Patrick&apos;s first patch for this issue, it looks like a few of the original ideas are duplicated in my patch.  I am making the assumption that the EntityManager (and the associated JDBCStoreManager) is single-threaded.  I am also making the assumption that the find method (and only the find method) utilizes the getInitializeStateResult() on the JDBCStoreManager.  &lt;/p&gt;

&lt;p&gt;This is still a prototype at this point, but I would like to get some input as to the direction.  The initial results look very promising.  I&apos;ve driven it with many clients with the findBy&apos;s performance increasing anywhere from 5-20% depending on the number of clients and machine capacity.  Of course, this is limited to findBy&apos;s at this point, but if the general direction is okay, maybe we can extend it to more general queries.&lt;/p&gt;

&lt;p&gt;Just looking for input at this point.  BTW, my findBy.patch file works with the 1.0.x branch.  Still hoping we can improve the performance of the service stream....&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12564241" author="pcl" created="Thu, 31 Jan 2008 00:34:46 +0000"  >&lt;p&gt;I haven&apos;t read the patch yet; I&apos;ll take a look at it later this week. However, without having looked at it, I&apos;m hesitant about putting something like this into the 1.0.x branch, as it seems like it&apos;s probably a decently-large behavioral change, and thus likely to introduce instability. I&apos;d prefer if we tried to keep our maintenance branch changes confined to bugfixes. Of course, performance issues tend to be hard to classify concretely as bugs vs. new features.&lt;/p&gt;</comment>
                            <comment id="12564339" author="christiaan" created="Thu, 31 Jan 2008 08:53:14 +0000"  >&lt;p&gt;I making this remark since I was triggered by the &quot;I changed the &apos;sql&apos; local variable in SelectImpl.execute() to be a member variable&quot;. I&apos;ve seen a similar approach in RowImpl and as described in &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-474&quot; title=&quot;Memory overhead by openjpa&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-474&quot;&gt;OPENJPA-474&lt;/a&gt;, I think this causes a lot of memory overhead when a many similar objects and modifications are involved, since the same sql is duplicated. Of course it is a good thing to cache for performance, but I do think a cache should use memory if it is available (not leading to an OoM) or at least try to keep it to a minimum. Not sure if it is the case with this patch, I just thought of making you aware of it.&lt;/p&gt;

&lt;p&gt;regards,&lt;br/&gt;
Christiaan&lt;/p&gt;</comment>
                            <comment id="12564820" author="pcl" created="Fri, 1 Feb 2008 16:35:58 +0000"  >&lt;p&gt;Generally, the patch looks sound. I agree with Christiaan&apos;s concerns; we should probably change the caches to be configurable data structures. &lt;/p&gt;

&lt;p&gt;I think that from a data structure standpoint, I would prefer something like the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;JDBCStoreManager has a private configurable Map&amp;lt;ClassMapping,SelectImpl&amp;gt;. This might be a non-LRU CacheMap, and the configuration for it should be exposed via a JDBCConfiguration setting.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The Map&amp;lt;SelectImpl,SQLBuffer&amp;gt; is moved into SelectImpl itself, obviating the need for the second public map.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We have not yet run the patch against our internal performance tests; I&apos;d like to hold off on that until we get the data structures finalized. (The requisite configuration changes can be done afterwards; they shouldn&apos;t impact runtime performance behavior.)&lt;/p&gt;</comment>
                            <comment id="12564824" author="kwsutter" created="Fri, 1 Feb 2008 16:52:53 +0000"  >&lt;p&gt;Thanks, Patrick, for the review.  We are also performing some internal performance tests.  We&apos;ll let the team know how they go shortly...  We&apos;re also looking at other related improvements to this findBy path.  We&apos;ll post a more complete patch in the near future.&lt;/p&gt;

&lt;p&gt;&amp;gt; Generally, the patch looks sound. I agree with Christiaan&apos;s concerns; we should probably change the caches to be configurable data structures.&lt;/p&gt;

&lt;p&gt;I&apos;m not convinced that a configurable data structure is necessary.  We want the performance of OpenJPA to be excellent &quot;out of the box&quot;.  We made a similar decision when we decided to turn the Compilation Cache on by default.  Maybe that&apos;s what you mean...  Make it configurable, but we can have it turned on by default?  If that&apos;s the case, then I&apos;m okay with that approach.&lt;/p&gt;

&lt;p&gt;&amp;gt;  - JDBCStoreManager has a private configurable Map&amp;lt;ClassMapping,SelectImpl&amp;gt;. This might be a non-LRU CacheMap, and the configuration for it should be exposed via a JDBCConfiguration setting.&lt;/p&gt;

&lt;p&gt;See above comments.&lt;/p&gt;

&lt;p&gt;&amp;gt;  - The Map&amp;lt;SelectImpl,SQLBuffer&amp;gt; is moved into SelectImpl itself, obviating the need for the second public map.&lt;/p&gt;

&lt;p&gt;Yep, already figured that one out.  Thanks.&lt;/p&gt;

&lt;p&gt;Thanks again,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12564920" author="pcl" created="Fri, 1 Feb 2008 20:17:31 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; Generally, the patch looks sound. I agree with Christiaan&apos;s concerns; we should probably&lt;br/&gt;
&amp;gt; &amp;gt; change the caches to be configurable data structures.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;m not convinced that a configurable data structure is necessary. We want the performance&lt;br/&gt;
&amp;gt; of OpenJPA to be excellent &quot;out of the box&quot;. We made a similar decision when we decided to&lt;br/&gt;
&amp;gt; turn the Compilation Cache on by default. Maybe that&apos;s what you mean... Make it configurable,&lt;br/&gt;
&amp;gt; but we can have it turned on by default? If that&apos;s the case, then I&apos;m okay with that approach.&lt;/p&gt;

&lt;p&gt;Yep. This definitely seems like the sort of thing that should be on by default, with a reasonable default hard ref size and a soft ref spillover.&lt;/p&gt;

&lt;p&gt;&amp;gt; We&apos;ll post a more complete patch in the near future.&lt;/p&gt;

&lt;p&gt;Excellent... I&apos;m looking forward to reading more.&lt;/p&gt;</comment>
                            <comment id="12582688" author="kwsutter" created="Thu, 27 Mar 2008 15:26:22 +0000"  >&lt;p&gt;Attaching a new version of the first patch for this Issue.  All of the stated comments about the first patch have been addressed.  But, this is not the &quot;final&quot; patch.  There are still some areas that could use some improvement, but I wanted to get the basic updates in place so that we can move forward.  Also, by getting these into trunk, we can wring out any potential problems.&lt;/p&gt;

&lt;p&gt;This patch introduces a property (modeled after the QueryCompilationCache property):&lt;/p&gt;

&lt;p&gt;openjpa.jdbc.QuerySQLCache&lt;br/&gt;
o  true - uses CacheMap (default)&lt;br/&gt;
o  all - uses a ConcurrentHashMap&lt;br/&gt;
o  false - none&lt;/p&gt;

&lt;p&gt;As before, this improvement attempts to cache the SelectImpls and associated SQLBuffers for common findBy operations.  The cache is scoped to an EntityManager instance.&lt;/p&gt;

&lt;p&gt;The patch also includes new trace messages for cache hits and misses.&lt;/p&gt;

&lt;p&gt;Any comments would be appreciated.  Like I mentioned, I would like to integrate this much of the patch soon since this is not a full-time Issue for me and it&apos;s a pain to continually update my environment.  If we&apos;re generally okay with the approach, then I&apos;d like to commit and then move on to the next level of SQL generation caching.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12591820" author="kwsutter" created="Wed, 23 Apr 2008 23:10:00 +0100"  >&lt;p&gt;Although the previously posted patch helped with performance on an individual EM basis, that was not sufficient when we pushed it through more scalable tests.  So, the patch has been re-worked to cache across EMs.  The basic concept is the same, but now the cache is longer lived and provides scalable performance improvements.&lt;/p&gt;

&lt;p&gt;As soon as the testcases and doc updates are done, the new patch will be posted for comments.  Hopefully, this version can be committed in the near future.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12592153" author="techhusky" created="Thu, 24 Apr 2008 20:14:33 +0100"  >&lt;p&gt;Attaching the patch Kevin referred to in his previous post.  The patch contains code updates, testcases, and OpenJPA documentation for a new QuerySQLCache property.  This property provides configurable EMF-scope caching of select statements employed by the find operation.&lt;/p&gt;

&lt;p&gt;Fay Wang (another OpenJPA contributor), in addition to making a large contribution to the code, wrote the bulk of the extra documentation (QuerySQLCache.doc) to go along with this patch.  It explains the performance issue and how it is addressed by this update.&lt;/p&gt;

&lt;p&gt;The patch also contains a couple miscellanous updates (most notably a change in FetchConfigurationImpl to eliminate hash queries for known values) that were flagged as target areas by a code profiler.&lt;/p&gt;

&lt;p&gt;Please review the patch and post comments. &lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Jeremy&lt;/p&gt;</comment>
                            <comment id="12592154" author="techhusky" created="Thu, 24 Apr 2008 20:15:29 +0100"  >&lt;p&gt;Attaching patch&lt;/p&gt;</comment>
                            <comment id="12592155" author="techhusky" created="Thu, 24 Apr 2008 20:16:56 +0100"  >&lt;p&gt;Attaching extra doc&lt;/p&gt;</comment>
                            <comment id="12592708" author="pcl" created="Mon, 28 Apr 2008 01:42:11 +0100"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In FetchConfigurationImpl.clearFetchGroups(), shouldn&apos;t the fetchGroupContainsDefault boolean be set to true, not false? Based on the FetchConfiguration.clearFetchGroups() javadoc, it&apos;s my understanding that after a clear, the default fetch group is active.&lt;/p&gt;</comment>
                            <comment id="12592712" author="pcl" created="Mon, 28 Apr 2008 01:57:16 +0100"  >&lt;p&gt;More comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In JDBCConfigurationImpl: you&apos;ve hard-coded the query sql cache to be a HashMap. Generally, we&apos;ve tried to use the plugin infrastructure to allow people to vary the implementations based on their needs. It looks like you&apos;ve taken this into account in your plugin class, but you never use the newInstance() method of that class, so my read is that the value will always be the hard-coded HashMap.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In JDBCFetchConfigurationImpl.JDBCConfigurationState, is there any reason why equals() and hashCode() for the inner class don&apos;t consider the fetchInnerJoins field? Also, in general, I try to keep the ordering of fields the same between the equals() / hashCode() block and the declarations, to make it easier to spot these sorts of differences.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In JDBCFetchConfigurationImpl, it&apos;s surprising that the equals() and hashCode() only consider fetch groups, and not any of the other things in JDBCFetchConfiguration or its superclass. What&apos;s the rationale behind that?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;More comments to come. In general, it looks like a promising approach, but I need to do more reading. Also, I&apos;ve sent off a build with the patch to our performance team to run through some internal tests.&lt;/p&gt;</comment>
                            <comment id="12592845" author="faywang" created="Mon, 28 Apr 2008 17:57:14 +0100"  >&lt;p&gt;Hi Patrick,&lt;/p&gt;

&lt;p&gt;   Thank you for your comments. &lt;br/&gt;
   (1)  regarding the clearFetchGroups, you are right. We will set the fetchGroupContainsDefault to true in this method.&lt;/p&gt;

&lt;p&gt;   (2) The querySQLCacheInstance in JDBCConfigurationImpl is a map of  maps. This map is hard coded as a HashMap, and can be accessed by multiple entity mangers. The key in this map is the class of the context where the SelectImpl is constructed, and the value is either CacheMap or ConcurrentCacheMap, depending on the qerySQLCache configuration plugin. Addmittedly, this usage of PluginValue is somehow different from the conventional usage.&lt;br/&gt;
Currently, the querySQLCacheInstance has three entries: (see the extra doc that we attached earlier). &lt;/p&gt;

&lt;p&gt;key: org.apache.openjpa.jdbc.kernel.JDBCStoreManager	&lt;br/&gt;
value: CacheMap / ConcurrentCacheMap (depending on the plugin value of querySQLCache)&lt;/p&gt;

&lt;p&gt;key: org.apache.openjpa.jdbc.meta.strats.StoreCollectionFieldStrategy	&lt;br/&gt;
value: CacheMap / ConcurrentCacheMap (depending on the plugin value of querySQLCache)&lt;/p&gt;

&lt;p&gt;key: org.apache.openjpa.jdbc.meta.starts.RelationFieldStrategy	&lt;br/&gt;
value: CacheMap / ConcurrentCacheMap (depending on the plugn value of  querySQLCache)&lt;/p&gt;

&lt;p&gt; (3)  Regarding fetchInnerJoin, this field is newly added for JIRA-547, a fix for dynamic query involving inner fetch join.  The addInnerJoinFetch is only called from JDBCStoreQuery. Since the patch we attached is for findBy only, and we want to keep the caculation of hash code as simple as possible., this fetchInnerJoin  is therefore not in the calculation of the hashCode for JDBCFetchConfigurationImpl. Perhaps we need to add a document indicating that the hashCode and equals methods in JDBCFetchConfigurationImpl are used in querySQLCache for findBy operation. Any other usage of hashCode/equals should consider the fetchInnderJoin?&lt;/p&gt;

&lt;p&gt;(4)  As you suggested, we will keep the ordering of  hashcodes and equals the same.&lt;/p&gt;

&lt;p&gt;(5)  In terms of which fields will go into the calcuation of hashcode and equals, we are considering those fields that can be changed at the runtime via FetchPlan, since these will be directly affect the generated sql.  For those which could not be changed at runtime, we are not including them in the hashcode or equals, hoping in doing so, we could minimize the effort in the calculation of cache key. &lt;/p&gt;






</comment>
                            <comment id="12592896" author="pcl" created="Mon, 28 Apr 2008 22:07:16 +0100"  >&lt;p&gt;&amp;gt; Perhaps we need to add a document indicating that the hashCode&lt;br/&gt;
&amp;gt; and equals methods in JDBCFetchConfigurationImpl are used in&lt;br/&gt;
&amp;gt; querySQLCache for findBy operation. &lt;/p&gt;

&lt;p&gt;I&apos;m a bit nervous about having equals() and hashCode() (which are by convention deemed to apply to an entire instance) only be meaningful in certain contexts. I think that it would make more sense to create some sort of inner cache key class whose equals() and hashCode() are custom-designed for the purposes of this cache.&lt;/p&gt;

&lt;p&gt;&amp;gt; Any other usage of hashCode/equals should consider the fetchInnderJoin? &lt;/p&gt;

&lt;p&gt;This change actually interfered with my &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-522&quot; title=&quot;pushFetchGroup(s) and popFetchGroup(s) on OpenJPAEntityManager&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-522&quot;&gt;&lt;del&gt;OPENJPA-522&lt;/del&gt;&lt;/a&gt; fix; I ended up switching to an IdentityHashMap to avoid the issue. At the time, I did not realize that the addition of equals() / hashCode() had caused this. I would not be surprised if there are other places in OpenJPA that implicitly make assumptions about equals() and hashCode() behavior for FetchConfigurations, although I can&apos;t think of any offhand.&lt;/p&gt;

&lt;p&gt;In general, I&apos;m not a huge fan of equals() / hashCode() methods (and especially hashCode()) that change in value over the lifecycle of the object; this tends to make it very hard to put these types into data structures.&lt;/p&gt;

&lt;p&gt;&amp;gt; (5) In terms of which fields will go into the calcuation of hashcode and equals, we are&lt;br/&gt;
&amp;gt; considering those fields that can be changed at the runtime via FetchPlan, since these&lt;br/&gt;
&amp;gt; will be directly affect the generated sql. For those which could not be changed at runtime,&lt;br/&gt;
&amp;gt; we are not including them in the hashcode or equals, hoping in doing so, we could&lt;br/&gt;
&amp;gt; minimize the effort in the calculation of cache key. &lt;/p&gt;

&lt;p&gt;As I mentioned above, this seems fair for the purposes of  a cache key, but not appropriate for the general equals() / hashCode() implementation for the instance.&lt;/p&gt;</comment>
                            <comment id="12592918" author="faywang" created="Mon, 28 Apr 2008 23:40:37 +0100"  >&lt;p&gt;You are right that the equals and hashCode are for general purpose. It is risky to have the special purpose hashCode and equals methods in JDBCFetchConfigurationImpl.  We will move the hashCode and equals from JDBCFetchConfigurationImpl into the SelectKey class to avoid interfering with other usage of hashCode and equals. I will post a patch soon with the changes suggested by Patrick.&lt;/p&gt;</comment>
                            <comment id="12592951" author="faywang" created="Tue, 29 Apr 2008 06:19:33 +0100"  >&lt;p&gt;Per Patrick&apos;s suggestions, this patch removes the equals() and hashCode() methods from JDBCFetchConfigurationImpl into the inner cache key class (SelectKey class) . It also sets fetchGroupContainsDefault to true in FetchConfigurationImpl.clearFetchGroups().&lt;/p&gt;</comment>
                            <comment id="12593892" author="mikedd" created="Fri, 2 May 2008 22:21:48 +0100"  >&lt;p&gt;I&apos;ve committed Fay &amp;amp; Jeremy&apos;s patch to trunk. The JIRA issue indicates that this issue is still a candidate for 1.1.0 - if it&apos;s deemed safe enough to put in 1.1.0 it should be easy to merge across. &lt;/p&gt;</comment>
                            <comment id="12613705" author="kwsutter" created="Tue, 15 Jul 2008 20:36:15 +0100"  >&lt;p&gt;I&apos;m marking this Issue as Resolved for trunk (1.2.0).  Version 1.1.1 is still listed as a potential Fix Version, but I&apos;ll leave that up to somebody else to see if it applies or if they want it.&lt;/p&gt;

&lt;p&gt;Additional sql generation optimizations or caching should be done via new related Issues.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12541678">OPENJPA-2121</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12536305">OPENJPA-2099</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12403004">OPENJPA-703</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12381066" name="OPENJPA-407.patch" size="81568" author="faywang" created="Tue, 29 Apr 2008 06:19:33 +0100"/>
                            <attachment id="12380863" name="OPENJPA-407.patch" size="82466" author="techhusky" created="Thu, 24 Apr 2008 20:15:29 +0100"/>
                            <attachment id="12378726" name="OPENJPA-407.patch" size="56081" author="kwsutter" created="Thu, 27 Mar 2008 15:27:56 +0000"/>
                            <attachment id="12367896" name="OPENJPA-407.patch" size="67784" author="pcl" created="Wed, 17 Oct 2007 20:02:12 +0100"/>
                            <attachment id="12380864" name="QuerySQLCache.doc" size="64000" author="techhusky" created="Thu, 24 Apr 2008 20:16:56 +0100"/>
                            <attachment id="12374420" name="findBy.patch" size="10304" author="kwsutter" created="Wed, 30 Jan 2008 23:00:27 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 17 Oct 2007 19:49:51 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160729</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt60v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>204156</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>