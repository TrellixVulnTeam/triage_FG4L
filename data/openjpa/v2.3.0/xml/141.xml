<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:34:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-141/OPENJPA-141.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-141] More performance improvements (in response to changes for OPENJPA-138)</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-141</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Abe&apos;s response to my committed changes for &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-138&quot; title=&quot;More performance improvements for OpenJPA (lib and kernel)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-138&quot;&gt;&lt;del&gt;OPENJPA-138&lt;/del&gt;&lt;/a&gt;.  I will be working with Abe and my performance team to work through these issues...&lt;/p&gt;

&lt;p&gt;&amp;gt; ======================================================================&lt;br/&gt;
&amp;gt; ========&lt;br/&gt;
&amp;gt; &amp;#8212; incubator/openjpa/trunk/openjpa-kernel/src/main/java/org/apache/&lt;br/&gt;
&amp;gt; openjpa/ee/JNDIManagedRuntime.java (original)&lt;br/&gt;
&amp;gt; +++ incubator/openjpa/trunk/openjpa-kernel/src/main/java/org/apache/&lt;br/&gt;
&amp;gt; openjpa/ee/JNDIManagedRuntime.java Sun Feb 11 18:33:05 2007&lt;br/&gt;
&amp;gt; @@ -29,6 +29,7 @@&lt;br/&gt;
&amp;gt;      implements ManagedRuntime {&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;      private String _tmLoc = &quot;java:/TransactionManager&quot;;&lt;br/&gt;
&amp;gt; +    private static TransactionManager _tm;&lt;/p&gt;

&lt;p&gt;Whoa, I didn&apos;t think you meant caching the TM statically.  That has&lt;br/&gt;
to be backed out.  You can cache it in an instance variable, but not&lt;br/&gt;
statically.  Nothing should prevent someone having two different&lt;br/&gt;
BrokerFactories accessing two different TMs at two different JNDI&lt;br/&gt;
locations.&lt;/p&gt;

&lt;p&gt;BrokerImpl:&lt;br/&gt;
&amp;gt; +     * Cache from/to assignments to avoid Class.isAssignableFrom&lt;br/&gt;
&amp;gt; overhead&lt;br/&gt;
&amp;gt; +     * @param from the target Class&lt;br/&gt;
&amp;gt; +     * @param to the Class to test&lt;br/&gt;
&amp;gt; +     * @return true if the &quot;to&quot; class could be assigned to &quot;from&quot;&lt;br/&gt;
&amp;gt; class&lt;br/&gt;
&amp;gt; +     */&lt;br/&gt;
&amp;gt; +    private boolean isAssignable(Class from, Class to) {&lt;br/&gt;
&amp;gt; +      boolean isAssignable;&lt;br/&gt;
&amp;gt; +      ConcurrentReferenceHashMap assignableTo =&lt;br/&gt;
&amp;gt; +          (ConcurrentReferenceHashMap) _assignableTypes.get(from);&lt;br/&gt;
&amp;gt; +&lt;br/&gt;
&amp;gt; +      if (assignableTo != null) { // &quot;to&quot; cache exists...&lt;br/&gt;
&amp;gt; +          isAssignable = (assignableTo.get(to) != null);&lt;br/&gt;
&amp;gt; +          if (!isAssignable) { // not in the map yet...&lt;br/&gt;
&amp;gt; +              isAssignable = from.isAssignableFrom(to);&lt;br/&gt;
&amp;gt; +              if (isAssignable) &lt;/p&gt;
{
&amp;gt; +                  assignableTo.put(to, new Object());
&amp;gt; +              }
&lt;p&gt;&amp;gt; +          }&lt;br/&gt;
&amp;gt; +      } else { // no &quot;to&quot; cache yet...&lt;br/&gt;
&amp;gt; +          isAssignable = from.isAssignableFrom(to);&lt;br/&gt;
&amp;gt; +          if (isAssignable) &lt;/p&gt;
{
&amp;gt; +              assignableTo = new ConcurrentReferenceHashMap(
&amp;gt; +                      ReferenceMap.HARD, ReferenceMap.WEAK);
&amp;gt; +              _assignableTypes.put(from, assignableTo);
&amp;gt; +              assignableTo.put(to, new Object());
&amp;gt; +          }
&lt;p&gt;&amp;gt; +      }&lt;br/&gt;
&amp;gt; +      return isAssignable;&lt;br/&gt;
&amp;gt; +    }&lt;/p&gt;

&lt;p&gt;This code could be simplified a lot.  Also, I don&apos;t understand what&lt;br/&gt;
you&apos;re trying to do from a memory management perspective.  For the&lt;br/&gt;
_assignableTypes member you&apos;ve got the Class keys using hard refs and&lt;br/&gt;
the Map values using weak refs.  No outside code references the Map&lt;br/&gt;
values, so all entries should be eligible for GC pretty much&lt;br/&gt;
immediately.  The way reference hash maps work prevents them from&lt;br/&gt;
expunging stale entries except on mutators, but still... every time a&lt;br/&gt;
new entry is added, all the old entries should be getting GC&apos;d and&lt;br/&gt;
removed.  Same for the individual Map values, which again map a hard&lt;br/&gt;
class ref to an unreferenced object value with a weak ref.  Basically&lt;br/&gt;
the whole map-of-maps system should never contain more than one entry&lt;br/&gt;
total after a GC run and a mutation.&lt;/p&gt;

&lt;p&gt;I&apos;d really like to see you run your tests under a different JVM,&lt;br/&gt;
because it seems to me like (a) this shouldn&apos;t be necessary in the&lt;br/&gt;
first place, and (b) if this is working, it&apos;s again only because of&lt;br/&gt;
some JVM particulars or GC timing particulars or testing particulars&lt;br/&gt;
(I&apos;ve seen profilers skew results in random ways like this) or even a&lt;br/&gt;
bug in ConcurrentReferenceHashMap.&lt;/p&gt;

&lt;p&gt;The same goes for all the repeat logic in FetchConfigurationImpl.&lt;br/&gt;
And if we keep this code or some variant of it, I strongly suggest&lt;br/&gt;
moving it to a common place like ImplHelper.&lt;/p&gt;

&lt;p&gt;&amp;gt; +    /**&lt;br/&gt;
&amp;gt; +     * Generate the hashcode for this Id.  Cache the type&apos;s&lt;br/&gt;
&amp;gt; generated hashcode&lt;br/&gt;
&amp;gt; +     * so that it doesn&apos;t have to be generated each time.&lt;br/&gt;
&amp;gt; +     */&lt;br/&gt;
&amp;gt;      public int hashCode() {&lt;br/&gt;
&amp;gt;          if (_typeHash == 0) {&lt;br/&gt;
&amp;gt; -            Class base = type;&lt;br/&gt;
&amp;gt; -            while (base.getSuperclass() != null&lt;br/&gt;
&amp;gt; -                &amp;amp;&amp;amp; base.getSuperclass() != Object.class)&lt;br/&gt;
&amp;gt; -                base = base.getSuperclass();&lt;br/&gt;
&amp;gt; -            _typeHash = base.hashCode();&lt;br/&gt;
&amp;gt; +            Integer typeHashInt = (Integer) _typeCache.get(type);&lt;br/&gt;
&amp;gt; +            if (typeHashInt == null) {&lt;br/&gt;
&amp;gt; +                Class base = type;&lt;br/&gt;
&amp;gt; +                Class superclass = base.getSuperclass();&lt;br/&gt;
&amp;gt; +                while (superclass != null &amp;amp;&amp;amp; superclass !=&lt;br/&gt;
&amp;gt; Object.class) &lt;/p&gt;
{
&amp;gt; +                    base = base.getSuperclass();
&amp;gt; +                    superclass = base.getSuperclass();
&amp;gt; +                }
&lt;p&gt;&amp;gt; +                _typeHash = base.hashCode();&lt;br/&gt;
&amp;gt; +                _typeCache.put(type, new Integer(_typeHash));&lt;br/&gt;
&amp;gt; +            } else &lt;/p&gt;
{
&amp;gt; +                _typeHash = typeHashInt.intValue();
&amp;gt; +            }
&lt;p&gt;&amp;gt;          }&lt;br/&gt;
&amp;gt;          return _typeHash ^ idHash();&lt;br/&gt;
&amp;gt;      }&lt;/p&gt;

&lt;p&gt;Once again, you&apos;re mapping a hard Class ref to a value with no&lt;br/&gt;
outside references held in a weak ref.  Once again that means the&lt;br/&gt;
entry should be immediately eligible for GC, and therefore should be&lt;br/&gt;
removed on the next mutation of the cache, subject to GC timing.  And&lt;br/&gt;
again I&apos;d like to know what your JVM is doing to make Class.hashCode&lt;br/&gt;
take an appreciable amount of time.  Aren&apos;t Class instances supposed&lt;br/&gt;
to be singletons?  What if we just used System.identityHashCode(cls)?&lt;/p&gt;

&lt;p&gt;&amp;gt; Modified: incubator/openjpa/trunk/openjpa-lib/src/main/java/org/&lt;br/&gt;
&amp;gt; apache/openjpa/lib/conf/ObjectValue.java&lt;br/&gt;
&amp;gt; URL: &lt;a href=&quot;http://svn.apache.org/viewvc/incubator/openjpa/trunk/openjpa-&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc/incubator/openjpa/trunk/openjpa-&lt;/a&gt;&lt;br/&gt;
&amp;gt; lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?&lt;br/&gt;
&amp;gt; view=diff&amp;amp;rev=506230&amp;amp;r1=506229&amp;amp;r2=506230&lt;br/&gt;
&amp;gt; ======================================================================&lt;br/&gt;
&amp;gt; ========&lt;br/&gt;
&amp;gt; &amp;#8212; incubator/openjpa/trunk/openjpa-lib/src/main/java/org/apache/&lt;br/&gt;
&amp;gt; openjpa/lib/conf/ObjectValue.java (original)&lt;br/&gt;
&amp;gt; +++ incubator/openjpa/trunk/openjpa-lib/src/main/java/org/apache/&lt;br/&gt;
&amp;gt; openjpa/lib/conf/ObjectValue.java Sun Feb 11 18:33:05 2007&lt;br/&gt;
&amp;gt; @@ -17,6 +17,8 @@&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  import org.apache.commons.lang.ObjectUtils;&lt;br/&gt;
&amp;gt;  import org.apache.openjpa.lib.util.Localizer;&lt;br/&gt;
&amp;gt; +import org.apache.openjpa.lib.util.ReferenceMap;&lt;br/&gt;
&amp;gt; +import&lt;br/&gt;
&amp;gt; org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;  /**&lt;br/&gt;
&amp;gt;   * An object &lt;/p&gt;
{@link Value}
&lt;p&gt;.&lt;br/&gt;
&amp;gt; @@ -28,6 +30,10 @@&lt;br/&gt;
&amp;gt;      private static final Localizer _loc = Localizer.forPackage&lt;br/&gt;
&amp;gt;          (ObjectValue.class);&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; +    // cache the types&apos; classloader&lt;br/&gt;
&amp;gt; +    private static ConcurrentReferenceHashMap _classloaderCache =&lt;br/&gt;
&amp;gt; +        new ConcurrentReferenceHashMap(ReferenceMap.HARD,&lt;br/&gt;
&amp;gt; ReferenceMap.WEAK);&lt;/p&gt;

&lt;p&gt;This maps a hard Class ref to a weak ClassLoader ref.  Given that a&lt;br/&gt;
Class references its ClassLoader (or is supposed to &amp;#8211; again I wonder&lt;br/&gt;
what the hell the JVM you&apos;re using is doing where&lt;br/&gt;
Class.getClassLoader is taking a long time), no entries will ever&lt;br/&gt;
expire from this map.&lt;/p&gt;

&lt;p&gt;Have you tried running your benchmarks without all the caching of&lt;br/&gt;
assignables and classloaders and hashcodes (all Class methods, btw)&lt;br/&gt;
and just the other improvements?  Or with any other JVM?&lt;/p&gt;</description>
                <environment></environment>
        <key id="12362606">OPENJPA-141</key>
            <summary>More performance improvements (in response to changes for OPENJPA-138)</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12361497">OPENJPA-115</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kwsutter">Kevin Sutter</assignee>
                                    <reporter username="kwsutter">Kevin Sutter</reporter>
                        <labels>
                    </labels>
                <created>Mon, 12 Feb 2007 17:37:20 +0000</created>
                <updated>Tue, 31 Jul 2007 19:55:14 +0100</updated>
                            <resolved>Tue, 27 Feb 2007 19:34:02 +0000</resolved>
                                                    <fixVersion>0.9.7</fixVersion>
                                    <component>jpa</component>
                        <due>Fri, 16 Feb 2007 08:00:00 +0000</due>
                            <votes>1</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12472440" author="kwsutter" created="Mon, 12 Feb 2007 22:14:55 +0000"  >&lt;p&gt;Re:  Caching the TransactionManager in a static...&lt;/p&gt;

&lt;p&gt;Although we could cache the TM in an instance variable or even do a hashmap with the name as the key, I&apos;m wondering what the scenario is where we could have multiple TMs at different JNDI locations.  I&apos;ve looked at the code and it seems that we have a single TM per runtime instance and we have one of those per configuration.  We attempt to find or create an appropriate runtime instance which in turn creates an appropriate TM.  Where or how can we run into the multiple TM problem?&lt;/p&gt;

&lt;p&gt;Re:  Caching of the assignable from/to types&lt;/p&gt;

&lt;p&gt;Yeah, the HARD/WEAK reference types probably weren&apos;t the right choices.  For the outer map, we could change to SOFT/SOFT references, and the inner map we could change to SOFT/WEAK references (since we don&apos;t really care about the values in the inner map).  We&apos;ll do some experimenting with this to determine the proper configuration.&lt;/p&gt;

&lt;p&gt;Moving this common &quot;isAssignable&quot; code to ImplHelper or something similar is a good suggestion.  I had the same thoughts, but ran out of time over the weekend...&lt;/p&gt;

&lt;p&gt;Re:  Use a different JVM&lt;/p&gt;

&lt;p&gt;We are actually doing these performance runs using the Sun JDK.  We are also verifying the results with the IBM JDK, but the Sun JDK is the one used for the primary performance runs and analysis.&lt;/p&gt;

&lt;p&gt;Re:  Hashcode performance&lt;/p&gt;

&lt;p&gt;It&apos;s actually not the calls to Class.hashCode() that take up so much time, it&apos;s the calls to Class.getSuperClass() that we&apos;re trying to avoid.  I&apos;m not familiar with the System.identityHashCode() method.  Maybe this method does the proper getSuperClass processing more efficiently?  Not sure.&lt;/p&gt;

&lt;p&gt;Also, same comment about the HARD/WEAK references.  I&apos;ll probably end up changing that to SOFT/SOFT.&lt;/p&gt;

&lt;p&gt;Re:  Class.getClassLoader performance&lt;/p&gt;

&lt;p&gt;Unfortunately, this call is expensive.  Although in theory, this invocation should be cheap since each Class needs a reference to its ClassLoader, the caching of the ClassLoader is beneficial.  Here again, this is with the Sun JDK as our primary JVM.&lt;/p&gt;

&lt;p&gt;Re:  Overall&lt;/p&gt;

&lt;p&gt;As stated previously, we are using the Sun JDK for all of these performance benchmarks.  We also verify the results using the IBM JDK.  (We&apos;ve even done some comparisons with JRockit.)  I&apos;ve asked our performance team to generalize our results for consumption by the OpenJPA community (we&apos;re not ready to go public with any specific numbers).  I should be able to post something shortly.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12472455" author="awhite" created="Mon, 12 Feb 2007 23:04:52 +0000"  >&lt;p&gt;1. Each BrokerFactory has a ManagedRuntime.  You can have multiple BrokerFactories, each of which is supposed to be completely independent.  Therefore you can have multiple ManagedRuntimes, each of which is supposed to be completely independent.  Caching the TM in a static in JNDIManagedRuntime breaks that.&lt;/p&gt;

&lt;p&gt;2. I still don&apos;t understand how the caches were working at all with the weak refs, unless GC just wasn&apos;t kicking in very often.  Any info on this?&lt;/p&gt;

&lt;p&gt;As to the proposed changes: there&apos;s no point in caching on Class keys with soft refs.  As soon as a Class is no longer referenced anywhere, there&apos;s no point in keeping it around.  So all Class keys should be weak refs.  The corresponding values can be soft.  &lt;/p&gt;

&lt;p&gt;3. System.identityHashCode isn&apos;t going to help with superclasses... I didn&apos;t realize that that was the slow part.&lt;/p&gt;</comment>
                            <comment id="12472478" author="clr" created="Tue, 13 Feb 2007 00:02:03 +0000"  >&lt;p&gt;Abe opined:&lt;br/&gt;
1. Each BrokerFactory has a ManagedRuntime. You can have multiple BrokerFactories, each of which is supposed to be completely independent. Therefore you can have multiple ManagedRuntimes, each of which is supposed to be completely independent. Caching the TM in a static in JNDIManagedRuntime breaks that. &lt;/p&gt;

&lt;p&gt;Craig thinks: +1. There is no reason to optimize the number of lookups of the ManagedRuntime, since it&apos;s only done once per EMF creation. I agree that making the reference static goes too far. &lt;/p&gt;

&lt;p&gt;2. I still don&apos;t understand how the caches were working at all with the weak refs, unless GC just wasn&apos;t kicking in very often. Any info on this? &lt;/p&gt;

&lt;p&gt;Craig thinks: Weak references are supposed to be cleaned up if the referenced instance is not otherwise referenced. What would cause the referred classes to be garbage collected immediately? I don&apos;t quite understand the issue here.&lt;/p&gt;

&lt;p&gt;But this might beg the real issue, which is what to use as the key for the Map if you want to effectively use the Class as the key but the hashCode and equals methods are just too slow. It might be well to look more closely at IdentityHashMap, in particular to see if there exists a ConcurrentIdentityHashMap or if we can create one. The IdentityHashMap uses System.identityHashCode(Object) instead of the overridden hashCode and == instead of equals. Even with Class instances as keys, this kind of Map should perform well.&lt;/p&gt;

&lt;p&gt;I also don&apos;t understand all the logic when caching the assignableTo info. &lt;br/&gt;
&amp;gt; + if (isAssignable) { &lt;br/&gt;
&amp;gt; + assignableTo.put(to, new Object()); &lt;br/&gt;
Seems like you would want to cache all instances of To and From, whether or not the answer is True. Once anyone asks if two types are assignable, and you find out the answer, why not cache the answer? From the code, it looks like you only cache True results. What if you change the above code to:&lt;br/&gt;
Boolean isAssignableResult = Boolean.valueOf(isAssignable);&lt;br/&gt;
assignableTo.put(to, isAssignableResult);&lt;/p&gt;
</comment>
                            <comment id="12472506" author="awhite" created="Tue, 13 Feb 2007 03:34:45 +0000"  >&lt;p&gt;&amp;gt; Craig thinks: Weak references are supposed to be cleaned up if the referenced instance is not otherwise referenced. What would cause the referred classes to be garbage collected immediately? I don&apos;t quite understand the issue here. &lt;/p&gt;

&lt;p&gt;No, the current code holds the Classes with hard refs, and maps them to various values with weak refs.  Nothing else refers to these weak values.  Therefore they should be eligible for GC immediately, and their map entries should be removed on the next map mutation (reference maps only clean up their expired entries on mutation).  That&apos;s why I don&apos;t understand how the current caches are working at all to boost performance, unless GC isn&apos;t happening very often.&lt;/p&gt;</comment>
                            <comment id="12472510" author="clr" created="Tue, 13 Feb 2007 03:49:02 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; Craig thinks: Weak references are supposed to be cleaned up if the referenced instance is not otherwise referenced. What would cause the referred classes to be garbage collected immediately? I don&apos;t quite understand the issue here. &lt;/p&gt;

&lt;p&gt;&amp;gt;No, the current code holds the Classes with hard refs, and maps them to various values with weak refs. Nothing else refers to these weak values. Therefore they should be eligible for GC immediately, and their map entries should be removed on the next map mutation (reference maps only clean up their expired entries on mutation). That&apos;s why I don&apos;t understand how the current caches are working at all to boost performance, unless GC isn&apos;t happening very often.&lt;/p&gt;

&lt;p&gt;Roger that. Thanks for the explanation, I&apos;m now confused as well. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;So what might work is having the keys be weak, and the otherwise unreferenced values strong. That way, the values will always be there as long as the keys are there. But if you do this, then you have to actually use the Class instances as keys, which implies solving the hashCode/equals problem.&lt;/p&gt;</comment>
                            <comment id="12472516" author="kwsutter" created="Tue, 13 Feb 2007 04:34:55 +0000"  >&lt;p&gt;&amp;gt; So what might work is having the keys be weak, and the otherwise unreferenced values strong. That way, the values will always be there as long as the keys are there. But if you do this, then you have to actually use the Class instances as keys, which implies solving the hashCode/equals problem.&lt;/p&gt;

&lt;p&gt;Solving the hashcode/equals problem?  You mean your concern about these operations being slow?  At least this caching is faster than repeating the calls over and over again...  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It also seems that the ConcurrentReferenceHashMaps require at least one HARD reference, so maybe your suggestion of WEAK/HARD is something to look at.  We&apos;re checking into it.&lt;/p&gt;

&lt;p&gt;Thanks for the other suggestions on the isAssignable method as well.&lt;/p&gt;

&lt;p&gt;More tomorrow...&lt;/p&gt;</comment>
                            <comment id="12472674" author="kwsutter" created="Tue, 13 Feb 2007 14:20:32 +0000"  >&lt;p&gt;&amp;gt; No, the current code holds the Classes with hard refs, and maps them to various values with weak refs. Nothing else refers to these weak values. Therefore they should be eligible for GC immediately, and their map entries should be removed on the next map mutation (reference maps only clean up their expired entries on mutation). That&apos;s why I don&apos;t understand how the current caches are working at all to boost performance, unless GC isn&apos;t happening very often.&lt;/p&gt;

&lt;p&gt;It&apos;s not that the GC isn&apos;t happening very often, it&apos;s that the transaction throughput is very fast (1500 per second).  So, even if we lose an entry once in a while via the GC (once every 20 seconds or so), it&apos;s not that big of a deal to re-populate the cache.  It&apos;s still a heck of lot better than performing the expensive operations on every invocation.  And, changing these Weak references to Soft should even be better since the GC would only collect these references if memory is getting tight.  But, either way is still better than what we have today.&lt;/p&gt;
</comment>
                            <comment id="12472758" author="awhite" created="Tue, 13 Feb 2007 16:53:01 +0000"  >&lt;p&gt;Craig: &lt;br/&gt;
There doesn&apos;t appear to be any hashCode/equals performance issues. As Kevin pointed out earlier in the thread (and I should have realized) he&apos;s only caching Class-&amp;gt;hash in OpenJPAId to prevent having to traverse to the base class... apparently Class.getSuperclass() is slow.  It could just as well be a cache of Class-&amp;gt;base Class, but given the restriction Kevin pointed out that ConcurrentReferenceHashMaps need at least one ref type to be hard, that&apos;d result in a cache that would maintain refs to classes that should be dropped due to redeployment.  &lt;/p&gt;

&lt;p&gt;Kevin:&lt;br/&gt;
It&apos;s unfortunate that ConcurrentReferenceHashMaps need at least one ref type to be hard.  It would have been nice to use weak Class keys and soft values for most of the caches.  As is, I guess hard keys will do... we&apos;ll rely on the value getting GC&apos;d to expire entries for classes that disappear due to redeployment.  Note that the &quot;inner&quot; maps in your map-of-maps scheme of assignables might as well just be a normal ConcurrentHashMaps too &amp;#8211; the outer map already will let inner maps drop when memory is low.  I also agree with craig about mapping to Boolean.TRUE/FALSE instead of new Object().  And I&apos;d still like to see the assignable logic moved to ImplHelper or some new common helper class.&lt;/p&gt;</comment>
                            <comment id="12472790" author="kwsutter" created="Tue, 13 Feb 2007 17:46:30 +0000"  >&lt;p&gt;Sounds good, Abe.  Thanks for the comments, Abe and Craig.  Here&apos;s the plan for the changes (for this Issue)...&lt;/p&gt;

&lt;p&gt;o  Fix up the TM caching&lt;br/&gt;
o  Change to using Hard/Soft reference types as required&lt;br/&gt;
o  Store true/false in the inner map&lt;br/&gt;
o  Make &quot;isAssignable&quot; common code&lt;br/&gt;
o  Use ConcurrentHashMap for the inner class&lt;/p&gt;

&lt;p&gt;That should cover it for now.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12472795" author="clr" created="Tue, 13 Feb 2007 17:50:31 +0000"  >&lt;p&gt;Nice work, Kevin and Abe.&lt;/p&gt;

&lt;p&gt;Just a reminder. Please attach an svn patch to this JIRA when it&apos;s ready. I&apos;d like to be able to see the patch right along side this discussion here. And when the patch is committed, please put &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-141&quot; title=&quot;More performance improvements (in response to changes for OPENJPA-138)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-141&quot;&gt;&lt;del&gt;OPENJPA-141&lt;/del&gt;&lt;/a&gt; into the commit comments so svn will back link to this page. Thanks.&lt;/p&gt;</comment>
                            <comment id="12472813" author="pcl" created="Tue, 13 Feb 2007 18:19:40 +0000"  >&lt;p&gt;&amp;gt; Please attach an svn patch to this JIRA when it&apos;s ready. I&apos;d like to be able to see the &lt;br/&gt;
&amp;gt; patch right along side this discussion here. And when the patch is committed, &lt;br/&gt;
&amp;gt; please put &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-141&quot; title=&quot;More performance improvements (in response to changes for OPENJPA-138)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-141&quot;&gt;&lt;del&gt;OPENJPA-141&lt;/del&gt;&lt;/a&gt; into the commit comments so svn will back link to this page.&lt;/p&gt;

&lt;p&gt;Actually, if you put &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-141&quot; title=&quot;More performance improvements (in response to changes for OPENJPA-138)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-141&quot;&gt;&lt;del&gt;OPENJPA-141&lt;/del&gt;&lt;/a&gt; in the comments, JIRA will automatically create a link to the commit in svn, which allows you to see a patch. IMO, if the issue number goes in the commit message, then we needn&apos;t bother with a patch.&lt;/p&gt;</comment>
                            <comment id="12472829" author="clr" created="Tue, 13 Feb 2007 19:02:42 +0000"  >&lt;p&gt;Given the number of iterations already documented on this issue, wouldn&apos;t it be better to attach the real patch here for review?&lt;/p&gt;

&lt;p&gt;In other words, this issue might be a case of &quot;review then commit&quot; instead of our normal &quot;commit then review&quot; approach.&lt;/p&gt;</comment>
                            <comment id="12472840" author="kwsutter" created="Tue, 13 Feb 2007 19:24:47 +0000"  >&lt;p&gt;Personally, I think I provide sufficient due diligence on the Issues that I own to stick with the normal &quot;commit then review&quot; approach.  There are many, many changes that get incorporated into OpenJPA without even a JIRA Issue discussion.  So, until I totally screw up, I&apos;m going along with Patrick&apos;s comment and will do my normal commit with the JIRA Issue in the comment field.&lt;/p&gt;</comment>
                            <comment id="12473167" author="kwsutter" created="Wed, 14 Feb 2007 19:31:00 +0000"  >&lt;p&gt;On second thought, I have attached the proposed patch to this Issue.  Please review and provide feedback in a timely manner.  I would like to commit these changes as soon as possible.  Thank you.&lt;/p&gt;

&lt;p&gt;The one thing that I decided to do is to go with SOFT references for the keys instead of WEAK.  This way, in case the GC does start to run more often, it will only clean up these SOFT references if memory constraints exist.&lt;/p&gt;

&lt;p&gt;Of course, all of the OpenJPA tests run just fine and the performance numbers are looking better.&lt;/p&gt;

&lt;p&gt;Thanks for your help,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12473172" author="awhite" created="Wed, 14 Feb 2007 19:53:11 +0000"  >&lt;p&gt;1. Why not keep a single assignable types map in ImplHelper?&lt;br/&gt;
2. I thought we had decided on the assignable types map having hard keys and soft values.  Using soft keys and hard values is odd to say the least.  First, as I mentioned in a previous note, using soft Class keys is pointless.  Once a Class is eligible for GC there&apos;s no point in keeping it in cache, so weak is better.  Second, using hard values means that other than adapting to class redeploys, this is basically a hard cache, because the only time entries are removed is when a Class disappears, and that only happens on redeploy.  It&apos;s not necessarily bad to make this a hard cache, but it should be discussed.&lt;br/&gt;
3. Why keep dedicated isAssignable methods in BrokerImpl and FetchConfigurationImpl if all they do is delegate to ImplHelper?  Why not call ImplHelper directly?&lt;br/&gt;
4. Why are you using a static JNDI location -&amp;gt; TM cache in JNDITransactionManager rather than just caching the TM in an instance variable?  The only time that would help performance is if you&apos;re creating a bunch of BrokerFactories all using the same TM location.  Most applications will only use a single BrokerFactory.  If your benchmarks is constantly creating BrokerFactories, I&apos;d question the validity of the benchmark.&lt;br/&gt;
5. Even if ImplHelper.isAssignable retains its map parameter (and per #1 above I question why it should), it should just be a Map; I don&apos;t see why you&apos;d have the method require a ConcurrentMap.&lt;br/&gt;
6. #2 above applies also to the Class-&amp;gt;base hash map in OpenJPAId.&lt;/p&gt;</comment>
                            <comment id="12473228" author="kwsutter" created="Wed, 14 Feb 2007 22:23:00 +0000"  >&lt;p&gt;Good thing I posted the patch...  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt;1. Why not keep a single assignable types map in ImplHelper?&lt;/p&gt;

&lt;p&gt;I actually thought about doing that, but then I had concerns about the size of the Cache.  So, I decided to isolate the changes (and the caches) to the problems at hand.  If you don&apos;t see a problem with this, I can change to a single assignable types map.&lt;/p&gt;

&lt;p&gt;&amp;gt;2. I thought we had decided on the assignable types map having hard keys and soft values. Using soft keys and hard values is odd to say the least. First, as I mentioned in a previous note, using soft Class keys is pointless. Once a Class is eligible for GC there&apos;s no point in keeping it in cache, so weak is better. Second, using hard values means that other than adapting to class redeploys, this is basically a hard cache, because the only time entries are removed is when a Class disappears, and that only happens on redeploy. It&apos;s not necessarily bad to make this a hard cache, but it should be discussed.&lt;/p&gt;

&lt;p&gt;Hmmm..  If I understand what you are saying, it really doesn&apos;t matter whether we use hard, weak, or soft keys, since the resulting cache will be hard no matter what &amp;#8211; since we&apos;re using Class objects in the cache.  And, using weak keys actually sounds better due to the class redeploy scenario.  I can understand your hesitance with soft keys, but from your arguments, it sounds like we should go with weak keys and hard values.&lt;/p&gt;

&lt;p&gt;&amp;gt;3. Why keep dedicated isAssignable methods in BrokerImpl and FetchConfigurationImpl if all they do is delegate to ImplHelper? Why not call ImplHelper directly?&lt;/p&gt;

&lt;p&gt;Certainly could.  Cleans up the code a bit.&lt;/p&gt;

&lt;p&gt;&amp;gt;4. Why are you using a static JNDI location -&amp;gt; TM cache in JNDITransactionManager rather than just caching the TM in an instance variable? The only time that would help performance is if you&apos;re creating a bunch of BrokerFactories all using the same TM location. Most applications will only use a single BrokerFactory. If your benchmarks is constantly creating BrokerFactories, I&apos;d question the validity of the benchmark.&lt;/p&gt;

&lt;p&gt;It&apos;s probably six of one, half a dozen of the other.  I can make the change to use an instance variable.&lt;/p&gt;

&lt;p&gt;The benchmark is a set of primitives based on the SpecJApp application using the SunOne Application Server.  The profiling data from this set of tests indicate that caching of the JNDI lookup is beneficial.  Maybe this change only helps with this particular Application Server, but I&apos;m trying to isolate our OpenJPA implementation from the RI (SunOne).&lt;/p&gt;

&lt;p&gt;&amp;gt;5. Even if ImplHelper.isAssignable retains its map parameter (and per #1 above I question why it should), it should just be a Map; I don&apos;t see why you&apos;d have the method require a ConcurrentMap.&lt;/p&gt;

&lt;p&gt;I did this way to be thread safe.  If I only used a Map parameter, then the caller would have to ensure that any updates to the Cache are thread safe.  Instead of putting that :&quot;artificial&quot; requirement on the caller, why not just use the ConcurrentMap type to ensure the safety?  Of course, this point is moot, if you are okay with going with a single Cache.&lt;/p&gt;

&lt;p&gt;&amp;gt;6. #2 above applies also to the Class-&amp;gt;base hash map in OpenJPAId.&lt;/p&gt;

&lt;p&gt;Yep, all the same issue.&lt;/p&gt;</comment>
                            <comment id="12473231" author="clr" created="Wed, 14 Feb 2007 22:32:01 +0000"  >&lt;p&gt;1. The original functionality of isAssignable(Class a, Class b) is to return true if either class is assignable to the other. e.g.&lt;br/&gt;
    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Whether either of the two types is assignable from the other.&lt;br/&gt;
     */&lt;br/&gt;
    private static boolean isAssignable(Class c1, Class c2) 
{
        return c1 != null &amp;amp;&amp;amp; c2 != null 
            &amp;amp;&amp;amp; (c1.isAssignableFrom(c2) || c2.isAssignableFrom(c1));
    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The new method doesn&apos;t seem to include both sides of the assignable functionality. Was this done on purpose?&lt;/p&gt;</comment>
                            <comment id="12473234" author="awhite" created="Wed, 14 Feb 2007 22:45:32 +0000"  >&lt;p&gt;Craig, good catch.  I didn&apos;t even look at the actual assignable method code... I was saving that for when we had settled on a caching strategy.&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt;1. Why not keep a single assignable types map in ImplHelper? &lt;br/&gt;
&amp;gt; I actually thought about doing that, but then I had concerns about the size of the Cache. &lt;/p&gt;

&lt;p&gt;How are two static maps going to end up being smaller overall than one combined static map?&lt;/p&gt;

&lt;p&gt;&amp;gt; Hmmm.. If I understand what you are saying, it really doesn&apos;t matter whether we use hard, weak, or soft keys, since the resulting cache will be hard no matter what &amp;#8211; since we&apos;re using Class objects in the cache.&lt;/p&gt;

&lt;p&gt;No, it does matter.  And the type of value references we use matters way more.  If we want a &quot;hard cache that drops entries for classes that are redeployed&quot;, then we should be using weak keys and hard values.  If we want a &quot;memory sensitive&quot; cache, then we should be using hard keys and soft values.  I&apos;m not sure where the disconnect is coming from with these reference types.&lt;/p&gt;

&lt;p&gt;&amp;gt; The benchmark is a set of primitives based on the SpecJApp application using the SunOne Application Server. The profiling data from this set of tests indicate that caching of the JNDI lookup is beneficial.&lt;/p&gt;

&lt;p&gt;Beneficial over the suggested use of an instance variable?  Or beneficial over no caching of the TM whatsoever?  There&apos;s a big difference.&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt;5. Even if ImplHelper.isAssignable retains its map parameter (and per #1 above I question why it should), it should just be a Map; I don&apos;t see why you&apos;d have the method require a ConcurrentMap. &lt;br/&gt;
&amp;gt; I did this way to be thread safe. If I only used a Map parameter, then the caller would have to ensure that any updates to the Cache are thread safe. &lt;/p&gt;

&lt;p&gt;The caller is giving you the Map in your scheme.  It&apos;s up to him whether the Map he&apos;s giving you is used concurrently or not.  The helper method itself has no threading issues at all, and only requires a Map.  But I agree that if we move to a single cache in ImplHelper it&apos;s a moot point.&lt;/p&gt;</comment>
                            <comment id="12473243" author="kwsutter" created="Wed, 14 Feb 2007 23:09:34 +0000"  >&lt;p&gt;Yes, good catch, Craig.  The original location that I wanted to resolve the isAssignableFrom() overhead was in BrokerImpl and that was just a one-way check.  The two-way check in FetchConfigurationImpl was overlooked.  Thank you.  But, that brings up a new question...  Do we do the two-way check in this new utility method (even though BrokerImpl didn&apos;t require this in the past)?  Or, is the one-way check sufficient for FetchConfigurationImpl&apos;s usage?  Any historical perspective?&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; 1. Why not keep a single assignable types map in ImplHelper?&lt;br/&gt;
&amp;gt;&amp;gt; I actually thought about doing that, but then I had concerns about the size of the Cache.&lt;br/&gt;
&amp;gt; How are two static maps going to end up being smaller overall than one combined static map?&lt;/p&gt;

&lt;p&gt;Never mind.  Since we&apos;re dealing with (hopefully) unique Class keys, a single map will suffice.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; Hmmm.. If I understand what you are saying, it really doesn&apos;t matter whether we use hard, weak, or soft keys, since the resulting cache will be hard no matter what &amp;#8211; since we&apos;re using Class objects in the cache.&lt;br/&gt;
&amp;gt; No, it does matter. And the type of value references we use matters way more. If we want a &quot;hard cache that drops entries for classes that are redeployed&quot;, then we should be using weak keys and hard values. If we want a &quot;memory sensitive&quot; cache, then we should be using hard keys and soft values. I&apos;m not sure where the disconnect is coming from with these reference types.&lt;/p&gt;

&lt;p&gt;There have been several viewpoints on the use of these reference types and what the impact would be.  To be honest, at this point, all that I am looking for is the ability to cache these assignable types.  Whether it&apos;s redployment-friendly or memory-friendly, I don&apos;t really care at this point.  We can worry about that later.  If you have a preference for this first iteration, let me know.  Thanks.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; The benchmark is a set of primitives based on the SpecJApp application using the SunOne Application Server. The profiling data from this set of tests indicate that caching of the JNDI lookup is beneficial.&lt;br/&gt;
&amp;gt;Beneficial over the suggested use of an instance variable? Or beneficial over no caching of the TM whatsoever? There&apos;s a big difference.&lt;/p&gt;

&lt;p&gt;Definitely beneficial over no caching of the TM whatsoever.  Sorry for the confusion.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; 5. Even if ImplHelper.isAssignable retains its map parameter (and per #1 above I question why it should), it should just be a Map; I don&apos;t see why you&apos;d have the method require a ConcurrentMap.&lt;br/&gt;
&amp;gt;&amp;gt; I did this way to be thread safe. If I only used a Map parameter, then the caller would have to ensure that any updates to the Cache are thread safe.&lt;br/&gt;
&amp;gt;The caller is giving you the Map in your scheme. It&apos;s up to him whether the Map he&apos;s giving you is used concurrently or not. The helper method itself has no threading issues at all, and only requires a Map. But I agree that if we move to a single cache in ImplHelper it&apos;s a moot point.&lt;/p&gt;

&lt;p&gt;That&apos;s definitely one way around it.  I prefer to enforce the requirement via the signature of the contract.  Changing to a single map anyway...&lt;/p&gt;</comment>
                            <comment id="12473253" author="pcl" created="Wed, 14 Feb 2007 23:28:58 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; 4. Why are you using a static JNDI location -&amp;gt; TM cache in JNDITransactionManager &lt;br/&gt;
&amp;gt; &amp;gt; rather than just caching the TM in an instance variable? &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; It&apos;s probably six of one, half a dozen of the other. I can make the change to use an &lt;br/&gt;
&amp;gt; instance variable. &lt;/p&gt;

&lt;p&gt;Personally, I&apos;m allergic to static fields, and can only tolerate them in small doses. So I prefer the instance variable caching. The nice thing about the OpenJPA configuration architecture is that the Configuration instance is a natural singleton for a given persistence unit; the more we can tie caches to the persistence unit, the better things will work in unexpected heterogeneous environments, during redeploys, etc.&lt;/p&gt;</comment>
                            <comment id="12473254" author="pcl" created="Wed, 14 Feb 2007 23:30:22 +0000"  >&lt;p&gt;&amp;gt; If we want a &quot;hard cache that drops entries for classes that are redeployed&quot;, then &lt;br/&gt;
&amp;gt; we should be using weak keys and hard values. If we want a &quot;memory sensitive&quot; &lt;br/&gt;
&amp;gt; cache, then we should be using hard keys and soft values.&lt;/p&gt;

&lt;p&gt;I vaguely prefer a &quot;hard cache that drops entries for classes that are redeployed&quot;, since I care more about speed than memory footprint.&lt;/p&gt;</comment>
                            <comment id="12473285" author="clr" created="Thu, 15 Feb 2007 01:54:34 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; If we want a &quot;hard cache that drops entries for classes that are redeployed&quot;, then &lt;br/&gt;
&amp;gt;&amp;gt; we should be using weak keys and hard values. If we want a &quot;memory sensitive&quot; &lt;br/&gt;
&amp;gt;&amp;gt; cache, then we should be using hard keys and soft values. &lt;/p&gt;

&lt;p&gt;&amp;gt;I vaguely prefer a &quot;hard cache that drops entries for classes that are redeployed&quot;, since I care more about speed than memory footprint.&lt;/p&gt;

&lt;p&gt;This is also affected by whether we use a giant cache (including all the EMFs) or one cache per EMF. I prefer one cache per EMF because it simplifies the cache entry life cycle. During EMF close, the cache can be explicitly cleared, which allows the garbage collector to be more efficient since it doesn&apos;t have to scan all the entries in the cache. &lt;/p&gt;</comment>
                            <comment id="12473290" author="pcl" created="Thu, 15 Feb 2007 02:39:13 +0000"  >&lt;p&gt;&amp;gt; This is also affected by whether we use a giant cache (including all the EMFs) or one cache per EMF.&lt;/p&gt;

&lt;p&gt;As I mentioned earlier, I generally prefer putting things in a Configuration or BrokerFactory to creating static fields. Now that I&apos;ve actually looked at the code &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/warning.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, I noticed that we only call the new ImplHelper method from places where we have a BrokerFactory handy. Maybe we should move the cache to the BrokerFactory or the Configuration? That way, at undeploy time (assuming that undeploy throws away the BrokerFactory), we don&apos;t need to do anything at all.&lt;/p&gt;

&lt;p&gt;This could end up looking like a new method Configuration.isAssignable(Class from, Class to).&lt;/p&gt;

&lt;p&gt;That said, in this case, I don&apos;t particularly mind using a static field, since this particular bit of data is already static (insofar as Class objects are singletons).&lt;/p&gt;</comment>
                            <comment id="12473416" author="awhite" created="Thu, 15 Feb 2007 16:28:18 +0000"  >&lt;p&gt;&amp;gt; The two-way check in FetchConfigurationImpl was overlooked. Thank you. But, that brings up a new question... Do we do the two-way check in this new utility method (even though BrokerImpl didn&apos;t require this in the past)? Or, is the one-way check sufficient for FetchConfigurationImpl&apos;s usage? &lt;/p&gt;

&lt;p&gt;It should be a one-way check and code that needs to check both directions should invoke it twice with the arguments swapped the second time.  Simple.&lt;/p&gt;

&lt;p&gt;&amp;gt; There have been several viewpoints on the use of these reference types and what the impact would be. To be honest, at this point, all that I am looking for is the ability to cache these assignable types. Whether it&apos;s redployment-friendly or memory-friendly, I don&apos;t really care at this point.&lt;/p&gt;

&lt;p&gt;I don&apos;t care either, so long as it&apos;s one of the two reference type combinations I outlined that actually make sense.  We can&apos;t just pick reference types randomly.&lt;/p&gt;

&lt;p&gt;As to whether we should use a static cache vs. a Configuration instance cache... doesn&apos;t matter much to me.  The static cache keeps the API simpler. &lt;/p&gt;

&lt;p&gt;&amp;gt; Definitely beneficial over no caching of the TM whatsoever. Sorry for the confusion. &lt;/p&gt;

&lt;p&gt;So the question now is whether it is beneficial over the use of an instance variable.  In normal usage, there&apos;s no reason it should be.  And so we should use an instance variable.  You could code an entire app using static maps in place of all instance variables if you really wanted to, so yes, in that sense they&apos;re equivalent, but there are good reasons not to.  Same goes for this.&lt;/p&gt;

&lt;p&gt;And finally, I&apos;m going to harp on something that is no longer even relevant, because I&apos;m sure it will come up again in API design moving forward:&lt;/p&gt;

&lt;p&gt;==================&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; 5. Even if ImplHelper.isAssignable retains its map parameter (and per #1 above I question why it should), it should just be a Map; I don&apos;t see why you&apos;d have the method require a ConcurrentMap. &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; I did this way to be thread safe. If I only used a Map parameter, then the caller would have to ensure that any updates to the Cache are thread safe. &lt;/p&gt;

&lt;p&gt;&amp;gt;The caller is giving you the Map in your scheme. It&apos;s up to him whether the Map he&apos;s giving you is used concurrently or not. The helper method itself has no threading issues at all, and only requires a Map. But I agree that if we move to a single cache in ImplHelper it&apos;s a moot point. &lt;/p&gt;

&lt;p&gt;That&apos;s definitely one way around it. I prefer to enforce the requirement via the signature of the contract. ===================&lt;/p&gt;

&lt;p&gt;This is a stateless static helper method.  You&apos;re not &quot;enforcing&quot; anything, because the method itself has no threading concerns whatsoever.  You&apos;re &lt;b&gt;imposing&lt;/b&gt; a requirement to use a certain kind of Map on a method that would function perfectly well with anything that implements the Map interface.  That is not something a helper method should do.  What if I want to use the method from single threaded code?  What if I want to use it from a method that&apos;s already synchronized?  Or what if I want to pass it a synchronized map instead of a concurrent one?  Why should a helper method that knows nothing about who is calling it and has no threading concerns itself be forcing any concurrency strategy on me, much less a particular one?  By this reasoning, every public method in the entire codebase should either be synchronized or should require thread safe arguments, because someone who calls the method &lt;b&gt;might&lt;/b&gt; be doing so from multi-threaded code that is not already synchronized.&lt;/p&gt;</comment>
                            <comment id="12473445" author="kwsutter" created="Thu, 15 Feb 2007 17:48:24 +0000"  >&lt;p&gt;Getting close to another patch posting...&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; The two-way check in FetchConfigurationImpl was overlooked. Thank you. But, that brings up a new question... Do we do the two-way check in this new utility method (even though BrokerImpl didn&apos;t require this in the past)? Or, is the one-way check sufficient for FetchConfigurationImpl&apos;s usage?&lt;/p&gt;

&lt;p&gt;&amp;gt; It should be a one-way check and code that needs to check both directions should invoke it twice with the arguments swapped the second time. Simple.&lt;/p&gt;

&lt;p&gt;From what I can tell, it looks like the double check within FetchConfigurationImpl was overhead and not needed.  Thus, my proposal is to just have the new helper method do the one-way check.  And, leave FetchConfigurationImpl usage with single invocations (BrokerImpl usage was already one-way).  Anybody with further historical knowledge in this area can surely pipe in...  Thanks.&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12473504" author="kwsutter" created="Thu, 15 Feb 2007 20:37:58 +0000"  >&lt;p&gt;Just posted another version of the performance patch for openjpa-141.  I believe I have honored the comments as posted to this Issue.  Please take a look and let&apos;s see if we can put this one to bed...  I have more performance-related items to pursue...  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Thanks!&lt;/p&gt;</comment>
                            <comment id="12473515" author="pcl" created="Thu, 15 Feb 2007 20:59:48 +0000"  >&lt;p&gt;Looks good to me. Super-tiny nit: you&apos;ve got a brace on a newline in an if statement in BrokerImpl.java, instead of the new brace-on-same-line convention that we&apos;ve been using on OpenJPA.&lt;/p&gt;</comment>
                            <comment id="12473521" author="kwsutter" created="Thu, 15 Feb 2007 21:21:38 +0000"  >&lt;p&gt;&amp;gt; Looks good to me. Super-tiny nit: you&apos;ve got a brace on a newline in an if statement in BrokerImpl.java, instead of the new brace-on-same-line convention that we&apos;ve been using on OpenJPA.&lt;/p&gt;

&lt;p&gt;That&apos;s because I ran up against the other OpenJPA convention of limiting the line length to 80 characters.  If I divided up the conditional, it was difficult to read.  And, the previous conditional statement in this same method did the same thing with dropping the brace to the next line, so I thought it was a safe alternative.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Thanks for reviewing the changes.  If I don&apos;t hear anything else, I&apos;ll commit the changes later this evening.&lt;/p&gt;</comment>
                            <comment id="12473527" author="clr" created="Thu, 15 Feb 2007 21:55:58 +0000"  >&lt;p&gt;&amp;gt;Just posted another version of the performance patch for openjpa-141. I believe I have honored the comments as posted to this Issue. Please take a look and let&apos;s see if we can put this one to bed... &lt;/p&gt;

&lt;p&gt;Looks good.&lt;/p&gt;

&lt;p&gt;&amp;gt;I have more performance-related items to pursue... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;I was hoping you did.&lt;/p&gt;

&lt;p&gt;&amp;gt;Thanks!&lt;/p&gt;

&lt;p&gt;Thanks for your patience.&lt;/p&gt;</comment>
                            <comment id="12473537" author="pcl" created="Thu, 15 Feb 2007 22:23:11 +0000"  >&lt;p&gt;&amp;gt; That&apos;s because I ran up against the other OpenJPA convention of limiting the line length to 80 characters. &lt;/p&gt;

&lt;p&gt;Ah, yes... the clash of the code standards.&lt;/p&gt;</comment>
                            <comment id="12476330" author="kwsutter" created="Tue, 27 Feb 2007 19:34:02 +0000"  >&lt;p&gt;Code changes complete per comments in Issue.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12362351">OPENJPA-138</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12351279" name="openjpa-141.txt" size="12565" author="kwsutter" created="Thu, 15 Feb 2007 20:37:57 +0000"/>
                            <attachment id="12351162" name="openjpa-141.txt" size="9933" author="kwsutter" created="Wed, 14 Feb 2007 19:31:00 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 12 Feb 2007 23:04:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160475</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt0jz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203270</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>