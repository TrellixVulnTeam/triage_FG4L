<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:46:09 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-1163/OPENJPA-1163.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-1163] Data consistency issues while modifying collections.</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-1163</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;There are data consistency issues when modifying more number of elements in a collection Vs less number of elements.&lt;/p&gt;

&lt;p&gt;Following is a detailed explanation about the issue with example:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Entity A has a collection of Entities AItems with cascade ALL.&lt;/li&gt;
	&lt;li&gt;Test case :&lt;br/&gt;
  Clear all the data inside tables representing Entity A and AItems.  &lt;br/&gt;
  Create 3 entity managers em1,em2 and em3.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  em1.begin()&lt;br/&gt;
      create A on em1 with id &quot;1&quot;&lt;br/&gt;
      add 10 elements of AItems (id&apos;s from 0-9) to the created A(id 1).&lt;br/&gt;
      persist A.&lt;br/&gt;
  em1.commit()&lt;/p&gt;

&lt;p&gt;  em1.begin()&lt;br/&gt;
      merge A ( created in the previous step)&lt;br/&gt;
      Remove 3 elements of AItems from the merged A.&lt;br/&gt;
      Add 3 elements of AItems ( id&apos;s 10,11,12) to the merged A (id 1).&lt;/p&gt;

&lt;p&gt;With out committing em1&lt;/p&gt;

&lt;p&gt;  em2.begin()&lt;br/&gt;
      query database to fetch A and construct object result2 of entity A.&lt;br/&gt;
      Add 3 elements of AItems ( id&apos;s 13,14,15) to fetched A ( result2)      &lt;/p&gt;

&lt;p&gt;   em2.commit ()&lt;br/&gt;
   em1.commit()&lt;/p&gt;

&lt;p&gt;  em3.begin()&lt;br/&gt;
     query database to check the size of AItems that are related to A ( id 1)&lt;br/&gt;
  em3.commit()&lt;/p&gt;

&lt;p&gt;  The result on em3&apos;s query for AItems related to A, returns 13 as expected.&lt;br/&gt;
  13 ( Initial 10 - em1&apos;s 3 + em1&apos;s 3 + em2&apos;s 3).&lt;/p&gt;

&lt;p&gt;When the same test case is repeated with removing and adding 10 elements instead of 3 as before then I get wrong results.&lt;/p&gt;

&lt;p&gt;    Add initial 10 AItems (id&apos;s 0-9) for A.&lt;br/&gt;
    commit()&lt;/p&gt;

&lt;p&gt;    em1 will remove 10 AItems from the collection of A.&lt;br/&gt;
    em1 will add 10 AItems (id&apos;s 10-19) to collection of A.&lt;/p&gt;

&lt;p&gt;    em2 will add 10 AItems (id&apos;s 20-29) to collection of A.&lt;/p&gt;

&lt;p&gt;    Commit em2.&lt;br/&gt;
    Commit em1.&lt;/p&gt;

&lt;p&gt;    Then instead of 20 elements ( Initial 10 - em1&apos;s 10 + em1&apos;s 10 + em2&apos;s 10), I see only 10 elements.&lt;/p&gt;

&lt;p&gt;    The 10 elements that I see are from em1&apos;s added AItems ( id&apos;s 10-19).&lt;/p&gt;


&lt;p&gt;I think the cause of the issue is that, when more number of elements (compared to initial element count of collection) in a collection are modified then collection tracking is disabled and openJPA tries to do the following:&lt;br/&gt;
 &amp;#8211; Delete every thing from the collection&lt;br/&gt;
 &amp;#8211; Insert data back to collection.&lt;br/&gt;
While Inserting the data back it does not consider adding the dirty records ( em2&apos;s 10 added elements ) because the collection tracking is disabled.&lt;/p&gt;</description>
                <environment>openJPA trunk. Derby DB.</environment>
        <key id="12429818">OPENJPA-1163</key>
            <summary>Data consistency issues while modifying collections.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rpalache">Ravi P Palacherla</assignee>
                                    <reporter username="rpalache">Ravi P Palacherla</reporter>
                        <labels>
                    </labels>
                <created>Wed, 8 Jul 2009 16:31:56 +0100</created>
                <updated>Tue, 9 Mar 2010 18:31:18 +0000</updated>
                            <resolved>Mon, 3 Aug 2009 22:07:10 +0100</resolved>
                                                    <fixVersion>1.1.1</fixVersion>
                    <fixVersion>2.0.0-M3</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                    <timeoriginalestimate seconds="0">0h</timeoriginalestimate>
                            <timeestimate seconds="0">0h</timeestimate>
                                        <comments>
                            <comment id="12728756" author="rpalache" created="Wed, 8 Jul 2009 17:01:36 +0100"  >&lt;p&gt;Attached is a test case and fix for the issue.&lt;/p&gt;</comment>
                            <comment id="12733454" author="mikedd" created="Tue, 21 Jul 2009 04:18:49 +0100"  >&lt;p&gt;Hi Ravi,&lt;/p&gt;

&lt;p&gt;Thanks for the patch. I think this sort of change needs a corresponding configuration option in the Compatibility class (maybe called limitChangesTracked?). The javadoc for org.apache.openjpa.conf.Compatibility can contain the information on when we changed the default behavior and why we made the change. If that isn&apos;t enough to go on just let me know and I&apos;ll provide some more pointers. &lt;/p&gt;

&lt;p&gt;I think that changing the default is the correct way to go, but I can also see existing applications that are unknowingly coded to the old behavior so I&apos;d like to give them an option to move forward. I&apos;ll take a closer look at the testcase tomorrow (might be evening) but at first glance the patch looks good. &lt;/p&gt;

&lt;p&gt;Thanks very much for finding and debugging this.&lt;/p&gt;</comment>
                            <comment id="12733960" author="mikedd" created="Wed, 22 Jul 2009 03:57:14 +0100"  >&lt;p&gt;Hi Ravi,&lt;/p&gt;

&lt;p&gt;This patch demonstrates a race condition more than anything else. You have two transactions. Tran 1 gets a copy of the entity, removes everything from its collection, then adds ten more items. Tran 2 gets a copy of the entity and just adds ten items. To show this just print out the size of newA.getAItems() before committing tran 1.&lt;/p&gt;

&lt;p&gt;In Tran 1 the entity has only 10 items , in tran 2 the entity has 20. The last one to commit wins. It&apos;s a unidirectional relationship - I&apos;m guessing this is because it&apos;s a uni-directional relationship and A is the owner (even though the updates are in the AItem table) and therefore the state in A trumps the state in AItem. &lt;/p&gt;

&lt;p&gt;Interestingly enough if you updated any field in A you should see an OptimisticLockException which would explain the problem better. &lt;/p&gt;</comment>
                            <comment id="12734736" author="rpalache" created="Thu, 23 Jul 2009 20:16:58 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;In my example, data dealt with Trans1 and Trans2 is not interfering with each other.&lt;br/&gt;
Both Trans1 and Trans2 are working on different objects and different rows of table.&lt;br/&gt;
Hence I fail to understand what you meant by &quot;This patch demonstrates a race condition more than anything else.&quot;&lt;/p&gt;

&lt;p&gt;The whole idea of my testcase is to demonstrate that the results in database are different if I execute same code but the number of rows updates are different.&lt;/p&gt;

&lt;p&gt;A Item has 10 rows.&lt;br/&gt;
Trans1 --&amp;gt; deletes 10 rows. (0 to 9)&lt;br/&gt;
                   Adds 10 rows.(10 to 19)&lt;br/&gt;
Trans2 --&amp;gt; Adds 10 rows.(20 to 29)&lt;br/&gt;
Commit Trans2.&lt;br/&gt;
Commit Trans1.&lt;/p&gt;

&lt;p&gt;Rows in talbe AItems after above execution : ( 10 to 19) = 10 rows in total.&lt;/p&gt;

&lt;p&gt;The same code when I manipulate only 3 rows.&lt;br/&gt;
A Item has 10 rows.&lt;br/&gt;
Trans1 --&amp;gt; deletes 3 rows. (0 to 6)&lt;br/&gt;
                   Adds 3 rows.(10 to 12)&lt;br/&gt;
Trans2 --&amp;gt; Adds 3 rows.(20 to 22)&lt;br/&gt;
Commit Trans2.&lt;br/&gt;
Commit Trans1.&lt;br/&gt;
Rows in talbe AItems after above execution : (0 to 6 , 10 to 12 , 20 to 22) = 13 rows in total&lt;/p&gt;

&lt;p&gt;If only Trans1 has to win , then the results should be ( 0 to 6 ,10 to 12 = 10 in total) rather than 13.&lt;/p&gt;

&lt;p&gt;So the results in AItems are different even though the same code is executed.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; You mentioned &quot;The last one to commit wins.&quot;&lt;br/&gt;
When the data in both the transactions are not interfering with each other then both the transactions has to win , isn&apos;t it ?&lt;/p&gt;

&lt;p&gt;Please correct me if I am loosing the track.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Ravi.&lt;/p&gt;</comment>
                            <comment id="12734774" author="mikedd" created="Thu, 23 Jul 2009 21:43:52 +0100"  >&lt;p&gt;Hi Ravi,&lt;/p&gt;

&lt;p&gt;I&apos;m sorry, I misread the test results I&apos;d made some changes and may have changed the testcase.&lt;/p&gt;

&lt;p&gt;I believe that both times the expected result should be 10 AItems (pretend A is unversioned). The last commit contains an instance of A, which is related to 10 AItems. A has a OneToMany unidirectional relationship with AItem. Since AItem does not have a relationship with A, A is the owner of the relationship. So the last transaction to update A:id=1 wins (or at least so I thought).&lt;/p&gt;

&lt;p&gt;It&apos;s very interesting that the behavior is different when you add more changes (exceed 10).&lt;/p&gt;

&lt;p&gt;What bothers me about it is that you&apos;ve updated a versioned entity (newA and result2) twice but didn&apos;t get an Optimistic Lock Exception. I&apos;d think this is the correct behavior in this case (because A owns the relationship, it&apos;s really A that gets updated). That won&apos;t help for unversioned entities though - they&apos;ll still get the odd behavior you&apos;ve found.&lt;/p&gt;</comment>
                            <comment id="12734861" author="rpalache" created="Fri, 24 Jul 2009 02:10:59 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;Thanks a lot for spending your time on this.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; It&apos;s very interesting that the behavior is different when you add more changes (exceed 10).&lt;/p&gt;

&lt;p&gt;CollectionChangeTrackerImpl.add() and remove() methods should give more info about this.&lt;br/&gt;
If the number of added objects plus the number of removed objects are greater than collection size, ChangeTracker is forcefully disabled.&lt;br/&gt;
If ChangeTracker is disabled, OpenJPA update strategy is delete all and re-insert all objects.&lt;br/&gt;
So while insert-all it can not see the objects inserted as part of em2 ( in my sample).&lt;br/&gt;
Hence this bug.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; What bothers me about it is that you&apos;ve updated a versioned entity (newA and result2) twice but didn&apos;t get an Optimistic Lock Exception. &lt;/p&gt;

&lt;p&gt;Excellent concern.&lt;br/&gt;
I was thinking previously that AItem objects modified in tran 1 and tran 2 does not interfere with each other and hence should not result in optimistic lock excpetion.&lt;br/&gt;
Now I understand that both tran 1 and tran 2 are working on same row of A , which mean at the time of tran1 commit I should get optimistic lock exception.&lt;/p&gt;

&lt;p&gt;I verified the reason why I am not getting optimistic lock exception and I changed the method level version annotation to field level.&lt;br/&gt;
Now I got optimistic lock errors when I set the version annotation on field rather than on method.&lt;br/&gt;
I think version annotation on methods has some issue.&lt;/p&gt;

&lt;p&gt;With version annotation on method, when I check the db tables then I do not see the corresponding version column.&lt;br/&gt;
After adding version attribute to the field I can see version column on the table and getting optimistic lock exception.&lt;/p&gt;

&lt;p&gt;So in my example, both A and AItems are treated as non versioned entities.&lt;/p&gt;

&lt;p&gt;In the process of answering your concerns, I realized that I definitely have to revisit my testcase.&lt;br/&gt;
I will try to modify the test case such that it properly demonstrates the current issue.&lt;br/&gt;
I think the issue defined in this JIRA is valid but my test case needs to be revisited.&lt;br/&gt;
Do you agree with this ?&lt;/p&gt;

&lt;p&gt;Thanks again,&lt;br/&gt;
Ravi.&lt;/p&gt;</comment>
                            <comment id="12735217" author="rpalache" created="Sat, 25 Jul 2009 01:30:12 +0100"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I simplified the test case now.&lt;br/&gt;
It has only one entity &quot;A&quot;.&lt;br/&gt;
A in unversioned and it has an id ( primary key), name, age and a map.&lt;/p&gt;

&lt;p&gt;A&apos;s initialValues :&lt;br/&gt;
    A(id,age,name,map) =     A (1, 30, &quot;Initial&quot;, 0-9 ( size of 10).&lt;/p&gt;

&lt;p&gt;Trans1 :&lt;br/&gt;
    A.Age = 40;&lt;br/&gt;
    Remove 8 elements in Map.&lt;br/&gt;
    Add 8 elements to Map (10 - 17)&lt;br/&gt;
Trans2: &lt;br/&gt;
    A.Name = &quot;Changed&quot;&lt;br/&gt;
    Add 8 elements to Map (20 - 27)&lt;/p&gt;

&lt;p&gt;Commit Trans2 .&lt;br/&gt;
Commit Trans1.&lt;/p&gt;

&lt;p&gt;Results :&lt;/p&gt;

&lt;p&gt;A&apos;s values :&lt;br/&gt;
    A(id,age,name,map) =     A (1, 40, &quot;Changed Name&quot;, 8,9,10-17 ( size of 10).&lt;/p&gt;

&lt;p&gt;The same when repeated with adding &amp;amp; removing 3 elements ( instead of 8)&lt;br/&gt;
then A&apos;s values :&lt;br/&gt;
    A(id,age,name,map) =     A (1, 40, &quot;Changed Name&quot;, 3-9,10-12,20-22 ( size of 13).&lt;/p&gt;

&lt;p&gt;The question is which behavior in the above is true ?&lt;/p&gt;

&lt;p&gt;Should the whole Map be replaced by Trans 1 ( as it is last committed) (or)&lt;br/&gt;
Should the Map be a combination of changes made in Trans1 and Trans2 ?&lt;/p&gt;

&lt;p&gt;If you see the other values of A; the changes made to age and name by Trans1 and 2 are both considered.&lt;br/&gt;
When it comes to map the results are different.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Ravi.&lt;/p&gt;</comment>
                            <comment id="12738175" author="rpalache" created="Mon, 3 Aug 2009 04:00:29 +0100"  >&lt;p&gt;The attached patch contains fix along with the testcase.&lt;br/&gt;
This will take autoOff parameter from openjpa.compatibility option.&lt;br/&gt;
The default option is what ever existing currently with out the patch.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Ravi.&lt;/p&gt;</comment>
                            <comment id="12738444" author="rpalache" created="Mon, 3 Aug 2009 18:33:20 +0100"  >&lt;p&gt;Forgot to attach the testcase.&lt;br/&gt;
The current patch contains both the test case and fix.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Ravi.&lt;/p&gt;</comment>
                            <comment id="12738586" author="mikedd" created="Mon, 3 Aug 2009 22:06:05 +0100"  >&lt;p&gt;Hi Ravi,&lt;/p&gt;

&lt;p&gt;Great testcases (sorry this was a long time coming). I wouldn&apos;t recommend using this approach for relationships but the PersistentCollection is an interesting wrinkle.&lt;/p&gt;

&lt;p&gt;Thanks very much for your hard work on this issue. &lt;/p&gt;</comment>
                            <comment id="12739308" author="ppoddar@apache.org" created="Wed, 5 Aug 2009 02:51:32 +0100"  >&lt;p&gt;Hi Ravi/Mike, &lt;br/&gt;
As you have analyzed the issue, do you think&lt;br/&gt;
  1. is this earlier value of autoOff considered a defect? Or a behavior that we must retain with a Compatibility option?&lt;/p&gt;

&lt;p&gt;If it is ony a defect that was not exposed till this issue then there may not be a strong case for a compatibility option.&lt;/p&gt;

&lt;p&gt;If it not a defect and we need to retain both the old value and the new value, then instead of adding a separate compatibility option, consider &lt;br/&gt;
autooff as one more configurable option of ProxyManager. ProxyManager already have few boolean configurable properties so this new&lt;br/&gt;
choice will fit neatly (also the patch footprint will reduce). &lt;br/&gt;
If this issue is not a defect then the default value should remain as before. But documentation should explain when the configuration should be switched.&lt;br/&gt;
If this issue is a defect then the default value should flip. But documentation should explain how the configuration could be switched to backward compatible behavior&lt;/p&gt;</comment>
                            <comment id="12739602" author="rpalache" created="Wed, 5 Aug 2009 17:47:29 +0100"  >&lt;p&gt;&amp;gt;&amp;gt; If this issue is a defect then the default value should flip.&lt;/p&gt;

&lt;p&gt;The reason for not switching the default value is because I am not completely confident that the previous behavior is a defect. &lt;br/&gt;
So without confirmation of whether it is a defect or not, I felt it is convenient for existing applications using the current default&lt;br/&gt;
 value to upgrade to latest versions without the need for any additional properties. Also there is a doc JIRA (&lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-1223&quot; title=&quot;Update documentation for autoOff config option&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-1223&quot;&gt;&lt;del&gt;OPENJPA-1223&lt;/del&gt;&lt;/a&gt;) opened for documenting this.&lt;/p&gt;

&lt;p&gt;In my opinion the previous value is a defect.&lt;br/&gt;
May be I am wrong but I think it is a defect based on the following :&lt;/p&gt;

&lt;p&gt;1)  The previous default behavior is as follows:&lt;br/&gt;
    When the number of modifications(add/remove) to a collection exceeds the initial size of collection then the logic is to&lt;br/&gt;
    remove everything from collection and re-insert the objects. In the process of re-inserting it will not consider data &lt;br/&gt;
    that is modified as part of another transaction.&lt;/p&gt;

&lt;p&gt;    So, the end result is that the data inserted into database is dependent on the number of modifications made on the collection.&lt;br/&gt;
    I think it is bug as the data inserted into the database should be consistent irrespective of the number of modifications &lt;br/&gt;
    made to the collection.&lt;/p&gt;

&lt;p&gt;2)  When the data modified in two concurrent transactions does not interfere with each other then both the transactions should win.&lt;br/&gt;
    For example, let&apos;s consider table A which has 5 rows ( primary key of int 1-5) and has row level locking. &lt;br/&gt;
    Transaction 1 tries to modify rows 1 -3 and transaction 2 modifies 4-5 at the same time.&lt;br/&gt;
    In this case I think both the transactions has to win.&lt;br/&gt;
    The above is not possible with default value of autoOff, when the # of modifications to A exceeds 5.&lt;/p&gt;

&lt;p&gt;If you think adding an option to ProxyManager is a better fit than compatibility configuration then I will modify my fix.&lt;br/&gt;
Can I please ask, if there is any additional advantage with it other than patch footprint.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Ravi.&lt;/p&gt;</comment>
                            <comment id="12739687" author="mikedd" created="Wed, 5 Aug 2009 20:23:13 +0100"  >&lt;p&gt;&amp;gt;    So, the end result is that the data inserted into database is dependent on the number of modifications made on the collection.&lt;br/&gt;
&amp;gt;    I think it is bug as the data inserted into the database should be consistent irrespective of the number of modifications&lt;br/&gt;
&amp;gt;    made to the collection. &lt;/p&gt;

&lt;p&gt;I agree, the number of modifications should not have an affect. &lt;/p&gt;

&lt;p&gt;&amp;gt; 2) When the data modified in two concurrent transactions does not interfere with each other then both the transactions should win.&lt;br/&gt;
&amp;gt;    For example, let&apos;s consider table A which has 5 rows ( primary key of int 1-5) and has row level locking.&lt;br/&gt;
&amp;gt;    Transaction 1 tries to modify rows 1 -3 and transaction 2 modifies 4-5 at the same time.&lt;br/&gt;
&amp;gt;    In this case I think both the transactions has to win.&lt;/p&gt;

&lt;p&gt;IMO this really depends on who owns the relationship or the collection. &lt;/p&gt;

&lt;p&gt;For example this model :&lt;br/&gt;
@Entity &lt;br/&gt;
public class Manager &lt;/p&gt;
{
    @OneToMany(mappedBy=&quot;manager&quot;)
    private Collection&amp;lt;Employee&amp;gt; employees;
}

&lt;p&gt;@Entity&lt;br/&gt;
public class Employee &lt;/p&gt;
{ 
    @ManyToOne
    private Manager manager; 
}

&lt;p&gt;Employee owns the relationship, and the employee table has a foreign key. Any Employees with a FK -&amp;gt; a particular manager are considered that manager&apos;s Employees. In this case we should see the behavior Ravi is advocating. &lt;/p&gt;

&lt;p&gt;The following example is slightly different : &lt;br/&gt;
@Entity &lt;br/&gt;
public class Manager &lt;/p&gt;
{
    @OneToMany
    private Collection&amp;lt;Employee&amp;gt; employees;
}

&lt;p&gt;@Entity&lt;br/&gt;
public class Employee &lt;/p&gt;
{ 
    // no reference to Manager.
}

&lt;p&gt;In this case Manager is the owner of the relationship and the Manager object owns the relationship and the set of Employees. In this case I&apos;m less certain how we should behave. My original take was that the last to commit wins - Manager owns the state of the relationship and bears the sole burden of maintaining it. &lt;/p&gt;

&lt;p&gt;I&apos;m not sure that&apos;s the ideal solution, but I didn&apos;t feel confident enough in the answer to change the default. &lt;/p&gt;</comment>
                            <comment id="12740755" author="dezzio" created="Fri, 7 Aug 2009 22:37:06 +0100"  >&lt;p&gt;From trunk, merged fix to 1.1.x branch at rev 802218&lt;/p&gt;</comment>
                            <comment id="12756713" author="drwoods" created="Thu, 17 Sep 2009 20:15:33 +0100"  >&lt;p&gt;add missing Fix version for trunk&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12432095">OPENJPA-1223</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12415375" name="OPENJPA-1163_trunk.patch" size="32565" author="rpalache" created="Mon, 3 Aug 2009 18:33:20 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 21 Jul 2009 03:18:49 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>38636</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12310041" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Patch Info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10042"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt2qf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203623</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>