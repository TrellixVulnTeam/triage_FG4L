<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:39:18 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-1873/OPENJPA-1873.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-1873] EntityManager#merge sometimes passes wrong entity values to @PostLoad EntityListeners </title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-1873</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;I&apos;ve tested this with the latest from branches/2.0.x.&lt;/p&gt;

&lt;p&gt;My entity has an @EntityListeners which observes the @PostLoad lifecycle event. This listener stores the &apos;old&apos; values from the database for later use (see &lt;a href=&quot;http://struberg.wordpress.com/2010/07/31/howto-changelog-with-jpa/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://struberg.wordpress.com/2010/07/31/howto-changelog-with-jpa/&lt;/a&gt; for the intention behind). All works well if the table has only a few rows. But if you add more rows, OpenJPA tries to optimize the access and only loads the @Version field + the dirty fields. In this case the merging seems to be wrong, because I get the NEW values from the dirty fields instead of the original values from the database passed to my @PostLoad method.&lt;/p&gt;

&lt;p&gt;Did cost me a few grey hairs to track down the differences between the working and the broken scenarios here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But finally I was able to creat a unit test showing the problem&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12479138">OPENJPA-1873</key>
            <summary>EntityManager#merge sometimes passes wrong entity values to @PostLoad EntityListeners </summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="struberg">Mark Struberg</assignee>
                                    <reporter username="struberg">Mark Struberg</reporter>
                        <labels>
                    </labels>
                <created>Thu, 4 Nov 2010 19:57:14 +0000</created>
                <updated>Thu, 2 Feb 2012 16:59:53 +0000</updated>
                            <resolved>Thu, 8 Dec 2011 14:59:07 +0000</resolved>
                                    <version>2.0.0</version>
                    <version>2.0.1</version>
                    <version>2.0.2</version>
                                    <fixVersion>2.2.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12928326" author="struberg" created="Thu, 4 Nov 2010 19:59:21 +0000"  >&lt;p&gt;this unit test shows the problem. If you comment out value2 .. value12 in PostLoadListenerEntity.java, then all works fine.&lt;/p&gt;

&lt;p&gt;In the meantime: is there a config option to disable this optimisation behaviour?&lt;/p&gt;</comment>
                            <comment id="12929812" author="curtisr7" created="Mon, 8 Nov 2010 23:29:21 +0000"  >&lt;p&gt;My first thoughts on this are that the merge operation shouldn&apos;t result in a postLoad() callback... Nothing from the DB is actually being placed in the persistence context.&lt;/p&gt;

&lt;p&gt;The only reason OpenJPA is hitting the DB is to see if the merged Entity is dirty. In the case where there is no version, we need to hit the DB to compare the dirty fields to those in the DB. In the case where there is a version field, we will only load that field... not the entire Entity. &lt;/p&gt;</comment>
                            <comment id="12929819" author="struberg" created="Mon, 8 Nov 2010 23:40:38 +0000"  >&lt;p&gt;Rick, the merge acutally does much more than simply loading the version field. It additionally loads all fields which are marked as &apos;dirty&apos; from the database. &lt;/p&gt;

&lt;p&gt;From the spec 3.1.1 EntityManager Interface&lt;br/&gt;
Merge the state of the given entity into the&lt;br/&gt;
current persistence context.&lt;br/&gt;
@return the managed instance that the state was merged to&lt;/p&gt;

&lt;p&gt;and &apos;managed instance&apos; is a well defined term in this spec which afaik means an entity which got loaded from the database.&lt;/p&gt;
</comment>
                            <comment id="12930105" author="struberg" created="Tue, 9 Nov 2010 12:08:39 +0000"  >&lt;p&gt;I did further debugging.&lt;/p&gt;

&lt;p&gt;In the DetachedStateManager #165 (right after the dirty check and reload of all those fields: Object origVersion = sm.getVersion(); ) the sm (StateManagerImpl) contains the correct entity values from the db in _pc!&lt;/p&gt;

&lt;p&gt;of course they get replaced with the values from toAttach before the @PostLoad gets fired.&lt;/p&gt;

&lt;p&gt;There are 2 options now:&lt;/p&gt;

&lt;p&gt;a) dont fire the @PostLoad at all for EM#merge - because the load data in the event is definitely wrong currently&lt;br/&gt;
b) first merge the non-dirty fields back to the sm._pc before firing the @PostLoad event and then do the toAttach merge.&lt;/p&gt;

&lt;p&gt;I&apos;d obviously prefer option b &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12930120" author="curtisr7" created="Tue, 9 Nov 2010 13:56:01 +0000"  >&lt;p&gt;Unfortunately option a.) gets my vote. &lt;/p&gt;

&lt;p&gt;Theoretically we shouldn&apos;t be hitting the DB at all for this Entity since we have a DetachedStateManager and we know which fields are dirty... so there isn&apos;t a need to load anything.&lt;/p&gt;</comment>
                            <comment id="12930126" author="struberg" created="Tue, 9 Nov 2010 14:09:53 +0000"  >&lt;p&gt;but it seems that EclipseLink and Hibernate both fire the @PostLoad event for a merge. &lt;br/&gt;
And albeit it is not 100% clear from the spec, there is a lot evidence that this behaviour is intended.&lt;/p&gt;

&lt;p&gt;edit: the wording from the PostLoad + merge (3.2.7.1) + &apos;managed instance&apos; in the spec indicate that @PostLoad should get fired if the merging gets called on a detached entity which exists in the database.&lt;/p&gt;</comment>
                            <comment id="12930166" author="kwsutter" created="Tue, 9 Nov 2010 15:30:18 +0000"  >&lt;p&gt;Hi guys,&lt;br/&gt;
My two cents worth...  I don&apos;t think the spec indicates that the @PostLoad should get fired on a merge() operation.  I do agree that if the merge() operation requires loading from the database, then the @PostLoad should get fired.  But, I don&apos;t see in the spec where it says that the merge() operation demands a load from the database (and thus the @PostLoad).&lt;/p&gt;

&lt;p&gt;Section 3.2.7.1 states:&lt;/p&gt;

&lt;p&gt;&quot;If X is a detached entity, the state of X is copied onto a pre-existing managed entity instance X&apos;&lt;br/&gt;
of the same identity or a new managed copy X&apos; of X is created.&quot;&lt;/p&gt;

&lt;p&gt;Since OpenJPA utilizes a &quot;detached state manager&quot;, that would constitute a pre-existing managed entity instance and there would be no requirement to go to the database.  If you think about it, this would be a good thing to avoid extra, unnecessary trips to the database.&lt;/p&gt;

&lt;p&gt;Now, if your detached entity does not use a &quot;detached state manger&quot; &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, then we probably have to go to the database (like the other providers) to load up the current state into a new managed copy and then merge in the updated values.  From side conversations with Rick, this processing may not be working quite right, but that&apos;s how I am reading the spec and the scenario described here.&lt;/p&gt;

&lt;p&gt;The other interesting piece from 3.2.7.1 is this:&lt;/p&gt;

&lt;p&gt;&quot;Any Version columns used by the entity must be checked by the persistence runtime implementation&lt;br/&gt;
during the merge operation and/or at flush or commit time. In the absence of Version columns there is&lt;br/&gt;
no additional version checking done by the persistence provider runtime during the merge operation.&quot;&lt;/p&gt;

&lt;p&gt;Earlier comments by Rick seemed to indicate that the absence of an @Version field would be a reason to access the database during merge().  This paragraph seems to indicate that this version checking should not be done during merge()...&lt;/p&gt;

&lt;p&gt;This looks to be a good problem.  I think we have an issue or two to resolve here.  We just need to come to a consensus.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;  &lt;a href=&quot;http://openjpa.apache.org/builds/2.0.1/apache-openjpa-2.0.1/docs/manual/manual.html#ref_guide_detach_state&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://openjpa.apache.org/builds/2.0.1/apache-openjpa-2.0.1/docs/manual/manual.html#ref_guide_detach_state&lt;/a&gt; &lt;/p&gt;</comment>
                            <comment id="12930171" author="curtisr7" created="Tue, 9 Nov 2010 15:39:37 +0000"  >&lt;p&gt;&amp;gt; but it seems that EclipseLink and Hibernate both fire the @PostLoad event for a merge. &lt;br/&gt;
Point noted.&lt;/p&gt;

&lt;p&gt;3.5.2 &amp;#8211; &quot;The PostLoad method for an entity is invoked after the entity has been loaded into the current persistence&lt;br/&gt;
context from the database or after the refresh operation has been applied to it.&quot;&lt;/p&gt;

&lt;p&gt;Most of my argument is based off the part which says &quot;from the database&quot;. In the case of this merge, OpenJPA has a DetachedStateManager so we &lt;b&gt;shouldn&apos;t&lt;/b&gt; need to hit to DB to see which fields are dirty. I think we have a bug here where we hit the DB even though we don&apos;t need to. &lt;/p&gt;

&lt;p&gt;I believe that the other providers aren&apos;t working per the spec. Upon merge being called, they may need to hit the DB to compare merged fields with those in the DB to see which are dirty/clean... but that data isn&apos;t actually loaded into the persistence context. They are loading data for the sake of version checking, not for loading in the context. &lt;/p&gt;

&lt;p&gt;I&apos;ll note that Pinaki wrote a blog post&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; quite some time back doing something very similar. It might be worth a read. It looks like the formatting is messed up so let me know if you want the full text.&lt;/p&gt;

&lt;p&gt;Quite the hair splitting for this early in the morning &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://webspherepersistence.blogspot.com/2009/01/auditing-with-openjpa.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://webspherepersistence.blogspot.com/2009/01/auditing-with-openjpa.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12930184" author="struberg" created="Tue, 9 Nov 2010 16:32:09 +0000"  >&lt;p&gt;Hi! Just verified that @PostLoad gets fired in Hibernate. See the attached little maven project.&lt;/p&gt;</comment>
                            <comment id="12931436" author="curtisr7" created="Fri, 12 Nov 2010 16:30:55 +0000"  >&lt;p&gt;@Mark -&lt;/p&gt;

&lt;p&gt;Thoughts on Kevin&apos;s last post?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Rick&lt;/p&gt;</comment>
                            <comment id="12931440" author="struberg" created="Fri, 12 Nov 2010 16:40:26 +0000"  >&lt;p&gt;I&apos;m very interested why OpenJPA currently loads the dirty fields from the database (in a manner which in the logs looks like it&apos;s doing multiple database interactions!) instead only &lt;em&gt;loading&lt;/em&gt; the version (if present). &lt;/p&gt;

&lt;p&gt;Fact: a @PostLoad must get called after loading from the database. Thus I&apos;d say that it needs to get called even if entities only got loaded partly. But the spec also defines that the &lt;em&gt;entity&lt;/em&gt; from the db needs to get posted. Currently we get a mix between old and new values in @PostLoad which (I think we agree) is wrong.&lt;/p&gt;

&lt;p&gt;Also quoting from the spec posted above:&lt;br/&gt;
&quot;In the absence of Version columns there is no additional version checking done by the persistence provider runtime during the merge operation.&quot;&lt;/p&gt;

&lt;p&gt;I interpret is that in reverse it should be checked on #merge if an @Version is present.&lt;/p&gt;</comment>
                            <comment id="12931452" author="curtisr7" created="Fri, 12 Nov 2010 17:31:01 +0000"  >&lt;p&gt;&amp;gt; I&apos;m very interested why OpenJPA currently loads the dirty fields from the database (in a manner which in the logs looks like it&apos;s doing multiple database interactions!) instead only &lt;em&gt;loading&lt;/em&gt; the version (if present). &lt;br/&gt;
It sounds like a bug.&lt;/p&gt;

&lt;p&gt;&amp;gt; a @PostLoad must get called after loading from the database.&lt;br/&gt;
The spec says that @PostLoad must get called after data gets loaded from the database INTO the persistence context. If the provider is loading from the DB, but it isn&apos;t going into the context, I don&apos;t think we need to do the callback.&lt;/p&gt;

&lt;p&gt;Also, since OpenJPA has this smart DetachedStateManager, we shouldn&apos;t need to load anything from the database on merge. We currently do (as noted above) but I think we have a bug.&lt;/p&gt;</comment>
                            <comment id="12931463" author="struberg" created="Fri, 12 Nov 2010 17:42:58 +0000"  >&lt;p&gt;Do we have someone representing the ASF on this JSR in the EG? If not I could ping a few guys on the EG or even ask on the eclipselink list.&lt;br/&gt;
I&apos;d rather like to get this confirmed before we implement it the wrong way.&lt;/p&gt;</comment>
                            <comment id="12931475" author="curtisr7" created="Fri, 12 Nov 2010 18:01:35 +0000"  >&lt;p&gt;&amp;gt; Do we have someone representing the ASF on this JSR in the EG? &lt;br/&gt;
Yes Kevin and Pinaki are both on the EG. I&apos;ll get one of them to comment on this issue early next week.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;d rather like to get this confirmed before we implement it the wrong way.  &lt;br/&gt;
Agreed.&lt;/p&gt;</comment>
                            <comment id="12932653" author="ppoddar@apache.org" created="Tue, 16 Nov 2010 20:58:05 +0000"  >&lt;p&gt;Mark,&lt;br/&gt;
  1. is the attached test in PostLoadTest.zip supposed to pass or fail?&lt;/p&gt;

&lt;p&gt;  you wrote:&lt;br/&gt;
&amp;gt; Fact: a @PostLoad must get called after loading from the database. Thus I&apos;d say that it needs to get called even if entities only got loaded partly. &lt;br/&gt;
  I tend of agree. The notion of &apos;loaded partly&apos; does not exist in the spce &amp;#8211; it is an implementation issue. &lt;br/&gt;
 However, my view is that the lifecycle callback methods are tied to instance life cycle state transitions and not directly to operational  methods such as find() or merge(). Of course, an operational method may cause a life cycle state transition. For example, a PostLoad callback is invoked when an entity state is loaded from the database. But whether a merge() operation will cause an entity state be loaded from database or not can vary based on other factors. &lt;br/&gt;
Hence a question such as &quot;does merge() must invoke postLoad()?&quot; may not offer a definite answer. &quot;Vendor X invoked postLoad() on merge()&quot; &amp;#8211; is not convincing enough  for me. &lt;/p&gt;


&lt;p&gt;&amp;gt; But the spec also defines that the &lt;em&gt;entity&lt;/em&gt; from the db needs to get posted. &lt;/p&gt;

&lt;p&gt;   Can you please elaborate this point? Are you suggesting that the state of the argument instance of postLoad() method should represent the database values? If that is the case, then I do not agree. The postLoad() will see the state of the instance &lt;b&gt;after&lt;/b&gt; the provider has loaded the instance in to its context &amp;#8211; some of the properties can come from the database, some can come from the user-supplied instance  &amp;#8211; but the state as presented to the postLoad() method argument must be &apos;consistent&apos; &amp;#8211; meaning it must be the exact same state that the persistence context holds and will eventually be committed if nothing changes further.&lt;/p&gt;

&lt;p&gt;&amp;gt; Currently we get a mix between old and new values in @PostLoad which (I think we agree) is wrong. &lt;/p&gt;

&lt;p&gt;  Such a mix, if proven, is inconsistent.  But I could not see how the test you have submitted exposes such inconsistent behavior. &lt;/p&gt;


</comment>
                            <comment id="12932684" author="struberg" created="Tue, 16 Nov 2010 22:17:03 +0000"  >&lt;p&gt;Hi Pinaki!&lt;/p&gt;

&lt;p&gt;The test contains a test entity PostLoadListenerEntity.&lt;br/&gt;
This  entity contains a field &apos;value&apos; which I use in the test.&lt;br/&gt;
If you add ONE single other value to the entity, the Object in the @PostLoad listener has a different value.&lt;/p&gt;

&lt;p&gt;Please comment out value2 to value12 in this entity (only id and value enabled) and rerun the test - it will pass now.&lt;br/&gt;
Then comment value2 or any other additional field back in -&amp;gt; the test will fail.&lt;br/&gt;
This is really inconsistent and should get fixed&lt;/p&gt;

&lt;p&gt;Btw I do not agree with you on the value of the @PostLoad data.&lt;br/&gt;
The spec says: &lt;br/&gt;
3.5.2&lt;br/&gt;
&quot;The PostLoad method for an entity is invoked after the entity has been loaded into the current persis-&lt;br/&gt;
tence context from the database or after the refresh operation has been applied to it.&quot;&lt;/p&gt;

&lt;p&gt;and for the merge:&lt;br/&gt;
3.1.1 &quot;Merge the state of the given entity into the current persistence context.&quot; &lt;br/&gt;
3.2.7.1 &quot;The merge operation allows for the propagation of state from detached entities onto persistent entities managed by the entity manager.&quot; + &quot;If X is a detached entity, the state of X is copied onto a pre-existing managed entity instance X&apos; of the same identity or a new managed copy X&apos; of X is created.&quot;&lt;/p&gt;

&lt;p&gt;I interpret this that  the value we need to hand to the @PostLoad method ist per spec the state of the entity &lt;em&gt;before&lt;/em&gt; the merge.&lt;br/&gt;
The only thing we imo can take into question is if the @PostLoad needs to get called at all. Section 3.2.7 at least gives a few answers where we for sure do not need to load it - but 3.2.7.1 imo says that we should for merging detached entities:&lt;/p&gt;

&lt;p&gt;3.2 &quot;A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.&quot;&lt;/p&gt;

&lt;p&gt;Of course you can say we don&apos;t need to go to the database to ensure the &apos;managed entity&apos; has a &apos;persistent identity&apos; but then you will fail if the database has been changed outside your application. Thus a load from the database is really required. &lt;/p&gt;

&lt;p&gt;I know that we only need to do what the spec says and not what any other JPA implementation does. But if 3 other major JPA impls act this way, than it might be a strong indicator at least &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;txs and LieGrue,&lt;br/&gt;
strub&lt;/p&gt;</comment>
                            <comment id="12936069" author="struberg" created="Fri, 26 Nov 2010 18:10:27 +0000"  >&lt;p&gt;The bug doesn&apos;t appear if I use&lt;/p&gt;

&lt;p&gt; &amp;lt;property name=&quot;openjpa.DetachState&quot; value=&quot;fetch-groups&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;So this is definitely a bug imo, because OpenJPA must return the same results regardless which detach strategy one uses.&lt;/p&gt;</comment>
                            <comment id="12978771" author="struberg" created="Fri, 7 Jan 2011 13:16:29 +0000"  >&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;This is just a small summary about the discussions I had with Rick at our yesterdays debugging session.&lt;/p&gt;

&lt;p&gt;It seems that the DetachStateManager is almost in the original state as imported by Patrick in early 2006 and might not reflect all things needed for JPA2.&lt;/p&gt;

&lt;p&gt;The attach() in line #108 is of special interrest. It consists of 3 parts:&lt;/p&gt;

&lt;p&gt;1.) (line #131 - #166) prepare old Values from the database to be able to restore those values in case of a rollback.&lt;br/&gt;
 comment: Imo this is NOT needed if openjpa.RestoreState is RESTORE_NONE!&lt;/p&gt;

&lt;p&gt;2.) (handled in the same block somehow) if optimistic locking is used (does the whole merging make any sense for row-locking at all?): Check the version in the database to make sure that we didn&apos;t have a concurrent modification already.&lt;/p&gt;

&lt;p&gt;3.) (line #168 - #295) perform the actual &apos;merging&apos;. by setting the values from the toAttach entity into the one from the DB.&lt;/p&gt;

&lt;p&gt;so far so good.&lt;/p&gt;

&lt;p&gt;Now to the problematic spots. &lt;/p&gt;

&lt;p&gt;Depending on the situation (_loaded and _dirty states) 1.) xor 3.) fire the @PostLoad event. The logic for the lifecyle event is to get fired if all fields (or all fields of a FetchGroup if fgs are used) got set. If all fields have been made dirty in the detached entity then this will happen in 1.) If not, it will happen in 3.). The problem here is that in 1.) the entity from the DB is not complete and in 3.) has nothing to do with any load from the database, since it contains the dirty values from the toAttach entity.&lt;/p&gt;

&lt;p&gt;It&apos;s really problematic that both the load() from the database and the attach() use the same StateManagerImpl#storeStringField() without any distinction. So those highly different tasks will both fire the same @PostLoad lifecycle event. Imo this must not happen while attaching.&lt;/p&gt;

&lt;p&gt;Rick, are you d&apos; accord so far?&lt;/p&gt;</comment>
                            <comment id="12978870" author="curtisr7" created="Fri, 7 Jan 2011 17:17:14 +0000"  >&lt;p&gt;Attaching a hack for Mark to play around with.&lt;/p&gt;</comment>
                            <comment id="12979042" author="struberg" created="Sat, 8 Jan 2011 00:43:35 +0000"  >&lt;p&gt;Hi Rick!&lt;/p&gt;

&lt;p&gt;Here is my first take on the problem based on your initial suggestion. &lt;/p&gt;

&lt;p&gt;What do you think about introducing a configuration parameter like openjpa.PostLoadOnMerge ?&lt;/p&gt;

&lt;p&gt;There is a line in the patch marking the right spot:&lt;br/&gt;
boolean postLoadOnMerge = true; //X make this configurable&lt;/p&gt;

&lt;p&gt;It seems to run fine in my real world application, but I just need to start the full OpenJPA compile with tests enabled over the night. So possibly still something left to fix...&lt;/p&gt;
</comment>
                            <comment id="12979044" author="struberg" created="Sat, 8 Jan 2011 00:53:13 +0000"  >&lt;p&gt;one thing: we should possibly suppress firing of the PostLoad event if postLoadOnMerge == false when reading the dirty attributes from the db.&lt;br/&gt;
Because this still gets fired if all attributes have been dirty in the detached entity. Currently you sometimes get the @PostLoad called on merge, sometimes not ...&lt;/p&gt;</comment>
                            <comment id="12979124" author="struberg" created="Sat, 8 Jan 2011 12:46:03 +0000"  >&lt;p&gt;and here comes the next one, this time with a new &apos;openjpa.PostLoadOnMerge&apos; configuration property.&lt;/p&gt;

&lt;p&gt;Tests are currently running....&lt;/p&gt;

&lt;p&gt;LieGrue,&lt;br/&gt;
strub&lt;/p&gt;</comment>
                            <comment id="13164623" author="struberg" created="Wed, 7 Dec 2011 19:02:53 +0000"  >&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;I&apos;ve now updated my patch to apply cleanly to the latest trunk!&lt;/p&gt;

&lt;p&gt;This is tested in 2 big real world projects and works fine now since a year. This is really an important issue, because currently the POST_LOAD lifecycle listeners are really broken. They e.g. currently also being called for parts which are lazily loaded - and in this case the lifecycle listener will get completely wrong data handed over!&lt;/p&gt;

&lt;p&gt;My patch is non-invasive because the &apos;fixed&apos; handling will only be used if POST_LOAD_ON_MERGE gets enabled in persistence.xml.&lt;/p&gt;

&lt;p&gt;If noone objects, I&apos;ll go on and commit the patch tomorrow.&lt;/p&gt;</comment>
                            <comment id="13165702" author="kwsutter" created="Fri, 9 Dec 2011 00:11:52 +0000"  >&lt;p&gt;Mark,&lt;br/&gt;
Your patch/commit looks pretty straight forward.  The JIRA has such a long history, I was wondering what you finally decided to resolve.  It looks like you have provided a new property (openjpa.PostLoadOnMerge) which will tell OpenJPA to call the PostLoad listener on every Merge.  If that&apos;s accurate, then some documentation updates would be good to have so that users know about this new property.  Thanks.&lt;/p&gt;

&lt;p&gt;I also noticed that you updated the OpenJPAConfiguration file to define the OPTION_POSTLOAD_ON_MERGE string.  I don&apos;t believe these are really even used any more.  It looks like maybe this was the old (original) way to specify properties, but the updated plugin configuration is much easier &amp;#8211; which you also implemented.  Maybe I&apos;m mistaken, but I don&apos;t think you need the OPTION_POSTLOAD_ON_MERGE updates.  Did you find that you required these?&lt;/p&gt;

&lt;p&gt;And, it looks like you resolved the problem with incorrect data being dispensed to the PostLoad listener on a Merge &amp;#8211; iff this new option is set. Is that correct?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="13166110" author="struberg" created="Fri, 9 Dec 2011 11:47:15 +0000"  >&lt;p&gt;Thanks for the review Kevin!&lt;/p&gt;

&lt;p&gt;Indeed, the problem I faced for a long time was that PostLoad was pretty much broken, because the payload entity you get into this event was always different, depending on the situation.&lt;/p&gt;

&lt;p&gt;I agree with what Rick and Pinaki pointed out above, that the spec is not really clear if PostLoad should get fired for a merge at all. But OpenJPA actually &lt;em&gt;did&lt;/em&gt; fire it in &lt;em&gt;some&lt;/em&gt; cases, and the entity which got handed to the event was a mixture between the entity in memory, the state on the database and the lazy-loaded delta. Again: it was not &lt;em&gt;one&lt;/em&gt; of those 3, but it was a weird mixture with some fields nulled out, etc. And it was depending on _loaded, _dirty and the detached state. So basically the PostLoad event was not usable for users once the entity got detached.&lt;/p&gt;

&lt;p&gt;Because of that, I would be in favour to even make PostLoadOnMerge enabled by default - but that&apos;s a policy decision which is not up to me to decide. Please note that the behaviour only got changed if there is any PostLoad lifecycle listener registered on the entity at all! &lt;br/&gt;
With the PostLoadOnMerge flag enabled, OpenJPA now behaves the same way as I saw with latest Hibernate and EclipseLink - I actually don&apos;t care much about those other impls, but I think it&apos;s at least not a bad thing &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I was not really sure about the String property based configuration, so I decided to go full route. If you say this is not supported anymore in openjpa-2.x, then we should think about Deprecating those parts at all?&lt;/p&gt;

&lt;p&gt;Regarding the documentation - thanks for the pointer! I thought those get generated out from the JavaDoc. Will fix those parts in the doc by adding the property.&lt;/p&gt;
</comment>
                            <comment id="13198951" author="allee8285" created="Thu, 2 Feb 2012 16:59:53 +0000"  >&lt;p&gt;Close issue in preparation for 2.2.0 release.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12467779" name="OPENJPA-1873-fix1.patch" size="17030" author="struberg" created="Sat, 8 Jan 2011 00:43:35 +0000"/>
                            <attachment id="12467792" name="OPENJPA-1873-fix2.patch" size="24555" author="struberg" created="Sat, 8 Jan 2011 12:46:03 +0000"/>
                            <attachment id="12506498" name="OPENJPA-1873-fix3.patch" size="28096" author="struberg" created="Wed, 7 Dec 2011 19:02:53 +0000"/>
                            <attachment id="12458842" name="OPENJPA-1873-unittest.patch" size="9639" author="struberg" created="Thu, 4 Nov 2010 19:59:20 +0000"/>
                            <attachment id="12467741" name="openjpa-1873-hack-1.patch" size="2706" author="curtisr7" created="Fri, 7 Jan 2011 17:17:13 +0000"/>
                            <attachment id="12459166" name="postloadtest.zip" size="11363" author="struberg" created="Tue, 9 Nov 2010 16:32:09 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 8 Nov 2010 23:29:21 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>162106</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt3hb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203744</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>