<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:29:46 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-343/OPENJPA-343.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-343] Do not call setRollbackOnly on inactive Transactions</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-343</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;While in the middle of processing an afterCompletion invocation in BrokerImpl, an unexpected RuntimeException (IndexOutOfBoundsException) occurred within some underlying WebSphere code.  While we (OpenJPA) were attempting to clean up after that exception, we attempted to call setRollbackOnly on the current transaction.  But, since we were in the process of completing the current transaction, it is invalid to be calling setRollbackOnly and we ended up getting an IllegalStateException from the WebSphere Transaction Manager.  Due this second exception, we ended up losing track of the original exception and this became a difficult problem to diagnose.&lt;/p&gt;

&lt;p&gt;This issue will be used to correct a couple of issues (at least):&lt;/p&gt;

&lt;p&gt;1)  We should ensure that the transaction is active before calling&lt;br/&gt;
setRollbackOnly().  When an exception happens during afterCompletion &lt;br/&gt;
processing, the Transaction can no longer accept setRollbackOnly &lt;br/&gt;
invocations.&lt;/p&gt;

&lt;p&gt;2)  When an unexpected exception happens like this, we should log the&lt;br/&gt;
exception before attempting to process the exception.  In this particular&lt;br/&gt;
case, we lost the original exception when we ran into the IllegalStateException&lt;br/&gt;
from the Transaction service.  This forced us to re-run the scenario just to&lt;br/&gt;
get a trace of the exception.&lt;/p&gt;

&lt;p&gt;3)  Or, if we don&apos;t want to log the exception immediately, we need to determine why we lost the first exception in the first place and ensure that doesn&apos;t happen again.&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</description>
                <environment></environment>
        <key id="12377093">OPENJPA-343</key>
            <summary>Do not call setRollbackOnly on inactive Transactions</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kwsutter">Kevin Sutter</assignee>
                                    <reporter username="kwsutter">Kevin Sutter</reporter>
                        <labels>
                    </labels>
                <created>Wed, 29 Aug 2007 14:15:21 +0100</created>
                <updated>Tue, 9 Mar 2010 18:32:38 +0000</updated>
                            <resolved>Tue, 4 Sep 2007 14:23:10 +0100</resolved>
                                    <version>0.9.7</version>
                    <version>1.0.0</version>
                                    <fixVersion>1.0.1</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12523962" author="kwsutter" created="Thu, 30 Aug 2007 23:47:19 +0100"  >&lt;p&gt;I should clarify a couple of statements.  I mixed Transaction and Synchronization concepts in the above description.  Since we are in the afterCompletion (Synchronization) processing, the Transaction is in a &quot;completed&quot; state and can no longer accept the setRollbackOnly invocation.  Although related, Transaction and Synchronization are two separate concepts and should treated as such.&lt;/p&gt;

&lt;p&gt;I plan to resolve issue (1) by checking for a valid transaction status before calling setRollbackOnly.  If the transaction is not in a suitable state, I will log a trace message indicating that the setRollbackOnly can not be called, but processing will continue.&lt;/p&gt;

&lt;p&gt;Re-looking at the code, I think we are already sufficiently addressing items (2) and (3), once issue (1) is resolved.  We already have the necessary trace logging for this unexpected exception.  Granted, we didn&apos;t expect this exception and it&apos;s a &quot;pain&quot; to turn on trace for long-running scenarios, the real exception that caused the problem in the first place will now get logged due to the fix for (1).  And, since OpenJPA doesn&apos;t have the concept of a first-failure-data-capture logging facility, it would get cumbersome to log every unexpected exception.&lt;/p&gt;

&lt;p&gt;So, my plans at this point are to just resolve the first issue (1) with ensuring that we do not attempt to call setRollbackOnly when the transaction can not accept it.  Comments welcome.&lt;/p&gt;

&lt;p&gt;Kevin&lt;/p&gt;</comment>
                            <comment id="12523976" author="clr" created="Fri, 31 Aug 2007 02:15:10 +0100"  >&lt;p&gt;I agree that 1) not calling setRollbackOnly during afterCompletion is correct.&lt;/p&gt;

&lt;p&gt;But when 2) an unexpected exception occurs during afterCompletion, like a NullPointerException, it seems that we should log the exception. Even though it&apos;s during afterCompletion, we shouldn&apos;t just swallow it. Of course, fixing 1) means that 2) can&apos;t be reliably reproduced. &lt;/p&gt;

&lt;p&gt;I&apos;m not clear on what 3) means. &lt;/p&gt;

&lt;p&gt;&amp;gt; I plan to resolve issue (1) by checking for a valid transaction status before calling setRollbackOnly. If the transaction is not in a suitable state, I will log a trace message indicating that the setRollbackOnly can not be called, but processing will continue. &lt;/p&gt;

&lt;p&gt;I guess the issue is whether this is a trace scenario or a more serious problem that should be reported back. We are still in commit as far as the application is concerned and it&apos;s not obvious to me that this is a successful transaction. I&apos;d think we should cause the outer level transaction to fail with a SystemException because the application handling is not consistent (the cache, for example, might be in an inconsistent state). If the application thinks everything is aok, then I think we have a problem.&lt;/p&gt;

&lt;p&gt;Craig&lt;/p&gt;</comment>
                            <comment id="12523983" author="kwsutter" created="Fri, 31 Aug 2007 03:40:51 +0100"  >&lt;p&gt;&amp;gt; I guess the issue is whether this is a trace scenario or a more serious problem that should be reported back. We are still in commit as far as the application is concerned and it&apos;s not obvious to me that this is a successful transaction. I&apos;d think we should cause the outer level transaction to fail with a SystemException because the application handling is not consistent (the cache, for example, might be in an inconsistent state). If the application thinks everything is aok, then I think we have a problem. &lt;/p&gt;

&lt;p&gt;When we get to this spot, the Transaction is complete.  All of the prepares and commits and/or rollbacks have completed.  The afterCompletion call is just a convenience callback to let those resources that have registered for Synchronization that the transaction has completed.  The parameter on afterCompletion lets you know whether the transaction committed or rolled back.  So, there is nothing to &quot;fail&quot;.  &lt;/p&gt;

&lt;p&gt;And, actually, the IllegalStateException that I mentioned about we get when we attempt to call setRollbackOnly is only logged by the TM.  It is not thrown back to the caller since there is nothing to fail.  So, the application actually continues running without a problem.  The exception just gets logged so that we know that something isn&apos;t quite right, but everything still completed &quot;okay&quot;.&lt;/p&gt;</comment>
                            <comment id="12523989" author="clr" created="Fri, 31 Aug 2007 04:40:17 +0100"  >&lt;p&gt;&amp;gt; When we get to this spot, the Transaction is complete. All of the prepares and commits and/or rollbacks have completed. The afterCompletion call is just a convenience callback to let those resources that have registered for Synchronization that the transaction has completed. The parameter on afterCompletion lets you know whether the transaction committed or rolled back. So, there is nothing to &quot;fail&quot;. &lt;/p&gt;

&lt;p&gt;If there&apos;s nothing important for OpenJPA to do in afterCompletion, then it should simply return and there cannot be an exception. If there is something important to do, then it&apos;s important that it complete.&lt;/p&gt;

&lt;p&gt;Is this not true?&lt;/p&gt;</comment>
                            <comment id="12523992" author="pcl" created="Fri, 31 Aug 2007 04:50:31 +0100"  >&lt;p&gt;I&apos;m generally against the log-and-throw pattern, whenever it&apos;s possible to avoid it. When it is necessary, I think that it&apos;s important that the log only happen at the trace level, so that we aren&apos;t unnecessarily repeating exception printouts.&lt;/p&gt;

&lt;p&gt;This conversation seems to have diverged a bit from suggesting a log-and-throw, but I figured it was worth mentioning anyways.&lt;/p&gt;</comment>
                            <comment id="12524125" author="kwsutter" created="Fri, 31 Aug 2007 17:01:41 +0100"  >&lt;p&gt;&amp;gt; If there&apos;s nothing important for OpenJPA to do in afterCompletion, then it should simply return and there cannot be an exception. If there is something important to do, then it&apos;s important that it complete.&lt;/p&gt;

&lt;p&gt;&amp;gt; Is this not true?&lt;/p&gt;

&lt;p&gt;Yes, that is true.  I was typing before thinking.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Our afterCompletion processing does do some &quot;real work&quot; with ending the transaction, detaching entities, etc.  So, when an exception happens in this code path, it could mean that some of our cleanup didn&apos;t complete.  We do log any exceptions that happen during this path via trace statements and the exception does get re-thrown.  It may get wrapped in a suitable PersistenceException, but it will get sent back.&lt;/p&gt;

&lt;p&gt;But, to get back to what I was attempting to explain...  The transaction itself is already completed.  There is nothing we can do at this point to revert the state of that transaction.  It was already either committed or rolled back by the time the afterCompletion method is invoked.  The beforeCompletion and afterCompletion methods on the Synchronization interface are just convenient listener methods.  Any exceptions that may happen due to these calls will not affect the outcome of the Transaction (since it is already complete).  And, from my experience, the Synchronization implementation will not stop processing just because an exception happens.  They will log the condition (as we have seen) and then continue processing.&lt;/p&gt;

&lt;p&gt;Hope this helps.&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12524377" author="clr" created="Sun, 2 Sep 2007 18:39:51 +0100"  >&lt;p&gt;&amp;gt; So, when an exception happens in this code path, it could mean that some of our cleanup didn&apos;t complete. We do log any exceptions that happen during this path via trace statements and the exception does get re-thrown.&lt;/p&gt;

&lt;p&gt;&amp;gt; There is nothing we can do at this point to revert the state of that transaction. It was already either committed or rolled back by the time the afterCompletion method is invoked.&lt;/p&gt;

&lt;p&gt;I agree.&lt;/p&gt;

&lt;p&gt;&amp;gt; The parameter on afterCompletion lets you know whether the transaction committed or rolled back. So, there is nothing to &quot;fail&quot;. &lt;/p&gt;

&lt;p&gt;Here&apos;s where we might disagree. The user-level commit should fail so the user doesn&apos;t think everything is ok as far as the cache is concerned. I understand that the database transaction is complete and whatever changes have been made there are permanent. But the EntityManager is possibly corrupted.&lt;/p&gt;

&lt;p&gt;Craig&lt;/p&gt;</comment>
                            <comment id="12524717" author="kwsutter" created="Tue, 4 Sep 2007 14:21:51 +0100"  >&lt;p&gt;&amp;gt; Here&apos;s where we might disagree. The user-level commit should fail so the user doesn&apos;t think everything is ok as far as the cache is concerned. I understand that the database transaction is complete and whatever changes have been made there are permanent. But the EntityManager is possibly corrupted.&lt;/p&gt;

&lt;p&gt;I agree.  We are performing this &quot;afterCompletion&quot; processing as far as we can until we hit this unexpected exception.  This exception is now being logged (if trace is turned on) and the exception is returned to the caller.  Unless you are suggesting that we should possibly log-and-eat this exception and attempt to continue additional processing as if nothing has happened, I think we have done everything we can do.  If we went this log-and-eat route, it would require more more granular try-catch blocks in this path.  Not sure this is necessary processing for the unexpected (rare) case.&lt;/p&gt;

&lt;p&gt;FYI, we are still flowing through the EntityManager with the setRollbackOnly invocation.  So, any processing in the EntityManager and/or Broker that would be triggered because of the setRollbackOnly call will still happen.  It&apos;s just the explicit setRollbackOnly call on the Transaction object itself that was conditionally skipped if the Transaction was not &quot;active&quot;.  Just wanted to clarify that aspect of the change.&lt;/p&gt;

&lt;p&gt;If there are still concerns about the general exception processing in the OpenJPA code base, then maybe we should open a separate JIRA issue or at least start a &lt;span class=&quot;error&quot;&gt;&amp;#91;DISCUSSION&amp;#93;&lt;/span&gt; topic on our dev mailing list.  The original intent of this Issue was to not call the setRollbackOnly method when the Transaction is not in a state to accept the invocation.  I think that issue has been resolved.  But, maybe there are still concerns about the general exception processing within OpenJPA...&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Kevin&lt;/p&gt;</comment>
                            <comment id="12524719" author="kwsutter" created="Tue, 4 Sep 2007 14:23:10 +0100"  >&lt;p&gt;Resolved in trunk (1.1.0) via svn revision #571523.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 31 Aug 2007 01:15:10 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160667</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hz7krz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>288336</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>