<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:45:12 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-359/OPENJPA-359.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-359] OptimisticLockException NOT thrown for entity using Timestamp Version when update from concurrent persistence contexts</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-359</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;We ran a test using Timestamp as the version field in an entity, the following (pseudo) test failed when an OptimisticLockException is expected:&lt;/p&gt;

&lt;p&gt;    em1.persist( e0(pk1) );&lt;/p&gt;

&lt;p&gt;    e1 = em1.find(pk1);&lt;br/&gt;
    e2 = em2.find(pk1);&lt;/p&gt;

&lt;p&gt;    e1.setAttr( &quot;new1&quot;);&lt;br/&gt;
    e2.setAttr( &quot;new2&quot;);&lt;/p&gt;

&lt;p&gt;    em1.merge( e1 );&lt;br/&gt;
    em2.merge( e2 );    &amp;lt;&amp;lt;&amp;lt;&amp;lt; Expect an OptimisticLockException&lt;/p&gt;

&lt;p&gt;The cause of this problem is because the TimestampVersionStrategy.nextVersion returns a java.sql.Timestamp(System.currentTimeMillis()); In the Wintel environment, the currentTimeMillis() only has approximately 15ms resolution. When 2 subsequent Timestamp version objects are requested within this 15ms interval, both has the same version value. Therefore the em2.merge does not detected the versions difference between o1 and o2, hence no exception is thrown.&lt;/p&gt;

&lt;p&gt;Due to this behavior, the same test case may failed intermittenly depends on the currentTimeMillis() resolution and the time when a timestamp version is created.  From some preliminary tests, the resolution for  wintel, linux and z/os are about 15ms, 2ms and 2ms respectively.&lt;/p&gt;
</description>
                <environment>WIntel 32 </environment>
        <key id="12377801">OPENJPA-359</key>
            <summary>OptimisticLockException NOT thrown for entity using Timestamp Version when update from concurrent persistence contexts</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="allee8285">Albert Lee</assignee>
                                    <reporter username="allee8285">Albert Lee</reporter>
                        <labels>
                    </labels>
                <created>Sat, 8 Sep 2007 06:03:51 +0100</created>
                <updated>Wed, 27 Feb 2008 20:30:05 +0000</updated>
                            <resolved>Tue, 26 Feb 2008 16:53:39 +0000</resolved>
                                    <version>1.0.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>jdbc</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12525890" author="allee8285" created="Sat, 8 Sep 2007 06:21:14 +0100"  >&lt;p&gt;The solution is to create a java.sql.Timestamp based on the current time plus a unique counter within the same current time windows. Therefore the timestamp is not truely a time based timestamp but a unique timestamp for versioning purpose.&lt;/p&gt;</comment>
                            <comment id="12525933" author="pcl" created="Sat, 8 Sep 2007 19:02:39 +0100"  >&lt;p&gt;We need to also consider clustered environments &amp;#8211; this patch doesn&apos;t do much for such environments. Of course, in a clustered environment, timestamp-based checks rely on clock synchronization, which is a hard problem.&lt;/p&gt;

&lt;p&gt;I&apos;ve always seen this as an insoluble problem with timestamp versioning, and have just worked around it by putting sleeps in test cases that test concurrency and timestamp versioning.&lt;/p&gt;

&lt;p&gt;The proposed change adds a synchronized block, which seems like a potential bottleneck; if we decide that we care about this problem, I think I&apos;d rather see us just put a Thread.currentThread().wait(&amp;lt;15 | 2&amp;gt;) call into the versioning code. Note, of course, that this still won&apos;t solve the problem in a clustered environment.&lt;/p&gt;</comment>
                            <comment id="12525944" author="allee8285" created="Sat, 8 Sep 2007 20:48:20 +0100"  >&lt;p&gt;&amp;gt;&amp;gt; We need to also consider clustered environments &amp;#8211; this patch doesn&apos;t do much for such environments. Of course, in a clustered environment, timestamp-based checks rely on clock synchronization, which is a hard problem. &lt;/p&gt;

&lt;p&gt;When you say clustered environment, do you mean multiple appl servers (in a cluster) accessing the same db server? This patch refines the time stamp granularity and improves version uniqueness. It does not degrade the current implementation and will exhibit the exact behavior as far as &quot;clustering&quot; is concern.  I agree with you that Versioning support in cluster environment is a hard problem and it is not only for Timestamp but any type. Until there is a central &quot;server&quot; that hands out unique version id, it will remain to be a insoluble problem.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; The proposed change adds a synchronized block, which seems like a potential bottleneck; &lt;br/&gt;
The synchronized block is required to make sure the counter is updated correctly in multi-thread scenario. This follows a similar pattern as implemented in the UUIDGenerator.  I have considered the bottleneck condition and scaled down the instructions absolutely needed in the synchronized block to improve concurrency.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; I think I&apos;d rather see us just put a Thread.currentThread().wait(&amp;lt;15 | 2&amp;gt;) call into the versioning code.&lt;br/&gt;
Do you mean &quot;Thread.currentThread().sleep(&amp;lt;15|2&amp;gt;)&quot; ?  &lt;br/&gt;
First, one has to determine the value to sleep. This value varies a lot and depends on the hardware platform and realistically should be determine at run-time.  Second, sleeping for 2ms per se is an artificial performance and concurrency inhibitors which I don&apos;t recommend.&lt;/p&gt;

&lt;p&gt;We may be able to figure out other means to avoid the synchronized block but still get the same result.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; Note, of course, that this still won&apos;t solve the problem in a clustered environment.&lt;br/&gt;
Distributed system synchronization is always a hard problem to solve.  The initial time stamp value is based on System.currentTimeMillis(), this means the first problem is to make sure this base value is synchronized between all servers in the cluster. The second problem is the increment value needs to be either synchronized and/or common between all servers.   &lt;/p&gt;

&lt;p&gt;If we take a step back and say using Timestamp as version id is inherently problematic (the same argument as using float as primary key) in cluster environment, all we can do is to provide an implementation that can improve the possibility NOT to run into a problem condition, as we already have encountered in our test scenario.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12526062" author="pcl" created="Mon, 10 Sep 2007 06:41:07 +0100"  >&lt;p&gt;&amp;gt; When you say clustered environment, do you mean multiple appl servers &lt;br/&gt;
&amp;gt; (in a cluster) accessing the same db server? &lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;&amp;gt; I agree with you that Versioning support in cluster environment is a hard &lt;br/&gt;
&amp;gt; problem and it is not only for Timestamp but any type. Until there is a central&lt;br/&gt;
&amp;gt; &quot;server&quot; that hands out unique version id, it will remain to be a insoluble problem.&lt;/p&gt;

&lt;p&gt;I don&apos;t understand. IMO, versioning in a clustered environment is a trivial problem &lt;br/&gt;
when using the monotonically-incrementing number approach. The only &quot;problems&quot;&lt;br/&gt;
arise when using timestamps, and arguably, these aren&apos;t problems, but rather just&lt;br/&gt;
limitations imposed by the timing needs of the application.&lt;/p&gt;

&lt;p&gt;FTR, with a monotonically-incrementing version number, the database itself acts&lt;br/&gt;
as the central server.&lt;/p&gt;

&lt;p&gt;&amp;gt; sleeping for 2ms per se is an artificial performance and concurrency inhibitors &lt;br/&gt;
&amp;gt; which I don&apos;t recommend. &lt;/p&gt;

&lt;p&gt;By my definitions, sleeping for 2ms does incur a performance cost, but does not &lt;br/&gt;
incur any concurrency problem at all. In fact, doing so avoids the concurrency &lt;br/&gt;
problem introduced by the new synchronized block.&lt;/p&gt;</comment>
                            <comment id="12526171" author="allee8285" created="Mon, 10 Sep 2007 15:54:19 +0100"  >&lt;p&gt;&amp;gt; I don&apos;t understand. IMO, versioning in a clustered environment is a trivial problem&lt;br/&gt;
when using the monotonically-incrementing number approach. The only &quot;problems&quot;&lt;br/&gt;
arise when using timestamps, and arguably, these aren&apos;t problems, but rather just&lt;br/&gt;
limitations imposed by the timing needs of the application.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; FTR, with a monotonically-incrementing version number, the database itself acts&lt;br/&gt;
as the central server. &lt;/p&gt;

&lt;p&gt;If the version is handed off from the db server, then I agree with you that is is a trivial problem. However in our implementation the version is handed off from an instance of the persistence provider of app server (in a cluster). E.g. &lt;/p&gt;

&lt;p&gt;NumberVersionStrategy.nextVersion() &lt;/p&gt;
{ .... return Numbers.valueOf(((Number) version).intValue() + 1); }
&lt;p&gt;TimestampVersionStrategy.netxtVersion() &lt;/p&gt;
{ return TimestampHelper.getCurrentTimestamp(); }

&lt;p&gt;TImestamp is always problematic, regardless of how accurate the value is used. It also depends on how precise (how many fractional digits) the column in the db are being stored. I ran into a scenario where the Timestamp version is precise to the 100ns but the test still failed. It is because the version column in the db only holds up to ms.&lt;/p&gt;

&lt;p&gt;&amp;gt; By my definitions, sleeping for 2ms does incur a performance cost, but does not&lt;br/&gt;
incur any concurrency problem at all. In fact, doing so avoids the concurrency&lt;br/&gt;
problem introduced by the new synchronized block.&lt;/p&gt;

&lt;p&gt;Sleeping in a thread to avoid duplicate time stamp only solve its own problem. What about if there are 2 threads coming in at the same time (within the 15ms time window) and asking for a new version. Without the synchronized block to hand out the next value, the time stamp version created in both threads will be same if sleep is used, which does not solve the initial problem. Even with the current suggested solution, it does not guarantee to solve the cluster scenario.&lt;/p&gt;</comment>
                            <comment id="12526257" author="pcl" created="Mon, 10 Sep 2007 21:23:51 +0100"  >&lt;p&gt;&amp;gt; If the version is handed off from the db server, then I agree with &lt;br/&gt;
&amp;gt; you that is is a trivial problem. However in our implementation &lt;br/&gt;
&amp;gt; the version is handed off from an instance of the persistence &lt;br/&gt;
&amp;gt; provider of app server (in a cluster). E.g.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; NumberVersionStrategy.nextVersion() &lt;/p&gt;
{
&amp;gt;     ...
&amp;gt;     return Numbers.valueOf(((Number) version).intValue() + 1);
&amp;gt; }
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;Yes, but then, the previous number is used in an UPDATE or DELETE statement. If the row being updated / deleted has been changed by a different VM, then the database will have a different version value at that time, and the update / delete statement will fail (modified row count of 0). So, while we don&apos;t fetch the number from the database, the database always contains the most-recent clean version number, and updates only get into the database when the reader had read that value.&lt;/p&gt;

&lt;p&gt;Timestamps are more complicated, as has been discussed on this thread.&lt;/p&gt;

&lt;p&gt;&amp;gt; Sleeping in a thread to avoid duplicate time stamp only solve its own problem.&lt;br/&gt;
&amp;gt; What about if there are 2 threads coming in at the same time (within the 15ms &lt;br/&gt;
&amp;gt; time window) and asking for a new version. Without the synchronized block to &lt;br/&gt;
&amp;gt; hand out the next value, the time stamp version created in both threads will be &lt;br/&gt;
&amp;gt; same if sleep is used, which does not solve the initial problem. Even with the &lt;br/&gt;
&amp;gt; current suggested solution, it does not guarantee to solve the cluster scenario.&lt;/p&gt;

&lt;p&gt;I agree &amp;#8211; this entire domain is rife with problems when transactions are shorter than the resolution available. I just do not think that adding synchronization to attempt to partially fix the situation is really worth the cost in all the use cases where transactions are known to be longer than the resolution.&lt;/p&gt;

&lt;p&gt;In any event, I understand that there is some value to what you&apos;re proposing; I just don&apos;t think that we should change our current behavior, because it&apos;s good enough for many users, and has characteristics (lack of synchronization) that is advantageous over the incremental improvement that you&apos;re suggesting. So, I could see room for a new versioning strategy or some sort of option to configure how the timestamp behavior works.&lt;/p&gt;</comment>
                            <comment id="12526286" author="allee8285" created="Mon, 10 Sep 2007 23:28:20 +0100"  >&lt;p&gt;Patrick,&lt;/p&gt;

&lt;p&gt;I understand your concern of the proposed changed. &lt;/p&gt;

&lt;p&gt;I&apos;ll continue to find other implementation that does not require a synchronized block plus improving granularity of the version value (time-wise).&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="12526297" author="pcl" created="Tue, 11 Sep 2007 00:06:20 +0100"  >&lt;p&gt;One approach might be to just create an implementation that uses System.nanoTime(). This would only work in 1.5 environments, but that might be good enough.&lt;/p&gt;

&lt;p&gt;An easy way to do this would be to make a new abstract superclass of TimestampVersionStrategy, and two implementations for providing a timestamp: one that uses the nano calls, and one that uses the milli calls. For extra credit, you could even make the Configuration framework choose which to use by default based on the value of JavaVersions.VERSION.&lt;/p&gt;</comment>
                            <comment id="12571849" author="allee8285" created="Sun, 24 Feb 2008 04:03:20 +0000"  >&lt;p&gt;Attached is an alternative implementation of the nano precision timestamp versioning. This is based on the JRE 1.5 System.nanoTime() support. It does not use synchronization block and should be thread-safe.&lt;/p&gt;

&lt;p&gt;A new NanoPrecisionTimestampVersionStrategy is created using alias &quot;nano-timestamp&quot;. This is the default date/timestamp version strategy if Java version &amp;gt;= 5.&lt;/p&gt;

&lt;p&gt;Due to the JRE 1.4 compilation requirement in the maven build process, the new TimestampHelper class in the openjpa-persistence module uses Reflection to invoke System.nanoTime() and TimeStamp.setNanos() methods.  If there is other alternative to get around the 1.4 maven compilation problem, I would prefer to call these methods directly but I don&apos;t have a good solution other than using Reflection. Suggestion is welcome.&lt;/p&gt;

&lt;p&gt;I&apos;ll wait until EOD Monday to commit this change.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Albert Lee.&lt;/p&gt;</comment>
                            <comment id="12571850" author="allee8285" created="Sun, 24 Feb 2008 04:05:24 +0000"  >&lt;p&gt;Attached again and grant ASF license.&lt;/p&gt;</comment>
                            <comment id="12571876" author="pcl" created="Sun, 24 Feb 2008 08:12:32 +0000"  >&lt;p&gt;We could get rid of at least some of the reflection, and push any remaining reflection to deploy-time only, by moving the new class to the openjpa-jdbc-5 module.&lt;/p&gt;</comment>
                            <comment id="12571994" author="allee8285" created="Mon, 25 Feb 2008 00:34:49 +0000"  >&lt;p&gt;Patrick,&lt;/p&gt;

&lt;p&gt;Thanks for the hint... I am able to get around the 1.4 compile and Reflection &quot;problems&quot; by new&apos;ing a single instance of  TimestampHelper with an override to Timestamp5elper at runtime if run in Java 5.&lt;/p&gt;

&lt;p&gt;Please review the current solution.&lt;/p&gt;

&lt;p&gt;Albert Lee.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12376329" name="OPENJPA-359.1.patch" size="8628" author="allee8285" created="Sun, 24 Feb 2008 04:05:24 +0000"/>
                            <attachment id="12376380" name="OPENJPA-359.2.patch" size="10648" author="allee8285" created="Mon, 25 Feb 2008 00:34:48 +0000"/>
                            <attachment id="12365390" name="OPENJPA-359.patch" size="3448" author="allee8285" created="Sat, 8 Sep 2007 06:21:13 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 8 Sep 2007 18:02:39 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160682</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hz7kpr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>288326</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>