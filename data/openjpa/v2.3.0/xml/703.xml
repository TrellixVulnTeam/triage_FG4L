<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:43:52 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-703/OPENJPA-703.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-703] Cache ResultObjectProvider data to improve query performance</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-703</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Profiling indicated that JDBCStoreQuery.populateSelect consumes a significant amount of CPU, and is executed every time a query is run. While, in fact, the actual PreparedStatement is created and run only in QueryImpl.toResult. It seems like the returned ResultObjectProvider from JDBCStoreQuery.executeQuery can be at least partially cached, or even cached in its entirety (provided care is taken with the context parameters). &lt;br/&gt;
It seems like such an improvement would significantly improve query performance.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12403004">OPENJPA-703</key>
            <summary>Cache ResultObjectProvider data to improve query performance</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ppoddar@apache.org">Pinaki Poddar</assignee>
                                    <reporter username="pron">Ron Pressler</reporter>
                        <labels>
                    </labels>
                <created>Mon, 25 Aug 2008 18:08:58 +0100</created>
                <updated>Tue, 7 Feb 2012 19:18:53 +0000</updated>
                            <resolved>Thu, 27 Aug 2009 17:58:05 +0100</resolved>
                                    <version>2.0.0-M2</version>
                                    <fixVersion>2.0.0-M3</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12625430" author="pron" created="Mon, 25 Aug 2008 18:25:26 +0100"  >&lt;p&gt;Actually, I now realize this has a direct connection to &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-407&quot; title=&quot;Cache SQL (or closer precursors to SQL) more aggressively&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-407&quot;&gt;&lt;del&gt;OPENJPA-407&lt;/del&gt;&lt;/a&gt;, though I&apos;m not sure if that fix addresses the JPQL issue discussed here.&lt;/p&gt;</comment>
                            <comment id="12625436" author="ppoddar@apache.org" created="Mon, 25 Aug 2008 18:45:17 +0100"  >&lt;p&gt;It always looks promising from performance perspectives to cache stuff that takes long time to compute. But caution must be exercised to cache query results (as opposed to parsed query such as PreparedStatement). Because time of execution is extremely significant  for result of a query. Caching a result may lead to erroneous behavior because a cached version of data collected at time T1 may not reflect the actual result at T2 when T2 &amp;gt; T1. &lt;/p&gt;

&lt;p&gt;As far as caching parsed query itself goes, as the experience with &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-407&quot; title=&quot;Cache SQL (or closer precursors to SQL) more aggressively&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-407&quot;&gt;&lt;del&gt;OPENJPA-407&lt;/del&gt;&lt;/a&gt; shows, is a non-trivial undertaking because of the context of query execution. To cache we need a key and we have made up a QueryKey. The content of the key dictates what we consider as the context of execution. But care must be taken to define the context. For example, as FetchPlan not being part of the query key can lead to erroneous behavior as documented in &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;. Such caching also limits or at least makes it more coupled to add more context information to a query. &lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://issues.apache.org/jira/browse/OPENJPA-671&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/OPENJPA-671&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12625770" author="pron" created="Tue, 26 Aug 2008 16:28:47 +0100"  >&lt;p&gt;I was referring to caching only the parsed query, not the results (interestingly enough, the ResultObjectProvider returned from JDBCStoreQuery.executeQuery does not, in fact, contain any results). &lt;br/&gt;
As for the fetch plan - if it indeed affects the generated SQL (as I assume it does), then it must be part of the cache key. It does not, however, make sense that, in a very common use-case. when I execute the same query over and over in my application (using the same fetch plan obviously), the SQL statement needs to be generated each time by analyzing the metadata of an entire class hierarchy. This was shown in practice to consume a lot of CPU resources.&lt;/p&gt;</comment>
                            <comment id="12627237" author="pron" created="Sat, 30 Aug 2008 20:33:31 +0100"  >&lt;p&gt;Come to think of it, for queries there&apos;s yet a simpler solution. Don&apos;t cache the generated SQL in a shared cache - simply return it along with the &quot;compiled query&quot; in the Query object returned to the user. If the fetch plan changes - discard the statement and regenerate it during the next execution. True, this does not implement a true cache, but it will provide significant performance improvements in the common case.&lt;br/&gt;
I just don&apos;t like seeing the SQL generation process taking over 30% of my program&apos;s execution time when I simply execute the SAME QUERY OBJECT over and over again.&lt;br/&gt;
I would have loved to fix this issue myself, I&apos;m just not yet familiar enough with the inner workings of OpenJPA. Getting there.&lt;/p&gt;</comment>
                            <comment id="12627354" author="ppoddar@apache.org" created="Sun, 31 Aug 2008 23:25:50 +0100"  >&lt;p&gt;&amp;gt; I just don&apos;t like seeing the SQL generation process taking over 30% of my program&apos;s execution time when I simply execute the SAME QUERY OBJECT over and over again. &lt;br/&gt;
Agreed. The issue with the proposed solution, however, is that the query instances are bound to a persistence context (aka. EntityManager) &amp;#8211; unless one is reusing the same EntityManager - an unlikely scenario in JEE container environment &amp;#8211; associating generated SQL with persistence context is not going to be fruitful as the context will live within a single transaction and then disappear.&lt;/p&gt;

&lt;p&gt;I have now introduced a mechanism similar to your proposed idea to cache the SQLs generated by OpenJPA. The cached SQL is  indexed by the original JPQL or NamedQuery moniker at EntityManagerFactory level. &lt;/p&gt;

&lt;p&gt;The advantages of the approach are manifold:&lt;br/&gt;
   1. this caching mechanism caches &lt;b&gt;any&lt;/b&gt; query. Not only findBy() as is the case with an earlier attempt to SQL level query caching. &lt;br/&gt;
   2. it provides a longer life span of the cache and hence same JPQL query Q when executed by different EntityManagers can be now reused efficiently. &lt;br/&gt;
   3.  the key for the query is natural and indirectly specified by the user to be unique as the key is the JPQL itself or the NamedQuery moniker. So there is neither any overhead of computing the query key nor there is any code coupling as context of what makes a query unique grows.&lt;br/&gt;
   4. the mechanism is orthogonal and unobtrusive to OpenJPA kernel as well as the user. The JPQL queries during first execution gets translated to SQL and any subsequent execution of the query within the same persistent unit (not context) reuse the generated SQL directly, bypassing the entire query formation (that 30% you mentioned) logic of the kernel. &lt;br/&gt;
   5. The critical (and slightly hairy) issue is the parameter binding. As JPQL allows positional as well as named parameter binding but SQL allows only positional binding, hence a bit of care must be exercised to ensure that parameter binding remains consistent as we translate a JPQL to SQL under the hood.&lt;/p&gt;

&lt;p&gt;Initial performance result with this simple mechanics is promising and presented below:&lt;br/&gt;
  1. All measurements are taken on my laptop &lt;br/&gt;
  2. Logging was turned off&lt;br/&gt;
  3. The database was empty &amp;#8211; so the query gets executed but no actual record is selected. This is done purposefully to accentuate the incremental benefit of query construction vs query caching. &lt;br/&gt;
  4. All measurements are taken by 100 repeated executions of each query &lt;/p&gt;

&lt;p&gt;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
       Query                                                                                                                                                          Time taken  in ms                                          %Improvement&lt;br/&gt;
                                                                                                                                                                  without cache      with cache&lt;br/&gt;
                                                                                                                                                                              t1                  t2                                               PCT&lt;span class=&quot;error&quot;&gt;&amp;#91;(t1-t2)/t1&amp;#93;&lt;/span&gt;&lt;br/&gt;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
1. select p from PObject p                                                                                                                                625              578                                              +7%&lt;br/&gt;
    SELECT t0.id, t0.version, t0.name FROM PObject t0 &lt;/p&gt;

&lt;p&gt;2. select p from PObject p where p.name = &apos;PObject&apos;                                                                                562              516                                               +8%&lt;br/&gt;
    SELECT t0.id, t0.version, t0.name FROM PObject t0 WHERE (t0.name = &apos;PObject&apos;)&lt;/p&gt;

&lt;p&gt;3. select p from PObject p where p.name = :param                                                                                   531               500                                              +6%&lt;br/&gt;
    SELECT t0.id, t0.version, t0.name FROM PObject t0 WHERE (t0.name = ?)&lt;/p&gt;

&lt;p&gt;4. select e from Employee e where e.name = :emp and e.department.name = :dept                         594             546                                               +8%&lt;br/&gt;
                and e.department.company.name = :company and e.address.zip = :zip&lt;br/&gt;
    SELECT t0.id, t3.id, t3.city, t3.state, t3.street, t3.zip, t1.id, t2.id, t2.name, t1.name, t0.name &lt;br/&gt;
        FROM Employee t0 INNER JOIN Department t1 ON t0.DEPARTMENT_ID = t1.id &lt;br/&gt;
        INNER JOIN Address t3 ON t0.ADDRESS_ID = t3.id &lt;br/&gt;
        INNER JOIN Company t2 ON t1.COMPANY_ID = t2.id &lt;br/&gt;
        WHERE (t0.name = ? AND t1.name = ? AND t2.name = ? AND t3.zip = ?)&lt;br/&gt;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;The current limitation is:&lt;br/&gt;
  a) queries that result into more than one SQL statements (e.g. union or parallel queries) are not amenable to caching.&lt;br/&gt;
  b) no cache invalidation on fetch plan changes &amp;#8211; but the existing caching does not address that issue either. &lt;/p&gt;



&lt;p&gt;   An earlier attempt to caching SQL query (as configured by jdbc.QuerySQLCache) is based on associating a SQL string to the implementation-internal Select objects and caching the Select objects themselves. This current work does overlap with this effort and hence some explanation is called for on why I have considered an alternative implementation for SQL query caching while one already exists. My primary concern with existing implementation for query caching are as follows:&lt;br/&gt;
       a) it is non-orthogonal to other design constructs. For example, when a relation is being loaded (a very critical and common code logic) the code becomes aware whether query caching is in effect and, more critically, takes a distinctly different path.&lt;br/&gt;
       b) the code logic of JDBCStoreManager &amp;#8211; another critical component of OpenJPA &amp;#8211; also becomes aware of query caching and starts bifurcating code paths. This approach can lead to poor maintainability and consistency in future.&lt;br/&gt;
       c) it only works for findBy() and trying to generalize it for other queries will spread the code to many other mapping strategies &amp;#8211; accentuating the above mentioned design concerns.&lt;br/&gt;
       d) it does need to compute a Select key and also caches a Select &amp;#8211; a very heavy object &amp;#8211; causing a poor memory usage profile. &lt;/p&gt;

&lt;p&gt;   I did not find any test case that measure performance gain of this existing approach. Can anyone (whoever has cared to read up to this point&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; please point me to any performance result obtained with existing caching implementation so that I can do a fair comparative performance evaluation of the existing approach and this current one?&lt;/p&gt;

</comment>
                            <comment id="12669012" author="ppoddar@apache.org" created="Fri, 30 Jan 2009 20:27:20 +0000"  >&lt;p&gt;This commit introduces few changes that may impact other developers. &lt;/p&gt;

&lt;p&gt;1. The identity type for a Query Parameter expression has changed from String to Object. This changes are reflected in &lt;br/&gt;
       /openjpa/trunk/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java  and all its subclasses.&lt;/p&gt;

&lt;p&gt;2. Query parsing preserves the runtime type of the parameter keys. The same parameter keys must be used as the key of the returned map from the following method of StoreQuery.Executor&lt;/p&gt;

&lt;p&gt;              public LinkedMap getParameterTypes(StoreQuery q);&lt;/p&gt;

&lt;p&gt;    This impact is shown in JPQLExpressionBuilder.getParameters().&lt;/p&gt;

&lt;p&gt;   Both the above changes to preserve the actual type of the parameter key (numeric or String) is important to identify them later when a query is executed with a new set of user parameter values. &lt;/p&gt;

&lt;p&gt;3. As QueryExpression Tree is walked and each node contributes to fill in the SQLBuffer, the user defined parameters must distinguish themselves from any other SQL parameters being inserted in SQLBuffer. This distinction is critical for reparameterizing the cached SQL with a new set of user parameter values while keeping the internal parameter values intact. This aspect add a new overloaded SQLBuffer.appendValue(Object, Column, Parameter) method.&lt;/p&gt;
</comment>
                            <comment id="12671993" author="ppoddar@apache.org" created="Mon, 9 Feb 2009 20:09:28 +0000"  >&lt;p&gt;This document describes the main issues and how they have been addressed in designing Prepared Query Cache &amp;#8211; which bypasses normal pathway of JPQL query execution by reusing the target SQL and other internal constructs. &lt;/p&gt;

&lt;p&gt;One of the design goal is to minimize intrusion to current pathways. The outcome is that the only change a OpenJPA developer must keep in mind is &lt;br/&gt;
while contributing to a SQLBuffer from the Query Expression Tree nodes is to distinguish between a user-supplied query parameter from an internally &lt;br/&gt;
inserted parameter (such as Literal or Const). &lt;/p&gt;</comment>
                            <comment id="12707847" author="fancy" created="Sun, 10 May 2009 22:58:50 +0100"  >&lt;p&gt;The JPQL queries are not cached until PreparedResultObjectProvider and SQLProjectResultObjectProvider can handle complex query results. &lt;br/&gt;
Queries having following characteristics are not cached:&lt;/p&gt;

&lt;p&gt;1. resulting entity class is not candidate type,&lt;br/&gt;
    select e.dept from Employee e&lt;br/&gt;
2: query returning any embeddable class&lt;br/&gt;
    select e.address from Employee e&lt;br/&gt;
3. query returning more than one entity class&lt;br/&gt;
    select d, e from Dept d, in (d.emps) e&lt;br/&gt;
4. query contains ORDER BY clause&lt;br/&gt;
    select e.name from Employee e order by e.salary&lt;br/&gt;
5. query returning basic types but SQL result columns don&apos;t match with JPQL selections&lt;br/&gt;
    select e.name, e.name from Employee e&lt;/p&gt;

&lt;p&gt;6. JPQL query returning boolean value where SQL returning 0 or 1&lt;br/&gt;
    select e.name, e.isManager from Employee e&lt;/p&gt;

&lt;p&gt;The revision r773404 has code in place that detects the characteristics of queries and not caching them,&lt;br/&gt;
It is to  avoid cached query returning wrong answer.&lt;/p&gt;

&lt;p&gt;The query cache-ability detection logic may not complete (&lt;br/&gt;
the query example 6 is currently cached and give wrong answer).&lt;/p&gt;

&lt;p&gt;This issue is reopened to re-evaluate the cache-ability of the queries having the characteristics as listed above.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12541678">OPENJPA-2121</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12536305">OPENJPA-2099</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12380622">OPENJPA-407</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12413662">OPENJPA-886</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12414961">OPENJPA-924</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12399852" name="PreparedQueryCache.pdf" size="188452" author="ppoddar@apache.org" created="Mon, 9 Feb 2009 20:09:28 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 25 Aug 2008 17:45:17 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>44267</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hysry7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>201876</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>