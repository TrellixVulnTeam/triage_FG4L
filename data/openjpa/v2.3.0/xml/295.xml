<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:29:49 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-295/OPENJPA-295.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-295] ArrayIndexOutofBoundsException when under load and within a managed Transaction</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-295</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Recent development builds of our WAS products as well as the Geronimo project are seeing exceptions when running under load.  An example of the exception is below:&lt;/p&gt;

&lt;p&gt;Caused by: &lt;br/&gt;
java.lang.ArrayIndexOutOfBoundsException&lt;br/&gt;
	at java.util.ArrayList.add(ArrayList.java:378)&lt;br/&gt;
	at org.apache.openjpa.kernel.AbstractBrokerFactory.syncWithManagedTransaction(AbstractBrokerFactory.java:684)&lt;br/&gt;
	... 39 more&lt;/p&gt;

&lt;p&gt;This is the deepest trace I can get with the actual exception, but the wrappering exception shows this stack trace for geronimo:&lt;/p&gt;

&lt;p&gt;&amp;lt;1.0.0-SNAPSHOT-SNAPSHOT nonfatal general error&amp;gt; org.apache.openjpa.persistence.PersistenceException: null&lt;br/&gt;
	at org.apache.openjpa.kernel.AbstractBrokerFactory.syncWithManagedTransaction(AbstractBrokerFactory.java:690)&lt;br/&gt;
	at org.apache.openjpa.kernel.BrokerImpl.initialize(BrokerImpl.java:304)&lt;br/&gt;
	at org.apache.openjpa.kernel.AbstractBrokerFactory.newBroker(AbstractBrokerFactory.java:182)&lt;br/&gt;
	at org.apache.openjpa.kernel.DelegatingBrokerFactory.newBroker(DelegatingBrokerFactory.java:142)&lt;br/&gt;
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:190)&lt;br/&gt;
	at org.apache.openjpa.persistence.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:55)&lt;br/&gt;
	at org.apache.geronimo.persistence.CMPEntityManagerTxScoped.createEntityManager(CMPEntityManagerTxScoped.java:74)&lt;br/&gt;
	at org.apache.geronimo.persistence.CMPEntityManagerTxScoped.getEntityManager(CMPEntityManagerTxScoped.java:55)&lt;br/&gt;
	at org.apache.geronimo.persistence.CMPEntityManagerTxScoped.createNamedQuery(CMPEntityManagerTxScoped.java:259)&lt;br/&gt;
	at org.apache.geronimo.samples.daytrader.ejb3.TradeSLSBBean.getClosedOrders(TradeSLSBBean.java:335)&lt;/p&gt;

&lt;p&gt;This is happening in two separate products with two different JTA implementations, and also both of these products were working at one point.&lt;/p&gt;

&lt;p&gt;Any ideas?&lt;/p&gt;</description>
                <environment>openjpa running under WebSphere development builds, as well as Geronimo development builds</environment>
        <key id="12374560">OPENJPA-295</key>
            <summary>ArrayIndexOutofBoundsException when under load and within a managed Transaction</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mikedd">Michael Dick</assignee>
                                    <reporter username="rob.wisniewski">Rob Wisniewski</reporter>
                        <labels>
                    </labels>
                <created>Wed, 25 Jul 2007 17:15:24 +0100</created>
                <updated>Fri, 12 Oct 2007 16:59:16 +0100</updated>
                            <resolved>Wed, 8 Aug 2007 18:50:31 +0100</resolved>
                                    <version>0.9.6</version>
                                    <fixVersion>1.0.1</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>jpa</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12515344" author="pcl" created="Wed, 25 Jul 2007 17:40:52 +0100"  >&lt;p&gt;We should be creating a concurrent data structure instead of an ArrayList a couple of lines above where you&apos;re getting the exception. I can&apos;t create a patch easily right now as I&apos;ve made significant uncommitted changes to that file.&lt;/p&gt;</comment>
                            <comment id="12515355" author="mprudhom" created="Wed, 25 Jul 2007 18:21:40 +0100"  >&lt;p&gt;Could the application somehow be using the same JTA transaction from different threads? The reason we don&apos;t synchronize at AbstractBrokerFactory:684 is that we don&apos;t expect to ever be able to have multiple threads accessing the list of brokers, since it is keyed off of the JTA transaction (which is supposed to be thread-bound).&lt;/p&gt;</comment>
                            <comment id="12515389" author="rob.wisniewski" created="Wed, 25 Jul 2007 20:15:11 +0100"  >&lt;p&gt;It&apos;s a long shot that both of these products would be having the same problem..  we&apos;re trying to switch out jpa implementations and see if the problem goes away.  earlier builds of the products built on 0.9.7 work fine while the 1.0.0 based builds fail.. trying to retrofit 0.9.7 into the newer builds.  Also synchonizing the set locally here to see if that gets rid of the problem.&lt;/p&gt;</comment>
                            <comment id="12515430" author="mikedd" created="Wed, 25 Jul 2007 22:43:41 +0100"  >&lt;p&gt;Attaching a simple patch based on Patrick&apos;s comments. The patch uses a ConcurrentSet (arbitrarily chosen) instead of an ArrayList. &lt;/p&gt;

&lt;p&gt;I also sent a jar containing this change to Rob earlier today and it looks like it resolved the problem. &lt;/p&gt;

&lt;p&gt;I&apos;m hesitating to commit the fix until we understand what else changed between 0.9.7 and now. A quick diff shows no changes to the AbstractBrokerFactory.syncWithManagedTransaction method and only a few in AbstractBrokerFactory as a whole. &lt;/p&gt;

&lt;p&gt;I believe the current builds are faster than 0.9.7 (at least for Rob&apos;s application) so it&apos;s possible that we&apos;re just hitting a timing window that we couldn&apos;t before.&lt;/p&gt;</comment>
                            <comment id="12517291" author="mikedd" created="Thu, 2 Aug 2007 16:23:54 +0100"  >&lt;p&gt;Getting back to Marc&apos;s comment. I think the difference in this case is that WebSphere Application Server (and I&apos;m guessing Geronimo) use the TransactionSynchronizationRegistry. &lt;/p&gt;

&lt;p&gt;When we use the TSR to get a TransactionManager it returns a TransactionManagerFacade (a singleton), calling getTransaction() on the facade returns a singleton (itself) as well. If I haven&apos;t misread the code, we&apos;ll hit this problem fairly quickly with any Application Server that uses the TSR.&lt;/p&gt;

&lt;p&gt;I can think of two potential fixes (assuming I&apos;ve identified the problem correctly) : &lt;/p&gt;

&lt;p&gt;1. Use a concurrent set (similar to the patch I attached earlier). &lt;/p&gt;

&lt;p&gt;2. The TSR API provides a getTransactionKey() method. The TransactionManagerFacade could be modified to return a new &quot;TransactionFacade&quot; Object when getTransaction is called. The TransactionFacade could use the transactionKey&apos;s hashcode (which should be unique to each transaction), and we&apos;ll avoid the collision. &lt;/p&gt;

&lt;p&gt;Does anyone see a problem with either approach (or something I&apos;ve missed) ? &lt;/p&gt;</comment>
                            <comment id="12517324" author="mprudhom" created="Thu, 2 Aug 2007 18:51:21 +0100"  >&lt;p&gt;I bet you&apos;re right. Good catch!&lt;/p&gt;

&lt;p&gt;Another solution might be to use the following patch: it changes RegistryManagedRuntime.java to use a ThreadLocal to hold its Transaction facades, rather than just having a single global one, which should mean that multiple threads never get the same Transaction facade. I would be interested in hearing if the patch works for you.&lt;/p&gt;</comment>
                            <comment id="12517373" author="clr" created="Thu, 2 Aug 2007 22:14:00 +0100"  >&lt;p&gt;Hi Marc,&lt;/p&gt;

&lt;p&gt;There should not be any issue using the identical instance of TSR for the registerSynchronization, get/setRollbackOnly, and getStatus methods. The issue is the assumption that the Transaction instance is different for each transaction.&lt;/p&gt;

&lt;p&gt;I think that Michael Dick&apos;s #2 solution is needed. The _transactional is already a concurrent map but all the keys are identical so the basic premise doesn&apos;t work.&lt;/p&gt;

&lt;p&gt;More basic, the AbstractBrokerFactory method findTransactionalBroker should have a different implementation for TSR, which has direct support for this functionality via the getResource and putResource methods. I think I&apos;d rather delegate the &quot;findTransactionalBroker&quot; to the ManagedRuntime, which could do the current behavior in other than TSR environments but delegate to the TSR behavior in the app server.&lt;/p&gt;

&lt;p&gt;Back to the current problem how about adding Object getTransactionKey() to ManagedRuntime which in non-TSR implementations returns &quot;this&quot; and in TSR returns &quot;this.getTransactionKey()&quot;.&lt;/p&gt;</comment>
                            <comment id="12517384" author="mprudhom" created="Thu, 2 Aug 2007 22:40:45 +0100"  >&lt;p&gt;My patch doesn&apos;t use a different TSR per thread, it just put a different instance of the javax.transaction.Transaction into the ThreadLocal, so that a different Transaction is used per thread (as per the JTA spec). &lt;/p&gt;

&lt;p&gt;That being said, there are plenty of other solutions to this problem. The advantage I see to my solution is that it doesn&apos;t introduce additional unnecessary synchronizatin into the findTransactionalBroker() method. However, even if a different solution is desired, my patch should probably be applied anyway, since having the same Transaction instance being used from multiple threads might break other assumptions elsewhere.&lt;/p&gt;</comment>
                            <comment id="12517388" author="clr" created="Thu, 2 Aug 2007 23:11:50 +0100"  >&lt;p&gt;The attached patch adds a new method getTransactionKey to ManagedRuntime and uses this key to manage the Map&amp;lt;Transaction, Broker&amp;gt; map. &lt;/p&gt;</comment>
                            <comment id="12517394" author="mikedd" created="Thu, 2 Aug 2007 23:27:03 +0100"  >&lt;p&gt;I agree with Marc and Craig that some variation of solution 2 is the best option (I see Marc&apos;s patch as one of these variations).&lt;/p&gt;

&lt;p&gt;That being said I think there are cases where we will need to return a separate TransactionFacade instance if the transaction key is different. &lt;/p&gt;

&lt;p&gt;If the container has suspended that current transaction and started a new one (a bean method with TX_REQUIRES_NEW calls another bean method with TX_REQUIRES_NEW) we&apos;ll need a separate key to the _transactions collection. If they used the same key then we&apos;d run into problems the first time an AfterCompletion event is fired. &lt;/p&gt;

&lt;p&gt;Between Marc and Craig&apos;s patches I think we&apos;re pretty close, I just haven&apos;t had a change to play with it much (yet) today. &lt;/p&gt;</comment>
                            <comment id="12517395" author="clr" created="Thu, 2 Aug 2007 23:30:36 +0100"  >&lt;p&gt;&amp;gt; My patch doesn&apos;t use a different TSR per thread, it just put a different instance of the javax.transaction.Transaction into the ThreadLocal, so that a different Transaction is used per thread (as per the JTA spec). &lt;/p&gt;

&lt;p&gt;Well, we are only using the Transaction interface to do a small number of things, and while it may seem attractive to use a ThreadLocal for this, it&apos;s a bit bizarre because the same ThreadLocal is permanently assigned to the thread so the Transaction never changes. This is not per the JTA spec &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; That being said, there are plenty of other solutions to this problem. The advantage I see to my solution is that it doesn&apos;t introduce additional unnecessary synchronizatin into the findTransactionalBroker() method. However, even if a different solution is desired, my patch should probably be applied anyway, since having the same Transaction instance being used from multiple threads might break other assumptions elsewhere.&lt;/p&gt;

&lt;p&gt;I think in the case of TSR, there is a much more elegant solution to findTransactionalBroker, by using the getResource and setResource methods. These methods should be much more efficient than our own synchronized _transactional.get(key). Then the only use for _transactional is to make sure that there are no outstanding transactions in progress when we try to close the EntityManagerFactory.&lt;/p&gt;

&lt;p&gt;So I&apos;d like to extend ManagedRuntime with a findTransactionalBroker method that would allow the RegistryManagedRuntime to be more efficient, and put the current AbstractBrokerFactory&apos;s implementation into AbstractManagedRuntime.&lt;/p&gt;</comment>
                            <comment id="12517420" author="pcl" created="Fri, 3 Aug 2007 02:13:02 +0100"  >&lt;p&gt;&amp;gt; So I&apos;d like to extend ManagedRuntime with a findTransactionalBroker method &lt;br/&gt;
&amp;gt; that would allow the RegistryManagedRuntime to be more efficient, and put the &lt;br/&gt;
&amp;gt; current AbstractBrokerFactory&apos;s implementation into AbstractManagedRuntime.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="12517424" author="clr" created="Fri, 3 Aug 2007 03:16:48 +0100"  >&lt;p&gt;Michael said:&lt;br/&gt;
&amp;gt;That being said I think there are cases where we will need to return a separate TransactionFacade instance if the transaction key is different. &lt;/p&gt;

&lt;p&gt;TSR was designed so this is not needed. Getting the transaction key is supposed to be a trivial operation so there&apos;s no need to remember (cache) it.&lt;/p&gt;

&lt;p&gt;&amp;gt;If the container has suspended that current transaction and started a new one (a bean method with TX_REQUIRES_NEW calls another bean method with TX_REQUIRES_NEW) we&apos;ll need a separate key to the _transactions collection. If they used the same key then we&apos;d run into problems the first time an AfterCompletion event is fired. &lt;/p&gt;

&lt;p&gt;As long as we never cache the transaction key, but look it up each time we need it, we&apos;re good. That is, any time you need to do anything with the transaction key, get it from the ManagedRuntime. It&apos;s guaranteed to give you the &lt;b&gt;current&lt;/b&gt; transaction key. &lt;/p&gt;

&lt;p&gt;The usage of the cached key in RemoveTransactionSync is ok because it&apos;s called after the transaction which was registered has completed. And the broker you want to remove from _transactional has that key.&lt;/p&gt;

&lt;p&gt;I&apos;ve attached a new patch that makes the internally cached transaction key an Object instead of a Transaction.&lt;/p&gt;</comment>
                            <comment id="12517427" author="mikedd" created="Fri, 3 Aug 2007 04:22:11 +0100"  >&lt;p&gt;I deleted the original bad patch. &lt;/p&gt;

&lt;p&gt;+1 to Craig&apos;s approach (now that I see what he meant). AbstractManagedRuntime seems to be missing from the patch. I&apos;m guessing LocalManagedRuntime will also extend AbstractManagedRuntime. &lt;/p&gt;

&lt;p&gt;I&apos;ll run a sniff test with WebSphere Application Server in the morning. &lt;/p&gt;</comment>
                            <comment id="12517436" author="clr" created="Fri, 3 Aug 2007 05:32:34 +0100"  >&lt;p&gt;Sorry, forgot to svn add the new abstract class before svn diff. The new patch includes the new class.&lt;/p&gt;

&lt;p&gt;I still have not put the findBroker method into the ManagedRuntime pending a bit more discussion.&lt;/p&gt;</comment>
                            <comment id="12517555" author="mikedd" created="Fri, 3 Aug 2007 16:01:24 +0100"  >&lt;p&gt;The attached patch is very similar to Craig&apos;s last one. I changed the type of&lt;br/&gt;
RegistryManagedRuntime._tm to TransactionManagerRegistryFacade, and made LocalManagedRuntime extend AbstractManagedRuntime. &lt;/p&gt;

&lt;p&gt;Of course there could be better solutions, but this worked for me. A very simple test with WebSphere Application Server proved that we aren&apos;t missing anything terribly obvious, but it&apos;d be nice to get validation that this did resolve the issue (I&apos;ve never reproduced the problem).&lt;/p&gt;</comment>
                            <comment id="12517576" author="mikedd" created="Fri, 3 Aug 2007 17:48:00 +0100"  >&lt;p&gt;Previous patch had a bug in AutomaticManagedRuntime - it wasn&apos;t delegating to the real ManagedRuntime&apos;s getTransactionKey method. &lt;/p&gt;</comment>
                            <comment id="12517592" author="mikedd" created="Fri, 3 Aug 2007 18:27:53 +0100"  >&lt;p&gt;I sent the &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-295&quot; title=&quot;ArrayIndexOutofBoundsException when under load and within a managed Transaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-295&quot;&gt;&lt;del&gt;OPENJPA-295&lt;/del&gt;&lt;/a&gt;.diff.txt patch to Rob and he confirmed that it does resolve the problem. I&apos;ll commit those changes but leave the JIRA open in case we want to discus the findBroker change here too. &lt;/p&gt;</comment>
                            <comment id="12517676" author="clr" created="Sat, 4 Aug 2007 01:52:46 +0100"  >&lt;p&gt;Looking at how to use the TSR map of object-&amp;gt;object instead of the _transactional, we would need to make a change to the AbstractBrokerFactory method BrokerImpl findTransactionalBroker(String user, String pass). The change would delegate to the ManagedRuntime which might have a better way to look up the Broker in the context of the current transaction.&lt;/p&gt;

&lt;p&gt;The _transactional map is a map of TransactionKey to Broker. This is needed for a completely different purpose (keeping track of whether there are any Brokers with open transactions). &lt;/p&gt;

&lt;p&gt;The issue is separation of concerns. Currently the ManagedRuntime doesn&apos;t really know anything about Brokers or transaction maps. To implement the findTransactionalBroker entirely in ManagedRuntime would introduce a lot of broker-aware code. We could simply have ManagedRuntime know about a Map of Transaction to Object, and do the rest of the processing in AbstractBrokerFactory. This would separate functionality but not completely.&lt;/p&gt;

&lt;p&gt;With this separation, the ManagedRuntime would have a new method Object getByTransactionKey(Object brokerFactory, Map transactional) that returns the entry associated with the current transaction (which it knows how to get) in the Map parameter (Abstract implementation) or the entry associated with the TSR Map using the brokerFactory as the key. This is not completely abstract but pretty close.&lt;/p&gt;

&lt;p&gt;But if we do all that, we should probably look at delegating most of the syncWithManagedTransaction to the ManagedRuntime as well...&lt;/p&gt;</comment>
                            <comment id="12518513" author="pcl" created="Wed, 8 Aug 2007 18:21:58 +0100"  >&lt;p&gt;It looks like the main feature is resolved here, and the issue is open for follow-on work. I&apos;m going to remove the 1.0.0 designation and downgrade the issue to &quot;Major&quot; from &quot;Blocking&quot;.&lt;/p&gt;</comment>
                            <comment id="12518522" author="clr" created="Wed, 8 Aug 2007 18:50:31 +0100"  >&lt;p&gt;This issue is resolved. See &lt;a href=&quot;https://issues.apache.org/jira/browse/OPENJPA-310&quot; title=&quot;Rework ManagedRuntime to make better use of TransactionSynchronizationRegistry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OPENJPA-310&quot;&gt;OPENJPA-310&lt;/a&gt; for more discussion on possible refactoring of the implementation.&lt;/p&gt;</comment>
                            <comment id="12528484" author="mikedd" created="Tue, 18 Sep 2007 19:14:56 +0100"  >&lt;p&gt;Already fixed in 1.0.1. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12375541">OPENJPA-310</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12363140" name="OPENJPA-295.diff.txt" size="12893" author="mikedd" created="Fri, 3 Aug 2007 17:48:00 +0100"/>
                            <attachment id="12363077" name="OPENJPA295.patch" size="5898" author="mprudhom" created="Thu, 2 Aug 2007 18:51:21 +0100"/>
                            <attachment id="12363101" name="openjpa-295.patch" size="11065" author="clr" created="Fri, 3 Aug 2007 05:32:34 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 25 Jul 2007 16:40:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160621</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hyt1jz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>203432</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>