<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:41:57 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-117/OPENJPA-117.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-117] Collection of TransactionListeners registered to a Broker should be available as unmodifiable collection</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-117</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;Currently TransactionListeners can be added/removed to a broker but the list of transaction listeners registered to a particular broker is not available. Such a collection can be made available in read-only mode so a caller can determine whether to add a new listener or not, or whether a particular listener is already registered. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12361581">OPENJPA-117</key>
            <summary>Collection of TransactionListeners registered to a Broker should be available as unmodifiable collection</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="ppoddar@apache.org">Pinaki Poddar</assignee>
                                    <reporter username="ppoddar@apache.org">Pinaki Poddar</reporter>
                        <labels>
                    </labels>
                <created>Tue, 30 Jan 2007 17:44:12 +0000</created>
                <updated>Mon, 5 Feb 2007 18:00:24 +0000</updated>
                                                                            <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12468711" author="pcl" created="Tue, 30 Jan 2007 17:49:10 +0000"  >&lt;p&gt;What&apos;s the use case for this? If someone were to write code that cannot track for itself what it&apos;s done, the code could always add a user object (Broker.putUserObject()).&lt;/p&gt;</comment>
                            <comment id="12468719" author="ppoddar@apache.org" created="Tue, 30 Jan 2007 18:00:05 +0000"  >&lt;p&gt;The use case is the code that intends to register a listener but gets the PersistenceManager/EntityManager from another layer outside of its own control. Then the registerer does not know whether the obtained PM/EM is already carrying a particular listener or not. Currently the internal collection of listener is not a Set, so unconditionally adding a listener results in duplicates. &lt;/p&gt;</comment>
                            <comment id="12468724" author="pcl" created="Tue, 30 Jan 2007 18:10:40 +0000"  >&lt;p&gt;So an alternate approach that would not expose any additional interfaces would be for the code to call Broker.putUserObject() at the same time as it set up the listener, and then check the user object beferehand:&lt;/p&gt;

&lt;p&gt;OpenJPAEntityManager oem = OpenJPAPersistence.cast(em);&lt;br/&gt;
if (oem.getUserObject(MyListener.class) == null) &lt;/p&gt;
{
    TransactionListener tl = new MyListener();
    oem.addTransactionListener(tl);
    oem.putUserObject(MyListener.class, tl);
}</comment>
                            <comment id="12468734" author="awhite" created="Tue, 30 Jan 2007 18:32:11 +0000"  >&lt;p&gt;I don&apos;t think we should encourage use of user objects for tracking state we could trivially expose ourselves.  Most of our APIs allow you to &quot;get&quot; anything you can &quot;set&quot;, so I agree with Pinaki&apos;s approach of exposing the listener collection unless our internal bookkeeping mechanism in this case makes it inefficient for some reason.&lt;/p&gt;</comment>
                            <comment id="12468735" author="pcl" created="Tue, 30 Jan 2007 18:36:55 +0000"  >&lt;p&gt;The problem is that this lets party A get what party B set. So if one bit of code added a particular listener, a different bit of code could then get the listener and remove it. Is this something that we want to make easy for people to do? It seems like different listeners should be relatively isolated from each other.&lt;/p&gt;</comment>
                            <comment id="12468770" author="awhite" created="Tue, 30 Jan 2007 20:13:34 +0000"  >&lt;p&gt;I don&apos;t see why listeners are some special case that require more isolation than all of the other state we expose.  There are tons of things you can do with a broker,etc to screw other users of that broker,etc.  I don&apos;t see how this is unique.&lt;/p&gt;

&lt;p&gt;That said, I also think the proposed use case is weak.  I&apos;d question the quality of an application that had code paths that could result in the same listener being added twice.  Adding listeners should generally either be done as an initialization step or as a temporary step where the listener is removed immediately following a specific action.  It&apos;s hard to imagine a scenario where listeners are added so haphazardly that duplicates could occur.  I&apos;d be interested to hear a more concrete use case.&lt;/p&gt;</comment>
                            <comment id="12469093" author="ppoddar@apache.org" created="Wed, 31 Jan 2007 16:35:15 +0000"  >&lt;p&gt;&amp;gt; Adding listeners should generally either be done as an initialization step&lt;br/&gt;
Of course. The use case that prompted the request is the code that registers listeners do not initialize Persistence/EntityManagers. At least that is what I gathered from the users&apos; input. Did not feel &apos;strongly&apos; about the use case either which reflects in the &apos;minor&apos; priority of the request. &lt;br/&gt;
As an alternative, one may consider a listener mechanism attached to the BrokerFactory itself that will notify creation/closure of managed Brokers. Then a user code that does not explictly control Broker may get a hook during broker initialization/closure.&lt;/p&gt;

&lt;p&gt;Exposing list of listeners does raise the concern about one user removing others listeners &amp;#8211; but isn&apos;t one of the prevailing themes of OpenJPA architecture thrieves upon the users having deep visibility  and customization of its myriad internal features?&lt;/p&gt;</comment>
                            <comment id="12470294" author="clr" created="Mon, 5 Feb 2007 18:00:17 +0000"  >&lt;p&gt;Maybe this case would best be handled by having the TransactionListener itself register for the event.&lt;/p&gt;

&lt;p&gt;I&apos;m assuming that the listener is stateful and is listening on a specific Broker. Then add a method on the TransactionListenerImpl like void listenOn(Broker broker). If it is already listening on the parameter, it returns. Otherwise it registers itself. This can be exended if a listener can listen on multiple Brokers. In that case, the listener can manage a Set of Brokers that it is listening on.&lt;/p&gt;

&lt;p&gt;I&apos;m not so concerned about different users of a Broker getting information about other users. As Abe points out, all the actors who share a Broker are already intimately connected, and any one can cause damage. So it&apos;s not about isolation, it&apos;s more about separation of concerns. In this case, why should an actor care if a listener is already listening? The listener can be active making sure it&apos;s not registered multiple times with the same Broker.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 30 Jan 2007 17:49:10 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160454</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hz7jtr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>288182</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>