<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sun May 17 04:31:37 UTC 2015

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/OPENJPA-1613/OPENJPA-1613.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[OPENJPA-1613] Exception thrown when enhancing a (property access) class that has an abstract @MappedSuperclass with no annotated properties</title>
                <link>https://issues.apache.org/jira/browse/OPENJPA-1613</link>
                <project id="12310351" key="OPENJPA">OpenJPA</project>
                    <description>&lt;p&gt;If you have a class (using property access) that has an abstract @MappedSuperclass that happens to have no annotated methods, you get the following exception when enhancing:&lt;/p&gt;

&lt;p&gt;org.apache.openjpa.util.MetaDataException: &quot;implicit property access&quot; for class &quot;org.apache.openjpa.persistence.simple.SubclassPerson&quot; is not consistent with &quot;implicit field access&quot; used by its persistent superclass &quot;org.apache.openjpa.persistence.simple.AbstractSuperclass&quot;.  All persistent classes in an inheritance hierarchy must use a single implicit field or property based access style or explicitly declare an access style.&lt;/p&gt;

&lt;p&gt;Presumably the enhancer is deciding incorrectly that the superclass is using field access. A workaround is to annotate the superclass with @Access(AccessType.PROPERTY)  so the enhancer doesn&apos;t make this assumption, but that is not JPA 1.0 backwards compatible.&lt;/p&gt;

&lt;p&gt;This did not occur in any of the OpenJPA 1.* versions&lt;/p&gt;

</description>
                <environment></environment>
        <key id="12461329">OPENJPA-1613</key>
            <summary>Exception thrown when enhancing a (property access) class that has an abstract @MappedSuperclass with no annotated properties</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="techhusky">Jeremy Bauer</assignee>
                                    <reporter username="sdroscher">Simon Droscher</reporter>
                        <labels>
                    </labels>
                <created>Wed, 7 Apr 2010 00:28:33 +0100</created>
                <updated>Wed, 12 Jan 2011 22:38:14 +0000</updated>
                            <resolved>Wed, 12 Jan 2011 22:38:14 +0000</resolved>
                                    <version>2.0.0-beta2</version>
                    <version>2.0.0-beta3</version>
                                    <fixVersion>2.1.0</fixVersion>
                                    <component>kernel</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12854253" author="sdroscher" created="Wed, 7 Apr 2010 00:29:49 +0100"  >&lt;p&gt;Attached a test case that demonstrates the problem&lt;/p&gt;</comment>
                            <comment id="12856082" author="drwoods" created="Mon, 12 Apr 2010 18:57:37 +0100"  >&lt;p&gt;For 1.0 (and 2.0) apps, you can use a orm.xml to specify the access-type as an attribute on the entity -&lt;br/&gt;
&amp;lt;xsd:simpleType name=&quot;access-type&quot;&amp;gt; &amp;lt;xsd:annotation&amp;gt;&lt;br/&gt;
&amp;lt;xsd:documentation&amp;gt;&lt;br/&gt;
This element determines how the persistence provider accesses the state of an entity or embedded object.&lt;br/&gt;
&amp;lt;/xsd:documentation&amp;gt; &amp;lt;/xsd:annotation&amp;gt; &amp;lt;xsd:restriction base=&quot;xsd:token&quot;&amp;gt;&lt;br/&gt;
&amp;lt;xsd:enumeration value=&quot;PROPERTY&quot;/&amp;gt;&lt;br/&gt;
&amp;lt;xsd:enumeration value=&quot;FIELD&quot;/&amp;gt; &amp;lt;/xsd:restriction&amp;gt;&lt;br/&gt;
&amp;lt;/xsd:simpleType&amp;gt;&lt;/p&gt;</comment>
                            <comment id="12856155" author="drwoods" created="Mon, 12 Apr 2010 21:35:52 +0100"  >&lt;p&gt;Well, since you marked the methods with @Transient, the PersistenceMetaDataDeafults.determineImplicitAccessType() will return ACCESS_UNKNOWN, as those methods are removed from consideration, which causes PersistenceMetaDataDeafults.determineAccessType() to call getDeafultAccessType() which returns the default of ACCESS_FIELD.&lt;/p&gt;</comment>
                            <comment id="12857473" author="drwoods" created="Thu, 15 Apr 2010 19:31:09 +0100"  >&lt;p&gt;From sect. 2.3.1 of the JPA 2.0 spec -&lt;br/&gt;
...&lt;br/&gt;
All such classes in the entity hierarchy whose access type is defaulted in this way must be consistent in their placement of annotations on either fields or properties, such that a single, consistent default access type applies within the hierarchy. Any embeddable classes used by such classes will have the same access type as the default access type of the hierarchy unless the Access annotation is specified as defined below.&lt;/p&gt;

&lt;p&gt;It is an error if a default access type cannot be determined and an access type is not explicitly specified by means of annotations or the XML descriptor. The behavior of applications that mix the placement of annotations on fields and properties within an entity hierarchy without explicitly specifying the Access annotation is undefined.&lt;/p&gt;

&lt;p&gt;So, in your case, the method is marked as Transient, so it is ignored.  The variable is private, which will not be persistance in the 2.0 spec, so it is ignored.  Therefore, the above &quot;It is an error if a default access type cannot be determined&quot; comes into play here, since the MappedSuperclass doesn&apos;t provide an explicit AccessType. &lt;/p&gt;

&lt;p&gt;One could argue though, if we should have thrown an exception, instead of defaulting to FIELD (which is the old OpenJPA 1.x behavior, as Private variables would be persisted.)&lt;/p&gt;</comment>
                            <comment id="12858578" author="drwoods" created="Mon, 19 Apr 2010 17:11:37 +0100"  >&lt;p&gt;updated tests&lt;/p&gt;</comment>
                            <comment id="12858579" author="drwoods" created="Mon, 19 Apr 2010 17:12:31 +0100"  >&lt;p&gt;Some code changes that I tried to make, which broke some existing junits, so DO NOT commit this AS-IS.&lt;/p&gt;</comment>
                            <comment id="12859079" author="techhusky" created="Tue, 20 Apr 2010 22:52:33 +0100"  >&lt;p&gt;I ran some comparisons between OpenJPA 1.2.2 and 2.0.x.  Version 1.2.2 is picking up the @javax.persistence.Transient annotation on the property in AbstractSuperclass and using this annotation to trigger property access by default.  Based on the JPA 1.0 spec (and carried forward to the 2.0 spec):&lt;/p&gt;

&lt;p&gt;&amp;lt;jpa 1.0 - section 2.1.1&amp;gt;&lt;br/&gt;
When annotations are used, the placement of the mapping annotations on either the persistent fields or persistent properties of the entity class specifies the access type as being either field- or property-based access respectively.&lt;br/&gt;
&amp;lt;/jpa 1.0&amp;gt;&lt;/p&gt;

&lt;p&gt;As you can see the spec uses &quot;annotations&quot; freely in this context.  Can this be inferred to include all javax.persistence annotations, including Transient?  If so, it would follow that this mapped superclass definition would/should result in an ambiguous access type exception:  (which it does in OpenJPA 1.2.2 - not currently in OpenJPA 2.0.x - 2.0.x defaults to field access)&lt;/p&gt;

&lt;p&gt;@MappedSuperclass&lt;br/&gt;
class MySuper {&lt;/p&gt;

&lt;p&gt; @Transient&lt;br/&gt;
  private String name;&lt;/p&gt;

&lt;p&gt;  @Transient&lt;br/&gt;
  private Address getAddress() &lt;/p&gt;
{ ... }&lt;br/&gt;
  private void setAddress(Address a) { ... }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;As Donald mentioned, OpenJPA 2.x.x currently ignores fields and methods tagged with the @Transient annotation when calculating the default access type.  Should OpenJPA take @Transient into account when deciding which access type to choose?  It is a very odd case where this annotation alone would be the deciding factor.  Regarding @Transient the 1.0 spec simply states:&lt;/p&gt;

&lt;p&gt;&amp;lt;jpa 1.0 - section 2.1.1&amp;gt;&lt;br/&gt;
All non-transient instance variables that are not annotated with the Transient annotation are persistent.&lt;br/&gt;
and&lt;br/&gt;
All properties not annotated with the Transient annotation are persistent.&lt;br/&gt;
&amp;lt;/jpa 1.0 -section 2.1.1&amp;gt;&lt;/p&gt;

&lt;p&gt;As Donald also points out, the 2.0 spec adds:&lt;/p&gt;

&lt;p&gt;&amp;lt;jpa 2.0 - section 2.3.1&amp;gt;&lt;br/&gt;
It is an error if a default access type cannot be determined and an access type is not explicitly specified by means of annotations or the XML descriptor. The behavior of applications that mix the placement of annotations on fields and properties within an entity hierarchy without explicitly specifying the Access annotation is undefined. &lt;br/&gt;
&amp;lt;/jpa 2.0 - section 2.3.1&amp;gt;&lt;/p&gt;

&lt;p&gt;Looking at this specific case - it seems odd that @MappedSuperclass is used on an class with no persistent state.  If that is true, you could eliminate @MappedSuperclass from AbstractSuperclass.  Extending a non-persistent Java class is possible with OpenJPA.&lt;/p&gt;

&lt;p&gt;Regardless, based on the verbiage in the spec and given the behavior of prior releases of OpenJPA, it would seem that using @Transient to detect the default access type is what OpenJPA should do.  Opinions, please!&lt;/p&gt;</comment>
                            <comment id="12859385" author="drwoods" created="Wed, 21 Apr 2010 16:11:07 +0100"  >&lt;p&gt;Agree.  In this case where AbstractSuperclass.java only has the @Transient on a getter and no parent classes to examine, then we&apos;d use the old behavior and set the access type as property.&lt;br/&gt;
If we do this, then I&apos;d also like to see a WARN message logged, letting the user know we&apos;re setting the access type based on @Transient and they should really set an explicit type instead (as this behavior may not be portable and could change in future Specs.)  Also, we should add a WARN when getDefaultAcessType() is called and we end up defaulting to ACCESS_FIELD, with the same type of warning message.&lt;/p&gt;</comment>
                            <comment id="12859395" author="techhusky" created="Wed, 21 Apr 2010 16:32:49 +0100"  >&lt;p&gt;Thanks, Donald.  I appreciate the feedback.  Adding warnings for these conditions is a great idea.&lt;/p&gt;</comment>
                            <comment id="12859872" author="techhusky" created="Thu, 22 Apr 2010 17:34:05 +0100"  >&lt;p&gt;Committed a fix under rev 936930 which included a slightly modified version of Simon&apos;s testcase.&lt;/p&gt;

&lt;p&gt;As of this commit, OpenJPA will now take @javax.persistence.Transient fields and properties into consideration when making a default access determination.  This is consistent with the JPA specifications and OpenJPA 1.x behavior.  However, OpenJPA 2.x does not completely mimic 1.x behavior regarding persistent properties.  The provided test application exposed another inconsistency between OpenJPA 1.x and 2.x.  OpenJPA 2.x does more stringent verification on persistent properties.  Per spec,&lt;/p&gt;

&lt;p&gt;&amp;lt;jpa 2.0 spec&amp;gt;&lt;br/&gt;
In this case, for every persistent property property of type T of the entity, there is a getter method, get-&lt;br/&gt;
Property, and setter method setProperty. For boolean properties, isProperty may be used as an alternative&lt;br/&gt;
name for the getter method.&lt;br/&gt;
For single-valued persistent properties, these method signatures are:&lt;br/&gt;
&#8226; T getProperty()&lt;br/&gt;
&#8226; void setProperty(T t)&lt;br/&gt;
&amp;lt;/jpa 2.0 spec&amp;gt;&lt;/p&gt;

&lt;p&gt;The supplied test application patch did not have a matching setter for the getter.  OpenJPA 1.x took the @Transient getter into account when making the default access determination - but dumped this message regarding the property:&lt;/p&gt;

&lt;p&gt;&amp;lt;OpenJPA 1.x&amp;gt;&lt;br/&gt;
No setter was found for method someProperty in type test.AbstractSuperclass while searching for persistent properties. This method will be ignored. If you intended for this to be persistent, please add a corresponding setter, or switch to field access for this type hierarchy.&lt;br/&gt;
&amp;lt;/OpenJPA 1.x&amp;gt;&lt;/p&gt;

&lt;p&gt;This is an inconsistency in the 1.x code base.  I think a property should only be considered in the access calculation only if the property is/can be persistent.  As of this commit, OpenJPA 2.0 will only take the @Transient property into the default access calculation if the property is persistent (has a matching getter/setter).  Thus, I made a small change to the test code to ensure the @Transient property is in the format defined by the spec.&lt;/p&gt;</comment>
                            <comment id="12859883" author="techhusky" created="Thu, 22 Apr 2010 17:48:05 +0100"  >&lt;p&gt;Forgot to mention - I added code to log a trace level message when the access type cannot be determined and default access is used.  I had this as a warning, but due to the sheer quantity of entities in the jUnit bucket that use default access, the added logging was slowing down the test bucket and bloating the logs.&lt;/p&gt;</comment>
                            <comment id="12980979" author="mikedd" created="Wed, 12 Jan 2011 22:38:14 +0000"  >&lt;p&gt;Last code change was in April. If there&apos;s more to be done we&apos;ll open another issue. &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12442197" name="OPENJPA-1613-failing-code-changes.diff" size="5890" author="drwoods" created="Mon, 19 Apr 2010 17:12:31 +0100"/>
                            <attachment id="12442196" name="OPENJPA-1613-tests.diff" size="8864" author="drwoods" created="Mon, 19 Apr 2010 17:11:36 +0100"/>
                            <attachment id="12440971" name="abstract-subclass.patch" size="6020" author="sdroscher" created="Wed, 7 Apr 2010 00:29:49 +0100"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 12 Apr 2010 17:57:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>161872</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2|hysnsv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>201204</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>